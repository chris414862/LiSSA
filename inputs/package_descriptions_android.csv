android,annotation,0,
android,accounts,6,
android,accessibilityservice,12,"The classes in this package are used for development of accessibility service that
   provide alternative or augmented feedback to the user.
  
   An  AccessibilityService  runs in the background and
   receives callbacks by the system when  AccessibilityEvent s
   are fired. Such events denote some state transition in the user interface for example the
   focus has changed a button has been clicked etc. Such a service can optionally request the
   capability for querying the content of the active window. Development of an accessibility
   service requires extends this class and implements its abstract methods.
  
   An  AccessibilityServiceInfo  describes an
    AccessibilityService . The system notifies an
   AccessibilityService for  AccessibilityEvent s
   according to the information encapsulated in this class."
android,app.assist,4,
android,animation,21,"These classes provide functionality for the property animation system which allows you
 to animate object properties of any type.  int   float  and hexadecimal
 color values are supported by default. You can animate any other type by telling the system how
 to calculate the values for that given type with a custom  TypeEvaluator .
  For more information see the
  Animation  guide. 
 You can set many different types of interpolators (contained in  android.view.animation )
 specify  keyframes  or group animations to play sequentially
 or simultaneously (with  AnimatorSet ) to further control your animation
 behaviors."
android,app.admin,14,"Provides device administration features at the system level allowing you to create
 security-aware applications that are useful in enterprise settings in which IT professionals
 require rich control over employee devices. For more information see the
  Device Administration 
 guide."
android,app.role,1,
android,android,26,"Contains resource classes used by applications included in the platform and defines application
 permissions for system features. You can use some resources directly from these  R  classes in your own
 applications but you should generally use only resources that you've provided directly in your
 application in order to provide a cohesive application package that has no external dependencies.
 In particular you should not use drawable resources from the  android  package because they
 may change between platform versions causing unforeseen conflicts with your design. Typically
  styles  are the only resources you should use directly from these
 resources. For information about using resources see the  Application Resources  developer guide."
android,app.job,8,
android,app.backup,10,"Contains the backup and restore functionality available to
 applications. If a user wipes the data on their device or upgrades to a new Android-powered
 device all applications that have enabled backup can restore the user's previous data when the
 application is reinstalled. For more information see the  Data Backup  guide. All backup and restore operations are controlled by the  BackupManager . Each application that would
 like to enable backup and preserve its data on remote storage must implement a
 backup agent. A backup agent can be built by extending either  BackupAgent 
 or  BackupAgentHelper . The  BackupAgentHelper  class provides a wrapper around  BackupAgent  that simplifies the procedures to implement a backup agent by
 employing backup helpers such as  SharedPreferencesBackupHelper  and
  FileBackupHelper . The backup APIs let applications: Perform backup of arbitrary data to remote storage Easily perform backup of  SharedPreferences  and files Restore the data saved to remote storage"
android,app.slice,7,
android,appwidget,5,"Contains the components necessary to create ""app widgets"" which users can embed in other
 applications (such as the home screen) to quickly access application data and services without
 launching a new activity. For more information see the
  App Widgets  guide. The behavior of an app widget is published by an ""app widget provider.""  An ""app widget host"" is
 a component that can contain app widgets (such as the Home screen). Any application can publish app widgets (as an app widget provider).  All an application needs to
 do to publish an app widget is
 provide a  BroadcastReceiver  that receives the  ACTION_APPWIDGET_UPDATE  intent
 and provide some metadata about the app widget.  Android provides the
  AppWidgetProvider  class which extends  BroadcastReceiver  as a convenience class to define the app widget behavior and aid
 in handling the broadcasts. App widget hosts are the containers in which widgets can be placed.  Most of the look and feel
 details are left up to the widget hosts.  For example the home screen has one way of viewing
 widgets but the lock screen could also contain widgets and it would have a different way of
 adding removing and otherwise managing widgets. For information about implementing an app widget host see the  AppWidgetHost  class."
android,app.usage,13,
android,companion,10,
android,bluetooth.le,20,
android,bluetooth,27,"Provides classes that manage Bluetooth functionality such as scanning for
 devices connecting with devices and managing data transfer between devices.
 The Bluetooth API supports both ""Classic Bluetooth"" and Bluetooth Low Energy. For more information about Classic Bluetooth see the
  Bluetooth  guide.
 For more information about Bluetooth Low Energy see the
  
 Bluetooth Low Energy  (BLE) guide. The Bluetooth APIs let applications: Scan for other Bluetooth devices (including BLE devices). Query the local Bluetooth adapter for paired Bluetooth devices. Establish RFCOMM channels/sockets. Connect to specified sockets on other devices. Transfer data to and from other devices. Communicate with BLE devices such as proximity sensors heart rate
     monitors fitness devices and so on. Act as a GATT client or a GATT server (BLE). 
 To perform Bluetooth communication using these APIs an application must
 declare the  BLUETOOTH  permission. Some
 additional functionality such as requesting device discovery
 also requires the  BLUETOOTH_ADMIN 
 permission.
  Note: 
 Not all Android-powered devices provide Bluetooth functionality."
android,content.res,12,"Contains classes for accessing application resources
 such as raw asset files colors drawables media or other files
 in the package plus important device configuration details
 (orientation input types etc.) that affect how the application may behave. For more information see the  Application Resources  guide."
android,database.sqlite,10,"Applications use these classes to manage private databases. If creating a
 content provider you will probably have to use these classes to create and
 manage your own database to store content. See  Content Providers 
 to learn the conventions for implementing a content provider. If you are working
 with data sent to you by a provider you do not use these SQLite classes but
 instead use the generic  android.database  classes.

  The Android SDK and Android emulators both include the
  sqlite3  command-line
 database tool. On your development machine run the tool from the
  platform-tools/  folder of your SDK. On the emulator run the tool
 with adb shell for example  adb -e shell sqlite3 .

  The version of SQLite depends on the version of Android. See the following table:
  Android API SQLite Version API 27 3.19 API 26 3.18 API 24 3.9 API 21 3.8 API 11 3.7 API 8 3.6 API 3 3.5 API 1 3.4 Some device manufacturers include different versions of SQLite on their devices.
   There are two ways to programmatically determine the version number.

  If available use the sqlite3 tool for example:
      adb -e shell sqlite3 --version . Create and query an in-memory database as shown in the following code sample:
      
     String query = ""select sqlite_version() AS sqlite_version"";
     SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase("":memory:"" null);
     Cursor cursor = db.rawQuery(query null);
     String sqliteVersion = """";
     if (cursor.moveToNext()) {
         sqliteVersion = cursor.getString(0);
     }"
android,database,19,"If you need to manage data in a private database use the  android.database.sqlite  classes. These classes are used to manage the  Cursor  object returned from a content provider query. Databases
 are usually created and opened with  openOrCreateDatabase(String int SQLiteDatabase.CursorFactory) 
 To make requests through
 content providers you can use the  content.ContentResolver  class.
  All databases are stored on the device in  /data/data/<package_name>/databases"
android,content.pm,42,"Contains classes for accessing information about an
 application package including information about its activities
 permissions services signatures and providers. Most of the information about an application package is defined by its manifest file. For
 more information see the  AndroidManifest.xml File 
 documentation."
android,gesture,10,
android,drm,18,"Provides classes for managing DRM content and determining the capabilities of DRM plugins
 (agents). Common uses of the DRM API include: Determining which DRM plug-ins (agents) are installed on a device. Retrieving information about specific plug-ins such as the MIME types and file suffixes
   they support. Registering a user or a device with an online DRM service. Retrieving license constraints for rights-protected content. Checking whether a user has the proper rights to play or use rights-protected
   content. Associating rights-protected content with its license so you can use the
    MediaPlayer  API to play the content."
android,graphics.drawable.shapes,6,
android,content,52,"Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources ."
android,graphics.fonts,7,
android,graphics.pdf,6,
android,graphics.text,6,
android,graphics.drawable,31,"Provides classes to manage a variety of visual elements that are intended for
 display only such as bitmaps and gradients. These elements are often used
 by widgets as background images or simply as indicators (for example a volume
 level indicator). You can create most of these drawables using XML as described in  Drawable Resources ."
android,hardware.biometrics,6,
android,hardware,19,"Provides support for hardware features such as the camera and other sensors. Be aware that
 not all Android-powered devices support all hardware features so you should declare hardware
 that your application requires using the  <uses-feature>  manifest element."
android,app,122,"Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User ."
android,hardware.display,3,
android,hardware.camera2.params,15,
android,hardware.input,1,
android,icu.lang,6,
android,hardware.usb,9,"Provides support to communicate with USB hardware peripherals that are connected to
 Android-powered devices. For more information see the
  USB  guide. Use  UsbManager  to access the state of the USB and to
 communicate with connected hardware peripherals. Use  UsbDevice  to
 communicate with the hardware peripheral if the Android-powered device is acting as the USB host.
 Use  UsbAccessory  if the peripheral is acting as the USB host."
android,hardware.camera2,20,"The android.hardware.camera2 package provides an interface to
 individual camera devices connected to an Android device. It replaces
 the deprecated  Camera  class. This package models a camera device as a pipeline which takes in
 input requests for capturing a single frame captures the single image
 per the request and then outputs one capture result metadata packet
 plus a set of output image buffers for the request. The requests are
 processed in-order and multiple requests can be in flight at
 once. Since the camera device is a pipeline with multiple stages
 having multiple requests in flight is required to maintain full
 framerate on most Android devices. To enumerate query and open available camera devices obtain a
  CameraManager  instance. Individual  CameraDevices  provide a set of static property information that
 describes the hardware device and the available settings and output
 parameters for the device. This information is provided through the
  CameraCharacteristics  object and is
 available through  getCameraCharacteristics(String) To capture or stream images from a camera device the application
 must first create a  camera capture session 
 with a set of output Surfaces for use with the camera device with
  createCaptureSession(SessionConfiguration) . Each
 Surface has to be pre-configured with an  appropriate
 size and format  (if applicable) to match the sizes and formats
 available from the camera device. A target Surface can be obtained
 from a variety of classes including  SurfaceView 
  SurfaceTexture  via
  Surface(SurfaceTexture) 
  MediaCodec   MediaRecorder 
  Allocation  and  ImageReader .
  Generally camera preview images are sent to  SurfaceView  or  TextureView  (via its
  SurfaceTexture ). Capture of JPEG images or
 RAW buffers for  DngCreator  can be
 done with  ImageReader  with the  JPEG  and  RAW_SENSOR  formats.  Application-driven
 processing of camera data in RenderScript OpenGL ES or directly in
 managed or native code is best done through  Allocation  with a YUV  Type   SurfaceTexture 
 and  ImageReader  with a  YUV_420_888  format respectively. The application then needs to construct a  CaptureRequest  which defines all the
 capture parameters needed by a camera device to capture a single
 image. The request also lists which of the configured output Surfaces
 should be used as targets for this capture. The CameraDevice has a
  factory method  for creating a  request builder  for a
 given use case which is optimized for the Android device the
 application is running on. Once the request has been set up it can be handed to the active
 capture session either for a one-shot  capture  or for
 an endlessly  repeating  use. Both methods also have a variant that accepts a list
 of requests to use as a burst capture / repeating burst. Repeating
 requests have a lower priority than captures so a request submitted
 through  capture()  while there's a repeating request
 configured will be captured before any new instances of the currently
 repeating (burst) capture will begin capture. After processing a request the camera device will produce a  TotalCaptureResult  object which contains
 information about the state of the camera device at time of capture
 and the final settings used. These may vary somewhat from the request
 if rounding or resolving contradictory parameters was necessary. The
 camera device will also send a frame of image data into each of the
 output  Surfaces  included in the request. These are produced
 asynchronously relative to the output CaptureResult sometimes
 substantially later."
android,icu.math,2,
android,hardware.fingerprint,4,
android,inputmethodservice,12,
android,graphics,70,
android,location,17,"Contains the framework API classes that define Android location-based and
 	related services. This API is not the recommended method for accessing Android location. 
 The
  Google Location Services API 
 part of Google Play services is the preferred way to add location-awareness to
 your app. It offers a simpler API higher accuracy low-power geofencing and
 more. If you are currently using the android.location API you are strongly
 encouraged to switch to the Google Location Services API as soon as
 possible.
  
 To learn more about the Google Location Services API see the
  Location API overview ."
android,media.browse,5,
android,icu.util,29,
android,media.effect,3,"Provides classes that allow you to apply a variety of visual effects to images and
 videos. For example you can easily fix red-eye convert an image to grayscale
 adjust brightness adjust saturation rotate an image apply a fisheye effect and much more. The
 system performs all effects processing on the GPU to obtain maximum performance. For maximum performance effects are applied directly to OpenGL textures so your application
 must have a valid OpenGL context before it can use the effects APIs. The textures to which you apply
 effects may be from bitmaps videos or even the camera. However there are certain restrictions that
 textures must meet: They must be bound to a  GL_TEXTURE_2D  texture image They must contain at least one mipmap level An  Effect  object defines a single media effect that you can apply to
 an image frame. The basic workflow to create an  Effect  is: Call  EffectContext.createWithCurrentGlContext()  from your OpenGL ES 2.0 context. Use the returned  EffectContext  to call  EffectContext.getFactory()  which returns an instance
 of  EffectFactory . Call  createEffect()  passing it an
 effect name from  EffectFactory  such as  EFFECT_FISHEYE  or  EFFECT_VIGNETTE . You can adjust an effect’s parameters by calling  setParameter()  and passing a parameter name and parameter value. Each type of effect accepts
 different parameters which are documented with the effect name. For example  EFFECT_FISHEYE  has one parameter for the  scale  of the
 distortion. To apply an effect on a texture call  apply()  on the
  Effect  and pass in the input texture its width and height and the output
 texture. The input texture  must be bound to a  GL_TEXTURE_2D  texture
 image (usually done by calling the  glTexImage2D() 
 function). You may provide multiple mipmap levels. If the output texture has not been bound to a
 texture image it will be automatically bound by the effect as a  GL_TEXTURE_2D  and with one mipmap level (0) which will have the same
 size as the input. Note:  All effects listed in  EffectFactory  are guaranteed to be supported. However some additional effects
 available from external libraries are not supported by all devices so you must first check if the
 desired effect from the external library is supported by calling  isEffectSupported() ."
android,media.projection,3,
android,media.midi,12,"Provides classes for sending and receiving messages using the standard MIDI
 event protocol over USB Bluetooth LE and virtual (inter-app) transports.
  Overview"
android,media.session,14,
android,media.audiofx,30,
android,icu.text,67,
android,mtp,7,"Provides APIs that let you interact directly with connected cameras and other devices using the
 PTP (Picture Transfer Protocol) subset of the MTP (Media Transfer Protocol) specification. Your
 application can receive notifications when devices are attached and removed manage files and
 storage on those devices and transfer files and metadata from the devices."
android,net.nsd,2,
android,media.tv,24,
android,net.rtp,4,
android,net.http,5,
android,net.ssl,2,
android,net.sip,9,
android,net.wifi.hotspot2,2,
android,net.wifi.hotspot2.omadm,1,
android,net.wifi.hotspot2.pps,5,
android,net.wifi.aware,18,"Provides classes which allow applications to use Wi-Fi Aware to discover peers and create
     connections to them. Using the Wi-Fi Aware APIs applications can advertise services discover peers which are
     advertising services and connect to them.
     Wi-Fi Aware is independent of Wi-Fi infrastructure (i.e. a device may or may
     not be associated with an AP concurrent to using Wi-Fi Aware).  The primary entry point to Wi-Fi Aware capabilities is the
      WifiAwareManager  class which is acquired by calling
      Context.getSystemService(Context.WIFI_AWARE_SERVICE) Some APIs may require the following user permissions: ACCESS_WIFI_STATE CHANGE_WIFI_STATE ACCESS_FINE_LOCATION Note:  Not all Android-powered devices support Wi-Fi Aware
     functionality.
     If your application only works with Wi-Fi Aware (i.e. it should only be installed on devices which
     support Wi-Fi Aware) declare so with a  <uses-feature> 
     element in the manifest file: 
 <manifest ...>
     <uses-feature android:name=""android.hardware.wifi.aware"" />
     ...
 </manifest>
  Alternatively if you application does not require Wi-Fi Aware but can take advantage of it if
     available you can perform
     the check at run-time in your code using  hasSystemFeature(String)  with  FEATURE_WIFI_AWARE : 
     getPackageManager().hasSystemFeature(PackageManager.FEATURE_WIFI_AWARE)"
android,net,42,
android,net.wifi,24,"Provides classes to manage Wi-Fi functionality on the device. The Wi-Fi APIs provide a means by which applications can communicate
 with the lower-level wireless stack that provides Wi-Fi network access. Almost all
 information from the device supplicant is available including the connected network's
 link speed IP address negotiation state and more plus information about other
 networks that are available. Some other API features include the ability to
 scan add save terminate and initiate Wi-Fi connections. Some APIs may require the following user permissions: ACCESS_WIFI_STATE CHANGE_WIFI_STATE CHANGE_WIFI_MULTICAST_STATE Note:  Not all Android-powered devices provide Wi-Fi functionality.
 If your application uses Wi-Fi declare so with a  <uses-feature> 
 element in the manifest file: 
 <manifest ...>
     <uses-feature android:name=""android.hardware.wifi"" />
     ...
 </manifest>"
android,net.wifi.p2p.nsd,6,
android,net.wifi.p2p,8,"Provides classes to create peer-to-peer (P2P) connections with Wi-Fi Direct. Using these APIs you can discover and connect to other devices when each
 device supports Wi-Fi Direct then communicate over a speedy connection across distances much longer
 than a Bluetooth connection. The primary class you need to work with is  WifiP2pManager  which you can acquire by calling  getSystemService(WIFI_P2P_SERVICE) . The  WifiP2pManager  includes APIs that allow you to: Initialize your application for P2P connections by calling  initialize() Discover nearby devices by calling  discoverPeers() Start a P2P connection by calling  connect() And more Several other interfaces and classes are necessary as well such as: The  WifiP2pManager.ActionListener  interface allows you to receive
 callbacks when an operation such as discovering peers or connecting to them succeeds or fails. WifiP2pManager.PeerListListener  interface allows you to receive
 information about discovered peers. The callback provides a  WifiP2pDeviceList  from which you can retrieve a  WifiP2pDevice  object for each device within range and get information such as
 the device name address device type the WPS configurations the device supports and more. The  WifiP2pManager.GroupInfoListener  interface allows you to
 receive information about a P2P group. The callback provides a  WifiP2pGroup  object which provides group information such as the owner the
 network name and passphrase. WifiP2pManager.ConnectionInfoListener  interface allows you to
 receive information about the current connection. The callback provides a  WifiP2pInfo  object which has information such as whether a group has been
 formed and who is the group owner. In order to use the Wi-Fi P2P APIs your app must request the following user permissions: ACCESS_WIFI_STATE CHANGE_WIFI_STATE INTERNET  (although your app doesn’t technically connect
 to the Internet communicating to Wi-Fi Direct peers with standard java sockets requires Internet
 permission). For example code see the  Wi-Fi
 Direct Demo  sample application. Note:  Not all Android-powered devices support Wi-Fi
 Direct. If your application uses Wi-Fi Direct declare so with a  <uses-feature> 
 element in the manifest file: 
 <manifest ...>
     <uses-feature android:name=""android.hardware.wifi.direct"" />
     ...
 </manifest>"
android,net.wifi.rtt,7,"Provides classes which allow applications to use Wi-Fi RTT (IEEE 802.11mc) to measure distance
     to supporting Access Points and peer devices. The primary entry point to Wi-Fi RTT capabilities is the
      WifiRttManager  class which is acquired by calling
      Context.getSystemService(Context.WIFI_RTT_RANGING_SERVICE) Some APIs may require the following user permissions: ACCESS_WIFI_STATE CHANGE_WIFI_STATE ACCESS_FINE_LOCATION Usage of the API is also gated by the device's Location Mode: whether it permits Wi-Fi based
 location to be queried. Note:  Not all Android-powered devices support Wi-Fi RTT
     functionality.
     If your application only works with Wi-Fi RTT (i.e. it should only be installed on devices which
     support Wi-Fi RTT) declare so with a  <uses-feature> 
     element in the manifest file: 
 <manifest ...>
     <uses-feature android:name=""android.hardware.wifi.rtt"" />
     ...
 </manifest>
  Alternatively if your application does not require Wi-Fi RTT but can take advantage of it if
     available you can perform
     the check at run-time in your code using  hasSystemFeature(String)  with  FEATURE_WIFI_RTT : 
     getPackageManager().hasSystemFeature(PackageManager.FEATURE_WIFI_RTT)"
android,nfc,6,"Provides access to Near Field Communication (NFC) functionality allowing applications to read
 NDEF message in NFC tags. A ""tag"" may actually be another device that appears as a tag. For more information see the
  Near Field Communication  guide. Here's a summary of the classes: NfcManager This is the high level manager used to obtain this device's  NfcAdapter . You can
 acquire an instance using  getSystemService(Class ) . NfcAdapter This represents the device's NFC adapter which is your entry-point to performing NFC
 operations. You can acquire an instance with  getDefaultAdapter()  or
  getDefaultAdapter(android.content.Context) . NdefMessage Represents an NDEF data message which is the standard format in which ""records""
 carrying data are transmitted between devices and tags. Your application can receive these
 messages from an  ACTION_TAG_DISCOVERED  intent. NdefRecord Represents a record which is delivered in a  NdefMessage  and describes the
 type of data being shared and carries the data itself. Note: 
 Not all Android-powered devices provide NFC functionality."
android,nfc.cardemulation,5,
android,nfc.tech,10,"These classes provide access to a tag technology's features which vary by the type
 of tag that is scanned. A scanned tag can support multiple technologies and you can find
 out what they are by calling  getTechList() . For more information on dealing with tag technologies and handling the ones that you care about see
  The Tag Dispatch System .
 The  TagTechnology  interface provides an overview of the
 supported technologies."
android,os.health,8,"Applications running in the background are responsible for a significant amount
 of battery usage on a typical android device. There are several things that
 applications can do in order to reduce their impact. For example by using
  JobScheduler  an application does not need
 to independently monitor whether the network is available whether the device is
 plugged in etc.  In addition to being simpler to use the application's
 services are only started when the required conditions have been met.  But even
 when using the appropriate helper APIs applications still can reduce their
 footprint. This package provides more insight into what is going on behind the
 scenes when an application is running.
  
 Application data is tracked by which user id (uid) is using particular
 resources. A snapshot of an application's measurements can be taken with the
  SystemHealth.takeMyUidSnapshot() 
 method. The  HealthStats  object returned contains the
 statistics.
  HealthStats 
 In order to be returned efficiently the  HealthStats 
 class uses a set of int keys to identify the data returned. The
  UidHealthStats   PidHealthStats 
  PackageHealthStats    ProcessHealthStats 
 and  ServiceHealthStats  classes provide those constants.
 Each  HealthStats  object will be associated with
 exactly one of those classes. The object returned from
  SystemHealth.takeMyUidSnapshot() 
 will be using the  UidHealthStats  keys as it contains all
 of the data available for that uid."
android,os.storage,3,"Contains classes for the system storage service which manages binary asset filesystems
 known as Opaque Binary Blobs (OBBs)."
android,os.strictmode,20,
android,opengl,28,"Provides an OpenGL ES static interface and utilities. For more information about how to use OpenGL read the
  OpenGL  developer guide."
android,preference,17,
android,print.pdf,1,
android,printservice,5,"Provides classes for implementing print services. Print services are plug-in components
 that know how to talk to printers via some standard protocols. These services serve as a
 bridge between the system and the printers. Hence the printer and print protocol specific
 implementation is factored out of the system and can be independently developed and updated.
  
 A print service implementation should extend  PrintService 
 and implement its abstract methods. Also the print service has to follow the contract for
 managing  PrintJob s.
  
 The system is responsible for starting and stopping a print service depending on whether
 there are active print jobs for the printers managed by the service. The print service
 should also perform printer discovery in a timely fashion to ensure good user experience.
 The interaction between the system and the print service during printer discovery is
 encapsulated by a  PrinterDiscoverySession  instance created
 by the print service when requested by the system."
android,media,139,"The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager )."
android,sax,2,
android,print,21,"Provides classes for implementing print support in applications and also contains all
 base classes and abstractions involved in printing. These base classes are also used
 by other more specialized printing related packages.
  
 The entry point for interacting with the print system is the  PrintManager 
 which is a system service that can be obtained from the current context. The print manager
 provides APIs for printing querying the state of print jobs etc.
  Print contract 
 An application that wants to implement printing must extend
  PrintDocumentAdapter  which defines the contract between the system
 and the application.The key idea behind this adapter is that the printed content may change
 based on the selected print options such as media size orientation which
 requires the content to be re-laid out. The constraints according to which the content has
 to be laid out are encapsulated in the  PrintAttributes  class. Once
 layout is completed the application calls back to the system passing a
  PrintDocumentInfo  instance which describes the generated content. After
 the content has been laid out the application may be asked to render some pages of that content
 for preview or printing. The range of pages that have to be rendered is abstracted by the
  PageRange  class.
  Print jobs 
 A print job is represented by the  PrintJob  class which has behavior
 methods as well as methods for querying its state. Each print job has a unique id represented
 by the  PrintJobId  class and exposes APIs for obtaining a  PrintJobInfo  which is a snapshot of its state. The print job state may
 change over time.
  Printers 
 An available printer represented by the  PrinterInfo  class has a
 unique id which is abstracted by the  PrinterId  class. The  PrinterInfo  contains printer properties such as id name description status
 and printer capabilities encapsulated in the  PrinterCapabilitiesInfo 
 class. Printer capabilities describe how a printer can print content for example what are
 the supported media sizes color modes resolutions etc."
android,se.omapi,4,
android,os,60,
android,security,10,"Provides access to a few facilities of the Android security
     subsystems."
android,security.keystore,7,
android,service.carrier,8,
android,service.dreams,1,
android,service.media,4,
android,service.notification,8,
android,service.quicksettings,2,
android,service.autofill,34,
android,service.restrictions,1,
android,service.textservice,2,"Provides classes that allow you to create spell checkers in a manner similar to the
 input method framework (for IMEs). To create a new spell checker you must implement a service that extends  SpellCheckerService  and extend the  SpellCheckerService.Session  class to provide spelling suggestions based
 on text provided by the interface's callback methods. In the  SpellCheckerService.Session  callback methods you must return the
 spelling suggestions as  SuggestionsInfo  objects.  Applications with a spell checker service must declare the  BIND_TEXT_SERVICE  permission as required by the service. The service
 must also declare an intent filter with  <action
 android:name=""android.service.textservice.SpellCheckerService"" />  as the intent’s action and should
 include a  <meta-data>  element that declares configuration information for the spell
 checker. For example: 
 <service
     android:label=""@string/app_name""
     android:name="".SampleSpellCheckerService""
     android:permission=""android.permission.BIND_TEXT_SERVICE"" >
     <intent-filter >
         <action android:name=""android.service.textservice.SpellCheckerService"" />
     </intent-filter>
     <meta-data
         android:name=""android.view.textservice.scs""
         android:resource=""@xml/spellchecker"" />
 </service>
  For example code see the sample  Spell
 Checker service  app and the sample  Spell
 Checker client  app."
android,renderscript,61,"RenderScript provides support for high-performance computation across heterogeneous processors. For more information see the
  RenderScript  developer guide."
android,service.vr,1,
android,service.wallpaper,2,
android,service.voice,15,
android,speech,5,
android,speech.tts,7,
android,system,9,
android,telephony.cdma,1,
android,telephony.data,2,
android,telephony.emergency,1,
android,telephony.euicc,3,
android,telephony.gsm,4,
android,telecom,36,"Android supports the following calling use cases (with increasing level of complexity):
  Implement the self-managed  ConnectionService  API - this is ideal
     for developers of standalone calling apps which do not wish to show their calls within the
     default phone app and do not wish to have other calls shown in their user interface.  Using
     a self-managed  ConnectionService  implementation within your
     standalone calling app helps you ensure that your app will interoperate not only with native
     telephony calling on the device but also other standalone calling apps implementing this
     API.  It also manages audio routing and focus for you. Implement the managed  ConnectionService  API - facilitates
     development of a calling solution that relies on the existing device phone application (see
      getDefaultDialerPackage() ) to provide the user
     interface for calls.  An example might be a third party implementation of SIP calling or a
     VOIP calling service.  A  ConnectionService  alone provides only the
     means of connecting calls but has no associated user interface. Implement the  InCallService  API - facilitates development of a
     replacement for the device's default Phone/Dialer app.  The
      InCallService  alone does not have any calling capability and consists
     of the user-interface side of calling only.  An  InCallService  must
     handle all Calls the Telecom framework is aware of.  It must not make assumptions about the
     nature of the calls (e.g. assuming calls are SIM-based telephony calls) and should not
     implement calling restrictions based on any one  ConnectionService 
     (e.g. it should not enforce Telephony restrictions for video calls). Implement both the  InCallService  and
      ConnectionService  API - ideal if you wish to create your own
      ConnectionService  based calling solution complete with its own
     full user interface while showing all other Android calls in the same user interface.  Using
     this approach you must still ensure that your  InCallService  makes
     no assumption about the source of the calls it displays.  You must also ensure that your
      ConnectionService  implementation can still function without the
     default phone app being set to your custom  InCallService ."
android,telephony.mbms,20,
android,test.mock,10,
android,test.suitebuilder,3,
android,test.suitebuilder.annotation,0,
android,test,21,
android,telephony,63,
android,text.format,4,
android,text,36,"Provides classes used to render or track text and text spans on the screen. You can use these classes to design your own widgets that manage text
 to handle arbitrary text spans for changes or to handle drawing yourself
 for an existing widget. The Span… interfaces and classes are used to create or manage spans of
 text in a View item. You can use these to style the text or background or to
 listen for changes. If creating your own widget extend DynamicLayout to manages
 the actual wrapping and drawing of your text."
android,text.util,3,
android,text.method,21,"Provides classes that monitor or modify keypad input. You can use these classes to modify the type of keypad entry
 for your application or decipher the keypresses entered for your specific
 entry method. For example: 
 // Set the text to password display style:
 EditText txtView = (EditText)findViewById(R.id.text);
 txtView.setTransformationMethod(PasswordTransformationMethod.getInstance());

 //Set the input style to numbers rather than qwerty keyboard style.
 txtView.setInputMethod(DigitsInputMethod.getInstance());

 // Find out whether the caps lock is on.
 // 0 is no 1 is yes 2 is caps lock on.
 int active = MultiTapInputMethod.getCapsActive(txtView.getText());"
android,text.style,48,"Provides classes used to view or change the style of a span of text in a View object.
 The classes with a subclass Standard are passed in to  SpannableString.setSpan()  or  SpannableStringBuilder.setSpan()  to add a new styled span to a string in a View object."
android,transition,25,"The classes in this package enable ""scenes & transitions"" functionality for
 view hiearchies. A  Scene  is an encapsulation of the state of a view hierarchy
 including the views in that hierarchy and the various values (layout-related
 and otherwise) that those views have. A scene can be defined by a layout hierarchy
 directly or by code which sets up the scene dynamically as it is entered. A  Transition  is a mechanism to automatically animate changes that occur
 when a new scene is entered. Some transition capabilities are automatic. That
 is entering a scene may cause animations to run which fade out views that
 go away changeBounds and resize existing views that change and fade in views that
 become visible. There are additional transitions that can animate other
 attributes such as color changes and which can optionally be specified
 to take place during particular scene changes. Finally developers can
 define their own Transition subclasses which monitor particular property
 changes and which run custom animations when those properties change values. TransitionManager  is used to specify custom transitions for particular
 scene changes and to cause scene changes with specific transitions to
 take place."
android,service.chooser,2,
android,view.accessibility,15,"The classes in this package are used to represent screen content and changes to it
   as well as APIs for querying the global accessibility state of the system.
  AccessibilityEvent s are sent by the system when
   something notable happens in the user interface. For example when a
    Button  is clicked a  View  is focused etc.
  AccessibilityRecord  contains information
   about state change of its source  View . When a view fires
   an accessibility event it requests from its parent to dispatch the
   constructed event. The parent may optionally append a record for itself for
   providing more context to  AccessibilityService s.
   Hence accessibility services can facilitate additional accessibility records
   to enhance feedback.
  AccessibilityNodeInfo  represents a node of the
   window content as well as actions that can be requested from its source. From the point
   of view of an  AccessibilityService  a window content is
   presented as tree of accessibility node info which may or may not map one-to-one
   to the view hierarchy. In other words a custom view is free to report itself as
   a tree of accessibility node info.
  AccessibilityManager  is a system level service that
   serves as an event dispatch for   AccessibilityEvent s
   and provides facilities for querying the accessibility state of the system. Accessibility
   events are generated when something notable happens in the user interface for example an
    Activity  starts the focus or selection of a  View 
   changes etc. Parties interested in handling accessibility events implement and register an
   accessibility service which extends  AccessibilityService ."
android,view.autofill,4,
android,util,38,
android,view.contentcapture,9,
android,view.animation,24,"Provides classes that handle tweened animations. Android provides two mechanisms
     that you can use to create simple animations:  tweened
         animation  in which you tell Android to perform a series of simple
     transformations (position size rotation and so on) to the content of a
     View; and  frame-by-frame animation  which loads a series of Drawable resources
     one after the other. Both animation types can be used in any View object
     to provide simple rotating timers activity icons and other useful UI elements.
     Tweened animation is handled by this package (android.view.animation); frame-by-frame animation is
     handled by the  AnimationDrawable  class.
      For more information on creating tweened or frame-by-frame animations read the discussion in the
  2D Graphics 
 Dev Guide."
android,view.inspector,3,
android,view.inputmethod,15,
android,view.textservice,7,
android,webkit,43,"Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview ."
android,dalvik.annotation,0,
android,dalvik.bytecode,1,
android,view.textclassifier,42,
android,java.awt.font,2,
android,dalvik.system,6,
android,view,78,
android,java.beans,4,
android,java.lang.annotation,0,
android,java.lang.invoke,8,
android,java.lang.ref,5,
android,java.lang.reflect,10,
android,java.io,51,
android,java.math,3,
android,java.nio,0,
android,java.net,0,
android,java.nio.channels.spi,6,
android,java.nio.channels,18,
android,java.nio.charset,6,
android,java.nio.charset.spi,1,
android,java.nio.file,8,
android,java.nio.file.attribute,5,
android,java.nio.file.spi,2,
android,java.security.acl,0,
android,provider,156,"Provides convenience classes to access the content providers supplied by
 Android. Android ships with a number of content providers that store common data such
 as contact informations calendar information and media files. These classes
 provide simplified methods of adding or retrieving data from these content
 providers. For information about how to use a content provider see the  Content Providers  developer
 guide."
android,java.security.interfaces,0,
android,java.lang,36,
android,java.security.cert,28,
android,java.sql,7,
android,java.time,0,
android,java.time.chrono,11,
android,java.time.format,3,
android,java.security,53,
android,java.text,26,
android,java.time.temporal,6,
android,java.time.zone,3,
android,java.util.concurrent,0,
android,java.util.concurrent.locks,11,
android,java.util.function,0,
android,java.util.jar,8,
android,java.util,27,
android,java.util.prefs,4,
android,java.util.logging,15,
android,java.util.regex,1,
android,java.util.stream,2,
android,java.util.concurrent.atomic,16,
android,javax.crypto.interfaces,0,
android,java.util.zip,16,
android,javax.crypto,17,
android,javax.microedition.khronos.opengles,0,
android,javax.microedition.khronos.egl,4,
android,javax.crypto.spec,16,
android,javax.net,2,
android,javax.security.auth.callback,1,
android,javax.security.auth.login,0,
android,javax.security.auth,4,
android,javax.security.auth.x500,1,
android,javax.security.cert,2,
android,javax.xml,1,
android,javax.sql,3,
android,javax.xml.namespace,1,
android,javax.xml.datatype,5,
android,javax.xml.parsers,4,
android,javax.net.ssl,26,
android,javax.xml.transform,3,
android,javax.xml.transform.dom,2,
android,javax.xml.transform.sax,3,
android,javax.xml.transform.stream,2,
android,javax.xml.validation,6,
android,javax.xml.xpath,2,
android,junit.framework,5,
android,org.apache.http.conn,0,
android,org.apache.http.conn.scheme,0,
android,junit.runner,2,
android,org.apache.http.params,1,
android,org.w3c.dom,0,
android,org.apache.http.conn.ssl,5,
android,org.json,4,
android,org.w3c.dom.ls,0,
android,org.xml.sax,2,
android,org.xml.sax.ext,3,
android,org.xmlpull.v1,1,
android,org.xmlpull.v1.sax2,1,
android,org.xml.sax.helpers,10,
android,widget,114,"The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file"
android,java.security.spec,22,
