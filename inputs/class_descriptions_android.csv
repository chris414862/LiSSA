android,accounts,AbstractAccountAuthenticator,15,"Abstract base class for creating AccountAuthenticators.
 In order to be an authenticator one must extend this class provide implementations for the
 abstract methods and write a service that returns the result of  getIBinder() 
 in the service's  Service.onBind(android.content.Intent)  when invoked
 with an intent with action  AccountManager#ACTION_AUTHENTICATOR_INTENT . This service
 must specify the following intent filter and metadata tags in its AndroidManifest.xml file
  
   <intent-filter>
     <action android:name=""android.accounts.AccountAuthenticator"" />
   </intent-filter>
   <meta-data android:name=""android.accounts.AccountAuthenticator""
             android:resource=""@xml/authenticator"" />
  android:resource 
 <account-authenticator xmlns:android=""http://schemas.android.com/apk/res/android""
    android:accountType=""typeOfAuthenticator""
    android:icon=""@drawable/icon""
    android:smallIcon=""@drawable/miniIcon""
    android:label=""@string/label""
    android:accountPreferences=""@xml/account_preferences""
 />
  android:accountType AccountManager Account#type 
 The preferences attribute points to a PreferenceScreen xml hierarchy that contains
 a list of PreferenceScreens that can be invoked to manage the authenticator. An example is:
  
 <PreferenceScreen xmlns:android=""http://schemas.android.com/apk/res/android"">
    <PreferenceCategory android:title=""@string/title_fmt"" />
    <PreferenceScreen
         android:key=""key1""
         android:title=""@string/key1_action""
         android:summary=""@string/key1_summary"">
         <intent
             android:action=""key1.ACTION""
             android:targetPackage=""key1.package""
             android:targetClass=""key1.class"" />
     </PreferenceScreen>
 </PreferenceScreen>
  
 The standard pattern for implementing any of the abstract methods is the following:
   If the supplied arguments are enough for the authenticator to fully satisfy the request
 then it will do so and return a  Bundle  that contains the results.
   If the authenticator needs information from the user to satisfy the request then it
 will create an  Intent  to an activity that will prompt the user for the information
 and then carry out the request. This intent must be returned in a Bundle as key
  AccountManager#KEY_INTENT .
  
 The activity needs to return the final result when it is complete so the Intent should contain
 the  AccountAuthenticatorResponse  as  AccountManager#KEY_ACCOUNT_MANAGER_RESPONSE .
 The activity must then call  AccountAuthenticatorResponse#onResult  or
  AccountAuthenticatorResponse#onError  when it is complete.
   If the authenticator cannot synchronously process the request and return a result then it
 may choose to return null and then use the AccountManagerResponse to send the result
 when it has completed the request.
  
 The following descriptions of each of the abstract authenticator methods will not describe the
 possible asynchronous nature of the request handling and will instead just describe the input
 parameters and the expected result.
  
 When writing an activity to satisfy these requests one must pass in the AccountManagerResponse
 and return the result via that response when the activity finishes (or whenever else  the
 activity author deems it is the correct time to respond).
 The  AccountAuthenticatorActivity  handles this so one may wish to extend that when
 writing activities to handle these requests."
android,accounts,Account,5,"Value type that represents an Account in the  AccountManager . This object is
  Parcelable  and also overrides  equals(Object)  and  hashCode()  making it
 suitable for use as the key of a  Map"
android,accounts,AccountAuthenticatorActivity,3,"Base class for implementing an Activity that is used to help implement an
 AbstractAccountAuthenticator. If the AbstractAccountAuthenticator needs to use an activity
 to handle the request then it can have the activity extend AccountAuthenticatorActivity.
 The AbstractAccountAuthenticator passes in the response to the intent using the following:
  
      intent.putExtra( AccountManager#KEY_ACCOUNT_AUTHENTICATOR_RESPONSE  response);
  setAccountAuthenticatorResult(android.os.Bundle) AccountManager#ERROR_CODE_CANCELED"
android,accounts,AccountAuthenticatorResponse,5,Object used to communicate responses back to the AccountManager
android,accounts,AccountManager,45,"This class provides access to a centralized registry of the user's
 online accounts.  The user enters credentials (username and password) once
 per account granting applications access to online resources with
 ""one-click"" approval.

  Different online services have different ways of handling accounts and
 authentication so the account manager uses pluggable  authenticator 
 modules for different  account types .  Authenticators (which may be
 written by third parties) handle the actual details of validating account
 credentials and storing account information.  For example Google Facebook
 and Microsoft Exchange each have their own authenticator.

  Many servers support some notion of an  authentication token 
 which can be used to authenticate a request to the server without sending
 the user's actual password.  (Auth tokens are normally created with a
 separate request which does include the user's credentials.)  AccountManager
 can generate auth tokens for applications so the application doesn't need to
 handle passwords directly.  Auth tokens are normally reusable and cached by
 AccountManager but must be refreshed periodically.  It's the responsibility
 of applications to  invalidate  auth tokens when they stop working so
 the AccountManager knows it needs to regenerate them.

  Applications accessing a server normally go through these steps:

  Get an instance of AccountManager using  get(android.content.Context) .

  List the available accounts using  getAccountsByType(String)  or
  getAccountsByTypeAndFeatures(String String[] AccountManagerCallback  Handler) .  Normally applications will only
 be interested in accounts with one particular  type  which
 identifies the authenticator.  Account  features  are used to
 identify particular account subtypes and capabilities.  Both the account
 type and features are authenticator-specific strings and must be known by
 the application in coordination with its preferred authenticators.

  Select one or more of the available accounts possibly by asking the
 user for their preference.  If no suitable accounts are available
  addAccount(String String String[] Bundle Activity AccountManagerCallback  Handler)  may be called to prompt the user to create an
 account of the appropriate type.

  Important:  If the application is using a previously remembered
 account selection it must make sure the account is still in the list
 of accounts returned by  getAccountsByType(String) .  Requesting an auth token
 for an account no longer on the device results in an undefined failure.

  Request an auth token for the selected account(s) using one of the
  getAuthToken(Account String Bundle Activity AccountManagerCallback  Handler)  methods or related helpers.  Refer to the description
 of each method for exact usage and error handling details.

  Make the request using the auth token.  The form of the auth token
 the format of the request and the protocol used are all specific to the
 service you are accessing.  The application may use whatever network and
 protocol libraries are useful.

  Important:  If the request fails with an authentication error
 it could be that a cached auth token is stale and no longer honored by
 the server.  The application must call  invalidateAuthToken(String String)  to remove
 the token from the cache otherwise requests will continue failing!  After
 invalidating the auth token immediately go back to the ""Request an auth
 token"" step above.  If the process fails the second time then it can be
 treated as a ""genuine"" authentication failure and the user notified or other
 appropriate actions taken.
  Some AccountManager methods may need to interact with the user to
 prompt for credentials present options or ask the user to add an account.
 The caller may choose whether to allow AccountManager to directly launch the
 necessary user interface and wait for the user or to return an Intent which
 the caller may use to launch the interface or (in some cases) to install a
 notification which the user can select at any time to launch the interface.
 To have AccountManager launch the interface directly the caller must supply
 the current foreground  Activity  context.

  Many AccountManager methods take  AccountManagerCallback  and
  Handler  as parameters.  These methods return immediately and
 run asynchronously. If a callback is provided then
  AccountManagerCallback#run  will be invoked on the Handler's
 thread when the request completes successfully or not.
 The result is retrieved by calling  AccountManagerFuture#getResult() 
 on the  AccountManagerFuture  returned by the method (and also passed
 to the callback).  This method waits for the operation to complete (if
 necessary) and either returns the result or throws an exception if an error
 occurred during the operation.  To make the request synchronously call
  AccountManagerFuture#getResult()  immediately on receiving the
 future from the method; no callback need be supplied.

  Requests which may block including
  AccountManagerFuture#getResult()  must never be called on
 the application's main event thread.  These operations throw
  IllegalStateException  if they are used on the main thread."
android,accounts,AuthenticatorDescription,6,A  Parcelable  value type that contains information about an account authenticator.
android,accessibilityservice,AccessibilityButtonController,4,"Controller for the accessibility button within the system's navigation area
  
 This class may be used to query the accessibility button's state and register
 callbacks for interactions with and state changes to the accessibility button when
  AccessibilityServiceInfo#FLAG_REQUEST_ACCESSIBILITY_BUTTON  is set.
  Note:  This class and
  AccessibilityServiceInfo#FLAG_REQUEST_ACCESSIBILITY_BUTTON  should not be used as
 the sole means for offering functionality to users via an  AccessibilityService .
 Some device implementations may choose not to provide a software-rendered system
 navigation area making this affordance permanently unavailable.
  Note:  On device implementations where the accessibility button is
 supported it may not be available at all times such as when a foreground application uses
  View.SYSTEM_UI_FLAG_HIDE_NAVIGATION . A user may also choose to assign
 this button to another accessibility service or feature. In each of these cases a
 registered  AccessibilityButtonCallback 's
  AccessibilityButtonCallback#onAvailabilityChanged(AccessibilityButtonController boolean) 
 method will be invoked to provide notifications of changes in the accessibility button's
 availability to the registering service."
android,accessibilityservice,AccessibilityButtonController.AccessibilityButtonCallback,2,"Callback for interaction with and changes to state of the accessibility button
 within the system's navigation area."
android,accessibilityservice,AccessibilityService,19,"Accessibility services should only be used to assist users with disabilities in using
 Android devices and apps. They run in the background and receive callbacks by the system
 when  AccessibilityEvent s are fired. Such events denote some state transition
 in the user interface for example the focus has changed a button has been clicked
 etc. Such a service can optionally request the capability for querying the content
 of the active window. Development of an accessibility service requires extending this
 class and implementing its abstract methods."
android,accessibilityservice,AccessibilityService.GestureResultCallback,2,Class used to report status of dispatched gestures
android,accessibilityservice,AccessibilityService.MagnificationController,10,Used to control and query the state of display magnification.
android,accessibilityservice,AccessibilityService.SoftKeyboardController,5,"Used to control query and listen for changes to the soft keyboard show mode.
  
 Accessibility services may request to override the decisions normally made about whether or
 not the soft keyboard is shown.
  
 If multiple services make conflicting requests the last request is honored. A service may
 register a listener to find out if the mode has changed under it.
  
 If the user takes action to override the behavior behavior requested by an accessibility
 service the user's request takes precendence the show mode will be reset to
  AccessibilityService#SHOW_MODE_AUTO  and services will no longer be able to control
 that aspect of the soft keyboard's behavior.
  
 Note: Because soft keyboards are independent apps the framework does not have total control
 over their behavior. They may choose to show themselves or not without regard to requests
 made here. So the framework will make a best effort to deliver the behavior requested but
 cannot guarantee success."
android,accessibilityservice,AccessibilityServiceInfo,20,"This class describes an  AccessibilityService . The system notifies an
  AccessibilityService  for  AccessibilityEvent s
 according to the information encapsulated in this class."
android,accessibilityservice,FingerprintGestureController,3,"An  AccessibilityService  can capture gestures performed on a device's fingerprint
 sensor as long as the device has a sensor capable of detecting gestures.
  
 This capability must be declared by the service as
  AccessibilityServiceInfo#CAPABILITY_CAN_REQUEST_FINGERPRINT_GESTURES . It also requires
 the permission  Manifest.permission.USE_FINGERPRINT .
  
 Because capturing fingerprint gestures may have side effects services with the capability only
 capture gestures when  AccessibilityServiceInfo#FLAG_REQUEST_FINGERPRINT_GESTURES  is set.
  Note:  The fingerprint sensor is used for authentication in critical use cases
 so services must carefully design their user's experience when performing gestures on the sensor.
 When the sensor is in use by an app for example when authenticating or enrolling a user
 the sensor will not detect gestures. Services need to ensure that users understand when the
 sensor is in-use for authentication to prevent users from authenticating unintentionally when
 trying to interact with the service. They can use
  FingerprintGestureCallback#onGestureDetectionAvailabilityChanged(boolean)  to learn when
 gesture detection becomes unavailable.
  
 Multiple accessibility services may listen for fingerprint gestures simultaneously so services
 should provide a way for the user to disable the use of this feature so multiple services don't
 conflict with each other."
android,accessibilityservice,FingerprintGestureController.FingerprintGestureCallback,2,Class that is called back when fingerprint gestures are being used for accessibility.
android,accessibilityservice,GestureDescription,4,"Accessibility services with the
  R.styleable.AccessibilityService_canPerformGestures  property can dispatch
 gestures. This class describes those gestures. Gestures are made up of one or more strokes.
 Gestures are immutable once built.
  
 Spatial dimensions throughout are in screen pixels. Time is measured in milliseconds."
android,accessibilityservice,GestureDescription.StrokeDescription,5,Immutable description of stroke that can be part of a gesture.
android,accessibilityservice,GestureDescription.Builder,2,Builder for a  GestureDescription
android,app.assist,AssistContent,13,"Holds information about the content an application is viewing to hand to an
 assistant at the user's request.  This is filled in by
  Activity.onProvideAssistContent ."
android,app.assist,AssistStructure,8,"This API automatically creates assist data from the platform's
 implementation of assist and autofill.

  The structure is used for assist purposes when created by
  Activity.onProvideAssistData(Bundle)   View#onProvideStructure(ViewStructure) 
 or  View#onProvideVirtualStructure(ViewStructure) .

  The structure is also used for autofill purposes when created by
  View#onProvideAutofillStructure(ViewStructure int) 
 or  View#onProvideAutofillVirtualStructure(ViewStructure int) .

  For performance reasons some properties of the assist data might only be available for
 assist or autofill purposes. In those cases a property's availability will be documented
 in its javadoc.

  To learn about using Autofill in your app read the
  Autofill Framework  guides."
android,app.assist,AssistStructure.ViewNode,57,Describes a single view in the assist data.
android,app.assist,AssistStructure.WindowNode,7,Describes a window in the assist data.
android,animation,Animator,25,"This is the superclass for classes which provide basic support for animations which can be
 started ended and have  AnimatorListeners  added to them."
android,animation,AnimatorListenerAdapter,6,"This adapter class provides empty implementations of the methods from  Animator.AnimatorListener .
 Any custom listener that cares only about a subset of the methods of this listener can
 simply subclass this adapter class instead of implementing the interface directly."
android,animation,AnimatorSet,28,"This class plays a set of  Animator  objects in the specified order. Animations
 can be set up to play together in sequence or after a specified delay.

  There are two different approaches to adding animations to a  AnimatorSet :
 either the  AnimatorSet#playTogether(Animator[])  or
  AnimatorSet#playSequentially(Animator[])  methods can be called to add
 a set of animations all at once or the  AnimatorSet#play(Animator)  can be
 used in conjunction with methods in the  AnimatorSet.Builder 
 class to add animations
 one by one. It is possible to set up a  AnimatorSet  with circular dependencies between
 its animations. For example an animation a1 could be set up to start before animation a2 a2
 before a3 and a3 before a1. The results of this configuration are undefined but will typically
 result in none of the affected animations being played. Because of this (and because
 circular dependencies do not make logical sense anyway) circular dependencies
 should be avoided and the dependency flow of animations should only be in one direction."
android,animation,AnimatorSet.Builder,4,"The  Builder  object is a utility class to facilitate adding animations to a
  AnimatorSet  along with the relationships between the various animations. The
 intention of the  Builder  methods along with the  AnimatorSet#play(Animator)  method of  AnimatorSet  is to make it possible
 to express the dependency relationships of animations in a natural way. Developers can also
 use the  AnimatorSet#playTogether(Animator[])  and  AnimatorSet#playSequentially(Animator[])  methods if these suit the need
 but it might be easier in some situations to express the AnimatorSet of animations in pairs.
  The  Builder  object cannot be constructed directly but is rather constructed
 internally via a call to  AnimatorSet#play(Animator) . For example this sets up a AnimatorSet to play anim1 and anim2 at the same time anim3 to
 play when anim2 finishes and anim4 to play when anim3 finishes: 
     AnimatorSet s = new AnimatorSet();
     s.play(anim1).with(anim2);
     s.play(anim2).before(anim3);
     s.play(anim4).after(anim3);
  Note in the example that both  Builder#before(Animator)  and  Builder#after(Animator)  are used. These are just different ways of expressing the same
 relationship and are provided to make it easier to say things in a way that is more natural
 depending on the situation. It is possible to make several calls into the same  Builder  object to express
 multiple relationships. However note that it is only the animation passed into the initial
  AnimatorSet#play(Animator)  method that is the dependency in any of the successive
 calls to the  Builder  object. For example the following code starts both anim2
 and anim3 when anim1 ends; there is no direct dependency relationship between anim2 and
 anim3:
  
   AnimatorSet s = new AnimatorSet();
   s.play(anim1).before(anim2).before(anim3);
  
   AnimatorSet s = new AnimatorSet();
   s.play(anim1).before(anim2);
   s.play(anim2).before(anim3);
  Note that it is possible to express relationships that cannot be resolved and will not
 result in sensible results. For example  play(anim1).after(anim1)  makes no
 sense. In general circular dependencies like this one (or more indirect ones where a depends
 on b which depends on c which depends on a) should be avoided. Only create AnimatorSets
 that can boil down to a simple one-way relationship of animations starting with before and
 after other different animations."
android,animation,BidirectionalTypeConverter,2,"Abstract base class used convert type T to another type V and back again. This
 is necessary when the value types of in animation are different from the property
 type. BidirectionalTypeConverter is needed when only the final value for the
 animation is supplied to animators."
android,animation,FloatArrayEvaluator,1,"This evaluator can be used to perform type interpolation between  float[]  values.
 Each index into the array is treated as a separate value to interpolate. For example
 evaluating  {100 200}  and  {300 400}  will interpolate the value at
 the first index between 100 and 300 and the value at the second index value between 200 and 400."
android,animation,IntArrayEvaluator,1,"This evaluator can be used to perform type interpolation between  int[]  values.
 Each index into the array is treated as a separate value to interpolate. For example
 evaluating  {100 200}  and  {300 400}  will interpolate the value at
 the first index between 100 and 300 and the value at the second index value between 200 and 400."
android,animation,IntEvaluator,1,This evaluator can be used to perform type interpolation between  int  values.
android,animation,AnimatorInflater,2,"This class is used to instantiate animator XML files into Animator objects.
  
 For performance reasons inflation relies heavily on pre-processing of
 XML files that is done at build time. Therefore it is not currently possible
 to use this inflater with an XmlPullParser over a plain XML file at runtime;
 it only works with an XmlPullParser returned from a compiled resource (R.
  something  file.)"
android,animation,ArgbEvaluator,1,"This evaluator can be used to perform type interpolation between integer
 values that represent ARGB colors."
android,animation,FloatEvaluator,1,This evaluator can be used to perform type interpolation between  float  values.
android,animation,Keyframe,15,"This class holds a time/value pair for an animation. The Keyframe class is used
 by  ValueAnimator  to define the values that the animation target will have over the course
 of the animation. As the time proceeds from one keyframe to the other the value of the
 target object will animate between the value at the previous keyframe and the value at the
 next keyframe. Each keyframe also holds an optional  TimeInterpolator 
 object which defines the time interpolation over the intervalue preceding the keyframe.

  The Keyframe class itself is abstract. The type-specific factory methods will return
 a subclass of Keyframe specific to the type of value being stored. This is done to improve
 performance when dealing with the most common cases (e.g.  float  and
  int  values). Other types will fall into a more general Keyframe class that
 treats its values as Objects. Unless your animation requires dealing with a custom type
 or a data structure that needs to be animated directly (and evaluated using an implementation
 of  TypeEvaluator ) you should stick to using float and int as animations using those
 types have lower runtime overhead than other types."
android,animation,LayoutTransition,26,"This class enables automatic animations on layout changes in ViewGroup objects. To enable
 transitions for a layout container create a LayoutTransition object and set it on any
 ViewGroup by calling  ViewGroup#setLayoutTransition(LayoutTransition) . This will cause
 default animations to run whenever items are added to or removed from that container. To specify
 custom animations use the  LayoutTransition#setAnimator(int Animator)  method.

  One of the core concepts of these transition animations is that there are two types of
 changes that cause the transition and four different animations that run because of
 those changes. The changes that trigger the transition are items being added to a container
 (referred to as an ""appearing"" transition) or removed from a container (also known as
 ""disappearing""). Setting the visibility of views (between GONE and VISIBLE) will trigger
 the same add/remove logic. The animations that run due to those events are one that animates
 items being added one that animates items being removed and two that animate the other
 items in the container that change due to the add/remove occurrence. Users of
 the transition may want different animations for the changing items depending on whether
 they are changing due to an appearing or disappearing event so there is one animation for
 each of these variations of the changing event. Most of the API of this class is concerned
 with setting up the basic properties of the animations used in these four situations
 or with setting up custom animations for any or all of the four. By default the DISAPPEARING animation begins immediately as does the CHANGE_APPEARING
 animation. The other animations begin after a delay that is set to the default duration
 of the animations. This behavior facilitates a sequence of animations in transitions as
 follows: when an item is being added to a layout the other children of that container will
 move first (thus creating space for the new item) then the appearing animation will run to
 animate the item being added. Conversely when an item is removed from a container the
 animation to remove it will run first then the animations of the other children in the
 layout will run (closing the gap created in the layout when the item was removed). If this
 default choreography behavior is not desired the  setDuration(int long)  and
  setStartDelay(int long)  of any or all of the animations can be changed as
 appropriate. Keep in mind however that if you start an APPEARING animation before a
 DISAPPEARING animation is completed the DISAPPEARING animation stops and any effects from
 the DISAPPEARING animation are reverted. If you instead start a DISAPPEARING animation
 before an APPEARING animation is completed a similar set of effects occurs for the
 APPEARING animation. The animations specified for the transition both the defaults and any custom animations
 set on the transition object are templates only. That is these animations exist to hold the
 basic animation properties such as the duration start delay and properties being animated.
 But the actual target object as well as the start and end values for those properties are
 set automatically in the process of setting up the transition each time it runs. Each of the
 animations is cloned from the original copy and the clone is then populated with the dynamic
 values of the target being animated (such as one of the items in a layout container that is
 moving as a result of the layout event) as well as the values that are changing (such as the
 position and size of that object). The actual values that are pushed to each animation
 depends on what properties are specified for the animation. For example the default
 CHANGE_APPEARING animation animates the  left   top   right 
  bottom   scrollX  and  scrollY  properties.
 Values for these properties are updated with the pre- and post-layout
 values when the transition begins. Custom animations will be similarly populated with
 the target and values being animated assuming they use ObjectAnimator objects with
 property names that are known on the target object. This class and the associated XML flag for containers animateLayoutChanges=""true""
 provides a simple utility meant for automating changes in straightforward situations.
 Using LayoutTransition at multiple levels of a nested view hierarchy may not work due to the
 interrelationship of the various levels of layout. Also a container that is being scrolled
 at the same time as items are being added or removed is probably not a good candidate for
 this utility because the before/after locations calculated by LayoutTransition
 may not match the actual locations when the animations finish due to the container
 being scrolled as the animations are running. You can work around that
 particular issue by disabling the 'changing' animations by setting the CHANGE_APPEARING
 and CHANGE_DISAPPEARING animations to null and setting the startDelay of the
 other animations appropriately."
android,animation,ObjectAnimator,37,"This subclass of  ValueAnimator  provides support for animating properties on target objects.
 The constructors of this class take parameters to define the target object that will be animated
 as well as the name of the property that will be animated. Appropriate set/get functions
 are then determined internally and the animation will call these functions as necessary to
 animate the property.

  Animators can be created from either code or resource files as shown here: <objectAnimator xmlns:android=""http://schemas.android.com/apk/res/android""
    android:duration=""1000""
    android:valueTo=""200""
    android:valueType=""floatType""
    android:propertyName=""y""
    android:repeatCount=""1""
    android:repeatMode=""reverse""/> Starting from API 23 it is possible to use  PropertyValuesHolder  and
  Keyframe  in resource files to create more complex animations. Using PropertyValuesHolders
 allows animators to animate several properties in parallel as shown in this sample: <objectAnimator xmlns:android=""http://schemas.android.com/apk/res/android""
                android:duration=""1000""
                android:repeatCount=""1""
                android:repeatMode=""reverse"">
    <propertyValuesHolder android:propertyName=""x"" android:valueTo=""400""/>
    <propertyValuesHolder android:propertyName=""y"" android:valueTo=""200""/>
</objectAnimator> Using Keyframes allows animations to follow more complex paths from the start
 to the end values. Note that you can specify explicit fractional values (from 0 to 1) for
 each keyframe to determine when in the overall duration the animation should arrive at that
 value. Alternatively you can leave the fractions off and the keyframes will be equally
 distributed within the total duration. Also a keyframe with no value will derive its value
 from the target object when the animator starts just like animators with only one
 value specified. In addition an optional interpolator can be specified. The interpolator will
 be applied on the interval between the keyframe that the interpolator is set on and the previous
 keyframe. When no interpolator is supplied the default  AccelerateDecelerateInterpolator 
 will be used.  <propertyValuesHolder android:propertyName=""x"" >
    <keyframe android:fraction=""0"" android:value=""800"" />
    <keyframe android:fraction="".2""
              android:interpolator=""@android:anim/accelerate_interpolator""
              android:value=""1000"" />
    <keyframe android:fraction=""1""
              android:interpolator=""@android:anim/accelerate_interpolator""
              android:value=""400"" />
</propertyValuesHolder>
<propertyValuesHolder android:propertyName=""y"" >
    <keyframe/>
    <keyframe android:fraction="".2""
              android:interpolator=""@android:anim/accelerate_interpolator""
              android:value=""300""/>
    <keyframe android:interpolator=""@android:anim/accelerate_interpolator""
              android:value=""1000"" />
</propertyValuesHolder>"
android,animation,PointFEvaluator,1,This evaluator can be used to perform type interpolation between  PointF  values.
android,animation,PropertyValuesHolder,30,"This class holds information about a property and the values that that property
 should take on during an animation. PropertyValuesHolder objects can be used to create
 animations with ValueAnimator or ObjectAnimator that operate on several different properties
 in parallel."
android,animation,RectEvaluator,1,This evaluator can be used to perform type interpolation between  Rect  values.
android,animation,StateListAnimator,3,"Lets you define a number of Animators that will run on the attached View depending on the View's
 drawable state.
  
 It can be defined in an XML file with the  <selector>  element.
 Each State Animator is defined in a nested  <item>  element."
android,animation,ValueAnimator,44,"This class provides a simple timing engine for running animations
 which calculate animated values and set them on target objects.

  There is a single timing pulse that all animations use. It runs in a
 custom handler to ensure that property changes happen on the UI thread. By default ValueAnimator uses non-linear time interpolation via the
  AccelerateDecelerateInterpolator  class which accelerates into and decelerates
 out of an animation. This behavior can be changed by calling
  ValueAnimator#setInterpolator(TimeInterpolator) . Animators can be created from either code or resource files. Here is an example
 of a ValueAnimator resource file: <animator xmlns:android=""http://schemas.android.com/apk/res/android""
    android:duration=""1000""
    android:valueFrom=""1""
    android:valueTo=""0""
    android:valueType=""floatType""
    android:repeatCount=""1""
    android:repeatMode=""reverse""/> Starting from API 23 it is also possible to use a combination of  PropertyValuesHolder 
 and  Keyframe  resource tags to create a multi-step animation.
 Note that you can specify explicit fractional values (from 0 to 1) for
 each keyframe to determine when in the overall duration the animation should arrive at that
 value. Alternatively you can leave the fractions off and the keyframes will be equally
 distributed within the total duration: <animator xmlns:android=""http://schemas.android.com/apk/res/android""
          android:duration=""1000""
          android:repeatCount=""1""
          android:repeatMode=""reverse"">
    <propertyValuesHolder>
        <keyframe android:fraction=""0"" android:value=""1""/>
        <keyframe android:fraction="".2"" android:value="".4""/>
        <keyframe android:fraction=""1"" android:value=""0""/>
    </propertyValuesHolder>
</animator>"
android,animation,TimeAnimator,3,"This class provides a simple callback mechanism to listeners that is synchronized with all
 other animators in the system. There is no duration interpolation or object value-setting
 with this Animator. Instead it is simply started after which it proceeds to send out events
 on every animation frame to its TimeListener (if set) with information about this animator
 the total elapsed time and the elapsed time since the previous animation frame."
android,animation,TypeConverter,1,"Abstract base class used convert type T to another type V. This
 is necessary when the value types of in animation are different
 from the property type."
android,app.admin,ConnectEvent,5,"A class that represents a TCP connect event initiated through the standard network stack.

  It contains information about the originating app as well as the remote TCP endpoint.

  Support both IPv4 and IPv6 connections."
android,app.admin,DelegatedAdminReceiver,3,"Base class for delegated apps to handle callbacks related to their delegated capabilities.

  Delegated apps are apps that receive additional capabilities from the profile owner or
 device owner apps. Some of these capabilities involve the framework calling into the apps.
 To receive these callbacks delegated apps should subclass this class and override the
 appropriate methods here. The subclassed receiver needs to be published in the app's
 manifest with appropriate intent filters to mark which callbacks the receiver is interested
 in. An app can have multiple receivers as long as they listen for disjoint set of callbacks.
 For the manifest definitions it must be protected by the
  Manifest.permission.BIND_DEVICE_ADMIN  permission to ensure only
 the system can trigger these callbacks.

  The callback methods happen on the main thread of the process.  Thus long running
 operations must be done on another thread.  Note that because a receiver
 is done once returning from its onReceive function such long-running operations
 should probably be done in a  Service ."
android,app.admin,DeviceAdminInfo,15,"This class is used to specify meta information of a device administrator
 component."
android,app.admin,DeviceAdminReceiver,32,"Base class for implementing a device administration component.  This
 class provides a convenience for interpreting the raw intent actions
 that are sent by the system.

  The callback methods like the base
  BroadcastReceiver#onReceive(Context Intent) 
 method happen on the main thread of the process.  Thus long running
 operations must be done on another thread.  Note that because a receiver
 is done once returning from its receive function such long-running operations
 should probably be done in a  Service .

  When publishing your DeviceAdmin subclass as a receiver it must
 handle  ACTION_DEVICE_ADMIN_ENABLED  and require the
  Manifest.permission.BIND_DEVICE_ADMIN  permission.  A typical
 manifest entry would look like: <receiver android:name="".app.DeviceAdminSample$DeviceAdminSampleReceiver""
        android:label=""@string/sample_device_admin""
        android:description=""@string/sample_device_admin_description""
        android:permission=""android.permission.BIND_DEVICE_ADMIN"">
    <meta-data android:name=""android.app.device_admin""
               android:resource=""@xml/device_admin_sample"" />
    <intent-filter>
        <action android:name=""android.app.action.DEVICE_ADMIN_ENABLED"" />
    </intent-filter>
</receiver>
<receiver android:name="".app.DeviceAdminSample$DeviceAdminSampleReceiver2""
    android:label=""@string/sample_device_admin2""
    android:description=""@string/sample_device_admin_description2""
    android:permission=""android.permission.BIND_DEVICE_ADMIN"">
    <meta-data android:name=""android.app.device_admin""
        android:resource=""@xml/device_admin_sample"" />
    <intent-filter>
        <action android:name=""android.app.action.DEVICE_ADMIN_ENABLED"" />
    </intent-filter>
</receiver> The meta-data referenced here provides addition information specific
 to the device administrator as parsed by the  DeviceAdminInfo  class.
 A typical file would be: <device-admin xmlns:android=""http://schemas.android.com/apk/res/android"">
    <uses-policies>
        <limit-password />
        <watch-login />
        <reset-password />
        <force-lock />
        <wipe-data />
        <expire-password />
        <encrypted-storage />
        <disable-camera />
        <disable-keyguard-features />
    </uses-policies>
</device-admin>"
android,app.admin,DeviceAdminService,1,"Base class for a service that device owner/profile owners can optionally have.

  The system searches for it with an intent filter with the
  DevicePolicyManager#ACTION_DEVICE_ADMIN_SERVICE  action and tries to keep a bound
 connection as long as the hosting user is running so that the device/profile owner is always
 considered to be in the foreground.  This is useful to receive implicit broadcasts that
 can no longer be received by manifest receivers by apps targeting Android version
  Build.VERSION_CODES.O .  Device/profile owners can use a runtime-registered
 broadcast receiver instead and have a  DeviceAdminService  so that the process is always
 running.

  Device/profile owners can use
  PackageManager.setComponentEnabledSetting(ComponentName int int) 
 to disable/enable its own service.  For example when a device/profile owner no longer needs
 to be in the foreground it can (and should) disable its service.

  The service must be protected with the permission
  Manifest.permission.BIND_DEVICE_ADMIN .  Otherwise the system would ignore it.

  When the owner process crashes the service will be re-bound automatically after a
 back-off.

  Note the process may still be killed if the system is under heavy memory pressure in which
 case the process will be re-started later."
android,app.admin,DevicePolicyManager,214,"Public interface for managing policies enforced on a device. Most clients of this class must be
 registered with the system as a  device
 administrator . Additionally a device administrator may be registered as either a profile or
 device owner. A given method is accessible to all device administrators unless the documentation
 for that method specifies that it is restricted to either device or profile owners. Any
 application calling an api may only pass as an argument a device administrator component it
 owns. Otherwise a  SecurityException  will be thrown."
android,app.admin,DevicePolicyManager.InstallSystemUpdateCallback,1,"Callback used in  DevicePolicyManager.installSystemUpdate(ComponentName Uri Executor DevicePolicyManager.InstallSystemUpdateCallback)  to indicate that there was an error while
 trying to install an update."
android,app.admin,FreezePeriod,3,"A class that represents one freeze period which repeats  annually . A freeze period has
 two  java.time  values that define the start and end dates of the period both
 inclusive. If the end date is earlier than the start date the period is considered wrapped
 around the year-end. As far as freeze period is concerned leap year is disregarded and February
 29th should be treated as if it were February 28th: so a freeze starting or ending on February
 28th is identical to a freeze starting or ending on February 29th. When calulating the length of
 a freeze or the distance bewteen two freee periods February 29th is also ignored."
android,app.admin,NetworkEvent,5,An abstract class that represents a network event.
android,app.admin,SystemUpdatePolicy,11,"Determines when over-the-air system updates are installed on a device. Only a device policy
 controller (DPC) running in device owner mode can set an update policy for the deviceâ€”by calling
 the  DevicePolicyManager  method
  DevicePolicyManager#setSystemUpdatePolicy . An update
 policy affects the pending system update (if there is one) and any future updates for the device.

  If a policy is set on a device the system doesn't notify the user about updates. Example The example below shows how a DPC might set a maintenance window for system updates: 
 private final MAINTENANCE_WINDOW_START = 1380; // 11pm
 private final MAINTENANCE_WINDOW_END = 120; // 2am

 // ...

 // Create the system update policy
 SystemUpdatePolicy policy = SystemUpdatePolicy.createWindowedInstallPolicy(
     MAINTENANCE_WINDOW_START MAINTENANCE_WINDOW_END);

 // Get a DevicePolicyManager instance to set the policy on the device
 DevicePolicyManager dpm =
     (DevicePolicyManager) context.getSystemService(Context.DEVICE_POLICY_SERVICE);
 ComponentName adminComponent = getComponentName(context);
 dpm.setSystemUpdatePolicy(adminComponent policy);
  Developer guide Manage system updates"
android,app.admin,DnsEvent,6,"A class that represents a DNS lookup event initiated through the standard network stack.

  It contains information about the originating app as well as the DNS hostname and resolved
 IP addresses."
android,app.admin,SecurityLog,0,"Definitions for working with security logs.

  Device owner apps can control the logging with
  DevicePolicyManager#setSecurityLoggingEnabled . When security logs are enabled device
 owner apps receive periodic callbacks from  DeviceAdminReceiver#onSecurityLogsAvailable 
 at which time new batch of logs can be collected via
  DevicePolicyManager#retrieveSecurityLogs .  SecurityEvent  describes the type and
 format of security logs being collected."
android,app.admin,SecurityLog.SecurityEvent,7,A class representing a security event log entry.
android,app.admin,SystemUpdateInfo,7,A class containing information about a pending system update.
android,app.role,RoleManager,3,"This class provides information about and manages roles.
  
 A role is a unique name within the system associated with certain privileges. The list of
 available roles might change with a system app update so apps should not make assumption about
 the availability of roles. Instead they should always query if the role is available using
  isRoleAvailable(java.lang.String)  before trying to do anything with it. Some predefined role names
 are available as constants in this class and a list of possibly available roles can be found in
 the  AndroidX Role
 library .
  
 There can be multiple applications qualifying for a role but only a subset of them can become
 role holders. To qualify for a role an application must meet certain requirements including
 defining certain components in its manifest. These requirements can be found in the AndroidX
 Libraries. Then the application will need user consent to become a role holder which can be
 requested using  Activity.startActivityForResult(Intent int)  with the
  Intent  obtained from  createRequestRoleIntent(java.lang.String) .
  
 Upon becoming a role holder the application may be granted certain privileges that are role
 specific. When the application loses its role these privileges will also be revoked."
android,android,Manifest,0,
android,android,Manifest.permission_group,0,
android,android,R.anim,0,
android,android,R.array,0,
android,android,R.color,0,
android,android,R.dimen,0,
android,android,R.integer,0,
android,android,R.layout,0,
android,android,R.raw,0,
android,android,Manifest.permission,0,
android,android,R.animator,0,
android,android,R.attr,0,
android,android,R.bool,0,
android,android,R.drawable,0,
android,android,R.fraction,0,
android,android,R.mipmap,0,
android,android,R.style,0,
android,android,R,0,
android,android,R.id,0,
android,android,R.interpolator,0,
android,android,R.menu,0,
android,android,R.plurals,0,
android,android,R.string,0,
android,android,R.styleable,0,
android,android,R.transition,0,
android,android,R.xml,0,
android,app.job,JobInfo,34,"Container of data passed to the  JobScheduler  fully encapsulating the
 parameters required to schedule work against the calling application. These are constructed
 using the  JobInfo.Builder .
 You must specify at least one sort of constraint on the JobInfo object that you are creating.
 The goal here is to provide the scheduler with high-level semantics about the work you want to
 accomplish. Doing otherwise with throw an exception in your app."
android,app.job,JobInfo.Builder,22,Builder class for constructing  JobInfo  objects.
android,app.job,JobInfo.TriggerContentUri,6,"Information about a content URI modification that a job would like to
 trigger on."
android,app.job,JobParameters,13,"Contains the parameters used to configure/identify your job. You do not create this object
 yourself instead it is handed in to your application by the System."
android,app.job,JobScheduler,6,"This is an API for scheduling various types of jobs against the framework that will be executed
 in your application's own process.
  
 See  JobInfo  for more description of the types of jobs that can be run
 and how to construct them. You will construct these JobInfo objects and pass them to the
 JobScheduler with  schedule(android.app.job.JobInfo) . When the criteria declared are met the
 system will execute this job on your application's  JobService .
 You identify the service component that implements the logic for your job when you
 construct the JobInfo using
  JobInfo.Builder.JobInfo.Builder(int android.content.ComponentName) .
  
 The framework will be intelligent about when it executes jobs and attempt to batch
 and defer them as much as possible. Typically if you don't specify a deadline on a job it
 can be run at any moment depending on the current state of the JobScheduler's internal queue.
  
 While a job is running the system holds a wakelock on behalf of your app.  For this reason
 you do not need to take any action to guarantee that the device stays awake for the
 duration of the job.
  You do not
 instantiate this class directly; instead retrieve it through
  Context.getSystemService(Context.JOB_SCHEDULER_SERVICE) ."
android,app.job,JobService,3,"Entry point for the callback from the  JobScheduler . This is the base class that handles asynchronous requests that were previously scheduled. You
 are responsible for overriding  JobService#onStartJob(JobParameters)  which is where
 you will implement your job logic. This service executes each incoming job on a  Handler  running on your
 application's main thread. This means that you  must  offload your execution logic to
 another thread/handler/ AsyncTask  of your choosing. Not doing so will result
 in blocking any future callbacks from the JobManager - specifically
  onStopJob(android.app.job.JobParameters)  which is meant to inform you that the
 scheduling requirements are no longer being met."
android,app.job,JobServiceEngine,4,"Helper for implementing a  Service  that interacts with
  JobScheduler .  This is not intended for use by regular applications but
 allows frameworks built on top of the platform to create their own
  Service  that interact with  JobScheduler  as well as
 add in additional functionality.  If you just want to execute jobs normally you
 should instead be looking at  JobService ."
android,app.job,JobWorkItem,7,"A unit of work that can be enqueued for a job using
  JobScheduler#enqueue .  See
  JobParameters#dequeueWork()  for more details."
android,app.backup,BackupAgent,10,"Provides the central interface between an
 application and Android's data backup infrastructure.  An application that wishes
 to participate in the backup and restore mechanism will declare a subclass of
  BackupAgent  implement the
  onBackup() 
 and  onRestore()  methods
 and provide the name of its backup agent class in its  AndroidManifest.xml  file via
 the  <application> 
 tag's  android:backupAgent  attribute."
android,app.backup,BackupAgentHelper,3,"A convenient  BackupAgent  wrapper class that automatically manages
 heterogeneous data sets within the backup data each identified by a unique
 key prefix.  When processing a backup or restore operation the BackupAgentHelper
 dispatches to one or more installed  BackupHelper  objects each
 of which is responsible for a defined subset of the data being processed.
  
 An application will typically extend this class in its own
 backup agent. Then within the agent's  BackupAgent#onCreate() 
 method it will call  addHelper()  one or more times to
 install the handlers for each kind of data it wishes to manage within its backups.
  
 The Android framework currently provides two predefined  BackupHelper  classes: FileBackupHelper  - Manages the backup and restore of entire files
 within an application's data directory hierarchy. SharedPreferencesBackupHelper  - Manages the backup and restore of an
 application's  SharedPreferences  data. 
 An application can also implement its own helper classes to work within the
  BackupAgentHelper  framework.  See the  BackupHelper  interface
 documentation for details."
android,app.backup,BackupDataInput,5,"Provides the structured interface through which a  BackupAgent  reads
 information from the backup data set via its
  BackupAgent#onRestore(BackupDataInput int android.os.ParcelFileDescriptor) 
 method.  The data is presented as a set of ""entities"" each
 representing one named record as previously stored by the agent's
  BackupAgent#onBackup(ParcelFileDescriptorBackupDataOutputParcelFileDescriptor)  implementation.  An entity is composed of a descriptive header plus a
 byte array that holds the raw data saved in the remote backup.
  
 The agent must consume every entity in the data stream otherwise the
 restored state of the application will be incomplete.
  Example 
 A typical
  BackupAgent#onRestore(BackupDataInputintParcelFileDescriptor)  implementation might be structured something like this:
  
 public void onRestore(BackupDataInput data int appVersionCode
                       ParcelFileDescriptor newState) {
     while (data.readNextHeader()) {
         String key = data.getKey();
         int dataSize = data.getDataSize();

         if (key.equals(MY_BACKUP_KEY_ONE)) {
             // process this kind of record here
             byte[] buffer = new byte[dataSize];
             data.readEntityData(buffer 0 dataSize); // reads the entire entity at once

             // now 'buffer' holds the raw data and can be processed however
             // the agent wishes
             processBackupKeyOne(buffer);
         } else if (key.equals(MY_BACKUP_KEY_TO_IGNORE) {
             // a key we recognize but wish to discard
             data.skipEntityData();
         } // ... etc.
    }
 }"
android,app.backup,BackupDataInputStream,5,"Provides an  InputStream -like interface for accessing an
 entity's data during a restore operation. Used by  BackupHelper  classes within the  BackupAgentHelper  mechanism.
  
 When  BackupHelper#restoreEntity(BackupDataInputStream) 
 is called the current entity's header has already been read from the underlying
  BackupDataInput .  The entity's key string and total data size are available
 through this class's  getKey()  and  size()  methods respectively.
  Note:  The caller should take care not to seek or close the underlying data
 source nor read more than  size()  bytes from the stream."
android,app.backup,BackupDataOutput,4,"Provides the structured interface through which a  BackupAgent  commits
 information to the backup data set via its  BackupAgent#onBackup(ParcelFileDescriptorBackupDataOutputParcelFileDescriptor)  method.  Data written for backup is presented
 as a set of ""entities"" key/value pairs in which each binary data record ""value"" is
 named with a string ""key.""
  
 To commit a data record to the backup transport the agent's
  BackupAgent#onBackup(ParcelFileDescriptorBackupDataOutputParcelFileDescriptor)  method first writes an ""entity header"" that supplies the key string for the record
 and the total size of the binary value for the record.  After the header has been
 written the agent then writes the binary entity value itself.  The entity value can
 be written in multiple chunks if desired as long as the total count of bytes written
 matches what was supplied to  writeEntityHeader() .
  
 Entity key strings are considered to be unique within a given application's backup
 data set. If a backup agent writes a new entity under an existing key string its value will
 replace any previous value in the transport's remote data store.  You can remove a record
 entirely from the remote data set by writing a new entity header using the
 existing record's key but supplying a negative  dataSize  parameter.
 When you do so the agent does not need to call  writeEntityData(byte[] int) .
  Example 
 Here is an example illustrating a way to back up the value of a String variable
 called  mStringToBackUp :
  
 static final String MY_STRING_KEY = ""storedstring"";

 public void  BackupAgent#onBackup(ParcelFileDescriptor BackupDataOutput ParcelFileDescriptor) 
         throws IOException {
     ...
     byte[] stringBytes = mStringToBackUp.getBytes();
     data.writeEntityHeader(MY_STRING_KEY stringBytes.length);
     data.writeEntityData(stringBytes stringBytes.length);
     ...
 }"
android,app.backup,BackupManager,4,"The interface through which an application interacts with the Android backup service to
 request backup and restore operations.
 Applications instantiate it using the constructor and issue calls through that instance.
  
 When an application has made changes to data which should be backed up a
 call to  dataChanged()  will notify the backup service. The system
 will then schedule a backup operation to occur in the near future. Repeated
 calls to  dataChanged()  have no further effect until the backup
 operation actually occurs.
  
 A backup or restore operation for your application begins when the system launches the
  BackupAgent  subclass you've declared in your manifest. See the
 documentation for  BackupAgent  for a detailed description
 of how the operation then proceeds.
  
 Several attributes affecting the operation of the backup and restore mechanism
 can be set on the  <application> 
 tag in your application's AndroidManifest.xml file."
android,app.backup,FullBackupDataOutput,2,"Provides the interface through which a  BackupAgent  writes entire files
 to a full backup data set via its  BackupAgent#onFullBackup(FullBackupDataOutput) 
 method."
android,app.backup,RestoreObserver,3,"Callback class for receiving progress reports during a restore operation.  These
 methods will all be called on your application's main thread."
android,app.backup,FileBackupHelper,3,"A helper class that can be used in conjunction with
  BackupAgentHelper  to manage the backup of a set of
 files. Whenever backup is performed all files changed since the last backup
 will be saved in their entirety. When backup first occurs
 every file in the list provided to  FileBackupHelper(Context String...)  will be backed up.
  
 During restore if the helper encounters data for a file that was not
 specified when the FileBackupHelper object was constructed that data
 will be ignored.
  Note:  This should be
 used only with small configuration files not large binary files."
android,app.backup,SharedPreferencesBackupHelper,3,"A helper class that can be used in conjunction with
  BackupAgentHelper  to manage the backup of
  SharedPreferences . Whenever a backup is performed it
 will back up all named shared preferences that have changed since the last
 backup operation.
  
 To use this class the application's backup agent class should extend
  BackupAgentHelper .  Then in the agent's
  BackupAgent#onCreate()  method an instance of this class should be
 allocated and installed as a backup/restore handler within the BackupAgentHelper
 framework.  For example an agent supporting backup and restore for
 an application with two groups of  SharedPreferences 
 data might look something like this:
  
 import android.app.backup.BackupAgentHelper;
 import android.app.backup.SharedPreferencesBackupHelper;

 public class MyBackupAgent extends BackupAgentHelper {
     // The names of the SharedPreferences groups that the application maintains.  These
     // are the same strings that are passed to  Context#getSharedPreferences(String int) .
     static final String PREFS_DISPLAY = ""displayprefs"";
     static final String PREFS_SCORES = ""highscores"";

     // An arbitrary string used within the BackupAgentHelper implementation to
     // identify the SharedPreferenceBackupHelper's data.
     static final String MY_PREFS_BACKUP_KEY = ""myprefs"";

     // Allocate a helper and install it.
     public void onCreate() {
         SharedPreferencesBackupHelper helper =
                 new SharedPreferencesBackupHelper(this PREFS_DISPLAY PREFS_SCORES);
         addHelper(MY_PREFS_BACKUP_KEY helper);
     }
 } 
 No further implementation is needed; the  BackupAgentHelper  mechanism automatically
 dispatches the
  BackupAgent#onBackup(android.os.ParcelFileDescriptor BackupDataOutput android.os.ParcelFileDescriptor) 
 and
  BackupAgent#onRestore(BackupDataInput int android.os.ParcelFileDescriptor) 
 callbacks to the SharedPreferencesBackupHelper as appropriate."
android,app.slice,Slice,7,"A slice is a piece of app content and actions that can be surfaced outside of the app.

  They are constructed using  Builder  in a tree structure
 that provides the OS some information about how the content should be displayed."
android,app.slice,Slice.Builder,11,A Builder used to construct  Slice s
android,app.slice,SliceItem,14,"A SliceItem is a single unit in the tree structure of a  Slice .

 A SliceItem a piece of content and some hints about what that content
 means or how it should be displayed. The types of content can be:
  FORMAT_SLICE FORMAT_TEXT FORMAT_IMAGE FORMAT_ACTION FORMAT_INT FORMAT_LONG FORMAT_REMOTE_INPUT FORMAT_BUNDLE SliceItem Slice"
android,app.slice,SliceManager,11,"Class to handle interactions with  Slice s.
  
 The SliceManager manages permissions and pinned state for slices."
android,app.slice,SliceMetrics,3,"Metrics interface for slices.

 This is called by SliceView so Slice developers should
 not need to reference this class."
android,app.slice,SliceProvider,15,"A SliceProvider allows an app to provide content to be displayed in system spaces. This content
 is templated and can contain actions and the behavior of how it is surfaced is specific to the
 system surface.
  
 Slices are not currently live content. They are bound once and shown to the user. If the content
 changes due to a callback from user interaction then
  ContentResolver#notifyChange(Uri ContentObserver)  should be used to notify the system.
  
 The provider needs to be declared in the manifest to provide the authority for the app. The
 authority for most slices is expected to match the package of the application.
  
 <provider
     android:name=""com.example.mypkg.MySliceProvider""
     android:authorities=""com.example.mypkg"" />
  
 Slices can be identified by a Uri or by an Intent. To link an Intent with a slice the provider
 must have an  IntentFilter  matching the slice intent. When a slice is being requested via
 an intent  onMapIntentToUri(android.content.Intent)  can be called and is expected to return an
 appropriate Uri representing the slice.

  
 <provider
     android:name=""com.example.mypkg.MySliceProvider""
     android:authorities=""com.example.mypkg"">
     <intent-filter>
         <action android:name=""com.example.mypkg.intent.action.MY_SLICE_INTENT"" />
         <category android:name=""android.app.slice.category.SLICE"" />
     </intent-filter>
 </provider>"
android,app.slice,SliceSpec,7,"Class describing the structure of the data contained within a slice.
  
 A data version contains a string which describes the type of structure
 and a revision which denotes this specific implementation. Revisions are expected
 to be backwards compatible and monotonically increasing. Meaning if a
 SliceSpec has the same type and an equal or lesser revision
 it is expected to be compatible.
  
 Apps rendering slices will provide a list of supported versions to the OS which
 will also be given to the app. Apps should only return a  Slice  with a
  SliceSpec  that one of the supported  SliceSpec s provided
  canRender(SliceSpec) ."
android,appwidget,AppWidgetHost,13,"AppWidgetHost provides the interaction with the AppWidget service for apps
 like the home screen that want to embed AppWidgets in their UI."
android,appwidget,AppWidgetHostView,16,"Provides the glue to show AppWidget views. This class offers automatic animation
 between updates and will try recycling old views for each incoming
  RemoteViews ."
android,appwidget,AppWidgetManager,21,"Updates AppWidget state; gets information about installed AppWidget providers and other
 AppWidget related state."
android,appwidget,AppWidgetProvider,7,"A convenience class to aid in implementing an AppWidget provider.
 Everything you can do with AppWidgetProvider you can do with a regular  BroadcastReceiver .
 AppWidgetProvider merely parses the relevant fields out of the Intent that is received in
  onReceive(ContextIntent)  and calls hook methods
 with the received extras.

  Extend this class and override one or more of the  onUpdate(Context AppWidgetManager int[])   onDeleted(Context int[]) 
  onEnabled(Context)  or  onDisabled(Context)  methods to implement your own AppWidget functionality."
android,appwidget,AppWidgetProviderInfo,8,"Describes the meta data for an installed AppWidget provider.  The fields in this class
 correspond to the fields in the  <appwidget-provider>  xml tag."
android,app.usage,ConfigurationStats,8,"Represents the usage statistics of a device  Configuration  for a
 specific time range."
android,app.usage,EventStats,9,"Contains usage statistics for an event type for a specific
 time range."
android,app.usage,ExternalStorageStats,7,"Shared/external storage statistics for a  UserHandle  on a single
 storage volume."
android,app.usage,NetworkStatsManager,10,"Provides access to network usage history and statistics. Usage data is collected in
 discrete bins of time called 'Buckets'. See  NetworkStats.Bucket  for details.
  
 Summary queries
  querySummaryForDevice(int String long long) querySummaryForUser(int String long long) querySummary(int String long long) 
 History queries
  queryDetailsForUid(int String long long int) queryDetails(int String long long) state NetworkStats.Bucket#STATE_ALL defaultNetwork NetworkStats.Bucket#DEFAULT_NETWORK_ALL metered  NetworkStats.Bucket#METERED_ALL roaming NetworkStats.Bucket#ROAMING_ALL NOTE: querySummaryForDevice(int String long long) Manifest.permission.PACKAGE_USAGE_STATS querySummaryForDevice(int String long long) NOTE: android.os.Build.VERSION_CODES.N"
android,app.usage,StorageStats,5,"Storage statistics for a UID package or  UserHandle  on a single
 storage volume."
android,app.usage,UsageEvents,4,"A result returned from  UsageStatsManager.queryEvents(long long) 
 from which to read  UsageEvents.Event  objects."
android,app.usage,UsageEvents.Event,7,An event representing a state change for a component.
android,app.usage,NetworkStats,4,"Class providing enumeration over buckets of network usage statistics.  NetworkStats  objects
 are returned as results to various queries in  NetworkStatsManager ."
android,app.usage,NetworkStats.Bucket,12,"Buckets are the smallest elements of a query result. As some dimensions of a result may be
 aggregated (e.g. time or state) some values may be equal across all buckets."
android,app.usage,NetworkStatsManager.UsageCallback,1,Base class for usage callbacks. Should be extended by applications wanting notifications.
android,app.usage,StorageStatsManager,6,"Access to detailed storage statistics. This provides a summary of how apps
 users and external/shared storage is utilizing disk space.
  
 Note: no permissions are required when calling these APIs for your own
 package or UID. However requesting details for any other package requires
 the  android.Manifest.permission#PACKAGE_USAGE_STATS  permission which
 is a system-level permission that will not be granted to normal apps.
 Declaring that permission expresses your intention to use this API and an end
 user can then choose to grant this permission through the Settings
 application."
android,app.usage,UsageStats,12,"Contains usage statistics for an app package for a specific
 time range."
android,app.usage,UsageStatsManager,8,"Provides access to device usage history and statistics. Usage data is aggregated into
 time intervals: days weeks months and years.
  
 PAST                   REQUEST_TIME                    TODAY                   FUTURE
 â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”||â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”Â¦-----------------------|
                        YEAR ||                           Â¦                       |
 â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”||â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”Â¦-----------------------|
  MONTH            |         ||                MONTH      Â¦                       |
 â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”|â€”â€”â€”â€”â€”â€”â€”â€”â€”||â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”Â¦-----------------------|
   |      WEEK     |     WEEK||    |     WEEK     |     WEÂ¦EK     |      WEEK     |
 â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”||â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”|â€”â€”â€”â€”â€”â€”â€”Â¦-----------------------|
                             ||           |DAY|DAY|DAY|DAYÂ¦DAY|DAY|DAY|DAY|DAY|DAY|
 â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”||â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”Â¦-----------------------|
  NOTE: Settings.ACTION_USAGE_ACCESS_SETTINGS getAppStandbyBucket() queryEventsForSelf(long long)"
android,companion,AssociationRequest,5,"A request for the user to select a companion device to associate with.

 You can optionally set  Builder#addDeviceFilter  for which devices to show to the
 user to select from.
 The exact type and fields of the filter you can set depend on the
 medium type. See  Builder 's static factory methods for specific protocols that are
 supported.

 You can also set  Builder#setSingleDevice  to request a popup with single
 device to be shown instead of a list to choose from"
android,companion,AssociationRequest.Builder,3,A builder for  AssociationRequest
android,companion,BluetoothDeviceFilter,4,A filter for Bluetooth(non-LE) devices
android,companion,BluetoothDeviceFilter.Builder,4,A builder for  BluetoothDeviceFilter
android,companion,BluetoothLeDeviceFilter,6,A filter for Bluetooth LE devices
android,companion,BluetoothLeDeviceFilter.Builder,6,Builder for  BluetoothLeDeviceFilter
android,companion,CompanionDeviceManager,5,"System level service for managing companion devices

  To obtain an instance call  Context#getSystemService ( Context#COMPANION_DEVICE_SERVICE ) Then call  associate(android.companion.AssociationRequest android.companion.CompanionDeviceManager.Callback android.os.Handler)  to initiate the flow of associating current package with a
 device selected by user."
android,companion,CompanionDeviceManager.Callback,2,"A callback to receive once at least one suitable device is found or the search failed
 (e.g. timed out)"
android,companion,WifiDeviceFilter,4,A filter for Wifi devices
android,companion,WifiDeviceFilter.Builder,2,Builder for  WifiDeviceFilter
android,bluetooth.le,AdvertiseCallback,2,Bluetooth LE advertising callbacks used to deliver advertising operation status.
android,bluetooth.le,AdvertiseData,8,"Advertise data packet container for Bluetooth LE advertising. This represents the data to be
 advertised as well as the scan response data for active scans.
  
 Use  AdvertiseData.Builder  to create an instance of  AdvertiseData  to be
 advertised."
android,bluetooth.le,AdvertiseData.Builder,6,Builder for  AdvertiseData .
android,bluetooth.le,AdvertiseSettings,7,"The  AdvertiseSettings  provide a way to adjust advertising preferences for each
 Bluetooth LE advertisement instance. Use  AdvertiseSettings.Builder  to create an
 instance of this class."
android,bluetooth.le,AdvertisingSet,7,"This class provides a way to control single Bluetooth LE advertising instance.
  
 To get an instance of  AdvertisingSet  call the
  BluetoothLeAdvertiser#startAdvertisingSet  method.
  Note:  Most of the methods here require  Manifest.permission.BLUETOOTH_ADMIN 
 permission."
android,bluetooth.le,AdvertisingSetCallback,9,"Bluetooth LE advertising set callbacks used to deliver advertising operation
 status."
android,bluetooth.le,ScanSettings,8,"Bluetooth LE scan settings are passed to  BluetoothLeScanner#startScan  to define the
 parameters for the scan."
android,bluetooth.le,AdvertiseSettings.Builder,5,Builder class for  AdvertiseSettings .
android,bluetooth.le,AdvertisingSetParameters,12,"The  AdvertisingSetParameters  provide a way to adjust advertising
 preferences for each
 Bluetooth LE advertising set. Use  AdvertisingSetParameters.Builder  to
 create an
 instance of this class."
android,bluetooth.le,AdvertisingSetParameters.Builder,10,Builder class for  AdvertisingSetParameters .
android,bluetooth.le,BluetoothLeAdvertiser,8,"This class provides a way to perform Bluetooth LE advertise operations such as starting and
 stopping advertising. An advertiser can broadcast up to 31 bytes of advertisement data
 represented by  AdvertiseData .
  
 To get an instance of  BluetoothLeAdvertiser  call the
  BluetoothAdapter#getBluetoothLeAdvertiser()  method.
  Note:  Most of the methods here require  Manifest.permission.BLUETOOTH_ADMIN 
 permission."
android,bluetooth.le,BluetoothLeScanner,6,"This class provides methods to perform scan related operations for Bluetooth LE devices. An
 application can scan for a particular type of Bluetooth LE devices using  ScanFilter . It
 can also request different types of callbacks for delivering the result.
  
 Use  BluetoothAdapter#getBluetoothLeScanner()  to get an instance of
  BluetoothLeScanner .
  Note:  Most of the scan methods here require
  Manifest.permission.BLUETOOTH_ADMIN  permission."
android,bluetooth.le,PeriodicAdvertisingParameters,4,"The  PeriodicAdvertisingParameters  provide a way to adjust periodic
 advertising preferences for each Bluetooth LE advertising set. Use  AdvertisingSetParameters.Builder  to create an instance of this class."
android,bluetooth.le,PeriodicAdvertisingParameters.Builder,3,
android,bluetooth.le,ScanCallback,3,Bluetooth LE scan callbacks. Scan results are reported using these callbacks.
android,bluetooth.le,ScanFilter,18,"Criteria for filtering result from Bluetooth LE scans. A  ScanFilter  allows clients to
 restrict scan results to only those that are of interest to them.
  
 Current filtering on the following fields are supported:
  Service UUIDs which identify the bluetooth gatt services running on the device.
  Name of remote Bluetooth LE device.
  Mac address of the remote device.
  Service data which is the data associated with a service.
  Manufacturer specific data which is the data associated with a particular manufacturer."
android,bluetooth.le,ScanResult,17,ScanResult for Bluetooth LE scan.
android,bluetooth.le,ScanSettings.Builder,8,Builder for  ScanSettings .
android,bluetooth.le,ScanFilter.Builder,11,Builder class for  ScanFilter .
android,bluetooth.le,ScanRecord,11,Represents a scan record from Bluetooth LE scan.
android,bluetooth,BluetoothAdapter,37,"Represents the local device Bluetooth adapter. The  BluetoothAdapter 
 lets you perform fundamental Bluetooth tasks such as initiate
 device discovery query a list of bonded (paired) devices
 instantiate a  BluetoothDevice  using a known MAC address and create
 a  BluetoothServerSocket  to listen for connection requests from other
 devices and start a scan for Bluetooth LE devices.

  To get a  BluetoothAdapter  representing the local Bluetooth
 adapter call the  BluetoothManager#getAdapter  function on  BluetoothManager .
 On JELLY_BEAN_MR1 and below you will need to use the static  getDefaultAdapter() 
 method instead.
  
 Fundamentally this is your starting point for all
 Bluetooth actions. Once you have the local adapter you can get a set of
  BluetoothDevice  objects representing all paired devices with
  getBondedDevices() ; start device discovery with
  startDiscovery() ; or create a  BluetoothServerSocket  to
 listen for incoming RFComm connection requests with  listenUsingRfcommWithServiceRecord(java.lang.String java.util.UUID) ; listen for incoming L2CAP Connection-oriented
 Channels (CoC) connection requests with  listenUsingL2capChannel() ; or start a scan for
 Bluetooth LE devices with  startLeScan(android.bluetooth.BluetoothAdapter.LeScanCallback) .
  This class is thread safe. Note: 
 Most methods require the  Manifest.permission.BLUETOOTH 
 permission and some also require the
  Manifest.permission.BLUETOOTH_ADMIN  permission."
android,bluetooth,BluetoothAssignedNumbers,0,"Bluetooth Assigned Numbers.
  
 For now we only include Company ID values."
android,bluetooth,BluetoothClass,8,"Represents a Bluetooth class which describes general characteristics
 and capabilities of a device. For example a Bluetooth class will
 specify the general device type such as a phone a computer or
 headset and whether it's capable of services such as audio or telephony.

  Every Bluetooth class is composed of zero or more service classes and
 exactly one device class. The device class is further broken down into major
 and minor device class components.

  BluetoothClass  is useful as a hint to roughly describe a device
 (for example to show an icon in the UI) but does not reliably describe which
 Bluetooth profiles or services are actually supported by a device. Accurate
 service discovery is done through SDP requests which are automatically
 performed when creating an RFCOMM socket with  BluetoothDevice#createRfcommSocketToServiceRecord  and  BluetoothAdapter#listenUsingRfcommWithServiceRecord Use  BluetoothDevice#getBluetoothClass  to retrieve the class for
 a remote device."
android,bluetooth,BluetoothClass.Device.Major,0,"Defines all major device class constants.
  See  BluetoothClass.Device  for minor classes."
android,bluetooth,BluetoothDevice,23,"Represents a remote Bluetooth device. A  BluetoothDevice  lets you
 create a connection with the respective device or query information about
 it such as the name address class and bonding state.

  This class is really just a thin wrapper for a Bluetooth hardware
 address. Objects of this class are immutable. Operations on this class
 are performed on the remote Bluetooth hardware address using the
  BluetoothAdapter  that was used to create this  BluetoothDevice .

  To get a  BluetoothDevice  use
  BluetoothAdapter#getRemoteDevice(String)  to create one representing a device
 of a known MAC address (which you can get through device discovery with
  BluetoothAdapter ) or get one from the set of bonded devices
 returned by  BluetoothAdapter#getBondedDevices() . You can then open a
  BluetoothSocket  for communication with the remote device using
  createRfcommSocketToServiceRecord(java.util.UUID)  over Bluetooth BR/EDR or using
  createL2capChannel(int)  over Bluetooth LE.

  Note: 
 Requires the  Manifest.permission.BLUETOOTH  permission."
android,bluetooth,BluetoothGattCharacteristic,20,"Represents a Bluetooth GATT Characteristic

  A GATT characteristic is a basic data element used to construct a GATT service
  BluetoothGattService . The characteristic contains a value as well as
 additional information and optional GATT descriptors  BluetoothGattDescriptor ."
android,bluetooth,BluetoothGattDescriptor,7,"Represents a Bluetooth GATT Descriptor

   GATT Descriptors contain additional information and attributes of a GATT
 characteristic  BluetoothGattCharacteristic . They can be used to describe
 the characteristic's features or to control certain behaviours of the characteristic."
android,bluetooth,BluetoothGattService,9,"Represents a Bluetooth GATT Service

   Gatt Service contains a collection of  BluetoothGattCharacteristic 
 as well as referenced services."
android,bluetooth,BluetoothHeadset,7,"Public API for controlling the Bluetooth Headset Service. This includes both
 Bluetooth Headset and Handsfree (v1.5) profiles.

  BluetoothHeadset is a proxy object for controlling the Bluetooth Headset
 Service via IPC.

   Use  BluetoothAdapter#getProfileProxy  to get
 the BluetoothHeadset proxy object. Use
  BluetoothAdapter#closeProfileProxy  to close the service connection.

   Android only supports one connected Bluetooth Headset at a time.
 Each method is protected with its appropriate permission."
android,bluetooth,BluetoothHearingAid,3,"This class provides the public APIs to control the Hearing Aid profile.

  BluetoothHearingAid is a proxy object for controlling the Bluetooth Hearing Aid
 Service via IPC. Use  BluetoothAdapter#getProfileProxy  to get
 the BluetoothHearingAid proxy object.

   Android only supports one set of connected Bluetooth Hearing Aid device at a time. Each
 method is protected with its appropriate permission."
android,bluetooth,BluetoothManager,5,"High level manager used to obtain an instance of an  BluetoothAdapter 
 and to conduct overall Bluetooth Management.
  
 Use  Context.getSystemService(java.lang.String) 
 with  Context#BLUETOOTH_SERVICE  to create an  BluetoothManager 
 then call  getAdapter()  to obtain the  BluetoothAdapter ."
android,bluetooth,BluetoothA2dp,5,"This class provides the public APIs to control the Bluetooth A2DP
 profile.

  BluetoothA2dp is a proxy object for controlling the Bluetooth A2DP
 Service via IPC. Use  BluetoothAdapter#getProfileProxy  to get
 the BluetoothA2dp proxy object.

   Android only supports one connected Bluetooth A2dp device at a time.
 Each method is protected with its appropriate permission."
android,bluetooth,BluetoothClass.Device,0,"Defines all device class constants.
  Each  BluetoothClass  encodes exactly one device class with
 major and minor components.
  The constants in  BluetoothClass.Device  represent a combination of major and minor
 device components (the complete device class). The constants in  BluetoothClass.Device.Major  represent only major device classes.
  See  BluetoothClass.Service  for service class constants."
android,bluetooth,BluetoothClass.Service,0,"Defines all service class constants.
  Each  BluetoothClass  encodes zero or more service classes."
android,bluetooth,BluetoothGatt,24,"Public API for the Bluetooth GATT Profile.

  This class provides Bluetooth GATT functionality to enable communication
 with Bluetooth Smart or Smart Ready devices.

  To connect to a remote peripheral device create a  BluetoothGattCallback 
 and call  BluetoothDevice#connectGatt  to get a instance of this class.
 GATT capable devices can be discovered using the Bluetooth device discovery or BLE
 scan process."
android,bluetooth,BluetoothGattCallback,12,This abstract class is used to implement  BluetoothGatt  callbacks.
android,bluetooth,BluetoothGattServer,15,"Public API for the Bluetooth GATT Profile server role.

  This class provides Bluetooth GATT server role functionality
 allowing applications to create Bluetooth Smart services and
 characteristics.

  BluetoothGattServer is a proxy object for controlling the Bluetooth Service
 via IPC.  Use  BluetoothManager#openGattServer  to get an instance
 of this class."
android,bluetooth,BluetoothGattServerCallback,11,This abstract class is used to implement  BluetoothGattServer  callbacks.
android,bluetooth,BluetoothHealth,8,"Public API for Bluetooth Health Profile.

  BluetoothHealth is a proxy object for controlling the Bluetooth
 Service via IPC.

   How to connect to a health device which is acting in the source role.
   Use  BluetoothAdapter#getProfileProxy  to get
 the BluetoothHealth proxy object.   Create an  BluetoothHealth  callback and call
  registerSinkAppConfiguration(String int BluetoothHealthCallback)  to register an application
 configuration   Pair with the remote device. This currently needs to be done manually
 from Bluetooth Settings   Connect to a health device using  connectChannelToSource(BluetoothDevice BluetoothHealthAppConfiguration) . Some
 devices will connect the channel automatically. The  BluetoothHealth 
 callback will inform the application of channel state change.   Use the file descriptor provided with a connected channel to read and
 write data to the health channel.   The received data needs to be interpreted using a health manager which
 implements the IEEE 11073-xxxxx specifications.
   When done close the health channel by calling  disconnectChannel(BluetoothDevice BluetoothHealthAppConfiguration int) 
 and unregister the application configuration calling
  unregisterAppConfiguration(BluetoothHealthAppConfiguration)"
android,bluetooth,BluetoothHealthAppConfiguration,5,"The Bluetooth Health Application Configuration that is used in conjunction with
 the  BluetoothHealth  class. This class represents an application configuration
 that the Bluetooth Health third party application will register to communicate with the
 remote Bluetooth health device."
android,bluetooth,BluetoothHealthCallback,2,This abstract class is used to implement  BluetoothHealth  callbacks.
android,bluetooth,BluetoothHidDevice,10,"Provides the public APIs to control the Bluetooth HID Device profile.

  BluetoothHidDevice is a proxy object for controlling the Bluetooth HID Device Service via IPC.
 Use  BluetoothAdapter#getProfileProxy  to get the BluetoothHidDevice proxy object."
android,bluetooth,BluetoothHidDevice.Callback,7,"The template class that applications use to call callback functions on events from the HID
 host. Callback functions are wrapped in this class and registered to the Android system
 during app registration."
android,bluetooth,BluetoothHidDeviceAppQosSettings,8,"Represents the Quality of Service (QoS) settings for a Bluetooth HID Device application.

  The BluetoothHidDevice framework will update the L2CAP QoS settings for the app during
 registration."
android,bluetooth,BluetoothHidDeviceAppSdpSettings,7,"Represents the Service Discovery Protocol (SDP) settings for a Bluetooth HID Device application.

  The BluetoothHidDevice framework adds the SDP record during app registration so that the
 Android device can be discovered as a Bluetooth HID Device."
android,bluetooth,BluetoothServerSocket,5,"A listening Bluetooth socket.

  The interface for Bluetooth Sockets is similar to that of TCP sockets:
  Socket  and  ServerSocket . On the server
 side use a  BluetoothServerSocket  to create a listening server
 socket. When a connection is accepted by the  BluetoothServerSocket 
 it will return a new  BluetoothSocket  to manage the connection.
 On the client side use a single  BluetoothSocket  to both initiate
 an outgoing connection and to manage the connection.

  For Bluetooth BR/EDR the most common type of socket is RFCOMM which is the type supported by
 the Android APIs. RFCOMM is a connection-oriented streaming transport over Bluetooth BR/EDR. It
 is also known as the Serial Port Profile (SPP). To create a listening
  BluetoothServerSocket  that's ready for incoming Bluetooth BR/EDR connections use  BluetoothAdapter#listenUsingRfcommWithServiceRecord .

  For Bluetooth LE the socket uses LE Connection-oriented Channel (CoC). LE CoC is a
 connection-oriented streaming transport over Bluetooth LE and has a credit-based flow control.
 Correspondingly use  BluetoothAdapter#listenUsingL2capChannel  to create a listening  BluetoothServerSocket 
 that's ready for incoming Bluetooth LE CoC connections. For LE CoC you can use  getPsm() 
 to get the protocol/service multiplexer (PSM) value that the peer needs to use to connect to your
 socket.

   After the listening  BluetoothServerSocket  is created call  accept()  to
 listen for incoming connection requests. This call will block until a connection is established
 at which point it will return a  BluetoothSocket  to manage the connection. Once the
  BluetoothSocket  is acquired it's a good idea to call  close()  on the  BluetoothServerSocket  when it's no longer needed for accepting
 connections. Closing the  BluetoothServerSocket  will  not  close the returned
  BluetoothSocket .

  BluetoothServerSocket  is thread
 safe. In particular  close()  will always immediately abort ongoing
 operations and close the server socket.

  Note: 
 Requires the  Manifest.permission.BLUETOOTH  permission."
android,bluetooth,BluetoothSocket,9,"A connected or connecting Bluetooth socket.

  The interface for Bluetooth Sockets is similar to that of TCP sockets:
  Socket  and  ServerSocket . On the server
 side use a  BluetoothServerSocket  to create a listening server
 socket. When a connection is accepted by the  BluetoothServerSocket 
 it will return a new  BluetoothSocket  to manage the connection.
 On the client side use a single  BluetoothSocket  to both initiate
 an outgoing connection and to manage the connection.

  The most common type of Bluetooth socket is RFCOMM which is the type
 supported by the Android APIs. RFCOMM is a connection-oriented streaming
 transport over Bluetooth. It is also known as the Serial Port Profile (SPP).

  To create a  BluetoothSocket  for connecting to a known device use
  BluetoothDevice#createRfcommSocketToServiceRecord .
 Then call  connect()  to attempt a connection to the remote device.
 This call will block until a connection is established or the connection
 fails.

  To create a  BluetoothSocket  as a server (or ""host"") see the
  BluetoothServerSocket  documentation.

  Once the socket is connected whether initiated as a client or accepted
 as a server open the IO streams by calling  getInputStream()  and
  getOutputStream()  in order to retrieve  InputStream 
 and  OutputStream  objects respectively which are
 automatically connected to the socket.

  BluetoothSocket  is thread
 safe. In particular  close()  will always immediately abort ongoing
 operations and close the socket.

  Note: 
 Requires the  Manifest.permission.BLUETOOTH  permission."
android,content.res,AssetFileDescriptor,12,"File descriptor of an entry in the AssetManager.  This provides your own
 opened FileDescriptor that can be used to read the data as well as the
 offset and length of that entry's data in the file."
android,content.res,AssetFileDescriptor.AutoCloseInputStream,8,"An InputStream you can create on a ParcelFileDescriptor which will
 take care of calling  ParcelFileDescriptor#close  for you when the stream is closed."
android,content.res,AssetFileDescriptor.AutoCloseOutputStream,3,"An OutputStream you can create on a ParcelFileDescriptor which will
 take care of calling  ParcelFileDescriptor#close  for you when the stream is closed."
android,content.res,AssetManager,11,"Provides access to an application's raw asset files; see  Resources 
 for the way most applications will want to retrieve their resource data.
 This class presents a lower-level API that allows you to open and read raw
 files that have been bundled with the application as a simple stream of
 bytes."
android,content.res,AssetManager.AssetInputStream,10,
android,content.res,Configuration,22,"This class describes all device configuration information that can
 impact the resources the application retrieves.  This includes both
 user-specified configuration options (locale list and scaling) as well
 as device configurations (such as input modes screen size and screen orientation).
  You can acquire this object from  Resources  using  Resources#getConfiguration . Thus from an activity you can get it by chaining the request
 with  ContextThemeWrapper.getResources() : Configuration config = getResources().getConfiguration();"
android,content.res,ObbInfo,3,"Basic information about a Opaque Binary Blob (OBB) that reflects the info
 from the footer on the OBB file. This information may be manipulated by a
 developer with the  obbtool  program in the Android SDK."
android,content.res,ObbScanner,1,"Class to scan Opaque Binary Blob (OBB) files. Use this to get information
 about an OBB file for use in a program via  ObbInfo ."
android,content.res,Resources,54,"Class for accessing an application's resources.  This sits on top of the
 asset manager of the application (accessible through  getAssets() ) and
 provides a high-level API for getting typed data from the assets.

  The Android resource system keeps track of all non-code assets associated with an
 application. You can use this class to access your application's resources. You can generally
 acquire the  Resources  instance associated with your application
 with  getResources() . The Android SDK tools compile your application's resources into the application binary
 at build time.  To use a resource you must install it correctly in the source tree (inside
 your project's  res/  directory) and build your application.  As part of the build
 process the SDK tools generate symbols for each resource which you can use in your application
 code to access the resources. Using application resources makes it easy to update various characteristics of your
 application without modifying code andâ€”by providing sets of alternative
 resourcesâ€”enables you to optimize your application for a variety of device configurations
 (such as for different languages and screen sizes). This is an important aspect of developing
 Android applications that are compatible on different types of devices. For more information about using resources see the documentation about  Application Resources ."
android,content.res,Resources.Theme,13,"This class holds the current attribute values for a particular theme.
 In other words a Theme is a set of values for resource attributes;
 these are used in conjunction with  TypedArray 
 to resolve the final value for an attribute.

  The Theme's attributes come into play in two ways: (1) a styled
 attribute can explicit reference a value in the theme through the
 ""?themeAttribute"" syntax; (2) if no value has been defined for a
 particular styled attribute as a last resort we will try to find that
 attribute's value in the Theme.

  You will normally use the  obtainStyledAttributes(AttributeSet int[] int int)  APIs to
 retrieve XML attributes with style and theme information applied."
android,content.res,ColorStateList,12,"Lets you map  View  state sets to colors.
  ColorStateList s are created from XML resource files defined in the
 ""color"" subdirectory directory of an application's resource directory. The XML file contains
 a single ""selector"" element with a number of ""item"" elements inside. For example:
  
 <selector xmlns:android=""http://schemas.android.com/apk/res/android"">
   <item android:state_focused=""true""
           android:color=""@color/sample_focused"" />
   <item android:state_pressed=""true""
           android:state_enabled=""false""
           android:color=""@color/sample_disabled_pressed"" />
   <item android:state_enabled=""false""
           android:color=""@color/sample_disabled_not_pressed"" />
   <item android:color=""@color/sample_default"" />
 </selector>
  State specs 
 Each item defines a set of state spec and color pairs where the state spec is a series of
 attributes set to either  true  or  false  to represent inclusion or exclusion. If
 an attribute is not specified for an item it may be any value.
  
 For example the following item will be matched whenever the focused state is set; any other
 states may be set or unset:
  
 <item android:state_focused=""true""
         android:color=""@color/sample_focused"" />
  
 Typically a color state list will reference framework-defined state attributes such as
  android:state_focused  or
  android:state_enabled ; however app-defined attributes may
 also be used.
  Note:  The list of state specs will be matched against in the order that they
 appear in the XML file. For this reason more-specific items should be placed earlier in the
 file. An item with no state spec is considered to match any set of states and is generally
 useful as a final item to be used as a default.
  
 If an item with no state spec is placed before other items those items
 will be ignored.

  Item attributes 
 Each item must define an  android:color  attribute which may be
 an HTML-style hex color a reference to a color resource or -- in API 23 and above -- a theme
 attribute that resolves to a color.
  
 Starting with API 23 items may optionally define an  android:alpha 
 attribute to modify the base color's opacity. This attribute takes a either floating-point value
 between 0 and 1 or a theme attribute that resolves as such. The item's overall color is
 calculated by multiplying by the base color's alpha channel by the  alpha  value. For
 example the following item represents the theme's accent color at 50% opacity:
  
 <item android:state_enabled=""false""
         android:color=""?android:attr/colorAccent""
         android:alpha=""0.5"" />
  Developer guide 
 For more information see the guide to
  Color State
 List Resource ."
android,content.res,TypedArray,33,"Container for an array of values that were retrieved with
  Resources.Theme#obtainStyledAttributes(AttributeSet int[] int int) 
 or  Resources#obtainAttributes .  Be
 sure to call  recycle()  when done with them.

 The indices used to retrieve values from this structure correspond to
 the positions of the attributes given to obtainStyledAttributes."
android,database.sqlite,SQLiteClosable,6,"An object created from a SQLiteDatabase that can be closed.

 This class implements a primitive reference counting scheme for database objects."
android,database.sqlite,SQLiteCursor,12,"A Cursor implementation that exposes results from a query on a
  SQLiteDatabase .

 SQLiteCursor is not internally synchronized so code using a SQLiteCursor from multiple
 threads should perform its own synchronization when using the SQLiteCursor."
android,database.sqlite,SQLiteDatabase,70,"Exposes methods to manage a SQLite database.

  
 SQLiteDatabase has methods to create delete execute SQL commands and
 perform other common database management tasks.
  
 See the Notepad sample application in the SDK for an example of creating
 and managing a database.
  
 Database names must be unique within an application not across all applications.
  Localized Collation - ORDER BY 
 In addition to SQLite's default  BINARY  collator Android supplies
 two more  LOCALIZED  which changes with the system's current locale
 and  UNICODE  which is the Unicode Collation Algorithm and not tailored
 to the current locale."
android,database.sqlite,SQLiteDatabase.OpenParams,8,Wrapper for configuration parameters that are used for opening  SQLiteDatabase
android,database.sqlite,SQLiteDatabase.OpenParams.Builder,10,Builder for  OpenParams .
android,database.sqlite,SQLiteOpenHelper,13,"A helper class to manage database creation and version management.

  You create a subclass implementing  onCreate(SQLiteDatabase)   onUpgrade(SQLiteDatabase int int)  and
 optionally  onOpen(SQLiteDatabase)  and this class takes care of opening the database
 if it exists creating it if it does not and upgrading it as necessary.
 Transactions are used to make sure the database is always in a sensible state.

  This class makes it easy for  ContentProvider 
 implementations to defer opening and upgrading the database until first use
 to avoid blocking application startup with long-running database upgrades.

  For an example see the NotePadProvider class in the NotePad sample application
 in the  samples/  directory of the SDK. Note:  this class assumes
 monotonically increasing version numbers for upgrades. Note:  the  AutoCloseable  interface was
 first added in the  Build.VERSION_CODES.Q  release."
android,database.sqlite,SQLiteProgram,9,"A base class for compiled SQLite programs.
  
 This class is not thread-safe."
android,database.sqlite,SQLiteQuery,1,"Represents a query that reads the resulting rows into a  SQLiteQuery .
 This class is used by  SQLiteCursor  and isn't useful itself.
  
 This class is not thread-safe."
android,database.sqlite,SQLiteQueryBuilder,25,"This is a convenience class that helps build SQL queries to be sent to
  SQLiteDatabase  objects."
android,database.sqlite,SQLiteStatement,7,"Represents a statement that can be executed against a database.  The statement
 cannot return multiple rows or columns but single value (1 x 1) result sets
 are supported.
  
 This class is not thread-safe."
android,database,AbstractCursor,51,"This is an abstract cursor class that handles a lot of the common code
 that all cursors need to deal with and is provided for convenience reasons."
android,database,AbstractCursor.SelfContentObserver,2,Cursors use this class to track changes others make to their URI.
android,database,AbstractWindowedCursor,18,"A base class for Cursors that store their data in  CursorWindow s.
  
 The cursor owns the cursor window it uses.  When the cursor is closed
 its window is also closed.  Likewise when the window used by the cursor is
 changed its old window is closed.  This policy of strict ownership ensures
 that cursor windows are not leaked.
  
 Subclasses are responsible for filling the cursor window with data during
  AbstractCursor.onMove(int int)  allocating a new cursor window if necessary.
 During  AbstractCursor.requery()  the existing cursor window should be cleared and
 filled with new data.
  
 If the contents of the cursor change or become invalid the old window must be closed
 (because it is owned by the cursor) and set to null."
android,database,ContentObservable,4,"A specialization of  Observable  for  ContentObserver 
 that provides methods for sending notifications to a list of
  ContentObserver  objects."
android,database,CrossProcessCursorWrapper,3,"Cursor wrapper that implements  CrossProcessCursor .
  
 If the wrapped cursor implements  CrossProcessCursor  then the wrapper
 delegates  fillWindow(int CursorWindow)   getWindow()  and  onMove(int int)  to it.
 Otherwise the wrapper provides default implementations of these methods that
 traverse the contents of the cursor similar to  AbstractCursor#fillWindow .
  
 This wrapper can be used to adapt an ordinary  Cursor  into a
  CrossProcessCursor ."
android,database,CursorJoiner,4,"Does a join on two cursors using the specified columns. The cursors must already
 be sorted on each of the specified columns in ascending order. This joiner only
 supports the case where the tuple of key column values is unique.
  
 Typical usage:

  
 CursorJoiner joiner = new CursorJoiner(cursorA keyColumnsofA cursorB keyColumnsofB);
 for (CursorJoiner.Result joinerResult : joiner) {
     switch (joinerResult) {
         case LEFT:
             // handle case where a row in cursorA is unique
             break;
         case RIGHT:
             // handle case where a row in cursorB is unique
             break;
         case BOTH:
             // handle case where a row with the same key is in both cursors
             break;
     }
 }"
android,database,DatabaseUtils,47,Static utility methods for dealing with databases and  Cursor s.
android,database,DataSetObservable,2,"A specialization of  Observable  for  DataSetObserver 
 that provides methods for sending notifications to a list of
  DataSetObserver  objects."
android,database,Observable,3,"Provides methods for registering or unregistering arbitrary observers in an  ArrayList .

 This abstract class is intended to be subclassed and specialized to maintain
 a registry of observers of specific types and dispatch notifications to them."
android,database,CharArrayBuffer,0,This is used for  Cursor#copyStringToBuffer
android,database,ContentObserver,5,"Receives call backs for changes to content.
 Must be implemented by objects which are added to a  ContentObservable ."
android,database,DatabaseUtils.InsertHelper,15,"This class allows users to do multiple inserts into a table using
 the same statement.
  
 This class is not thread-safe."
android,database,MatrixCursor,14,"A mutable cursor implementation backed by an array of  Object s. Use
  newRow()  to add rows. Automatically expands internal capacity
 as needed."
android,database,MatrixCursor.RowBuilder,2,"Builds a row of values using either of these approaches:
  Values can be added with explicit column ordering using
  add(java.lang.Object)  which starts from the left-most column and adds one
 column value at a time. This follows the same ordering as the column
 names specified at cursor construction time.
  Column and value pairs can be offered for possible inclusion using
  add(java.lang.String java.lang.Object) . If the cursor includes the given column
 the value will be set for that column otherwise the value is ignored.
 This approach is useful when matching data to a custom projection.
  null"
android,database,MergeCursor,19,"A convenience class that lets you present an array of Cursors as a single linear Cursor.
 The schema of the cursors presented is entirely up to the creator of the MergeCursor and
 may be different if that is desired. Calls to getColumns getColumnIndex etc will return the
 value for the row that the MergeCursor is currently pointing at."
android,database,CursorWindow,32,"A buffer containing multiple cursor rows.
  
 A  CursorWindow  is read-write when initially created and used locally.
 When sent to a remote process (by writing it to a  Parcel ) the remote process
 receives a read-only view of the cursor window.  Typically the cursor window
 will be allocated by the producer filled with data and then sent to the
 consumer for reading."
android,database,CursorWrapper,44,"Wrapper class for Cursor that delegates all calls to the actual cursor object.  The primary
 use for this class is to extend a cursor while overriding only a subset of its methods."
android,database,DataSetObserver,2,"Receives call backs when a data set has been changed or made invalid. The typically data sets
 that are observed are  Cursor s or  Adapter s.
 DataSetObserver must be implemented by objects which are added to a DataSetObservable."
android,database,DefaultDatabaseErrorHandler,1,"Default class used to define the action to take when database corruption is reported
 by sqlite.
  
 An application can specify an implementation of  DatabaseErrorHandler  on the
 following:
  SQLiteDatabase#openOrCreateDatabase(String
      android.database.sqlite.SQLiteDatabase.CursorFactory DatabaseErrorHandler) SQLiteDatabase#openDatabase(String
      android.database.sqlite.SQLiteDatabase.CursorFactory int DatabaseErrorHandler) DatabaseErrorHandler 
 If null is specified for the DatabaseErrorHandler param in the above calls this class is used
 as the default  DatabaseErrorHandler ."
android,content.pm,ActivityInfo.WindowLayout,0,"Contains information about position and size of the activity on the display.

 Used in freeform mode to set desired position when activity is first launched.
 It describes how big the activity wants to be in both width and height
 the minimal allowed size and the gravity to be applied."
android,content.pm,ChangedPackages,4,"Packages that have been changed since the last time they
 were requested."
android,content.pm,ConfigurationInfo,4,"Information you can retrieve about hardware configuration preferences
 declared by an application. This corresponds to information collected from the
 AndroidManifest.xml's <uses-configuration> and <uses-feature> tags."
android,content.pm,CrossProfileApps,4,"Class for handling cross profile operations. Apps can use this class to interact with its
 instance in any profile that is in  getTargetUserProfiles() . For example app can
 use this class to start its main activity in managed profile."
android,content.pm,FeatureGroupInfo,2,"A set of features that can be requested by an application. This corresponds
 to information collected from the
 AndroidManifest.xml's  <feature-group>  tag."
android,content.pm,InstrumentationInfo,3,"Information you can retrieve about a particular piece of test
 instrumentation.  This corresponds to information collected
 from the AndroidManifest.xml's <instrumentation> tag."
android,content.pm,LabeledIntent,8,"A special subclass of Intent that can have a custom label/icon
 associated with it.  Primarily for use with  Intent#ACTION_CHOOSER ."
android,content.pm,LauncherActivityInfo,8,"A representation of an activity that can belong to this user or a managed
 profile associated with this user. It can be used to query the label icon
 and badged icon for the activity."
android,content.pm,LauncherApps.Callback,9,Callbacks for package changes to this and related managed profiles.
android,content.pm,LauncherApps.ShortcutQuery,5,Represents a query passed to  LauncherApps.getShortcuts(android.content.pm.LauncherApps.ShortcutQuery android.os.UserHandle) .
android,content.pm,PackageInstaller.Session,16,"An installation that is being actively staged. For an install to succeed
 all existing and new packages must have identical package names version
 codes and signing certificates.
  
 A session may contain any number of split packages. If the application
 does not yet exist this session must include a base package.
  
 If an APK included in this session is already defined by the existing
 installation (for example the same split name) the APK in this session
 will replace the existing APK.
  
 In such a case that multiple packages need to be committed simultaneously
 multiple sessions can be referenced by a single multi-package session.
 This session is created with no package name and calling
  SessionParams#setMultiPackage() . The individual session IDs can be
 added with  addChildSessionId(int)  and commit of the multi-package
 session will result in all child sessions being committed atomically."
android,content.pm,PackageInstaller.SessionParams,13,Parameters for creating a new  PackageInstaller.Session .
android,content.pm,PackageManager,107,"Class for retrieving various kinds of information related to the application
 packages that are currently installed on the device.

 You can find this class through  Context#getPackageManager ."
android,content.pm,PackageStats,5,implementation of PackageStats associated with a application package.
android,content.pm,PathPermission,3,"Description of permissions needed to access a particular path
 in a  ProviderInfo ."
android,content.pm,PermissionInfo,6,"Information you can retrieve about a particular security permission
 known to the system.  This corresponds to information collected from the
 AndroidManifest.xml's <permission> tags."
android,content.pm,ResolveInfo,7,"Information that is returned from resolving an intent
 against an IntentFilter. This partially corresponds to
 information collected from the AndroidManifest.xml's
 <intent> tags."
android,content.pm,ServiceInfo,5,"Information you can retrieve about a particular application
 service. This corresponds to information collected from the
 AndroidManifest.xml's <service> tags."
android,content.pm,ShortcutInfo.Builder,15,Builder class for  ShortcutInfo  objects.
android,content.pm,ShortcutManager,19,"ShortcutManager  executes operations on an app's set of  shortcuts  which
 represent specific tasks and actions that users can perform within your app. This page lists
 components of the  ShortcutManager  class that you can use to create and manage
 sets of shortcuts.

  To learn about methods that retrieve information about a single shortcutâ€”including
 identifiers type and statusâ€”read the  ShortcutInfo  reference.

  For guidance about using shortcuts see
  App shortcuts .

  Retrieving class instances"
android,content.pm,Signature,8,"Opaque immutable representation of a signing certificate associated with an
 application package.
  
 This class name is slightly misleading since it's not actually a signature."
android,content.pm,SigningInfo,6,Information pertaining to the signing certificates used to sign a package.
android,content.pm,ActivityInfo,5,"Information you can retrieve about a particular application
 activity or receiver. This corresponds to information collected
 from the AndroidManifest.xml's <activity> and
 <receiver> tags."
android,content.pm,ApplicationInfo,9,"Information you can retrieve about a particular application.  This
 corresponds to information collected from the AndroidManifest.xml's
 <application> tag."
android,content.pm,ApplicationInfo.DisplayNameComparator,1,
android,content.pm,ComponentInfo,7,"Base class containing information common to all application components
 ( ActivityInfo   ServiceInfo ).  This class is not intended
 to be used by itself; it is simply here to share common definitions
 between all application components.  As such it does not itself
 implement Parcelable but does provide convenience methods to assist
 in the implementation of Parcelable in subclasses."
android,content.pm,FeatureInfo,4,"Definition of a single optional hardware or software feature of an Android
 device.
  
 This object is used to represent both features supported by a device and
 features requested by an app. Apps can request that certain features be
 available as a prerequisite to being installed through the
  uses-feature  tag in their manifests.
  
 Starting in  Build.VERSION_CODES.N  features can have a
 version which must always be backwards compatible. That is a device
 claiming to support version 3 of a specific feature must support apps
 requesting version 1 of that feature."
android,content.pm,LauncherApps,27,"Class for retrieving a list of launchable activities for the current user and any associated
 managed profiles that are visible to the current user which can be retrieved with
  getProfiles() . This is mainly for use by launchers.

 Apps can be queried for each user profile.
 Since the PackageManager will not deliver package broadcasts for other profiles you can register
 for package changes here.
  
 To watch for managed profiles being added or removed register for the following broadcasts:
  Intent#ACTION_MANAGED_PROFILE_ADDED  and  Intent#ACTION_MANAGED_PROFILE_REMOVED .
  
 Note as of Android O apps on a managed profile are no longer allowed to access apps on the
 main profile.  Apps can only access profiles returned by  getProfiles() ."
android,content.pm,PackageInstaller,16,"Offers the ability to install upgrade and remove applications on the
 device. This includes support for apps packaged either as a single
 ""monolithic"" APK or apps packaged as multiple ""split"" APKs.
  
 An app is delivered for installation through a
  PackageInstaller.Session  which any app can create. Once the session
 is created the installer can stream one or more APKs into place until it
 decides to either commit or destroy the session. Committing may require user
 intervention to complete the installation unless the caller falls into one of the
 following categories in which case the installation will complete automatically.
  the device owner
  the affiliated profile owner
  
 Sessions can install brand new apps upgrade existing apps or add new splits
 into an existing app.
  
 Apps packaged as multiple split APKs always consist of a single ""base"" APK
 (with a  null  split name) and zero or more ""split"" APKs (with unique
 split names). Any subset of these APKs can be installed together as long as
 the following constraints are met:
  All APKs must have the exact same package name version code and signing
 certificates.
  All APKs must have unique split names.
  All installations must contain a single base APK.
  
 The ApiDemos project contains examples of using this API:
  ApiDemos/src/com/example/android/apis/content/InstallApk*.java ."
android,content.pm,PackageInstaller.SessionCallback,5,"Events for observing session lifecycle.
  
 A typical session lifecycle looks like this:
  An installer creates a session to indicate pending app delivery. All
 install details are available at this point.
  The installer opens the session to deliver APK data. Note that a
 session may be opened and closed multiple times as network connectivity
 changes. The installer may deliver periodic progress updates.
  The installer commits or abandons the session resulting in the
 session being finished."
android,content.pm,PackageItemInfo.DisplayNameComparator,1,
android,content.pm,SharedLibraryInfo,9,"This class provides information for a shared library. There are
 three types of shared libraries: builtin - non-updatable part of
 the OS; dynamic - updatable backwards-compatible dynamically linked;
 static - non backwards-compatible emulating static linking."
android,content.pm,LauncherApps.PinItemRequest,9,"Represents a ""pin shortcut"" or a ""pin appwidget"" request made by an app which is sent with
 an  LauncherApps.ACTION_CONFIRM_PIN_SHORTCUT  or  LauncherApps.ACTION_CONFIRM_PIN_APPWIDGET  intent
 respectively to the default launcher app.

  Request of the  REQUEST_TYPE_SHORTCUT  type.

  A  REQUEST_TYPE_SHORTCUT  request represents a request to pin a
  ShortcutInfo .  If the launcher accepts a request call  accept() 
 or  accept(android.os.Bundle)  with a null or empty Bundle.  No options are defined for
 pin-shortcuts requests.

  getShortcutInfo()  always returns a non-null  ShortcutInfo  for this type.

  The launcher may receive a request with a  ShortcutInfo  that is already pinned in
 which case  ShortcutInfo#isPinned()  returns true.  This means the user wants to create
 another pinned shortcut for a shortcut that's already pinned.  If the launcher accepts it
  accept()  must still be called even though the shortcut is already pinned and
 create a new pinned shortcut icon for it.

  See also  ShortcutManager  for more details.

  Request of the  REQUEST_TYPE_APPWIDGET  type.

  A  REQUEST_TYPE_SHORTCUT  request represents a request to pin a
 an AppWidget.  If the launcher accepts a request call  accept(android.os.Bundle)  with
 the appwidget integer ID set to the
  AppWidgetManager.EXTRA_APPWIDGET_ID  extra.

  getAppWidgetProviderInfo(android.content.Context)  always returns a non-null
  AppWidgetProviderInfo  for this type.

  See also  AppWidgetManager  for more details."
android,content.pm,ModuleInfo,8,"Information you can retrieve about a particular system
 module."
android,content.pm,PackageInfo,5,"Overall information about the contents of a package.  This corresponds
 to all of the information collected from AndroidManifest.xml."
android,content.pm,PackageInstaller.SessionInfo,30,Details for an active install session.
android,content.pm,PackageItemInfo,9,"Base class containing information common to all package items held by
 the package manager.  This provides a very common basic set of attributes:
 a label icon and meta-data.  This class is not intended
 to be used by itself; it is simply here to share common definitions
 between all items returned by the package manager.  As such it does not
 itself implement Parcelable but does provide convenience methods to assist
 in the implementation of Parcelable in subclasses."
android,content.pm,PermissionGroupInfo,4,"Information you can retrieve about a particular security permission
 group known to the system.  This corresponds to information collected from the
 AndroidManifest.xml's <permission-group> tags."
android,content.pm,ProviderInfo,4,"Holds information about a specific
  content provider . This is returned by
  PackageManager.resolveContentProvider() ."
android,content.pm,ResolveInfo.DisplayNameComparator,1,
android,content.pm,ShortcutInfo,24,Represents a shortcut that can be published via  ShortcutManager .
android,content.pm,VersionedPackage,6,Encapsulates a package and its version code.
android,gesture,Gesture,15,"A gesture is a hand-drawn shape on a touch screen. It can have one or multiple strokes.
 Each stroke is a sequence of timed points. A user-defined gesture can be recognized by
 a GestureLibrary."
android,gesture,GestureLibraries,4,
android,gesture,GestureOverlayView,45,"A transparent overlay for gesture input that can be placed on top of other
 widgets or contain other widgets."
android,gesture,GestureStroke,5,"A gesture stroke started on a touch down and ended on a touch up. A stroke
 consists of a sequence of timed points. One or multiple strokes form a gesture."
android,gesture,GestureUtils,5,"Utility functions for gesture processing & analysis including methods for:
  feature extraction (e.g. samplers and those for calculating bounding
 boxes and gesture path lengths);
  geometric transformation (e.g. translation rotation and scaling);
  gesture similarity comparison (e.g. calculating Euclidean or Cosine
 distances between two gestures)."
android,gesture,Prediction,1,
android,gesture,GestureLibrary,13,
android,gesture,GesturePoint,1,A timed point of a gesture stroke. Multiple points form a stroke.
android,gesture,GestureStore,15,"GestureLibrary maintains gesture examples and makes predictions on a new
 gesture"
android,gesture,OrientedBoundingBox,0,An oriented bounding box
android,drm,DrmConvertedStatus,0,"An entity class that wraps converted data conversion status and the
 offset for appending the header and body signature to the converted data.
 An instance of this class may be created two ways by the drm framework:
 a) a call to  DrmManagerClient#convertData  and
 b) a call to  DrmManagerClient#closeConvertSession .
 An valid offset value is provided only from a success call to
  DrmManagerClient#closeConvertSession ."
android,drm,DrmErrorEvent,0,"An entity class that is passed to the
  DrmManagerClient.OnErrorListener#onError  callback."
android,drm,DrmEvent,4,A base class that is used to send asynchronous event information from the DRM framework.
android,drm,DrmInfo,7,"An entity class that describes the information required to send transactions
 between a device and an online DRM server. The DRM framework achieves
 server registration license acquisition and any other server-related transactions
 by passing an instance of this class to  DrmManagerClient#processDrmInfo .
 
 The caller can retrieve the  DrmInfo  instance by passing a  DrmInfoRequest 
 instance to  DrmManagerClient#acquireDrmInfo ."
android,drm,DrmInfoEvent,0,"An entity class that is passed to the
  DrmManagerClient.OnInfoListener#onInfo  callback."
android,drm,DrmInfoRequest,6,"An entity class that is used to pass information to an online DRM server. An instance of this
 class is passed to the  DrmManagerClient#acquireDrmInfo  method to get an
 instance of a  DrmInfo ."
android,drm,DrmInfoStatus,0,"An entity class that wraps the result of communication between a device
 and an online DRM server. Specifically when the
  DrmManagerClient#processDrmInfo 
 method is called an instance of  DrmInfoStatus  is returned.
 
 This class contains the  ProcessedData  object which can be used
 to instantiate a  DrmRights  object during license acquisition."
android,drm,DrmManagerClient,31,"The main programming interface for the DRM framework. An application must instantiate this class
 to access DRM agents through the DRM framework."
android,drm,DrmRights,4,"An entity class that wraps the license information retrieved from the online DRM server.
 
 A caller can instantiate a  DrmRights  object by first invoking the
  DrmManagerClient#processDrmInfo(DrmInfo)  method and then using the resulting
  ProcessedData  object to invoke the  DrmRights#DrmRights(ProcessedData String) 
 constructor.
 
 A caller can also instantiate a  DrmRights  object by using the
  DrmRights#DrmRights(String String)  constructor which takes a path to a file
 containing rights information instead of a  ProcessedData .
 
 Please note that the account id and subscription id is not mandatory by all DRM agents
 or plugins. When account id or subscription id is not required by the specific DRM
 agent or plugin they can be either null or an empty string or any other don't-care
 string value."
android,drm,DrmSupportInfo,9,"An entity class that wraps the capability of each DRM plug-in (agent)
 such as the MIME type and file suffix the DRM plug-in can handle.
 
 Plug-in developers can expose the capability of their plug-in by passing an instance of this
 class to an application."
android,drm,DrmUtils.ExtendedMetadataParser,3,"Utility that parses extended metadata embedded in DRM constraint information.
 
 Usage example:
 
 byte[] extendedMetadata 
 Â Â Â Â  =
         constraints.getAsByteArray(DrmStore.ConstraintsColumns.EXTENDED_METADATA); 
 ExtendedMetadataParser parser = getExtendedMetadataParser(extendedMetadata); 
 Iterator keyIterator = parser.keyIterator(); 
 while (keyIterator.hasNext()) { 
     Â Â Â Â String extendedMetadataKey = keyIterator.next(); 
     Â Â Â Â String extendedMetadataValue =
             parser.get(extendedMetadataKey); 
 }"
android,drm,DrmStore,0,Defines constants that are used by the DRM framework.
android,drm,DrmStore.Action,0,Defines actions that can be performed on rights-protected content.
android,drm,DrmStore.DrmObjectType,0,Defines DRM object types.
android,drm,DrmStore.Playback,0,Defines playback states for content.
android,drm,DrmStore.RightsStatus,0,Defines status notifications for digital rights.
android,drm,DrmUtils,1,"A utility class that provides operations for parsing extended metadata embedded in
 DRM constraint information. If a DRM scheme has specific constraints beyond the standard
 constraints the constraints will show up in the
  DrmStore.ConstraintsColumns#EXTENDED_METADATA  key. You can use
  DrmUtils.ExtendedMetadataParser  to iterate over those values."
android,drm,ProcessedData,3,"An entity class that wraps the result of a
  DrmManagerClient#processDrmInfo(DrmInfo) 
 transaction between a device and a DRM server.

 In a license acquisition scenario this class holds the rights information in binary form."
android,graphics.drawable.shapes,ArcShape,7,"Creates an arc shape. The arc shape starts at a specified angle and sweeps
 clockwise drawing slices of pie.
  
 The arc can be drawn to a  Canvas  with its own
  draw(android.graphics.Canvas android.graphics.Paint)  method but more graphical control is available
 if you instead pass the ArcShape to a
  ShapeDrawable ."
android,graphics.drawable.shapes,OvalShape,3,"Defines an oval shape.
  
 The oval can be drawn to a Canvas with its own draw() method
 but more graphical control is available if you instead pass
 the OvalShape to a  ShapeDrawable ."
android,graphics.drawable.shapes,PathShape,5,"Creates geometric paths utilizing the  Path  class.
  
 The path can be drawn to a Canvas with its own draw() method
 but more graphical control is available if you instead pass
 the PathShape to a  ShapeDrawable ."
android,graphics.drawable.shapes,RectShape,7,"Defines a rectangle shape.
  
 The rectangle can be drawn to a Canvas with its own draw() method
 but more graphical control is available if you instead pass
 the RectShape to a  ShapeDrawable ."
android,graphics.drawable.shapes,RoundRectShape,6,"Creates a rounded-corner rectangle. Optionally an inset (rounded) rectangle
 can be included (to make a sort of ""O"" shape).
  
 The rounded rectangle can be drawn to a Canvas with its own draw() method
 but more graphical control is available if you instead pass
 the RoundRectShape to a  ShapeDrawable ."
android,graphics.drawable.shapes,Shape,10,"Defines a generic graphical ""shape.""
  
 Any Shape can be drawn to a Canvas with its own draw() method but more
 graphical control is available if you instead pass it to a
  ShapeDrawable .
  
 Custom Shape classes must implement  clone()  and return an instance
 of the custom Shape class."
android,content,AsyncQueryHandler.WorkerArgs,0,
android,content,AsyncTaskLoader,9,"Abstract Loader that provides an  AsyncTask  to do the work.  See
  Loader  and  LoaderManager  for more details.

  Here is an example implementation of an AsyncTaskLoader subclass that
 loads the currently installed applications from the package manager.  This
 implementation takes care of retrieving the application labels and sorting
 its result set from them monitoring for changes to the installed
 applications and rebuilding the list when a change in configuration requires
 this (such as a locale change).

  /**
 * This class holds the per-item data in our Loader.
 */
public static class AppEntry {
    public AppEntry(AppListLoader loader ApplicationInfo info) {
        mLoader = loader;
        mInfo = info;
        mApkFile = new File(info.sourceDir);
    }

    public ApplicationInfo getApplicationInfo() {
        return mInfo;
    }

    public String getLabel() {
        return mLabel;
    }

    public Drawable getIcon() {
        if (mIcon == null) {
            if (mApkFile.exists()) {
                mIcon = mInfo.loadIcon(mLoader.mPm);
                return mIcon;
            } else {
                mMounted = false;
            }
        } else if (!mMounted) {
            // If the app wasn't mounted but is now mounted reload
            // its icon.
            if (mApkFile.exists()) {
                mMounted = true;
                mIcon = mInfo.loadIcon(mLoader.mPm);
                return mIcon;
            }
        } else {
            return mIcon;
        }

        return mLoader.getContext().getResources().getDrawable(
                android.R.drawable.sym_def_app_icon);
    }

    @Override public String toString() {
        return mLabel;
    }

    void loadLabel(Context context) {
        if (mLabel == null || !mMounted) {
            if (!mApkFile.exists()) {
                mMounted = false;
                mLabel = mInfo.packageName;
            } else {
                mMounted = true;
                CharSequence label = mInfo.loadLabel(context.getPackageManager());
                mLabel = label != null ? label.toString() : mInfo.packageName;
            }
        }
    }

    private final AppListLoader mLoader;
    private final ApplicationInfo mInfo;
    private final File mApkFile;
    private String mLabel;
    private Drawable mIcon;
    private boolean mMounted;
}

/**
 * Perform alphabetical comparison of application entry objects.
 */
public static final Comparator<AppEntry> ALPHA_COMPARATOR = new Comparator<AppEntry>() {
    private final Collator sCollator = Collator.getInstance();
    @Override
    public int compare(AppEntry object1 AppEntry object2) {
        return sCollator.compare(object1.getLabel() object2.getLabel());
    }
};

/**
 * Helper for determining if the configuration has changed in an interesting
 * way so we need to rebuild the app list.
 */
public static class InterestingConfigChanges {
    final Configuration mLastConfiguration = new Configuration();
    int mLastDensity;

    boolean applyNewConfig(Resources res) {
        int configChanges = mLastConfiguration.updateFrom(res.getConfiguration());
        boolean densityChanged = mLastDensity != res.getDisplayMetrics().densityDpi;
        if (densityChanged || (configChanges&(ActivityInfo.CONFIG_LOCALE
                |ActivityInfo.CONFIG_UI_MODE|ActivityInfo.CONFIG_SCREEN_LAYOUT)) != 0) {
            mLastDensity = res.getDisplayMetrics().densityDpi;
            return true;
        }
        return false;
    }
}

/**
 * Helper class to look for interesting changes to the installed apps
 * so that the loader can be updated.
 */
public static class PackageIntentReceiver extends BroadcastReceiver {
    final AppListLoader mLoader;

    public PackageIntentReceiver(AppListLoader loader) {
        mLoader = loader;
        IntentFilter filter = new IntentFilter(Intent.ACTION_PACKAGE_ADDED);
        filter.addAction(Intent.ACTION_PACKAGE_REMOVED);
        filter.addAction(Intent.ACTION_PACKAGE_CHANGED);
        filter.addDataScheme(""package"");
        mLoader.getContext().registerReceiver(this filter);
        // Register for events related to sdcard installation.
        IntentFilter sdFilter = new IntentFilter();
        sdFilter.addAction(Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE);
        sdFilter.addAction(Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE);
        mLoader.getContext().registerReceiver(this sdFilter);
    }

    @Override public void onReceive(Context context Intent intent) {
        // Tell the loader about the change.
        mLoader.onContentChanged();
    }
}

/**
 * A custom Loader that loads all of the installed applications.
 */
public static class AppListLoader extends AsyncTaskLoader<List<AppEntry>> {
    final InterestingConfigChanges mLastConfig = new InterestingConfigChanges();
    final PackageManager mPm;

    List<AppEntry> mApps;
    PackageIntentReceiver mPackageObserver;

    public AppListLoader(Context context) {
        super(context);

        // Retrieve the package manager for later use; note we don't
        // use 'context' directly but instead the save global application
        // context returned by getContext().
        mPm = getContext().getPackageManager();
    }

    /**
     * This is where the bulk of our work is done.  This function is
     * called in a background thread and should generate a new set of
     * data to be published by the loader.
     */
    @Override public List<AppEntry> loadInBackground() {
        // Retrieve all known applications.
        List<ApplicationInfo> apps = mPm.getInstalledApplications(
                PackageManager.GET_UNINSTALLED_PACKAGES |
                PackageManager.GET_DISABLED_COMPONENTS);
        if (apps == null) {
            apps = new ArrayList<ApplicationInfo>();
        }

        final Context context = getContext();

        // Create corresponding array of entries and load their labels.
        List<AppEntry> entries = new ArrayList<AppEntry>(apps.size());
        for (int i=0; i<apps.size(); i++) {
            AppEntry entry = new AppEntry(this apps.get(i));
            entry.loadLabel(context);
            entries.add(entry);
        }

        // Sort the list.
        Collections.sort(entries ALPHA_COMPARATOR);

        // Done!
        return entries;
    }

    /**
     * Called when there is new data to deliver to the client.  The
     * super class will take care of delivering it; the implementation
     * here just adds a little more logic.
     */
    @Override public void deliverResult(List<AppEntry> apps) {
        if (isReset()) {
            // An async query came in while the loader is stopped.  We
            // don't need the result.
            if (apps != null) {
                onReleaseResources(apps);
            }
        }
        List<AppEntry> oldApps = mApps;
        mApps = apps;

        if (isStarted()) {
            // If the Loader is currently started we can immediately
            // deliver its results.
            super.deliverResult(apps);
        }

        // At this point we can release the resources associated with
        // 'oldApps' if needed; now that the new result is delivered we
        // know that it is no longer in use.
        if (oldApps != null) {
            onReleaseResources(oldApps);
        }
    }

    /**
     * Handles a request to start the Loader.
     */
    @Override protected void onStartLoading() {
        if (mApps != null) {
            // If we currently have a result available deliver it
            // immediately.
            deliverResult(mApps);
        }

        // Start watching for changes in the app data.
        if (mPackageObserver == null) {
            mPackageObserver = new PackageIntentReceiver(this);
        }

        // Has something interesting in the configuration changed since we
        // last built the app list?
        boolean configChange = mLastConfig.applyNewConfig(getContext().getResources());

        if (takeContentChanged() || mApps == null || configChange) {
            // If the data has changed since the last time it was loaded
            // or is not currently available start a load.
            forceLoad();
        }
    }

    /**
     * Handles a request to stop the Loader.
     */
    @Override protected void onStopLoading() {
        // Attempt to cancel the current load task if possible.
        cancelLoad();
    }

    /**
     * Handles a request to cancel a load.
     */
    @Override public void onCanceled(List<AppEntry> apps) {
        super.onCanceled(apps);

        // At this point we can release the resources associated with 'apps'
        // if needed.
        onReleaseResources(apps);
    }

    /**
     * Handles a request to completely reset the Loader.
     */
    @Override protected void onReset() {
        super.onReset();

        // Ensure the loader is stopped
        onStopLoading();

        // At this point we can release the resources associated with 'apps'
        // if needed.
        if (mApps != null) {
            onReleaseResources(mApps);
            mApps = null;
        }

        // Stop monitoring for changes.
        if (mPackageObserver != null) {
            getContext().unregisterReceiver(mPackageObserver);
            mPackageObserver = null;
        }
    }

    /**
     * Helper function to take care of releasing resources associated
     * with an actively loaded data set.
     */
    protected void onReleaseResources(List<AppEntry> apps) {
        // For a simple List<> there is nothing to do.  For something
        // like a Cursor we would close it here.
    }
} An example implementation of a fragment that uses the above loader to show
 the currently installed applications in a list is below.

  public static class AppListAdapter extends ArrayAdapter<AppEntry> {
    private final LayoutInflater mInflater;

    public AppListAdapter(Context context) {
        super(context android.R.layout.simple_list_item_2);
        mInflater = (LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    }

    public void setData(List<AppEntry> data) {
        clear();
        if (data != null) {
            addAll(data);
        }
    }

    /**
     * Populate new items in the list.
     */
    @Override public View getView(int position View convertView ViewGroup parent) {
        View view;

        if (convertView == null) {
            view = mInflater.inflate(R.layout.list_item_icon_text parent false);
        } else {
            view = convertView;
        }

        AppEntry item = getItem(position);
        ((ImageView)view.findViewById(R.id.icon)).setImageDrawable(item.getIcon());
        ((TextView)view.findViewById(R.id.text)).setText(item.getLabel());

        return view;
    }
}

public static class AppListFragment extends ListFragment
        implements OnQueryTextListener OnCloseListener
        LoaderManager.LoaderCallbacks<List<AppEntry>> {

    // This is the Adapter being used to display the list's data.
    AppListAdapter mAdapter;

    // The SearchView for doing filtering.
    SearchView mSearchView;

    // If non-null this is the current filter the user has provided.
    String mCurFilter;

    @Override public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        // Give some text to display if there is no data.  In a real
        // application this would come from a resource.
        setEmptyText(""No applications"");

        // We have a menu item to show in action bar.
        setHasOptionsMenu(true);

        // Create an empty adapter we will use to display the loaded data.
        mAdapter = new AppListAdapter(getActivity());
        setListAdapter(mAdapter);

        // Start out with a progress indicator.
        setListShown(false);

        // Prepare the loader.  Either re-connect with an existing one
        // or start a new one.
        getLoaderManager().initLoader(0 null this);
    }

    public static class MySearchView extends SearchView {
        public MySearchView(Context context) {
            super(context);
        }

        // The normal SearchView doesn't clear its search text when
        // collapsed so we will do this for it.
        @Override
        public void onActionViewCollapsed() {
            setQuery("""" false);
            super.onActionViewCollapsed();
        }
    }

    @Override public void onCreateOptionsMenu(Menu menu MenuInflater inflater) {
        // Place an action bar item for searching.
        MenuItem item = menu.add(""Search"");
        item.setIcon(android.R.drawable.ic_menu_search);
        item.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM
                | MenuItem.SHOW_AS_ACTION_COLLAPSE_ACTION_VIEW);
        mSearchView = new MySearchView(getActivity());
        mSearchView.setOnQueryTextListener(this);
        mSearchView.setOnCloseListener(this);
        mSearchView.setIconifiedByDefault(true);
        item.setActionView(mSearchView);
    }

    @Override public boolean onQueryTextChange(String newText) {
        // Called when the action bar search text has changed.  Since this
        // is a simple array adapter we can just have it do the filtering.
        mCurFilter = !TextUtils.isEmpty(newText) ? newText : null;
        mAdapter.getFilter().filter(mCurFilter);
        return true;
    }

    @Override public boolean onQueryTextSubmit(String query) {
        // Don't care about this.
        return true;
    }

    @Override
    public boolean onClose() {
        if (!TextUtils.isEmpty(mSearchView.getQuery())) {
            mSearchView.setQuery(null true);
        }
        return true;
    }

    @Override public void onListItemClick(ListView l View v int position long id) {
        // Insert desired behavior here.
        Log.i(""LoaderCustom"" ""Item clicked: "" + id);
    }

    @Override public Loader<List<AppEntry>> onCreateLoader(int id Bundle args) {
        // This is called when a new Loader needs to be created.  This
        // sample only has one Loader with no arguments so it is simple.
        return new AppListLoader(getActivity());
    }

    @Override public void onLoadFinished(Loader<List<AppEntry>> loader List<AppEntry> data) {
        // Set the new data in the adapter.
        mAdapter.setData(data);

        // The list should now be shown.
        if (isResumed()) {
            setListShown(true);
        } else {
            setListShownNoAnimation(true);
        }
    }

    @Override public void onLoaderReset(Loader<List<AppEntry>> loader) {
        // Clear the data in the adapter.
        mAdapter.setData(null);
    }
}"
android,content,BroadcastReceiver.PendingResult,11,"State for a result that is pending for a broadcast receiver.  Returned
 by  BroadcastReceiver#goAsync() 
 while in  BroadcastReceiver#onReceive .
 This allows you to return from onReceive() without having the broadcast
 terminate; you must call  finish()  once you are done with the
 broadcast.  This allows you to process the broadcast off of the main
 thread of your app.

  Note on threading: the state inside of this class is not itself
 thread-safe however you can use it from any thread if you properly
 sure that you do not have races.  Typically this means you will hand
 the entire object to another thread which will be solely responsible
 for setting any results and finally calling  finish() ."
android,content,ClipboardManager,10,"Interface to the clipboard service for placing and retrieving text in
 the global clipboard.

  
 The ClipboardManager API itself is very simple: it consists of methods
 to atomically get and set the current primary clipboard data.  That data
 is expressed as a  ClipData  object which defines the protocol
 for data exchange between applications."
android,content,ComponentName,18,"Identifier for a specific application component
 ( Activity   Service 
  BroadcastReceiver  or
  ContentProvider ) that is available.  Two
 pieces of information encapsulated here are required to identify
 a component: the package (a String) it exists in and the class (a String)
 name inside of that package."
android,content,ContentProvider.CallingIdentity,0,Opaque token representing the identity of an incoming IPC.
android,content,ContentProviderClient,27,"The public interface object used to interact with a specific
  ContentProvider .
  
 Instances can be obtained by calling
  ContentResolver#acquireContentProviderClient  or
  ContentResolver#acquireUnstableContentProviderClient . Instances must
 be released using  close()  in order to indicate to the system that
 the underlying  ContentProvider  is no longer needed and can be killed
 to free up resources.
  
 Note that you should generally create a new ContentProviderClient instance
 for each thread that will be performing operations. Unlike
  ContentResolver  the methods here such as  query(Uri String[] Bundle CancellationSignal)  and
  openFile(Uri String)  are not thread safe -- you must not call  close() 
 on the ContentProviderClient those calls are made from until you are finished
 with the data they have returned."
android,content,ContentProviderOperation,18,Represents a single operation to be performed as part of a batch of operations.
android,content,ContentResolver.MimeTypeInfo,3,"Detailed description of a specific MIME type including an icon and label
 that describe the type."
android,content,CursorLoader,18,"A loader that queries the  ContentResolver  and returns a  Cursor .
 This class implements the  Loader  protocol in a standard way for
 querying cursors building on  AsyncTaskLoader  to perform the cursor
 query on a background thread so that it does not block the application's UI.

  A CursorLoader must be built with the full information for the query to
 perform either through the
  CursorLoader(android.content.Context android.net.Uri java.lang.String[] java.lang.String java.lang.String[] java.lang.String)  or
 creating an empty instance with  CursorLoader(android.content.Context)  and filling
 in the desired parameters with  setUri(android.net.Uri)   setSelection(java.lang.String) 
  setSelectionArgs(java.lang.String[])   setSortOrder(java.lang.String) 
 and  setProjection(java.lang.String[]) ."
android,content,Entity,4,"A representation of a item using ContentValues. It contains one top level ContentValue
 plus a collection of Uri ContentValues tuples as subvalues. One example of its use
 is in Contacts where the top level ContentValue contains the columns from the RawContacts
 table and the subvalues contain a ContentValues object for each row from the Data table that
 corresponds to that RawContact. The uri refers to the Data table uri for each row."
android,content,Entity.NamedContentValues,0,
android,content,Intent,126,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed."
android,content,Intent.FilterComparison,3,"Wrapper class holding an Intent and implementing comparisons on it for
 the purpose of filtering.  The class implements its
  equals()  and  hashCode()  methods as
 simple calls to  Intent#filterEquals(Intent)   filterEquals()} and
  Intent.filterHashCode()   filterHashCode()}
 on the wrapped Intent."
android,content,Loader,30,"A class that performs asynchronous loading of data. While Loaders are active
 they should monitor the source of their data and deliver new results when the contents
 change.  See  LoaderManager  for more detail.

  Note on threading:  Clients of loaders should as a rule perform
 any calls on to a Loader from the main thread of their process (that is
 the thread the Activity callbacks and other things occur on).  Subclasses
 of Loader (such as  AsyncTaskLoader ) will often perform their work
 in a separate thread but when delivering their results this too should
 be done on the main thread. Subclasses generally must implement at least  onStartLoading() 
  onStopLoading()   onForceLoad()  and  onReset() . Most implementations should not derive directly from this class but
 instead inherit from  AsyncTaskLoader ."
android,content,Loader.ForceLoadContentObserver,2,"An implementation of a ContentObserver that takes care of connecting
 it to the Loader to have the loader re-load its data when the observer
 is told it has changed.  You do not normally need to use this yourself;
 it is used for you by  CursorLoader  to take care of executing
 an update when the cursor's backing data changes."
android,content,QuickViewConstants,0,Constants for  Intent#ACTION_QUICK_VIEW .
android,content,RestrictionEntry,30,"Applications can expose restrictions for a restricted user on a
 multiuser device. The administrator can configure these restrictions that will then be
 applied to the restricted user. Each RestrictionsEntry is one configurable restriction.
  Intent#ACTION_GET_RESTRICTION_ENTRIES ."
android,content,RestrictionsManager,7,"Provides a mechanism for apps to query restrictions imposed by an entity that
 manages the user. Apps can also send permission requests to a local or remote
 device administrator to override default app-specific restrictions or any other
 operation that needs explicit authorization from the administrator.
  
 Apps can expose a set of restrictions via an XML file specified in the manifest.
  
 If the user has an active Restrictions Provider dynamic requests can be made in
 addition to the statically imposed restrictions. Dynamic requests are app-specific
 and can be expressed via a predefined set of request types.
  
 The RestrictionsManager forwards the dynamic requests to the active
 Restrictions Provider. The Restrictions Provider can respond back to requests by calling
  notifyPermissionResponse(java.lang.String android.os.PersistableBundle)  when
 a response is received from the administrator of the device or user.
 The response is relayed back to the application via a protected broadcast
  ACTION_PERMISSION_RESPONSE_RECEIVED .
  
 Static restrictions are specified by an XML file referenced by a meta-data attribute
 in the manifest. This enables applications as well as any web administration consoles
 to be able to read the list of available restrictions from the apk.
  
 The syntax of the XML format is as follows:
  
 <?xml version=""1.0"" encoding=""utf-8""?>
 <restrictions xmlns:android=""http://schemas.android.com/apk/res/android"" >
     <restriction
         android:key=""string""
         android:title=""string resource""
         android:restrictionType=[""bool"" | ""string"" | ""integer""
                                         | ""choice"" | ""multi-select"" | ""hidden""
                                         | ""bundle"" | ""bundle_array""]
         android:description=""string resource""
         android:entries=""string-array resource""
         android:entryValues=""string-array resource""
         android:defaultValue=""reference"" >
             <restriction ... />
             ...
     </restriction>
     <restriction ... />
     ...
 </restrictions>
  
 The attributes for each restriction depend on the restriction type.
  key   title  and  restrictionType  are mandatory. entries  and  entryValues  are required if  restrictionType
   is  choice  or  multi-select . defaultValue  is optional and its type depends on the
  restrictionType hidden  type must have a  defaultValue  and will
 not be shown to the administrator. It can be used to pass along data that cannot be modified
 such as a version code. description  is meant to describe the restriction in more detail to the
 administrator controlling the values if the title is not sufficient. 
 Only restrictions of type  bundle  and  bundle_array  can have one or multiple nested
 restriction elements.
  
 In your manifest's  application  section add the meta-data tag to point to
 the restrictions XML file as shown below:
  
 <application ... >
     <meta-data android:name=""android.content.APP_RESTRICTIONS""
                   android:resource=""@xml/app_restrictions"" />
     ...
 </application>"
android,content,SearchRecentSuggestionsProvider,7,"This superclass can be used to create a simple search suggestions provider for your application.
 It creates suggestions (as the user types) based on recent queries and/or recent views.

  In order to use this class you must do the following.

  Implement and test query search as described in  SearchManager .  (This
 provider will send any suggested queries via the standard
  ACTION_SEARCH  Intent which you'll already
 support once you have implemented and tested basic searchability.) Create a Content Provider within your application by extending
  SearchRecentSuggestionsProvider .  The class you create will be
 very simple - typically it will have only a constructor.  But the constructor has a very
 important responsibility:  When it calls  setupSuggestions(java.lang.String int)  it
  configures  the provider to match the requirements of your searchable activity. Create a manifest entry describing your provider.  Typically this would be as simple
 as adding the following lines:
  
     <!-- Content provider for search suggestions -->
     <provider android:name=""YourSuggestionProviderClass""
               android:authorities=""your.suggestion.authority"" /> Please note that you  do not  instantiate this content provider directly from within
 your code.  This is done automatically by the system Content Resolver when the search dialog
 looks for suggestions. In order for the Content Resolver to do this you must update your searchable activity's
 XML configuration file with information about your content provider.  The following additions
 are usually sufficient:
  
     android:searchSuggestAuthority=""your.suggestion.authority""
     android:searchSuggestSelection="" ? "" In your searchable activities capture any user-generated queries and record them
 for future searches by calling  SearchRecentSuggestions.saveRecentQuery() ."
android,content,SyncAdapterType,11,"Value type that represents a SyncAdapterType. This object overrides  equals(Object)  and
  hashCode()  making it suitable for use as the key of a  Map"
android,content,SyncInfo,0,Information about the sync operation that is currently underway.
android,content,SyncResult,9,"This class is used to communicate the results of a sync operation to the SyncManager.
 Based on the values here the SyncManager will determine the disposition of the
 sync and whether or not a new sync operation needs to be scheduled in the future."
android,content,SyncStats,4,"Used to record various statistics about the result of a sync operation. The SyncManager
 gets access to these via a  SyncResult  and uses some of them to determine the
 disposition of the sync. See  SyncResult  for further dicussion on how the
 SyncManager uses these values."
android,content,AbstractThreadedSyncAdapter,7,"An abstract implementation of a SyncAdapter that spawns a thread to invoke a sync operation.
 If a sync operation is already in progress when a sync request is received an error will be
 returned to the new request and the existing request will be allowed to continue.
 However if there is no sync in progress then a thread will be spawned and  onPerformSync(Account Bundle String ContentProviderClient SyncResult) 
 will be invoked on that thread.
  
 Syncs can be cancelled at any time by the framework. For example a sync that was not
 user-initiated and lasts longer than 30 minutes will be considered timed-out and cancelled.
 Similarly the framework will attempt to determine whether or not an adapter is making progress
 by monitoring its network activity over the course of a minute. If the network traffic over this
 window is close enough to zero the sync will be cancelled. You can also request the sync be
 cancelled via  ContentResolver#cancelSync(Account String)  or
  ContentResolver#cancelSync(SyncRequest) .
  
 A sync is cancelled by issuing a  Thread#interrupt()  on the syncing thread.  Either
 your code in  onPerformSync(android.accounts.Account android.os.Bundle java.lang.String android.content.ContentProviderClient android.content.SyncResult) 
 must check  Thread#interrupted()  or you you must override one of
  onSyncCanceled(java.lang.Thread) / onSyncCanceled()  (depending on whether or not
 your adapter supports syncing of multiple accounts in parallel). If your adapter does not
 respect the cancel issued by the framework you run the risk of your app's entire process being
 killed.
  
 In order to be a sync adapter one must extend this class provide implementations for the
 abstract methods and write a service that returns the result of  getSyncAdapterBinder() 
 in the service's  Service.onBind(android.content.Intent)  when invoked
 with an intent with action  android.content.SyncAdapter . This service
 must specify the following intent filter and metadata tags in its AndroidManifest.xml file
  
   <intent-filter>
     <action android:name=""android.content.SyncAdapter"" />
   </intent-filter>
   <meta-data android:name=""android.content.SyncAdapter""
             android:resource=""@xml/syncadapter"" />
  android:resource 
 <sync-adapter xmlns:android=""http://schemas.android.com/apk/res/android""
    android:contentAuthority=""authority""
    android:accountType=""accountType""
    android:userVisible=""true|false""
    android:supportsUploading=""true|false""
    android:allowParallelSyncs=""true|false""
    android:isAlwaysSyncable=""true|false""
    android:syncAdapterSettingsAction=""ACTION_OF_SETTINGS_ACTIVITY""
 />
  The  android:contentAuthority  and  android:accountType  attributes
 indicate which content authority and for which account types this sync adapter serves.
  android:userVisible  defaults to true and controls whether or not this sync
 adapter shows up in the Sync Settings screen.
  android:supportsUploading  defaults
 to true and if true an upload-only sync will be requested for all syncadapters associated
 with an authority whenever that authority's content provider does a
  ContentResolver#notifyChange(android.net.Uri android.database.ContentObserver boolean) 
 with syncToNetwork set to true.
  android:allowParallelSyncs  defaults to false and if true indicates that
 the sync adapter can handle syncs for multiple accounts at the same time. Otherwise
 the SyncManager will wait until the sync adapter is not in use before requesting that
 it sync an account's data.
  android:isAlwaysSyncable  defaults to false and if true tells the SyncManager
 to initialize the isSyncable state to 1 for that sync adapter for each account that is added.
  android:syncAdapterSettingsAction  defaults to null and if supplied it
 specifies an Intent action of an activity that can be used to adjust the sync adapter's
 sync settings. The activity must live in the same package as the sync adapter."
android,content,BroadcastReceiver,18,"Base class for code that receives and handles broadcast intents sent by
  Context.sendBroadcast(Intent) .

  You can either dynamically register an instance of this class with
  Context#registerReceiver 
 or statically declare an implementation with the
  <receiver> 
 tag in your  AndroidManifest.xml ."
android,content,ContentQueryMap,6,"Caches the contents of a cursor into a Map of String->ContentValues and optionally
 keeps the cache fresh by registering for updates on the content backing the cursor. The column of
 the database that is to be used as the key of the map is user-configurable and the
 ContentValues contains all columns other than the one that is designated the key.
  
 The cursor data is accessed by row key and column name via getValue()."
android,content,ContentValues,32,"This class is used to store a set of values that the  ContentResolver 
 can process."
android,content,Context,122,"Interface to global information about an application environment.  This is
 an abstract class whose implementation is provided by
 the Android system.  It
 allows access to application-specific resources and classes as well as
 up-calls for application-level operations such as launching activities
 broadcasting and receiving intents etc."
android,content,IntentFilter,49,"Structured description of Intent values to be matched.  An IntentFilter can
 match against actions categories and data (either via its type scheme
 and/or path) in an Intent.  It also includes a ""priority"" value which is
 used to order multiple matching filters.

  IntentFilter objects are often created in XML as part of a package's
  AndroidManifest.xml  file
 using  intent-filter 
 tags.

  There are three Intent characteristics you can filter on: the
  action   data  and  categories .  For each of these
 characteristics you can provide
 multiple possible matching values (via  addAction(String) 
  addDataType(String)   addDataScheme(String)   addDataSchemeSpecificPart(String int) 
  addDataAuthority(String String)   addDataPath(String int)  and  addCategory(String)  respectively).
 For actions if no data characteristics are specified then the filter will
 only match intents that contain no data.

  The data characteristic is
 itself divided into three attributes: type scheme authority and path.
 Any that are
 specified must match the contents of the Intent.  If you specify a scheme
 but no type only Intent that does not have a type (such as mailto:) will
 match; a content: URI will never match because they always have a MIME type
 that is supplied by their content provider.  Specifying a type with no scheme
 has somewhat special meaning: it will match either an Intent with no URI
 field or an Intent with a content: or file: URI.  If you specify neither
 then only an Intent with no data or type will match.  To specify an authority
 you must also specify one or more schemes that it is associated with.
 To specify a path you also must specify both one or more authorities and
 one or more schemes it is associated with."
android,content,UriMatcher,2,"Utility class to aid in matching URIs in content providers.
 
  To use this class build up a tree of  UriMatcher  objects.
 For example:
  
    private static final int PEOPLE = 1;
    private static final int PEOPLE_ID = 2;
    private static final int PEOPLE_PHONES = 3;
    private static final int PEOPLE_PHONES_ID = 4;
    private static final int PEOPLE_CONTACTMETHODS = 7;
    private static final int PEOPLE_CONTACTMETHODS_ID = 8;
 
    private static final int DELETED_PEOPLE = 20;
 
    private static final int PHONES = 9;
    private static final int PHONES_ID = 10;
    private static final int PHONES_FILTER = 14;
 
    private static final int CONTACTMETHODS = 18;
    private static final int CONTACTMETHODS_ID = 19;
 
    private static final int CALLS = 11;
    private static final int CALLS_ID = 12;
    private static final int CALLS_FILTER = 15;
 
    private static final UriMatcher sURIMatcher = new UriMatcher(UriMatcher.NO_MATCH);
 
    static
    {
        sURIMatcher.addURI(""contacts"" ""people"" PEOPLE);
        sURIMatcher.addURI(""contacts"" ""people/#"" PEOPLE_ID);
        sURIMatcher.addURI(""contacts"" ""people/#/phones"" PEOPLE_PHONES);
        sURIMatcher.addURI(""contacts"" ""people/#/phones/#"" PEOPLE_PHONES_ID);
        sURIMatcher.addURI(""contacts"" ""people/#/contact_methods"" PEOPLE_CONTACTMETHODS);
        sURIMatcher.addURI(""contacts"" ""people/#/contact_methods/#"" PEOPLE_CONTACTMETHODS_ID);
        sURIMatcher.addURI(""contacts"" ""deleted_people"" DELETED_PEOPLE);
        sURIMatcher.addURI(""contacts"" ""phones"" PHONES);
        sURIMatcher.addURI(""contacts"" ""phones/filter/*"" PHONES_FILTER);
        sURIMatcher.addURI(""contacts"" ""phones/#"" PHONES_ID);
        sURIMatcher.addURI(""contacts"" ""contact_methods"" CONTACTMETHODS);
        sURIMatcher.addURI(""contacts"" ""contact_methods/#"" CONTACTMETHODS_ID);
        sURIMatcher.addURI(""call_log"" ""calls"" CALLS);
        sURIMatcher.addURI(""call_log"" ""calls/filter/*"" CALLS_FILTER);
        sURIMatcher.addURI(""call_log"" ""calls/#"" CALLS_ID);
    }
  Starting from API level  Build.VERSION_CODES.JELLY_BEAN_MR2  paths can start
 with a leading slash.  For example:
  
        sURIMatcher.addURI(""contacts"" ""/people"" PEOPLE);
  Then when you need to match against a URI call  match(Uri)  providing
 the URL that you have been given.  You can use the result to build a query
 return a type insert or delete a row or whatever you need without duplicating
 all of the if-else logic that you would otherwise need.  For example:
  
    public String getType(Uri url)
    {
        int match = sURIMatcher.match(url);
        switch (match)
        {
            case PEOPLE:
                return ""vnd.android.cursor.dir/person"";
            case PEOPLE_ID:
                return ""vnd.android.cursor.item/person"";
 ... snip ...
                return ""vnd.android.cursor.dir/snail-mail"";
            case PEOPLE_ADDRESS_ID:
                return ""vnd.android.cursor.item/snail-mail"";
            default:
                return null;
        }
    }
  
    public String getType(Uri url)
    {
        List  pathSegments = url.getPathSegments();
        if (pathSegments.size() >= 2) {
            if (""people"".equals(pathSegments.get(1))) {
                if (pathSegments.size() == 2) {
                    return ""vnd.android.cursor.dir/person"";
                } else if (pathSegments.size() == 3) {
                    return ""vnd.android.cursor.item/person"";
 ... snip ...
                    return ""vnd.android.cursor.dir/snail-mail"";
                } else if (pathSegments.size() == 3) {
                    return ""vnd.android.cursor.item/snail-mail"";
                }
            }
        }
        return null;
    }"
android,content,AsyncQueryHandler.WorkerHandler,1,
android,content,ClipData,13,"Representation of a clipped data on the clipboard.

  ClipData is a complex type containing one or more Item instances
 each of which can hold one or more representations of an item of data.
 For display to the user it also has a label. A ClipData contains a  ClipDescription  which describes
 important meta-data about the clip.  In particular its
  ClipDescription#getMimeType(int) 
 must return correct MIME type(s) describing the data in the clip.  For help
 in correctly constructing a clip with the correct MIME type use
  newPlainText(java.lang.CharSequence java.lang.CharSequence) 
  newUri(android.content.ContentResolver java.lang.CharSequence android.net.Uri)  and
  newIntent(java.lang.CharSequence android.content.Intent) .

  Each Item instance can be one of three main classes of data: a simple
 CharSequence of text a single Intent object or a Uri.  See  Item 
 for more details."
android,content,ClipDescription,12,"Meta-data describing the contents of a  ClipData .  Provides enough
 information to know if you can handle the ClipData but not the data
 itself."
android,content,ContentProviderResult,3,"Contains the result of the application of a  ContentProviderOperation . It is guaranteed
 to have exactly one of  uri  or  count  set."
android,content,ContentResolver,67,This class provides applications access to the content model.
android,content,IntentFilter.AuthorityEntry,4,"This is an entry for a single authority in the Iterator returned by
  IntentFilter.authoritiesIterator() ."
android,content,IntentSender,13,"A description of an Intent and target action to perform with it.
 The returned object can be
 handed to other applications so that they can perform the action you
 described on your behalf at a later time.

  By giving a IntentSender to another application
 you are granting it the right to perform the operation you have specified
 as if the other application was yourself (with the same permissions and
 identity).  As such you should be careful about how you build the IntentSender:
 often for example the base Intent you supply will have the component
 name explicitly set to one of your own components to ensure it is ultimately
 sent there and nowhere else.

  A IntentSender itself is simply a reference to a token maintained by
 the system describing the original data used to retrieve it.  This means
 that even if its owning application's process is killed the
 IntentSender itself will remain usable from other processes that
 have been given it.  If the creating application later re-retrieves the
 same kind of IntentSender (same operation same Intent action data
 categories and components and same flags) it will receive a IntentSender
 representing the same token if that is still valid.

  Instances of this class can not be made directly but rather must be
 created from an existing  PendingIntent  with
  PendingIntent.getIntentSender() ."
android,content,SyncContext,2,
android,content,SyncRequest.Builder,12,"Builder class for a  SyncRequest . As you build your SyncRequest this class will also
 perform validation."
android,content,AsyncQueryHandler,11,"A helper class to help make handling asynchronous  ContentResolver 
 queries easier."
android,content,ClipData.Item,8,"Description of a single item in a ClipData.

  The types than an individual item can currently contain are:  Text: a basic string of text.  This is actually a CharSequence
 so it can be formatted text supported by corresponding Android built-in
 style spans.  (Custom application spans are not supported and will be
 stripped when transporting through the clipboard.)
   Intent: an arbitrary Intent object.  A typical use is the shortcut
 to create when pasting a clipped item on to the home screen.
   Uri: a URI reference.  This may be any URI (such as an http: URI
 representing a bookmark) however it is often a content: URI.  Using
 content provider references as clips like this allows an application to
 share complex or large clips through the standard content provider
 facilities."
android,content,ContentProvider,42,"Content providers are one of the primary building blocks of Android applications providing
 content to applications. They encapsulate data and provide it to applications through the single
  ContentResolver  interface. A content provider is only required if you need to share
 data between multiple applications. For example the contacts data is used by multiple
 applications and must be stored in a content provider. If you don't need to share data amongst
 multiple applications you can use a database directly via
  SQLiteDatabase .

  When a request is made via
 a  ContentResolver  the system inspects the authority of the given URI and passes the
 request to the content provider registered with the authority. The content provider can interpret
 the rest of the URI however it wants. The  UriMatcher  class is helpful for parsing
 URIs. The primary methods that need to be implemented are:
  onCreate()  which is called to initialize the provider query(Uri String[] Bundle CancellationSignal)  which returns data to the caller insert(Uri ContentValues)  which inserts new data into the content provider update(Uri ContentValues String String[])  which updates existing data in the content provider delete(Uri String String[])  which deletes data from the content provider getType(Uri)  which returns the MIME type of data in the content provider Requests to  ContentResolver  are automatically forwarded to the appropriate
 ContentProvider instance so subclasses don't have to worry about the details of
 cross-process calls."
android,content,ContentProviderOperation.Builder,9,"Used to add parameters to a  ContentProviderOperation . The  Builder  is
 first created by calling  ContentProviderOperation#newInsert(android.net.Uri) 
  ContentProviderOperation#newUpdate(android.net.Uri) 
  ContentProviderOperation#newDelete(android.net.Uri)  or
  ContentProviderOperation#newAssertQuery(Uri) . The withXXX methods
 can then be used to add parameters to the builder. See the specific methods to find for
 which  Builder  type each is allowed. Call  build()  to create the
  ContentProviderOperation  once all the parameters have been supplied."
android,content,ContentUris,4,"Utility methods useful for working with  Uri  objects
 that use the ""content"" (content://) scheme.

 
   Content URIs have the syntax
 content:// authority / path / id content: 
       The scheme portion of the URI. This is always set to  ContentResolver.SCHEME_CONTENT  (value
        content:// ).
    authority 
       A string that identifies the entire content provider. All the content URIs for the provider
       start with this string. To guarantee a unique authority providers should consider
       using an authority that is the same as the provider class' package identifier.
    path 
       Zero or more segments separated by a forward slash ( / ) that identify
       some subset of the provider's data. Most providers use the path part to identify
       individual tables. Individual segments in the path are often called
       ""directories"" although they do not refer to file directories. The right-most
       segment in a path is often called a ""twig""
    id 
       A unique numeric identifier for a single row in the subset of data identified by the
       preceding path part. Most providers recognize content URIs that contain an id part
       and give them special handling. A table that contains a column named  _ID 
       often expects the id part to be a particular value for that column."
android,content,ContextWrapper,109,"Proxying implementation of Context that simply delegates all of its calls to
 another Context.  Can be subclassed to modify behavior without changing
 the original Context."
android,content,Intent.ShortcutIconResource,4,Represents a shortcut/live folder icon resource.
android,content,LocusId,6,"An identifier for an unique state (locus) in the application. Should be stable across reboots and
 backup / restore.

  Locus is a new concept introduced on
  Android Q  and it lets the Android system correlate
 state between different subsystems such as content capture shortcuts and notifications.

  For example if your app provides an activiy representing a chat between 2 users
 (say  A  and  B  this chat state could be represented by:

  
 LocusId chatId = new LocusId(""Chat_A_B"");
  And then you should use that  chatId  by:

  Setting it in the chat notification (through
    Notification.Builder.setLocusId(chatId) ).
    Setting it into the  ShortcutInfo  (through
    ShortcutInfo.Builder.setLocusId(chatId) ) if you provide a launcher shortcut for that chat
   conversation.
    Associating it with the  ContentCaptureContext  of the
   root view of the chat conversation activity (through
    View.getContentCaptureSession()  then
    new ContentCaptureContext.Builder(chatId).build()  and
    ContentCaptureSession.setContentCaptureContext(android.view.contentcapture.ContentCaptureContext)  - see  ContentCaptureManager 
   for more info about content capture).
    Configuring your app to launch the chat conversation through the
    Intent#ACTION_VIEW_LOCUS  intent."
android,content,MutableContextWrapper,1,"Special version of  ContextWrapper  that allows the base context to
 be modified after it is initially set."
android,content,PeriodicSync,4,Value type that contains information about a periodic sync.
android,content,SyncRequest,2,"Convenience class to construct sync requests. See  SyncRequest.Builder 
 for an explanation of the various functions. The resulting object is passed through to the
 framework via  ContentResolver.requestSync(SyncRequest) ."
android,content,UriPermission,7,"Description of a single Uri permission grant. This grants may have been
 created via  Intent#FLAG_GRANT_READ_URI_PERMISSION  etc when sending
 an  Intent  or explicitly through
  Context#grantUriPermission(String android.net.Uri int) ."
android,graphics.fonts,Font,9,A font class can be used for creating FontFamily.
android,graphics.fonts,Font.Builder,6,A builder class for creating new Font.
android,graphics.fonts,FontFamily,2,"A font family class can be used for creating Typeface.

  
 A font family is a bundle of fonts for drawing text in various styles.
 For example you can bundle regular style font and bold style font into a single font family
 then system will select the correct style font from family for drawing.

  
  FontFamily family = new FontFamily.Builder(new Font.Builder(""regular.ttf"").build())
      .addFont(new Font.Builder(""bold.ttf"").build()).build();
  Typeface typeface = new Typeface.Builder2(family).build();

  SpannableStringBuilder ssb = new SpannableStringBuilder(""Hello World."");
  ssb.setSpan(new StyleSpan(Typeface.Bold) 6 12 Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);

  textView.setTypeface(typeface);
  textView.setText(ssb);"
android,graphics.fonts,FontFamily.Builder,2,A builder class for creating new FontFamily.
android,graphics.fonts,FontStyle,5,"A font style object.

 This class represents a single font style which is a pair of weight value and slant value.
 Here are common font styles examples:
  
 final FontStyle NORMAL = new FontStyle(FONT_WEIGHT_NORMAL FONT_SLANT_UPRIGHT);
 final FontStyle BOLD = new FontStyle(FONT_WEIGHT_BOLD FONT_SLANT_UPRIGHT);
 final FontStyle ITALIC = new FontStyle(FONT_WEIGHT_NORMAL FONT_SLANT_ITALIC);
 final FontStyle BOLD_ITALIC = new FontStyle(FONT_WEIGHT_BOLD FONT_SLANT_ITALIC);"
android,graphics.fonts,FontVariationAxis,7,Class that holds information about single font variation axis.
android,graphics.fonts,SystemFonts,1,Provides the system font configurations.
android,graphics.pdf,PdfDocument,6,"This class enables generating a PDF document from native Android content. You
 create a new document and then for every page you want to add you start a page
 write content to the page and finish the page. After you are done with all
 pages you write the document to an output stream and close the document.
 After a document is closed you should not use it anymore. Note that pages are
 created one by one i.e. you can have only a single page to which you are
 writing at any given time. This class is not thread safe.
  
 A typical use of the APIs looks like this:
  
 // create a new document
 PdfDocument document = new PdfDocument();

 // crate a page description
 PageInfo pageInfo = new PageInfo.Builder(new Rect(0 0 100 100) 1).create();

 // start a page
 Page page = document.startPage(pageInfo);

 // draw something on the page
 View content = getContentView();
 content.draw(page.getCanvas());

 // finish the page
 document.finishPage(page);
 . . .
 // add more pages
 . . .
 // write the document content
 document.writeTo(getOutputStream());

 // close the document
 document.close();"
android,graphics.pdf,PdfDocument.Page,2,"This class represents a PDF document page. It has associated
 a canvas on which you can draw content and is acquired by a
 call to  getCanvas() . It also has associated a
  PageInfo  instance that describes its attributes. Also
 a page has"
android,graphics.pdf,PdfDocument.PageInfo,4,This class represents meta-data that describes a PDF  Page .
android,graphics.pdf,PdfDocument.PageInfo.Builder,2,Builder for creating a  PageInfo .
android,graphics.pdf,PdfRenderer,5,"This class enables rendering a PDF document. This class is not thread safe.
  
 If you want to render a PDF you create a renderer and for every page you want
 to render you open the page render it and close the page. After you are done
 with rendering you close the renderer. After the renderer is closed it should not
 be used anymore. Note that the pages are rendered one by one i.e. you can have
 only a single page opened at any given time.
  
 A typical use of the APIs to render a PDF looks like this:
  
 // create a new renderer
 PdfRenderer renderer = new PdfRenderer(getSeekableFileDescriptor());

 // let us just render all pages
 final int pageCount = renderer.getPageCount();
 for (int i = 0; i < pageCount; i++) {
     Page page = renderer.openPage(i);

     // say we render for showing on the screen
     page.render(mBitmap null null Page.RENDER_MODE_FOR_DISPLAY);

     // do stuff with the bitmap

     // close the page
     page.close();
 }

 // close the renderer
 renderer.close();
  Print preview and print output 
 If you are using this class to rasterize a PDF for printing or show a print
 preview it is recommended that you respect the following contract in order
 to provide a consistent user experience when seeing a preview and printing
 i.e. the user sees a preview that is the same as the printout.
  
 Respect the property whether the document would like to be scaled for printing
 as per  shouldScaleForPrinting() .
  
 When scaling a document for printing the aspect ratio should be preserved.
  
 Do not inset the content with any margins from the  PrintAttributes 
 as the application is responsible to render it such that the margins are respected.
  
 If document page size is greater than the printed media size the content should
 be anchored to the upper left corner of the page for left-to-right locales and
 top right corner for right-to-left locales."
android,graphics.pdf,PdfRenderer.Page,6,This class represents a PDF document page for rendering.
android,graphics.text,LineBreaker,1,"Provides automatic line breaking for a  single  paragraph.

  
 Paint paint = new Paint();
 Paint bigPaint = new Paint();
 bigPaint.setTextSize(paint.getTextSize() * 2.0);
 String text = ""Hello Android."";

 // Prepare the measured text
 MeasuredText mt = new MeasuredText.Builder(text.toCharArray())
     .appendStyleRun(paint 7 false)  // Use paint for ""Hello ""
     .appednStyleRun(bigPaint 8 false)  // Use bigPaint for ""Hello ""
     .build();

 LineBreaker lb = new LineBreaker.Builder()
     // Use simple line breaker
     .setBreakStrategy(LineBreaker.BREAK_STRATEGY_SIMPLE)
     // Do not add hyphenation.
     .setHyphenationFrequency(LineBreaker.HYPHENATION_FREQUENCY_NONE)
     // Build the LineBreaker
     .build();

 ParagraphConstraints c = new ParagraphConstraints();
 c.setWidth(240);  // Set the line wieth as 1024px

 // Do the line breaking
 Result r = lb.computeLineBreaks(mt c 0);

 // Compute the total height of the text.
 float totalHeight = 0;
 for (int i = 0; i < r.getLineCount(); ++i) {  // iterate over the lines
    totalHeight += r.getLineDescent(i) - r.getLineAscent(i);
 }

 // Draw text to the canvas
 Bitmap bmp = Bitmap.createBitmap(240 totalHeight Bitmap.Config.ARGB_8888);
 Canvas c = new Canvas(bmp);
 float yOffset = 0f;
 int prevOffset = 0;
 for (int i = 0; i < r.getLineCount(); ++i) {  // iterate over the lines
     int nextOffset = r.getLineBreakOffset(i);
     c.drawText(text prevOffset nextOffset 0f yOffset paint);

     prevOffset = nextOffset;
     yOffset += r.getLineDescent(i) - r.getLineAscent(i);
 }"
android,graphics.text,LineBreaker.Builder,5,Helper class for creating a  LineBreaker .
android,graphics.text,LineBreaker.ParagraphConstraints,8,Line breaking constraints for single paragraph.
android,graphics.text,LineBreaker.Result,8,Holds the result of the  LineBreaker#computeLineBreaks .
android,graphics.text,MeasuredText,3,"Result of text shaping of the single paragraph string.

  
 Paint paint = new Paint();
 Paint bigPaint = new Paint();
 bigPaint.setTextSize(paint.getTextSize() * 2.0);
 String text = ""Hello Android."";
 MeasuredText mt = new MeasuredText.Builder(text.toCharArray())
      .appendStyleRun(paint 7 false)  // Use paint for ""Hello ""
      .appendStyleRun(bigPaint 8 false)  // Use bigPaint for ""Android.""
      .build();"
android,graphics.text,MeasuredText.Builder,5,"Helper class for creating a  MeasuredText .
  
 Paint paint = new Paint();
 String text = ""Hello Android."";
 MeasuredText mt = new MeasuredText.Builder(text.toCharArray())
      .appendStyleRun(paint text.length false)
      .build();"
android,graphics.drawable,AdaptiveIconDrawable,38,"This class can also be created via XML inflation using  <adaptive-icon>  tag
 in addition to dynamic creation.

  This drawable supports two drawable layers: foreground and background. The layers are clipped
 when rendering using the mask defined in the device configuration.

  Both foreground and background layers should be sized at 108 x 108 dp. The inner 72 x 72 dp  of the icon appears within the masked viewport. The outer 18 dp on each of the 4 sides of the layers is reserved for use by the system UI
 surfaces to create interesting visual effects such as parallax or pulsing. 
 Rect(getBounds().left - getBounds().getWidth() * #getExtraInsetFraction()
      getBounds().top - getBounds().getHeight() * #getExtraInsetFraction()
      getBounds().right + getBounds().getWidth() * #getExtraInsetFraction()
      getBounds().bottom + getBounds().getHeight() * #getExtraInsetFraction())"
android,graphics.drawable,AnimatedImageDrawable,20,"Drawable  for drawing animated images (like GIF).

  The framework handles decoding subsequent frames in another thread and
 updating when necessary. The drawable will only animate while it is being
 displayed. Created by  ImageDecoder#decodeDrawable . A user needs to call
  start()  to start the animation. It can also be defined in XML using the  <animated-image> 
 element."
android,graphics.drawable,BitmapDrawable,42,"A Drawable that wraps a bitmap and can be tiled stretched or aligned. You can create a
 BitmapDrawable from a file path an input stream through XML inflation or from
 a  Bitmap  object.
  It can be defined in an XML file with the  <bitmap>  element.  For more
 information see the guide to  Drawable Resources . 
 Also see the  Bitmap  class which handles the management and
 transformation of raw bitmap graphics and should be used when drawing to a
  Canvas ."
android,graphics.drawable,ColorDrawable,19,"A specialized Drawable that fills the Canvas with a specified color.
 Note that a ColorDrawable ignores the ColorFilter.

  It can be defined in an XML file with the  <color>  element."
android,graphics.drawable,Drawable,72,"A Drawable is a general abstraction for ""something that can be drawn.""  Most
 often you will deal with Drawable as the type of resource retrieved for
 drawing things to the screen; the Drawable class provides a generic API for
 dealing with an underlying visual resource that may take a variety of forms.
 Unlike a  View  a Drawable does not have any facility to
 receive events or otherwise interact with the user.

  In addition to simple drawing Drawable provides a number of generic
 mechanisms for its client to interact with what is being drawn:

   The  setBounds(Rect)  method  must  be called to tell the
     Drawable where it is drawn and how large it should be.  All Drawables
     should respect the requested size often simply by scaling their
     imagery.  A client can find the preferred size for some Drawables with
     the  getIntrinsicHeight()  and  getIntrinsicWidth()  methods.

       The  getPadding(Rect)  method can return from some Drawables
     information about how to frame content that is placed inside of them.
     For example a Drawable that is intended to be the frame for a button
     widget would need to return padding that correctly places the label
     inside of itself.

       The  setState(int[])  method allows the client to tell the Drawable
     in which state it is to be drawn such as ""focused"" ""selected"" etc.
     Some drawables may modify their imagery based on the selected state.

       The  setLevel(int)  method allows the client to supply a single
     continuous controller that can modify the Drawable is displayed such as
     a battery level or progress level.  Some drawables may modify their
     imagery based on the current level.

       A Drawable can perform animations by calling back to its client
     through the  Callback  interface.  All clients should support this
     interface (via  setCallback(Drawable.Callback) ) so that animations will work.  A
     simple way to do this is through the system facilities such as
      View.setBackground(Drawable)  and
      ImageView .
  Bitmap : the simplest Drawable a PNG or JPEG image.
      Nine Patch : an extension to the PNG format allows it to
     specify information about how to stretch it and place things inside of
     it.
      Vector : a drawable defined in an XML file as a set of points
     lines and curves along with its associated color information. This type
     of drawable can be scaled without loss of display quality.
      Shape : contains simple drawing commands instead of a raw
     bitmap allowing it to resize better in some cases.
      Layers : a compound drawable which draws multiple underlying
     drawables on top of each other.
      States : a compound drawable that selects one of a set of
     drawables based on its state.
      Levels : a compound drawable that selects one of a set of
     drawables based on its level.
      Scale : a compound drawable with a single child drawable
     whose overall size is modified based on the current level.
  Custom drawables 
 All versions of Android allow the Drawable class to be extended and used at
 run time in place of framework-provided drawable classes. Starting in
  API 24  custom drawables classes
 may also be used in XML.
  Note:  Custom drawable classes are only accessible from
 within your application package. Other applications will not be able to load
 them.
  
 At a minimum custom drawable classes must implement the abstract methods on
 Drawable and should override the  Drawable#draw(Canvas)  method to
 draw content.
  
 Custom drawables classes may be used in XML in multiple ways:
  
         Using the fully-qualified class name as the XML element name. For
         this method the custom drawable class must be a public top-level
         class.
  
 <com.myapp.MyCustomDrawable xmlns:android=""http://schemas.android.com/apk/res/android""
     android:color=""#ffff0000"" />
  
         Using  drawable  as the XML element name and specifying the
         fully-qualified class name from the  class  attribute. This
         method may be used for both public top-level classes and public
         static inner classes.
  
 <drawable xmlns:android=""http://schemas.android.com/apk/res/android""
     class=""com.myapp.MyTopLevelClass$InnerCustomDrawable""
     android:color=""#ffff0000"" />"
android,graphics.drawable,GradientDrawable,61,"A Drawable with a color gradient for buttons backgrounds etc.

  It can be defined in an XML file with the  <shape>  element. For more
 information see the guide to  Drawable Resources ."
android,graphics.drawable,LevelListDrawable,5,"A resource that manages a number of alternate Drawables each assigned a maximum numerical value.
 Setting the level value of the object with  Drawable.setLevel(int)  will load the image with the next
 greater or equal value assigned to its max attribute.
 A good example use of
 a LevelListDrawable would be a battery level indicator icon with different images to indicate the current
 battery level.
  
 It can be defined in an XML file with the  <level-list>  element.
 Each Drawable level is defined in a nested  <item> . For example:
  
 <level-list xmlns:android=""http://schemas.android.com/apk/res/android"">
  <item android:maxLevel=""0"" android:drawable=""@drawable/ic_wifi_signal_1"" />
  <item android:maxLevel=""1"" android:drawable=""@drawable/ic_wifi_signal_2"" />
  <item android:maxLevel=""2"" android:drawable=""@drawable/ic_wifi_signal_3"" />
  <item android:maxLevel=""3"" android:drawable=""@drawable/ic_wifi_signal_4"" />
 </level-list>
 With this XML saved into the res/drawable/ folder of the project it can be referenced as
 the drawable for an  ImageView . The default image is the first in the list.
 It can then be changed to one of the other levels with
  ImageView.setImageLevel(int) . For more
 information see the guide to  Drawable Resources ."
android,graphics.drawable,StateListDrawable,11,"Lets you assign a number of graphic images to a single Drawable and swap out the visible item by a string
 ID value.
  It can be defined in an XML file with the  <selector>  element.
 Each state Drawable is defined in a nested  <item>  element. For more
 information see the guide to  Drawable Resources ."
android,graphics.drawable,Animatable2.AnimationCallback,2,
android,graphics.drawable,AnimatedStateListDrawable,10,"Drawable containing a set of Drawable keyframes where the currently displayed
 keyframe is chosen based on the current state set. Animations between
 keyframes may optionally be defined using transition elements.
  
 This drawable can be defined in an XML file with the  
 <animated-selector>  element. Each keyframe Drawable is defined in a
 nested  <item>  element. Transitions are defined in a nested
  <transition>  element."
android,graphics.drawable,AnimatedVectorDrawable,33,"This class animates properties of a  VectorDrawable  with
 animations defined using  ObjectAnimator  or
  AnimatorSet .
  
 Starting from API 25 AnimatedVectorDrawable runs on RenderThread (as opposed to on UI thread for
 earlier APIs). This means animations in AnimatedVectorDrawable can remain smooth even when there
 is heavy workload on the UI thread. Note: If the UI thread is unresponsive RenderThread may
 continue animating until the UI thread is capable of pushing another frame. Therefore it is not
 possible to precisely coordinate a RenderThread-enabled AnimatedVectorDrawable with UI thread
 animations. Additionally
  Animatable2.AnimationCallback.onAnimationEnd(Drawable)  will be
 called the frame after the AnimatedVectorDrawable finishes on the RenderThread.
  
 AnimatedVectorDrawable can be defined in either  three separate XML files 
 or  one XML .
  Define an AnimatedVectorDrawable in three separate XML files XML for the VectorDrawable containing properties to be animated 
 Animations can be performed on the animatable attributes in
  VectorDrawable . These attributes will be animated by
  ObjectAnimator . The ObjectAnimator's target can be the root element
 a group element or a path element. The targeted elements need to be named uniquely within
 the same VectorDrawable. Elements without animation do not need to be named.
  
 Here are all the animatable attributes in  VectorDrawable :
  Element Name Animatable attribute name <vector> alpha <group> rotation pivotX pivotY scaleX scaleY translateX translateY <path> pathData fillColor strokeColor strokeWidth strokeAlpha fillAlpha trimPathStart trimPathEnd trimPathOffset <clip-path> pathData 
 
 Below is an example of a VectorDrawable defined in vectordrawable.xml. This VectorDrawable is
 referred to by its file name (not including file suffix) in the
  AnimatedVectorDrawable XML example .
  
 <vector xmlns:android=""http://schemas.android.com/apk/res/android""
     android:height=""64dp""
     android:width=""64dp""
     android:viewportHeight=""600""
     android:viewportWidth=""600"" >
     <group
         android:name=""rotationGroup""
         android:pivotX=""300.0""
         android:pivotY=""300.0""
         android:rotation=""45.0"" >
         <path
             android:name=""v""
             android:fillColor=""#000000""
             android:pathData=""M30070 l 0-70 7070 00 -7070z"" />
     </group>
 </vector>
  XML for AnimatedVectorDrawable 
 An AnimatedVectorDrawable element has a VectorDrawable attribute and one or more target
 element(s). The target element can specify its target by android:name attribute and link the
 target with the proper ObjectAnimator or AnimatorSet by android:animation attribute.
  
 The following code sample defines an AnimatedVectorDrawable. Note that the names refer to the
 groups and paths in the  VectorDrawable XML above .
  
 <animated-vector xmlns:android=""http://schemas.android.com/apk/res/android""
     android:drawable=""@drawable/vectordrawable"" >
     <target
         android:name=""rotationGroup""
         android:animation=""@animator/rotation"" />
     <target
         android:name=""v""
         android:animation=""@animator/path_morph"" />
 </animated-vector>
  XML for Animations defined using ObjectAnimator or AnimatorSet 
 From the previous  example of AnimatedVectorDrawable  two animations
 were used: rotation.xml and path_morph.xml.
  
 rotation.xml rotates the target group from 0 degree to 360 degrees over 6000ms:
  
 <objectAnimator
     android:duration=""6000""
     android:propertyName=""rotation""
     android:valueFrom=""0""
     android:valueTo=""360"" />
  

 path_morph.xml morphs the path from one shape into the other. Note that the paths must be
 compatible for morphing. Specifically the paths must have the same commands in the same order
 and must have the same number of parameters for each command. It is recommended to store path
 strings as string resources for reuse.
  
 <set xmlns:android=""http://schemas.android.com/apk/res/android"">
     <objectAnimator
         android:duration=""3000""
         android:propertyName=""pathData""
         android:valueFrom=""M30070 l 0-70 7070 00 -7070z""
         android:valueTo=""M30070 l 0-70 700  0140 -700 z""
         android:valueType=""pathType""/>
 </set>
  Define an AnimatedVectorDrawable all in one XML file 
 Since the AAPT tool supports a new format that bundles several related XML files together we can
 merge the XML files from the previous examples into one XML file:
  
 <animated-vector xmlns:android=""http://schemas.android.com/apk/res/android""
                  xmlns:aapt=&quothttp://schemas.android.com/aapt"" >
     <aapt:attr name=""android:drawable"">
         <vector
             android:height=""64dp""
             android:width=""64dp""
             android:viewportHeight=""600""
             android:viewportWidth=""600"" >
             <group
                 android:name=""rotationGroup""
                 android:pivotX=""300.0""
                 android:pivotY=""300.0""
                 android:rotation=""45.0"" >
                 <path
                     android:name=""v""
                     android:fillColor=""#000000""
                     android:pathData=""M30070 l 0-70 7070 00 -7070z"" />
             </group>
         </vector>
     </aapt:attr>

     <target android:name=""rotationGroup""> *
         <aapt:attr name=""android:animation"">
             <objectAnimator
             android:duration=""6000""
             android:propertyName=""rotation""
             android:valueFrom=""0""
             android:valueTo=""360"" />
         </aapt:attr>
     </target>

     <target android:name=""v"" >
         <aapt:attr name=""android:animation"">
             <set>
                 <objectAnimator
                     android:duration=""3000""
                     android:propertyName=""pathData""
                     android:valueFrom=""M30070 l 0-70 7070 00 -7070z""
                     android:valueTo=""M30070 l 0-70 700  0140 -700 z""
                     android:valueType=""pathType""/>
             </set>
         </aapt:attr>
      </target>
 </animated-vector>"
android,graphics.drawable,AnimationDrawable,15,"An object used to create frame-by-frame animations defined by a series of
 Drawable objects which can be used as a View object's background.
  
 The simplest way to create a frame-by-frame animation is to define the
 animation in an XML file placed in the res/drawable/ folder and set it as
 the background to a View object. Then call  start()  to run the
 animation.
  
 An AnimationDrawable defined in XML consists of a single
  <animation-list>  element and a series of nested
  <item>  tags. Each item defines a frame of the animation. See
 the example below.
  
 spin_animation.xml file in res/drawable/ folder:
  
 <!-- Animation frames are wheel0.png through wheel5.png
     files inside the res/drawable/ folder -->
 <animation-list android:id=""@+id/selected"" android:oneshot=""false"">
    <item android:drawable=""@drawable/wheel0"" android:duration=""50"" />
    <item android:drawable=""@drawable/wheel1"" android:duration=""50"" />
    <item android:drawable=""@drawable/wheel2"" android:duration=""50"" />
    <item android:drawable=""@drawable/wheel3"" android:duration=""50"" />
    <item android:drawable=""@drawable/wheel4"" android:duration=""50"" />
    <item android:drawable=""@drawable/wheel5"" android:duration=""50"" />
 </animation-list> 
 Here is the code to load and play this animation.
  
 // Load the ImageView that will host the animation and
 // set its background to our AnimationDrawable XML resource.
 ImageView img = (ImageView)findViewById(R.id.spinning_wheel_image);
 img.setBackgroundResource(R.drawable.spin_animation);

 // Get the background which has been compiled to an AnimationDrawable object.
 AnimationDrawable frameAnimation = (AnimationDrawable) img.getBackground();

 // Start the animation (looped playback by default).
 frameAnimation.start();"
android,graphics.drawable,ClipDrawable,5,"A Drawable that clips another Drawable based on this Drawable's current
 level value.  You can control how much the child Drawable gets clipped in width
 and height based on the level as well as a gravity to control where it is
 placed in its overall container.  Most often used to implement things like
 progress bars by increasing the drawable's level with  setLevel() .
  Note:  The drawable is clipped completely and not visible when
 the level is 0 and fully revealed when the level is 10000. It can be defined in an XML file with the  <clip>  element.  For more
 information see the guide to  Drawable Resources ."
android,graphics.drawable,DrawableWrapper,33,Drawable container with only one child element.
android,graphics.drawable,Icon,22,"An umbrella container for several serializable graphics representations including Bitmaps
 compressed bitmap images (e.g. JPG or PNG) and drawable resources (including vectors).

  Much ink 
 has been spilled on the best way to load images and many clients may have different needs when
 it comes to threading and fetching. This class is therefore focused on encapsulation rather than
 behavior."
android,graphics.drawable,PictureDrawable,8,"Drawable subclass that wraps a Picture allowing the picture to be used
 wherever a Drawable is supported."
android,graphics.drawable,Drawable.ConstantState,5,"This abstract class is used by  Drawable s to store shared constant state and data
 between Drawables.  BitmapDrawable s created from the same resource will for instance
 share a unique bitmap stored in their ConstantState.

  newDrawable(android.content.res.Resources)  can be used as a factory to create new Drawable instances
 from this ConstantState.
  Drawable#getConstantState() Drawable#mutate()"
android,graphics.drawable,DrawableContainer,40,"A helper class that contains several  Drawable s and selects which one to use.

 You can subclass it to create your own DrawableContainers or directly use one its child classes."
android,graphics.drawable,DrawableContainer.DrawableContainerState,23,"A ConstantState that can contain several  Drawable s.

 This class was made public to enable testing and its visibility may change in a future
 release."
android,graphics.drawable,InsetDrawable,9,"A Drawable that insets another Drawable by a specified distance or fraction of the content bounds.
 This is used when a View needs a background that is smaller than
 the View's actual bounds.

  It can be defined in an XML file with the  <inset>  element. For more
 information see the guide to  Drawable Resources ."
android,graphics.drawable,LayerDrawable,74,"A Drawable that manages an array of other Drawables. These are drawn in array
 order so the element with the largest index will be drawn on top.
  
 It can be defined in an XML file with the  <layer-list>  element.
 Each Drawable in the layer is defined in a nested  <item> .
  
 For more information see the guide to
  Drawable Resources ."
android,graphics.drawable,NinePatchDrawable,30,"A resizeable bitmap with stretchable areas that you define. This type of image
 is defined in a .png file with a special format."
android,graphics.drawable,RippleDrawable,23,"Drawable that shows a ripple effect in response to state changes. The
 anchoring position of the ripple for a given state may be specified by
 calling  setHotspot(float float)  with the corresponding state
 attribute identifier.
  
 A touch feedback drawable may contain multiple child layers including a
 special mask layer that is not drawn to the screen. A single layer may be
 set as the mask from XML by specifying its  android:id  value as
  R.id.mask . At run time a single layer may be set as the
 mask using  setId(... android.R.id.mask)  or an existing mask layer
 may be replaced using  setDrawableByLayerId(android.R.id.mask ...) .
  <!-- A red ripple masked against an opaque rectangle. --/>
 <ripple android:color=""#ffff0000"">
   <item android:id=""@android:id/mask""
         android:drawable=""@android:color/white"" />
 </ripple> 
 If a mask layer is set the ripple effect will be masked against that layer
 before it is drawn over the composite of the remaining child layers.
  
 If no mask layer is set the ripple effect is masked against the composite
 of the child layers.
  <!-- A green ripple drawn atop a black rectangle. --/>
 <ripple android:color=""#ff00ff00"">
   <item android:drawable=""@android:color/black"" />
 </ripple>

 <!-- A blue ripple drawn atop a drawable resource. --/>
 <ripple android:color=""#ff0000ff"">
   <item android:drawable=""@drawable/my_drawable"" />
 </ripple> 
 If no child layers or mask is specified and the ripple is set as a View
 background the ripple will be drawn atop the first available parent
 background within the View's hierarchy. In this case the drawing region
 may extend outside of the Drawable bounds.
  <!-- An unbounded red ripple. --/>
 <ripple android:color=""#ffff0000"" />"
android,graphics.drawable,RotateDrawable,16,"A Drawable that can rotate another Drawable based on the current level value.
 The start and end angles of rotation can be controlled to map any circular
 arc to the level values range.
  
 It can be defined in an XML file with the  <rotate>  element.
 For more information see the guide to
  Animation Resources ."
android,graphics.drawable,ShapeDrawable.ShaderFactory,1,"Base class defines a factory object that is called each time the drawable
 is resized (has a new width or height). Its resize() method returns a
 corresponding shader or null. Implement this class if you'd like your
 ShapeDrawable to use a special  Shader  such as a
  LinearGradient ."
android,graphics.drawable,TransitionDrawable,6,"An extension of LayerDrawables that is intended to cross-fade between
 the first and second layer. To start the transition call  startTransition(int) . To
 display just the first layer call  resetTransition() .
  
 It can be defined in an XML file with the  <transition>  element.
 Each Drawable in the transition is defined in a nested  <item> . For more
 information see the guide to  Drawable Resources ."
android,graphics.drawable,ColorStateListDrawable,24,"A Drawable that manages a  ColorDrawable  to make it stateful and backed by a
  ColorStateList ."
android,graphics.drawable,PaintDrawable,3,"Drawable that draws its bounds in the given paint with optional
 rounded corners."
android,graphics.drawable,ScaleDrawable,6,"A Drawable that changes the size of another Drawable based on its current
 level value. You can control how much the child Drawable changes in width
 and height based on the level as well as a gravity to control where it is
 placed in its overall container. Most often used to implement things like
 progress bars.
  
 The default level may be specified from XML using the
  android:level  property. When
 this property is not specified the default level is 0 which corresponds to
 zero height and/or width depending on the values specified for
  android.R.styleable#ScaleDrawable_scaleWidth scaleWidth  and
  android.R.styleable#ScaleDrawable_scaleHeight scaleHeight . At run
 time the level may be set via  Drawable.setLevel(int) .
  
 A scale drawable may be defined in an XML file with the  <scale> 
 element. For more information see the guide to
  Drawable
 Resources ."
android,graphics.drawable,ShapeDrawable,31,"A Drawable object that draws primitive shapes. A ShapeDrawable takes a
  Shape  object and manages its
 presence on the screen. If no Shape is given then the ShapeDrawable will
 default to a  RectShape .
  
 This object can be defined in an XML file with the  <shape> 
 element."
android,graphics.drawable,VectorDrawable,21,"This lets you create a drawable based on an XML vector graphic.
  Note: <vector> <vector> Used to define a vector drawable
  android:name Defines the name of this vector drawable. android:width Used to define the intrinsic width of the drawable.
 This support all the dimension units normally specified with dp. android:height Used to define the intrinsic height the drawable.
 This support all the dimension units normally specified with dp. android:viewportWidth Used to define the width of the viewport space. Viewport is basically
 the virtual canvas where the paths are drawn on. android:viewportHeight Used to define the height of the viewport space. Viewport is basically
 the virtual canvas where the paths are drawn on. android:tint The color to apply to the drawable as a tint. By default no tint is applied. android:tintMode The Porter-Duff blending mode for the tint color. Default is src_in. android:autoMirrored Indicates if the drawable needs to be mirrored when its layout direction is
 RTL (right-to-left). Default is false. android:alpha The opacity of this drawable. Default is 1.0. <group> Defines a group of paths or subgroups plus transformation information.
 The transformations are defined in the same coordinates as the viewport.
 And the transformations are applied in the order of scale rotate then translate.
  android:name Defines the name of the group. android:rotation The degrees of rotation of the group. Default is 0. android:pivotX The X coordinate of the pivot for the scale and rotation of the group.
 This is defined in the viewport space. Default is 0. android:pivotY The Y coordinate of the pivot for the scale and rotation of the group.
 This is defined in the viewport space. Default is 0. android:scaleX The amount of scale on the X Coordinate. Default is 1. android:scaleY The amount of scale on the Y coordinate. Default is 1. android:translateX The amount of translation on the X coordinate.
 This is defined in the viewport space. Default is 0. android:translateY The amount of translation on the Y coordinate.
 This is defined in the viewport space. Default is 0. <path> Defines paths to be drawn.
  android:name Defines the name of the path. android:pathData Defines path data using exactly same format as ""d"" attribute
 in the SVG's path data. This is defined in the viewport space. android:fillColor Specifies the color used to fill the path. May be a color or for SDK 24+ a color state list
 or a gradient color (See  R.styleable.GradientColor 
 and  R.styleable.GradientColorItem ).
 If this property is animated any value set by the animation will override the original value.
 No path fill is drawn if this property is not specified. android:strokeColor Specifies the color used to draw the path outline. May be a color or for SDK 24+ a color
 state list or a gradient color (See  R.styleable.GradientColor 
 and  R.styleable.GradientColorItem ).
 If this property is animated any value set by the animation will override the original value.
 No path outline is drawn if this property is not specified. android:strokeWidth The width a path stroke. Default is 0. android:strokeAlpha The opacity of a path stroke. Default is 1. android:fillAlpha The opacity to fill the path with. Default is 1. android:trimPathStart The fraction of the path to trim from the start in the range from 0 to 1. Default is 0. android:trimPathEnd The fraction of the path to trim from the end in the range from 0 to 1. Default is 1. android:trimPathOffset Shift trim region (allows showed region to include the start and end) in the range
 from 0 to 1. Default is 0. android:strokeLineCap Sets the linecap for a stroked path: butt round square. Default is butt. android:strokeLineJoin Sets the lineJoin for a stroked path: miterroundbevel. Default is miter. android:strokeMiterLimit Sets the Miter limit for a stroked path. Default is 4. android:fillType For SDK 24+ sets the fillType for a path. The types can be either ""evenOdd"" or ""nonZero"". They behave the
 same as SVG's ""fill-rule"" properties. Default is nonZero. For more details see
  FillRuleProperty <clip-path> Defines path to be the current clip. Note that the clip path only apply to
 the current group and its children.
  android:name Defines the name of the clip path. Animatable : No. android:pathData Defines clip path using the same format as ""d"" attribute
 in the SVG's path data. Animatable : Yes. Here is a simple VectorDrawable in this vectordrawable.xml file.
  
 <vector xmlns:android=""http://schemas.android.com/apk/res/android""
     android:height=""64dp""
     android:width=""64dp""
     android:viewportHeight=""600""
     android:viewportWidth=""600"" >
     <group
         android:name=""rotationGroup""
         android:pivotX=""300.0""
         android:pivotY=""300.0""
         android:rotation=""45.0"" >
         <path
             android:name=""v""
             android:fillColor=""#000000""
             android:pathData=""M30070 l 0-70 7070 00 -7070z"" />
     </group>
 </vector>
  Gradient support LinearGradient RadialGradient SweepGradient Shader.TileMode R.styleable.GradientColor LinearGradient RadialGradient SweepGradient startColor  startColor startColor centerColor centerColor centerColor endColor endColor endColor type type type tileMode tileMode tileMode startX centerX centerX startY centerY centerY endX gradientRadius endY R.styleable.GradientColorItem R.styleable.GradientColor R.styleable.GradientColorItem 
 <gradient xmlns:android=""http://schemas.android.com/apk/res/android""
     android:startColor=""?android:attr/colorPrimary""
     android:endColor=""?android:attr/colorControlActivated""
     android:centerColor=""#f00""
     android:startX=""0""
     android:startY=""0""
     android:endX=""100""
     android:endY=""100""
     android:type=""linear"">
 </gradient>
  
 <gradient xmlns:android=""http://schemas.android.com/apk/res/android""
     android:centerX=""300""
     android:centerY=""300""
     android:gradientRadius=""100""
     android:type=""radial"">
     <item android:offset=""0.1"" android:color=""#0ff""/>
     <item android:offset=""0.4"" android:color=""#fff""/>
     <item android:offset=""0.9"" android:color=""#ff0""/>
 </gradient>"
android,hardware.biometrics,BiometricManager,1,A class that contains biometric utilities. For authentication see  BiometricPrompt .
android,hardware.biometrics,BiometricPrompt,2,A class that manages a system-provided biometric dialog.
android,hardware.biometrics,BiometricPrompt.AuthenticationCallback,4,"Callback structure provided to  BiometricPrompt#authenticate(CancellationSignal
 Executor AuthenticationCallback)  or  BiometricPrompt#authenticate(CryptoObject
 CancellationSignal Executor AuthenticationCallback) . Users must provide an implementation
 of this for listening to authentication events."
android,hardware.biometrics,BiometricPrompt.AuthenticationResult,1,Container for callback data from  BiometricPrompt.authenticate(android.os.CancellationSignal java.util.concurrent.Executor android.hardware.biometrics.BiometricPrompt.AuthenticationCallback)  and  BiometricPrompt.authenticate(android.hardware.biometrics.BiometricPrompt.CryptoObject android.os.CancellationSignal java.util.concurrent.Executor android.hardware.biometrics.BiometricPrompt.AuthenticationCallback)
android,hardware.biometrics,BiometricPrompt.Builder,7,"A builder that collects arguments to be shown on the system-provided biometric dialog.
     * @apiSince 28"
android,hardware.biometrics,BiometricPrompt.CryptoObject,3,"A wrapper class for the crypto objects supported by BiometricPrompt. Currently the framework
 supports  Signature   Cipher  and  Mac  objects."
android,hardware,Camera.CameraInfo,0,Information about a camera
android,hardware,Camera.Face,0,"Information about a face identified through camera face detection.

  When face detection is used with a camera the  FaceDetectionListener  returns a
 list of face objects for use in focusing and metering."
android,hardware,GeomagneticField,7,"Estimates magnetic field at a given point on
 Earth and in particular to compute the magnetic declination from true
 north.

  This uses the World Magnetic Model produced by the United States National
 Geospatial-Intelligence Agency.  More details about the model can be found at
  http://www.ngdc.noaa.gov/geomag/WMM/DoDWMM.shtml .
 This class currently uses WMM-2015 which is valid until 2020 but should
 produce acceptable results for several years after that. Future versions of
 Android may use a newer version of the model."
android,hardware,Sensor,20,"Class representing a sensor. Use  SensorManager#getSensorList  to get
 the list of available sensors. For more information about Android sensors
 read the
  Motion Sensors guide ."
android,hardware,SensorAdditionalInfo,0,"This class represents a  Sensor  additional information frame
 which is reported through listener callback  onSensorAdditionalInfo ."
android,hardware,SensorEventCallback,4,Used for receiving sensor additional information frames.
android,hardware,SensorManager,32,"SensorManager lets you access the device's  sensors .
  
 Always make sure to disable sensors you don't need especially when your
 activity is paused. Failing to do so can drain the battery in just a few
 hours. Note that the system will  not  disable sensors automatically when
 the screen turns off.
  
 Note: Don't use this mechanism with a Trigger Sensor have a look
 at  TriggerEventListener .  Sensor#TYPE_SIGNIFICANT_MOTION 
 is an example of a trigger sensor.
  
 public class SensorActivity extends Activity implements SensorEventListener {
     private final SensorManager mSensorManager;
     private final Sensor mAccelerometer;

     public SensorActivity() {
         mSensorManager = (SensorManager)getSystemService(SENSOR_SERVICE);
         mAccelerometer = mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
     }

     protected void onResume() {
         super.onResume();
         mSensorManager.registerListener(this mAccelerometer SensorManager.SENSOR_DELAY_NORMAL);
     }

     protected void onPause() {
         super.onPause();
         mSensorManager.unregisterListener(this);
     }

     public void onAccuracyChanged(Sensor sensor int accuracy) {
     }

     public void onSensorChanged(SensorEvent event) {
     }
 }"
android,hardware,SensorManager.DynamicSensorCallback,2,"Used for receiving notifications from the SensorManager when dynamic sensors are connected or
 disconnected."
android,hardware,Camera,33,"The Camera class is used to set image capture settings start/stop preview
 snap pictures and retrieve frames for encoding for video.  This class is a
 client for the Camera service which manages the actual camera hardware.

  To access the device camera you must declare the
  Manifest.permission.CAMERA  permission in your Android
 Manifest. Also be sure to include the
  <uses-feature> 
 manifest element to declare camera features used by your application.
 For example if you use the camera and auto-focus feature your Manifest
 should include the following:  <uses-permission android:name=""android.permission.CAMERA"" />
 <uses-feature android:name=""android.hardware.camera"" />
 <uses-feature android:name=""android.hardware.camera.autofocus"" /> To take pictures with this class use the following steps: Obtain an instance of Camera from  open(int) .

  Get existing (default) settings with  getParameters() .

  If necessary modify the returned  Camera.Parameters  object and call
  setParameters(android.hardware.Camera.Parameters) .

  Call  setDisplayOrientation(int)  to ensure correct orientation of preview.

  Important : Pass a fully initialized  SurfaceHolder  to
  setPreviewDisplay(android.view.SurfaceHolder) .  Without a surface the camera
 will be unable to start the preview.

  Important : Call  startPreview()  to start updating the
 preview surface.  Preview must be started before you can take a picture.

  When you want call  takePicture(android.hardware.Camera.ShutterCallback android.hardware.Camera.PictureCallback android.hardware.Camera.PictureCallback android.hardware.Camera.PictureCallback)  to
 capture a photo.  Wait for the callbacks to provide the actual image data.

  After taking a picture preview display will have stopped.  To take more
 photos call  startPreview()  again first.

  Call  stopPreview()  to stop updating the preview surface.

  Important:  Call  release()  to release the camera for
 use by other applications.  Applications should release the camera
 immediately in  Activity.onPause()  (and re- open() 
 it in  Activity.onResume() ).
  To quickly switch to video recording mode use these steps: Obtain and initialize a Camera and start preview as described above.

  Call  unlock()  to allow the media process to access the camera.

  Pass the camera to  MediaRecorder.setCamera(Camera) .
 See  MediaRecorder  information about video recording.

  When finished recording call  reconnect()  to re-acquire
 and re-lock the camera.

  If desired restart preview and take more photos or videos.

  Call  stopPreview()  and  release()  as described above.
  This class is not thread-safe and is meant for use from one event thread.
 Most long-running operations (preview focus photo capture etc) happen
 asynchronously and invoke callbacks as necessary.  Callbacks will be invoked
 on the event thread  open(int)  was called from.  This class's methods
 must never be called from multiple threads at once."
android,hardware,Camera.Area,1,"The Area class is used for choosing specific metering and focus areas for
 the camera to use when calculating auto-exposure auto-white balance and
 auto-focus. To find out how many simultaneous areas a given camera supports use
  Parameters#getMaxNumMeteringAreas()  and
  Parameters#getMaxNumFocusAreas() . If metering or focusing area
 selection is unsupported these methods will return 0. Each Area consists of a rectangle specifying its bounds and a weight
 that determines its importance. The bounds are relative to the camera's
 current field of view. The coordinates are mapped so that (-1000 -1000)
 is always the top-left corner of the current field of view and (1000
 1000) is always the bottom-right corner of the current field of
 view. Setting Areas with bounds outside that range is not allowed. Areas
 with zero or negative width or height are not allowed. The weight must range from 1 to 1000 and represents a weight for
 every pixel in the area. This means that a large metering area with
 the same weight as a smaller area will have more effect in the
 metering result.  Metering areas can overlap and the driver
 will add the weights in the overlap region."
android,hardware,Camera.Parameters,92,"Camera service settings.

  To make camera parameters take effect applications have to call
  Camera#setParameters(Camera.Parameters) . For example after
  Camera.Parameters#setWhiteBalance  is called white balance is not
 actually changed until  Camera#setParameters(Camera.Parameters) 
 is called with the changed parameters object.

  Different devices may have different camera capabilities such as
 picture size or flash modes. The application should query the camera
 capabilities before setting parameters. For example the application
 should call  Camera.Parameters#getSupportedColorEffects()  before
 calling  Camera.Parameters#setColorEffect(String) . If the
 camera does not support color effects
  Camera.Parameters#getSupportedColorEffects()  will return null."
android,hardware,Camera.Size,2,Image size (width and height dimensions).
android,hardware,ConsumerIrManager,3,"Class that operates consumer infrared on the device.
 
  
 Requires the  PackageManager#FEATURE_CONSUMER_IR  feature which can be detected using  PackageManager.hasSystemFeature(String) ."
android,hardware,ConsumerIrManager.CarrierFrequencyRange,2,"Represents a range of carrier frequencies (inclusive) on which the
 infrared transmitter can transmit"
android,hardware,HardwareBuffer,12,"HardwareBuffer wraps a native  AHardwareBuffer  object which is a low-level object
 representing a memory buffer accessible by various hardware units. HardwareBuffer allows sharing
 buffers across different application processes. In particular HardwareBuffers may be mappable
 to memory accessibly to various hardware systems such as the GPU a sensor or context hub or
 other auxiliary processing units.

 For more information see the NDK documentation for  AHardwareBuffer ."
android,hardware,SensorDirectChannel,4,"Class representing a sensor direct channel. Use
  SensorManager#createDirectChannel(android.os.MemoryFile)  or
  SensorManager#createDirectChannel(android.hardware.HardwareBuffer) 
 to obtain an object. The channel object can be then configured
 (see  configure(android.hardware.Sensor int) )
 to start delivery of sensor events into shared memory buffer."
android,hardware,SensorEvent,0,"This class represents a  Sensor  event and
 holds information such as the sensor's type the time-stamp accuracy and of
 course the sensor's  SensorEvent#values .

  Definition of the coordinate system used by the SensorEvent API. 
 The coordinate-system is defined relative to the screen of the phone in its
 default orientation. The axes are not swapped when the device's screen
 orientation changes.
  
 The X axis is horizontal and points to the right the Y axis is vertical and
 points up and the Z axis points towards the outside of the front face of the
 screen. In this system coordinates behind the screen have negative Z values.
  Note:  This coordinate system is different from the one used in the
 Android 2D APIs where the origin is in the top-left corner."
android,hardware,TriggerEvent,0,"This class represents a Trigger Event - the event
 associated with a Trigger Sensor. When the sensor detects a trigger
 event condition such as significant motion in the case of the
  Sensor#TYPE_SIGNIFICANT_MOTION  the  TriggerEventListener 
 is called with the TriggerEvent. The sensor is automatically canceled
 after the trigger.
  
 This class holds information such as the value of the sensor
 when the trigger happened the timestamp along with detailed
 information regarding the Sensor itself."
android,hardware,TriggerEventListener,1,"This class is the listener used to handle Trigger Sensors.
 Trigger Sensors are sensors that trigger an event and are automatically
 disabled.  Sensor#TYPE_SIGNIFICANT_MOTION  is one such example.
  SensorManager  lets you access the device's  sensors . Get an instance of  SensorManager  by calling
  Context.getSystemService()  with the argument
  Context.SENSOR_SERVICE .
  Here's an example setup for a TriggerEventListener:

  
 class TriggerListener extends TriggerEventListener {
     public void onTrigger(TriggerEvent event) {
          // Do Work.

     // As it is a one shot sensor it will be canceled automatically.
     // SensorManager.requestTriggerSensor(this mSigMotion); needs to
     // be called again if needed.
     }
 }
 public class SensorActivity extends Activity {
     private final SensorManager mSensorManager;
     private final Sensor mSigMotion;
     private final TriggerEventListener mListener = new TriggerEventListener();

     public SensorActivity() {
         mSensorManager = (SensorManager)getSystemService(SENSOR_SERVICE);
         mSigMotion = mSensorManager.getDefaultSensor(Sensor.TYPE_SIGNIFICANT_MOTION);
     }

     protected void onResume() {
         super.onResume();
         mSensorManager.requestTriggerSensor(mListener mSigMotion);
     }

     protected void onPause() {
         super.onPause();
         // Call disable to ensure that the trigger request has been canceled.
         mSensorManager.cancelTriggerSensor(mListener mSigMotion);
     }

 }"
android,app,ActionBar,61,"A primary toolbar within the activity that may display the activity title application-level
 navigation affordances and other interactive items.

  Beginning with Android 3.0 (API level 11) the action bar appears at the top of an
 activity's window when the activity uses the system's  Holo  theme (or one of its descendant themes) which is the default.
 You may otherwise add the action bar by calling  requestFeature(FEATURE_ACTION_BAR)  or by declaring it in a
 custom theme with the  windowActionBar  property.
  Beginning with Android L (API level 21) the action bar may be represented by any
 Toolbar widget within the application layout. The application may signal to the Activity
 which Toolbar should be treated as the Activity's action bar. Activities that use this
 feature should use one of the supplied  .NoActionBar  themes set the
  windowActionBar  attribute to  false 
 or otherwise not request the window feature. By adjusting the window features requested by the theme and the layouts used for
 an Activity's content view an app can use the standard system action bar on older platform
 releases and the newer inline toolbars on newer platform releases. The  ActionBar 
 object obtained from the Activity can be used to control either configuration transparently. When using the Holo themes the action bar shows the application icon on
 the left followed by the activity title. If your activity has an options menu you can make
 select items accessible directly from the action bar as ""action items"". You can also
 modify various characteristics of the action bar or remove it completely. When using the Material themes (default in API 21 or newer) the navigation button
 (formerly ""Home"") takes over the space previously occupied by the application icon.
 Apps wishing to express a stronger branding should use their brand colors heavily
 in the action bar and other application chrome or use a  logo 
 in place of their standard title text. From your activity you can retrieve an instance of  ActionBar  by calling  getActionBar() . In some cases the action bar may be overlayed by another bar that enables contextual actions
 using an  ActionMode . For example when the user selects one or more items in
 your activity you can enable an action mode that offers actions specific to the selected
 items with a UI that temporarily replaces the action bar. Although the UI may occupy the
 same space the  ActionMode  APIs are distinct and independent from those for
  ActionBar ."
android,app,ActivityManager,34,"This class gives information about and interacts
 with activities services and the containing
 process.
  
 A number of the methods in this class are for
 debugging or informational purposes and they should
 not be used to affect any runtime behavior of
 your app. These methods are called out as such in
 the method level documentation.
  
 Most application developers should not have the need to
 use this class most of whose methods are for specialized
 use cases. However a few methods are more broadly applicable.
 For instance  isLowRamDevice() 
 enables your app to detect whether it is running on a low-memory device
 and behave accordingly.
  clearApplicationUserData() 
 is for apps with reset-data functionality.
  
 In some special use cases where an app interacts with
 its Task stack the app may use the
  ActivityManager.AppTask  and
  ActivityManager.RecentTaskInfo  inner
 classes. However in general the methods in this class should
 be used for testing and debugging purposes only."
android,app,ActivityManager.AppTask,5,"The AppTask allows you to manage your own application's tasks.
 See  ActivityManager.getAppTasks()"
android,app,ActivityManager.MemoryInfo,3,"Information you can retrieve about the available memory through
  ActivityManager#getMemoryInfo ."
android,app,ActivityManager.ProcessErrorStateInfo,3,Information you can retrieve about any processes that are in an error condition.
android,app,ActivityManager.RecentTaskInfo,3,"Information you can retrieve about tasks that the user has most recently
 started or visited."
android,app,ActivityManager.RunningAppProcessInfo,3,Information you can retrieve about a running process.
android,app,ActivityManager.RunningServiceInfo,3,"Information you can retrieve about a particular Service that is
 currently running in the system."
android,app,ActivityManager.RunningTaskInfo,3,"Information you can retrieve about a particular task that is currently
 ""running"" in the system.  Note that a running task does not mean the
 given task actually has a process it is actively running in; it simply
 means that the user has gone to it and never closed it but currently
 the system may have killed its process and is only holding on to its
 last state in order to restart it when the user returns."
android,app,ActivityManager.TaskDescription,7,Information you can set and retrieve about the current activity within the recent task list.
android,app,ActivityOptions,18,"Helper class for building an options Bundle that can be used with
  Context.startActivity(Intent Bundle)  and related methods."
android,app,AlarmManager,16,"This class provides access to the system alarm services.  These allow you
 to schedule your application to be run at some point in the future.  When
 an alarm goes off the  Intent  that had been registered for it
 is broadcast by the system automatically starting the target application
 if it is not already running.  Registered alarms are retained while the
 device is asleep (and can optionally wake the device up if they go off
 during that time) but will be cleared if it is turned off and rebooted.

  The Alarm Manager holds a CPU wake lock as long as the alarm receiver's
 onReceive() method is executing. This guarantees that the phone will not sleep
 until you have finished handling the broadcast. Once onReceive() returns the
 Alarm Manager releases this wake lock. This means that the phone will in some
 cases sleep as soon as your onReceive() method completes.  If your alarm receiver
 called  Context.startService()  it
 is possible that the phone will sleep before the requested service is launched.
 To prevent this your BroadcastReceiver and Service will need to implement a
 separate wake lock policy to ensure that the phone continues running until the
 service becomes available.

  Note: The Alarm Manager is intended for cases where you want to have
 your application code run at a specific time even if your application is
 not currently running.  For normal timing operations (ticks timeouts
 etc) it is easier and much more efficient to use
  Handler ."
android,app,AlertDialog,22,"A subclass of Dialog that can display one two or three buttons. If you only want to
 display a String in this dialog box use the setMessage() method.  If you
 want to display a more complex view look up the FrameLayout called ""custom""
 and add your view to it:

  
 FrameLayout fl = findViewById(android.R.id.custom);
 fl.addView(myView new LayoutParams(MATCH_PARENT WRAP_CONTENT));
  The AlertDialog class takes care of automatically setting
  WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM  for you based on whether
 any views in the dialog return true from  View#onCheckIsTextEditor() .  Generally you want this set for a Dialog
 without text editors so that it will be placed on top of the current
 input method UI.  You can modify this behavior by forcing the flag to your
 desired mode after calling  onCreate(Bundle) ."
android,app,AlertDialog.Builder,36,
android,app,AliasActivity,0,"Stub activity that launches another activity (and then finishes itself)
 based on information in its component's manifest meta-data.  This is a
 simple way to implement an alias-like mechanism.

 To use this activity you should include in the manifest for the associated
 component an entry named ""android.app.alias"".  It is a reference to an XML
 resource describing an intent that launches the real application."
android,app,AppComponentFactory,6,Interface used to control the instantiation of manifest elements.
android,app,ApplicationErrorReport,5,"Describes an application error.

 A report has a type which is one of
  TYPE_NONE  uninitialized instance of  ApplicationErrorReport .
  TYPE_CRASH  application crash. Information about the crash
 is stored in  crashInfo .
  TYPE_ANR  application not responding. Information about the
 ANR is stored in  anrInfo .
  TYPE_BATTERY  user reported application is using too much
 battery. Information about the battery use is stored in  batteryInfo .
  TYPE_RUNNING_SERVICE  user reported application is leaving an
 unneeded serive running. Information about the battery use is stored in
  runningServiceInfo ."
android,app,ApplicationErrorReport.CrashInfo,2,Describes an application crash.
android,app,AppOpsManager,19,"API for interacting with ""application operation"" tracking.

  This API is not generally intended for third party application developers; most
 features are only available to system applications."
android,app,DatePickerDialog,7,"A simple dialog containing an  DatePicker .
  
 See the  Pickers 
 guide."
android,app,DialogFragment,23,"A fragment that displays a dialog window floating on top of its
 activity's window.  This fragment contains a Dialog object which it
 displays as appropriate based on the fragment's state.  Control of
 the dialog (deciding when to show hide dismiss it) should be done through
 the API here not with direct calls on the dialog.

  Implementations should override this class and implement
  Fragment.onCreateView(android.view.LayoutInflater android.view.ViewGroup android.os.Bundle)  to supply the
 content of the dialog.  Alternatively they can override
  onCreateDialog(android.os.Bundle)  to create an entirely custom dialog such
 as an AlertDialog with its own content.

  Topics covered here:
  Lifecycle Basic Dialog Alert Dialog Selecting Between Dialog or Embedding Lifecycle DialogFragment does various things to keep the fragment's lifecycle
 driving it instead of the Dialog.  Note that dialogs are generally
 autonomous entities -- they are their own window receiving their own
 input events and often deciding on their own when to disappear (by
 receiving a back key event or the user clicking on a button).

  DialogFragment needs to ensure that what is happening with the Fragment
 and Dialog states remains consistent.  To do this it watches for dismiss
 events from the dialog and takes care of removing its own state when they
 happen.  This means you should use  show(android.app.FragmentManager java.lang.String) 
 or  show(android.app.FragmentTransaction java.lang.String)  to add an instance of
 DialogFragment to your UI as these keep track of how DialogFragment should
 remove itself when the dialog is dismissed.

  Basic Dialog The simplest use of DialogFragment is as a floating container for the
 fragment's view hierarchy.  A simple implementation may look like this:

  public static class MyDialogFragment extends DialogFragment {
    int mNum;

    /**
     * Create a new instance of MyDialogFragment providing ""num""
     * as an argument.
     */
    static MyDialogFragment newInstance(int num) {
        MyDialogFragment f = new MyDialogFragment();

        // Supply num input as an argument.
        Bundle args = new Bundle();
        args.putInt(""num"" num);
        f.setArguments(args);

        return f;
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        mNum = getArguments().getInt(""num"");

        // Pick a style based on the num.
        int style = DialogFragment.STYLE_NORMAL theme = 0;
        switch ((mNum-1)%6) {
            case 1: style = DialogFragment.STYLE_NO_TITLE; break;
            case 2: style = DialogFragment.STYLE_NO_FRAME; break;
            case 3: style = DialogFragment.STYLE_NO_INPUT; break;
            case 4: style = DialogFragment.STYLE_NORMAL; break;
            case 5: style = DialogFragment.STYLE_NORMAL; break;
            case 6: style = DialogFragment.STYLE_NO_TITLE; break;
            case 7: style = DialogFragment.STYLE_NO_FRAME; break;
            case 8: style = DialogFragment.STYLE_NORMAL; break;
        }
        switch ((mNum-1)%6) {
            case 4: theme = android.R.style.Theme_Holo; break;
            case 5: theme = android.R.style.Theme_Holo_Light_Dialog; break;
            case 6: theme = android.R.style.Theme_Holo_Light; break;
            case 7: theme = android.R.style.Theme_Holo_Light_Panel; break;
            case 8: theme = android.R.style.Theme_Holo_Light; break;
        }
        setStyle(style theme);
    }

    @Override
    public View onCreateView(LayoutInflater inflater ViewGroup container
            Bundle savedInstanceState) {
        View v = inflater.inflate(R.layout.fragment_dialog container false);
        View tv = v.findViewById(R.id.text);
        ((TextView)tv).setText(""Dialog #"" + mNum + "": using style ""
                + getNameForNum(mNum));

        // Watch for button clicks.
        Button button = (Button)v.findViewById(R.id.show);
        button.setOnClickListener(new OnClickListener() {
            public void onClick(View v) {
                // When button is clicked call up to owning activity.
                ((FragmentDialog)getActivity()).showDialog();
            }
        });

        return v;
    }
} An example showDialog() method on the Activity could be:

  void showDialog() {
    mStackLevel++;

    // DialogFragment.show() will take care of adding the fragment
    // in a transaction.  We also want to remove any currently showing
    // dialog so make our own transaction and take care of that here.
    FragmentTransaction ft = getFragmentManager().beginTransaction();
    Fragment prev = getFragmentManager().findFragmentByTag(""dialog"");
    if (prev != null) {
        ft.remove(prev);
    }
    ft.addToBackStack(null);

    // Create and show the dialog.
    DialogFragment newFragment = MyDialogFragment.newInstance(mStackLevel);
    newFragment.show(ft ""dialog"");
} This removes any currently shown dialog creates a new DialogFragment
 with an argument and shows it as a new state on the back stack.  When the
 transaction is popped the current DialogFragment and its Dialog will be
 destroyed and the previous one (if any) re-shown.  Note that in this case
 DialogFragment will take care of popping the transaction of the Dialog
 is dismissed separately from it.

  Alert Dialog Instead of (or in addition to) implementing  Fragment.onCreateView(LayoutInflater ViewGroup Bundle)  to
 generate the view hierarchy inside of a dialog you may implement
  onCreateDialog(android.os.Bundle)  to create your own custom Dialog object.

  This is most useful for creating an  AlertDialog  allowing you
 to display standard alerts to the user that are managed by a fragment.
 A simple example implementation of this is:

  public static class MyAlertDialogFragment extends DialogFragment {

    public static MyAlertDialogFragment newInstance(int title) {
        MyAlertDialogFragment frag = new MyAlertDialogFragment();
        Bundle args = new Bundle();
        args.putInt(""title"" title);
        frag.setArguments(args);
        return frag;
    }

    @Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {
        int title = getArguments().getInt(""title"");

        return new AlertDialog.Builder(getActivity())
                .setIcon(R.drawable.alert_dialog_icon)
                .setTitle(title)
                .setPositiveButton(R.string.alert_dialog_ok
                    new DialogInterface.OnClickListener() {
                        public void onClick(DialogInterface dialog int whichButton) {
                            ((FragmentAlertDialog)getActivity()).doPositiveClick();
                        }
                    }
                )
                .setNegativeButton(R.string.alert_dialog_cancel
                    new DialogInterface.OnClickListener() {
                        public void onClick(DialogInterface dialog int whichButton) {
                            ((FragmentAlertDialog)getActivity()).doNegativeClick();
                        }
                    }
                )
                .create();
    }
} The activity creating this fragment may have the following methods to
 show the dialog and receive results from it:

  void showDialog() {
    DialogFragment newFragment = MyAlertDialogFragment.newInstance(
            R.string.alert_dialog_two_buttons_title);
    newFragment.show(getFragmentManager() ""dialog"");
}

public void doPositiveClick() {
    // Do stuff here.
    Log.i(""FragmentAlertDialog"" ""Positive click!"");
}

public void doNegativeClick() {
    // Do stuff here.
    Log.i(""FragmentAlertDialog"" ""Negative click!"");
} Note that in this case the fragment is not placed on the back stack it
 is just added as an indefinitely running fragment.  Because dialogs normally
 are modal this will still operate as a back stack since the dialog will
 capture user input until it is dismissed.  When it is dismissed DialogFragment
 will take care of removing itself from its fragment manager.

  Selecting Between Dialog or Embedding A DialogFragment can still optionally be used as a normal fragment if
 desired.  This is useful if you have a fragment that in some cases should
 be shown as a dialog and others embedded in a larger UI.  This behavior
 will normally be automatically selected for you based on how you are using
 the fragment but can be customized with  setShowsDialog(boolean) .

  For example here is a simple dialog fragment:

  public static class MyDialogFragment extends DialogFragment {
    static MyDialogFragment newInstance() {
        return new MyDialogFragment();
    }

    @Override
    public View onCreateView(LayoutInflater inflater ViewGroup container
            Bundle savedInstanceState) {
        View v = inflater.inflate(R.layout.hello_world container false);
        View tv = v.findViewById(R.id.text);
        ((TextView)tv).setText(""This is an instance of MyDialogFragment"");
        return v;
    }
} An instance of this fragment can be created and shown as a dialog:

  void showDialog() {
    // Create the fragment and show it as a dialog.
    DialogFragment newFragment = MyDialogFragment.newInstance();
    newFragment.show(getFragmentManager() ""dialog"");
} It can also be added as content in a view hierarchy:

  FragmentTransaction ft = getFragmentManager().beginTransaction();
DialogFragment newFragment = MyDialogFragment.newInstance();
ft.add(R.id.embedded newFragment);
ft.commit();"
android,app,DirectAction,7,"Represents a abstract action that can be perform on this app. This are requested from
 outside the app's UI (eg by SystemUI or assistant). The semantics of these actions are
 not specified by the OS. This allows open-ended and scalable approach for defining how
 an app interacts with components that expose alternative interaction models to the user
 such as the assistant SystemUI etc. You can use  equals(java.lang.Object)  to compare
 instances of this class."
android,app,DownloadManager.Request,16,"This class contains all the information necessary to request a new download. The URI is the
 only required parameter.

 Note that the default download destination is a shared volume where the system might delete
 your file if it needs to reclaim space for system use. If this is a problem use a location
 on external storage (see  setDestinationUri(android.net.Uri) ."
android,app,FragmentBreadCrumbs,8,"Helper class for showing ""bread crumbs"" representing the fragment
 stack in an activity.  This is intended to be used with
  ActionBar#setCustomView(View)  to place the bread crumbs in
 the action bar.

  The default style for this view is
  R.style.Widget_FragmentBreadCrumbs ."
android,app,FragmentContainer,2,Callbacks to a  Fragment 's container.
android,app,FragmentController,40,"Provides integration points with a  FragmentManager  for a fragment host.
  
 It is the responsibility of the host to take care of the Fragment's lifecycle.
 The methods provided by  FragmentController  are for that purpose."
android,app,FragmentHostCallback,14,"Integration points with the Fragment host.
  
 Fragments may be hosted by any object; such as an  Activity . In order to
 host fragments implement  FragmentHostCallback  overriding the methods
 applicable to the host."
android,app,FragmentManagerNonConfig,0,"FragmentManagerNonConfig stores the retained instance fragments across
 activity recreation events.

  Apps should treat objects of this type as opaque returned by
 and passed to the state save and restore process for fragments in
  FragmentController#retainNonConfig()  and
  FragmentController#restoreAllState(Parcelable FragmentManagerNonConfig) ."
android,app,FragmentTransaction,30,API for performing a set of Fragment operations.
android,app,Instrumentation.ActivityResult,2,"Description of a Activity execution result to return to the original
 activity."
android,app,KeyguardManager,9,"Class that can be used to lock and unlock the keyguard. The
 actual class to control the keyguard locking is
  KeyguardManager.KeyguardLock ."
android,app,LauncherActivity,10,"Displays a list of all activities which can be performed
 for a given intent. Launches when clicked."
android,app,ListFragment,13,"A fragment that displays a list of items by binding to a data source such as
 an array or Cursor and exposes event handlers when the user selects an item.
  
 ListFragment hosts a  ListView  object that can
 be bound to different data sources typically either an array or a Cursor
 holding query results. Binding screen layout and row layout are discussed
 in the following sections.
  Screen Layout 
 ListFragment has a default layout that consists of a single list view.
 However if you desire you can customize the fragment layout by returning
 your own view hierarchy from  onCreateView(LayoutInflater ViewGroup Bundle) .
 To do this your view hierarchy  must  contain a ListView object with the
 id ""@android:id/list"" (or  R.id.list  if it's in code)
  
 Optionally your view hierarchy can contain another view object of any type to
 display when the list view is empty. This ""empty list"" notifier must have an
 id ""android:empty"". Note that when an empty view is present the list view
 will be hidden when there is no data to display.
  
 The following code demonstrates an (ugly) custom list layout. It has a list
 with a green background and an alternate red ""no data"" message.
  
 <?xml version=""1.0"" encoding=""utf-8""?>
 <LinearLayout xmlns:android=""http://schemas.android.com/apk/res/android""
         android:orientation=""vertical""
         android:layout_width=""match_parent""
         android:layout_height=""match_parent""
         android:paddingLeft=""8dp""
         android:paddingRight=""8dp"">

     <ListView android:id=""@id/android:list""
               android:layout_width=""match_parent""
               android:layout_height=""match_parent""
               android:background=""#00FF00""
               android:layout_weight=""1""
               android:drawSelectorOnTop=""false""/>

     <TextView android:id=""@id/android:empty""
               android:layout_width=""match_parent""
               android:layout_height=""match_parent""
               android:background=""#FF0000""
               android:text=""No data""/>
 </LinearLayout>
  Row Layout 
 You can specify the layout of individual rows in the list. You do this by
 specifying a layout resource in the ListAdapter object hosted by the fragment
 (the ListAdapter binds the ListView to the data; more on this later).
  
 A ListAdapter constructor takes a parameter that specifies a layout resource
 for each row. It also has two additional parameters that let you specify
 which data field to associate with which object in the row layout resource.
 These two parameters are typically parallel arrays.
  
 Android provides some standard row layout resources. These are in the
  R.layout  class and have names such as simple_list_item_1
 simple_list_item_2 and two_line_list_item. The following layout XML is the
 source for the resource two_line_list_item which displays two data
 fieldsone above the other for each list row.
  
 <?xml version=""1.0"" encoding=""utf-8""?>
 <LinearLayout xmlns:android=""http://schemas.android.com/apk/res/android""
     android:layout_width=""match_parent""
     android:layout_height=""wrap_content""
     android:orientation=""vertical"">

     <TextView android:id=""@+id/text1""
         android:textSize=""16sp""
         android:textStyle=""bold""
         android:layout_width=""match_parent""
         android:layout_height=""wrap_content""/>

     <TextView android:id=""@+id/text2""
         android:textSize=""16sp""
         android:layout_width=""match_parent""
         android:layout_height=""wrap_content""/>
 </LinearLayout>
  
 You must identify the data bound to each TextView object in this layout. The
 syntax for this is discussed in the next section.
  Binding to Data 
 You bind the ListFragment's ListView object to data using a class that
 implements the  ListAdapter  interface.
 Android provides two standard list adapters:
  SimpleAdapter  for static data (Maps)
 and  SimpleCursorAdapter  for Cursor
 query results.
  
 You  must  use
  ListFragment.setListAdapter()  to
 associate the list with an adapter.  Do not directly call
  ListView#setAdapter(ListAdapter)  or else
 important initialization will be skipped."
android,app,LoaderManager,6,"Interface associated with an  Activity  or  Fragment  for managing
 one or more  Loader  instances associated with it.  This
 helps an application manage longer-running operations in conjunction with the
 Activity or Fragment lifecycle; the most common use of this is with a
  CursorLoader  however applications are free to write
 their own loaders for loading other types of data.

 While the LoaderManager API was introduced in
  Build.VERSION_CODES.HONEYCOMB  a version of the API
 at is also available for use on older platforms through
  FragmentActivity .  See the blog post
  
 Fragments For All  for more details.

  As an example here is the full implementation of a  Fragment 
 that displays a  ListView  containing the results of
 a query against the contacts content provider.  It uses a
  CursorLoader  to manage the query on the provider.

  public static class CursorLoaderListFragment extends ListFragment
        implements OnQueryTextListener OnCloseListener
        LoaderManager.LoaderCallbacks<Cursor> {

    // This is the Adapter being used to display the list's data.
    SimpleCursorAdapter mAdapter;

    // The SearchView for doing filtering.
    SearchView mSearchView;

    // If non-null this is the current filter the user has provided.
    String mCurFilter;

    @Override public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        // Give some text to display if there is no data.  In a real
        // application this would come from a resource.
        setEmptyText(""No phone numbers"");

        // We have a menu item to show in action bar.
        setHasOptionsMenu(true);

        // Create an empty adapter we will use to display the loaded data.
        mAdapter = new SimpleCursorAdapter(getActivity()
                android.R.layout.simple_list_item_2 null
                new String[] { Contacts.DISPLAY_NAME Contacts.CONTACT_STATUS }
                new int[] { android.R.id.text1 android.R.id.text2 } 0);
        setListAdapter(mAdapter);

        // Start out with a progress indicator.
        setListShown(false);

        // Prepare the loader.  Either re-connect with an existing one
        // or start a new one.
        getLoaderManager().initLoader(0 null this);
    }

    public static class MySearchView extends SearchView {
        public MySearchView(Context context) {
            super(context);
        }

        // The normal SearchView doesn't clear its search text when
        // collapsed so we will do this for it.
        @Override
        public void onActionViewCollapsed() {
            setQuery("""" false);
            super.onActionViewCollapsed();
        }
    }

    @Override public void onCreateOptionsMenu(Menu menu MenuInflater inflater) {
        // Place an action bar item for searching.
        MenuItem item = menu.add(""Search"");
        item.setIcon(android.R.drawable.ic_menu_search);
        item.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM
                | MenuItem.SHOW_AS_ACTION_COLLAPSE_ACTION_VIEW);
        mSearchView = new MySearchView(getActivity());
        mSearchView.setOnQueryTextListener(this);
        mSearchView.setOnCloseListener(this);
        mSearchView.setIconifiedByDefault(true);
        item.setActionView(mSearchView);
    }

    public boolean onQueryTextChange(String newText) {
        // Called when the action bar search text has changed.  Update
        // the search filter and restart the loader to do a new query
        // with this filter.
        String newFilter = !TextUtils.isEmpty(newText) ? newText : null;
        // Don't do anything if the filter hasn't actually changed.
        // Prevents restarting the loader when restoring state.
        if (mCurFilter == null && newFilter == null) {
            return true;
        }
        if (mCurFilter != null && mCurFilter.equals(newFilter)) {
            return true;
        }
        mCurFilter = newFilter;
        getLoaderManager().restartLoader(0 null this);
        return true;
    }

    @Override public boolean onQueryTextSubmit(String query) {
        // Don't care about this.
        return true;
    }

    @Override
    public boolean onClose() {
        if (!TextUtils.isEmpty(mSearchView.getQuery())) {
            mSearchView.setQuery(null true);
        }
        return true;
    }

    @Override public void onListItemClick(ListView l View v int position long id) {
        // Insert desired behavior here.
        Log.i(""FragmentComplexList"" ""Item clicked: "" + id);
    }

    // These are the Contacts rows that we will retrieve.
    static final String[] CONTACTS_SUMMARY_PROJECTION = new String[] {
        Contacts._ID
        Contacts.DISPLAY_NAME
        Contacts.CONTACT_STATUS
        Contacts.CONTACT_PRESENCE
        Contacts.PHOTO_ID
        Contacts.LOOKUP_KEY
    };

    public Loader<Cursor> onCreateLoader(int id Bundle args) {
        // This is called when a new Loader needs to be created.  This
        // sample only has one Loader so we don't care about the ID.
        // First pick the base URI to use depending on whether we are
        // currently filtering.
        Uri baseUri;
        if (mCurFilter != null) {
            baseUri = Uri.withAppendedPath(Contacts.CONTENT_FILTER_URI
                    Uri.encode(mCurFilter));
        } else {
            baseUri = Contacts.CONTENT_URI;
        }

        // Now create and return a CursorLoader that will take care of
        // creating a Cursor for the data being displayed.
        String select = ""(("" + Contacts.DISPLAY_NAME + "" NOTNULL) AND (""
                + Contacts.HAS_PHONE_NUMBER + ""=1) AND (""
                + Contacts.DISPLAY_NAME + "" != '' ))"";
        return new CursorLoader(getActivity() baseUri
                CONTACTS_SUMMARY_PROJECTION select null
                Contacts.DISPLAY_NAME + "" COLLATE LOCALIZED ASC"");
    }

    public void onLoadFinished(Loader<Cursor> loader Cursor data) {
        // Swap the new cursor in.  (The framework will take care of closing the
        // old cursor once we return.)
        mAdapter.swapCursor(data);

        // The list should now be shown.
        if (isResumed()) {
            setListShown(true);
        } else {
            setListShownNoAnimation(true);
        }
    }

    public void onLoaderReset(Loader<Cursor> loader) {
        // This is called when the last Cursor provided to onLoadFinished()
        // above is about to be closed.  We need to make sure we are no
        // longer using it.
        mAdapter.swapCursor(null);
    }
}"
android,app,MediaRouteActionProvider,7,"The media route action provider displays a  MediaRouteButton 
 in the application's  ActionBar  to allow the user to select routes and
 to control the currently selected route.
  
 The application must specify the kinds of routes that the user should be allowed
 to select by specifying the route types with the  setRouteTypes(int)  method.
  
 Refer to  MediaRouteButton  for a description of the button that will
 appear in the action bar menu.  Note that instead of disabling the button
 when no routes are available the action provider will instead make the
 menu item invisible.  In this way the button will only be visible when it
 is possible for the user to discover and select a matching route."
android,app,NativeActivity,17,"Convenience for implementing an activity that will be implemented
 purely in native code.  That is a game (or game-like thing).  There
 is no need to derive from this class; you can simply declare it in your
 manifest and use the NDK APIs from there.

  A  sample
 native activity  is available in the NDK samples."
android,app,Notification.Action,10,"Structure to encapsulate a named action that can be shown as part of this notification.
 It must include an icon a label and a  PendingIntent  to be fired when the action is
 selected by the user.
  
 Apps should use  Notification.Builder#addAction(int CharSequence PendingIntent) 
 or  Notification.Builder#addAction(Notification.Action) 
 to attach actions."
android,app,Notification.Action.Builder,8,Builder class for  Action  objects.
android,app,Notification.Action.WearableExtender,14,"Wearable extender for notification actions. To add extensions to an action
 create a new  Notification.Action.WearableExtender  object using
 the  WearableExtender()  constructor and apply it to a
  Notification.Action.Builder  using
  Notification.Action.Builder.extend(Notification.Action.Extender) .

  
 Notification.Action action = new Notification.Action.Builder(
         R.drawable.archive_all ""Archive all"" actionIntent)
         .extend(new Notification.Action.WearableExtender()
                 .setAvailableOffline(false))
         .build();"
android,app,Notification.BigPictureStyle,5,"Helper class for generating large-format notifications that include a large image attachment.

 Here's how you'd set the  BigPictureStyle  on a notification:
  
 Notification notif = new Notification.Builder(mContext)
     .setContentTitle(""New photo from "" + sender.toString())
     .setContentText(subject)
     .setSmallIcon(R.drawable.new_post)
     .setLargeIcon(aBitmap)
     .setStyle(new Notification.BigPictureStyle()
         .bigPicture(aBigBitmap))
     .build();"
android,app,Notification.BubbleMetadata,9,"Encapsulates the information needed to display a notification as a bubble.

  A bubble is used to display app content in a floating window over the existing
 foreground activity. A bubble has a collapsed state represented by an icon
  Notification.BubbleMetadata.Builder.setIcon(Icon)  and an expanded state which is populated
 via  Notification.BubbleMetadata.Builder.setIntent(PendingIntent) . Notifications with a valid and allowed bubble will display in collapsed state
 outside of the notification shade on unlocked devices. When a user interacts with the
 collapsed bubble the bubble intent will be invoked and displayed."
android,app,Notification.Builder,70,"Builder class for  Notification  objects.

 Provides a convenient way to set the various fields of a  Notification  and generate
 content views using the platform's notification layout template. If your app supports
 versions of Android as old as API level 4 you can instead use
  NotificationCompat.Builder 
 available in the  Android Support
 library .

  Example:

  
 Notification noti = new Notification.Builder(mContext)
         .setContentTitle(""New mail from "" + sender.toString())
         .setContentText(subject)
         .setSmallIcon(R.drawable.new_mail)
         .setLargeIcon(aBitmap)
         .build();"
android,app,Notification.CarExtender,7,"Helper class to add Android Auto extensions to notifications. To create a notification
 with car extensions:

  Create an  Notification.Builder  setting any desired
  properties.
   Create a  CarExtender .
   Set car-specific properties using the  add  and  set  methods of
   CarExtender .
   Call  Notification.Builder#extend(Notification.Extender) 
  to apply the extensions to a notification.
  
 Notification notification = new Notification.Builder(context)
         ...
         .extend(new CarExtender()
                 .set*(...))
         .build();
  Car extensions can be accessed on an existing notification by using the
  CarExtender(Notification)  constructor and then using the  get  methods
 to access values."
android,app,Notification.CarExtender.Builder,5,Builder class for  CarExtender.UnreadConversation  objects.
android,app,Notification.CarExtender.UnreadConversation,7,A class which holds the unread messages from a conversation.
android,app,Notification.DecoratedMediaCustomViewStyle,0,"Notification style for media custom views that are decorated by the system

  Instead of providing a media notification that is completely custom a developer can set
 this style and still obtain system decorations like the notification header with the expand
 affordance and actions.

  Use  Notification.Builder.setCustomContentView(RemoteViews) 
  Notification.Builder.setCustomBigContentView(RemoteViews)  and
  Notification.Builder.setCustomHeadsUpContentView(RemoteViews)  to set the
 corresponding custom views to display.
  
 Contrary to  MediaStyle  a developer has to opt-in to the colorizing of the
 notification by using  Notification.Builder#setColorized(boolean) .
  
 To use this style with your Notification feed it to
  Notification.Builder#setStyle(android.app.Notification.Style)  like so:
  
 Notification noti = new Notification.Builder()
     .setSmallIcon(R.drawable.ic_stat_player)
     .setLargeIcon(albumArtBitmap))
     .setCustomContentView(contentView);
     .setStyle( new Notification.DecoratedMediaCustomViewStyle() 
          .setMediaSession(mySession))
     .build();"
android,app,Notification.MediaStyle,2,"Notification style for media playback notifications.

 In the expanded form  Notification#bigContentView  up to 5
  Notification.Action s specified with
  Notification.Builder#addAction(Action)  will be
 shown as icon-only pushbuttons suitable for transport controls. The Bitmap given to
  Notification.Builder#setLargeIcon(android.graphics.Bitmap)  will be
 treated as album artwork.
  
 Unlike the other styles provided here MediaStyle can also modify the standard-size
  Notification#contentView ; by providing action indices to
  setShowActionsInCompactView(int)  you can promote up to 3 actions to be displayed
 in the standard view alongside the usual content.
  
 Notifications created with MediaStyle will have their category set to
  Notification#CATEGORY_TRANSPORT  unless you set a different
 category using  Notification.Builder#setCategory(String) .
  
 Finally if you attach a  MediaSession.Token  using
  setMediaSession(MediaSession.Token) 
 the System UI can identify this as a notification representing an active media session
 and respond accordingly (by showing album artwork in the lockscreen for example).

  
 Starting at  Android O  any notification that has a
 media session attached with  setMediaSession(android.media.session.MediaSession.Token)  will be colorized.
 You can opt-out of this behavior by using  Notification.Builder#setColorized(boolean) .
  

 To use this style with your Notification feed it to
  Notification.Builder#setStyle(android.app.Notification.Style)  like so:
  
 Notification noti = new Notification.Builder()
     .setSmallIcon(R.drawable.ic_stat_player)
     .setContentTitle(""Track title"")
     .setContentText(""Artist - Album"")
     .setLargeIcon(albumArtBitmap))
     .setStyle( new Notification.MediaStyle() 
         .setMediaSession(mySession))
     .build();"
android,app,Notification.MessagingStyle,12,"Helper class for generating large-format notifications that include multiple back-and-forth
 messages of varying types between any number of people.

  
 If the platform does not provide large-format notifications this method has no effect. The
 user will always see the normal notification view.

  
 If the app is targeting Android P and above it is required to use the  Person 
 class in order to get an optimal rendering of the notification and its avatars. For
 conversations involving multiple people the app should also make sure that it marks the
 conversation as a group with  setGroupConversation(boolean) .

  
 This class is a ""rebuilder"": It attaches to a Builder object and modifies its behavior.
 Here's an example of how this may be used:
  

 Person user = new Person.Builder().setIcon(userIcon).setName(userName).build();
 MessagingStyle style = new MessagingStyle(user)
      .addMessage(messages[1].getText() messages[1].getTime() messages[1].getPerson())
      .addMessage(messages[2].getText() messages[2].getTime() messages[2].getPerson())
      .setGroupConversation(hasMultiplePeople());

 Notification noti = new Notification.Builder()
     .setContentTitle(""2 new messages with "" + sender.toString())
     .setContentText(subject)
     .setSmallIcon(R.drawable.new_message)
     .setLargeIcon(aBitmap)
     .setStyle(style)
     .build();"
android,app,Notification.Style,6,"An object that can apply a rich notification style to a  Notification.Builder 
 object."
android,app,NotificationChannel,34,A representation of settings that apply to a collection of similarly themed notifications.
android,app,NotificationChannelGroup,12,A grouping of related notification channels. e.g. channels that all belong to a single account.
android,app,NotificationManager.Policy,8,"Notification policy configuration.  Represents user-preferences for notification
 filtering."
android,app,PendingIntent,27,"A description of an Intent and target action to perform with it.  Instances
 of this class are created with  getActivity(Context int Intent int)   getActivities(Context int Intent[] int) 
  getBroadcast(Context int Intent int)  and  getService(Context int Intent int) ; the returned object can be
 handed to other applications so that they can perform the action you
 described on your behalf at a later time.

  By giving a PendingIntent to another application
 you are granting it the right to perform the operation you have specified
 as if the other application was yourself (with the same permissions and
 identity).  As such you should be careful about how you build the PendingIntent:
 almost always for example the base Intent you supply should have the component
 name explicitly set to one of your own components to ensure it is ultimately
 sent there and nowhere else.

  A PendingIntent itself is simply a reference to a token maintained by
 the system describing the original data used to retrieve it.  This means
 that even if its owning application's process is killed the
 PendingIntent itself will remain usable from other processes that
 have been given it.  If the creating application later re-retrieves the
 same kind of PendingIntent (same operation same Intent action data
 categories and components and same flags) it will receive a PendingIntent
 representing the same token if that is still valid and can thus call
  cancel()  to remove it.

  Because of this behavior it is important to know when two Intents
 are considered to be the same for purposes of retrieving a PendingIntent.
 A common mistake people make is to create multiple PendingIntent objects
 with Intents that only vary in their ""extra"" contents expecting to get
 a different PendingIntent each time.  This does  not  happen.  The
 parts of the Intent that are used for matching are the same ones defined
 by  Intent#filterEquals(Intent) .  If you use two
 Intent objects that are equivalent as per
  Intent#filterEquals(Intent)  then you will get
 the same PendingIntent for both of them.

  There are two typical ways to deal with this.

  If you truly need multiple distinct PendingIntent objects active at
 the same time (such as to use as two notifications that are both shown
 at the same time) then you will need to ensure there is something that
 is different about them to associate them with different PendingIntents.
 This may be any of the Intent attributes considered by
  Intent#filterEquals(Intent)  or different
 request code integers supplied to  getActivity(Context int Intent int)   getActivities(Context int Intent[] int) 
  getBroadcast(Context int Intent int)  or  getService(Context int Intent int) .

  If you only need one PendingIntent active at a time for any of the
 Intents you will use then you can alternatively use the flags
  FLAG_CANCEL_CURRENT  or  FLAG_UPDATE_CURRENT  to either
 cancel or modify whatever current PendingIntent is associated with the
 Intent you are supplying."
android,app,Person,11,"Provides an immutable reference to an entity that appears repeatedly on different surfaces of the
 platform. For example this could represent the sender of a message."
android,app,PictureInPictureParams,2,"Represents a set of parameters used to initialize and update an Activity in picture-in-picture
 mode."
android,app,Presentation,7,"Base class for presentations.
  
 A presentation is a special kind of dialog whose purpose is to present
 content on a secondary display.  A  Presentation  is associated with
 the target  Display  at creation time and configures its context and
 resource configuration according to the display's metrics.
  
 Notably the  Context  of a presentation is different from the context
 of its containing  Activity .  It is important to inflate the layout
 of a presentation and load other resources using the presentation's own context
 to ensure that assets of the correct size and density for the target display
 are loaded.
  
 A presentation is automatically canceled (see  Dialog#cancel() ) when
 the display to which it is attached is removed.  An activity should take
 care of pausing and resuming whatever content is playing within the presentation
 whenever the activity itself is paused or resumed.
  Choosing a presentation display 
 Before showing a  Presentation  it's important to choose the  Display 
 on which it will appear.  Choosing a presentation display is sometimes difficult
 because there may be multiple displays attached.  Rather than trying to guess
 which display is best an application should let the system choose a suitable
 presentation display.
  
 There are two main ways to choose a  Display .
  Using the media router to choose a presentation display 
 The easiest way to choose a presentation display is to use the
  MediaRouter  API.  The media router service keeps
 track of which audio and video routes are available on the system.
 The media router sends notifications whenever routes are selected or unselected
 or when the preferred presentation display of a route changes.
 So an application can simply watch for these notifications and show or dismiss
 a presentation on the preferred presentation display automatically.
  
 The preferred presentation display is the display that the media router recommends
 that the application should use if it wants to show content on the secondary display.
 Sometimes there may not be a preferred presentation display in which
 case the application should show its content locally without using a presentation.
  
 Here's how to use the media router to create and show a presentation on the preferred
 presentation display using  MediaRouter.RouteInfo.getPresentationDisplay() .
  
 MediaRouter mediaRouter = (MediaRouter) context.getSystemService(Context.MEDIA_ROUTER_SERVICE);
 MediaRouter.RouteInfo route = mediaRouter.getSelectedRoute();
 if (route != null) {
     Display presentationDisplay = route.getPresentationDisplay();
     if (presentationDisplay != null) {
         Presentation presentation = new MyPresentation(context presentationDisplay);
         presentation.show();
     }
 } 
 The following sample code from  ApiDemos  demonstrates how to use the media
 router to automatically switch between showing content in the main activity and showing
 the content in a presentation when a presentation display is available.
  /**
 * <h3>Presentation Activity</h3>
 *
 * <p>
 * This demonstrates how to create an activity that shows some content
 * on a secondary display using a {@link Presentation}.
 * </p><p>
 * The activity uses the {@link MediaRouter} API to automatically detect when
 * a presentation display is available and to allow the user to control the
 * media routes using a menu item.  When a presentation display is available
 * we stop showing content in the main activity and instead open up a
 * {@link Presentation} on the preferred presentation display.  When a presentation
 * display is removed we revert to showing content in the main activity.
 * We also write information about displays and display-related events to
 * the Android log which you can read using <code>adb logcat</code>.
 * </p><p>
 * You can try this out using an HDMI or Wifi display or by using the
 * ""Simulate secondary displays"" feature in Development Settings to create a few
 * simulated secondary displays.  Each display will appear in the list along with a
 * checkbox to show a presentation on that display.
 * </p><p>
 * See also the {@link PresentationActivity} sample which
 * uses the low-level display manager to enumerate displays and to show multiple
 * simultaneous presentations on different displays.
 * </p>
 */
public class PresentationWithMediaRouterActivity extends Activity {
    private final String TAG = ""PresentationWithMediaRouterActivity"";

    private MediaRouter mMediaRouter;
    private DemoPresentation mPresentation;
    private GLSurfaceView mSurfaceView;
    private TextView mInfoTextView;
    private boolean mPaused;

    /**
     * Initialization of the Activity after it is first created.  Must at least
     * call {@link android.app.Activity#setContentView setContentView()} to
     * describe what is to be displayed in the screen.
     */
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        // Be sure to call the super class.
        super.onCreate(savedInstanceState);

        // Get the media router service.
        mMediaRouter = (MediaRouter)getSystemService(Context.MEDIA_ROUTER_SERVICE);

        // See assets/res/any/layout/presentation_with_media_router_activity.xml for this
        // view layout definition which is being set here as
        // the content of our screen.
        setContentView(R.layout.presentation_with_media_router_activity);

        // Set up the surface view for visual interest.
        mSurfaceView = (GLSurfaceView)findViewById(R.id.surface_view);
        mSurfaceView.setRenderer(new CubeRenderer(false));

        // Get a text view where we will show information about what's happening.
        mInfoTextView = (TextView)findViewById(R.id.info);
    }

    @Override
    protected void onResume() {
        // Be sure to call the super class.
        super.onResume();

        // Listen for changes to media routes.
        mMediaRouter.addCallback(MediaRouter.ROUTE_TYPE_LIVE_VIDEO mMediaRouterCallback);

        // Update the presentation based on the currently selected route.
        mPaused = false;
        updatePresentation();
    }

    @Override
    protected void onPause() {
        // Be sure to call the super class.
        super.onPause();

        // Stop listening for changes to media routes.
        mMediaRouter.removeCallback(mMediaRouterCallback);

        // Pause rendering.
        mPaused = true;
        updateContents();
    }

    @Override
    protected void onStop() {
        // Be sure to call the super class.
        super.onStop();

        // Dismiss the presentation when the activity is not visible.
        if (mPresentation != null) {
            Log.i(TAG ""Dismissing presentation because the activity is no longer visible."");
            mPresentation.dismiss();
            mPresentation = null;
        }
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        // Be sure to call the super class.
        super.onCreateOptionsMenu(menu);

        // Inflate the menu and configure the media router action provider.
        getMenuInflater().inflate(R.menu.presentation_with_media_router_menu menu);

        MenuItem mediaRouteMenuItem = menu.findItem(R.id.menu_media_route);
        MediaRouteActionProvider mediaRouteActionProvider =
                (MediaRouteActionProvider)mediaRouteMenuItem.getActionProvider();
        mediaRouteActionProvider.setRouteTypes(MediaRouter.ROUTE_TYPE_LIVE_VIDEO);

        // Return true to show the menu.
        return true;
    }

    private void updatePresentation() {
        // Get the current route and its presentation display.
        MediaRouter.RouteInfo route = mMediaRouter.getSelectedRoute(
                MediaRouter.ROUTE_TYPE_LIVE_VIDEO);
        Display presentationDisplay = route != null ? route.getPresentationDisplay() : null;

        // Dismiss the current presentation if the display has changed.
        if (mPresentation != null && mPresentation.getDisplay() != presentationDisplay) {
            Log.i(TAG ""Dismissing presentation because the current route no longer ""
                    + ""has a presentation display."");
            mPresentation.dismiss();
            mPresentation = null;
        }

        // Show a new presentation if needed.
        if (mPresentation == null && presentationDisplay != null) {
            Log.i(TAG ""Showing presentation on display: "" + presentationDisplay);
            mPresentation = new DemoPresentation(this presentationDisplay);
            mPresentation.setOnDismissListener(mOnDismissListener);
            try {
                mPresentation.show();
            } catch (WindowManager.InvalidDisplayException ex) {
                Log.w(TAG ""Couldn't show presentation!  Display was removed in ""
                        + ""the meantime."" ex);
                mPresentation = null;
            }
        }

        // Update the contents playing in this activity.
        updateContents();
    }

    private void updateContents() {
        // Show either the content in the main activity or the content in the presentation
        // along with some descriptive text about what is happening.
        if (mPresentation != null) {
            mInfoTextView.setText(getResources().getString(
                    R.string.presentation_with_media_router_now_playing_remotely
                    mPresentation.getDisplay().getName()));
            mSurfaceView.setVisibility(View.INVISIBLE);
            mSurfaceView.onPause();
            if (mPaused) {
                mPresentation.getSurfaceView().onPause();
            } else {
                mPresentation.getSurfaceView().onResume();
            }
        } else {
            mInfoTextView.setText(getResources().getString(
                    R.string.presentation_with_media_router_now_playing_locally
                    getWindowManager().getDefaultDisplay().getName()));
            mSurfaceView.setVisibility(View.VISIBLE);
            if (mPaused) {
                mSurfaceView.onPause();
            } else {
                mSurfaceView.onResume();
            }
        }
    }

    private final MediaRouter.SimpleCallback mMediaRouterCallback =
            new MediaRouter.SimpleCallback() {
        @Override
        public void onRouteSelected(MediaRouter router int type RouteInfo info) {
            Log.d(TAG ""onRouteSelected: type="" + type + "" info="" + info);
            updatePresentation();
        }

        @Override
        public void onRouteUnselected(MediaRouter router int type RouteInfo info) {
            Log.d(TAG ""onRouteUnselected: type="" + type + "" info="" + info);
            updatePresentation();
        }

        @Override
        public void onRoutePresentationDisplayChanged(MediaRouter router RouteInfo info) {
            Log.d(TAG ""onRoutePresentationDisplayChanged: info="" + info);
            updatePresentation();
        }
    };

    /**
     * Listens for when presentations are dismissed.
     */
    private final DialogInterface.OnDismissListener mOnDismissListener =
            new DialogInterface.OnDismissListener() {
        @Override
        public void onDismiss(DialogInterface dialog) {
            if (dialog == mPresentation) {
                Log.i(TAG ""Presentation was dismissed."");
                mPresentation = null;
                updateContents();
            }
        }
    };

    /**
     * The presentation to show on the secondary display.
     * <p>
     * Note that this display may have different metrics from the display on which
     * the main activity is showing so we must be careful to use the presentation's
     * own {@link Context} whenever we load resources.
     * </p>
     */
    private final static class DemoPresentation extends Presentation {
        private GLSurfaceView mSurfaceView;

        public DemoPresentation(Context context Display display) {
            super(context display);
        }

        @Override
        protected void onCreate(Bundle savedInstanceState) {
            // Be sure to call the super class.
            super.onCreate(savedInstanceState);

            // Get the resources for the context of the presentation.
            // Notice that we are getting the resources from the context of the presentation.
            Resources r = getContext().getResources();

            // Inflate the layout.
            setContentView(R.layout.presentation_with_media_router_content);

            // Set up the surface view for visual interest.
            mSurfaceView = (GLSurfaceView)findViewById(R.id.surface_view);
            mSurfaceView.setRenderer(new CubeRenderer(false));
        }

        public GLSurfaceView getSurfaceView() {
            return mSurfaceView;
        }
    }
} Using the display manager to choose a presentation display 
 Another way to choose a presentation display is to use the  DisplayManager  API
 directly.  The display manager service provides functions to enumerate and describe all
 displays that are attached to the system including displays that may be used
 for presentations.
  
 The display manager keeps track of all displays in the system.  However not all
 displays are appropriate for showing presentations.  For example if an activity
 attempted to show a presentation on the main display it might obscure its own content
 (it's like opening a dialog on top of your activity).
  
 Here's how to identify suitable displays for showing presentations using
  DisplayManager#getDisplays(String)  and the
  DisplayManager#DISPLAY_CATEGORY_PRESENTATION  category.
  
 DisplayManager displayManager = (DisplayManager) context.getSystemService(Context.DISPLAY_SERVICE);
 Display[] presentationDisplays = displayManager.getDisplays(DisplayManager.DISPLAY_CATEGORY_PRESENTATION);
 if (presentationDisplays.length > 0) {
     // If there is more than one suitable presentation display then we could consider
     // giving the user a choice.  For this example we simply choose the first display
     // which is the one the system recommends as the preferred presentation display.
     Display display = presentationDisplays[0];
     Presentation presentation = new MyPresentation(context presentationDisplay);
     presentation.show();
 } 
 The following sample code from  ApiDemos  demonstrates how to use the display
 manager to enumerate displays and show content on multiple presentation displays
 simultaneously.
  /**
 * <h3>Presentation Activity</h3>
 *
 * <p>
 * This demonstrates how to create an activity that shows some content
 * on a secondary display using a {@link Presentation}.
 * </p><p>
 * The activity uses the {@link DisplayManager} API to enumerate displays.
 * When the user selects a display the activity opens a {@link Presentation}
 * on that display.  We show a different photograph in each presentation
 * on a unique background along with a label describing the display.
 * We also write information about displays and display-related events to
 * the Android log which you can read using <code>adb logcat</code>.
 * </p><p>
 * You can try this out using an HDMI or Wifi display or by using the
 * ""Simulate secondary displays"" feature in Development Settings to create a few
 * simulated secondary displays.  Each display will appear in the list along with a
 * checkbox to show a presentation on that display.
 * </p><p>
 * See also the {@link PresentationWithMediaRouterActivity} sample which
 * uses the media router to automatically select a secondary display
 * on which to show content based on the currently selected route.
 * </p>
 */
public class PresentationActivity extends Activity
        implements OnCheckedChangeListener OnClickListener OnItemSelectedListener {
    private final String TAG = ""PresentationActivity"";

    // Key for storing saved instance state.
    private static final String PRESENTATION_KEY = ""presentation"";

    // The content that we want to show on the presentation.
    private static final int[] PHOTOS = new int[] {
        R.drawable.frantic
        R.drawable.photo1 R.drawable.photo2 R.drawable.photo3
        R.drawable.photo4 R.drawable.photo5 R.drawable.photo6
        R.drawable.sample_4
    };

    private DisplayManager mDisplayManager;
    private DisplayListAdapter mDisplayListAdapter;
    private CheckBox mShowAllDisplaysCheckbox;
    private ListView mListView;
    private int mNextImageNumber;

    // List of presentation contents indexed by displayId.
    // This state persists so that we can restore the old presentation
    // contents when the activity is paused or resumed.
    private SparseArray<DemoPresentationContents> mSavedPresentationContents;

    // List of all currently visible presentations indexed by display id.
    private final SparseArray<DemoPresentation> mActivePresentations =
            new SparseArray<DemoPresentation>();

    /**
     * Initialization of the Activity after it is first created.  Must at least
     * call {@link android.app.Activity#setContentView setContentView()} to
     * describe what is to be displayed in the screen.
     */
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        // Be sure to call the super class.
        super.onCreate(savedInstanceState);

        // Restore saved instance state.
        if (savedInstanceState != null) {
            mSavedPresentationContents =
                    savedInstanceState.getSparseParcelableArray(PRESENTATION_KEY);
        } else {
            mSavedPresentationContents = new SparseArray<DemoPresentationContents>();
        }

        // Get the display manager service.
        mDisplayManager = (DisplayManager)getSystemService(Context.DISPLAY_SERVICE);

        // See assets/res/any/layout/presentation_activity.xml for this
        // view layout definition which is being set here as
        // the content of our screen.
        setContentView(R.layout.presentation_activity);

        // Set up checkbox to toggle between showing all displays or only presentation displays.
        mShowAllDisplaysCheckbox = (CheckBox)findViewById(R.id.show_all_displays);
        mShowAllDisplaysCheckbox.setOnCheckedChangeListener(this);

        // Set up the list of displays.
        mDisplayListAdapter = new DisplayListAdapter(this);
        mListView = (ListView)findViewById(R.id.display_list);
        mListView.setAdapter(mDisplayListAdapter);
    }

    @Override
    protected void onResume() {
        // Be sure to call the super class.
        super.onResume();

        // Update our list of displays on resume.
        mDisplayListAdapter.updateContents();

        // Restore presentations from before the activity was paused.
        final int numDisplays = mDisplayListAdapter.getCount();
        for (int i = 0; i < numDisplays; i++) {
            final Display display = mDisplayListAdapter.getItem(i);
            final DemoPresentationContents contents =
                    mSavedPresentationContents.get(display.getDisplayId());
            if (contents != null) {
                showPresentation(display contents);
            }
        }
        mSavedPresentationContents.clear();

        // Register to receive events from the display manager.
        mDisplayManager.registerDisplayListener(mDisplayListener null);
    }

    @Override
    protected void onPause() {
        // Be sure to call the super class.
        super.onPause();

        // Unregister from the display manager.
        mDisplayManager.unregisterDisplayListener(mDisplayListener);

        // Dismiss all of our presentations but remember their contents.
        Log.d(TAG ""Activity is being paused.  Dismissing all active presentation."");
        for (int i = 0; i < mActivePresentations.size(); i++) {
            DemoPresentation presentation = mActivePresentations.valueAt(i);
            int displayId = mActivePresentations.keyAt(i);
            mSavedPresentationContents.put(displayId presentation.mContents);
            presentation.dismiss();
        }
        mActivePresentations.clear();
    }

    @Override
    protected void onSaveInstanceState(Bundle outState) {
        // Be sure to call the super class.
        super.onSaveInstanceState(outState);
        outState.putSparseParcelableArray(PRESENTATION_KEY mSavedPresentationContents);
    }

    /**
     * Shows a {@link Presentation} on the specified display.
     */
    private void showPresentation(Display display DemoPresentationContents contents) {
        final int displayId = display.getDisplayId();
        if (mActivePresentations.get(displayId) != null) {
            return;
        }

        Log.d(TAG ""Showing presentation photo #"" + contents.photo
                + "" on display #"" + displayId + ""."");

        DemoPresentation presentation = new DemoPresentation(this display contents);
        presentation.show();
        presentation.setOnDismissListener(mOnDismissListener);
        mActivePresentations.put(displayId presentation);
    }

    /**
     * Hides a {@link Presentation} on the specified display.
     */
    private void hidePresentation(Display display) {
        final int displayId = display.getDisplayId();
        DemoPresentation presentation = mActivePresentations.get(displayId);
        if (presentation == null) {
            return;
        }

        Log.d(TAG ""Dismissing presentation on display #"" + displayId + ""."");

        presentation.dismiss();
        mActivePresentations.delete(displayId);
    }

    /**
     * Sets the display mode of the {@link Presentation} on the specified display
     * if it is already shown.
     */
    private void setPresentationDisplayMode(Display display int displayModeId) {
        final int displayId = display.getDisplayId();
        DemoPresentation presentation = mActivePresentations.get(displayId);
        if (presentation == null) {
            return;
        }

        presentation.setPreferredDisplayMode(displayModeId);
    }

    private int getNextPhoto() {
        final int photo = mNextImageNumber;
        mNextImageNumber = (mNextImageNumber + 1) % PHOTOS.length;
        return photo;
    }

    /**
     * Called when the show all displays checkbox is toggled or when
     * an item in the list of displays is checked or unchecked.
     */
    @Override
    public void onCheckedChanged(CompoundButton buttonView boolean isChecked) {
        if (buttonView == mShowAllDisplaysCheckbox) {
            // Show all displays checkbox was toggled.
            mDisplayListAdapter.updateContents();
        } else {
            // Display item checkbox was toggled.
            final Display display = (Display)buttonView.getTag();
            if (isChecked) {
                DemoPresentationContents contents = new DemoPresentationContents(getNextPhoto());
                showPresentation(display contents);
            } else {
                hidePresentation(display);
            }
            mDisplayListAdapter.updateContents();
        }
    }

    /**
     * Called when the Info button next to a display is clicked to show information
     * about the display.
     */
    @Override
    public void onClick(View v) {
        Context context = v.getContext();
        AlertDialog.Builder builder = new AlertDialog.Builder(context);
        final Display display = (Display)v.getTag();
        Resources r = context.getResources();
        AlertDialog alert = builder
                .setTitle(r.getString(
                        R.string.presentation_alert_info_text display.getDisplayId()))
                .setMessage(display.toString())
                .setNeutralButton(R.string.presentation_alert_dismiss_text
                        new DialogInterface.OnClickListener() {
                            @Override
                            public void onClick(DialogInterface dialog int which) {
                                dialog.dismiss();
                            }
                    })
                .create();
        alert.show();
    }

    /**
     * Called when a display mode has been selected.
     */
    @Override
    public void onItemSelected(AdapterView<?> parent View view int position long id) {
        final Display display = (Display)parent.getTag();
        final Display.Mode[] modes = display.getSupportedModes();
        setPresentationDisplayMode(display position >= 1 && position <= modes.length ?
                modes[position - 1].getModeId() : 0);
    }

    /**
     * Called when a display mode has been unselected.
     */
    @Override
    public void onNothingSelected(AdapterView<?> parent) {
        final Display display = (Display)parent.getTag();
        setPresentationDisplayMode(display 0);
    }

    /**
     * Listens for displays to be added changed or removed.
     * We use it to update the list and show a new {@link Presentation} when a
     * display is connected.
     *
     * Note that we don't bother dismissing the {@link Presentation} when a
     * display is removed although we could.  The presentation API takes care
     * of doing that automatically for us.
     */
    private final DisplayManager.DisplayListener mDisplayListener =
            new DisplayManager.DisplayListener() {
        @Override
        public void onDisplayAdded(int displayId) {
            Log.d(TAG ""Display #"" + displayId + "" added."");
            mDisplayListAdapter.updateContents();
        }

        @Override
        public void onDisplayChanged(int displayId) {
            Log.d(TAG ""Display #"" + displayId + "" changed."");
            mDisplayListAdapter.updateContents();
        }

        @Override
        public void onDisplayRemoved(int displayId) {
            Log.d(TAG ""Display #"" + displayId + "" removed."");
            mDisplayListAdapter.updateContents();
        }
    };

    /**
     * Listens for when presentations are dismissed.
     */
    private final DialogInterface.OnDismissListener mOnDismissListener =
            new DialogInterface.OnDismissListener() {
        @Override
        public void onDismiss(DialogInterface dialog) {
            DemoPresentation presentation = (DemoPresentation)dialog;
            int displayId = presentation.getDisplay().getDisplayId();
            Log.d(TAG ""Presentation on display #"" + displayId + "" was dismissed."");
            mActivePresentations.delete(displayId);
            mDisplayListAdapter.notifyDataSetChanged();
        }
    };

    /**
     * List adapter.
     * Shows information about all displays.
     */
    private final class DisplayListAdapter extends ArrayAdapter<Display> {
        final Context mContext;

        public DisplayListAdapter(Context context) {
            super(context R.layout.presentation_list_item);
            mContext = context;
        }

        @Override
        public View getView(int position View convertView ViewGroup parent) {
            final View v;
            if (convertView == null) {
                v = ((Activity) mContext).getLayoutInflater().inflate(
                        R.layout.presentation_list_item null);
            } else {
                v = convertView;
            }

            final Display display = getItem(position);
            final int displayId = display.getDisplayId();

            DemoPresentation presentation = mActivePresentations.get(displayId);
            DemoPresentationContents contents = presentation != null ?
                    presentation.mContents : null;
            if (contents == null) {
                contents = mSavedPresentationContents.get(displayId);
            }

            CheckBox cb = (CheckBox)v.findViewById(R.id.checkbox_presentation);
            cb.setTag(display);
            cb.setOnCheckedChangeListener(PresentationActivity.this);
            cb.setChecked(contents != null);

            TextView tv = (TextView)v.findViewById(R.id.display_id);
            tv.setText(v.getContext().getResources().getString(
                    R.string.presentation_display_id_text displayId display.getName()));

            Button b = (Button)v.findViewById(R.id.info);
            b.setTag(display);
            b.setOnClickListener(PresentationActivity.this);

            Spinner s = (Spinner)v.findViewById(R.id.modes);
            Display.Mode[] modes = display.getSupportedModes();
            if (contents == null || modes.length == 1) {
                s.setVisibility(View.GONE);
                s.setAdapter(null);
            } else {
                ArrayAdapter<String> modeAdapter = new ArrayAdapter<String>(mContext
                        android.R.layout.simple_list_item_1);
                s.setVisibility(View.VISIBLE);
                s.setAdapter(modeAdapter);
                s.setTag(display);
                s.setOnItemSelectedListener(PresentationActivity.this);

                modeAdapter.add(""<default mode>"");

                for (Display.Mode mode : modes) {
                    modeAdapter.add(String.format(""Mode %d: %dx%d/%.1ffps""
                            mode.getModeId()
                            mode.getPhysicalWidth() mode.getPhysicalHeight()
                            mode.getRefreshRate()));
                    if (contents.displayModeId == mode.getModeId()) {
                        s.setSelection(modeAdapter.getCount() - 1);
                    }
                }
            }

            return v;
        }

        /**
         * Update the contents of the display list adapter to show
         * information about all current displays.
         */
        public void updateContents() {
            clear();

            String displayCategory = getDisplayCategory();
            Display[] displays = mDisplayManager.getDisplays(displayCategory);
            addAll(displays);

            Log.d(TAG ""There are currently "" + displays.length + "" displays connected."");
            for (Display display : displays) {
                Log.d(TAG ""  "" + display);
            }
        }

        private String getDisplayCategory() {
            return mShowAllDisplaysCheckbox.isChecked() ? null :
                DisplayManager.DISPLAY_CATEGORY_PRESENTATION;
        }
    }

    /**
     * The presentation to show on the secondary display.
     *
     * Note that the presentation display may have different metrics from the display on which
     * the main activity is showing so we must be careful to use the presentation's
     * own {@link Context} whenever we load resources.
     */
    private final class DemoPresentation extends Presentation {

        final DemoPresentationContents mContents;

        public DemoPresentation(Context context Display display
                DemoPresentationContents contents) {
            super(context display);
            mContents = contents;
        }

        /**
         * Sets the preferred display mode id for the presentation.
         */
        public void setPreferredDisplayMode(int modeId) {
            mContents.displayModeId = modeId;

            WindowManager.LayoutParams params = getWindow().getAttributes();
            params.preferredDisplayModeId = modeId;
            getWindow().setAttributes(params);
        }

        @Override
        protected void onCreate(Bundle savedInstanceState) {
            // Be sure to call the super class.
            super.onCreate(savedInstanceState);

            // Get the resources for the context of the presentation.
            // Notice that we are getting the resources from the context of the presentation.
            Resources r = getContext().getResources();

            // Inflate the layout.
            setContentView(R.layout.presentation_content);

            final Display display = getDisplay();
            final int displayId = display.getDisplayId();
            final int photo = mContents.photo;

            // Show a caption to describe what's going on.
            TextView text = (TextView)findViewById(R.id.text);
            text.setText(r.getString(R.string.presentation_photo_text
                    photo displayId display.getName()));

            // Show a n image for visual interest.
            ImageView image = (ImageView)findViewById(R.id.image);
            image.setImageDrawable(r.getDrawable(PHOTOS[photo]));

            GradientDrawable drawable = new GradientDrawable();
            drawable.setShape(GradientDrawable.RECTANGLE);
            drawable.setGradientType(GradientDrawable.RADIAL_GRADIENT);

            // Set the background to a random gradient.
            Point p = new Point();
            getDisplay().getSize(p);
            drawable.setGradientRadius(Math.max(p.x p.y) / 2);
            drawable.setColors(mContents.colors);
            findViewById(android.R.id.content).setBackground(drawable);
        }
    }

    /**
     * Information about the content we want to show in the presentation.
     */
    private final static class DemoPresentationContents implements Parcelable {
        final int photo;
        final int[] colors;
        int displayModeId;

        public static final Creator<DemoPresentationContents> CREATOR =
                new Creator<DemoPresentationContents>() {
            @Override
            public DemoPresentationContents createFromParcel(Parcel in) {
                return new DemoPresentationContents(in);
            }

            @Override
            public DemoPresentationContents[] newArray(int size) {
                return new DemoPresentationContents[size];
            }
        };

        public DemoPresentationContents(int photo) {
            this.photo = photo;
            colors = new int[] {
                    ((int) (Math.random() * Integer.MAX_VALUE)) | 0xFF000000
                    ((int) (Math.random() * Integer.MAX_VALUE)) | 0xFF000000 };
        }

        private DemoPresentationContents(Parcel in) {
            photo = in.readInt();
            colors = new int[] { in.readInt() in.readInt() };
            displayModeId = in.readInt();
        }

        @Override
        public int describeContents() {
            return 0;
        }

        @Override
        public void writeToParcel(Parcel dest int flags) {
            dest.writeInt(photo);
            dest.writeInt(colors[0]);
            dest.writeInt(colors[1]);
            dest.writeInt(displayModeId);
        }
    }
}"
android,app,RemoteAction,12,"Represents a remote action that can be called from another process.  The action can have an
 associated visualization including metadata like an icon or title."
android,app,RemoteInput,16,"A  RemoteInput  object specifies input to be collected from a user to be passed along with
 an intent inside a  PendingIntent  that is sent.
 Always use  RemoteInput.Builder  to create instances of this class.
   See
  Replying
 to notifications  for more information on how to use this class.

  The following example adds a  RemoteInput  to a  Notification.Action 
 sets the result key as  quick_reply  and sets the label as  Quick reply .
 Users are prompted to input a response when they trigger the action. The results are sent along
 with the intent and can be retrieved with the result key (provided to the  Builder 
 constructor) from the Bundle returned by  getResultsFromIntent(Intent) .

  
 public static final String KEY_QUICK_REPLY_TEXT = ""quick_reply"";
 Notification.Action action = new Notification.Action.Builder(
         R.drawable.reply ""Reply"" actionIntent)
          .addRemoteInput(new RemoteInput.Builder(KEY_QUICK_REPLY_TEXT)
                 .setLabel(""Quick reply"").build() )
         .build(); When the  PendingIntent  is fired the intent inside will contain the
 input results if collected. To access these results use the  getResultsFromIntent(Intent) 
 function. The result values will present under the result key passed to the  Builder 
 constructor.

  
 public static final String KEY_QUICK_REPLY_TEXT = ""quick_reply"";
 Bundle results = RemoteInput.getResultsFromIntent(intent);
 if (results != null) {
     CharSequence quickReplyResult = results.getCharSequence(KEY_QUICK_REPLY_TEXT);
 }"
android,app,RemoteInput.Builder,8,Builder class for  RemoteInput  objects.
android,app,SearchableInfo,26,"Searchability meta-data for an activity. Only applications that search other applications
 should need to use this class.
 See  Searchable Configuration 
 for more information about declaring searchability meta-data for your application."
android,app,SearchManager,10,"This class provides access to the system search services.

  In practice you won't interact with this class directly as search
 services are provided through methods in  Activity 
 and the  ACTION_SEARCH Intent .

  Configuration#UI_MODE_TYPE_WATCH  does not support this system service."
android,app,SharedElementCallback,7,"Listener provided in
  Activity#setEnterSharedElementCallback(SharedElementCallback)  and
  Activity#setExitSharedElementCallback(SharedElementCallback)  as well as
  Fragment#setEnterSharedElementCallback(SharedElementCallback)  and
  Fragment#setExitSharedElementCallback(SharedElementCallback) 
 to monitor the Shared element transitions. The events can be used to customize Activity
 and Fragment Transition behavior."
android,app,StatusBarManager,0,Allows an app to control the status bar.
android,app,TabActivity,9,"For apps developing against  Build.VERSION_CODES.HONEYCOMB 
 or later tabs are typically presented in the UI using the new
  ActionBar#newTab()  and
 related APIs for placing tabs within their action bar area."
android,app,TaskStackBuilder,13,"Utility class for constructing synthetic back stacks for cross-task navigation
 on Android 3.0 and newer.

  In API level 11 (Android 3.0/Honeycomb) the recommended conventions for
 app navigation using the back key changed. The back key's behavior is local
 to the current task and does not capture navigation across different tasks.
 Navigating across tasks and easily reaching the previous task is accomplished
 through the ""recents"" UI accessible through the software-provided Recents key
 on the navigation or system bar. On devices with the older hardware button configuration
 the recents UI can be accessed with a long press on the Home key. When crossing from one task stack to another post-Android 3.0
 the application should synthesize a back stack/history for the new task so that
 the user may navigate out of the new task and back to the Launcher by repeated
 presses of the back key. Back key presses should not navigate across task stacks. TaskStackBuilder provides a way to obey the correct conventions
 around cross-task navigation."
android,app,TimePickerDialog,6,"A dialog that prompts the user for the time of day using a
  TimePicker .

  
 See the  Pickers 
 guide."
android,app,VoiceInteractor.AbortVoiceRequest,1,"Reports that the current interaction can not be complete with voice so the
 application will need to switch to a traditional input UI.  Applications should
 only use this when they need to completely bail out of the voice interaction
 and switch to a traditional UI.  When the response comes back the voice
 system has handled the request and is ready to switch; at that point the application
 can start a new non-voice activity.  Be sure when starting the new activity
 to use  Intent.FLAG_ACTIVITY_NEW_TASK  to keep the new activity out of the current voice
 interaction task."
android,app,VoiceInteractor.CommandRequest,1,"Execute a vendor-specific command using the trusted system VoiceInteractionService.
 This allows an Activity to request additional information from the user needed to
 complete an action (e.g. booking a table might have several possible times that the
 user could select from or an app might need the user to agree to a terms of service).
 The result of the confirmation will be returned through an asynchronous call to
 either  onCommandResult(boolean android.os.Bundle)  or
  VoiceInteractor.Request.onCancel() .

  The command is a string that describes the generic operation to be performed.
 The command will determine how the properties in extras are interpreted and the set of
 available commands is expected to grow over time.  An example might be
 ""com.google.voice.commands.REQUEST_NUMBER_BAGS"" to request the number of bags as part of
 airline check-in.  (This is not an actual working example.)"
android,app,VoiceInteractor.CompleteVoiceRequest,1,"Reports that the current interaction was successfully completed with voice so the
 application can report the final status to the user. When the response comes back the
 voice system has handled the request and is ready to switch; at that point the
 application can start a new non-voice activity or finish.  Be sure when starting the new
 activity to use  Intent.FLAG_ACTIVITY_NEW_TASK  to keep the new activity out of the current voice
 interaction task."
android,app,VoiceInteractor.PickOptionRequest,1,"Select a single option from multiple potential options with the user via the trusted system
 VoiceInteractionService. Typically the application would present this visually as
 a list view to allow selecting the option by touch.
 The result of the confirmation will be returned through an asynchronous call to
 either  onPickOptionResult(boolean VoiceInteractor.PickOptionRequest.Option[] Bundle)  or  VoiceInteractor.Request.onCancel()  - these methods should
 be overridden to define the application specific behavior."
android,app,VoiceInteractor.Prompt,6,"A set of voice prompts to use with the voice interaction system to confirm an action select
 an option or do similar operations. Multiple voice prompts may be provided for variety. A
 visual prompt must be provided which might not match the spoken version. For example the
 confirmation ""Are you sure you want to purchase this item?"" might use a visual label like
 ""Purchase item""."
android,app,VoiceInteractor.Request,8,"Base class for voice interaction requests that can be submitted to the interactor.
 Do not instantiate this directly -- instead use the appropriate subclass."
android,app,WallpaperColors,10,"Provides information about the colors of a wallpaper.
  
 Exposes the 3 most visually representative colors of a wallpaper. Can be either
  WallpaperColors#getPrimaryColor()   WallpaperColors#getSecondaryColor() 
 or  WallpaperColors#getTertiaryColor() ."
android,app,WallpaperInfo,19,This class is used to specify meta information of a wallpaper service.
android,app,ActionBar.Tab,17,"A tab in the action bar.

  Tabs manage the hiding and showing of  Fragment s."
android,app,Application,12,"Base class for maintaining global application state. You can provide your own
 implementation by creating a subclass and specifying the fully-qualified name
 of this subclass as the  ""android:name""  attribute in your
 AndroidManifest.xml's  <application>  tag. The Application
 class or your subclass of the Application class is instantiated before any
 other class when the process for your application/package is created.

  Note:  There is normally no need to subclass
 Application.  In most situations static singletons can provide the same
 functionality in a more modular way.  If your singleton needs a global
 context (for example to register broadcast receivers) include
  Context.getApplicationContext() 
 as a  Context  argument when invoking your singleton's
  getInstance()  method."
android,app,ApplicationErrorReport.AnrInfo,2,Describes an application not responding error.
android,app,ApplicationErrorReport.BatteryInfo,2,Describes a battery usage report.
android,app,AutomaticZenRule,19,Rule instance information for zen mode.
android,app,Dialog,88,"Base class for Dialogs.

  Note: Activities provide a facility to manage the creation saving and
 restoring of dialogs. See  Activity#onCreateDialog(int) 
  Activity#onPrepareDialog(int Dialog) 
  Activity#showDialog(int)  and  Activity#dismissDialog(int) . If
 these methods are used  getOwnerActivity()  will return the Activity
 that managed this dialog.

  Often you will want to have a Dialog display on top of the current
 input method because there is no reason for it to accept text.  You can
 do this by setting the  WindowManager.LayoutParams#FLAG_ALT_FOCUSABLE_IM  window flag (assuming
 your Dialog takes input focus as it the default) with the following code:

  
 getWindow().setFlags(WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM
         WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);"
android,app,DirectAction.Builder,3,Builder for construction of DirectAction.
android,app,DownloadManager,10,"The download manager is a system service that handles long-running HTTP downloads. Clients may
 request that a URI be downloaded to a particular destination file. The download manager will
 conduct the download in the background taking care of HTTP interactions and retrying downloads
 after failures or across connectivity changes and system reboots.
  
 Apps that request downloads through this API should register a broadcast receiver for
  ACTION_NOTIFICATION_CLICKED  to appropriately handle when the user clicks on a running
 download in a notification or from the downloads UI.
  
 Note that the application must have the  Manifest.permission.INTERNET 
 permission to use this class."
android,app,Fragment,108,"A Fragment is a piece of an application's user interface or behavior
 that can be placed in an  Activity .  Interaction with fragments
 is done through  FragmentManager  which can be obtained via
  Activity#getFragmentManager()  and
  Fragment#getFragmentManager() .

  The Fragment class can be used many ways to achieve a wide variety of
 results. In its core it represents a particular operation or interface
 that is running within a larger  Activity .  A Fragment is closely
 tied to the Activity it is in and can not be used apart from one.  Though
 Fragment defines its own lifecycle that lifecycle is dependent on its
 activity: if the activity is stopped no fragments inside of it can be
 started; when the activity is destroyed all fragments will be destroyed.

  All subclasses of Fragment must include a public no-argument constructor.
 The framework will often re-instantiate a fragment class when needed
 in particular during state restore and needs to be able to find this
 constructor to instantiate it.  If the no-argument constructor is not
 available a runtime exception will occur in some cases during state
 restore.

  Topics covered here:
  Older Platforms Lifecycle Layout Back Stack"
android,app,FragmentManager.FragmentLifecycleCallbacks,14,"Callback interface for listening to fragment state changes that happen
 within a given FragmentManager."
android,app,IntentService,7,"IntentService is a base class for  Service s that handle asynchronous
 requests (expressed as  Intent s) on demand.  Clients send requests
 through  Context.startService(Intent)  calls; the
 service is started as needed handles each Intent in turn using a worker
 thread and stops itself when it runs out of work.

  This ""work queue processor"" pattern is commonly used to offload tasks
 from an application's main thread.  The IntentService class exists to
 simplify this pattern and take care of the mechanics.  To use it extend
 IntentService and implement  onHandleIntent(android.content.Intent) .  IntentService
 will receive the Intents launch a worker thread and stop the service as
 appropriate.

  All requests are handled on a single worker thread -- they may take as
 long as necessary (and will not block the application's main loop) but
 only one request will be processed at a time.

  Note:  IntentService is subject to all the
  background execution limits 
 imposed with Android 8.0 (API level 26). In most cases you are better off
 using  JobIntentService  which uses jobs
 instead of services when running on Android 8.0 or higher."
android,app,KeyguardManager.KeyguardDismissCallback,3,"Callback passed to
  KeyguardManager#requestDismissKeyguard(Activity KeyguardDismissCallback) 
 to notify caller of result."
android,app,LauncherActivity.IconResizer,1,Utility class to resize icons to match default icon size.
android,app,LocalActivityManager,12,"Helper class for managing multiple running embedded activities in the same
 process. This class is not normally used directly but rather created for
 you as part of the  ActivityGroup  implementation."
android,app,MediaRouteButton,15,
android,app,Notification.InboxStyle,3,"Helper class for generating large-format notifications that include a list of (up to 5) strings.

 Here's how you'd set the  InboxStyle  on a notification:
  
 Notification notif = new Notification.Builder(mContext)
     .setContentTitle(""5 New mails from "" + sender.toString())
     .setContentText(subject)
     .setSmallIcon(R.drawable.new_mail)
     .setLargeIcon(aBitmap)
     .setStyle(new Notification.InboxStyle()
         .addLine(str1)
         .addLine(str2)
         .setContentTitle("""")
         .setSummaryText(""+3 more""))
     .build();"
android,app,Notification.WearableExtender,46,"Helper class to add wearable extensions to notifications.
   See
  Creating Notifications
 for Android Wear  for more information on how to use this class.
  
 To create a notification with wearable extensions:
  Create a  Notification.Builder  setting any desired
   properties.
    Create a  Notification.WearableExtender .
    Set wearable-specific properties using the
    add  and  set  methods of  Notification.WearableExtender .
    Call  Notification.Builder.extend(Notification.Extender)  to apply the extensions to a
   notification.
    Post the notification to the notification system with the
    NotificationManager.notify(...)  methods.
  
 Notification notif = new Notification.Builder(mContext)
         .setContentTitle(""New mail from "" + sender.toString())
         .setContentText(subject)
         .setSmallIcon(R.drawable.new_mail)
         .extend(new Notification.WearableExtender()
                 .setContentIcon(R.drawable.new_mail))
         .build();
 NotificationManager notificationManger =
         (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
 notificationManger.notify(0 notif); Wearable extensions can be accessed on an existing notification by using the
  WearableExtender(Notification)  constructor
 and then using the  get  methods to access values.

  
 Notification.WearableExtender wearableExtender = new Notification.WearableExtender(
         notification);
 List<Notification> pages = wearableExtender.getPages();"
android,app,NotificationManager,37,"Class to notify the user of events that happen.  This is how you tell
 the user that something has happened in the background.  

 Notifications can take different forms:
  A persistent icon that goes in the status bar and is accessible
          through the launcher (when the user selects it a designated Intent
          can be launched) Turning on or flashing LEDs on the device or Alerting the user by flashing the backlight playing a sound
          or vibrating. 
 Each of the notify methods takes an int id parameter and optionally a
  String  tag parameter which may be  null .  These parameters
 are used to form a pair (tag id) or ( null  id) if tag is
 unspecified.  This pair identifies this notification from your app to the
 system so that pair should be unique within your app.  If you call one
 of the notify methods with a (tag id) pair that is currently active and
 a new set of notification parameters it will be updated.  For example
 if you pass a new status bar icon the old icon in the status bar will
 be replaced with the new one.  This is also the same tag and id you pass
 to the  cancel(int)  or  cancel(java.lang.String int)  method to clear
 this notification."
android,app,PictureInPictureParams.Builder,4,Builder class for  PictureInPictureParams  objects.
android,app,TaskInfo,1,Stores information about a particular Task.
android,app,UiAutomation,25,"Class for interacting with the device's UI by simulation user actions and
 introspection of the screen content. It relies on the platform accessibility
 APIs to introspect the screen and to perform some actions on the remote view
 tree. It also allows injecting of arbitrary raw input events simulating user
 interaction with keyboards and touch devices. One can think of a UiAutomation
 as a special type of  AccessibilityService 
 which does not provide hooks for the service life cycle and exposes other
 APIs that are useful for UI test automation.
  
 The APIs exposed by this class are low-level to maximize flexibility when
 developing UI test automation tools and libraries. Generally a UiAutomation
 client should be using a higher-level library or implement high-level functions.
 For example performing a tap on the screen requires construction and injecting
 of a touch down and up events which have to be delivered to the system by a
 call to  injectInputEvent(android.view.InputEvent boolean) .
  
 The APIs exposed by this class operate across applications enabling a client
 to write tests that cover use cases spanning over multiple applications. For
 example going to the settings application to change a setting and then
 interacting with another application whose behavior depends on that setting."
android,app,VoiceInteractor,9,"Interface for an  Activity  to interact with the user through voice.  Use
  Activity.getVoiceInteractor 
 to retrieve the interface if the activity is currently involved in a voice interaction.

  The voice interactor revolves around submitting voice interaction requests to the
 back-end voice interaction service that is working with the user.  These requests are
 submitted with  submitRequest(VoiceInteractor.Request)  providing a new instance of a
  Request  subclass describing the type of operation to perform -- currently the
 possible requests are  ConfirmationRequest  and  CommandRequest .

  Once a request is submitted the voice system will process it and eventually deliver
 the result to the request object.  The application can cancel a pending request at any
 time.

  The VoiceInteractor is integrated with Activity's state saving mechanism so that
 if an activity is being restarted with retained state it will retain the current
 VoiceInteractor and any outstanding requests.  Because of this you should always use
  Request#getActivity()  to get back to the activity of a
 request rather than holding on to the activity instance yourself either explicitly
 or implicitly through a non-static inner class."
android,app,WallpaperManager,39,"Provides access to the system wallpaper. With WallpaperManager you can
 get the current wallpaper get the desired dimensions for the wallpaper set
 the wallpaper and more.

   An app can check whether wallpapers are supported for the current user by calling
  isWallpaperSupported()  and whether setting of wallpapers is allowed by calling
  isSetWallpaperAllowed() ."
android,app,ActionBar.LayoutParams,0,Per-child layout information associated with action bar custom views.
android,app,ActivityGroup,8,A screen that contains and runs multiple embedded activities.
android,app,ApplicationErrorReport.RunningServiceInfo,2,Describes a running service report.
android,app,Fragment.SavedState,2,"State information that has been retrieved from a fragment instance
 through  FragmentManager#saveFragmentInstanceState(Fragment) ."
android,app,FragmentManager,26,"Interface for interacting with  Fragment  objects inside of an
  Activity"
android,app,KeyguardManager.KeyguardLock,2,"Handle returned by  KeyguardManager#newKeyguardLock  that allows
 you to disable / reenable the keyguard."
android,app,ListActivity,10,"An activity that displays a list of items by binding to a data source such as
 an array or Cursor and exposes event handlers when the user selects an item.
  
 ListActivity hosts a  ListView  object that can
 be bound to different data sources typically either an array or a Cursor
 holding query results. Binding screen layout and row layout are discussed
 in the following sections.
  Screen Layout 
 ListActivity has a default layout that consists of a single full-screen list
 in the center of the screen. However if you desire you can customize the
 screen layout by setting your own view layout with setContentView() in
 onCreate(). To do this your own view MUST contain a ListView object with the
 id ""@android:id/list"" (or  R.id.list  if it's in code)
  
 Optionally your custom view can contain another view object of any type to
 display when the list view is empty. This ""empty list"" notifier must have an
 id ""android:id/empty"". Note that when an empty view is present the list view
 will be hidden when there is no data to display.
  
 The following code demonstrates an (ugly) custom screen layout. It has a list
 with a green background and an alternate red ""no data"" message.
  
 <?xml version=""1.0"" encoding=""utf-8""?>
 <LinearLayout xmlns:android=""http://schemas.android.com/apk/res/android""
         android:orientation=""vertical""
         android:layout_width=""match_parent""
         android:layout_height=""match_parent""
         android:paddingLeft=""8dp""
         android:paddingRight=""8dp"">

     <ListView android:id=""@android:id/list""
               android:layout_width=""match_parent""
               android:layout_height=""match_parent""
               android:background=""#00FF00""
               android:layout_weight=""1""
               android:drawSelectorOnTop=""false""/>

     <TextView android:id=""@android:id/empty""
               android:layout_width=""match_parent""
               android:layout_height=""match_parent""
               android:background=""#FF0000""
               android:text=""No data""/>
 </LinearLayout>
  Row Layout 
 You can specify the layout of individual rows in the list. You do this by
 specifying a layout resource in the ListAdapter object hosted by the activity
 (the ListAdapter binds the ListView to the data; more on this later).
  
 A ListAdapter constructor takes a parameter that specifies a layout resource
 for each row. It also has two additional parameters that let you specify
 which data field to associate with which object in the row layout resource.
 These two parameters are typically parallel arrays.
  
 Android provides some standard row layout resources. These are in the
  R.layout  class and have names such as simple_list_item_1
 simple_list_item_2 and two_line_list_item. The following layout XML is the
 source for the resource two_line_list_item which displays two data
 fieldsone above the other for each list row.
  
 <?xml version=""1.0"" encoding=""utf-8""?>
 <LinearLayout xmlns:android=""http://schemas.android.com/apk/res/android""
     android:layout_width=""match_parent""
     android:layout_height=""wrap_content""
     android:orientation=""vertical"">

     <TextView android:id=""@+id/text1""
         android:textSize=""16sp""
         android:textStyle=""bold""
         android:layout_width=""match_parent""
         android:layout_height=""wrap_content""/>

     <TextView android:id=""@+id/text2""
         android:textSize=""16sp""
         android:layout_width=""match_parent""
         android:layout_height=""wrap_content""/>
 </LinearLayout>
  
 You must identify the data bound to each TextView object in this layout. The
 syntax for this is discussed in the next section.
  Binding to Data 
 You bind the ListActivity's ListView object to data using a class that
 implements the  ListAdapter  interface.
 Android provides two standard list adapters:
  SimpleAdapter  for static data (Maps)
 and  SimpleCursorAdapter  for Cursor
 query results.
  
 The following code from a custom ListActivity demonstrates querying the
 Contacts provider for all contacts then binding the Name and Company fields
 to a two line row layout in the activity's ListView.
  
 public class MyListAdapter extends ListActivity {

     @Override
     protected void onCreate(Bundle savedInstanceState){
         super.onCreate(savedInstanceState);

         // We'll define a custom screen layout here (the one shown above) but
         // typically you could just use the standard ListActivity layout.
         setContentView(R.layout.custom_list_activity_view);

         // Query for all people contacts using the  Contacts.People  convenience class.
         // Put a managed wrapper around the retrieved cursor so we don't have to worry about
         // requerying or closing it as the activity changes state.
         mCursor = this.getContentResolver().query(People.CONTENT_URI null null null null);
         startManagingCursor(mCursor);

         // Now create a new list adapter bound to the cursor.
         // SimpleListAdapter is designed for binding to a Cursor.
         ListAdapter adapter = new SimpleCursorAdapter(
                 this // Context.
                 android.R.layout.two_line_list_item  // Specify the row template to use (here two columns bound to the two retrieved cursor
 rows).
                 mCursor                                              // Pass in the cursor to bind to.
                 new String[] {People.NAME People.COMPANY}           // Array of cursor columns to bind to.
                 new int[] {android.R.id.text1 android.R.id.text2});  // Parallel array of which template objects to bind to those columns.

         // Bind to our new adapter.
         setListAdapter(adapter);
     }
 }"
android,app,Notification.BigTextStyle,3,"Helper class for generating large-format notifications that include a lot of text.

 Here's how you'd set the  BigTextStyle  on a notification:
  
 Notification notif = new Notification.Builder(mContext)
     .setContentTitle(""New mail from "" + sender.toString())
     .setContentText(subject)
     .setSmallIcon(R.drawable.new_mail)
     .setLargeIcon(aBitmap)
     .setStyle(new Notification.BigTextStyle()
         .bigText(aVeryLongString))
     .build();"
android,app,Notification.DecoratedCustomViewStyle,0,"Notification style for custom views that are decorated by the system

  Instead of providing a notification that is completely custom a developer can set this
 style and still obtain system decorations like the notification header with the expand
 affordance and actions.

  Use  Notification.Builder.setCustomContentView(RemoteViews) 
  Notification.Builder.setCustomBigContentView(RemoteViews)  and
  Notification.Builder.setCustomHeadsUpContentView(RemoteViews)  to set the
 corresponding custom views to display.

 To use this style with your Notification feed it to
  Notification.Builder#setStyle(android.app.Notification.Style)  like so:
  
 Notification noti = new Notification.Builder()
     .setSmallIcon(R.drawable.ic_stat_player)
     .setLargeIcon(albumArtBitmap))
     .setCustomContentView(contentView);
     .setStyle( new Notification.DecoratedCustomViewStyle() )
     .build();"
android,app,VoiceInteractor.ConfirmationRequest,1,"Confirms an operation with the user via the trusted system
 VoiceInteractionService.  This allows an Activity to complete an unsafe operation that
 would require the user to touch the screen when voice interaction mode is not enabled.
 The result of the confirmation will be returned through an asynchronous call to
 either  onConfirmationResult(boolean android.os.Bundle)  or
  VoiceInteractor.Request.onCancel()  - these methods should be overridden to define the application specific
  behavior.

  In some cases this may be a simple yes / no confirmation or the confirmation could
 include context information about how the action will be completed
 (e.g. booking a cab might include details about how long until the cab arrives)
 so the user can give a confirmation."
android,app,Activity,257,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle"
android,app,AlarmManager.AlarmClockInfo,4,"An immutable description of a scheduled ""alarm clock"" event."
android,app,DownloadManager.Query,2,This class may be used to filter download manager queries.
android,app,ExpandableListActivity,13,"An activity that displays an expandable list of items by binding to a data
 source implementing the ExpandableListAdapter and exposes event handlers
 when the user selects an item.
  
 ExpandableListActivity hosts a
  ExpandableListView  object that can
 be bound to different data sources that provide a two-levels of data (the
 top-level is group and below each group are children). Binding screen
 layout and row layout are discussed in the following sections.
  Screen Layout 
 ExpandableListActivity has a default layout that consists of a single
 full-screen centered expandable list. However if you desire you can
 customize the screen layout by setting your own view layout with
 setContentView() in onCreate(). To do this your own view MUST contain an
 ExpandableListView object with the id ""@android:id/list"" (or
  R.id.list  if it's in code)
  
 Optionally your custom view can contain another view object of any type to
 display when the list view is empty. This ""empty list"" notifier must have an
 id ""android:empty"". Note that when an empty view is present the expandable
 list view will be hidden when there is no data to display.
  
 The following code demonstrates an (ugly) custom screen layout. It has a list
 with a green background and an alternate red ""no data"" message.
  
 <?xml version=""1.0"" encoding=""UTF-8""?>
 <LinearLayout xmlns:android=""http://schemas.android.com/apk/res/android""
         android:orientation=""vertical""
         android:layout_width=""match_parent""
         android:layout_height=""match_parent""
         android:paddingLeft=""8dp""
         android:paddingRight=""8dp"">

     <ExpandableListView android:id=""@id/android:list""
               android:layout_width=""match_parent""
               android:layout_height=""match_parent""
               android:background=""#00FF00""
               android:layout_weight=""1""
               android:drawSelectorOnTop=""false""/>

     <TextView android:id=""@id/android:empty""
               android:layout_width=""match_parent""
               android:layout_height=""match_parent""
               android:background=""#FF0000""
               android:text=""No data""/>
 </LinearLayout>
  Row Layout ExpandableListAdapter ExpandableListActivity setListAdapter(android.widget.ExpandableListAdapter) View View View ExpandableListAdapter SimpleCursorTreeAdapter SimpleExpandableListAdapter 
 With these you can specify the layout of individual rows for groups and
 children in the list. These constructor takes a few parameters that specify
 layout resources for groups and children. It also has additional parameters
 that let you specify which data field to associate with which object in the
 row layout resource. The  SimpleCursorTreeAdapter  fetches data from
  Cursor s and the  SimpleExpandableListAdapter  fetches data
 from  List s of  Map s.
  
 Android provides some standard row layout resources. These are in the
  R.layout  class and have names such as simple_list_item_1
 simple_list_item_2 and two_line_list_item. The following layout XML is the
 source for the resource two_line_list_item which displays two data
 fieldsone above the other for each list row.
  
 <?xml version=""1.0"" encoding=""utf-8""?>
 <LinearLayout xmlns:android=""http://schemas.android.com/apk/res/android""
     android:layout_width=""match_parent""
     android:layout_height=""wrap_content""
     android:orientation=""vertical"">

     <TextView android:id=""@+id/text1""
         android:textSize=""16sp""
         android:textStyle=""bold""
         android:layout_width=""match_parent""
         android:layout_height=""wrap_content""/>

     <TextView android:id=""@+id/text2""
         android:textSize=""16sp""
         android:layout_width=""match_parent""
         android:layout_height=""wrap_content""/>
 </LinearLayout>
  
 You must identify the data bound to each TextView object in this layout. The
 syntax for this is discussed in the next section.
  Binding to Data 
 You bind the ExpandableListActivity's ExpandableListView object to data using
 a class that implements the
  ExpandableListAdapter  interface.
 Android provides two standard list adapters:
  SimpleExpandableListAdapter 
 for static data (Maps) and
  SimpleCursorTreeAdapter  for
 Cursor query results."
android,app,Instrumentation,67,"Base class for implementing application instrumentation code.  When running
 with instrumentation turned on this class will be instantiated for you
 before any of the application code allowing you to monitor all of the
 interaction the system has with the application.  An Instrumentation
 implementation is described to the system through an AndroidManifest.xml's
 <instrumentation> tag."
android,app,Instrumentation.ActivityMonitor,8,"Information about a particular kind of Intent that is being monitored.
 An instance of this class is added to the
 current instrumentation through  Instrumentation.addMonitor(Instrumentation.ActivityMonitor) ; after being added
 when a new activity is being started the monitor will be checked and if
 matching its hit count updated and (optionally) the call stopped and a
 canned result returned.

  An ActivityMonitor can also be used to look for the creation of an
 activity through the  waitForActivity()  method.  This will return
 after a matching activity has been created with that activity object."
android,app,Notification.BubbleMetadata.Builder,8,Builder to construct a  BubbleMetadata  object.
android,app,Person.Builder,7,Builder for the immutable  Person  class.
android,app,LauncherActivity.ListItem,0,An item in the list
android,app,Notification,17,"A class that represents how a persistent notification is to be presented to
 the user using the  NotificationManager .

  The  Notification.Builder  has been added to make it
 easier to construct Notifications."
android,app,Notification.MessagingStyle.Message,8,
android,app,ProgressDialog,23,"A dialog showing a progress indicator and an optional text message or view.
 Only a text message or a view can be used at the same time.

  The dialog can be made cancelable on back key press. The progress range is 0 to  max ."
android,app,Service,21,"A Service is an application component representing either an application's desire
 to perform a longer-running operation while not interacting with the user
 or to supply functionality for other applications to use.  Each service
 class must have a corresponding
  <service> 
 declaration in its package's  AndroidManifest.xml .  Services
 can be started with
  Context.startService()  and
  Context.bindService() .

  Note that services like other application objects run in the main
 thread of their hosting process.  This means that if your service is going
 to do any CPU intensive (such as MP3 playback) or blocking (such as
 networking) operations it should spawn its own thread in which to do that
 work.  More information on this can be found in
  Processes and
 Threads .  The  IntentService  class is available
 as a standard implementation of Service that has its own thread where it
 schedules its work to be done. Topics covered here:
  What is a Service? Service Lifecycle Permissions Process Lifecycle Local Service Sample Remote Messenger Service Sample"
android,app,UiModeManager,5,"This class provides access to the system uimode services.  These services
 allow applications to control UI modes of the device.
 It provides functionality to disable the car mode and it gives access to the
 night mode settings.

  These facilities are built on top of the underlying
  Intent.ACTION_DOCK_EVENT  broadcasts that are sent when the user
 physical places the device into and out of a dock.  When that happens
 the UiModeManager switches the system  Configuration 
 to the appropriate UI mode sends broadcasts about the mode switch and
 starts the corresponding mode activity if appropriate.  See the
 broadcasts  ACTION_ENTER_CAR_MODE  and
  ACTION_ENTER_DESK_MODE  for more information.

  In addition the user may manually switch the system to car mode without
 physically being in a dock.  While in car mode -- whether by manual action
 from the user or being physically placed in a dock -- a notification is
 displayed allowing the user to exit dock mode.  Thus the dock mode
 represented here may be different than the current state of the underlying
 dock event broadcast."
android,app,VoiceInteractor.PickOptionRequest.Option,9,"Represents a single option that the user may select using their voice. The
  getIndex()  method should be used as a unique ID to identify the option
 when it is returned from the voice interactor."
android,hardware.display,DisplayManager,7,Manages the properties of attached displays.
android,hardware.display,VirtualDisplay,6,"Represents a virtual display. The content of a virtual display is rendered to a
  Surface  that you must provide to  DisplayManager#createVirtualDisplay .
  
 Because a virtual display renders to a surface provided by the application it will be
 released automatically when the process terminates and all remaining windows on it will
 be forcibly removed.  However you should also explicitly call  release()  when
 you're done with it."
android,hardware.display,VirtualDisplay.Callback,3,Interface for receiving information about a  VirtualDisplay 's state changes.
android,hardware.camera2.params,BlackLevelPattern,5,"Immutable class to store a 4-element vector of integers corresponding to a 2x2 pattern
 of color channel offsets used for the black level offsets of each color channel.

 For a camera device with
  MONOCHROME  capability all 4 elements of the pattern will have the same value."
android,hardware.camera2.params,ColorSpaceTransform,6,"Immutable class for describing a 3x3 matrix of  Rational  values in row-major order.

  This matrix maps a transform from one color space to another. For the particular color space
 source and target see the appropriate camera metadata documentation for the key that provides
 this value."
android,hardware.camera2.params,Face,7,Describes a face detected in an image.
android,hardware.camera2.params,InputConfiguration,6,"Immutable class to store an input configuration that is used to create a reprocessable capture
 session."
android,hardware.camera2.params,LensShadingMap,9,Immutable class for describing a  4 x N x M  lens shading map of floats.
android,hardware.camera2.params,MandatoryStreamCombination,5,"Immutable class to store the available mandatory stream combination.

  A mandatory stream combination refers to a specific entry in the documented sets of
 required stream  CameraDevice#createCaptureSession .
 These combinations of streams are required to be supported by the camera device.

  The list of stream combinations is available by invoking
  CameraCharacteristics#get  and passing key
  CameraCharacteristics.SCALER_MANDATORY_STREAM_COMBINATIONS ."
android,hardware.camera2.params,MeteringRectangle,12,"An immutable class to represent a rectangle  (x y width height)  with an additional
 weight component.
  
 The rectangle is defined to be inclusive of the specified coordinates.
  
 When used with a  CaptureRequest  the coordinate system is based on the active pixel
 array with  (00)  being the top-left pixel in the
  CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE  and
  (android.sensor.info.activeArraySize.width - 1
 android.sensor.info.activeArraySize.height - 1)  being the bottom-right pixel in the active pixel
 array.
  
 The weight must range from  .METERING_WEIGHT_MIN  to  .METERING_WEIGHT_MAX 
 inclusively and represents a weight for every pixel in the area. This means that a large
 metering area with the same weight as a smaller area will have more effect in the metering
 result. Metering areas can partially overlap and the camera device will add the weights in the
 overlap rectangle.
  
 If all rectangles have 0 weight then no specific metering area needs to be used by the camera
 device. If the metering rectangle is outside the used android.scaler.cropRegion returned in
 capture result metadata the camera device will ignore the sections outside the rectangle and
 output the used sections in the result metadata."
android,hardware.camera2.params,OutputConfiguration,12,"A class for describing camera output which contains a  Surface  and its specific
 configuration for creating capture session.

  There are several ways to instantiate modify and use OutputConfigurations. The most common
 and recommended usage patterns are summarized in the following list: Passing a  Surface  to the constructor and using the OutputConfiguration instance as
 argument to  CameraDevice#createCaptureSessionByOutputConfigurations . This is the most
 frequent usage and clients should consider it first before other more complicated alternatives.
  Passing only a surface source class as an argument to the constructor. This is usually
 followed by a call to create a capture session
 (see  CameraDevice#createCaptureSessionByOutputConfigurations  and a  Surface  add
 call  addSurface(Surface)  with a valid  Surface . The sequence completes with
  CameraCaptureSession#finalizeOutputConfigurations . This is the deferred usage case which
 aims to enhance performance by allowing the resource-intensive capture session create call to
 execute in parallel with any  Surface  initialization such as waiting for a
  SurfaceView  to be ready as part of the UI initialization. The third and most complex usage pattern involves surface sharing. Once instantiated an
 OutputConfiguration can be enabled for surface sharing via  enableSurfaceSharing() . This
 must be done before creating a new capture session and enables calls to
  CameraCaptureSession#updateOutputConfiguration . An OutputConfiguration with enabled
 surface sharing can be modified via  addSurface(Surface)  or  removeSurface(Surface) . The updates
 to this OutputConfiguration will only come into effect after
  CameraCaptureSession#updateOutputConfiguration  returns without throwing exceptions.
 Such updates can be done as long as the session is active. Clients should always consider the
 additional requirements and limitations placed on the output surfaces (for more details see
  enableSurfaceSharing()   addSurface(Surface)   removeSurface(Surface) 
  CameraCaptureSession#updateOutputConfiguration ). A trade-off exists between additional
 complexity and flexibility. If exercised correctly surface sharing can switch between different
 output surfaces without interrupting any ongoing repeating capture requests. This saves time and
 can significantly improve the user experience. Surface sharing can be used in combination with deferred surfaces. The rules from both cases
 are combined and clients must call  enableSurfaceSharing()  before creating a capture
 session. Attach and/or remove output surfaces via   addSurface(Surface) / removeSurface(Surface)  and
 finalize the configuration using  CameraCaptureSession#finalizeOutputConfigurations .
  CameraCaptureSession#updateOutputConfiguration  can be called after the configuration
 finalize method returns without exceptions.  As of  Android P  all formats except
  ImageFormat#JPEG  and  ImageFormat#RAW_PRIVATE  can be used for sharing subject to
 device support. On prior API levels only  ImageFormat#PRIVATE  format may be used."
android,hardware.camera2.params,RggbChannelVector,9,Immutable class to store a 4-element vector of floats indexable by a bayer RAW 2x2 pixel block.
android,hardware.camera2.params,TonemapCurve,6,"Immutable class for describing a  2 x M x 3  tonemap curve of floats.

  This defines red green and blue curves that the  CameraDevice  will
 use as the tonemapping/contrast/gamma curve when  CaptureRequest#TONEMAP_MODE  is
 set to  CameraMetadata#TONEMAP_MODE_CONTRAST_CURVE . For a camera device with
  MONOCHROME  capability all 3 channels will contain the same set of control points.

  The total number of points  (Pin Pout)  for each color channel can be no more than
  CameraCharacteristics#TONEMAP_MAX_CURVE_POINTS . The coordinate system for each point is within the inclusive range
 [ .LEVEL_BLACK   .LEVEL_WHITE ]."
android,hardware.camera2.params,MandatoryStreamCombination.MandatoryStreamInformation,5,Immutable class to store available mandatory stream information.
android,hardware.camera2.params,OisSample,6,"Immutable class to store an
  CaptureResult#STATISTICS_OIS_SAMPLES ."
android,hardware.camera2.params,RecommendedStreamConfigurationMap,18,"Immutable class to store the recommended stream configurations to set up
  Surfaces  for creating a
  capture session  with
  CameraDevice.createCaptureSession(SessionConfiguration) .

  The recommended list does not replace or deprecate the exhaustive complete list found in
  StreamConfigurationMap . It is a suggestion about available power and performance
 efficient stream configurations for a specific use case. Per definition it is only a subset
 of  StreamConfigurationMap  and can be considered by developers for optimization
 purposes. This also duplicates the minimum frame durations and stall durations from the
  StreamConfigurationMap  for each format/size combination that can be used to calculate
 effective frame rate when submitting multiple captures.
  An instance of this object is available by invoking
  CameraCharacteristics#getRecommendedStreamConfigurationMap  and passing a respective
 usecase id. For more information about supported use case constants see
  USECASE_PREVIEW . CameraCharacteristics characteristics = cameraManager.getCameraCharacteristics(cameraId);
 RecommendedStreamConfigurationMap configs = characteristics.getRecommendedStreamConfigurationMap(
         RecommendedStreamConfigurationMap.USECASE_PREVIEW);"
android,hardware.camera2.params,SessionConfiguration,12,A helper class that aggregates all supported arguments for capture session initialization.
android,hardware.camera2.params,StreamConfigurationMap,21,"Immutable class to store the available stream
  CameraCharacteristics#SCALER_STREAM_CONFIGURATION_MAP  to set up
  Surfaces  for creating a
  capture session  with
  CameraDevice.createCaptureSession(SessionConfiguration) .
  This is the authoritative list for all  output formats (and sizes respectively
 for that format) that are supported by a camera device. This also contains the minimum frame durations and stall durations for each format/size
 combination that can be used to calculate effective frame rate when submitting multiple captures.
  An instance of this object is available from  CameraCharacteristics  using
 the  CameraCharacteristics#SCALER_STREAM_CONFIGURATION_MAP  key and the
  CameraCharacteristics#get  method. CameraCharacteristics characteristics = cameraManager.getCameraCharacteristics(cameraId);
 StreamConfigurationMap configs = characteristics.get(
         CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);"
android,hardware.input,InputManager,4,Provides information about input devices and available key layouts.
android,icu.lang,UCharacter,98,"[icu enhancement]  ICU's replacement for  Character .Â Methods fields and other functionality specific to ICU are labeled ' [icu] '.

  The UCharacter class provides extensions to the  Character  class.
 These extensions provide support for more Unicode properties.
 Each ICU release supports the latest version of Unicode available at that time.

  For some time before Java 5 added support for supplementary Unicode code points
 The ICU UCharacter class and many other ICU classes already supported them.
 Some UCharacter methods and constants were widened slightly differently than
 how the Character class methods and constants were widened later.
 In particular  Character#MAX_VALUE  is still a char with the value U+FFFF
 while the  UCharacter#MAX_VALUE  is an int with the value U+10FFFF.

  Code points are represented in these API using ints. While it would be
 more convenient in Java to have a separate primitive datatype for them
 ints suffice in the meantime.

  Aside from the additions for UTF-16 support and the updated Unicode
 properties the main differences between UCharacter and Character are:
   UCharacter is not designed to be a char wrapper and does not have
      APIs to which involves management of that single char. 
      These include:
        char charValue()
          int compareTo(java.lang.Character java.lang.Character) etc.
        UCharacter does not include Character APIs that are deprecated nor
      does it include the Java-specific character information such as
      boolean isJavaIdentifierPart(char ch).
   Character maps characters 'A' - 'Z' and 'a' - 'z' to the numeric
      values '10' - '35'. UCharacter also does this in digit and
      getNumericValue to adhere to the java semantics of these
      methods.  New methods unicodeDigit and
      getUnicodeNumericValue do not treat the above code points
      as having numeric values.  This is a semantic change from ICU4J 1.3.1.
  
 In addition to Java compatibility functions which calculate derived properties
 this API provides low-level access to the Unicode Character Database.
  
 Unicode assigns each code point (not just assigned character) values for
 many properties.
 Most of them are simple boolean flags or constants from a small enumerated list.
 For some properties values are strings or other relatively more complex types.
  
 For more information see
  ""About the Unicode Character Database"" 
 (http://www.unicode.org/ucd/)
 and the  ICU
 User Guide chapter on Properties 
 (http://www.icu-project.org/userguide/properties.html).
  
 There are also functions that provide easy migration from C/POSIX functions
 like isblank(). Their use is generally discouraged because the C/POSIX
 standards do not define their semantics beyond the ASCII range which means
 that different implementations exhibit very different behavior.
 Instead Unicode properties should be used directly.
  
 There are also only a few broad C/POSIX character classes and they tend
 to be used for conflicting purposes. For example the ""isalpha()"" class
 is sometimes used to determine word boundaries while a more sophisticated
 approach would at least distinguish initial letters from continuation
 characters (the latter including combining marks).
 (In ICU BreakIterator is the most sophisticated API for word boundaries.)
 Another example: There is no ""istitle()"" class for titlecase characters.
  
 ICU 3.4 and later provides API access for all twelve C/POSIX character classes.
 ICU implements them according to the Standard Recommendations in
 Annex C: Compatibility Properties of UTS #18 Unicode Regular Expressions
 (http://www.unicode.org/reports/tr18/#Compatibility_Properties).
  
 API access for C/POSIX character classes is as follows:
  - alpha:     isUAlphabetic(c) or hasBinaryProperty(c UProperty.ALPHABETIC)
 - lower:     isULowercase(c) or hasBinaryProperty(c UProperty.LOWERCASE)
 - upper:     isUUppercase(c) or hasBinaryProperty(c UProperty.UPPERCASE)
 - punct:     ((1<<getType(c)) & ((1<<DASH_PUNCTUATION)|(1<<START_PUNCTUATION)|
               (1<<END_PUNCTUATION)|(1<<CONNECTOR_PUNCTUATION)|(1<<OTHER_PUNCTUATION)|
               (1<<INITIAL_PUNCTUATION)|(1<<FINAL_PUNCTUATION)))!=0
 - digit:     isDigit(c) or getType(c)==DECIMAL_DIGIT_NUMBER
 - xdigit:    hasBinaryProperty(c UProperty.POSIX_XDIGIT)
 - alnum:     hasBinaryProperty(c UProperty.POSIX_ALNUM)
 - space:     isUWhiteSpace(c) or hasBinaryProperty(c UProperty.WHITE_SPACE)
 - blank:     hasBinaryProperty(c UProperty.POSIX_BLANK)
 - cntrl:     getType(c)==CONTROL
 - graph:     hasBinaryProperty(c UProperty.POSIX_GRAPH)
 - print:     hasBinaryProperty(c UProperty.POSIX_PRINT) 
 The C/POSIX character classes are also available in UnicodeSet patterns
 using patterns like [:graph:] or \p{graph}.

  [icu] Note:  There are several ICU (and Java) whitespace functions.
 Comparison:  isUWhiteSpace=UCHAR_WHITE_SPACE: Unicode White_Space property;
       most of general categories ""Z"" (separators) + most whitespace ISO controls
       (including no-break spaces but excluding IS1..IS4)
   isWhitespace: Java isWhitespace; Z + whitespace ISO controls but excluding no-break spaces
   isSpaceChar: just Z (including no-break spaces) 
 This class is not subclassable."
android,icu.lang,UCharacter.UnicodeBlock,4,"[icu enhancement]  ICU's replacement for  Character.UnicodeBlock .Â Methods fields and other functionality specific to ICU are labeled ' [icu] '.

 A family of character subsets representing the character blocks in the
 Unicode specification generated from Unicode Data file Blocks.txt.
 Character blocks generally define characters used for a specific script
 or purpose. A character is contained by at most one Unicode block.

  [icu] Note:  All fields named XXX_ID are specific to ICU."
android,icu.lang,UCharacterCategory,1,"Enumerated Unicode category types from the UnicodeData.txt file.
 Used as return results from  UCharacter 
 Equivalent to icu's UCharCategory.
 Refer to  
 Unicode Consortium  for more information about UnicodeData.txt.
  NOTE:  the UCharacterCategory values are  not  compatible with
 those returned by java.lang.Character.getType.  UCharacterCategory values
 match the ones used in ICU4C while java.lang.Character type
 values though similar skip the value 17. 
 This class is not subclassable"
android,icu.lang,UCharacterDirection,1,"Enumerated Unicode character linguistic direction constants.
 Used as return results from  UCharacter 
 This class is not subclassable"
android,icu.lang,UCharacterEnums,0,A container for the different 'enumerated types' used by UCharacter.
android,icu.lang,UScript,14,"Constants for ISO 15924 script codes and related functions.

  The current set of script code constants supports at least all scripts
 that are encoded in the version of Unicode which ICU currently supports.
 The names of the constants are usually derived from the
 Unicode script property value aliases.
 See UAX #24 Unicode Script Property (http://www.unicode.org/reports/tr24/)
 and http://www.unicode.org/Public/UCD/latest/ucd/PropertyValueAliases.txt .

  In addition constants for many ISO 15924 script codes
 are included for use with language tags CLDR data and similar.
 Some of those codes are not used in the Unicode Character Database (UCD).
 For example there are no characters that have a UCD script property value of
 Hans or Hant. All Han ideographs have the Hani script property value in Unicode.

  Private-use codes Qaaa..Qabx are not included except as used in the UCD or in CLDR.

  Starting with ICU 55 script codes are only added when their scripts
 have been or will certainly be encoded in Unicode
 and have been assigned Unicode script property value aliases
 to ensure that their script names are stable and match the names of the constants.
 Script codes like Latf and Aran that are not subject to separate encoding
 may be added at any time."
android,hardware.usb,UsbAccessory,11,"A class representing a USB accessory which is an external hardware component
 that communicates with an android application over USB.
 The accessory is the USB host and android the device side of the USB connection.

  When the accessory connects it reports its manufacturer and model names
 the version of the accessory and a user visible description of the accessory to the device.
 The manufacturer model and version strings are used by the USB Manager to choose
 an appropriate application for the accessory.
 The accessory may optionally provide a unique serial number
 and a URL to for the accessory's website to the device as well.

  An instance of this class is sent to the application via the
  UsbManager#ACTION_USB_ACCESSORY_ATTACHED  Intent.
 The application can then call  UsbManager#openAccessory  to open a file descriptor
 for reading and writing data to and from the accessory."
android,hardware.usb,UsbConfiguration,10,"A class representing a configuration on a  UsbDevice .
 A USB configuration can have one or more interfaces each one providing a different
 piece of functionality separate from the other interfaces.
 An interface will have one or more  UsbEndpoint s which are the
 channels by which the host transfers data with the device."
android,hardware.usb,UsbConstants,0,"Contains constants for the USB protocol.
 These constants correspond to definitions in linux/usb/ch9.h in the linux kernel."
android,hardware.usb,UsbDevice,22,"This class represents a USB device attached to the android device with the android device
 acting as the USB host.
 Each device contains one or more  UsbInterface s each of which contains a number of
  UsbEndpoint s (the channels via which data is transmitted over USB).

   This class contains information (along with  UsbInterface  and  UsbEndpoint )
 that describes the capabilities of the USB device.
 To communicate with the device you open a  UsbDeviceConnection  for the device
 and use  UsbRequest  to send and receive data on an endpoint.
  UsbDeviceConnection#controlTransfer  is used for control requests on endpoint zero."
android,hardware.usb,UsbDeviceConnection,15,"This class is used for sending and receiving data and control messages to a USB device.
 Instances of this class are created by  UsbManager#openDevice ."
android,hardware.usb,UsbEndpoint,10,"A class representing an endpoint on a  UsbInterface .
 Endpoints are the channels for sending and receiving data over USB.
 Typically bulk endpoints are used for sending non-trivial amounts of data.
 Interrupt endpoints are used for sending small amounts of data typically events
 separately from the main data streams.
 The endpoint zero is a special endpoint for control messages sent from the host
 to device.
 Isochronous endpoints are currently unsupported."
android,hardware.usb,UsbInterface,11,"A class representing an interface on a  UsbDevice .
 USB devices can have one or more interfaces each one providing a different
 piece of functionality separate from the other interfaces.
 An interface will have one or more  UsbEndpoint s which are the
 channels by which the host transfers data with the device."
android,hardware.usb,UsbManager,8,"This class allows you to access the state of USB and communicate with USB devices.
 Currently only host mode is supported in the public API."
android,hardware.usb,UsbRequest,9,"A class representing USB request packet.
 This can be used for both reading and writing data to or from a
  UsbDeviceConnection .
 UsbRequests can be used to transfer data on bulk and interrupt endpoints.
 Requests on bulk endpoints can be sent synchronously via  UsbDeviceConnection#bulkTransfer 
 or asynchronously via  queue(ByteBuffer)  and  UsbDeviceConnection#requestWait .
 Requests on interrupt endpoints are only send and received asynchronously.

  Requests on endpoint zero are not supported by this class;
 use  UsbDeviceConnection#controlTransfer  for endpoint zero requests instead."
android,hardware.camera2,CameraCaptureSession,17,"A configured capture session for a  CameraDevice  used for capturing images from the
 camera or reprocessing images captured from the camera in the same session previously.

  A CameraCaptureSession is created by providing a set of target output surfaces to
  CameraDevice#createCaptureSession  or by providing an
  InputConfiguration  and a set of target output surfaces to
  CameraDevice#createReprocessableCaptureSession  for a
 reprocessable capture session. Once created the session is active until a new session is
 created by the camera device or the camera device is closed. All capture sessions can be used for capturing images from the camera but only reprocessable
 capture sessions can reprocess images captured from the camera in the same session previously.
  Creating a session is an expensive operation and can take several hundred milliseconds since
 it requires configuring the camera device's internal pipelines and allocating memory buffers for
 sending images to the desired targets. Therefore the setup is done asynchronously and
  CameraDevice#createCaptureSession  and
  CameraDevice#createReprocessableCaptureSession  will
 send the ready-to-use CameraCaptureSession to the provided listener's
  CameraCaptureSession.StateCallback#onConfigured  callback. If configuration
 cannot be completed then the
  CameraCaptureSession.StateCallback#onConfigureFailed  is called and the
 session will not become active. If a new session is created by the camera device then the previous session is closed and its
 associated  StateCallback#onClosed  callback will be invoked.  All
 of the session methods will throw an IllegalStateException if called once the session is
 closed. A closed session clears any repeating requests (as if  stopRepeating()  had been called)
 but will still complete all of its in-progress capture requests as normal before a newly
 created session takes over and reconfigures the camera device."
android,hardware.camera2,CameraCaptureSession.CaptureCallback,7,"A callback object for tracking the progress of a  CaptureRequest  submitted to the
 camera device. This callback is invoked when a request triggers a capture to start
 and when the capture is complete. In case on an error capturing an image
 the error method is triggered instead of the completion method."
android,hardware.camera2,CameraCaptureSession.StateCallback,7,A callback object for receiving updates about the state of a camera capture session.
android,hardware.camera2,CameraConstrainedHighSpeedCaptureSession,1,"A constrained high speed capture session for a  CameraDevice  used for capturing high
 speed images from the  CameraDevice  for high speed video recording use case.
  
 A CameraHighSpeedCaptureSession is created by providing a set of target output surfaces to
  CameraDevice#createConstrainedHighSpeedCaptureSession  Once created the session is
 active until a new session is created by the camera device or the camera device is closed.
  
 An active high speed capture session is a specialized capture session that is only targeted at
 high speed video recording (>=120fps) use case if the camera device supports high speed video
 capability (i.e.  CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES  contains
  CameraMetadata#REQUEST_AVAILABLE_CAPABILITIES_CONSTRAINED_HIGH_SPEED_VIDEO ). It only
 accepts request lists created via  createHighSpeedRequestList(CaptureRequest)  and the request list can
 only be submitted to this session via  CameraCaptureSession#captureBurst  or
  CameraCaptureSession#setRepeatingBurst . See
  CameraDevice#createConstrainedHighSpeedCaptureSession  for more details of the
 limitations.
  
 Creating a session is an expensive operation and can take several hundred milliseconds since it
 requires configuring the camera device's internal pipelines and allocating memory buffers for
 sending images to the desired targets. Therefore the setup is done asynchronously and
  CameraDevice#createConstrainedHighSpeedCaptureSession  will send the ready-to-use
 CameraCaptureSession to the provided listener's
  CameraCaptureSession.StateCallback#onConfigured  callback. If configuration cannot be
 completed then the  CameraCaptureSession.StateCallback#onConfigureFailed  is called and
 the session will not become active.
  
 If a new session is created by the camera device then the previous session is closed and its
 associated  CameraCaptureSession.StateCallback#onClosed  callback will be
 invoked. All of the session methods will throw an IllegalStateException if called once the
 session is closed.
  
 A closed session clears any repeating requests (as if  CameraCaptureSession.stopRepeating()  had been called)
 but will still complete all of its in-progress capture requests as normal before a newly created
 session takes over and reconfigures the camera device."
android,hardware.camera2,CameraDevice,12,"The CameraDevice class is a representation of a single camera connected to an
 Android device allowing for fine-grain control of image capture and
 post-processing at high frame rates. Your application must declare the
  Camera  permission in its manifest
 in order to access camera devices. A given camera device may provide support at one of several levels defined
 in  CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL .
 If a device supports  CameraMetadata#INFO_SUPPORTED_HARDWARE_LEVEL_LEGACY  level
 the camera device is running in backward compatibility mode and has minimum camera2 API support.
 If a device supports the  CameraMetadata#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED 
 level then Camera2 exposes a feature set that is roughly equivalent to the older
  Camera  API although with a cleaner and more
 efficient interface.
 If a device supports the  CameraMetadata#INFO_SUPPORTED_HARDWARE_LEVEL_EXTERNAL 
 level then the device is a removable camera that provides similar but slightly less features
 as the  CameraMetadata#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED  level.
 Devices that implement the  CameraMetadata#INFO_SUPPORTED_HARDWARE_LEVEL_FULL  or
  CameraMetadata#INFO_SUPPORTED_HARDWARE_LEVEL_3  level of support
 provide substantially improved capabilities over the older camera
 API. If your application requires a full-level device for
 proper operation declare the ""android.hardware.camera.level.full"" feature in your
 manifest."
android,hardware.camera2,CameraManager,11,"A system service manager for detecting characterizing and connecting to
  CameraDevice . For more details about communicating with camera devices read the Camera
 developer guide or the  camera2 
 package documentation."
android,hardware.camera2,CameraManager.AvailabilityCallback,3,"A callback for camera devices becoming available or unavailable to open.

  Cameras become available when they are no longer in use or when a new
 removable camera is connected. They become unavailable when some
 application or service starts using a camera or when a removable camera
 is disconnected. Extend this callback and pass an instance of the subclass to
  CameraManager#registerAvailabilityCallback  to be notified of such availability
 changes."
android,hardware.camera2,CameraMetadata,1,"The base class for camera controls and information.

  
 This class defines the basic key/value map used for querying for camera
 characteristics or capture results and for setting camera request
 parameters.
  
 All instances of CameraMetadata are immutable. The list of keys with  getKeys() 
 never changes nor do the values returned by any key with  #get  throughout
 the lifetime of the object."
android,hardware.camera2,CaptureRequest.Builder,8,"A builder for capture requests.

  To obtain a builder instance use the
  CameraDevice#createCaptureRequest  method which initializes the
 request fields to one of the templates defined in  CameraDevice ."
android,hardware.camera2,CameraCharacteristics,9,"The properties describing a
  CameraDevice . These properties are fixed for a given CameraDevice and can be queried
 through the  CameraManager 
 interface with  CameraManager#getCameraCharacteristics . CameraCharacteristics  objects are immutable."
android,hardware.camera2,CameraCharacteristics.Key,4,"A  Key  is used to do camera characteristics field lookups with
  CameraCharacteristics#get .

  For example to get the stream configuration map:
  
 StreamConfigurationMap map = cameraCharacteristics.get(
      CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);
  To enumerate over all possible keys for  CameraCharacteristics  see
  CameraCharacteristics#getKeys() ."
android,hardware.camera2,CameraDevice.StateCallback,4,"A callback objects for receiving updates about the state of a camera device.

  A callback instance must be provided to the  CameraManager#openCamera  method to
 open a camera device. These state updates include notifications about the device completing startup (
 allowing for  CameraDevice.createCaptureSession(SessionConfiguration)  to be called) about device
 disconnection or closure and about unexpected device errors. Events about the progress of specific  CaptureRequest  are provided
 through a  CameraCaptureSession.CaptureCallback  given to the
  CameraCaptureSession#capture   CameraCaptureSession#captureBurst 
  CameraCaptureSession#setRepeatingRequest  or
  CameraCaptureSession#setRepeatingBurst  methods."
android,hardware.camera2,CameraManager.TorchCallback,2,"A callback for camera flash torch modes becoming unavailable disabled or enabled.

  The torch mode becomes unavailable when the camera device it belongs to becomes
 unavailable or other camera resources it needs become busy due to other higher priority
 camera activities. The torch mode becomes disabled when it was turned off or when the camera
 device it belongs to is no longer in use and other camera resources it needs are no longer
 busy. A camera's torch mode is turned off when an application calls  CameraManager.setTorchMode(String boolean)  to
 turn off the camera's torch mode or when an application turns on another camera's torch mode
 if keeping multiple torch modes on simultaneously is not supported. The torch mode becomes
 enabled when it is turned on via  CameraManager.setTorchMode(String boolean) . The torch mode is available to set via  CameraManager.setTorchMode(String boolean)  only when it's in a disabled
 or enabled state. Extend this callback and pass an instance of the subclass to
  CameraManager#registerTorchCallback  to be notified of such status changes."
android,hardware.camera2,CaptureFailure,6,"A report of failed capture for a single image capture from the image sensor.

  CaptureFailures are produced by a  CameraDevice  if processing a
  CaptureRequest  fails either partially or fully. Use  getReason() 
 to determine the specific nature of the failed capture. Receiving a CaptureFailure means that the metadata associated with that frame number
 has been dropped -- no  CaptureResult  with the same frame number will be
 produced."
android,hardware.camera2,CaptureRequest,8,"An immutable package of settings and outputs needed to capture a single
 image from the camera device. Contains the configuration for the capture hardware (sensor lens flash)
 the processing pipeline the control algorithms and the output buffers. Also
 contains the list of target Surfaces to send image data to for this
 capture. CaptureRequests can be created by using a  Builder  instance
 obtained by calling  CameraDevice#createCaptureRequest CaptureRequests are given to  CameraCaptureSession#capture  or
  CameraCaptureSession#setRepeatingRequest  to capture images from a camera. Each request can specify a different subset of target Surfaces for the
 camera to send the captured data to. All the surfaces used in a request must
 be part of the surface list given to the last call to
  CameraDevice#createCaptureSession  when the request is submitted to the
 session. For example a request meant for repeating preview might only include the
 Surface for the preview SurfaceView or SurfaceTexture while a
 high-resolution still capture would also include a Surface from a ImageReader
 configured for high-resolution JPEG images. A reprocess capture request allows a previously-captured image from the camera device to be
 sent back to the device for further processing. It can be created with
  CameraDevice#createReprocessCaptureRequest  and used with a reprocessable capture session
 created with  CameraDevice#createReprocessableCaptureSession ."
android,hardware.camera2,CaptureRequest.Key,4,"A  Key  is used to do capture request field lookups with
  CaptureResult#get  or to set fields with
  CaptureRequest.Builder#set(Key Object) .

  For example to set the crop rectangle for the next capture:
  
 Rect cropRectangle = new Rect(0 0 640 480);
 captureRequestBuilder.set(SCALER_CROP_REGION cropRectangle);
  To enumerate over all possible keys for  CaptureResult  see
  CameraCharacteristics#getAvailableCaptureResultKeys ."
android,hardware.camera2,CaptureResult,5,"The subset of the results of a single image capture from the image sensor. Contains a subset of the final configuration for the capture hardware (sensor lens
 flash) the processing pipeline the control algorithms and the output
 buffers. CaptureResults are produced by a  CameraDevice  after processing a
  CaptureRequest . All properties listed for capture requests can also
 be queried on the capture result to determine the final values used for
 capture. The result also includes additional metadata about the state of the
 camera device during the capture. Not all properties returned by  CameraCharacteristics#getAvailableCaptureResultKeys() 
 are necessarily available. Some results are  CaptureResult  and will
 not have every key set. Only  TotalCaptureResult  results are guaranteed to have
 every key available that was enabled by the request. CaptureResult  objects are immutable."
android,hardware.camera2,CaptureResult.Key,4,"A  Key  is used to do capture result field lookups with
  CaptureResult#get .

  For example to get the timestamp corresponding to the exposure of the first row:
  
 long timestamp = captureResult.get(CaptureResult.SENSOR_TIMESTAMP);
  To enumerate over all possible keys for  CaptureResult  see
  CameraCharacteristics#getAvailableCaptureResultKeys ."
android,hardware.camera2,DngCreator,10,"The  DngCreator  class provides functions to write raw pixel data as a DNG file.

  
 This class is designed to be used with the  ImageFormat.RAW_SENSOR 
 buffers available from  CameraDevice  or with Bayer-type raw
 pixel data that is otherwise generated by an application.  The DNG metadata tags will be
 generated from a  CaptureResult  object or set directly.
  
 The DNG file format is a cross-platform file format that is used to store pixel data from
 camera sensors with minimal pre-processing applied.  DNG files allow for pixel data to be
 defined in a user-defined colorspace and have associated metadata that allow for this
 pixel data to be converted to the standard CIE XYZ colorspace during post-processing.
  
 For more information on the DNG file format and associated metadata please refer to the
  
 Adobe DNG 1.4.0.0 specification ."
android,hardware.camera2,TotalCaptureResult,2,"The total assembled results of a single image capture from the image sensor. Contains the final configuration for the capture hardware (sensor lens
 flash) the processing pipeline the control algorithms and the output
 buffers. A  TotalCaptureResult  is produced by a  CameraDevice  after processing a
  CaptureRequest . All properties listed for capture requests can also
 be queried on the capture result to determine the final values used for
 capture. The result also includes additional metadata about the state of the
 camera device during the capture. All properties returned by  CameraCharacteristics#getAvailableCaptureResultKeys() 
 are available (that is  CaptureResult#get  will return non- null  if and only if
 that key that was enabled by the request. A few keys such as
  CaptureResult#STATISTICS_FACES  are disabled by default unless enabled with a switch (such
 as  CaptureRequest#STATISTICS_FACE_DETECT_MODE ). Refer to each key documentation on
 a case-by-case basis. For a logical multi-camera device if the CaptureRequest contains a surface for an underlying
 physical camera the corresponding  TotalCaptureResult  object will include the metadata
 for that physical camera. And the mapping between the physical camera id and result metadata
 can be accessed via  getPhysicalCameraResults() . If all requested surfaces are for the
 logical camera no metadata for physical camera will be included. TotalCaptureResult  objects are immutable."
android,icu.math,BigDecimal,55,"The  BigDecimal  class implements immutable arbitrary-precision decimal numbers. The methods of the
  BigDecimal  class provide operations for fixed and floating point arithmetic comparison format
 conversions and hashing.
  
 As the numbers are decimal there is an exact correspondence between an instance of a  BigDecimal  object
 and its  String  representation; the  BigDecimal  class provides direct conversions to and from
  String  and character array ( char[] ) objects as well as conversions to and from the Java
 primitive types (which may not be exact) and  BigInteger .
  
 In the descriptions of constructors and methods in this documentation the value of a  BigDecimal  number
 object is shown as the result of invoking the  toString()  method on the object. The internal
 representation of a decimal number is neither defined nor exposed and is not permitted to affect the result of any
 operation.
  
 The floating point arithmetic provided by this class is defined by the ANSI X3.274-1996 standard and is also
 documented at  http://www2.hursley.ibm.com/decimal [This URL will change.] Operator methods 
 Operations on  BigDecimal  numbers are controlled by a  MathContext  object which provides the
 context (precision and other information) for the operation. Methods that can take a  MathContext 
 parameter implement the standard arithmetic operators for  BigDecimal  objects and are known as
  operator methods . The default settings provided by the constant  MathContext#DEFAULT  ( digits=9
 form=SCIENTIFIC lostDigits=false roundingMode=ROUND_HALF_UP ) perform general-purpose floating point
 arithmetic to nine digits of precision. The  MathContext  parameter must not be  null .
  
 Each operator method also has a version provided which does not take a  MathContext  parameter. For this
 version of each method the context settings used are  digits=0
 form=PLAIN lostDigits=false roundingMode=ROUND_HALF_UP ; these settings perform fixed point arithmetic with
 unlimited precision as defined for the original BigDecimal class in Java 1.1 and Java 1.2.
  
 For monadic operators only the optional  MathContext  parameter is present; the operation acts upon the
 current object.
  
 For dyadic operators a  BigDecimal  parameter is always present; it must not be  null . The
 operation acts with the current object being the left-hand operand and the  BigDecimal  parameter being
 the right-hand operand.
  
 For example adding two  BigDecimal  objects referred to by the names  award  and
  extra  could be written as any of:
  
     award.add(extra)
  award.add(extra MathContext.DEFAULT)
  award.add(extra acontext)
  
 (where  acontext  is a  MathContext  object) which would return a  BigDecimal 
 object whose value is the result of adding  award  and  extra  under the appropriate context
 settings.
  
 When a  BigDecimal  operator method is used a set of rules define what the result will be (and by
 implication how the result would be represented as a character string). These rules are defined in the BigDecimal
 arithmetic documentation (see the URL above) but in summary:
  Results are normally calculated with up to some maximum number of significant digits. For example if the
  MathContext  parameter for an operation were  MathContext.DEFAULT  then the result would be
 rounded to 9 digits; the division of 2 by 3 would then result in 0.666666667.  
 You can change the default of 9 significant digits by providing the method with a suitable  MathContext 
 object. This lets you calculate using as many digits as you need -- thousands if necessary. Fixed point (scaled)
 arithmetic is indicated by using a  digits  setting of 0 (or omitting the  MathContext 
 parameter).  
 Similarly you can change the algorithm used for rounding from the default ""classic"" algorithm.
  
 In standard arithmetic (that is when the  form  setting is not  PLAIN ) a zero result is
 always expressed as the single digit  '0'  (that is with no sign decimal point or exponent part).
  
 Except for the division and power operators in standard arithmetic trailing zeros are preserved (this is in contrast
 to binary floating point operations and most electronic calculators which lose the information about trailing zeros
 in the fractional part of results).  
 So for example:
  
     new BigDecimal(""2.40"").add(     new BigDecimal(""2""))      => ""4.40""
  new BigDecimal(""2.40"").subtract(new BigDecimal(""2""))      => ""0.40""
  new BigDecimal(""2.40"").multiply(new BigDecimal(""2""))      => ""4.80""
  new BigDecimal(""2.40"").divide(  new BigDecimal(""2"") def) => ""1.2""
  
 where the value on the right of the  =>  would be the result of the operation expressed as a
  String  and  def  (in this and following examples) refers to  MathContext.DEFAULT 
 ). This preservation of trailing zeros is desirable for most calculations (including financial calculations). If
 necessary trailing zeros may be easily removed using division by 1.
  
 In standard arithmetic exponential form is used for a result depending on its value and the current setting of
  digits  (the default is 9 digits). If the number of places needed before the decimal point exceeds the
  digits  setting or the absolute value of the number is less than  0.000001  then the number
 will be expressed in exponential notation; thus
  
   new BigDecimal(""1e+6"").multiply(new BigDecimal(""1e+6"") def)
  
 results in  1E+12  instead of  1000000000000  and
  
   new BigDecimal(""1"").divide(new BigDecimal(""3E+10"") def)
  
 results in  3.33333333E-11  instead of  0.0000000000333333333 .
  
 The form of the exponential notation (scientific or engineering) is determined by the  form  setting.
  
 The names of methods in this class follow the conventions established by  java.lang.Number 
  java.math.BigInteger  and  java.math.BigDecimal  in Java 1.1 and Java 1.2."
android,icu.math,MathContext,5,"The  MathContext  immutable class encapsulates the
 settings understood by the operator methods of the  BigDecimal 
 class (and potentially other classes).  Operator methods are those
 that effect an operation on a number or a pair of numbers.
  
 The settings which are not base-dependent comprise:
  digits :
 the number of digits (precision) to be used for an operation
  form :
 the form of any exponent that results from the operation
  lostDigits :
 whether checking for lost digits is enabled
  roundingMode :
 the algorithm to be used for rounding.
  
 When provided a  MathContext  object supplies the
 settings for an operation directly.
  
 When  MathContext.DEFAULT  is provided for a
  MathContext  parameter then the default settings are used
 ( 9 SCIENTIFIC false ROUND_HALF_UP ).
  
 In the  BigDecimal  class all methods which accept a
  MathContext  object defaults) also have a version of the
 method which does not accept a MathContext parameter.  These versions
 carry out unlimited precision fixed point arithmetic (as though the
 settings were ( 0 PLAIN false ROUND_HALF_UP ).
  
 The instance variables are shared with default access (so they are
 directly accessible to the  BigDecimal  class) but must
 never be changed.
  
 The rounding mode constants have the same names and values as the
 constants of the same name in  java.math.BigDecimal  to
 maintain compatibility with earlier versions of
  BigDecimal ."
android,hardware.fingerprint,FingerprintManager,3,"A class that coordinates access to the fingerprint hardware.
  
 Requires the  PackageManager#FEATURE_FINGERPRINT  feature which can be detected using  PackageManager.hasSystemFeature(String) ."
android,hardware.fingerprint,FingerprintManager.AuthenticationCallback,4,"Callback structure provided to  FingerprintManager#authenticate(CryptoObject
 CancellationSignal int AuthenticationCallback Handler) . Users of  FingerprintManager#authenticate(CryptoObject CancellationSignal
 int AuthenticationCallback Handler)  must provide an implementation of this for listening to
 fingerprint events."
android,hardware.fingerprint,FingerprintManager.AuthenticationResult,1,"Container for callback data from  FingerprintManager#authenticate(CryptoObject
     CancellationSignal int AuthenticationCallback Handler) ."
android,hardware.fingerprint,FingerprintManager.CryptoObject,3,"A wrapper class for the crypto objects supported by FingerprintManager. Currently the
 framework supports  Signature   Cipher  and  Mac  objects."
android,inputmethodservice,AbstractInputMethodService,7,"AbstractInputMethodService provides a abstract base class for input methods.
 Normal input method implementations will not derive from this directly
 instead building on top of  InputMethodService  or another more
 complete base class.  Be sure to read  InputMethod  for more
 information on the basics of writing input methods.

  This class combines a Service (representing the input method component
 to the system with the InputMethod interface that input methods must
 implement.  This base class takes care of reporting your InputMethod from
 the service when clients bind to it but provides no standard implementation
 of the InputMethod interface itself.  Derived classes must implement that
 interface."
android,inputmethodservice,AbstractInputMethodService.AbstractInputMethodImpl,3,"Base class for derived classes to implement their  InputMethod 
 interface.  This takes care of basic maintenance of the input method
 but most behavior must be implemented in a derived class."
android,inputmethodservice,AbstractInputMethodService.AbstractInputMethodSessionImpl,7,"Base class for derived classes to implement their  InputMethodSession 
 interface.  This takes care of basic maintenance of the session
 but most behavior must be implemented in a derived class."
android,inputmethodservice,InputMethodService.InputMethodSessionImpl,9,"Concrete implementation of
  AbstractInputMethodService.AbstractInputMethodSessionImpl  that provides
 all of the standard behavior for an input method session."
android,inputmethodservice,Keyboard.Key,5,Class for describing the position and characteristics of a single key in the keyboard.
android,inputmethodservice,ExtractEditText,11,"Specialization of  EditText  for showing and interacting with the
 extracted text in a full-screen input method."
android,inputmethodservice,InputMethodService,85,"InputMethodService provides a standard implementation of an InputMethod
 which final implementations can derive from and customize.  See the
 base class  AbstractInputMethodService  and the  InputMethod 
 interface for more information on the basics of writing input methods.

  In addition to the normal Service lifecycle methods this class
 introduces some new specific callbacks that most subclasses will want
 to make use of: onInitializeInterface()  for user-interface initialization
 in particular to deal with configuration changes while the service is
 running.
  onBindInput()  to find out about switching to a new client.
  onStartInput(EditorInfo boolean)  to deal with an input session starting with
 the client.
  onCreateInputView()   onCreateCandidatesView() 
 and  onCreateExtractTextView()  for non-demand generation of the UI.
  onStartInputView(android.view.inputmethod.EditorInfo boolean)  to deal with input
 starting within the input area of the IME.
  An input method has significant discretion in how it goes about its
 work: the  InputMethodService  provides
 a basic framework for standard UI elements (input view candidates view
 and running in fullscreen mode) but it is up to a particular implementor
 to decide how to use them.  For example one input method could implement
 an input area with a keyboard another could allow the user to draw text
 while a third could have no input area (and thus not be visible to the
 user) but instead listen to audio and perform text to speech conversion. In the implementation provided here all of these elements are placed
 together in a single window managed by the InputMethodService.  It will
 execute callbacks as it needs information about them and provides APIs for
 programmatic control over them.  They layout of these elements is explicitly
 defined: The soft input view if available is placed at the bottom of the
 screen.
  The candidates view if currently shown is placed above the soft
 input view.
  If not running fullscreen the application is moved or resized to be
 above these views; if running fullscreen the window will completely cover
 the application and its top part will contain the extract text of what is
 currently being edited by the application.
  Soft Input View Central to most input methods is the soft input view.  This is where most
 user interaction occurs: pressing on soft keys drawing characters or
 however else your input method wants to generate text.  Most implementations
 will simply have their own view doing all of this work and return a new
 instance of it when  onCreateInputView()  is called.  At that point
 as long as the input view is visible you will see user interaction in
 that view and can call back on the InputMethodService to interact with the
 application as appropriate. There are some situations where you want to decide whether or not your
 soft input view should be shown to the user.  This is done by implementing
 the  onEvaluateInputViewShown()  to return true or false based on
 whether it should be shown in the current environment.  If any of your
 state has changed that may impact this call
  updateInputViewShown()  to have it re-evaluated.  The default
 implementation always shows the input view unless there is a hard
 keyboard available which is the appropriate behavior for most input
 methods. Candidates View Often while the user is generating raw text an input method wants to
 provide them with a list of possible interpretations of that text that can
 be selected for use.  This is accomplished with the candidates view and
 like the soft input view you implement  onCreateCandidatesView() 
 to instantiate your own view implementing your candidates UI. Management of the candidates view is a little different than the input
 view because the candidates view tends to be more transient being shown
 only when there are possible candidates for the current text being entered
 by the user.  To control whether the candidates view is shown you use
  setCandidatesViewShown(boolean) .  Note that because the candidate
 view tends to be shown and hidden a lot it does not impact the application
 UI in the same way as the soft input view: it will never cause application
 windows to resize only cause them to be panned if needed for the user to
 see the current focus. Fullscreen Mode Sometimes your input method UI is too large to integrate with the
 application UI so you just want to take over the screen.  This is
 accomplished by switching to full-screen mode causing the input method
 window to fill the entire screen and add its own ""extracted text"" editor
 showing the user the text that is being typed.  Unlike the other UI elements
 there is a standard implementation for the extract editor that you should
 not need to change.  The editor is placed at the top of the IME above the
 input and candidates views. Similar to the input view you control whether the IME is running in
 fullscreen mode by implementing  onEvaluateFullscreenMode() 
 to return true or false based on
 whether it should be fullscreen in the current environment.  If any of your
 state has changed that may impact this call
  updateFullscreenMode()  to have it re-evaluated.  The default
 implementation selects fullscreen mode when the screen is in a landscape
 orientation which is appropriate behavior for most input methods that have
 a significant input area. When in fullscreen mode you have some special requirements because the
 user can not see the application UI.  In particular you should implement
  onDisplayCompletions(android.view.inputmethod.CompletionInfo[])  to show completions
 generated by your application typically in your candidates view like you
 would normally show candidates.


  Generating Text The key part of an IME is of course generating text for the application.
 This is done through calls to the
  InputConnection  interface to the
 application which can be retrieved from  getCurrentInputConnection() .
 This interface allows you to generate raw key events or if the target
 supports it directly edit in strings of candidates and committed text. Information about what the target is expected and supports can be found
 through the  EditorInfo  class which is
 retrieved with  getCurrentInputEditorInfo()  method.  The most
 important part of this is  EditorInfo.inputType ; in particular if this is
  EditorInfo.TYPE_NULL 
 then the target does not support complex edits and you need to only deliver
 raw key events to it.  An input method will also want to look at other
 values here to for example detect password mode auto complete text views
 phone number entry etc. When the user switches between input targets you will receive calls to
  onFinishInput()  and  onStartInput(android.view.inputmethod.EditorInfo boolean) .
 You can use these to reset and initialize your input state for the current
 target.  For example you will often want to clear any input state and
 update a soft keyboard to be appropriate for the new inputType."
android,inputmethodservice,InputMethodService.InputMethodImpl,8,"Concrete implementation of
  AbstractInputMethodService.AbstractInputMethodImpl  that provides
 all of the standard behavior for an input method."
android,inputmethodservice,InputMethodService.Insets,0,Information about where interesting parts of the input method UI appear.
android,inputmethodservice,Keyboard,18,"Loads an XML description of a keyboard and stores the attributes of the keys. A keyboard
 consists of rows of keys.
  The layout file for a keyboard contains XML that looks like the following snippet: 
 <Keyboard
         android:keyWidth=""%10p""
         android:keyHeight=""50px""
         android:horizontalGap=""2px""
         android:verticalGap=""2px"" >
     <Row android:keyWidth=""32px"" >
         <Key android:keyLabel=""A"" />
         ...
     </Row>
     ...
 </Keyboard>"
android,inputmethodservice,Keyboard.Row,0,"Container for keys in the keyboard. All keys in a row are at the same Y-coordinate.
 Some of the key size defaults can be overridden per row from what the  Keyboard 
 defines."
android,inputmethodservice,KeyboardView,29,"A view that renders a virtual  Keyboard . It handles rendering of keys and
 detecting key presses and touch movements."
android,graphics,Bitmap,65,
android,graphics,BitmapFactory,11,"Creates Bitmap objects from various sources including files streams
 and byte-arrays."
android,graphics,BitmapFactory.Options,1,
android,graphics,BitmapRegionDecoder,10,"BitmapRegionDecoder can be used to decode a rectangle region from an image.
 BitmapRegionDecoder is particularly useful when an original image is large and
 you only need parts of the image.

  To create a BitmapRegionDecoder call newInstance(...).
 Given a BitmapRegionDecoder users can call decodeRegion() repeatedly
 to get a decoded Bitmap of the specified region."
android,graphics,BitmapShader,0,"Shader used to draw a bitmap as a texture. The bitmap can be repeated or
 mirrored by setting the tiling mode."
android,graphics,BlendModeColorFilter,4,"A color filter that can be used to tint the source pixels using a single
 color and a specific  BlendMode ."
android,graphics,BlurMaskFilter,0,"This takes a mask and blurs its edge by the specified radius. Whether or
 or not to include the original mask and whether the blur goes outside
 inside or straddles the original mask's border is controlled by the
 Blur enum."
android,graphics,ColorFilter,0,"A color filter can be used with a  Paint  to modify the color of
 each pixel drawn with that paint. This is an abstract class that should
 never be used directly."
android,graphics,ColorMatrix,13,"4x5 matrix for transforming the color and alpha components of a Bitmap.
 The matrix can be passed as single array and is treated as follows:

  
  [ a b c d e
    f g h i j
    k l m n o
    p q r s t ] 
 When applied to a color  [R G B A]  the resulting color
 is computed as:
  
   Râ€™ = a*R + b*G + c*B + d*A + e;
   Gâ€™ = f*R + g*G + h*B + i*A + j;
   Bâ€™ = k*R + l*G + m*B + n*A + o;
   Aâ€™ = p*R + q*G + r*B + s*A + t; 
 That resulting color  [Râ€™ Gâ€™ Bâ€™ Aâ€™] 
 then has each channel clamped to the  0  to  255 
 range.
  
 The sample ColorMatrix below inverts incoming colors by scaling each
 channel by  -1  and then shifting the result up by
  255  to remain in the standard color space.
  
   [ -1 0 0 0 255
     0 -1 0 0 255
     0 0 -1 0 255
     0 0 0 1 0 ]"
android,graphics,ColorSpace.Connector,5,"A connector transforms colors from a source color space to a destination
 color space. A source color space is connected to a destination color space using the
 color transform \(C\) computed from their respective transforms noted
 \(T_{src}\) and \(T_{dst}\) in the following equation: The transform \(C\) shown above is only valid when the source and
 destination color spaces have the same profile connection space (PCS).
 We know that instances of  ColorSpace  always use CIE XYZ as their
 PCS but their white points might differ. When they do we must perform
 a chromatic adaptation of the color spaces' transforms. To do so we
 use the von Kries method described in the documentation of  Adaptation 
 using the CIE standard illuminant  ColorSpace#ILLUMINANT_D50 
 as the target white point. Example of conversion from  Named#SRGB  to
  Named#DCI_P3 : 
 ColorSpace.Connector connector = ColorSpace.connect(
         ColorSpace.get(ColorSpace.Named.SRGB)
         ColorSpace.get(ColorSpace.Named.DCI_P3));
 float[] p3 = connector.transform(1.0f 0.0f 0.0f);
 // p3 contains { 0.9473 0.2740 0.2076 }"
android,graphics,ComposePathEffect,0,
android,graphics,ComposeShader,0,"A subclass of shader that returns the composition of two other shaders combined by
 an  Xfermode  subclass."
android,graphics,CornerPathEffect,0,
android,graphics,DashPathEffect,0,
android,graphics,DiscretePathEffect,0,
android,graphics,HardwareRenderer,13,"Creates an instance of a hardware-accelerated renderer. This is used to render a scene built
 from  RenderNode 's to an output  Surface . There can be as many
 HardwareRenderer instances as desired. Resources & lifecycle All HardwareRenderer instances share a common render thread. The render thread contains
 the GPU context & resources necessary to do GPU-accelerated rendering. As such the first
 HardwareRenderer created comes with the cost of also creating the associated GPU contexts
 however each incremental HardwareRenderer thereafter is fairly cheap. The expected usage
 is to have a HardwareRenderer instance for every active  Surface . For example
 when an Activity shows a Dialog the system internally will use 2 hardware renderers both
 of which may be drawing at the same time. NOTE: Due to the shared cooperative nature of the render thread it is critical that
 any  Surface  used must have a prompt reliable consuming side. System-provided
 consumers such as  SurfaceView 
  Window.takeSurface(SurfaceHolder.Callback2) 
 or  TextureView  all fit this requirement. However if custom consumers
 are used such as when using  SurfaceTexture  or  ImageReader 
 it is the app's responsibility to ensure that they consume updates promptly and rapidly.
 Failure to do so will cause the render thread to stall on that surface blocking all
 HardwareRenderer instances."
android,graphics,ImageDecoder.ImageInfo,4,Information about an encoded image.
android,graphics,ImageDecoder.Source,0,"Source of encoded image data.

   References the data that will be used to decode a  Drawable 
  or  Bitmap  in  decodeDrawable  or
   decodeBitmap . Constructing a  Source  (with
  one of the overloads of  createSource ) can be done on any thread
  because the construction simply captures values. The real work is done
  in  decodeDrawable  or  decodeBitmap .

   A  Source  object can be reused to create multiple versions of the
  same image. For example to decode a full size image and its thumbnail
  the same  Source  can be used once with no
   OnHeaderDecodedListener  and once with an
  implementation of  OnHeaderDecodedListener#onHeaderDecoded 
  that calls  ImageDecoder.setTargetSize(int int)  with smaller dimensions. One  Source 
  can even be used simultaneously in multiple threads."
android,graphics,ImageFormat,1,
android,graphics,Interpolator,10,
android,graphics,LightingColorFilter,2,"A color filter that can be used to simulate simple lighting effects.
 A  LightingColorFilter  is defined by two parameters one
 used to multiply the source color (called  colorMultiply )
 and one used to add to the source color (called  colorAdd ).
 The alpha channel is left untouched by this color filter.

 Given a source color RGB the resulting R'G'B' color is computed thusly:
  
 R' = R * colorMultiply.R + colorAdd.R
 G' = G * colorMultiply.G + colorAdd.G
 B' = B * colorMultiply.B + colorAdd.B
  [0..255]"
android,graphics,LinearGradient,0,
android,graphics,MaskFilter,0,"MaskFilter is the base class for object that perform transformations on
 an alpha-channel mask before drawing it. A subclass of MaskFilter may be
 installed into a Paint. Blur and emboss are implemented as subclasses of MaskFilter."
android,graphics,Matrix,49,The Matrix class holds a 3x3 matrix for transforming coordinates.
android,graphics,Paint,124,"The Paint class holds the style and color information about how to draw
 geometries text and bitmaps."
android,graphics,Paint.FontMetrics,0,"Class that describes the various metrics for a font at a given text size.
 Remember Y values increase going down so those values will be positive
 and values that measure distances going up will be negative. This class
 is returned by getFontMetrics()."
android,graphics,Paint.FontMetricsInt,1,"Convenience method for callers that want to have FontMetrics values as
 integers."
android,graphics,PaintFlagsDrawFilter,0,
android,graphics,PathEffect,0,"PathEffect is the base class for objects in the Paint that affect
 the geometry of a drawing primitive before it is transformed by the
 canvas' matrix and drawn."
android,graphics,PathMeasure,8,
android,graphics,Point,10,Point holds two integer coordinates
android,graphics,PorterDuffColorFilter,2,"A color filter that can be used to tint the source pixels using a single
 color and a specific  PorterDuff ."
android,graphics,RecordingCanvas,61,"A Canvas implementation that records view system drawing operations for deferred rendering.
 This is used in combination with RenderNode. This class keeps a list of all the Paint and
 Bitmap objects that it draws preventing the backing memory of Bitmaps from being released while
 the RecordingCanvas is still holding a native reference to the memory.

 This is obtained by calling  RenderNode#beginRecording()  and is valid until the matching
  RenderNode#endRecording()  is called. It must not be retained beyond that as it is
 internally reused."
android,graphics,Rect,34,"Rect holds four integer coordinates for a rectangle. The rectangle is
 represented by the coordinates of its 4 edges (left top right bottom).
 These fields can be accessed directly. Use width() and height() to retrieve
 the rectangle's width and height. Note: most methods do not check to see that
 the coordinates are sorted correctly (i.e. left <= right and top <= bottom).
  
 Note that the right and bottom coordinates are exclusive. This means a Rect
 being drawn untransformed onto a  Canvas  will draw
 into the column and row described by its left and top coordinates but not
 those of its bottom and right."
android,graphics,RegionIterator,2,
android,graphics,RenderNode,67,"RenderNode is used to build hardware accelerated rendering hierarchies. Each RenderNode
 contains both a display list as well as a set of properties that affect the rendering of the
 display list. RenderNodes are used internally for all Views by default and are not typically
 used directly. RenderNodes are used to divide up the rendering content of a complex scene into smaller
 pieces that can then be updated individually more cheaply. Updating part of the scene only needs
 to update the display list or properties of a small number of RenderNode instead of redrawing
 everything from scratch. A RenderNode only needs its display list re-recorded when its content
 alone should be changed. RenderNodes can also be transformed without re-recording the display
 list through the transform properties. A text editor might for instance store each paragraph into its own RenderNode.
 Thus when the user inserts or removes characters only the display list of the
 affected paragraph needs to be recorded again. Hardware acceleration RenderNodes can be drawn using a  RecordingCanvas . They are not
 supported in software. Always make sure that the  Canvas 
 you are using to render a display list is hardware accelerated using
  Canvas.isHardwareAccelerated() . Creating a RenderNode 
     RenderNode renderNode = new RenderNode(""myRenderNode"");
     renderNode.setLeftTopRightBottom(0 0 50 50); // Set the size to 50x50
     RecordingCanvas canvas = renderNode.beginRecording();
     try {
         // Draw with the canvas
         canvas.drawRect(...);
     } finally {
         renderNode.endRecording();
     } Drawing a RenderNode in a View 
     protected void onDraw(Canvas canvas) {
         if (canvas.isHardwareAccelerated()) {
             // Check that the RenderNode has a display list re-recording it if it does not.
             if (!myRenderNode.hasDisplayList()) {
                 updateDisplayList(myRenderNode);
             }
             // Draw the RenderNode into this canvas.
             canvas.drawRenderNode(myRenderNode);
         }
     } Releasing resources This step is not mandatory but recommended if you want to release resources
 held by a display list as soon as possible. Most significantly any bitmaps it may contain. 
     // Discards the display list content allowing for any held resources to be released.
     // After calling this
     renderNode.discardDisplayList(); Properties In addition a RenderNode offers several properties such as
  setScaleX(float)  or  setTranslationX(float)  that can be used to affect all
 the drawing commands recorded within. For instance these properties can be used
 to move around a large number of images without re-issuing all the individual
  canvas.drawBitmap()  calls. 
     private void createDisplayList() {
         mRenderNode = new RenderNode(""MyRenderNode"");
         mRenderNode.setLeftTopRightBottom(0 0 width height);
         RecordingCanvas canvas = mRenderNode.beginRecording();
         try {
             for (Bitmap b : mBitmaps) {
                 canvas.drawBitmap(b 0.0f 0.0f null);
                 canvas.translate(0.0f b.getHeight());
             }
         } finally {
             mRenderNode.endRecording();
         }
     }

     protected void onDraw(Canvas canvas) {
         if (canvas.isHardwareAccelerated())
             canvas.drawRenderNode(mRenderNode);
         }
     }

     private void moveContentBy(int x) {
          // This will move all the bitmaps recorded inside the display list
          // by x pixels to the right and redraw this view. All the commands
          // recorded in createDisplayList() won't be re-issued only onDraw()
          // will be invoked and will execute very quickly
          mRenderNode.offsetLeftAndRight(x);
          invalidate();
     } A few of the properties may at first appear redundant such as  setElevation(float) 
 and  setTranslationZ(float) . The reason for these duplicates are to allow for a
 separation between static & transient usages. For example consider a button that raises from 2dp
 to 8dp when pressed. To achieve that an application may decide to setElevation(2dip) and then
 on press to animate setTranslationZ to 6dip. Combined this achieves the final desired 8dip
 value but the animation need only concern itself with animating the lift from press without
 needing to know the initial starting value.  setTranslationX(float)  and
  setTranslationY(float)  are similarly provided for animation uses despite the functional
 overlap with  setPosition(android.graphics.Rect) .

  The RenderNode's transform matrix is computed at render time as follows:
  
     Matrix transform = new Matrix();
     transform.setTranslate(renderNode.getTranslationX() renderNode.getTranslationY());
     transform.preRotate(renderNode.getRotationZ()
             renderNode.getPivotX() renderNode.getPivotY());
     transform.preScale(renderNode.getScaleX() renderNode.getScaleY()
             renderNode.getPivotX() renderNode.getPivotY()); 
     renderNode.setTranslationX(100);
     renderNode.setScaleX(100); 
     renderNode.setScaleX(100);
     renderNode.setTranslationX(100); Threading RenderNode may be created and used on any thread but they are not thread-safe. Only
 a single thread may interact with a RenderNode at any given time. It is critical
 that the RenderNode is only used on the same thread it is drawn with. For example when using
 RenderNode with a custom View then that RenderNode must only be used from the UI thread. When to re-render Many of the RenderNode mutation methods such as  setTranslationX(float)  return
 a boolean indicating if the value actually changed or not. This is useful in detecting
 if a new frame should be rendered or not. A typical usage would look like:
  
     public void translateTo(int x int y) {
         boolean needsUpdate = myRenderNode.setTranslationX(x);
         needsUpdate |= myRenderNode.setTranslationY(y);
         if (needsUpdate) {
             myOwningView.invalidate();
         }
     } getTranslationX() Surface#lockHardwareCanvas() Surface#lockHardwareCanvas() Surface#unlockCanvasAndPost(Canvas)"
android,graphics,Shader,2,"Shader is the based class for objects that return horizontal spans of colors
 during drawing. A subclass of Shader is installed in a Paint calling
 paint.setShader(shader). After that any object (other than a bitmap) that is
 drawn with that paint will get its color(s) from the shader."
android,graphics,SumPathEffect,0,
android,graphics,SurfaceTexture,12,"Captures frames from an image stream as an OpenGL ES texture.

  The image stream may come from either camera preview or video decode. A
  Surface  created from a SurfaceTexture can be used as an output
 destination for the  android.hardware.camera2   MediaCodec 
  MediaPlayer  and  Allocation  APIs.
 When  updateTexImage()  is called the contents of the texture object specified
 when the SurfaceTexture was created are updated to contain the most recent image from the image
 stream.  This may cause some frames of the stream to be skipped.

  A SurfaceTexture may also be used in place of a SurfaceHolder when specifying the output
 destination of the older  Camera  API. Doing so will cause all the
 frames from the image stream to be sent to the SurfaceTexture object rather than to the device's
 display.

  When sampling from the texture one should first transform the texture coordinates using the
 matrix queried via  getTransformMatrix(float[]) .  The transform matrix may change each
 time  updateTexImage()  is called so it should be re-queried each time the texture image
 is updated.
 This matrix transforms traditional 2D OpenGL ES texture coordinate column vectors of the form (s
 t 0 1) where s and t are on the inclusive interval [0 1] to the proper sampling location in
 the streamed texture.  This transform compensates for any properties of the image stream source
 that cause it to appear different from a traditional OpenGL ES texture.  For example sampling
 from the bottom left corner of the image can be accomplished by transforming the column vector
 (0 0 0 1) using the queried matrix while sampling from the top right corner of the image can
 be done by transforming (1 1 0 1).

  The texture object uses the GL_TEXTURE_EXTERNAL_OES texture target which is defined by the
  
 GL_OES_EGL_image_external  OpenGL ES extension.  This limits how the texture may be used.
 Each time the texture is bound it must be bound to the GL_TEXTURE_EXTERNAL_OES target rather than
 the GL_TEXTURE_2D target.  Additionally any OpenGL ES 2.0 shader that samples from the texture
 must declare its use of this extension using for example an ""#extension
 GL_OES_EGL_image_external : require"" directive.  Such shaders must also access the texture using
 the samplerExternalOES GLSL sampler type.

  SurfaceTexture objects may be created on any thread.   updateTexImage()  may only be
 called on the thread with the OpenGL ES context that contains the texture object.  The
 frame-available callback is called on an arbitrary thread so unless special care is taken  updateTexImage()  should not be called directly from the callback."
android,graphics,Typeface,13,"The Typeface class specifies the typeface and intrinsic style of a font.
 This is used in the paint along with optionally Paint settings like
 textSize textSkewX textScaleX to specify
 how text appears when drawn (and measured)."
android,graphics,Typeface.Builder,7,"A builder class for creating new Typeface instance.

  
 Examples
 1) Create Typeface from ttf file.
  
 Typeface.Builder buidler = new Typeface.Builder(""your_font_file.ttf"");
 Typeface typeface = builder.build();
  
 Typeface.Builder buidler = new Typeface.Builder(getAssets() ""your_font_file.ttc"");
 builder.setTtcIndex(2);  // Set index of font collection.
 Typeface typeface = builder.build();
  
 Typeface.Builder buidler = new Typeface.Builder(""your_font_file.ttf"");
 builder.setFontVariationSettings(""'wght' 700 'slnt' 20 'ital' 1"");
 builder.setWeight(700);  // Tell the system that this is a bold font.
 builder.setItalic(true);  // Tell the system that this is an italic style font.
 Typeface typeface = builder.build();"
android,graphics,YuvImage,6,"YuvImage contains YUV data and provides a method that compresses a region of
 the YUV data to a Jpeg. The YUV data should be provided as a single byte
 array irrespective of the number of image planes in it.
 Currently only ImageFormat.NV21 and ImageFormat.YUY2 are supported.

 To compress a rectangle region in the YUV data users have to specify the
 region by left top width and height."
android,graphics,Camera,15,"A camera instance can be used to compute 3D transformations and
 generate a matrix that can be applied for instance on a
  Canvas ."
android,graphics,Color,58,"The  Color  class provides methods for creating converting and
 manipulating colors. Colors have three different representations: Color ints the most common representation Color longs Color  instances The section below describe each representation in detail. Color ints Color ints are the most common representation of colors on Android and
 have been used since  API level 1 . A color int always defines a color in the  ColorSpace.Named#SRGB 
 color space using 4 components packed in a single 32 bit integer value: Component Name Size Range A Alpha 8 bits \([0..255]\) R Red 8 bits \([0..255]\) G Green 8 bits \([0..255]\) B Blue 8 bits \([0..255]\) The components in this table are listed in encoding order (see below)
 which is why color ints are called ARGB colors. Usage in code To avoid confusing color ints with arbitrary integer values it is a
 good practice to annotate them with the  @ColorInt  annotation
 found in the Android Support Library. Encoding The four components of a color int are encoded in the following way: 
 int color = (A & 0xff) << 24 | (R & 0xff) << 16 | (G & 0xff) << 8 | (B & 0xff);
  Because of this encoding color ints can easily be described as an integer
 constant in source. For instance opaque blue is  0xff0000ff 
 and yellow is  0xffffff00 . To easily encode color ints it is recommended to use the static methods
  argb(int int int int)  and  rgb(int int int) . The second
 method omits the alpha component and assumes the color is opaque (alpha is 255).
 As a convenience this class also offers methods to encode color ints from components
 defined in the \([0..1]\) range:  argb(float float float float)  and
  rgb(float float float) . Color longs (defined below) can be easily converted to color ints by invoking
 the  toArgb(long)  method. This method performs a color space conversion
 if needed. It is also possible to create a color int by invoking the method  toArgb() 
 on a color instance. Decoding The four ARGB components can be individually extracted from a color int
 using the following expressions: 
 int A = (color >> 24) & 0xff; // or color >>> 24
 int R = (color >> 16) & 0xff;
 int G = (color >>  8) & 0xff;
 int B = (color      ) & 0xff;
  This class offers convenience methods to easily extract these components: alpha(int)  to extract the alpha component red(int)  to extract the red component green(int)  to extract the green component blue(int)  to extract the blue component Color longs Color longs are a representation introduced in
  Android O  to store colors in different
  ColorSpace  with more precision than color ints. A color long always defines a color using 4 components packed in a single
 64 bit long value. One of these components is always alpha while the other
 three components depend on the color space's  ColorSpace.Model .
 The most common color model is the  ColorSpace.Model#RGB  model in
 which the components represent red green and blue values. Component ranges:  the ranges defined in the tables
 below indicate the ranges that can be encoded in a color long. They do not
 represent the actual ranges as they may differ per color space. For instance
 the RGB components of a color in the  ColorSpace.Named#DISPLAY_P3 
 color space use the \([0..1]\) range. Please refer to the documentation of the
 various  ColorSpace.Named  to find their respective ranges. Alpha range:  while alpha is encoded in a color long using
 a 10 bit integer (thus using a range of \([0..1023]\)) it is converted to and
 from \([0..1]\) float values when decoding and encoding color longs. sRGB color space:  for compatibility reasons and ease of
 use color longs encoding  ColorSpace.Named#SRGB  colors do not
 use the same encoding as other color longs. Component Name Size Range ColorSpace.Model#RGB  color model R Red 16 bits \([-65504.0 65504.0]\) G Green 16 bits \([-65504.0 65504.0]\) B Blue 16 bits \([-65504.0 65504.0]\) A Alpha 10 bits \([0..1023]\) Color space 6 bits \([0..63]\) ColorSpace.Named#SRGB  color space A Alpha 8 bits \([0..255]\) R Red 8 bits \([0..255]\) G Green 8 bits \([0..255]\) B Blue 8 bits \([0..255]\) X Unused 32 bits \(0\) ColorSpace.Model#XYZ  color model X X 16 bits \([-65504.0 65504.0]\) Y Y 16 bits \([-65504.0 65504.0]\) Z Z 16 bits \([-65504.0 65504.0]\) A Alpha 10 bits \([0..1023]\) Color space 6 bits \([0..63]\) ColorSpace.Model#XYZ  color model L L 16 bits \([-65504.0 65504.0]\) a a 16 bits \([-65504.0 65504.0]\) b b 16 bits \([-65504.0 65504.0]\) A Alpha 10 bits \([0..1023]\) Color space 6 bits \([0..63]\) ColorSpace.Model#CMYK  color model Unsupported The components in this table are listed in encoding order (see below)
 which is why color longs in the RGB model are called RGBA colors (even if
 this doesn't quite hold for the special case of sRGB colors). The color long encoding relies on half-precision float values (fp16). If you
 wish to know more about the limitations of half-precision float values please
 refer to the documentation of the  Half  class. Usage in code To avoid confusing color longs with arbitrary long values it is a
 good practice to annotate them with the  @ColorLong  annotation
 found in the Android Support Library. Encoding Given the complex nature of color longs it is strongly encouraged to use
 the various methods provided by this class to encode them. The most flexible way to encode a color long is to use the method
  pack(float float float float android.graphics.ColorSpace) . This method allows you
 to specify three color components (typically RGB) an alpha component and a
 color space. To encode sRGB colors use  pack(float float float) 
 and  pack(float float float float)  which are the
 equivalent of  rgb(int int int)  and  argb(int int int int) 
 for color ints. If you simply need to convert a color int into a color long
 use  pack(int) . It is also possible to create a color long value by invoking the method
  pack()  on a color instance. Decoding This class offers convenience methods to easily extract the components
 of a color long: alpha(long)  to extract the alpha component red(long)  to extract the red/X/L component green(long)  to extract the green/Y/a component blue(long)  to extract the blue/Z/b component The values returned by these methods depend on the color space encoded
 in the color long. The values are however typically in the \([0..1]\) range
 for RGB colors. Please refer to the documentation of the various
  ColorSpace.Named  for the exact ranges. Color instances Color instances are a representation introduced in
  Android O  to store colors in different
  ColorSpace  with more precision than both color ints and
 color longs. Color instances also offer the ability to store more than 4
 components if necessary. Colors instances are immutable and can be created using one of the various
  valueOf  methods. For instance: 
 // sRGB
 Color opaqueRed = Color.valueOf(0xffff0000); // from a color int
 Color translucentRed = Color.valueOf(1.0f 0.0f 0.0f 0.5f);

 // Wide gamut color
 @ColorLong long p3 = pack(1.0f 1.0f 0.0f 1.0f colorSpaceP3);
 Color opaqueYellow = Color.valueOf(p3); // from a color long

 // CIE L*a*b* color space
 ColorSpace lab = ColorSpace.get(ColorSpace.Named.LAB);
 Color green = Color.valueOf(100.0f -128.0f 128.0f 1.0f lab);
  Color instances can be converted to color ints ( toArgb() ) or
 color longs ( pack() ). They also offer easy access to their various
 components using the following methods: alpha()  returns the alpha component value red()  returns the red component value (or first
     component value in non-RGB models) green()  returns the green component value (or second
     component value in non-RGB models) blue()  returns the blue component value (or third
     component value in non-RGB models) getComponent(int)  returns a specific component value getComponents()  returns all component values as an array Color space conversions You can convert colors from one color space to another using
  ColorSpace#connect(ColorSpace ColorSpace)  and its variants. However
 the  Color  class provides a few convenience methods to simplify
 the process. Here is a brief description of some of them: convert(android.graphics.ColorSpace)  to convert a color instance in a color
     space to a new color instance in a different color space convert(float float float float android.graphics.ColorSpace android.graphics.ColorSpace)  to
     convert a color from a source color space to a destination color space convert(long android.graphics.ColorSpace)  to convert a color long from its
     built-in color space to a destination color space convert(int android.graphics.ColorSpace)  to convert a color int from sRGB
     to a destination color space Please refere to the  ColorSpace  documentation for more
 information. Alpha and transparency The alpha component of a color defines the level of transparency of a
 color. When the alpha component is 0 the color is completely transparent.
 When the alpha is component is 1 (in the \([0..1]\) range) or 255 (in the
 \([0..255]\) range) the color is completely opaque. The color representations described above do not use pre-multiplied
 color components (a pre-multiplied color component is a color component
 that has been multiplied by the value of the alpha component).
 For instance the color int representation of opaque red is
  0xffff0000 . For semi-transparent (50%) red the
 representation becomes  0x80ff0000 . The equivalent color
 instance representations would be  (1.0 0.0 0.0 1.0) 
 and  (1.0 0.0 0.0 0.5) ."
android,graphics,ColorMatrixColorFilter,1,"A color filter that transforms colors through a 4x5 color matrix. This filter
 can be used to change the saturation of pixels convert from YUV to RGB etc."
android,graphics,ColorSpace,23,"A  ColorSpace  is used to identify a specific organization of colors.
 Each color space is characterized by a  Model  that defines
 how a color value is represented (for instance the  Model#RGB  color
 model defines a color value as a triplet of numbers). Each component of a color must fall within a valid range specific to each
 color space defined by  getMinValue(int)  and  getMaxValue(int) 
 This range is commonly \([0..1]\). While it is recommended to use values in the
 valid range a color space always clamps input and output values when performing
 operations such as converting to a different color space. Using color spaces This implementation provides a pre-defined set of common color spaces
 described in the  Named  enum. To obtain an instance of one of the
 pre-defined color spaces simply invoke  get(android.graphics.ColorSpace.Named) : 
 ColorSpace sRgb = ColorSpace.get(ColorSpace.Named.SRGB);
  The  get(android.graphics.ColorSpace.Named)  method always returns the same instance for a given
 name. Color spaces with an  Model#RGB  color model can be safely
 cast to  Rgb . Doing so gives you access to more APIs to query various
 properties of RGB color models: color gamut primaries transfer functions
 conversions to and from linear space etc. Please refer to  Rgb  for
 more information. The documentation of  Named  provides a detailed description of the
 various characteristics of each available color space. Color space conversions To allow conversion between color spaces this implementation uses the CIE
 XYZ profile connection space (PCS). Color values can be converted to and from
 this PCS using  toXyz(float[])  and  fromXyz(float[]) . For color space with a non-RGB color model the white point of the PCS
  must be  the CIE standard illuminant D50. RGB color spaces use their
 native white point (D65 for  Named#SRGB  for instance and must
 undergo  Adaptation  as necessary. Since the white point of the PCS is not defined for RGB color space it is
 highly recommended to use the variants of the  connect(android.graphics.ColorSpace android.graphics.ColorSpace) 
 method to perform conversions between color spaces. A color space can be
 manually adapted to a specific white point using  adapt(android.graphics.ColorSpace float[]) .
 Please refer to the documentation of  Rgb  for more
 information. Several common CIE standard illuminants are provided in this
 class as reference (see  ILLUMINANT_D65  or  ILLUMINANT_D50 
 for instance). Here is an example of how to convert from a color space to another: 
 // Convert from DCI-P3 to Rec.2020
 ColorSpace.Connector connector = ColorSpace.connect(
         ColorSpace.get(ColorSpace.Named.DCI_P3)
         ColorSpace.get(ColorSpace.Named.BT2020));

 float[] bt2020 = connector.transform(p3r p3g p3b);
  You can easily convert to  Named#SRGB  by omitting the second
 parameter: 
 // Convert from DCI-P3 to sRGB
 ColorSpace.Connector connector = ColorSpace.connect(ColorSpace.get(ColorSpace.Named.DCI_P3));

 float[] sRGB = connector.transform(p3r p3g p3b);
  Conversions also work between color spaces with different color models: 
 // Convert from CIE L*a*b* (color model Lab) to Rec.709 (color model RGB)
 ColorSpace.Connector connector = ColorSpace.connect(
         ColorSpace.get(ColorSpace.Named.CIE_LAB)
         ColorSpace.get(ColorSpace.Named.BT709));
  Color spaces and multi-threading Color spaces and other related classes ( Connector  for instance)
 are immutable and stateless. They can be safely used from multiple concurrent
 threads. Public static methods provided by this class such as  get(android.graphics.ColorSpace.Named) 
 and  connect(android.graphics.ColorSpace android.graphics.ColorSpace)  are also guaranteed to be
 thread-safe."
android,graphics,ColorSpace.Rgb,23,"An RGB color space is an additive color space using the
  Model#RGB  color model (a color is therefore represented
 by a tuple of 3 numbers). A specific RGB color space is defined by the following properties: Three chromaticities of the red green and blue primaries which
     define the gamut of the color space. A white point chromaticity that defines the stimulus to which
     color space values are normalized (also just called ""white""). An opto-electronic transfer function also called opto-electronic
     conversion function or often and approximately gamma function. An electro-optical transfer function also called electo-optical
     conversion function or often and approximately gamma function. A range of valid RGB values (most commonly \([0..1]\)). The most commonly used RGB color space is  Named#SRGB . Primaries and white point chromaticities In this implementation the chromaticity of the primaries and the white
 point of an RGB color space is defined in the CIE xyY color space. This
 color space separates the chromaticity of a color the x and y components
 and its luminance the Y component. Since the primaries and the white
 point have full brightness the Y component is assumed to be 1 and only
 the x and y components are needed to encode them. For convenience this implementation also allows to define the
 primaries and white point in the CIE XYZ space. The tristimulus XYZ values
 are internally converted to xyY. sRGB primaries and white point Transfer functions A transfer function is a color component conversion function defined as
 a single variable monotonic mathematical function. It is applied to each
 individual component of a color. They are used to perform the mapping
 between linear tristimulus values and non-linear electronic signal value. The  opto-electronic transfer function  (OETF or OECF) encodes
 tristimulus values in a scene to a non-linear electronic signal value.
 An OETF is often expressed as a power function with an exponent between
 0.38 and 0.55 (the reciprocal of 1.8 to 2.6). The  electro-optical transfer function  (EOTF or EOCF) decodes
 a non-linear electronic signal value to a tristimulus value at the display.
 An EOTF is often expressed as a power function with an exponent between
 1.8 and 2.6. Transfer functions are used as a compression scheme. For instance
 linear sRGB values would normally require 11 to 12 bits of precision to
 store all values that can be perceived by the human eye. When encoding
 sRGB values using the appropriate OETF (see  Named#SRGB  for
 an exact mathematical description of that OETF) the values can be
 compressed to only 8 bits precision. When manipulating RGB values particularly sRGB values it is safe
 to assume that these values have been encoded with the appropriate
 OETF (unless noted otherwise). Encoded values are often said to be in
 ""gamma space"". They are therefore defined in a non-linear space. This
 in turns means that any linear operation applied to these values is
 going to yield mathematically incorrect results (any linear interpolation
 such as gradient generation for instance most image processing functions
 such as blurs etc.). To properly process encoded RGB values you must first apply the
 EOTF to decode the value into linear space. After processing the RGB
 value must be encoded back to non-linear (""gamma"") space. Here is a
 formal description of the process where \(f\) is the processing
 function to apply: If the transfer functions of the color space can be expressed as an
 ICC parametric curve as defined in ICC.1:2004-10 the numeric parameters
 can be retrieved by calling  getTransferParameters() . This can
 be useful to match color spaces for instance. Some RGB color spaces such as  Named#ACES  and
  Named#LINEAR_EXTENDED_SRGB  are said to be linear because
 their transfer functions are the identity function: \(f(x) = x\).
 If the source and/or destination are known to be linear it is not
 necessary to invoke the transfer functions. Range Most RGB color spaces allow RGB values in the range \([0..1]\). There
 are however a few RGB color spaces that allow much larger ranges. For
 instance  Named#EXTENDED_SRGB  is used to manipulate the
 range \([-0.5..7.5]\) while  Named#ACES  can be used throughout
 the range \([-65504 65504]\). Extended sRGB and its large range Converting between RGB color spaces Conversion between two color spaces is achieved by using an intermediate
 color space called the profile connection space (PCS). The PCS used by
 this implementation is CIE XYZ. The conversion operation is defined
 as such: Where \(T_{src}\) is the  RGB to XYZ transform 
 of the source color space and \(T_{dst}^{-1}\) the  XYZ to RGB transform  of the destination color space. Many RGB color spaces commonly used with electronic devices use the
 standard illuminant  D65 . Care must be take however
 when converting between two RGB color spaces if their white points do not
 match. This can be achieved by either calling
  ColorSpace.adapt(android.graphics.ColorSpace float[])  to adapt one or both color spaces to
 a single common white point. This can be achieved automatically by calling
  ColorSpace#connect(ColorSpace ColorSpace)  which also handles
 non-RGB color spaces. To learn more about the white point adaptation process refer to the
 documentation of  Adaptation ."
android,graphics,ColorSpace.Rgb.TransferParameters,2,"Defines the parameters for the ICC parametric curve type 4 as
 defined in ICC.1:2004-10 section 10.15. The EOTF is of the form: The corresponding OETF is simply the inverse function. The parameters defined by this class form a valid transfer
 function only if all the following conditions are met: No parameter is a  Double#isNaN(double) \(d\) is in the range \([0..1]\) The function is not constant The function is positive and increasing"
android,graphics,HardwareRenderer.FrameRenderRequest,4,"Sets the parameters that can be used to control a render request for a
  HardwareRenderer . This is not thread-safe and must not be held on to for longer
 than a single frame request."
android,graphics,ImageDecoder,32,"A class for converting encoded images (like  PNG   JPEG 
   WEBP   GIF  or  HEIF ) into  Drawable  or
   Bitmap  objects.

   To use it first create a  Source  using one of the
   createSource  overloads. For example to decode from a  File  call
   createSource(java.io.File)  and pass the result to  decodeDrawable(android.graphics.ImageDecoder.Source) 
  or  decodeBitmap(android.graphics.ImageDecoder.Source) :

   
  File file = new File(...);
  ImageDecoder.Source source = ImageDecoder.createSource(file);
  Drawable drawable = ImageDecoder.decodeDrawable(source);
   To change the default settings pass the  Source  and an
   OnHeaderDecodedListener  to
   decodeDrawable(android.graphics.ImageDecoder.Source android.graphics.ImageDecoder.OnHeaderDecodedListener)  or
   decodeBitmap(android.graphics.ImageDecoder.Source android.graphics.ImageDecoder.OnHeaderDecodedListener) . For example to
  create a sampled image with half the width and height of the original image
  call  setTargetSampleSize(2)  inside
   OnHeaderDecodedListener#onHeaderDecoded :

   
  OnHeaderDecodedListener listener = new OnHeaderDecodedListener() {
      public void onHeaderDecoded(ImageDecoder decoder ImageInfo info Source source) {
          decoder.setTargetSampleSize(2);
      }
  };
  Drawable drawable = ImageDecoder.decodeDrawable(source listener);
   The  ImageInfo  contains information about the encoded image like
  its width and height and the  Source  can be used to match to a particular
   Source  if a single  OnHeaderDecodedListener 
  is used with multiple  Source  objects.

   The  OnHeaderDecodedListener  can also be implemented
  as a lambda:

   
  Drawable drawable = ImageDecoder.decodeDrawable(source (decoder info src) -> {
      decoder.setTargetSampleSize(2);
  });
   If the encoded image is an animated  GIF  or  WEBP 
   decodeDrawable  will return an  AnimatedImageDrawable . To
  start its animation call  AnimatedImageDrawable#start :

   
  Drawable drawable = ImageDecoder.decodeDrawable(source);
  if (drawable instanceof AnimatedImageDrawable) {
      ((AnimatedImageDrawable) drawable).start();
  }
   By default a  Bitmap  created by  ImageDecoder  (including
  one that is inside a  Drawable ) will be immutable (i.e.
   Bitmap#isMutable  returns  false ) and it
  will typically have  Config Bitmap.Config#HARDWARE . Although
  these properties can be changed with  setMutableRequired(true) 
  (which is only compatible with  decodeBitmap(android.graphics.ImageDecoder.Source)  and
   decodeBitmap(android.graphics.ImageDecoder.Source android.graphics.ImageDecoder.OnHeaderDecodedListener) ) and  setAllocator(int) 
  it is also possible to apply custom effects regardless of the mutability of
  the final returned object by passing a  PostProcessor  to
   setPostProcessor . A  PostProcessor  can also be a lambda:

   
  Drawable drawable = ImageDecoder.decodeDrawable(source (decoder info src) -> {
      decoder.setPostProcessor((canvas) -> {
              // This will create rounded corners.
              Path path = new Path();
              path.setFillType(Path.FillType.INVERSE_EVEN_ODD);
              int width = canvas.getWidth();
              int height = canvas.getHeight();
              path.addRoundRect(0 0 width height 20 20 Path.Direction.CW);
              Paint paint = new Paint();
              paint.setAntiAlias(true);
              paint.setColor(Color.TRANSPARENT);
              paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC));
              canvas.drawPath(path paint);
              return PixelFormat.TRANSLUCENT;
      });
  });
   If the encoded image is incomplete or contains an error or if an
   Exception  occurs during decoding a  DecodeException 
  will be thrown. In some cases the  ImageDecoder  may have decoded part of
  the image. In order to display the partial image an
   OnPartialImageListener  must be passed to
   setOnPartialImageListener . For example:

   
  Drawable drawable = ImageDecoder.decodeDrawable(source (decoder info src) -> {
      decoder.setOnPartialImageListener((DecodeException e) -> {
              // Returning true indicates to create a Drawable or Bitmap even
              // if the whole image could not be decoded. Any remaining lines
              // will be blank.
              return true;
      });
  });"
android,graphics,Path,46,"The Path class encapsulates compound (multiple contour) geometric paths
 consisting of straight line segments quadratic curves and cubic curves.
 It can be drawn with canvas.drawPath(path paint) either filled or stroked
 (based on the paint's Style) or it can be used for clipping or to draw
 text on a path."
android,graphics,SweepGradient,0,
android,graphics,Canvas,104,"The Canvas class holds the ""draw"" calls. To draw something you need
 4 basic components: A Bitmap to hold the pixels a Canvas to host
 the draw calls (writing into the bitmap) a drawing primitive (e.g. Rect
 Path text Bitmap) and a paint (to describe the colors and styles for the
 drawing)."
android,graphics,EmbossMaskFilter,0,
android,graphics,Movie,11,
android,graphics,NinePatch,14,"The NinePatch class permits drawing a bitmap in nine or more sections.
 Essentially it allows the creation of custom graphics that will scale the
 way that you define when content added within the image exceeds the normal
 bounds of the graphic. For a thorough explanation of a NinePatch image
 read the discussion in the
  2D
 Graphics  document.
  
 The  Draw 9-Patch 
 tool offers an extremely handy way to create your NinePatch images
 using a WYSIWYG graphics editor."
android,graphics,PathDashPathEffect,0,
android,graphics,Picture,7,"A Picture records drawing calls (via the canvas returned by beginRecording)
 and can then play them back into Canvas (via  Picture#draw(Canvas)  or
  Canvas#drawPicture(Picture) ).For most content (e.g. text lines rectangles)
 drawing a sequence from a picture can be faster than the equivalent API
 calls since the picture performs its playback without incurring any
 method-call overhead.

  Note:  Prior to API level 23 a picture cannot
 be replayed on a hardware accelerated canvas."
android,graphics,PixelFormat,2,
android,graphics,RadialGradient,0,
android,graphics,Typeface.CustomFallbackBuilder,5,"A builder class for creating new Typeface instance.

 There are two font fallback mechanisms custom font fallback and system font fallback.
 The custom font fallback is a simple ordered list. The text renderer tries to see if it can
 render a character with the first font and if that font does not support the character try
 next one and so on. It will keep trying until end of the custom fallback chain. The maximum
 length of the custom fallback chain is 64.
 The system font fallback is a system pre-defined fallback chain. The system fallback is
 processed only when no matching font is found in the custom font fallback.

  
 Examples
 1) Create Typeface from single ttf file.
  
 Font font = new Font.Builder(""your_font_file.ttf"").build();
 FontFamily family = new FontFamily.Builder(font).build();
 Typeface typeface = new Typeface.CustomFallbackBuilder(family).build();
  
 Font regularFont = new Font.Builder(""regular.ttf"").build();
 Font boldFont = new Font.Builder(""bold.ttf"").build();
 FontFamily family = new FontFamily.Builder(regularFont)
     .addFont(boldFont).build();
 Typeface typeface = new Typeface.CustomFallbackBuilder(family)
     .setWeight(Font.FONT_WEIGHT_BOLD)  // Set bold style as the default style.
                                        // If the font family doesn't have bold style font
                                        // system will select the closest font.
     .build();
  
 Font font = new Font.Builder(""your_font_file.ttf"").build();
 FontFamily family = new FontFamily.Builder(font).build();
 Typeface typeface = new Typeface.CustomFallbackBuilder(family)
     .setSystemFallback(""serif"")  // Set serif font family as the fallback.
     .build();
  
 Font font = new Font.Builder(""English.ttf"").build();
 FontFamily family = new FontFamily.Builder(font).build();

 Font fallbackFont = new Font.Builder(""Arabic.ttf"").build();
 FontFamily fallbackFamily = new FontFamily.Builder(fallbackFont).build();
 Typeface typeface = new Typeface.CustomFallbackBuilder(family)
     .addCustomFallback(fallbackFamily)  // Specify fallback family.
     .setSystemFallback(""serif"")  // Set serif font family as the fallback.
     .build();"
android,graphics,DrawFilter,0,"A DrawFilter subclass can be installed in a Canvas. When it is present it
 can modify the paint that is used to draw (temporarily). With this a filter
 can disable/enable antialiasing or change the color for everything this is
 drawn."
android,graphics,Insets,11,"An Insets instance holds four integer offsets which describe changes to the four
 edges of a Rectangle. By convention positive values move edges towards the
 centre of the rectangle.
  
 Insets are immutable so may be treated as values."
android,graphics,Outline,16,"Defines a simple shape used for bounding graphical regions.
  
 Can be computed for a View or computed by a Drawable to drive the shape of
 shadows cast by a View or to clip the contents of the View."
android,graphics,PointF,13,PointF holds two float coordinates
android,graphics,PorterDuff,0,"This class contains the list of alpha compositing and blending modes
 that can be passed to  PorterDuffXfermode  a specialized implementation
 of  Paint 's  Paint#setXfermode(Xfermode) .
 All the available modes can be found in the  Mode  enum. BlendMode"
android,graphics,PorterDuffXfermode,0,"Specialized implementation of  Paint 's
  Paint#setXfermode(Xfermode) . Refer to the
 documentation of the  PorterDuff.Mode  enum for more
 information on the available alpha compositing and blending modes."
android,graphics,RectF,33,"RectF holds four float coordinates for a rectangle. The rectangle is
 represented by the coordinates of its 4 edges (left top right bottom).
 These fields can be accessed directly. Use width() and height() to retrieve
 the rectangle's width and height. Note: most methods do not check to see that
 the coordinates are sorted correctly (i.e. left <= right and top <= bottom)."
android,graphics,Region,31,
android,graphics,Xfermode,0,"Xfermode is the base class for objects that are called to implement custom
 ""transfer-modes"" in the drawing pipeline. The static function Create(Modes)
 can be called to return an instance of any of the predefined subclasses as
 specified in the Modes enum. When an Xfermode is assigned to an Paint then
 objects drawn with that paint have the xfermode applied."
android,location,Address,43,"A class representing an Address i.e a set of Strings describing a location.

 The address format is a simplified version of xAL (eXtensible Address Language)
 http://www.oasis-open.org/committees/ciq/ciq.html#6"
android,location,Criteria,23,"A class indicating the application criteria for selecting a
 location provider. Providers may be ordered according to accuracy
 power usage ability to report altitude speed bearing and monetary
 cost."
android,location,Geocoder,4,"A class for handling geocoding and reverse geocoding.  Geocoding is
 the process of transforming a street address or other description
 of a location into a (latitude longitude) coordinate.  Reverse
 geocoding is the process of transforming a (latitude longitude)
 coordinate into a (partial) address.  The amount of detail in a
 reverse geocoded location description may vary for example one
 might contain the full street address of the closest building while
 another might contain only a city name and postal code.

 The Geocoder class requires a backend service that is not included in
 the core android framework.  The Geocoder query methods will return an
 empty list if there no backend service in the platform.  Use the
 isPresent() method to determine whether a Geocoder implementation
 exists."
android,location,LocationManager,47,"This class provides access to the system location services.  These
 services allow applications to obtain periodic updates of the
 device's geographical location or to fire an application-specified
  Intent  when the device enters the proximity of a given
 geographical location.

  Unless noted all Location API methods require
 the  Manifest.permission.ACCESS_COARSE_LOCATION  or
  Manifest.permission.ACCESS_FINE_LOCATION  permissions.
 If your application only has the coarse permission then it will not have
 access to the GPS or passive location providers. Other providers will still
 return location results but the update rate will be throttled and the exact
 location will be obfuscated to a coarse level of accuracy.
 
  
 Requires the  PackageManager#FEATURE_LOCATION  feature which can be detected using  PackageManager.hasSystemFeature(String) ."
android,location,GnssClock,23,"A class containing a GPS clock timestamp.

  It represents a measurement of the GPS receiver's clock."
android,location,GnssMeasurement,30,A class representing a GNSS satellite measurement containing raw and computed information.
android,location,GnssMeasurementsEvent,5,"A class implementing a container for data associated with a measurement event.
 Events are delivered to registered instances of  Callback ."
android,location,GnssMeasurementsEvent.Callback,2,"Used for receiving GNSS satellite measurements from the GNSS engine.
 Each measurement contains raw and computed data identifying a satellite.
 You can implement this interface and call
  LocationManager#registerGnssMeasurementsCallback ."
android,location,GnssNavigationMessage,9,A class containing a GNSS satellite Navigation Message.
android,location,GnssNavigationMessage.Callback,2,"Used for receiving GNSS satellite Navigation Messages from the GNSS engine.

  You can implement this interface and call
  LocationManager#registerGnssNavigationMessageCallback ."
android,location,GnssStatus,11,"This class represents the current state of the GNSS engine.
 This class is used in conjunction with the  GnssStatus.Callback ."
android,location,GnssStatus.Callback,4,Used for receiving notifications when GNSS events happen.
android,location,GpsSatellite,7,"This class represents the current state of a GPS satellite.

 This class is used in conjunction with the  GpsStatus  class."
android,location,SettingInjectorService,6,"Dynamically specifies the summary (subtitle) and enabled status of a preference injected into
 the list of app settings displayed by the system settings app
  SettingInjectorService 
     <service android:name=""com.example.android.injector.MyInjectorService"" >
         <intent-filter>
             <action android:name=""android.location.SettingInjectorService"" />
         </intent-filter>

         <meta-data
             android:name=""android.location.SettingInjectorService""
             android:resource=""@xml/my_injected_location_setting"" />
     </service>
  
     <injected-location-setting xmlns:android=""http://schemas.android.com/apk/res/android""
         android:title=""@string/injected_setting_title""
         android:icon=""@drawable/ic_acme_corp""
         android:settingsActivity=""com.example.android.injector.MySettingActivity""
     />
  title: The  Preference.getTitle()  value. The title should make
 it clear which apps are affected by the setting typically by including the name of the
 developer. For example ""Acme Corp. ads preferences.""  icon: The  Preference.getIcon()  value. Typically this will be a
 generic icon for the developer rather than the icon for an individual app. settingsActivity: the activity which is launched to allow the user to modify the setting
 value.  The activity must be in the same package as the subclass of
  SettingInjectorService . The activity should use your own branding to help emphasize
 to the user that it is not part of the system settings. Application.onCreate() onGetSummary() onGetEnabled() onGetSummary() settingsActivity"
android,location,GpsStatus,3,"This class represents the current state of the GPS engine.

  This class is used in conjunction with the  Listener  interface."
android,location,Location,52,"A data class representing a geographic location.

  A location can consist of a latitude longitude timestamp
 and other information such as bearing altitude and velocity.

  All locations generated by the  LocationManager  are
 guaranteed to have a valid latitude longitude and timestamp
 (both UTC time and elapsed real-time since boot) all other
 parameters are optional."
android,location,LocationProvider,11,"An abstract superclass for location providers.  A location provider
 provides periodic reports on the geographical location of the
 device.

   Each provider has a set of criteria under which it may be used;
 for example some providers require GPS hardware and visibility to
 a number of satellites; others require the use of the cellular
 radio or access to a specific carrier's network or to the
 internet.  They may also have different battery consumption
 characteristics or monetary costs to the user.  The  Criteria  class allows providers to be selected based on
 user-specified criteria."
android,media.browse,MediaBrowser,12,"Browses media content offered by a link MediaBrowserService.
  
 This object is not thread-safe. All calls should happen on the thread on which the browser
 was constructed.
  Standard Extra Data These are the current standard fields that can be used as extra data via
  subscribe(java.lang.String android.os.Bundle android.media.browse.MediaBrowser.SubscriptionCallback) 
  unsubscribe(java.lang.String android.media.browse.MediaBrowser.SubscriptionCallback)  and
  SubscriptionCallback#onChildrenLoaded(String List Bundle) .

  EXTRA_PAGE EXTRA_PAGE_SIZE"
android,media.browse,MediaBrowser.ConnectionCallback,3,Callbacks for connection related events.
android,media.browse,MediaBrowser.ItemCallback,2,Callback for receiving the result of  MediaBrowser.getItem(String MediaBrowser.ItemCallback) .
android,media.browse,MediaBrowser.MediaItem,8,"A class with information on a single media item for use in browsing/searching media.
 MediaItems are application dependent so we cannot guarantee that they contain the
 right values."
android,media.browse,MediaBrowser.SubscriptionCallback,4,Callbacks for subscription related events.
android,icu.util,CopticCalendar,3,"Implement the Coptic calendar system.
  
 CopticCalendar usually should be instantiated using
  Calendar.getInstance(ULocale)  passing in a  ULocale 
 with the tag  ""@calendar=coptic"" ."
android,icu.util,EthiopicCalendar,4,"Implement the Ethiopic calendar system.
  
 EthiopicCalendar usually should be instantiated using
  Calendar.getInstance(ULocale)  passing in a  ULocale 
 with the tag  ""@calendar=ethiopic"" ."
android,icu.util,HebrewCalendar,9,"HebrewCalendar  is a subclass of  Calendar 
 that that implements the traditional Hebrew calendar.
 This is the civil calendar in Israel and the liturgical calendar
 of the Jewish faith worldwide.
  
 The Hebrew calendar is lunisolar and thus has a number of interesting
 properties that distinguish it from the Gregorian.  Months start
 on the day of (an arithmetic approximation of) each new moon.  Since the
 solar year (approximately 365.24 days) is not an even multiple of
 the lunar month (approximately 29.53 days) an extra ""leap month"" is
 inserted in 7 out of every 19 years.  To make matters even more
 interesting the start of a year can be delayed by up to three days
 in order to prevent certain holidays from falling on the Sabbath and
 to prevent certain illegal year lengths.  Finally the lengths of certain
 months can vary depending on the number of days in the year.
  
 The leap month is known as ""Adar 1"" and is inserted between the
 months of Shevat and Adar in leap years.  Since the leap month does
 not come at the end of the year calculations involving
 month numbers are particularly complex.  Users of this class should
 make sure to use the  roll  and  add  methods
 rather than attempting to perform date arithmetic by manipulating
 the fields directly.
  Note:  In the traditional Hebrew calendar days start at sunset.
 However in order to keep the time fields in this class
 synchronized with those of the other calendars and with local clock time
 we treat days and months as beginning at midnight
 roughly 6 hours after the corresponding sunset.
  
 If you are interested in more information on the rules behind the Hebrew
 calendar see one of the following references:
  "" Calendrical Calculations ""
      by Nachum Dershowitz & Edward Reingold Cambridge University Press 1997 pages 85-91.

  Hebrew Calendar Science and Myths
       
      http://web.archive.org/web/20090423084613/http://www.geocities.com/Athens/1584/ The Calendar FAQ
       
      http://www.faqs.org/faqs/calendars/faq/ 
 This class should not be subclassed. 
 HebrewCalendar usually should be instantiated using
  Calendar.getInstance(ULocale)  passing in a  ULocale 
 with the tag  ""@calendar=hebrew"" ."
android,icu.util,MeasureUnit,8,"A unit such as length mass volume currency etc.  A unit is
 coupled with a numeric amount to produce a Measure. MeasureUnit objects are immutable.
 All subclasses must guarantee that. (However subclassing is discouraged.)"
android,icu.util,BuddhistCalendar,5,"BuddhistCalendar  is a subclass of  GregorianCalendar 
 that numbers years since the birth of the Buddha.  This is the civil calendar
 in some predominantly Buddhist countries such as Thailand and it is used for
 religious purposes elsewhere.
  
 The Buddhist calendar is identical to the Gregorian calendar in all respects
 except for the year and era.  Years are numbered since the birth of the
 Buddha in 543 BC (Gregorian) so that 1 AD (Gregorian) is equivalent to 544
 BE (Buddhist Era) and 1998 AD is 2541 BE.
  
 The Buddhist Calendar has only one allowable era:  BE .  If the
 calendar is not in lenient mode (see  setLenient ) dates before
 1/1/1 BE are rejected with an  IllegalArgumentException .
  
 This class should not be subclassed. 
 BuddhistCalendar usually should be instantiated using
  Calendar.getInstance(ULocale)  passing in a  ULocale 
 with the tag  ""@calendar=buddhist"" ."
android,icu.util,Calendar.WeekData,3,Simple immutable struct-like class for access to the CLDR weekend data.
android,icu.util,Currency,28,"A class encapsulating a currency as defined by ISO 4217.  A
  Currency  object can be created given a  Locale  or
 given an ISO 4217 code.  Once created the  Currency  object
 can return various data necessary to its proper display:

  A display symbol for a specific locale
  The number of fraction digits to display
  A rounding increment
  DecimalFormat Note: This class deliberately resembles
  java.util.Currency  but it has a completely independent
 implementation and adds features not present in the JDK."
android,icu.util,GregorianCalendar,16,"[icu enhancement]  ICU's replacement for  GregorianCalendar .Â Methods fields and other functionality specific to ICU are labeled ' [icu] '.

  GregorianCalendar  is a concrete subclass of
  Calendar 
 and provides the standard calendar used by most of the world.

  The standard (Gregorian) calendar has 2 eras BC and AD.

  This implementation handles a single discontinuity which corresponds by
 default to the date the Gregorian calendar was instituted (October 15 1582
 in some countries later in others).  The cutover date may be changed by the
 caller by calling  setGregorianChange() .

  Historically in those countries which adopted the Gregorian calendar first
 October 4 1582 was thus followed by October 15 1582. This calendar models
 this correctly.  Before the Gregorian cutover  GregorianCalendar 
 implements the Julian calendar.  The only difference between the Gregorian
 and the Julian calendar is the leap year rule. The Julian calendar specifies
 leap years every four years whereas the Gregorian calendar omits century
 years which are not divisible by 400.

  GregorianCalendar  implements  proleptic  Gregorian and
 Julian calendars. That is dates are computed by extrapolating the current
 rules indefinitely far backward and forward in time. As a result
  GregorianCalendar  may be used for all years to generate
 meaningful and consistent results. However dates obtained using
  GregorianCalendar  are historically accurate only from March 1 4
 AD onward when modern Julian calendar rules were adopted.  Before this date
 leap year rules were applied irregularly and before 45 BC the Julian
 calendar did not even exist.

  Prior to the institution of the Gregorian calendar New Year's Day was
 March 25. To avoid confusion this calendar always uses January 1. A manual
 adjustment may be made if desired for dates that are prior to the Gregorian
 changeover and which fall between January 1 and March 24.

  Values calculated for the  WEEK_OF_YEAR  field range from 1 to
 53.  Week 1 for a year is the earliest seven day period starting on
  getFirstDayOfWeek()  that contains at least
  getMinimalDaysInFirstWeek()  days from that year.  It thus
 depends on the values of  getMinimalDaysInFirstWeek() 
  getFirstDayOfWeek()  and the day of the week of January 1.
 Weeks between week 1 of one year and week 1 of the following year are
 numbered sequentially from 2 to 52 or 53 (as needed).
 
  For example January 1 1998 was a Thursday.  If
  getFirstDayOfWeek()  is  MONDAY  and
  getMinimalDaysInFirstWeek()  is 4 (these are the values
 reflecting ISO 8601 and many national standards) then week 1 of 1998 starts
 on December 29 1997 and ends on January 4 1998.  If however
  getFirstDayOfWeek()  is  SUNDAY  then week 1 of 1998
 starts on January 4 1998 and ends on January 10 1998; the first three days
 of 1998 then are part of week 53 of 1997.

  Values calculated for the  WEEK_OF_MONTH  field range from 0 or
 1 to 4 or 5.  Week 1 of a month (the days with  WEEK_OF_MONTH =
 1 ) is the earliest set of at least
  getMinimalDaysInFirstWeek()  contiguous days in that month
 ending on the day before  getFirstDayOfWeek() .  Unlike
 week 1 of a year week 1 of a month may be shorter than 7 days need
 not start on  getFirstDayOfWeek()  and will not include days of
 the previous month.  Days of a month before week 1 have a
  WEEK_OF_MONTH  of 0.

  For example if  getFirstDayOfWeek()  is  SUNDAY 
 and  getMinimalDaysInFirstWeek()  is 4 then the first week of
 January 1998 is Sunday January 4 through Saturday January 10.  These days
 have a  WEEK_OF_MONTH  of 1.  Thursday January 1 through
 Saturday January 3 have a  WEEK_OF_MONTH  of 0.  If
  getMinimalDaysInFirstWeek()  is changed to 3 then January 1
 through January 3 have a  WEEK_OF_MONTH  of 1.

  Example: 
 // get the supported ids for GMT-08:00 (Pacific Standard Time)
 String[] ids = TimeZone.getAvailableIDs(-8 * 60 * 60 * 1000);
 // if no ids were returned something is wrong. get out.
 if (ids.length == 0)
     System.exit(0);

  // begin output
 System.out.println(""Current Time"");

 // create a Pacific Standard Time time zone
 SimpleTimeZone pdt = new SimpleTimeZone(-8 * 60 * 60 * 1000 ids[0]);

 // set up rules for daylight savings time
 pdt.setStartRule(Calendar.MARCH 2 Calendar.SUNDAY 2 * 60 * 60 * 1000);
 pdt.setEndRule(Calendar.NOVEMBER 1 Calendar.SUNDAY 2 * 60 * 60 * 1000);

 // create a GregorianCalendar with the Pacific Daylight time zone
 // and the current date and time
 Calendar calendar = new GregorianCalendar(pdt);
 Date trialTime = new Date();
 calendar.setTime(trialTime);

 // print out a bunch of interesting things
 System.out.println(""ERA: "" + calendar.get(Calendar.ERA));
 System.out.println(""YEAR: "" + calendar.get(Calendar.YEAR));
 System.out.println(""MONTH: "" + calendar.get(Calendar.MONTH));
 System.out.println(""WEEK_OF_YEAR: "" + calendar.get(Calendar.WEEK_OF_YEAR));
 System.out.println(""WEEK_OF_MONTH: "" + calendar.get(Calendar.WEEK_OF_MONTH));
 System.out.println(""DATE: "" + calendar.get(Calendar.DATE));
 System.out.println(""DAY_OF_MONTH: "" + calendar.get(Calendar.DAY_OF_MONTH));
 System.out.println(""DAY_OF_YEAR: "" + calendar.get(Calendar.DAY_OF_YEAR));
 System.out.println(""DAY_OF_WEEK: "" + calendar.get(Calendar.DAY_OF_WEEK));
 System.out.println(""DAY_OF_WEEK_IN_MONTH: ""
                    + calendar.get(Calendar.DAY_OF_WEEK_IN_MONTH));
 System.out.println(""AM_PM: "" + calendar.get(Calendar.AM_PM));
 System.out.println(""HOUR: "" + calendar.get(Calendar.HOUR));
 System.out.println(""HOUR_OF_DAY: "" + calendar.get(Calendar.HOUR_OF_DAY));
 System.out.println(""MINUTE: "" + calendar.get(Calendar.MINUTE));
 System.out.println(""SECOND: "" + calendar.get(Calendar.SECOND));
 System.out.println(""MILLISECOND: "" + calendar.get(Calendar.MILLISECOND));
 System.out.println(""ZONE_OFFSET: ""
                    + (calendar.get(Calendar.ZONE_OFFSET)/(60*60*1000)));
 System.out.println(""DST_OFFSET: ""
                    + (calendar.get(Calendar.DST_OFFSET)/(60*60*1000)));
 
 System.out.println(""Current Time with hour reset to 3"");
 calendar.clear(Calendar.HOUR_OF_DAY); // so doesn't override
 calendar.set(Calendar.HOUR 3);
 System.out.println(""ERA: "" + calendar.get(Calendar.ERA));
 System.out.println(""YEAR: "" + calendar.get(Calendar.YEAR));
 System.out.println(""MONTH: "" + calendar.get(Calendar.MONTH));
 System.out.println(""WEEK_OF_YEAR: "" + calendar.get(Calendar.WEEK_OF_YEAR));
 System.out.println(""WEEK_OF_MONTH: "" + calendar.get(Calendar.WEEK_OF_MONTH));
 System.out.println(""DATE: "" + calendar.get(Calendar.DATE));
 System.out.println(""DAY_OF_MONTH: "" + calendar.get(Calendar.DAY_OF_MONTH));
 System.out.println(""DAY_OF_YEAR: "" + calendar.get(Calendar.DAY_OF_YEAR));
 System.out.println(""DAY_OF_WEEK: "" + calendar.get(Calendar.DAY_OF_WEEK));
 System.out.println(""DAY_OF_WEEK_IN_MONTH: ""
                    + calendar.get(Calendar.DAY_OF_WEEK_IN_MONTH));
 System.out.println(""AM_PM: "" + calendar.get(Calendar.AM_PM));
 System.out.println(""HOUR: "" + calendar.get(Calendar.HOUR));
 System.out.println(""HOUR_OF_DAY: "" + calendar.get(Calendar.HOUR_OF_DAY));
 System.out.println(""MINUTE: "" + calendar.get(Calendar.MINUTE));
 System.out.println(""SECOND: "" + calendar.get(Calendar.SECOND));
 System.out.println(""MILLISECOND: "" + calendar.get(Calendar.MILLISECOND));
 System.out.println(""ZONE_OFFSET: ""
        + (calendar.get(Calendar.ZONE_OFFSET)/(60*60*1000))); // in hours
 System.out.println(""DST_OFFSET: ""
        + (calendar.get(Calendar.DST_OFFSET)/(60*60*1000))); // in hours 
 GregorianCalendar usually should be instantiated using
  Calendar.getInstance(ULocale)  passing in a  ULocale 
 with the tag  ""@calendar=gregorian"" ."
android,icu.util,IndianCalendar,7,"IndianCalendar  is a subclass of  GregorianCalendar 
 that numbers years since the birth of the Buddha.  This is the civil calendar
 which is accepted by government of India as Indian National Calendar.
 The two calendars most widely used in India today are the Vikrama calendar
 followed in North India and the Shalivahana or Saka calendar which is followed
 in South India and Maharashtra.
 
 A variant of the Shalivahana Calendar was reformed and standardized as the
 Indian National calendar in 1957.
  
 Some details of Indian National Calendar (to be implemented) :
 The Months
 Month          Length      Start date (Gregorian)
 =================================================
 1 Chaitra      30/31          March 22*
 2 Vaisakha     31             April 21
 3 Jyaistha     31             May 22
 4 Asadha       31             June 22
 5 Sravana      31             July 23
 6 Bhadra       31             August 23
 7 Asvina       30             September 23
 8 Kartika      30             October 23
 9 Agrahayana   30             November 22
 10 Pausa       30             December 22
 11 Magha       30             January 21
 12 Phalguna    30             February 20
 
 In leap years Chaitra has 31 days and starts on March 21 instead.
 The leap years of Gregorian calendar and Indian National Calendar are in synchornization.
 So When its a leap year in Gregorian calendar then Chaitra has 31 days.

 The Years
 Years are counted in the Saka Era which starts its year 0 in 78AD (by gregorian calendar).
 So for eg. 9th June 2006 by Gregorian Calendar is same as 19th of Jyaistha in 1928 of Saka
 era by Indian National Calendar.
  
 The Indian Calendar has only one allowable era:  Saka Era .  If the
 calendar is not in lenient mode (see  setLenient ) dates before
 1/1/1 Saka Era are rejected with an  IllegalArgumentException .
  
 This class should not be subclassed. 
 IndianCalendar usually should be instantiated using
  Calendar.getInstance(ULocale)  passing in a  ULocale 
 with the tag  ""@calendar=Indian"" ."
android,icu.util,IslamicCalendar,9,"IslamicCalendar  is a subclass of  Calendar 
 that that implements the Islamic civil and religious calendars.  It
 is used as the civil calendar in most of the Arab world and the
 liturgical calendar of the Islamic faith worldwide.  This calendar
 is also known as the ""Hijri"" calendar since it starts at the time
 of Mohammed's emigration (or ""hijra"") to Medinah on Thursday
 July 15 622 AD (Julian).
  
 The Islamic calendar is strictly lunar and thus an Islamic year of twelve
 lunar months does not correspond to the solar year used by most other
 calendar systems including the Gregorian.  An Islamic year is on average
 about 354 days long so each successive Islamic year starts about 11 days
 earlier in the corresponding Gregorian year.
  
 Each month of the calendar starts when the new moon's crescent is visible
 at sunset.  However in order to keep the time fields in this class
 synchronized with those of the other calendars and with local clock time
 we treat days and months as beginning at midnight
 roughly 6 hours after the corresponding sunset.
  
 There are three main variants of the Islamic calendar in existence.  The first
 is the  civil  calendar which uses a fixed cycle of alternating 29-
 and 30-day months with a leap day added to the last month of 11 out of
 every 30 years.  This calendar is easily calculated and thus predictable in
 advance so it is used as the civil calendar in a number of Arab countries.
 This is the default behavior of a newly-created  IslamicCalendar 
 object.
  
 The Islamic  religious  calendar and Saudi Arabia's  Umm al-Qura 
 calendar however are based on the  observation  of the crescent moon.
 It is thus affected by the position at which the
 observations are made seasonal variations in the time of sunset the
 eccentricities of the moon's orbit and even the weather at the observation
 site.  This makes it impossible to calculate in advance and it causes the
 start of a month in the religious calendar to differ from the civil calendar
 by up to three days.
  
 Using astronomical calculations for the position of the sun and moon the
 moon's illumination and other factors it is possible to determine the start
 of a lunar month with a fairly high degree of certainty.  However these
 calculations are extremely complicated and thus slow so most algorithms
 including the one used here are only approximations of the true astronomical
 calculations.  At present the approximations used in this class are fairly
 simplistic; they will be improved in later versions of the code.
  
 Like the Islamic religious calendar  Umm al-Qura  is also based
 on the sighting method of the crescent moon but is standardized by Saudi Arabia.
  
 The fixed-cycle  civil  calendar is used.
  
 This class should not be subclassed. 
 IslamicCalendar usually should be instantiated using
  Calendar.getInstance(ULocale)  passing in a  ULocale 
 with the tag  ""@calendar=islamic""  or  ""@calendar=islamic-civil"" 
 or  ""@calendar=islamic-umalqura"" ."
android,icu.util,Calendar,112,"[icu enhancement]  ICU's replacement for  Calendar .Â Methods fields and other functionality specific to ICU are labeled ' [icu] '.

  Calendar  is an abstract base class for converting between
 a  Date  object and a set of integer fields such as
  YEAR   MONTH   DAY   HOUR 
 and so on. (A  Date  object represents a specific instant in
 time with millisecond precision. See
  Date 
 for information about the  Date  class.)

  Subclasses of  Calendar  interpret a  Date 
 according to the rules of a specific calendar system.  ICU4J contains
 several subclasses implementing different international calendar systems.

  
 Like other locale-sensitive classes  Calendar  provides a
 class method  getInstance  for getting a generally useful
 object of this type.  Calendar 's  getInstance  method
 returns a calendar of a type appropriate to the locale whose
 time fields have been initialized with the current date and time:
  Calendar rightNow = Calendar.getInstance() When a  ULocale  is used by  getInstance  its
 ' calendar ' tag and value are retrieved if present.  If a recognized
 value is supplied a calendar is provided and configured as appropriate.
 Currently recognized tags are ""buddhist"" ""chinese"" ""coptic"" ""ethiopic""
 ""gregorian"" ""hebrew"" ""islamic"" ""islamic-civil"" ""japanese"" and ""roc"".  For
 example:  Calendar cal = Calendar.getInstance(new ULocale(""en_US@calendar=japanese"")); A  Calendar  object can produce all the time field values
 needed to implement the date-time formatting for a particular language and
 calendar style (for example Japanese-Gregorian Japanese-Traditional).
  Calendar  defines the range of values returned by certain fields
 as well as their meaning.  For example the first month of the year has value
  MONTH  ==  JANUARY  for all calendars.  Other values
 are defined by the concrete subclass such as  ERA  and
  YEAR .  See individual field documentation and subclass
 documentation for details.

  When a  Calendar  is  lenient  it accepts a wider range
 of field values than it produces.  For example a lenient
  GregorianCalendar  interprets  MONTH  ==
  JANUARY   DAY_OF_MONTH  == 32 as February 1.  A
 non-lenient  GregorianCalendar  throws an exception when given
 out-of-range field settings.  When calendars recompute field values for
 return by  get()  they normalize them.  For example a
  GregorianCalendar  always produces  DAY_OF_MONTH 
 values between 1 and the length of the month.

  Calendar  defines a locale-specific seven day week using two
 parameters: the first day of the week and the minimal days in first week
 (from 1 to 7).  These numbers are taken from the locale resource data when a
  Calendar  is constructed.  They may also be specified explicitly
 through the API.

  When setting or getting the  WEEK_OF_MONTH  or
  WEEK_OF_YEAR  fields  Calendar  must determine the
 first week of the month or year as a reference point.  The first week of a
 month or year is defined as the earliest seven day period beginning on
  getFirstDayOfWeek()  and containing at least
  getMinimalDaysInFirstWeek()  days of that month or year.  Weeks
 numbered ... -1 0 precede the first week; weeks numbered 2 3... follow
 it.  Note that the normalized numbering returned by  get()  may be
 different.  For example a specific  Calendar  subclass may
 designate the week before week 1 of a year as week  n  of the previous
 year.

   When computing a  Date  from time fields some special
 circumstances may arise: there may be insufficient information to compute the
  Date  (such as only year and month but no day in the month)
 there may be inconsistent information (such as ""Tuesday July 15 1996"" --
 July 15 1996 is actually a Monday) or the input time might be ambiguous
 because of time zone transition.

  Insufficient information.  The calendar will use default
 information to specify the missing fields. This may vary by calendar; for
 the Gregorian calendar the default for a field is the same as that of the
 start of the epoch: i.e. YEAR = 1970 MONTH = JANUARY DATE = 1 etc.

  Inconsistent information.  If fields conflict the calendar
 will give preference to fields set more recently. For example when
 determining the day the calendar will look for one of the following
 combinations of fields.  The most recent combination as determined by the
 most recently set single field will be used.

  
 MONTH + DAY_OF_MONTH
 MONTH + WEEK_OF_MONTH + DAY_OF_WEEK
 MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK
 DAY_OF_YEAR
 DAY_OF_WEEK + WEEK_OF_YEAR 
 HOUR_OF_DAY
 AM_PM + HOUR Ambiguous Wall Clock Time.  When time offset from UTC has
 changed it produces an ambiguous time slot around the transition. For example
 many US locations observe daylight saving time. On the date switching to daylight
 saving time in US wall clock time jumps from 12:59 AM (standard) to 2:00 AM
 (daylight). Therefore wall clock time from 1:00 AM to 1:59 AM do not exist on
 the date. When the input wall time fall into this missing time slot the ICU
 Calendar resolves the time using the UTC offset before the transition by default.
 In this example 1:30 AM is interpreted as 1:30 AM standard time (non-exist)
 so the final result will be 2:30 AM daylight time.

  On the date switching back to standard time wall clock time is moved back one
 hour at 2:00 AM. So wall clock time from 1:00 AM to 1:59 AM occur twice. In this
 case the ICU Calendar resolves the time using the UTC offset after the transition
 by default. For example 1:30 AM on the date is resolved as 1:30 AM standard time.

  Ambiguous wall clock time resolution behaviors can be customized by Calendar APIs
  setRepeatedWallTimeOption(int)  and  setSkippedWallTimeOption(int) .
 These methods are available in ICU 49 or later versions.

  Note:  for some non-Gregorian calendars different
 fields may be necessary for complete disambiguation. For example a full
 specification of the historial Arabic astronomical calendar requires year
 month day-of-month  and  day-of-week in some cases.

  Note:  There are certain possible ambiguities in
 interpretation of certain singular times which are resolved in the
 following ways:
   24:00:00 ""belongs"" to the following day. That is
          23:59 on Dec 31 1969 < 24:00 on Jan 1 1970 < 24:01:00 on Jan 1 1970

       Although historically not precise midnight also belongs to ""am""
          and noon belongs to ""pm"" so on the same day
          12:00 am (midnight) < 12:01 am and 12:00 pm (noon) < 12:01 pm
  The date or time format strings are not part of the definition of a
 calendar as those must be modifiable or overridable by the user at
 runtime. Use  DateFormat 
 to format dates.

  Field manipulation methods Calendar  fields can be changed using three methods:
  set()   add()  and  roll() . set(f value)  changes field
  f  to  value .  In addition it sets an
 internal member variable to indicate that field  f  has
 been changed. Although field  f  is changed immediately
 the calendar's milliseconds is not recomputed until the next call to
  get()   getTime()  or
  getTimeInMillis()  is made. Thus multiple calls to
  set()  do not trigger multiple unnecessary
 computations. As a result of changing a field using
  set()  other fields may also change depending on the
 field the field value and the calendar system. In addition
  get(f)  will not necessarily return  value 
 after the fields have been recomputed. The specifics are determined by
 the concrete calendar class. Example : Consider a  GregorianCalendar 
 originally set to August 31 1999. Calling  set(Calendar.MONTH
 Calendar.SEPTEMBER)  sets the calendar to September 31
 1999. This is a temporary internal representation that resolves to
 October 1 1999 if  getTime() is then called. However a
 call to  set(Calendar.DAY_OF_MONTH 30)  before the call to
  getTime()  sets the calendar to September 30 1999 since
 no recomputation occurs after  set()  itself. add(f delta)  adds  delta 
 to field  f .  This is equivalent to calling  set(f
 get(f) + delta)  with two adjustments: Add rule 1 . The value of field  f 
   after the call minus the value of field  f  before the
   call is  delta  modulo any overflow that has occurred in
   field  f . Overflow occurs when a field value exceeds its
   range and as a result the next larger field is incremented or
   decremented and the field value is adjusted back into its range. Add rule 2 . If a smaller field is expected to be
   invariant but Â  it is impossible for it to be equal to its
   prior value because of changes in its minimum or maximum after field
    f  is changed then its value is adjusted to be as close
   as possible to its expected value. A smaller field represents a
   smaller unit of time.  HOUR  is a smaller field than
    DAY_OF_MONTH . No adjustment is made to smaller fields
   that are not expected to be invariant. The calendar system
   determines what fields are expected to be invariant. In addition unlike  set()   add()  forces
 an immediate recomputation of the calendar's milliseconds and all
 fields. Example : Consider a  GregorianCalendar 
 originally set to August 31 1999. Calling  add(Calendar.MONTH
 13)  sets the calendar to September 30 2000.  Add rule
 1  sets the  MONTH  field to September since
 adding 13 months to August gives September of the next year. Since
  DAY_OF_MONTH  cannot be 31 in September in a
  GregorianCalendar   add rule 2  sets the
  DAY_OF_MONTH  to 30 the closest possible value. Although
 it is a smaller field  DAY_OF_WEEK  is not adjusted by
 rule 2 since it is expected to change when the month changes in a
  GregorianCalendar . roll(f delta)  adds
  delta  to field  f  without changing larger
 fields. This is equivalent to calling  add(f delta)  with
 the following adjustment: Roll rule . Larger fields are unchanged after the
   call. A larger field represents a larger unit of
   time.  DAY_OF_MONTH  is a larger field than
    HOUR . Example : Consider a  GregorianCalendar 
 originally set to August 31 1999. Calling  roll(Calendar.MONTH
 8)  sets the calendar to April 30  1999 .  Add
 rule 1 sets the  MONTH  field to April. Using a
  GregorianCalendar  the  DAY_OF_MONTH  cannot
 be 31 in the month April. Add rule 2 sets it to the closest possible
 value 30. Finally the  roll rule  maintains the
  YEAR  field value of 1999. Example : Consider a  GregorianCalendar 
 originally set to Sunday June 6 1999. Calling
  roll(Calendar.WEEK_OF_MONTH -1)  sets the calendar to
 Tuesday June 1 1999 whereas calling
  add(Calendar.WEEK_OF_MONTH -1)  sets the calendar to
 Sunday May 30 1999. This is because the roll rule imposes an
 additional constraint: The  MONTH  must not change when the
  WEEK_OF_MONTH  is rolled. Taken together with add rule 1
 the resultant date must be between Tuesday June 1 and Saturday June
 5. According to add rule 2 the  DAY_OF_WEEK  an invariant
 when changing the  WEEK_OF_MONTH  is set to Tuesday the
 closest possible value to Sunday (where Sunday is the first day of the
 week). Usage model . To motivate the behavior of
  add()  and  roll()  consider a user interface
 component with increment and decrement buttons for the month day and
 year and an underlying  GregorianCalendar . If the
 interface reads January 31 1999 and the user presses the month
 increment button what should it read? If the underlying
 implementation uses  set()  it might read March 3 1999. A
 better result would be February 28 1999. Furthermore if the user
 presses the month increment button again it should read March 31
 1999 not March 28 1999. By saving the original date and using either
  add()  or  roll()  depending on whether larger
 fields should be affected the user interface can behave as most users
 will intuitively expect. Note:  You should always use  roll  and  add  rather
 than attempting to perform arithmetic operations directly on the fields
 of a  Calendar .  It is quite possible for  Calendar  subclasses
 to have fields with non-linear behavior for example missing months
 or days during non-leap years.  The subclasses'  add  and  roll 
 methods will take this into account while simple arithmetic manipulations
 may give invalid results.

  Calendar Architecture in ICU4J Recently the implementation of  Calendar  has changed
 significantly in order to better support subclassing. The original
  Calendar  class was designed to support subclassing but
 it had only one implemented subclass  GregorianCalendar .
 With the implementation of several new calendar subclasses including
 the  BuddhistCalendar   ChineseCalendar 
  HebrewCalendar   IslamicCalendar  and
  JapaneseCalendar  the subclassing API has been reworked
 thoroughly. This section details the new subclassing API and other
 ways in which  android.icu.util.Calendar  differs from
  java.util.Calendar .
  Changes Overview of changes between the classic  Calendar 
 architecture and the new architecture.

  The  fields[]  array is  private  now
     instead of  protected .  Subclasses must access it
     using the methods  internalSet(int int)  and
      internalGet(int) .   Motivation:  Subclasses should
     not directly access data members. The  time  long word is  private  now
     instead of  protected .  Subclasses may access it using
     the method  internalGetTimeInMillis()  which does not
     provoke an update.  Motivation:  Subclasses should not
     directly access data members. The scope of responsibility of subclasses has been drastically
     reduced. As much functionality as possible is implemented in the
      Calendar  base class. As a result it is much easier
     to subclass  Calendar .  Motivation:  Subclasses
     should not have to reimplement common code. Certain behaviors are
     common across calendar systems: The definition and behavior of
     week-related fields and time fields the arithmetic
     ( add  and  roll ) behavior of many
     fields and the field validation system. The subclassing API has been completely redesigned. The  Calendar  base class contains some Gregorian
     calendar algorithmic support that subclasses can use (specifically
     in  handleComputeFields(int) ).  Subclasses can use the
     methods  getGregorianXxx()  to obtain precomputed
     values.  Motivation:  This is required by all
      Calendar  subclasses in order to implement consistent
     time zone behavior and Gregorian-derived systems can use the
     already computed data. The  FIELD_COUNT  constant has been removed. Use
      getFieldCount() .  In addition framework API has been
     added to allow subclasses to define additional fields.
      Motivation:  The number of fields is not constant across
     calendar systems. The range of handled dates has been narrowed from +/-
     ~300000000 years to +/- ~5000000 years. In practical terms
     this should not affect clients. However it does mean that client
     code cannot be guaranteed well-behaved results with dates such as
      Date(Long.MIN_VALUE)  or
      Date(Long.MAX_VALUE) . Instead the
      Calendar  protected constants should be used.
      Motivation:  With
     the addition of the  JULIAN_DAY  field Julian day
     numbers must be restricted to a 32-bit  int .  This
     restricts the overall supported range. Furthermore restricting
     the supported range simplifies the computations by removing
     special case code that was used to accomodate arithmetic overflow
     at millis near  Long.MIN_VALUE  and
      Long.MAX_VALUE . New fields are implemented:  JULIAN_DAY  defines
     single-field specification of the
     date.  MILLISECONDS_IN_DAY  defines a single-field
     specification of the wall time.  DOW_LOCAL  and
      YEAR_WOY  implement localized day-of-week and
     week-of-year behavior. Subclasses can access protected millisecond constants
   defined in  Calendar . New API has been added to support calendar-specific subclasses
     of  DateFormat . Several subclasses have been implemented representing
     various international calendar systems. Subclass API The original  Calendar  API was based on the experience
 of implementing a only a single subclass
  GregorianCalendar . As a result all of the subclassing
 kinks had not been worked out. The new subclassing API has been
 refined based on several implemented subclasses. This includes methods
 that must be overridden and methods for subclasses to call. Subclasses
 no longer have direct access to  fields  and
  stamp . Instead they have new API to access
 these. Subclasses are able to allocate the  fields  array
 through a protected framework method; this allows subclasses to
 specify additional fields.  More functionality has been moved into the base class. The base
 class now contains much of the computational machinery to support the
 Gregorian calendar. This is based on two things: (1) Many calendars
 are based on the Gregorian calendar (such as the Buddhist and Japanese
 imperial calendars). (2)  All  calendars require basic
 Gregorian support in order to handle timezone computations.  Common computations have been moved into
  Calendar . Subclasses no longer compute the week related
 fields and the time related fields. These are commonly handled for all
 calendars by the base class.  Subclass computation of time  =>  fields The  ERA   YEAR 
  EXTENDED_YEAR   MONTH 
  DAY_OF_MONTH  and  DAY_OF_YEAR  fields are
 computed by the subclass based on the Julian day. All other fields
 are computed by  Calendar .

  Subclasses should implement  handleComputeFields(int) 
     to compute the  ERA   YEAR 
      EXTENDED_YEAR   MONTH 
      DAY_OF_MONTH  and  DAY_OF_YEAR  fields
     based on the value of the  JULIAN_DAY  field. If there
     are calendar-specific fields not defined by  Calendar 
     they must also be computed. These are the only fields that the
     subclass should compute. All other fields are computed by the base
     class so time and week fields behave in a consistent way across
     all calendars. The default version of this method in
      Calendar  implements a proleptic Gregorian
     calendar. Within this method subclasses may call
      getGregorianXxx()  to obtain the Gregorian calendar
     month day of month and extended year for the given date. Subclass computation of fields  =>  time The interpretation of most field values is handled entirely by
  Calendar .  Calendar  determines which fields
 are set which are not which are set more recently and so on. In
 addition  Calendar  handles the computation of the time
 from the time fields and handles the week-related fields. The only
 thing the subclass must do is determine the extended year based on
 the year fields and then given an extended year and a month it must
 return a Julian day number.

  Subclasses should implement  handleGetExtendedYear() 
     to return the extended year for this calendar system based on the
      YEAR   EXTENDED_YEAR  and any fields that
     the calendar system uses that are larger than a year such as
      ERA . Subclasses should implement  handleComputeMonthStart(int int boolean) 
     to return the Julian day number
     associated with a month and extended year. This is the Julian day
     number of the day before the first day of the month. The month
     number is zero-based. This computation should not depend on any
     field values. Other methods Subclasses should implement  handleGetMonthLength(int int) 
     to return the number of days in a
     given month of a given extended year. The month number as always
     is zero-based. Subclasses should implement  handleGetYearLength(int) 
     to return the number of days in the given
     extended year. This method is used by
      computeWeekFields  to compute the
      WEEK_OF_YEAR  and  YEAR_WOY  fields. Subclasses should implement  handleGetLimit(int int) 
     to return the protected values of a field depending on the value of
      limitType . This method only needs to handle the
     fields  ERA   YEAR   MONTH 
      WEEK_OF_YEAR   WEEK_OF_MONTH 
      DAY_OF_MONTH   DAY_OF_YEAR 
      DAY_OF_WEEK_IN_MONTH   YEAR_WOY  and
      EXTENDED_YEAR .  Other fields are invariant (with
     respect to calendar system) and are handled by the base
     class. Optionally subclasses may override  validateField(int) 
     to check any subclass-specific fields. If the
     field's value is out of range the method should throw an
      IllegalArgumentException . The method may call
      super.validateField(field)  to handle fields in a
     generic way that is to compare them to the range
      getMinimum(field) .. getMaximum(field) . Optionally subclasses may override
      handleCreateFields()  to create an  int[] 
     array large enough to hold the calendar's fields. This is only
     necessary if the calendar defines additional fields beyond those
     defined by  Calendar . The length of the result must be
     be between the base and maximum field counts. Optionally subclasses may override
      handleGetDateFormat(String ULocale)  to create a
      DateFormat  appropriate to this calendar. This is only
     required if a calendar subclass redefines the use of a field (for
     example changes the  ERA  field from a symbolic field
     to a numeric one) or defines an additional field. Optionally subclasses may override  roll  and
      add  to handle fields that are discontinuous. For
     example in the Hebrew calendar the month ""Adar I"" only
     occurs in leap years; in other years the calendar jumps from
     Shevat (month #4) to Adar (month #6). The  HebrewCalendar#add  and  HebrewCalendar#roll  methods take this into
     account so that adding 1 month to Shevat gives the proper result
     (Adar) in a non-leap year. The protected utility method  pinField  is often useful when implementing these two
     methods.  Normalized behavior The behavior of certain fields has been made consistent across all
 calendar systems and implemented in  Calendar .

  Time is normalized. Even though some calendar systems transition
     between days at sunset or at other times all ICU4J calendars
     transition between days at  local zone midnight .  This
     allows ICU4J to centralize the time computations in
      Calendar  and to maintain basic correpsondences
     between calendar systems. Affected fields:  AM_PM 
      HOUR   HOUR_OF_DAY   MINUTE 
      SECOND   MILLISECOND 
      ZONE_OFFSET  and  DST_OFFSET . DST behavior is normalized. Daylight savings time behavior is
     computed the same for all calendar systems and depends on the
     value of several  GregorianCalendar  fields: the
      YEAR   MONTH  and
      DAY_OF_MONTH . As a result  Calendar 
     always computes these fields even for non-Gregorian calendar
     systems. These fields are available to subclasses. Weeks are normalized. Although locales define the week
     differently in terms of the day on which it starts and the
     designation of week number one of a month or year they all use a
     common mechanism. Furthermore the day of the week has a simple
     and consistent definition throughout history. For example
     although the Gregorian calendar introduced a discontinuity when
     first instituted the day of week was not disrupted. For this
     reason the fields  DAY_OF_WEEK   WEEK_OF_YEAR
     WEEK_OF_MONTH   DAY_OF_WEEK_IN_MONTH 
      DOW_LOCAL   YEAR_WOY  are all computed in
     a consistent way in the base class based on the
      EXTENDED_YEAR   DAY_OF_YEAR 
      MONTH  and  DAY_OF_MONTH  which are
     computed by the subclass. Supported range The allowable range of  Calendar  has been
 narrowed.  GregorianCalendar  used to attempt to support
 the range of dates with millisecond values from
  Long.MIN_VALUE  to  Long.MAX_VALUE . This
 introduced awkward constructions (hacks) which slowed down
 performance. It also introduced non-uniform behavior at the
 boundaries. The new  Calendar  protocol specifies the
 maximum range of supportable dates as those having Julian day numbers
 of  -0x7F000000  to  +0x7F000000 . This
 corresponds to years from ~5800000 BCE to ~5800000 CE. Programmers
 should use the protected constants in  Calendar  to
 specify an extremely early or extremely late date. General notes Calendars implementations are  proleptic . For example
     even though the Gregorian calendar was not instituted until the
     16th century the  GregorianCalendar  class supports
     dates before the historical onset of the calendar by extending the
     calendar system backward in time. Similarly the
      HebrewCalendar  extends backward before the start of
     its epoch into zero and negative years. Subclasses do not throw
     exceptions because a date precedes the historical start of a
     calendar system. Instead they implement
      handleGetLimit(int int)  to return appropriate limits on
      YEAR   ERA  etc. fields. Then if the
     calendar is set to not be lenient out-of-range field values will
     trigger an exception. Calendar system subclasses compute a  extended
     year . This differs from the  YEAR  field in that
     it ranges over all integer values including zero and negative
     values and it encapsulates the information of the
      YEAR  field and all larger fields.  Thus for the
     Gregorian calendar the  EXTENDED_YEAR  is computed as
      ERA==AD ? YEAR : 1-YEAR . Another example is the Mayan
     long count which has years ( KUN ) and nested cycles
     of years ( KATUN  and  BAKTUN ). The Mayan
      EXTENDED_YEAR  is computed as  TUN + 20 * (KATUN
     + 20 * BAKTUN) . The  Calendar  base class uses
     the  EXTENDED_YEAR  field to compute the week-related
     fields."
android,icu.util,ChineseCalendar,10,"ChineseCalendar  is a concrete subclass of  Calendar 
 that implements a traditional Chinese calendar.  The traditional Chinese
 calendar is a lunisolar calendar: Each month starts on a new moon and
 the months are numbered according to solar events specifically to
 guarantee that month 11 always contains the winter solstice.  In order
 to accomplish this leap months are inserted in certain years.  Leap
 months are numbered the same as the month they follow.  The decision of
 which month is a leap month depends on the relative movements of the sun
 and moon.

  All astronomical computations are performed with respect to a time
 zone of GMT+8:00 and a longitude of 120 degrees east.  Although some
 calendars implement a historically more accurate convention of using
 Beijing's local longitude (116 degrees 25 minutes east) and time zone
 (GMT+7:45:40) for dates before 1929 we do not implement this here.

  Years are counted in two different ways in the Chinese calendar.  The
 first method is by sequential numbering from the 61st year of the reign
 of Huang Di 2637 BCE which is designated year 1 on the Chinese
 calendar.  The second method uses 60-year cycles from the same starting
 point which is designated year 1 of cycle 1.  In this class the
  EXTENDED_YEAR  field contains the sequential year count.
 The  ERA  field contains the cycle number and the
  YEAR  field contains the year of the cycle a value between
 1 and 60.

  There is some variation in what is considered the starting point of
 the calendar with some sources starting in the first year of the reign
 of Huang Di rather than the 61st.  This gives continuous year numbers
 60 years greater and cycle numbers one greater than what this class
 implements.

  Because  ChineseCalendar  defines an additional field and
 redefines the way the  ERA  field is used it requires a new
 format class  ChineseDateFormat .  As always use the
 methods  DateFormat.getXxxInstance(Calendar cal...)  to
 obtain a formatter for this calendar.

  References: Dershowitz and Reingold  Calendrical Calculations 
 Cambridge University Press 1997 Helmer Aslaksen's
  
 Chinese Calendar page The  
 Calendar FAQ 
 This class should not be subclassed. 
 ChineseCalendar usually should be instantiated using
  Calendar.getInstance(ULocale)  passing in a  ULocale 
 with the tag  ""@calendar=chinese"" ."
android,icu.util,CurrencyAmount,1,"An amount of currency consisting of a Number and a Currency.
 CurrencyAmount objects are immutable."
android,icu.util,DateInterval,5,"This class represents date interval.
 It is a pair of long representing from date 1 to date 2."
android,icu.util,JapaneseCalendar,5,"JapaneseCalendar  is a subclass of  GregorianCalendar 
 that numbers years and eras based on the reigns of the Japanese emperors.
 The Japanese calendar is identical to the Gregorian calendar in all respects
 except for the year and era.  The ascension of each  emperor to the throne
 begins a new era and the years of that era are numbered starting with the
 year of ascension as year 1.
  
 Note that in the year of an imperial ascension there are two possible sets
 of year and era values: that for the old era and for the new.  For example a
 new era began on January 7 1989 AD.  Strictly speaking the first six days
 of that year were in the Showa era e.g. ""January 6 64 Showa"" while the rest
 of the year was in the Heisei era e.g. ""January 7 1 Heisei"".  This class
 handles this distinction correctly when computing dates.  However in lenient
 mode either form of date is acceptable as input.
  
 In modern times eras have started on January 8 1868 AD Gregorian (Meiji)
 July 30 1912 (Taisho) December 25 1926 (Showa) and January 7 1989 (Heisei).  Constants
 for these eras suitable for use in the  ERA  field are provided
 in this class.  Note that the  number  used for each era is more or
 less arbitrary.  Currently the era starting in 645 AD is era #0; however this
 may change in the future.  Use the predefined constants rather than using actual
 absolute numbers.
  
 Since ICU4J 63 start date of each era is imported from CLDR. CLDR era data
 may contain tentative era in near future with placeholder names. By default
 such era data is not enabled. ICU4J users who want to test the behavior of
 the future era can enable this by one of following settings (in the priority
 order):
  Java system property  ICU_ENABLE_TENTATIVE_ERA=true . Environment variable  ICU_ENABLE_TENTATIVE_ERA=true . Java system property  jdk.calendar.japanese.supplemental.era=xxx .
     (Note: This configuration is used for specifying a new era's start date and
     names in OpenJDK. ICU4J implementation enables the CLDR tentative era when
     this property is defined but it does not use the start date and names specified
     by the property value.) 
 This class should not be subclassed. 
 JapaneseCalendar usually should be instantiated using
  Calendar.getInstance(ULocale)  passing in a  ULocale 
 with the tag  ""@calendar=japanese"" ."
android,icu.util,LocaleData.MeasurementSystem,0,Enumeration for representing the measurement systems.
android,icu.util,LocaleData.PaperSize,2,"A class that represents the size of letter head
 used in the country"
android,icu.util,Measure,5,"An amount of a specified unit consisting of a Number and a Unit.
 For example a length measure consists of a Number and a length
 unit such as feet or meters.

  Measure objects are parsed and formatted by subclasses of
 MeasureFormat.

  Measure objects are immutable. All subclasses must guarantee that.
 (However subclassing is discouraged.)"
android,icu.util,ULocale,93,"[icu enhancement]  ICU's replacement for  Locale .Â Methods fields and other functionality specific to ICU are labeled ' [icu] '.

 A class analogous to  Locale  that provides additional
 support for ICU protocol.  In ICU 3.0 this class is enhanced to support
 RFC 3066 language identifiers.

  Many classes and services in ICU follow a factory idiom in
 which a factory method or object responds to a client request with
 an object.  The request includes a locale (the  requested 
 locale) and the returned object is constructed using data for that
 locale.  The system may lack data for the requested locale in
 which case the locale fallback mechanism will be invoked until a
 populated locale is found (the  valid  locale).  Furthermore
 even when a populated locale is found (the  valid  locale)
 further fallback may be required to reach a locale containing the
 specific data required by the service (the  actual  locale).

  ULocale performs  'normalization'  and  'canonicalization'  of locale ids.
 Normalization 'cleans up' ICU locale ids as follows:
  language script country variant and keywords are properly cased 
 (lower title upper upper and lower case respectively) hyphens used as separators are converted to underscores three-letter language and country ids are converted to two-letter
 equivalents where available surrounding spaces are removed from keywords and values if there are multiple keywords they are put in sorted order POSIX ids are converted to ICU format IDs 'grandfathered' 3066 ids are converted to ICU standard form 'PREEURO' and 'EURO' variants are converted to currency keyword form
 with the currency
 id appropriate to the country of the locale (for PREEURO) or EUR (for EURO).
  canonicalize canonicalInstance Note: The  actual  locale is returned correctly but the  valid 
 locale is not in most cases."
android,icu.util,LocaleData,8,A class for accessing miscellaneous data in the locale bundles
android,icu.util,Output,1,Simple struct-like class for output parameters.
android,icu.util,RangeValueIterator.Element,0,"Return result wrapper for android.icu.util.RangeValueIterator.
 Stores the start and limit of the continous result range and the
 common value all integers between [start limit - 1] has."
android,icu.util,TaiwanCalendar,4,"TaiwanCalendar  is a subclass of  GregorianCalendar 
 that numbers years since 1912.
  
 The Taiwan calendar is identical to the Gregorian calendar in all respects
 except for the year and era.  Years are numbered since 1912 AD (Gregorian).
  
 The Taiwan Calendar has one era:  MINGUO .
  
 This class should not be subclassed. 
 TaiwanCalendar usually should be instantiated using
  Calendar.getInstance(ULocale)  passing in a  ULocale 
 with the tag  ""@calendar=roc"" ."
android,icu.util,TimeUnit,1,Measurement unit for time units.
android,icu.util,TimeZone,40,"[icu enhancement]  ICU's replacement for  TimeZone .Â Methods fields and other functionality specific to ICU are labeled ' [icu] '.

  TimeZone  represents a time zone offset and also computes daylight
 savings.

  Typically you get a  TimeZone  using  getDefault() 
 which creates a  TimeZone  based on the time zone where the program
 is running. For example for a program running in Japan  getDefault 
 creates a  TimeZone  object based on Japanese Standard Time.

  You can also get a  TimeZone  using  getTimeZone(java.lang.String) 
 along with a time zone ID. For instance the time zone ID for the
 U.S. Pacific Time zone is ""America/Los_Angeles"". So you can get a
 U.S. Pacific Time  TimeZone  object with:

  
 TimeZone tz = TimeZone.getTimeZone(""America/Los_Angeles"");
  getAvailableIDs() TimeZone 
 GMT[+|-]hh[[:]mm]
  TimeZone getCanonicalID For compatibility with JDK 1.1.x some other three-letter time zone IDs
 (such as ""PST"" ""CTT"" ""AST"") are also supported. However  their
 use is deprecated  because the same abbreviation is often used
 for multiple time zones (for example ""CST"" could be U.S. ""Central Standard
 Time"" and ""China Standard Time"") and the Java platform can then only
 recognize one of them."
android,icu.util,ULocale.Builder,13,"Builder  is used to build instances of  ULocale 
 from values configured by the setters.  Unlike the  ULocale 
 constructors the  Builder  checks if a value configured by a
 setter satisfies the syntax requirements defined by the  ULocale 
 class.  A  ULocale  object created by a  Builder  is
 well-formed and can be transformed to a well-formed IETF BCP 47 language tag
 without losing information.

  Note:  The  ULocale  class does not provide any
 syntactic restrictions on variant while BCP 47 requires each variant
 subtag to be 5 to 8 alphanumerics or a single numeric followed by 3
 alphanumerics.  The method  setVariant  throws
  IllformedLocaleException  for a variant that does not satisfy
 this restriction. If it is necessary to support such a variant use a
 ULocale constructor.  However keep in mind that a  ULocale 
 object created this way might lose the variant information when
 transformed to a BCP 47 language tag.

  The following example shows how to create a  Locale  object
 with the  Builder .
  
     ULocale aLocale = new Builder().setLanguage(""sr"").setScript(""Latn"").setRegion(""RS"").build();
  Builders can be reused;  clear()  resets all
 fields to their default values."
android,icu.util,UniversalTimeScale,8,"There are quite a few different conventions for binary datetime depending on different
 platforms and protocols. Some of these have severe drawbacks. For example people using
 Unix time (seconds since Jan 1 1970 usually in a 32-bit integer)
 think that they are safe until near the year 2038.
 But cases can and do arise where arithmetic manipulations causes serious problems. Consider
 the computation of the average of two datetimes for example: if one calculates them with
  averageTime = (time1 + time2)/2  there will be overflow even with dates
 beginning in 2004. Moreover even if these problems don't occur there is the issue of
 conversion back and forth between different systems.

  Binary datetimes differ in a number of ways: the datatype the unit
 and the epoch (origin). We refer to these as time scales.

  ICU implements a universal time scale that is similar to the
 .NET framework's System.DateTime. The universal time scale is a
 64-bit integer that holds ticks since midnight January 1st 0001.
 (One tick is 100 nanoseconds.)
 Negative values are supported. This has enough range to guarantee that
 calculations involving dates around the present are safe.

  The universal time scale always measures time according to the
 proleptic Gregorian calendar. That is the Gregorian calendar's
 leap year rules are used for all times even before 1582 when it was
 introduced. (This is different from the default ICU calendar which
 switches from the Julian to the Gregorian calendar in 1582.
 See GregorianCalendar.setGregorianChange() and ucal_setGregorianChange().)

 ICU provides conversion functions to and from all other major time
 scales allowing datetimes in any time scale to be converted to the
 universal time scale safely manipulated and converted back to any other
 datetime time scale.

  For more details and background see the
  Universal Time Scale 
 chapter in the ICU User Guide."
android,icu.util,ValueIterator.Element,0,"The return result container of each iteration. Stores the next
 integer index and its associated value Object."
android,icu.util,VersionInfo,13,Class to store version numbers of the form major.minor.milli.micro.
android,media.effect,Effect,5,"Effects are high-performance transformations that can be applied to image frames. These are
 passed in the form of OpenGL ES 2.0 texture names. Typical frames could be images loaded from
 disk or frames from the camera or other video streams. To create an Effect you must first create an EffectContext. You can obtain an instance of the
 context's EffectFactory by calling
  getFactory() . The EffectFactory allows
 you to instantiate specific Effects. The application is responsible for creating an EGL context and making it current before
 applying an effect. An effect is bound to a single EffectContext which in turn is bound to a
 single EGL context. If your EGL context is destroyed the EffectContext becomes invalid and any
 effects bound to this context can no longer be used."
android,media.effect,EffectContext,3,"An EffectContext keeps all necessary state information to run Effects within a Open GL ES 2.0
 context. Every EffectContext is bound to one GL context. The application is responsible for creating
 this EGL context and making it current before applying any effect. If your EGL context is
 destroyed the EffectContext becomes invalid and any effects bound to this context can no longer
 be used. If you switch to another EGL context you must create a new EffectContext. Each Effect
 is bound to a single EffectContext and can only be executed in that context."
android,media.effect,EffectFactory,2,"The EffectFactory class defines the list of available Effects and provides functionality to
 inspect and instantiate them. Some effects may not be available on all platforms so before
 creating a certain effect the application should confirm that the effect is supported on this
 platform by calling  isEffectSupported(java.lang.String) ."
android,media.projection,MediaProjection,4,"A token granting applications the ability to capture screen contents and/or
 record system audio. The exact capabilities granted depend on the type of
 MediaProjection.

  
 A screen capture session can be started through  MediaProjectionManager#createScreenCaptureIntent . This grants the ability to
 capture screen contents but not system audio."
android,media.projection,MediaProjection.Callback,1,Callbacks for the projection session.
android,media.projection,MediaProjectionManager,2,Manages the retrieval of certain types of  MediaProjection  tokens.
android,media.midi,MidiDevice,7,"This class is used for sending and receiving data to and from a MIDI device
 Instances of this class are created by  MidiManager#openDevice ."
android,media.midi,MidiDeviceInfo,12,"This class contains information to describe a MIDI device.
 For now we only have information that can be retrieved easily for USB devices
 but we will probably expand this in the future.

 This class is just an immutable object to encapsulate the MIDI device description.
 Use the MidiDevice class to actually communicate with devices."
android,media.midi,MidiDeviceInfo.PortInfo,3,Contains information about an input or output port.
android,media.midi,MidiDeviceService,7,"A service that implements a virtual MIDI device.
 Subclasses must implement the  onGetInputPortReceivers()  method to provide a
 list of  MidiReceiver s to receive data sent to the device's input ports.
 Similarly subclasses can call  getOutputPortReceivers()  to fetch a list
 of  MidiReceiver s for sending data out the output ports.

  To extend this class you must declare the service in your manifest file with
 an intent filter with the  SERVICE_INTERFACE  action
 and meta-data to describe the virtual device.
 For example: 
 <service android:name="".VirtualDeviceService""
          android:label=""@string/service_name"">
     <intent-filter>
         <action android:name=""android.media.midi.MidiDeviceService"" />
     </intent-filter>
           <meta-data android:name=""android.media.midi.MidiDeviceService""
               android:resource=""@xml/device_info"" />
 </service>"
android,media.midi,MidiInputPort,5,This class is used for sending data to a port on a MIDI device
android,media.midi,MidiManager,5,"This class is the public application interface to the MIDI service.
 
  
 Requires the  PackageManager#FEATURE_MIDI  feature which can be detected using  PackageManager.hasSystemFeature(String) ."
android,media.midi,MidiManager.DeviceCallback,3,Callback class used for clients to receive MIDI device added and removed notifications
android,media.midi,MidiReceiver,6,Interface for sending and receiving data to and from a MIDI device.
android,media.midi,MidiSender,4,"Interface provided by a device to allow attaching
 MidiReceivers to a MIDI device."
android,media.midi,MidiDevice.MidiConnection,2,"This class represents a connection between the output port of one device
 and the input port of another. Created by  MidiDevice.connectPorts(MidiInputPort int) .
 Close this object to terminate the connection."
android,media.midi,MidiDeviceStatus,6,This is an immutable class that describes the current status of a MIDI device's ports.
android,media.midi,MidiOutputPort,5,This class is used for receiving data from a port on a MIDI device
android,media.session,MediaController,20,"Allows an app to interact with an ongoing media session. Media buttons and
 other commands can be sent to the session. A callback may be registered to
 receive updates from the session such as metadata and play state changes.
  
 A MediaController can be created through  MediaSessionManager  if you
 hold the ""android.permission.MEDIA_CONTENT_CONTROL"" permission or are an
 enabled notification listener or by getting a  MediaSession.Token 
 directly from the session owner.
  
 MediaController objects are thread-safe."
android,media.session,MediaController.Callback,8,"Callback for receiving updates from the session. A Callback can be
 registered using  MediaController.registerCallback(MediaController.Callback) ."
android,media.session,MediaController.TransportControls,20,"Interface for controlling media playback on a session. This allows an app
 to send media transport commands to the session."
android,media.session,MediaSession,20,"Allows interaction with media controllers volume keys media buttons and
 transport controls.
  
 A MediaSession should be created when an app wants to publish media playback
 information or handle media keys. In general an app only needs one session
 for all playback though multiple sessions can be created to provide finer
 grain controls of media.
  
 Once a session is created the owner of the session may pass its
  session token  to other processes to allow them to
 create a  MediaController  to interact with the session.
  
 To receive commands media keys and other events a  Callback  must be
 set with  setCallback(android.media.session.MediaSession.Callback)  and  setActive(true)  must be called.
  
 When an app is finished performing playback it must call  release() 
 to clean up the session and notify any controllers.
  
 MediaSession objects are thread safe."
android,media.session,MediaSession.Callback,21,"Receives media buttons transport controls and commands from controllers
 and the system. A callback may be set using  MediaSession.setCallback(MediaSession.Callback) ."
android,media.session,MediaSession.QueueItem,6,"A single item that is part of the play queue. It contains a description
 of the item and its id in the queue."
android,media.session,MediaSession.Token,4,"Represents an ongoing session. This may be passed to apps by the session
 owner to allow them to create a  MediaController  to communicate with
 the session."
android,media.session,MediaSessionManager,10,"Provides support for interacting with  MediaSession 
 that applications have published to express their ongoing media playback
 state."
android,media.session,MediaController.PlaybackInfo,8,"Holds information about the current playback and how audio is handled for
 this session."
android,media.session,MediaSessionManager.RemoteUserInfo,5,"Information of a remote user of  MediaSession  or  MediaBrowserService .
 This can be used to decide whether the remote user is trusted app and also differentiate
 caller of  MediaSession  and  MediaBrowserService  callbacks.
  
 See  equals(java.lang.Object)  to take a look at how it differentiate media controller."
android,media.session,PlaybackState,13,"Playback state for a  MediaSession . This includes a state like
  PlaybackState#STATE_PLAYING  the current playback position
 and the current control capabilities."
android,media.session,PlaybackState.Builder,10,Builder for  PlaybackState  objects.
android,media.session,PlaybackState.CustomAction,7,"PlaybackState.CustomAction  can be used to extend the capabilities of
 the standard transport controls by exposing app specific actions to
  MediaController ."
android,media.session,PlaybackState.CustomAction.Builder,2,Builder for  CustomAction  objects.
android,media.audiofx,AutomaticGainControl,2,"Automatic Gain Control (AGC).
  Automatic Gain Control (AGC) is an audio pre-processor which automatically normalizes the
 output of the captured signal by boosting or lowering input from the microphone to match a preset
 level so that the output signal level is virtually constant.
 AGC can be used by applications where the input signal dynamic range is not important but where
 a constant strong capture level is desired.
  An application creates a AutomaticGainControl object to instantiate and control an AGC
 engine in the audio framework.
  To attach the AutomaticGainControl to a particular  AudioRecord 
 specify the audio session ID of this AudioRecord when creating the AutomaticGainControl.
 The audio session is retrieved by calling
  AudioRecord.getAudioSessionId()  on the AudioRecord instance.
  On some devices an AGC can be inserted by default in the capture path by the platform
 according to the  MediaRecorder.AudioSource  used. The application should
 call AutomaticGainControl.getEnable() after creating the AGC to check the default AGC activation
 state on a particular AudioRecord session.
  See  AudioEffect  class for more details on
 controlling audio effects."
android,media.audiofx,BassBoost,6,"Bass boost is an audio effect to boost or amplify low frequencies of the sound. It is comparable
 to a simple equalizer but limited to one band amplification in the low frequency range.
  An application creates a BassBoost object to instantiate and control a bass boost engine in
 the audio framework.
  The methods parameter types and units exposed by the BassBoost implementation are directly
 mapping those defined by the OpenSL ES 1.0.1 Specification (http://www.khronos.org/opensles/)
 for the SLBassBoostItf interface. Please refer to this specification for more details.
  To attach the BassBoost to a particular AudioTrack or MediaPlayer specify the audio session
 ID of this AudioTrack or MediaPlayer when constructing the BassBoost.
  NOTE: attaching a BassBoost to the global audio output mix by use of session 0 is deprecated.
  See  MediaPlayer.getAudioSessionId()  for details on audio sessions.
  See  AudioEffect  class for more details on
 controlling audio effects."
android,media.audiofx,DynamicsProcessing,29,"DynamicsProcessing is an audio effect for equalizing and changing dynamic range properties of the
 sound. It is composed of multiple stages including equalization multi-band compression and
 limiter.
  The number of bands and active stages is configurable and most parameters can be controlled
 in realtime such as gains attack/release times thresholds etc.
  The effect is instantiated and controlled by channels. Each channel has the same basic
 architecture but all of their parameters are independent from other channels.
  The basic channel configuration is:
  

    Channel 0          Channel 1       ....       Channel N-1
      Input              Input                       Input
        |                  |                           |
   +----v----+        +----v----+                 +----v----+
   |inputGain|        |inputGain|                 |inputGain|
   +---------+        +---------+                 +---------+
        |                  |                           |
  +-----v-----+      +-----v-----+               +-----v-----+
  |   PreEQ   |      |   PreEQ   |               |   PreEQ   |
  +-----------+      +-----------+               +-----------+
        |                  |                           |
  +-----v-----+      +-----v-----+               +-----v-----+
  |    MBC    |      |    MBC    |               |    MBC    |
  +-----------+      +-----------+               +-----------+
        |                  |                           |
  +-----v-----+      +-----v-----+               +-----v-----+
  |  PostEQ   |      |  PostEQ   |               |  PostEQ   |
  +-----------+      +-----------+               +-----------+
        |                  |                           |
  +-----v-----+      +-----v-----+               +-----v-----+
  |  Limiter  |      |  Limiter  |               |  Limiter  |
  +-----------+      +-----------+               +-----------+
        |                  |                           |
     Output             Output                      Output
  Where the stages are:
 inputGain: input gain factor in decibels (dB). 0 dB means no change in level.
 PreEQ:  Multi-band Equalizer.
 MBC:    Multi-band Compressor
 PostEQ: Multi-band Equalizer
 Limiter: Single band compressor/limiter.

  An application creates a DynamicsProcessing object to instantiate and control this audio
 effect in the audio framework. A DynamicsProcessor.Config and DynamicsProcessor.Config.Builder
 are available to help configure the multiple stages and each band parameters if desired.
  See each stage documentation for further details.
  If no Config is specified during creation a default configuration is chosen.
  To attach the DynamicsProcessing to a particular AudioTrack or MediaPlayer
 specify the audio session ID of this AudioTrack or MediaPlayer when constructing the effect
 (see  AudioTrack#getAudioSessionId()  and  MediaPlayer#getAudioSessionId() ).

  To attach the DynamicsProcessing to a particular AudioTrack or MediaPlayer specify the audio
 session ID of this AudioTrack or MediaPlayer when constructing the DynamicsProcessing.
  See  MediaPlayer.getAudioSessionId()  for details on audio sessions.
  See  AudioEffect  class for more details on controlling audio
 effects."
android,media.audiofx,DynamicsProcessing.BandBase,5,Base class for bands
android,media.audiofx,DynamicsProcessing.Channel,17,"Class for Channel configuration parameters. It is composed of multiple stages which can be
 used/enabled independently. Stages not used or disabled will be bypassed and the sound would
 be unaffected by them."
android,media.audiofx,DynamicsProcessing.Config,37,"Class for Config object used by DynamicsProcessing to configure and update the audio effect.
 use Builder to instantiate objects of this type."
android,media.audiofx,DynamicsProcessing.Eq,3,Class for Equalizer stage
android,media.audiofx,PresetReverb.Settings,1,"The Settings class regroups all preset reverb parameters. It is used in
 conjuntion with getProperties() and setProperties() methods to backup and restore
 all parameters in a single call."
android,media.audiofx,AcousticEchoCanceler,2,"Acoustic Echo Canceler (AEC).
  Acoustic Echo Canceler (AEC) is an audio pre-processor which removes the contribution of the
 signal received from the remote party from the captured audio signal.
  AEC is used by voice communication applications (voice chat video conferencing SIP calls)
 where the presence of echo with significant delay in the signal received from the remote party
 is highly disturbing. AEC is often used in conjunction with noise suppression (NS).
  An application creates an AcousticEchoCanceler object to instantiate and control an AEC
 engine in the audio capture path.
  To attach the AcousticEchoCanceler to a particular  AudioRecord 
 specify the audio session ID of this AudioRecord when creating the AcousticEchoCanceler.
 The audio session is retrieved by calling
  AudioRecord.getAudioSessionId()  on the AudioRecord instance.
  On some devices an AEC can be inserted by default in the capture path by the platform
 according to the  MediaRecorder.AudioSource  used. The application should
 call AcousticEchoCanceler.getEnable() after creating the AEC to check the default AEC activation
 state on a particular AudioRecord session.
  See  AudioEffect  class for more details on
 controlling audio effects."
android,media.audiofx,AudioEffect.Descriptor,2,"The effect descriptor contains information on a particular effect implemented in the
 audio framework: type: UUID identifying the effect type. May be one of:
  AudioEffect#EFFECT_TYPE_AEC   AudioEffect#EFFECT_TYPE_AGC 
  AudioEffect#EFFECT_TYPE_BASS_BOOST   AudioEffect#EFFECT_TYPE_ENV_REVERB 
  AudioEffect#EFFECT_TYPE_EQUALIZER   AudioEffect#EFFECT_TYPE_NS 
  AudioEffect#EFFECT_TYPE_PRESET_REVERB   AudioEffect#EFFECT_TYPE_VIRTUALIZER 
  AudioEffect#EFFECT_TYPE_DYNAMICS_PROCESSING .
   uuid: UUID for this particular implementation connectMode:  AudioEffect.EFFECT_INSERT  or  AudioEffect.EFFECT_AUXILIARY name: human readable effect name implementor: human readable effect implementor name AudioEffect.queryEffects()"
android,media.audiofx,BassBoost.Settings,1,"The Settings class regroups all bass boost parameters. It is used in
 conjuntion with getProperties() and setProperties() methods to backup and restore
 all parameters in a single call."
android,media.audiofx,DynamicsProcessing.EqBand,3,"Class for Equalizer Bands
 Equalizer bands have three controllable parameters: enabled/disabled cutoffFrequency and
 gain"
android,media.audiofx,DynamicsProcessing.Mbc,3,Class for Multi-Band Compressor (MBC) stage
android,media.audiofx,EnvironmentalReverb.Settings,1,"The Settings class regroups all environmental reverb parameters. It is used in
 conjuntion with getProperties() and setProperties() methods to backup and restore
 all parameters in a single call."
android,media.audiofx,Virtualizer.Settings,1,"The Settings class regroups all virtualizer parameters. It is used in
 conjuntion with getProperties() and setProperties() methods to backup and restore
 all parameters in a single call."
android,media.audiofx,Visualizer,17,"The Visualizer class enables application to retrieve part of the currently playing audio for
 visualization purpose. It is not an audio recording interface and only returns partial and low
 quality audio content. However to protect privacy of certain audio data (e.g voice mail) the use
 of the visualizer requires the permission android.permission.RECORD_AUDIO.
  The audio session ID passed to the constructor indicates which audio content should be
 visualized: If the session is 0 the audio output mix is visualized If the session is not 0 the audio from a particular  MediaPlayer  or
    AudioTrack 
   using this audio session is visualized  Two types of representation of audio content can be captured:  Waveform data: consecutive 8-bit (unsigned) mono samples by using the
    getWaveForm(byte[])  method Frequency data: 8-bit magnitude FFT by using the  getFft(byte[])  method The length of the capture can be retrieved or specified by calling respectively
  getCaptureSize()  and  setCaptureSize(int)  methods. The capture size must be a
 power of 2 in the range returned by  getCaptureSizeRange() .
  In addition to the polling capture mode described above with  getWaveForm(byte[])  and
   getFft(byte[])  methods a callback mode is also available by installing a listener by
  use of the  setDataCaptureListener(android.media.audiofx.Visualizer.OnDataCaptureListener int boolean boolean)  method.
  The rate at which the listener capture method is called as well as the type of data returned is
  specified.
  Before capturing data the Visualizer must be enabled by calling the
  setEnabled(boolean)  method.
 When data capture is not needed any more the Visualizer should be disabled.
  It is good practice to call the  release()  method when the Visualizer is not used
 anymore to free up native resources associated to the Visualizer instance.
  Creating a Visualizer on the output mix (audio session 0) requires permission
  Manifest.permission.MODIFY_AUDIO_SETTINGS The Visualizer class can also be used to perform measurements on the audio being played back.
 The measurements to perform are defined by setting a mask of the requested measurement modes with
  setMeasurementMode(int) . Supported values are  MEASUREMENT_MODE_NONE  to cancel
 any measurement and  MEASUREMENT_MODE_PEAK_RMS  for peak and RMS monitoring.
 Measurements can be retrieved through  getMeasurementPeakRms(android.media.audiofx.Visualizer.MeasurementPeakRms) ."
android,media.audiofx,Visualizer.MeasurementPeakRms,0,"A class to store peak and RMS values.
 Peak and RMS are expressed in mB as described in the
  Visualizer#MEASUREMENT_MODE_PEAK_RMS  measurement mode."
android,media.audiofx,AudioEffect,10,"AudioEffect is the base class for controlling audio effects provided by the android audio
 framework.
  Applications should not use the AudioEffect class directly but one of its derived classes to
 control specific effects:
  Equalizer Virtualizer BassBoost PresetReverb EnvironmentalReverb DynamicsProcessing To apply the audio effect to a specific AudioTrack or MediaPlayer instance
 the application must specify the audio session ID of that instance when creating the AudioEffect.
 (see  MediaPlayer.getAudioSessionId()  for details on audio sessions).
  NOTE: attaching insert effects (equalizer bass boost virtualizer) to the global audio output
 mix by use of session 0 is deprecated.
  Creating an AudioEffect object will create the corresponding effect engine in the audio
 framework if no instance of the same effect type exists in the specified audio session.
 If one exists this instance will be used.
  The application creating the AudioEffect object (or a derived class) will either receive
 control of the effect engine or not depending on the priority parameter. If priority is higher
 than the priority used by the current effect engine owner the control will be transfered to the
 new object. Otherwise control will remain with the previous object. In this case the new
 application will be notified of changes in effect engine state or control ownership by the
 appropriate listener."
android,media.audiofx,DynamicsProcessing.BandStage,2,Base class for stages that hold bands
android,media.audiofx,DynamicsProcessing.Config.Builder,14,
android,media.audiofx,DynamicsProcessing.Limiter,13,"Class for Limiter Stage
 Limiter is a single band compressor at the end of the processing chain commonly used to
 protect the signal from overloading and distortion. Limiters have multiple controllable
 parameters: enabled/disabled linkGroup attackTime releaseTime ratio threshold and
 postGain.
  Limiters can be linked in groups across multiple channels. Linked limiters will trigger
 the same limiting if any of the linked limiters starts compressing."
android,media.audiofx,DynamicsProcessing.MbcBand,19,"Class for Multi-Band compressor bands
 MBC bands have multiple controllable parameters: enabled/disabled cutoffFrequency
 attackTime releaseTime ratio threshold kneeWidth noiseGateThreshold expanderRatio
 preGain and postGain."
android,media.audiofx,EnvironmentalReverb,23,"A sound generated within a room travels in many directions. The listener first hears the direct
 sound from the source itself. Later he or she hears discrete echoes caused by sound bouncing off
 nearby walls the ceiling and the floor. As sound waves arrive after undergoing more and more
 reflections individual reflections become indistinguishable and the listener hears continuous
 reverberation that decays over time.
 Reverb is vital for modeling a listener's environment. It can be used in music applications
 to simulate music being played back in various environments or in games to immerse the
 listener within the game's environment.
 The EnvironmentalReverb class allows an application to control each reverb engine property in a
 global reverb environment and is more suitable for games. For basic control more suitable for
 music applications it is recommended to use the
  PresetReverb  class.
  An application creates a EnvironmentalReverb object to instantiate and control a reverb engine
 in the audio framework.
  The methods parameter types and units exposed by the EnvironmentalReverb implementation are
 directly mapping those defined by the OpenSL ES 1.0.1 Specification
 (http://www.khronos.org/opensles/) for the SLEnvironmentalReverbItf interface.
 Please refer to this specification for more details.
  The EnvironmentalReverb is an output mix auxiliary effect and should be created on
 Audio session 0. In order for a MediaPlayer or AudioTrack to be fed into this effect
 they must be explicitely attached to it and a send level must be specified. Use the effect ID
 returned by getId() method to designate this particular effect when attaching it to the
 MediaPlayer or AudioTrack.
  Creating a reverb on the output mix (audio session 0) requires permission
  Manifest.permission.MODIFY_AUDIO_SETTINGS See  AudioEffect  class for more details on controlling
 audio effects."
android,media.audiofx,LoudnessEnhancer,2,"LoudnessEnhancer is an audio effect for increasing audio loudness.
 The processing is parametrized by a target gain value which determines the maximum amount
 by which an audio signal will be amplified; signals amplified outside of the sample
 range supported by the platform are compressed.
 An application creates a LoudnessEnhancer object to instantiate and control a
 this audio effect in the audio framework.
 To attach the LoudnessEnhancer to a particular AudioTrack or MediaPlayer
 specify the audio session ID of this AudioTrack or MediaPlayer when constructing the effect
 (see  AudioTrack#getAudioSessionId()  and  MediaPlayer#getAudioSessionId() )."
android,media.audiofx,NoiseSuppressor,2,"Noise Suppressor (NS).
  Noise suppression (NS) is an audio pre-processor which removes background noise from the
 captured signal. The component of the signal considered as noise can be either stationary
 (car/airplane engine AC system) or non-stationary (other peoples conversations car horn) for
 more advanced implementations.
  NS is mostly used by voice communication applications (voice chat video conferencing
 SIP calls).
  An application creates a NoiseSuppressor object to instantiate and control an NS
 engine in the audio framework.
  To attach the NoiseSuppressor to a particular  AudioRecord 
 specify the audio session ID of this AudioRecord when creating the NoiseSuppressor.
 The audio session is retrieved by calling
  AudioRecord.getAudioSessionId()  on the AudioRecord instance.
  On some devices NS can be inserted by default in the capture path by the platform
 according to the  MediaRecorder.AudioSource  used. The application should
 call NoiseSuppressor.getEnable() after creating the NS to check the default NS activation
 state on a particular AudioRecord session.
  See  AudioEffect  class for more details on
 controlling audio effects."
android,media.audiofx,PresetReverb,5,"A sound generated within a room travels in many directions. The listener first hears the
 direct sound from the source itself. Later he or she hears discrete echoes caused by sound
 bouncing off nearby walls the ceiling and the floor. As sound waves arrive after
 undergoing more and more reflections individual reflections become indistinguishable and
 the listener hears continuous reverberation that decays over time.
 Reverb is vital for modeling a listener's environment. It can be used in music applications
 to simulate music being played back in various environments or in games to immerse the
 listener within the game's environment.
 The PresetReverb class allows an application to configure the global reverb using a reverb preset.
 This is primarily used for adding some reverb in a music playback context. Applications
 requiring control over a more advanced environmental reverb are advised to use the
  EnvironmentalReverb  class.
  An application creates a PresetReverb object to instantiate and control a reverb engine in the
 audio framework.
  The methods parameter types and units exposed by the PresetReverb implementation are
 directly mapping those defined by the OpenSL ES 1.0.1 Specification
 (http://www.khronos.org/opensles/) for the SLPresetReverbItf interface.
 Please refer to this specification for more details.
  The PresetReverb is an output mix auxiliary effect and should be created on
 Audio session 0. In order for a MediaPlayer or AudioTrack to be fed into this effect
 they must be explicitely attached to it and a send level must be specified. Use the effect ID
 returned by getId() method to designate this particular effect when attaching it to the
 MediaPlayer or AudioTrack.
  Creating a reverb on the output mix (audio session 0) requires permission
  Manifest.permission.MODIFY_AUDIO_SETTINGS See  AudioEffect  class for more details on controlling
 audio effects."
android,media.audiofx,Virtualizer,10,"An audio virtualizer is a general name for an effect to spatialize audio channels. The exact
 behavior of this effect is dependent on the number of audio input channels and the types and
 number of audio output channels of the device. For example in the case of a stereo input and
 stereo headphone output a stereo widening effect is used when this effect is turned on.
  An application creates a Virtualizer object to instantiate and control a virtualizer engine
 in the audio framework.
  The methods parameter types and units exposed by the Virtualizer implementation are directly
 mapping those defined by the OpenSL ES 1.0.1 Specification (http://www.khronos.org/opensles/)
 for the SLVirtualizerItf interface. Please refer to this specification for more details.
  To attach the Virtualizer to a particular AudioTrack or MediaPlayer specify the audio session
 ID of this AudioTrack or MediaPlayer when constructing the Virtualizer.
  NOTE: attaching a Virtualizer to the global audio output mix by use of session 0 is
 deprecated.
  See  MediaPlayer.getAudioSessionId()  for details on audio sessions.
  See  AudioEffect  class for more details on controlling
 audio effects."
android,media.audiofx,DynamicsProcessing.Stage,4,base class for the different stages.
android,media.audiofx,Equalizer,14,"An Equalizer is used to alter the frequency response of a particular music source or of the main
 output mix.
  An application creates an Equalizer object to instantiate and control an Equalizer engine
 in the audio framework. The application can either simply use predefined presets or have a more
 precise control of the gain in each frequency band controlled by the equalizer.
  The methods parameter types and units exposed by the Equalizer implementation are directly
 mapping those defined by the OpenSL ES 1.0.1 Specification (http://www.khronos.org/opensles/)
 for the SLEqualizerItf interface. Please refer to this specification for more details.
  To attach the Equalizer to a particular AudioTrack or MediaPlayer specify the audio session
 ID of this AudioTrack or MediaPlayer when constructing the Equalizer.
  NOTE: attaching an Equalizer to the global audio output mix by use of session 0 is deprecated.
  See  MediaPlayer.getAudioSessionId()  for details on audio sessions.
  See  AudioEffect  class for more details on controlling audio
 effects."
android,media.audiofx,Equalizer.Settings,1,"The Settings class regroups all equalizer parameters. It is used in
 conjuntion with getProperties() and setProperties() methods to backup and restore
 all parameters in a single call."
android,icu.text,AlphabeticIndex,20,"AlphabeticIndex supports the creation of a UI index appropriate for a given language.
 It can support either direct use or use with a client that doesn't support localized collation.
 The following is an example of what an index might look like in a UI:

  ... A B C D E F G H I J K L M N O P Q R S T U V W X Y Z  ... A 
     Addison
     Albertson
     Azensky
   B 
     Baecker
  ...
  
 The class also supports having buckets for strings before the first (underflow)
 after the last (overflow) and between scripts (inflow). For example if the index
 is constructed with labels for Russian and English Greek characters would fall
 into an inflow bucket between the other two scripts.

  Note:  If you expect to have a lot of ASCII or Latin characters
 as well as characters from the user's language
 then it is a good idea to call addLabels(ULocale.English)."
android,icu.text,Bidi,54,
android,icu.text,CaseMap.Fold,4,Case folding options and methods. Immutable.
android,icu.text,CollationKey.BoundMode,0,"Options that used in the API CollationKey.getBound() for getting a
 CollationKey based on the bound mode requested."
android,icu.text,CompactDecimalFormat,4,"Formats numbers in compact (abbreviated) notation like ""1.2K"" instead of ""1200"".

 The CompactDecimalFormat produces abbreviated numbers suitable for display in environments will
 limited real estate. For example 'Hits: 1.2B' instead of 'Hits: 1200000000'. The format will
 be appropriate for the given language such as ""12 Mrd."" for German.

  For numbers under 1000 trillion (under 10^15 such as 123456789012345) the result will be
 short for supported languages. However the result may sometimes exceed 7 characters such as
 when there are combining marks or thin characters. In such cases the visual width in fonts
 should still be short.

  By default there are 2 significant digits. After creation if more than three significant
 digits are set (with setMaximumSignificantDigits) or if a fixed number of digits are set (with
 setMaximumIntegerDigits or setMaximumFractionDigits) then result may be wider.

  The ""short"" style is also capable of formatting currency amounts such as ""$1.2M"" instead of
 ""$1200000.00"" (English) or ""53Â Mio.Â â‚¬"" instead of ""5.300.00000 â‚¬"" (German). Localized data
 concerning longer formats is not available yet in the Unicode CLDR. Because of this attempting
 to format a currency amount using the ""long"" style will produce an UnsupportedOperationException.

  At this time negative numbers and parsing are not supported and will produce an
 UnsupportedOperationException. Resetting the pattern prefixes or suffixes is not supported; the
 method calls are ignored.

  Note that important methods like setting the number of decimals will be moved up from
 DecimalFormat to NumberFormat."
android,icu.text,Edits,11,"Records lengths of string edits but not replacement text. Supports replacements insertions deletions
 in linear progression. Does not support moving/reordering of text.
  
 There are two types of edits:  change edits  and  no-change edits . Add edits to
 instances of this class using  addReplace(int int)  (for change edits) and
  addUnchanged(int)  (for no-change edits). Change edits are retained with full granularity
 whereas adjacent no-change edits are always merged together. In no-change edits there is a one-to-one
 mapping between code points in the source and destination strings.
  
 After all edits have been added instances of this class should be considered immutable and an
  Edits.Iterator  can be used for queries.
  
 There are four flavors of Edits.Iterator:
  getFineIterator()  retains full granularity of change edits.
  getFineChangesIterator()  retains full granularity of change edits and when calling
 next() on the iterator skips over no-change edits (unchanged regions).
  getCoarseIterator()  treats adjacent change edits as a single edit. (Adjacent no-change
 edits are automatically merged during the construction phase.)
  getCoarseChangesIterator()  treats adjacent change edits as a single edit and when
 calling next() on the iterator skips over no-change edits (unchanged regions).
  
 For example consider the string ""abcÃŸDeF"" which case-folds to ""abcssdef"". This string has the
 following fine edits:
  abc â‡¨ abc (no-change)
  ÃŸ â‡¨ ss (change)
  D â‡¨ d (change)
  e â‡¨ e (no-change)
  F â‡¨ f (change)
  abc â‡¨ abc (no-change)
  ÃŸD â‡¨ ssd (change)
  e â‡¨ e (no-change)
  F â‡¨ f (change)
  
 The ""fine changes"" and ""coarse changes"" iterators will step through only the change edits when their
  Edits.Iterator#next()  methods are called. They are identical to the non-change iterators when
 their  Edits.Iterator#findSourceIndex(int)  method is used to walk through the string.
  
 For examples of how to use this class see the test  TestCaseMapEditsIteratorDocs  in
 UCharacterCaseTest.java."
android,icu.text,IDNA,5,"Abstract base class for IDNA processing.
 See http://www.unicode.org/reports/tr46/
 and http://www.ietf.org/rfc/rfc3490.txt
  
 The IDNA class is not intended for public subclassing.
  
 The non-static methods implement UTS #46 and IDNA2008.
 IDNA2008 is implemented according to UTS #46 see getUTS46Instance().
  
 IDNA2003 is obsolete. The static methods implement IDNA2003. They are all deprecated.
  
 IDNA2003 API Overview:
  
 The static IDNA API methods implement the IDNA protocol as defined in the
  IDNA RFC .
 The draft defines 2 operations: ToASCII and ToUnicode. Domain labels
 containing non-ASCII code points are required to be processed by
 ToASCII operation before passing it to resolver libraries. Domain names
 that are obtained from resolver libraries are required to be processed by
 ToUnicode operation before displaying the domain name to the user.
 IDNA requires that implementations process input strings with
  Nameprep 
 which is a profile of  Stringprep  
 and then with  Punycode .
 Implementations of IDNA MUST fully implement Nameprep and Punycode;
 neither Nameprep nor Punycode are optional.
 The input and output of ToASCII and ToUnicode operations are Unicode
 and are designed to be chainable i.e. applying ToASCII or ToUnicode operations
 multiple times to an input string will yield the same result as applying the operation
 once.
 ToUnicode(ToUnicode(ToUnicode...(ToUnicode(string)))) == ToUnicode(string)
 ToASCII(ToASCII(ToASCII...(ToASCII(string))) == ToASCII(string)."
android,icu.text,Normalizer.QuickCheckResult,0,"Result values for quickCheck().
 For details see Unicode Technical Report 15."
android,icu.text,NumberFormat.Field,0,"The instances of this inner class are used as attribute keys and values
 in AttributedCharacterIterator that
 NumberFormat.formatToCharacterIterator() method returns.
  
 There is no public constructor to this class the only instances are the
 constants defined here."
android,icu.text,ScientificNumberFormatter,5,"A formatter that formats numbers in user-friendly scientific notation.

 ScientificNumberFormatter instances are immutable and thread-safe.

 Sample code:
  
 ULocale en = new ULocale(""en"");
 ScientificNumberFormatter fmt = ScientificNumberFormatter.getMarkupInstance(
         en ""<sup>"" ""</sup>"");
  
 // Output: ""1.23456Ã—10<sup>-78</sup>""
 System.out.println(fmt.format(1.23456e-78));"
android,icu.text,TimeZoneFormat,33,"TimeZoneFormat  supports time zone display name formatting and parsing.
 An instance of TimeZoneFormat works as a subformatter of  SimpleDateFormat 
 but you can also directly get a new instance of  TimeZoneFormat  and
 formatting/parsing time zone display names.
  
 ICU implements the time zone display names defined by  UTS#35
 Unicode Locale Data Markup Language (LDML) .  TimeZoneNames  represents the
 time zone display name data model and this class implements the algorithm for actual
 formatting and parsing."
android,icu.text,UnicodeSetIterator,5,"UnicodeSetIterator iterates over the contents of a UnicodeSet.  It
 iterates over either code points or code point ranges.  After all
 code points or ranges have been returned it returns the
 multicharacter strings of the UnicodSet if any.

  To iterate over code points and multicharacter strings
 use a loop like this:
  
 for (UnicodeSetIterator it = new UnicodeSetIterator(set); it.next();) {
   processString(it.getString());
 }
  To iterate over code point ranges use a loop like this:
  
 for (UnicodeSetIterator it = new UnicodeSetIterator(set); it.nextRange();) {
   if (it.codepoint != UnicodeSetIterator.IS_STRING) {
     processCodepointRange(it.codepoint it.codepointEnd);
   } else {
     processString(it.getString());
   }
 }
  Warning:  For speed UnicodeSet iteration does not check for concurrent modification.
 Do not alter the UnicodeSet while iterating."
android,icu.text,AlphabeticIndex.Bucket,5,"An index ""bucket"" with a label string and type.
 It is referenced by  AlphabeticIndex#getBucketIndex(CharSequence) 
 and  AlphabeticIndex.ImmutableIndex#getBucketIndex(CharSequence) 
 returned by  AlphabeticIndex.ImmutableIndex#getBucket(int) 
 and  AlphabeticIndex#addRecord(CharSequence Object)  adds a record
 into a bucket according to the record's name."
android,icu.text,AlphabeticIndex.ImmutableIndex,4,"Immutable thread-safe version of  AlphabeticIndex .
 This class provides thread-safe methods for bucketing
 and random access to buckets and their properties
 but does not offer adding records to the index."
android,icu.text,BidiClassifier,3,"Overrides default Bidi class values with custom ones.

  The override mechanism requires to define a subclass of
  BidiClassifier  which overrides the  classifier 
 method to assign customized Bidi classes. This may be useful for assigning Bidi classes to PUA characters or
 for special application needs. For instance an application may want to
 handle all spaces like L or R characters (according to the base direction)
 when creating the visual ordering of logical lines which are part of a report
 organized in columns: there should not be interaction between adjacent
 cells. To start using this customized
 classifier with a Bidi object it must be specified by calling the
  Bidi.setCustomClassifier  method; after that the method
  classify  of the custom  BidiClassifier  will be
 called by the UBA implementation any time the class of a character is
 to be determined."
android,icu.text,BidiRun,8,"A BidiRun represents a sequence of characters at the same embedding level.
 The Bidi algorithm decomposes a piece of text into sequences of characters
 at the same embedding level each such sequence is called a ""run"".

  A BidiRun represents such a run by storing its essential properties
 but does not duplicate the characters which form the run.

  The ""limit"" of the run is the position just after the
 last character i.e. one more than that position.

  This class has no public constructor and its members cannot be
 modified by users."
android,icu.text,CaseMap.Lower,3,Lowercasing options and methods. Immutable.
android,icu.text,CaseMap.Title,8,Titlecasing options and methods. Immutable.
android,icu.text,CaseMap.Upper,3,Uppercasing options and methods. Immutable.
android,icu.text,CollationElementIterator,13,"CollationElementIterator  is an iterator created by
 a RuleBasedCollator to walk through a string. The return result of
 each iteration is a 32-bit collation element (CE) that defines the
 ordering priority of the next character or sequence of characters
 in the source string.

  For illustration consider the following in Slovak and in traditional Spanish collation:
  
 ""ca"" -> the first collation element is CE('c') and the second
         collation element is CE('a').
 ""cha"" -> the first collation element is CE('ch') and the second
          collation element is CE('a').
  
 Since the character 'Ã¦' is a composed character of 'a' and 'e' the
 iterator returns two collation elements for the single character 'Ã¦'

 ""Ã¦b"" -> the first collation element is collation_element('a') the
              second collation element is collation_element('e') and the
              third collation element is collation_element('b').
  For collation ordering comparison the collation element results
 can not be compared simply by using basic arithmetic operators
 e.g. < == or > further processing has to be done. Details
 can be found in the ICU
  
 User Guide . An example of using the CollationElementIterator
 for collation ordering comparison is the class
  StringSearch .

  To construct a CollationElementIterator object users
 call the method getCollationElementIterator() on a
 RuleBasedCollator that defines the desired sorting order.

   Example:
  
  String testString = ""This is a test"";
  RuleBasedCollator rbc = new RuleBasedCollator(""&a<b"");
  CollationElementIterator iterator = rbc.getCollationElementIterator(testString);
  int primaryOrder = iterator.IGNORABLE;
  while (primaryOrder != iterator.NULLORDER) {
      int order = iterator.next();
      if (order != iterator.IGNORABLE &&
          order != iterator.NULLORDER) {
          // order is valid not ignorable and we have not passed the end
          // of the iteration we do something
          primaryOrder = CollationElementIterator.primaryOrder(order);
          System.out.println(""Next primary order 0x"" +
                             Integer.toHexString(primaryOrder));
      }
  }
  
 The method next() returns the collation order of the next character based on
 the comparison level of the collator. The method previous() returns the
 collation order of the previous character based on the comparison level of
 the collator. The Collation Element Iterator moves only in one direction
 between calls to reset() setOffset() or setText(). That is next() and
 previous() can not be inter-used. Whenever previous() is to be called after
 next() or vice versa reset() setOffset() or setText() has to be called first
 to reset the status shifting current position to either the end or the start of
 the string (reset() or setText()) or the specified position (setOffset()).
 Hence at the next call of next() or previous() the first or last collation order
 or collation order at the specified position will be returned. If a change of
 direction is done without one of these calls the result is undefined.
  
 This class is not subclassable."
android,icu.text,CurrencyPluralInfo,11,"This class represents the information needed by
 DecimalFormat to format currency plural
 such as ""3.00 US dollars"" or ""1.00 US dollar"".
 DecimalFormat creates for itself an instance of
 CurrencyPluralInfo from its locale data.
 If you need to change any of these symbols you can get the
 CurrencyPluralInfo object from your
 DecimalFormat and modify it.

 Following are the information needed for currency plural format and parse:
 locale information
 plural rule of the locale
 currency plural pattern of the locale."
android,icu.text,DateFormat,60,"[icu enhancement]  ICU's replacement for  DateFormat .Â Methods fields and other functionality specific to ICU are labeled ' [icu] '.

  
 DateFormat is an abstract class for date/time formatting subclasses which formats and parses dates or time in a
 language-independent manner. The date/time formatting subclass such as SimpleDateFormat allows for formatting
 (i.e. date -> text) parsing (text -> date) and normalization. The date is represented as a  Date 
 object or as the milliseconds since January 1 1970 00:00:00 GMT.

  
 DateFormat helps you to format and parse dates for any locale. Your code can be completely independent of the locale
 conventions for months days of the week or even the calendar format: lunar vs. solar. It provides many class
 methods for obtaining default date/time formatters based on the default for a given locale and a number of formatting
 styles or arbitrary ""skeletons"".
  The formatting styles include FULL LONG MEDIUM and SHORT. More detail and examples of using these styles are
 provided in the method descriptions.
  The formatting styles only cover a fraction of the necessary usage. You often need to have just certain
 combinations of fields like Month and Year but have it to be formatted appropriate to a given locale. This is done
 using the (misnamed) getPatternInstance() method supplying a skeleton. There are a number of constants that have
 common pre-defined skeletons such as  MINUTE_SECOND  for something like ""13:45"" or  YEAR_ABBR_MONTH 
 for something like ""Sept 2012"".
  
 To format a date for the current Locale use one of the static factory methods:

  
 myString = DateFormat.getDateInstance().format(myDate);
 myString = DateFormat.getPatternInstance(DateFormat.YEAR_ABBR_MONTH).format(myDate);
  
 If you are formatting multiple numbers it is more efficient to get the format and use it multiple times so that the
 system doesn't have to fetch the information about the local language and country conventions multiple times.

  
 DateFormat df = DateFormat.getDateInstance();
 for (int i = 0; i < a.length; ++i) {
     output.println(df.format(myDate[i]) + ""; "");
 }
  
 To format a date for a different Locale specify it in the call to getDateInstance().

  
 DateFormat df = DateFormat.getDateInstance(DateFormat.LONG Locale.FRANCE);
  
 You can use a DateFormat to parse also.

  
 myDate = df.parse(myString);
  
 There are many static factory methods available. Use getDateInstance to get the normal date format for that country.
 Use getTimeInstance to get the time format for that country. Use getDateTimeInstance to get a date and time format.
 You can pass in different options to these factory methods to control the length of the result; from SHORT to MEDIUM
 to LONG to FULL. The exact result depends on the locale but generally:
  SHORT is completely numeric such as 12.13.52 or 3:30pm
  MEDIUM is longer such as Jan 12 1952
  LONG is longer such as January 12 1952 or 3:30:32pm
  FULL is pretty completely specified such as Tuesday April 12 1952 AD or 3:30:42pm PST.
  
 Use getPatternInstance to format with a skeleton. Typically this is with a predefined skeleton like
  YEAR_ABBR_MONTH  for something like ""Sept 2012"". If you don't want to use one of the predefined skeletons
 you can supply your own. The skeletons are like the patterns in SimpleDateFormat except they:
  only keep the field pattern letter and ignore all other parts in a pattern such as space punctuation and
 string literals.
  are independent of the order of fields.
  ignore certain differences in the field's pattern letter length:
  For those non-digit calendar fields the pattern letter length is important such as MMM MMMM and MMMMM; E and
 EEEE and the field's pattern letter length is honored.
  For the digit calendar fields such as M or MM d or dd yy or yyyy the field pattern length is ignored and the
 best match which is defined in date time patterns will be returned without honor the field pattern letter length in
 skeleton.
  
 You can also set the time zone on the format if you wish. If you want even more control over the format or parsing
 (or want to give your users more control) you can try casting the DateFormat you get from the factory methods to a
 SimpleDateFormat. This will work for the majority of countries; just remember to put it in a try block in case you
 encounter an unusual one.

  
 You can also use forms of the parse and format methods with ParsePosition and FieldPosition to allow you to
  progressively parse through pieces of a string.
  align any particular field or find out where it is for selection on the screen.
  Synchronization"
android,icu.text,DateIntervalFormat,15,"DateIntervalFormat is a class for formatting and parsing date
 intervals in a language-independent manner.
 Only formatting is supported. Parsing is not supported.

  
 Date interval means from one date to another date
 for example from ""Jan 11 2008"" to ""Jan 18 2008"".
 We introduced class DateInterval to represent it.
 DateInterval is a pair of UDate which is
 the standard milliseconds since 24:00 GMT Jan 1 1970.

  
 DateIntervalFormat formats a DateInterval into
 text as compactly as possible.
 For example the date interval format from ""Jan 11 2008"" to ""Jan 18. 2008""
 is ""Jan 11-18 2008"" for English.
 And it parses text into DateInterval
 although initially parsing is not supported.

  
 There is no structural information in date time patterns.
 For any punctuations and string literals inside a date time pattern
 we do not know whether it is just a separator or a prefix or a suffix.
 Without such information so it is difficult to generate a sub-pattern
 (or super-pattern) by algorithm.
 So formatting a DateInterval is pattern-driven. It is very
 similar to formatting in SimpleDateFormat.
 We introduce class DateIntervalInfo to save date interval
 patterns similar to date time pattern in SimpleDateFormat.

  
 Logically the interval patterns are mappings
 from (skeleton the_largest_different_calendar_field)
 to (date_interval_pattern).

  
 A skeleton
  
 only keeps the field pattern letter and ignores all other parts
 in a pattern such as space punctuations and string literals.
  
 hides the order of fields.
  
 might hide a field's pattern letter length.

 For those non-digit calendar fields the pattern letter length is
 important such as MMM MMMM and MMMMM; EEE and EEEE
 and the field's pattern letter length is honored.

 For the digit calendar fields  such as M or MM d or dd yy or yyyy
 the field pattern length is ignored and the best match which is defined
 in date time patterns will be returned without honor the field pattern
 letter length in skeleton.
  
 The calendar fields we support for interval formatting are:
 year month date day-of-week am-pm hour hour-of-day minute and
 second (though we do not currently have specific intervalFormat data for
 skeletons with seconds).
 Those calendar fields can be defined in the following order:
 year > month > date > hour (in day) > minute > second

 The largest different calendar fields between 2 calendars is the
 first different calendar field in above order.

 For example: the largest different calendar fields between ""Jan 10 2007""
 and ""Feb 20 2008"" is year.

  
 For other calendar fields the compact interval formatting is not
 supported. And the interval format will be fall back to fall-back
 patterns which is mostly ""{date0} - {date1}"".

  
 There is a set of pre-defined static skeleton strings in DateFormat
 There are pre-defined interval patterns for those pre-defined skeletons
 in locales' resource files.
 For example for a skeleton YEAR_ABBR_MONTH_DAY which is  ""yMMMd""
 in  en_US if the largest different calendar field between date1 and date2
 is ""year"" the date interval pattern  is ""MMM d yyyy - MMM d yyyy""
 such as ""Jan 10 2007 - Jan 10 2008"".
 If the largest different calendar field between date1 and date2 is ""month""
 the date interval pattern is ""MMM d - MMM d yyyy""
 such as ""Jan 10 - Feb 10 2007"".
 If the largest different calendar field between date1 and date2 is ""day""
 the date interval pattern is """"MMM d-d yyyy"" such as ""Jan 10-20 2007"".

 For date skeleton the interval patterns when year or month or date is
 different are defined in resource files.
 For time skeleton the interval patterns when am/pm or hour or minute is
 different are defined in resource files.

  
 If a skeleton is not found in a locale's DateIntervalInfo which means
 the interval patterns for the skeleton is not defined in resource file
 the interval pattern will falls back to the interval ""fallback"" pattern
 defined in resource file.
 If the interval ""fallback"" pattern is not defined the default fall-back
 is ""{date0} - {data1}"".

  
 For the combination of date and time
 The rule to genearte interval patterns are:
  
    when the year month or day differs falls back to fall-back
    interval pattern which mostly is the concatenate the two original
    expressions with a separator between
    For example interval pattern from ""Jan 10 2007 10:10 am""
    to ""Jan 11 2007 10:10am"" is
    ""Jan 10 2007 10:10 am - Jan 11 2007 10:10am""
  
    otherwise present the date followed by the range expression
    for the time.
    For example interval pattern from ""Jan 10 2007 10:10 am""
    to ""Jan 10 2007 11:10am"" is ""Jan 10 2007 10:10 am - 11:10am""
  
 If two dates are the same the interval pattern is the single date pattern.
 For example interval pattern from ""Jan 10 2007"" to ""Jan 10 2007"" is
 ""Jan 10 2007"".

 Or if the presenting fields between 2 dates have the exact same values
 the interval pattern is the  single date pattern.
 For example if user only requests year and month
 the interval pattern from ""Jan 10 2007"" to ""Jan 20 2007"" is ""Jan 2007"".

  
 DateIntervalFormat needs the following information for correct
 formatting: time zone calendar type pattern date format symbols
 and date interval patterns.
 It can be instantiated in several ways:
  
    create an instance using default or given locale plus given skeleton.
    Users are encouraged to created date interval formatter this way and
    to use the pre-defined skeleton macros such as
    YEAR_NUM_MONTH which consists the calendar fields and
    the format style.
  
    create an instance using default or given locale plus given skeleton
    plus a given DateIntervalInfo.
    This factory method is for powerful users who want to provide their own
    interval patterns.
    Locale provides the timezone calendar and format symbols information.
    Local plus skeleton provides full pattern information.
    DateIntervalInfo provides the date interval patterns.
  
 For the calendar field pattern letter such as G y M d a h H m s etc.
 DateIntervalFormat uses the same syntax as that of
 DateTime format.

  
 Code Sample: general usage
  

   // the date interval object which the DateIntervalFormat formats on
   // and parses into
   DateInterval dtInterval = new DateInterval(1000*3600*24L 1000*3600*24*2L);
   DateIntervalFormat dtIntervalFmt = DateIntervalFormat.getInstance(
                   YEAR_MONTH_DAY Locale(""en"" ""GB"" """"));
   StringBuffer str = new StringBuffer("""");
   FieldPosition pos = new FieldPosition(0);
   // formatting
   dtIntervalFmt.format(dtInterval dateIntervalString pos);

  
 Code Sample: for powerful users who wants to use their own interval pattern
  

     import android.icu.text.DateIntervalInfo;
     import android.icu.text.DateIntervalFormat;
     ....................

     // Get DateIntervalFormat instance using default locale
     DateIntervalFormat dtitvfmt = DateIntervalFormat.getInstance(YEAR_MONTH_DAY);

     // Create an empty DateIntervalInfo object which does not have any interval patterns inside.
     dtitvinf = new DateIntervalInfo();

     // a series of set interval patterns.
     // Only ERA YEAR MONTH DATE  DAY_OF_MONTH DAY_OF_WEEK AM_PM  HOUR HOUR_OF_DAY
     MINUTE and SECOND are supported.
     dtitvinf.setIntervalPattern(""yMMMd"" Calendar.YEAR ""'y ~ y'"");
     dtitvinf.setIntervalPattern(""yMMMd"" Calendar.MONTH ""yyyy 'diff' MMM d - MMM d"");
     dtitvinf.setIntervalPattern(""yMMMd"" Calendar.DATE ""yyyy MMM d ~ d"");
     dtitvinf.setIntervalPattern(""yMMMd"" Calendar.HOUR_OF_DAY ""yyyy MMM d HH:mm ~ HH:mm"");

     // Set fallback interval pattern. Fallback pattern is used when interval pattern is not found.
     // If the fall-back pattern is not set  falls back to {date0} - {date1} if interval pattern is not found.
     dtitvinf.setFallbackIntervalPattern(""{0} - {1}"");

     // Set above DateIntervalInfo object as the interval patterns of date interval formatter
     dtitvfmt.setDateIntervalInfo(dtitvinf);

     // Prepare to format
     pos = new FieldPosition(0);
     str = new StringBuffer("""");

     // The 2 calendars should be equivalent otherwise  IllegalArgumentException will be thrown by format()
     Calendar fromCalendar = (Calendar) dtfmt.getCalendar().clone();
     Calendar toCalendar = (Calendar) dtfmt.getCalendar().clone();
     fromCalendar.setTimeInMillis(....);
     toCalendar.setTimeInMillis(...);

     //Formatting given 2 calendars
     dtitvfmt.format(fromCalendar toCalendar str pos);


  Synchronization"
android,icu.text,DateIntervalInfo.PatternInfo,6,"PatternInfo class saves the first and second part of interval pattern
 and whether the interval pattern is earlier date first."
android,icu.text,DateTimePatternGenerator,25,"This class provides flexible generation of date format patterns like
 ""yy-MM-dd"". The user can build up the generator by adding successive
 patterns. Once that is done a query can be made using a ""skeleton"" which is
 a pattern which just includes the desired fields and lengths. The generator
 will return the ""best fit"" pattern corresponding to that skeleton.
  
 The main method people will use is getBestPattern(String skeleton) since
 normally this class is pre-built with data from a particular locale. However
 generators can be built directly from other data as well."
android,icu.text,DecimalFormat,89,"[icu enhancement]  ICU's replacement for  DecimalFormat .Â Methods fields and other functionality specific to ICU are labeled ' [icu] '.

  DecimalFormat  is the primary
 concrete subclass of  NumberFormat . It has a variety of features designed to make it
 possible to parse and format numbers in any locale including support for Western Arabic or
 Indic digits. It supports different flavors of numbers including integers (""123"") fixed-point
 numbers (""123.4"") scientific notation (""1.23E4"") percentages (""12%"") and currency amounts
 (""$123.00"" ""USD123.00"" ""123.00 US dollars""). All of these flavors can be easily localized.

  To obtain a number formatter for a specific locale (including the default locale) call one of
 NumberFormat's factory methods such as  NumberFormat#getInstance . Do not call
 DecimalFormat constructors directly unless you know what you are doing.

  DecimalFormat aims to comply with the specification  UTS #35 . Read
 the specification for more information on how all the properties in DecimalFormat fit together.

  NOTE:  Starting in ICU 60 there is a new set of APIs for localized number
 formatting that are designed to be an improvement over DecimalFormat.  New users are discouraged
 from using DecimalFormat.  For more information see the package android.icu.number.

  Example Usage Customize settings on a DecimalFormat instance from the NumberFormat factory:

  
 NumberFormat f = NumberFormat.getInstance(loc);
 if (f instanceof DecimalFormat) {
     ((DecimalFormat) f).setDecimalSeparatorAlwaysShown(true);
     ((DecimalFormat) f).setMinimumGroupingDigits(2);
 }
  Quick and dirty print out a number using the localized number currency and percent format
 for each locale:

  
 for (ULocale uloc : ULocale.getAvailableLocales()) {
     System.out.print(uloc + "":\t"");
     System.out.print(NumberFormat.getInstance(uloc).format(1.23));
     System.out.print(""\t"");
     System.out.print(NumberFormat.getCurrencyInstance(uloc).format(1.23));
     System.out.print(""\t"");
     System.out.print(NumberFormat.getPercentInstance(uloc).format(1.23));
     System.out.println();
 }
  Properties and Symbols A DecimalFormat object encapsulates a set of  properties  and a set of
  symbols . Grouping size rounding mode and affixes are examples of properties. Locale
 digits and the characters used for grouping and decimal separators are examples of symbols.

  To set a custom set of symbols use  setDecimalFormatSymbols(DecimalFormatSymbols) . Use the various other
 setters in this class to set custom values for the properties.

  Rounding DecimalFormat provides three main strategies to specify the position at which numbers should
 be rounded:

  Magnitude:  Display a fixed number of fraction digits; this is the most
       common form.
    Increment:  Round numbers to the closest multiple of a certain increment
       such as 0.05. This is common in currencies.
    Significant Digits:  Round numbers such that a fixed number of nonzero
       digits are shown. This is most common in scientific notation.
  It is not possible to specify more than one rounding strategy. For example setting a rounding
 increment in conjunction with significant digits results in undefined behavior.

  It is also possible to specify the  rounding mode  to use. The default rounding mode is
 ""half even"" which rounds numbers to their closest increment with ties broken in favor of
 trailing numbers being even. For more information see  setRoundingMode(int)  and  the ICU User
 Guide .

  Pattern Strings A  pattern string  is a way to serialize some of the available properties for decimal
 formatting. However not all properties are capable of being serialized into a pattern string;
 see  applyPattern(String)  for more information.

  Most users should not need to interface with pattern strings directly.

  ICU DecimalFormat aims to follow the specification for pattern strings in  UTS #35 .
 Refer to that specification for more information on pattern string syntax.

  Pattern String BNF 
 pattern    := subpattern (';' subpattern)?
 subpattern := prefix? number exponent? suffix?
 number     := (integer ('.' fraction)?) | sigDigits
 prefix     := '\u0000'..'\uFFFD' - specialCharacters
 suffix     := '\u0000'..'\uFFFD' - specialCharacters
 integer    := '#'* '0'* '0'
 fraction   := '0'* '#'*
 sigDigits  := '#'* '@' '@'* '#'*
 exponent   := 'E' '+'? '0'* '0'
 padSpec    := '*' padChar
 padChar    := '\u0000'..'\uFFFD' - quote
  
 Notation:
   X*       0 or more instances of X
   X?       0 or 1 instances of X
   X|Y      either X or Y
   C..D     any character from C up to D inclusive
   S-T      characters in S except those in T
  The first subpattern is for positive numbers. The second (optional) subpattern is for negative
 numbers.

  Not indicated in the BNF syntax above:

  The grouping separator '' can occur inside the integer and sigDigits elements between any
       two pattern characters of that element as long as the integer or sigDigits element is not
       followed by the exponent element.
    Two grouping intervals are recognized: That between the decimal point and the first
       grouping symbol and that between the first and second grouping symbols. These intervals
       are identical in most locales but in some locales they differ. For example the pattern
       ""######"" formats the number 123456789 as ""123456789"".
    The pad specifier  padSpec  may appear before the prefix after the prefix
       before the suffix after the suffix or not at all.
    In place of '0' the digits '1' through '9' may be used to indicate a rounding increment.
  Parsing DecimalFormat aims to be able to parse anything that it can output as a formatted string.

  There are two primary parse modes:  lenient  and  strict . Lenient mode should
 be used if the goal is to parse user input to a number; strict mode should be used if the goal is
 validation. The default is lenient mode. For more information see  setParseStrict(boolean) .

  DecimalFormat  parses all Unicode characters that represent decimal digits as
 defined by  UCharacter#digit . In addition  DecimalFormat  also recognizes as
 digits the ten consecutive characters starting with the localized zero digit defined in the
  DecimalFormatSymbols  object. During formatting the  DecimalFormatSymbols -based
 digits are output.

  Grouping separators are ignored in lenient mode (default). In strict mode grouping separators
 must match the locale-specified grouping sizes.

  When using  parseCurrency(CharSequence ParsePosition)  all currencies are accepted not just the currency
 currently set in the formatter. In addition the formatter is able to parse every currency style
 format for a particular locale no matter which style the formatter is constructed with. For
 example a formatter instance gotten from NumberFormat.getInstance(ULocale
 NumberFormat.CURRENCYSTYLE) can parse both ""USD1.00"" and ""3.00 US dollars"".

  Whitespace characters (lenient mode) and control characters (lenient and strict mode)
 collectively called ""ignorables"" do not need to match in identity or quantity between the
 pattern string and the input string. For example the pattern ""# %"" matches ""35 %"" (with a single
 space) ""35%"" (with no space) ""35Â %"" (with a non-breaking space) and ""35Â  %"" (with
 multiple spaces). Arbitrary ignorables are also allowed at boundaries between the parts of the
 number: prefix number exponent separator and suffix. Ignorable whitespace characters are those
 having the Unicode ""blank"" property for regular expressions defined in UTS #18 Annex C which is
 ""horizontal"" whitespace like spaces and tabs but not ""vertical"" whitespace like line breaks.
 Ignorable control characters are those in the Unicode set [:Default_Ignorable_Code_Point:].

  If  parse(java.lang.String java.text.ParsePosition)  fails to parse a string it returns  null 
 and leaves the parse position unchanged. The convenience method  NumberFormat.parse(java.lang.String)  indicates
 parse failure by throwing a  ParseException .

  Under the hood a state table parsing engine is used. To debug a parsing failure during
 development use the following pattern to print details about the state table transitions:

  
 android.icu.impl.number.Parse.DEBUGGING = true;
 df.parse(""123.45"" ppos);
 android.icu.impl.number.Parse.DEBUGGING = false;
  Thread Safety and Best Practices Starting with ICU 59 instances of DecimalFormat are thread-safe.

  Under the hood DecimalFormat maintains an immutable formatter object that is rebuilt whenever
 any of the property setters are called. It is therefore best practice to call property setters
 only during construction and not when formatting numbers online."
android,icu.text,DecimalFormatSymbols,72,"[icu enhancement]  ICU's replacement for  DecimalFormatSymbols .Â Methods fields and other functionality specific to ICU are labeled ' [icu] '.

 This class represents the set of symbols (such as the decimal separator the grouping
 separator and so on) needed by  DecimalFormat  to format
 numbers.  DecimalFormat  creates for itself an instance of
  DecimalFormatSymbols  from its locale data.  If you need to change any of
 these symbols you can get the  DecimalFormatSymbols  object from your
  DecimalFormat  and modify it."
android,icu.text,Edits.Iterator,12,"Access to the list of edits.
  
 At any moment in time an instance of this class points to a single edit: a ""window"" into a span
 of the source string and the corresponding span of the destination string. The source string span
 starts at  sourceIndex()  and runs for  oldLength()  chars; the destination string
 span starts at  destinationIndex()  and runs for  newLength()  chars.
  
 The iterator can be moved between edits using the  next()  and
  findSourceIndex(int)  methods. Calling any of these methods mutates the iterator
 to make it point to the corresponding edit.
  
 For more information see the documentation for  Edits .
  
 Note: Although this class is called ""Iterator"" it does not implement  Iterator ."
android,icu.text,IDNA.Info,3,"Output container for IDNA processing errors.
 The Info class is not suitable for subclassing."
android,icu.text,MeasureFormat,17,"A formatter for Measure objects.

  
 To format a Measure object first create a formatter object using a MeasureFormat factory method. Then
 use that object's format or formatMeasures methods.

 Here is sample code:

  
 MeasureFormat fmtFr = MeasureFormat.getInstance(ULocale.FRENCH FormatWidth.SHORT);
 Measure measure = new Measure(23 MeasureUnit.CELSIUS);

 // Output: 23 Â°C
 System.out.println(fmtFr.format(measure));

 Measure measureF = new Measure(70 MeasureUnit.FAHRENHEIT);

 // Output: 70 Â°F
 System.out.println(fmtFr.format(measureF));

 MeasureFormat fmtFrFull = MeasureFormat.getInstance(ULocale.FRENCH FormatWidth.WIDE);
 // Output: 70 pieds et 53 pouces
 System.out.println(fmtFrFull.formatMeasures(new Measure(70 MeasureUnit.FOOT)
         new Measure(5.3 MeasureUnit.INCH)));

 // Output: 1 pied et 1 pouce
 System.out.println(
         fmtFrFull.formatMeasures(new Measure(1 MeasureUnit.FOOT) new Measure(1 MeasureUnit.INCH)));

 MeasureFormat fmtFrNarrow = MeasureFormat.getInstance(ULocale.FRENCH FormatWidth.NARROW);
 // Output: 1â€² 1â€³
 System.out.println(fmtFrNarrow.formatMeasures(new Measure(1 MeasureUnit.FOOT)
         new Measure(1 MeasureUnit.INCH)));

 MeasureFormat fmtEn = MeasureFormat.getInstance(ULocale.ENGLISH FormatWidth.WIDE);

 // Output: 1 inch 2 feet
 fmtEn.formatMeasures(new Measure(1 MeasureUnit.INCH) new Measure(2 MeasureUnit.FOOT));
  
 This class does not do conversions from one unit to another. It simply formats whatever units it is
 given
  
 This class is immutable and thread-safe so long as its deprecated subclass TimeUnitFormat is never
 used. TimeUnitFormat is not thread-safe and is mutable. Although this class has existing subclasses
 this class does not support new sub-classes."
android,icu.text,MessageFormat.Field,0,"Defines constants that are used as attribute keys in the
  AttributedCharacterIterator  returned
 from  MessageFormat.formatToCharacterIterator ."
android,icu.text,MessagePattern,28,"Parses and represents ICU MessageFormat patterns.
 Also handles patterns for ChoiceFormat PluralFormat and SelectFormat.
 Used in the implementations of those classes as well as in tools
 for message validation translation and format conversion.
  
 The parser handles all syntax relevant for identifying message arguments.
 This includes ""complex"" arguments whose style strings contain
 nested MessageFormat pattern substrings.
 For ""simple"" arguments (with no nested MessageFormat pattern substrings)
 the argument style is not parsed any further.
  
 The parser handles named and numbered message arguments and allows both in one message.
  
 Once a pattern has been parsed successfully iterate through the parsed data
 with countParts() getPart() and related methods.
  
 The data logically represents a parse tree but is stored and accessed
 as a list of ""parts"" for fast and simple parsing and to minimize object allocations.
 Arguments and nested messages are best handled via recursion.
 For every _START ""part""  getLimitPartIndex(int)  efficiently returns
 the index of the corresponding _LIMIT ""part"".
  
 List of ""parts"":
  
 message = MSG_START (SKIP_SYNTAX | INSERT_CHAR | REPLACE_NUMBER | argument)* MSG_LIMIT
 argument = noneArg | simpleArg | complexArg
 complexArg = choiceArg | pluralArg | selectArg

 noneArg = ARG_START.NONE (ARG_NAME | ARG_NUMBER) ARG_LIMIT.NONE
 simpleArg = ARG_START.SIMPLE (ARG_NAME | ARG_NUMBER) ARG_TYPE [ARG_STYLE] ARG_LIMIT.SIMPLE
 choiceArg = ARG_START.CHOICE (ARG_NAME | ARG_NUMBER) choiceStyle ARG_LIMIT.CHOICE
 pluralArg = ARG_START.PLURAL (ARG_NAME | ARG_NUMBER) pluralStyle ARG_LIMIT.PLURAL
 selectArg = ARG_START.SELECT (ARG_NAME | ARG_NUMBER) selectStyle ARG_LIMIT.SELECT

 choiceStyle = ((ARG_INT | ARG_DOUBLE) ARG_SELECTOR message)+
 pluralStyle = [ARG_INT | ARG_DOUBLE] (ARG_SELECTOR [ARG_INT | ARG_DOUBLE] message)+
 selectStyle = (ARG_SELECTOR message)+
  Literal output text is not represented directly by ""parts"" but accessed
       between parts of a message from one part's getLimit() to the next part's getIndex().
    ARG_START.CHOICE  stands for an ARG_START Part with ArgType CHOICE.
    In the choiceStyle the ARG_SELECTOR has the '<' the '#' or
       the less-than-or-equal-to sign (U+2264).
    In the pluralStyle the first optional numeric Part has the ""offset:"" value.
       The optional numeric Part between each (ARG_SELECTOR message) pair
       is the value of an explicit-number selector like ""=2""
       otherwise the selector is a non-numeric identifier.
    The REPLACE_NUMBER Part can occur only in an immediate sub-message of the pluralStyle.
  
 This class is not intended for public subclassing."
android,icu.text,Normalizer,5,"Old Unicode normalization API.

  This API has been replaced by the  Normalizer2  class and is only available
 for backward compatibility. This class simply delegates to the Normalizer2 class.
 There are two exceptions: The new API does not provide a replacement for
  QuickCheckResult  and  compare() .

  normalize  transforms Unicode text into an equivalent composed or
 decomposed form allowing for easier sorting and searching of text.
  normalize  supports the standard normalization forms described in
  
 Unicode Standard Annex #15 â€” Unicode Normalization Forms .

  Characters with accents or other adornments can be encoded in
 several different ways in Unicode.  For example take the character A-acute.
 In Unicode this can be encoded as a single character (the
 ""composed"" form):

  
      00C1    LATIN CAPITAL LETTER A WITH ACUTE
  
      0041    LATIN CAPITAL LETTER A
      0301    COMBINING ACUTE ACCENT
  To a user of your program however both of these sequences should be
 treated as the same ""user-level"" character ""A with acute accent"".  When you
 are searching or comparing text you must ensure that these two sequences are
 treated equivalently.  In addition you must handle characters with more than
 one accent.  Sometimes the order of a character's combining accents is
 significant while in other cases accent sequences in different orders are
 really equivalent.

  Similarly the string ""ffi"" can be encoded as three separate letters:

  
      0066    LATIN SMALL LETTER F
      0066    LATIN SMALL LETTER F
      0069    LATIN SMALL LETTER I
  
      FB03    LATIN SMALL LIGATURE FFI
  The ffi ligature is not a distinct semantic character and strictly speaking
 it shouldn't be in Unicode at all but it was included for compatibility
 with existing character sets that already provided it.  The Unicode standard
 identifies such characters by giving them ""compatibility"" decompositions
 into the corresponding semantic characters.  When sorting and searching you
 will often want to use these mappings.

  normalize  helps solve these problems by transforming text into
 the canonical composed and decomposed forms as shown in the first example
 above. In addition you can have it perform compatibility decompositions so
 that you can treat compatibility characters the same as their equivalents.
 Finally  normalize  rearranges accents into the proper canonical
 order so that you do not have to worry about accent rearrangement on your
 own.

  Form FCD ""Fast C or D"" is also designed for collation.
 It allows to work on strings that are not necessarily normalized
 with an algorithm (like in collation) that works under ""canonical closure""
 i.e. it treats precomposed characters and their decomposed equivalents the
 same.

  It is not a normalization form because it does not provide for uniqueness of
 representation. Multiple strings may be canonically equivalent (their NFDs
 are identical) and may all conform to FCD without being identical themselves.

  The form is defined such that the ""raw decomposition"" the recursive
 canonical decomposition of each character results in a string that is
 canonically ordered. This means that precomposed characters are allowed for
 as long as their decompositions do not need canonical reordering.

  Its advantage for a process like collation is that all NFD and most NFC texts
 - and many unnormalized texts - already conform to FCD and do not need to be
 normalized (NFD) for such a process. The FCD quick check will return YES for
 most strings in practice.

  normalize(FCD) may be implemented with NFD.

  For more details on FCD see Unicode Technical Note #5 (Canonical Equivalence in Applications):
 http://www.unicode.org/notes/tn5/#FCD

  ICU collation performs either NFD or FCD normalization automatically if
 normalization is turned on for the collator object. Beyond collation and
 string search normalized strings may be useful for string equivalence
 comparisons transliteration/transcription unique representations etc.

  The W3C generally recommends to exchange texts in NFC.
 Note also that most legacy character encodings use only precomposed forms and
 often do not encode any combining marks by themselves. For conversion to such
 character encodings the Unicode text needs to be normalized to NFC.
 For more usage examples see the Unicode Standard Annex.

  Note: The Normalizer class also provides API for iterative normalization.
 While the setIndex() and getIndex() refer to indices in the
 underlying Unicode input text the next() and previous() methods
 iterate through characters in the normalized output.
 This means that there is not necessarily a one-to-one correspondence
 between characters returned by next() and previous() and the indices
 passed to and returned from setIndex() and getIndex().
 It is for this reason that Normalizer does not implement the CharacterIterator interface."
android,icu.text,NumberFormat,63,"[icu enhancement]  ICU's replacement for  NumberFormat .Â Methods fields and other functionality specific to ICU are labeled ' [icu] '.

  IMPORTANT:  New users are strongly encouraged to see if
  NumberFormatter  fits their use case.  Although not deprecated this
 class NumberFormat is only provided for java.text.NumberFormat compatibility.
  NumberFormat NumberFormat NumberFormat 
 To format a number for the current Locale use one of the factory
 class methods:
  
  myString = NumberFormat.getInstance().format(myNumber);
  
 NumberFormat nf = NumberFormat.getInstance();
 for (int i = 0; i < a.length; ++i) {
     output.println(nf.format(myNumber[i]) + ""; "");
 }
  getInstance 
 NumberFormat nf = NumberFormat.getInstance(Locale.FRENCH);
  NumberFormat 
 myNumber = nf.parse(myString);
  getInstance getNumberInstance getIntegerInstance getCurrencyInstance getPercentInstance 
 Starting from ICU 4.2 you can use getInstance() by passing in a 'style'
 as parameter to get the correct instance.
 For example
 use getInstance(...NUMBERSTYLE) to get the normal number format
 getInstance(...PERCENTSTYLE) to get a format for displaying percentage
 getInstance(...SCIENTIFICSTYLE) to get a format for displaying scientific number
 getInstance(...INTEGERSTYLE) to get an integer number format
 getInstance(...CURRENCYSTYLE) to get the currency number format
 in which the currency is represented by its symbol for example ""$3.00"".
 getInstance(...ISOCURRENCYSTYLE)  to get the currency number format
 in which the currency is represented by its ISO code for example ""USD3.00"".
 getInstance(...PLURALCURRENCYSTYLE) to get the currency number format
 in which the currency is represented by its full name in plural format
 for example ""3.00 US dollars"" or ""1.00 US dollar"".


  
 You can also control the display of numbers with such methods as
  setMinimumFractionDigits .
 If you want even more control over the format or parsing
 or want to give your users more control
 you can try casting the  NumberFormat  you get from the factory methods
 to a  DecimalFormat . This will work for the vast majority
 of locales; just remember to put it in a  try  block in case you
 encounter an unusual one.

  
 NumberFormat is designed such that some controls
 work for formatting and others work for parsing.  The following is
 the detailed description for each these control methods
  
 setParseIntegerOnly : only affects parsing e.g.
 if true  ""3456.78"" -> 3456 (and leaves the parse position just after '6')
 if false ""3456.78"" -> 3456.78 (and leaves the parse position just after '8')
 This is independent of formatting.  If you want to not show a decimal point
 where there might be no digits after the decimal point use
 setDecimalSeparatorAlwaysShown on DecimalFormat.
  
 You can also use forms of the  parse  and  format 
 methods with  ParsePosition  and  FieldPosition  to
 allow you to:
   progressively parse through pieces of a string
   align the decimal point and other areas
   If you are using a monospaced font with spacing for alignment
      you can pass the  FieldPosition  in your format call with
       field  =  INTEGER_FIELD . On output
       getEndIndex  will be set to the offset between the
      last character of the integer and the decimal. Add
      (desiredSpaceCount - getEndIndex) spaces at the front of the string.

   If you are using proportional fonts
      instead of padding with spaces measure the width
      of the string in pixels from the start to  getEndIndex .
      Then move the pen by
      (desiredPixelWidth - widthToAlignmentPoint) before drawing the text.
      It also works where there is no decimal but possibly additional
      characters at the end e.g. with parentheses in negative
      numbers: ""(12)"" for -12.
  Synchronization 
 Number formats are generally not synchronized. It is recommended to create
 separate format instances for each thread. If multiple threads access a format
 concurrently it must be synchronized externally.

  DecimalFormat DecimalFormat is the concrete implementation of NumberFormat and the
 NumberFormat API is essentially an abstraction from DecimalFormat's API.
 Refer to DecimalFormat for more information about this API."
android,icu.text,NumberingSystem,11,"NumberingSystem  is the base class for all number
 systems. This class provides the interface for setting different numbering
 system types whether it be a simple alternate digit system such as
 Thai digits or Devanagari digits or an algorithmic numbering system such
 as Hebrew numbering or Chinese numbering."
android,icu.text,PluralRules,14,"Defines rules for mapping non-negative numeric values onto a small set of keywords.
  
 Rules are constructed from a text description consisting of a series of keywords and conditions. The  select(double) 
 method examines each condition in order and returns the keyword for the first condition that matches the number. If
 none match  KEYWORD_OTHER  is returned.
  
 A PluralRules object is immutable. It contains caches for sample values but those are synchronized.
  
 PluralRules is Serializable so that it can be used in formatters which are serializable.
  
 For more information details and tips for writing rules see the  LDML spec C.11 Language Plural
 Rules 
 Examples:
  
 ""one: n is 1; few: n in 2..4""
  
 This defines two rules for 'one' and 'few'. The condition for 'one' is ""n is 1"" which means that the number must be
 equal to 1 for this condition to pass. The condition for 'few' is ""n in 2..4"" which means that the number must be
 between 2 and 4 inclusive - and be an integer - for this condition to pass. All other numbers are assigned the
 keyword ""other"" by the default rule.
  
 ""zero: n is 0; one: n is 1; zero: n mod 100 in 1..19""
  
 This illustrates that the same keyword can be defined multiple times. Each rule is examined in order and the first
 keyword whose condition passes is the one returned. Also notes that a modulus is applied to n in the last rule. Thus
 its condition holds for 119 219 319...
  
 ""one: n is 1; few: n mod 10 in 2..4 and n mod 100 not in 12..14""
  
 This illustrates conjunction and negation. The condition for 'few' has two parts both of which must be met:
 ""n mod 10 in 2..4"" and ""n mod 100 not in 12..14"". The first part applies a modulus to n before the test as in the
 previous example. The second part applies a different modulus and also uses negation thus it matches all numbers
 _not_ in 12 13 14 112 113 114 212 213 214...
  
 Syntax:
  
 rules         = rule (';' rule)*
 rule          = keyword ':' condition
 keyword       = <identifier>
 condition     = and_condition ('or' and_condition)*
 and_condition = relation ('and' relation)*
 relation      = not? expr not? rel not? range_list
 expr          = ('n' | 'i' | 'f' | 'v' | 't') (mod value)?
 not           = 'not' | '!'
 rel           = 'in' | 'is' | '=' | 'â‰ ' | 'within'
 mod           = 'mod' | '%'
 range_list    = (range | value) ('' range_list)*
 value         = digit+
 digit         = 0|1|2|3|4|5|6|7|8|9
 range         = value'..'value
  Each  not  term inverts the meaning; however there should not be more than one of them. 
 The i f t and v values are defined as follows:
  i to be the integer digits. f to be the visible decimal digits as an integer. t to be the visible decimal digitsâ€”without trailing zerosâ€”as an integer. v to be the number of visible fraction digits. j is defined to only match integers. That is j is 3 fails if v != 0 (eg for 3.1 or 3.0). 
 Examples are in the following table:
  n i f v 1.0 1 0 1 1.00 1 0 2 1.3 1 3 1 1.03 1 3 2 1.23 1 23 2 
 An ""identifier"" is a sequence of characters that do not have the Unicode Pattern_Syntax or Pattern_White_Space
 properties.
  
 The difference between 'in' and 'within' is that 'in' only includes integers in the specified range while 'within'
 includes all values. Using 'within' with a range_list consisting entirely of values is the same as using 'in' (it's
 not an error)."
android,icu.text,SelectFormat,8,"SelectFormat  supports the creation of  internationalized
 messages by selecting phrases based on keywords. The pattern  specifies
 how to map keywords to phrases and provides a default phrase. The
 object provided to the format method is a string that's matched
 against the keywords. If there is a match the corresponding phrase
 is selected; otherwise the default phrase is used.

  Using  SelectFormat  for Gender Agreement Note: Typically select formatting is done via  MessageFormat 
 with a  select  argument type
 rather than using a stand-alone  SelectFormat .

  The main use case for the select format is gender based  inflection.
 When names or nouns are inserted into sentences their gender can  affect pronouns
 verb forms articles and adjectives. Special care needs to be
 taken for the case where the gender cannot be determined.
 The impact varies between languages:

  English has three genders and unknown gender is handled as a  special
 case. Names use the gender of the named person (if known) nouns  referring
 to people use natural gender and inanimate objects are usually  neutral.
 The gender only affects pronouns: ""he"" ""she"" ""it"" ""they"".

  German differs from English in that the gender of nouns is  rather
 arbitrary even for nouns referring to people (""MÃ¤dchen"" girl is  neutral).
 The gender affects pronouns (""er"" ""sie"" ""es"") articles (""der""  ""die""
 ""das"") and adjective forms (""guter Mann"" ""gute Frau"" ""gutes  MÃ¤dchen"").

  French has only two genders; as in German the gender of nouns
 is rather arbitrary - for sun and moon the genders
 are the opposite of those in German. The gender affects
 pronouns (""il"" ""elle"") articles (""le"" ""la"")
 adjective forms (""bon"" ""bonne"") and sometimes
 verb forms (""allÃ©"" ""allÃ©e"").

  Polish distinguishes five genders (or noun classes)
 human masculine animate non-human masculine inanimate masculine
 feminine and neuter.
  Some other languages have noun classes that are not related to  gender
 but similar in grammatical use.
 Some African languages have around 20 noun classes.

  Note: For the gender of a  person  in a given sentence
 we usually need to distinguish only between female male and other/unknown.

  To enable localizers to create sentence patterns that take their
 language's gender dependencies into consideration software has to  provide
 information about the gender associated with a noun or name to
  MessageFormat .
 Two main cases can be distinguished:

  For people natural gender information should be maintained  for each person.
 Keywords like ""male"" ""female"" ""mixed"" (for groups of people)
 and ""unknown"" could be used.

  For nouns grammatical gender information should be maintained  for
 each noun and per language e.g. in resource bundles.
 The keywords ""masculine"" ""feminine"" and ""neuter"" are commonly  used
 but some languages may require other keywords.
  The resulting keyword is provided to  MessageFormat   as a
 parameter separate from the name or noun it's associated with. For  example
 to generate a message such as ""Jean went to Paris"" three separate  arguments
 would be provided: The name of the person as argument 0 the  gender of
 the person as argument 1 and the name of the city as argument 2.
 The sentence pattern for English where the gender of the person has
 no impact on this simple sentence would not refer to argument 1  at all:

  {0} went to {2}. Note:  The entire sentence should be included (and partially repeated)
 inside each phrase. Otherwise translators would have to be trained on how to
 move bits of the sentence in and out of the select argument of a message.
 (The examples below do not follow this recommendation!)

  The sentence pattern for French where the gender of the person affects
 the form of the participle uses a select format based on argument 1:

  {0} est {1 select female {allÃ©e} other {allÃ©}} Ã  {2}. Patterns can be nested so that it's possible to handle  interactions of
 number and gender where necessary. For example if the above  sentence should
 allow for the names of several people to be inserted the  following sentence
 pattern can be used (with argument 0 the list of people's names
 argument 1 the number of people argument 2 their combined gender and
 argument 3 the city name):

  {0} {1 plural
 one {est {2 select female {allÃ©e} other  {allÃ©}}}
 other {sont {2 select female {allÃ©es} other {allÃ©s}}}
 }Ã  {3}. Patterns and Their Interpretation The  SelectFormat  pattern string defines the phrase  output
 for each user-defined keyword.
 The pattern is a sequence of (keyword message) pairs.
 A keyword is a ""pattern identifier"": [^[[:Pattern_Syntax:][:Pattern_White_Space:]]]+

  Each message is a MessageFormat pattern string enclosed in {curly braces}.

  You always have to define a phrase for the default keyword
  other ; this phrase is returned when the keyword
 provided to
 the  format  method matches no other keyword.
 If a pattern does not provide a phrase for  other  the  method
 it's provided to returns the error   U_DEFAULT_KEYWORD_MISSING .
  
 Pattern_White_Space between keywords and messages is ignored.
 Pattern_White_Space within a message is preserved and output.

  Example:
 MessageFormat msgFmt = new MessageFormat(""{0} est "" +
     ""{1 select female {allÃ©e} other {allÃ©}} Ã  Paris.""
     new ULocale(""fr""));
 Object args[] = {""Kirti""""female""};
 System.out.println(msgFmt.format(args));
  
 Produces the output: Kirti est allÃ©e Ã  Paris."
android,icu.text,SimpleDateFormat,27,"[icu enhancement]  ICU's replacement for  SimpleDateFormat .Â Methods fields and other functionality specific to ICU are labeled ' [icu] '.

  SimpleDateFormat  is a concrete class for formatting and
 parsing dates in a locale-sensitive manner. It allows for formatting
 (date -> text) parsing (text -> date) and normalization.

  SimpleDateFormat  allows you to start by choosing
 any user-defined patterns for date-time formatting. However you
 are encouraged to create a date-time formatter with either
  getTimeInstance   getDateInstance  or
  getDateTimeInstance  in  DateFormat . Each
 of these class methods can return a date/time formatter initialized
 with a default format pattern. You may modify the format pattern
 using the  applyPattern  methods as desired.
 For more information on using these methods see
  DateFormat .

  Date and Time Patterns: Date and time formats are specified by  date and time pattern  strings.
 Within date and time pattern strings all unquoted ASCII letters [A-Za-z] are reserved
 as pattern letters representing calendar fields.  SimpleDateFormat  supports
 the date and time formatting algorithm and pattern letters defined by  UTS#35
 Unicode Locale Data Markup Language (LDML) . The following pattern letters are
 currently available (note that the actual values depend on CLDR and may change from the
 examples shown here): Field Sym. No. Example Description era G 1..3 AD Era - Replaced with the Era string for the current date. One to three letters for the
         abbreviated form four letters for the long (wide) form five for the narrow form. 4 Anno Domini 5 A year y 1..n 1996 Year. Normally the length specifies the padding but for two letters it also specifies the maximum
         length. Example:"
android,icu.text,StringSearch,12,"StringSearch  is a  SearchIterator  that provides
 language-sensitive text searching based on the comparison rules defined
 in a  RuleBasedCollator  object.
 StringSearch ensures that language eccentricity can be
 handled e.g. for the German collator characters ÃŸ and SS will be matched
 if case is chosen to be ignored.
 See the  
 ""ICU Collation Design Document""  for more information.
  
 There are 2 match options for selection: 
 Let S' be the sub-string of a text string S between the offsets start and
 end [start end].
  
 A pattern string P matches a text string S at the offsets [start end]
 if
  
 option 1. Some canonical equivalent of P matches some canonical equivalent
           of S'
 option 2. P matches S' and if P starts or ends with a combining mark
           there exists no non-ignorable combining mark before or after S?
           in S respectively.
  
 This search has APIs similar to that of other text iteration mechanisms
 such as the break iterators in  BreakIterator . Using these
 APIs it is easy to scan through text looking for all occurrences of
 a given pattern. This search iterator allows changing of direction by
 calling a  reset()  followed by a  SearchIterator.next()  or  SearchIterator.previous() .
 Though a direction change can occur without calling  reset()  first
 this operation comes with some speed penalty.
 Match results in the forward direction will match the result matches in
 the backwards direction in the reverse order
  SearchIterator  provides APIs to specify the starting position
 within the text string to be searched e.g.  SearchIterator#setIndex 
  SearchIterator#preceding  and  SearchIterator#following .
 Since the starting position will be set as it is specified please take note that
 there are some danger points at which the search may render incorrect
 results:
   In the midst of a substring that requires normalization.
   If the following match is to be found the position should not be the
      second character which requires swapping with the preceding
      character. Vice versa if the preceding match is to be found the
      position to search from should not be the first character which
      requires swapping with the next character. E.g certain Thai and
      Lao characters require swapping.
   If a following pattern match is to be found any position within a
      contracting sequence except the first will fail. Vice versa if a
      preceding pattern match is to be found an invalid starting point
      would be any character within a contracting sequence except the last.
  
 A  BreakIterator  can be used if only matches at logical breaks are desired.
 Using a  BreakIterator  will only give you results that exactly matches the
 boundaries given by the  BreakIterator . For instance the pattern ""e"" will
 not be found in the string ""Ã©"" if a character break iterator is used.
  
 Options are provided to handle overlapping matches.
 E.g. In English overlapping matches produces the result 0 and 2
 for the pattern ""abab"" in the text ""ababab"" where mutually
 exclusive matches only produces the result of 0.
  
 Options are also provided to implement ""asymmetric search"" as described in
  
 UTS #10 Unicode Collation Algorithm  specifically the ElementComparisonType
 values.
  
 Though collator attributes will be taken into consideration while
 performing matches there are no APIs here for setting and getting the
 attributes. These attributes can be set by getting the collator
 from  getCollator()  and using the APIs in  RuleBasedCollator .
 Lastly to update  StringSearch  to the new collator attributes
  reset()  has to be called.
  
 Restriction:  
 Currently there are no composite characters that consists of a
 character with combining class > 0 before a character with combining
 class == 0. However if such a character exists in the future
  StringSearch  does not guarantee the results for option 1.
  
 Consult the  SearchIterator  documentation for information on
 and examples of how to use instances of this class to implement text
 searching.
  
 Note  StringSearch  is not to be subclassed."
android,icu.text,TimeZoneNames,11,"TimeZoneNames  is an abstract class representing the time zone display name data model defined
 by  UTS#35 Unicode Locale Data Markup Language (LDML) .
 The model defines meta zone which is used for storing a set of display names. A meta zone can be shared
 by multiple time zones. Also a time zone may have multiple meta zone historic mappings.
  
 For example people in the United States refer the zone used by the east part of North America as ""Eastern Time"".
 The tz database contains multiple time zones ""America/New_York"" ""America/Detroit"" ""America/Montreal"" and some
 others that belong to ""Eastern Time"". However assigning different display names to these time zones does not make
 much sense for most of people.
  
 In  CLDR  (which uses LDML for representing locale data) the display name
 ""Eastern Time"" is stored as long generic display name of a meta zone identified by the ID ""America_Eastern"".
 Then there is another table maintaining the historic mapping to meta zones for each time zone. The time zones in
 the above example (""America/New_York"" ""America/Detroit""...) are mapped to the meta zone ""America_Eastern"".
  
 Sometimes a time zone is mapped to a different time zone in the past. For example ""America/Indiana/Knox""
 had been moving ""Eastern Time"" and ""Central Time"" back and forth. Therefore it is necessary that time zone
 to meta zones mapping data are stored by date range.

  Note: TimeZoneFormat  assumes an instance of  TimeZoneNames  is immutable. If you want to provide
 your own  TimeZoneNames  implementation and use it with  TimeZoneFormat  you must follow
 the contract.
  
 The methods in this class assume that time zone IDs are already canonicalized. For example you may not get proper
 result returned by a method with time zone ID ""America/Indiana/Indianapolis"" because it's not a canonical time zone
 ID (the canonical time zone ID for the time zone is ""America/Indianapolis"". See
  TimeZone#getCanonicalID(String)  about ICU canonical time zone IDs.

  
 In CLDR most of time zone display names except location names are provided through meta zones. But a time zone may
 have a specific name that is not shared with other time zones.

 For example time zone ""Europe/London"" has English long name for standard time ""Greenwich Mean Time"" which is also
 shared with other time zones. However the long name for daylight saving time is ""British Summer Time"" which is only
 used for ""Europe/London"".

  getTimeZoneDisplayName(java.lang.String android.icu.text.TimeZoneNames.NameType)  is designed for accessing a name only used by a single time zone.
 But is not necessarily mean that a subclass implementation use the same model with CLDR. A subclass implementation
 may provide time zone names only through  getTimeZoneDisplayName(java.lang.String android.icu.text.TimeZoneNames.NameType)  or only through
  getMetaZoneDisplayName(java.lang.String android.icu.text.TimeZoneNames.NameType)  or both.

  
 The default  TimeZoneNames  implementation returned by  getInstance(android.icu.util.ULocale)  uses the locale data
 imported from CLDR. In CLDR set of meta zone IDs and mappings between zone IDs and meta zone IDs are shared by all
 locales. Therefore the behavior of  getAvailableMetaZoneIDs()   getAvailableMetaZoneIDs(java.lang.String) 
  getMetaZoneID(java.lang.String long)  and  getReferenceZoneID(java.lang.String java.lang.String)  won't be changed no matter
 what locale is used for getting an instance of  TimeZoneNames ."
android,icu.text,Transliterator.Position,5,"Position structure for incremental transliteration.  This data
 structure defines two substrings of the text being
 transliterated.  The first region [contextStart
 contextLimit) defines what characters the transliterator will
 read as context.  The second region [start limit) defines
 what characters will actually be transliterated.  The second
 region should be a subset of the first.

  After a transliteration operation some of the indices in this
 structure will be modified.  See the field descriptions for
 details.

  contextStart <= start <= limit <= contextLimit

  Note: All index values in this structure must be at code point
 boundaries.  That is none of them may occur between two code units
 of a surrogate pair.  If any index does split a surrogate pair
 results are unspecified."
android,icu.text,UCharacterIterator,24,"Abstract class that defines an API for iteration on text objects.This is an interface for forward and backward
 iteration and random access into a text object. Forward iteration is done with post-increment and backward iteration
 is done with pre-decrement semantics while the  java.text.CharacterIterator  interface methods provided
 forward iteration with ""pre-increment"" and backward iteration with pre-decrement semantics. This API is more
 efficient for forward iteration over code points. The other major difference is that this API can do both code unit
 and code point iteration  java.text.CharacterIterator  can only iterate over code units and is limited to
 BMP (0 - 0xFFFF)"
android,icu.text,UnicodeFilter,2,"UnicodeFilter  defines a protocol for selecting a
 subset of the full range (U+0000 to U+FFFF) of Unicode characters."
android,icu.text,UnicodeSet.EntryRange,1,"A struct-like class used for iteration through ranges for faster iteration than by String.
 Read about the restrictions on usage in  UnicodeSet#ranges() ."
android,icu.text,UnicodeSetSpanner,14,"A helper class used to count replace and trim CharSequences based on UnicodeSet matches.
 An instance is immutable (and thus thread-safe) iff the source UnicodeSet is frozen.
  Note:  The counting deletion and replacement depend on alternating a  SpanCondition  with
 its inverse. That is the code spans then spans for the inverse then spans and so on.
 For the inverse the following mapping is used:
  UnicodeSet.SpanCondition#SIMPLE  â†’  UnicodeSet.SpanCondition#NOT_CONTAINED UnicodeSet.SpanCondition#CONTAINED  â†’  UnicodeSet.SpanCondition#NOT_CONTAINED UnicodeSet.SpanCondition#NOT_CONTAINED  â†’  UnicodeSet.SpanCondition#SIMPLE SIMPLE xxx[ab]cyyy CONTAINED xxx[abc]yyy NOT_CONTAINED [xxx]ab[cyyy] So here is what happens when you alternate:

  start |xxxabcyyy NOT_CONTAINED xxx|abcyyy CONTAINED xxxabc|yyy NOT_CONTAINED xxxabcyyy| The entire string is traversed."
android,icu.text,BreakIterator,32,"[icu enhancement]  ICU's replacement for  BreakIterator .Â Methods fields and other functionality specific to ICU are labeled ' [icu] '.

  A class that locates boundaries in text.  This class defines a protocol for
 objects that break up a piece of natural-language text according to a set
 of criteria.  Instances or subclasses of BreakIterator can be provided for
 example to break a piece of text into words sentences or logical characters
 according to the conventions of some language or group of languages.

 We provide five built-in types of BreakIterator:
  getTitleInstance() returns a BreakIterator that locates boundaries
 between title breaks.
  getSentenceInstance() returns a BreakIterator that locates boundaries
 between sentences.  This is useful for triple-click selection for example.
  getWordInstance() returns a BreakIterator that locates boundaries between
 words.  This is useful for double-click selection or ""find whole words"" searches.
 This type of BreakIterator makes sure there is a boundary position at the
 beginning and end of each legal word.  (Numbers count as words too.)  Whitespace
 and punctuation are kept separate from real words.
  getLineInstance() returns a BreakIterator that locates positions where it is
 legal for a text editor to wrap lines.  This is similar to word breaking but
 not the same: punctuation and whitespace are generally kept with words (you don't
 want a line to start with whitespace for example) and some special characters
 can force a position to be considered a line-break position or prevent a position
 from being a line-break position.
  getCharacterInstance() returns a BreakIterator that locates boundaries between
 logical characters.  Because of the structure of the Unicode encoding a logical
 character may be stored internally as more than one Unicode code point.  (A with an
 umlaut may be stored as an a followed by a separate combining umlaut character
 for example but the user still thinks of it as one character.)  This iterator allows
 various processes (especially text editors) to treat as characters the units of text
 that a user would think of as characters rather than the units of text that the
 computer sees as ""characters"". 
 BreakIterator's interface follows an ""iterator"" model (hence the name) meaning it
 has a concept of a ""current position"" and methods like first() last() next()
 and previous() that update the current position.  All BreakIterators uphold the
 following invariants:
  The beginning and end of the text are always treated as boundary positions.
  The current position of the iterator is always a boundary position (random-
 access methods move the iterator to the nearest boundary position before or
 after the specified position not _to_ the specified position).
  DONE is used as a flag to indicate when iteration has stopped.  DONE is only
 returned when the current position is the end of the text and the user calls next()
 or when the current position is the beginning of the text and the user calls
 previous().
  Break positions are numbered by the positions of the characters that follow
 them.  Thus under normal circumstances the position before the first character
 is 0 the position after the first character is 1 and the position after the
 last character is 1 plus the length of the string.
  The client can change the position of an iterator or the text it analyzes
 at will but cannot change the behavior.  If the user wants different behavior he
 must instantiate a new iterator. Note: Examples : 
 Creating and using text boundaries
  
 public static void main(String args[]) {
      if (args.length == 1) {
          String stringToExamine = args[0];
          //print each word in order
          BreakIterator boundary = BreakIterator.getWordInstance();
          boundary.setText(stringToExamine);
          printEachForward(boundary stringToExamine);
          //print each sentence in reverse order
          boundary = BreakIterator.getSentenceInstance(Locale.US);
          boundary.setText(stringToExamine);
          printEachBackward(boundary stringToExamine);
          printFirst(boundary stringToExamine);
          printLast(boundary stringToExamine);
      }
 }
  
 public static void printEachForward(BreakIterator boundary String source) {
     int start = boundary.first();
     for (int end = boundary.next();
          end != BreakIterator.DONE;
          start = end end = boundary.next()) {
          System.out.println(source.substring(startend));
     }
 }
  
 public static void printEachBackward(BreakIterator boundary String source) {
     int end = boundary.last();
     for (int start = boundary.previous();
          start != BreakIterator.DONE;
          end = start start = boundary.previous()) {
         System.out.println(source.substring(startend));
     }
 }
  
 public static void printFirst(BreakIterator boundary String source) {
     int start = boundary.first();
     int end = boundary.next();
     System.out.println(source.substring(startend));
 }
  
 public static void printLast(BreakIterator boundary String source) {
     int end = boundary.last();
     int start = boundary.previous();
     System.out.println(source.substring(startend));
 }
  
 public static void printAt(BreakIterator boundary int pos String source) {
     int end = boundary.following(pos);
     int start = boundary.previous();
     System.out.println(source.substring(startend));
 }
  
 public static int nextWordStartAfter(int pos String text) {
     BreakIterator wb = BreakIterator.getWordInstance();
     wb.setText(text);
     int wordStart = wb.following(pos);
     for (;;) {
         int wordLimit = wb.next();
         if (wordLimit == BreakIterator.DONE) {
             return BreakIterator.DONE;
         }
         int wordStatus = wb.getRuleStatus();
         if (wordStatus != BreakIterator.WORD_NONE) {
             return wordStart;
         }
         wordStart = wordLimit;
      }
 }
  
 The iterator returned by  getWordInstance()  is unique in that
 the break positions it returns don't represent both the start and end of the
 thing being iterated over.  That is a sentence-break iterator returns breaks
 that each represent the end of one sentence and the beginning of the next.
 With the word-break iterator the characters between two boundaries might be a
 word or they might be the punctuation or whitespace between two words.  The
 above code uses  getRuleStatus()  to identify and ignore boundaries associated
 with punctuation or other non-word characters."
android,icu.text,CaseMap,5,"Low-level case mapping options and methods. Immutable.
 ""Setters"" return instances with the union of the current and new options set.

 This class is not intended for public subclassing."
android,icu.text,CollationKey,8,"A  CollationKey  represents a  String 
 under the rules of a specific  Collator 
 object. Comparing two  CollationKey s returns the
 relative order of the  String s they represent.

  Since the rule set of  Collator s can differ the
 sort orders of the same string under two different
  Collator s might differ.  Hence comparing
  CollationKey s generated from different
  Collator s can give incorrect results.
 
  Both the method
  CollationKey.compareTo(CollationKey)  and the method
  Collator.compare(String String)  compare two strings
 and returns their relative order.  The performance characteristics
 of these two approaches can differ.
 Note that collation keys are often less efficient than simply doing comparison.
 For more details see the ICU User Guide.

  During the construction of a  CollationKey  the
 entire source string is examined and processed into a series of
 bits terminated by a null that are stored in the  CollationKey .
 When  CollationKey.compareTo(CollationKey)  executes it
 performs bitwise comparison on the bit sequences.  This can incurs
 startup cost when creating the  CollationKey  but once
 the key is created binary comparisons are fast.  This approach is
 recommended when the same strings are to be compared over and over
 again.

  On the other hand implementations of
  Collator.compare(String String)  can examine and
 process the strings only until the first characters differing in
 order.  This approach is recommended if the strings are to be
 compared only once. More information about the composition of the bit sequence can
 be found in the
  
 user guide . The following example shows how  CollationKey s can be used
 to sort a list of  String s. 
 // Create an array of CollationKeys for the Strings to be sorted.
 Collator myCollator = Collator.getInstance();
 CollationKey[] keys = new CollationKey[3];
 keys[0] = myCollator.getCollationKey(""Tom"");
 keys[1] = myCollator.getCollationKey(""Dick"");
 keys[2] = myCollator.getCollationKey(""Harry"");
 sort( keys );
  
 //...
  
 // Inside body of sort routine compare keys this way
 if( keys[i].compareTo( keys[j] ) > 0 )
    // swap keys[i] and keys[j]
  
 //...
  
 // Finally when we've returned from sort.
 System.out.println( keys[0].getSourceString() );
 System.out.println( keys[1].getSourceString() );
 System.out.println( keys[2].getSourceString() );
  
 This class is not subclassable"
android,icu.text,DateFormatSymbols,36,"[icu enhancement]  ICU's replacement for  DateFormatSymbols .Â Methods fields and other functionality specific to ICU are labeled ' [icu] '.

  DateFormatSymbols  is a public class for encapsulating
 localizable date-time formatting data such as the names of the
 months the names of the days of the week and the time zone data.
  DateFormat  and  SimpleDateFormat  both use
  DateFormatSymbols  to encapsulate this information.

  Typically you shouldn't use  DateFormatSymbols  directly.
 Rather you are encouraged to create a date-time formatter with the
  DateFormat  class's factory methods:  getTimeInstance 
  getDateInstance  or  getDateTimeInstance .
 These methods automatically create a  DateFormatSymbols  for
 the formatter so that you don't have to. After the
 formatter is created you may modify its format pattern using the
  setPattern  method. For more information about
 creating formatters using  DateFormat 's factory methods
 see  DateFormat .

  If you decide to create a date-time formatter with a specific
 format pattern for a specific locale you can do so with:
  
 new SimpleDateFormat(aPattern new DateFormatSymbols(aLocale)).
  DateFormatSymbols  objects are clonable. When you obtain
 a  DateFormatSymbols  object feel free to modify the
 date-time formatting data. For instance you can replace the localized
 date-time format pattern characters with the ones that you feel easy
 to remember. Or you can change the representative cities
 to your favorite ones.

  New  DateFormatSymbols  subclasses may be added to support
  SimpleDateFormat  for date-time formatting for additional locales."
android,icu.text,DateTimePatternGenerator.PatternInfo,0,"PatternInfo supplies output parameters for addPattern(...). It is used because
 Java doesn't have real output parameters. It is treated like a struct (eg
 Point) so all fields are public."
android,icu.text,LocaleDisplayNames,20,"Returns display names of ULocales and components of ULocales. For
 more information on language script region variant key and
 values see  ULocale ."
android,icu.text,MessageFormat,34,"[icu enhancement]  ICU's replacement for  MessageFormat .Â Methods fields and other functionality specific to ICU are labeled ' [icu] '.

  MessageFormat prepares strings for display to users
 with optional arguments (variables/placeholders).
 The arguments can occur in any order which is necessary for translation
 into languages with different grammars.

  A MessageFormat is constructed from a  pattern  string
 with arguments in {curly braces} which will be replaced by formatted values.

  MessageFormat  differs from the other  Format 
 classes in that you create a  MessageFormat  object with one
 of its constructors (not with a  getInstance  style factory
 method). Factory methods aren't necessary because  MessageFormat 
 itself doesn't implement locale-specific behavior. Any locale-specific
 behavior is defined by the pattern that you provide and the
 subformats used for inserted arguments.

  Arguments can be named (using identifiers) or numbered (using small ASCII-digit integers).
 Some of the API methods work only with argument numbers and throw an exception
 if the pattern has named arguments (see  usesNamedArguments() ).

  An argument might not specify any format type. In this case
 a Number value is formatted with a default (for the locale) NumberFormat
 a Date value is formatted with a default (for the locale) DateFormat
 and for any other value its toString() value is used.

  An argument might specify a ""simple"" type for which the specified
 Format object is created cached and used.

  An argument might have a ""complex"" type with nested MessageFormat sub-patterns.
 During formatting one of these sub-messages is selected according to the argument value
 and recursively formatted.

  After construction a custom Format object can be set for
 a top-level argument overriding the default formatting and parsing behavior
 for that argument.
 However custom formatting can be achieved more simply by writing
 a typeless argument in the pattern string
 and supplying it with a preformatted string value.

  When formatting MessageFormat takes a collection of argument values
 and writes an output string.
 The argument values may be passed as an array
 (when the pattern contains only numbered arguments)
 or as a Map (which works for both named and numbered arguments).

  Each argument is matched with one of the input values by array index or map key
 and formatted according to its pattern specification
 (or using a custom Format object if one was set).
 A numbered pattern argument is matched with a map key that contains that number
 as an ASCII-decimal-digit string (without leading zero).

  Patterns and Their Interpretation MessageFormat 
 message = messageText (argument messageText)*
 argument = noneArg | simpleArg | complexArg
 complexArg = choiceArg | pluralArg | selectArg | selectordinalArg

 noneArg = '{' argNameOrNumber '}'
 simpleArg = '{' argNameOrNumber '' argType ['' argStyle] '}'
 choiceArg = '{' argNameOrNumber '' ""choice"" '' choiceStyle '}'
 pluralArg = '{' argNameOrNumber '' ""plural"" '' pluralStyle '}'
 selectArg = '{' argNameOrNumber '' ""select"" '' selectStyle '}'
 selectordinalArg = '{' argNameOrNumber '' ""selectordinal"" '' pluralStyle '}'

 choiceStyle: see  ChoiceFormat 
 pluralStyle: see  PluralFormat 
 selectStyle: see  SelectFormat 

 argNameOrNumber = argName | argNumber
 argName = [^[[:Pattern_Syntax:][:Pattern_White_Space:]]]+
 argNumber = '0' | ('1'..'9' ('0'..'9')*)

 argType = ""number"" | ""date"" | ""time"" | ""spellout"" | ""ordinal"" | ""duration""
 argStyle = ""short"" | ""medium"" | ""long"" | ""full"" | ""integer"" | ""currency"" | ""percent"" | argStyleText
  messageText can contain quoted literal strings including syntax characters.
       A quoted literal string begins with an ASCII apostrophe and a syntax character
       (usually a {curly brace}) and continues until the next single apostrophe.
       A double ASCII apostrohpe inside or outside of a quoted string represents
       one literal apostrophe.
    Quotable syntax characters are the {curly braces} in all messageText parts
       plus the '#' sign in a messageText immediately inside a pluralStyle
       and the '|' symbol in a messageText immediately inside a choiceStyle.
    See also  MessagePattern.ApostropheMode In argStyleText every single ASCII apostrophe begins and ends quoted literal text
       and unquoted {curly braces} must occur in matched pairs.
  Recommendation: Use the real apostrophe (single quote) character \\u2019 for
 human-readable text and use the ASCII apostrophe (\\u0027 ' )
 only in program syntax like quoting in MessageFormat.
 See the annotations for U+0027 Apostrophe in The Unicode Standard.

  The  choice  argument type is deprecated.
 Use  plural  arguments for proper plural selection
 and  select  arguments for simple selection among a fixed set of choices.

  The  argType  and  argStyle  values are used to create
 a  Format  instance for the format element. The following
 table shows how the values map to Format instances. Combinations not
 shown in the table are illegal. Any  argStyleText  must
 be a valid pattern string for the Format subclass used.

  argType
        argStyle
        resulting Format object
     (none) null number (none) NumberFormat.getInstance(getLocale()) integer NumberFormat.getIntegerInstance(getLocale()) currency NumberFormat.getCurrencyInstance(getLocale()) percent NumberFormat.getPercentInstance(getLocale()) argStyleText new DecimalFormat(argStyleText new DecimalFormatSymbols(getLocale())) date (none) DateFormat.getDateInstance(DateFormat.DEFAULT getLocale()) short DateFormat.getDateInstance(DateFormat.SHORT getLocale()) medium DateFormat.getDateInstance(DateFormat.DEFAULT getLocale()) long DateFormat.getDateInstance(DateFormat.LONG getLocale()) full DateFormat.getDateInstance(DateFormat.FULL getLocale()) argStyleText new SimpleDateFormat(argStyleText getLocale()) time (none) DateFormat.getTimeInstance(DateFormat.DEFAULT getLocale()) short DateFormat.getTimeInstance(DateFormat.SHORT getLocale()) medium DateFormat.getTimeInstance(DateFormat.DEFAULT getLocale()) long DateFormat.getTimeInstance(DateFormat.LONG getLocale()) full DateFormat.getTimeInstance(DateFormat.FULL getLocale()) argStyleText new SimpleDateFormat(argStyleText getLocale()) spellout argStyleText (optional) new RuleBasedNumberFormat(getLocale() RuleBasedNumberFormat.SPELLOUT)
            Â Â Â Â .setDefaultRuleset(argStyleText); ordinal argStyleText (optional) new RuleBasedNumberFormat(getLocale() RuleBasedNumberFormat.ORDINAL)
            Â Â Â Â .setDefaultRuleset(argStyleText); duration argStyleText (optional) new RuleBasedNumberFormat(getLocale() RuleBasedNumberFormat.DURATION)
            Â Â Â Â .setDefaultRuleset(argStyleText); Differences from java.text.MessageFormat The ICU MessageFormat supports both named and numbered arguments
 while the JDK MessageFormat only supports numbered arguments.
 Named arguments make patterns more readable.

  ICU implements a more user-friendly apostrophe quoting syntax.
 In message text an apostrophe only begins quoting literal text
 if it immediately precedes a syntax character (mostly {curly braces}). 
 In the JDK MessageFormat an apostrophe always begins quoting
 which requires common text like ""don't"" and ""aujourd'hui""
 to be written with doubled apostrophes like ""don''t"" and ""aujourd''hui"".
 For more details see  MessagePattern.ApostropheMode .

  ICU does not create a ChoiceFormat object for a choiceArg pluralArg or selectArg
 but rather handles such arguments itself.
 The JDK MessageFormat does create and use a ChoiceFormat object
 ( new ChoiceFormat(argStyleText) ).
 The JDK does not support plural and select arguments at all.

  Usage Information Here are some examples of usage:
  
 Object[] arguments = {
     7
     new Date(System.currentTimeMillis())
     ""a disturbance in the Force""
 };

 String result = MessageFormat.format(
     ""At {1time} on {1date} there was {2} on planet {0numberinteger}.""
     arguments);

  output : At 12:30 PM on Jul 3 2053 there was a disturbance
           in the Force on planet 7.

  Example 2:
  
 Object[] testArgs = { 3 ""MyDisk"" };

 MessageFormat form = new MessageFormat(
     ""The disk \""{1}\"" contains {0} file(s)."");

 System.out.println(form.format(testArgs));

 // output with different testArgs
  output : The disk ""MyDisk"" contains 0 file(s).
  output : The disk ""MyDisk"" contains 1 file(s).
  output : The disk ""MyDisk"" contains 1273 file(s).
  For messages that include plural forms you can use a plural argument:
  
 MessageFormat msgFmt = new MessageFormat(
     ""{num_files plural "" +
     ""=0{There are no files on disk \""{disk_name}\"".}"" +
     ""=1{There is one file on disk \""{disk_name}\"".}"" +
     ""other{There are # files on disk \""{disk_name}\"".}}""
     ULocale.ENGLISH);
 Map args = new HashMap();
 args.put(""num_files"" 0);
 args.put(""disk_name"" ""MyDisk"");
 System.out.println(msgFmt.format(args));
 args.put(""num_files"" 3);
 System.out.println(msgFmt.format(args));

  output :
 There are no files on disk ""MyDisk"".
 There are 3 files on ""MyDisk"".
  PluralFormat PluralRules Synchronization MessageFormats are not synchronized.
 It is recommended to create separate format instances for each thread.
 If multiple threads access a format concurrently it must be synchronized
 externally."
android,icu.text,PluralFormat,11,"PluralFormat  supports the creation of internationalized
 messages with plural inflection. It is based on  plural
 selection  i.e. the caller specifies messages for each
 plural case that can appear in the user's language and the
  PluralFormat  selects the appropriate message based on
 the number.

  The Problem of Plural Forms in Internationalized Messages 
 Different languages have different ways to inflect
 plurals. Creating internationalized messages that include plural
 forms is only feasible when the framework is able to handle plural
 forms of  all  languages correctly.  ChoiceFormat 
 doesn't handle this well because it attaches a number interval to
 each message and selects the message whose interval contains a
 given number. This can only handle a finite number of
 intervals. But in some languages like Polish one plural case
 applies to infinitely many intervals (e.g. the paucal case applies to
 numbers ending with 2 3 or 4 except those ending with 12 13 or
 14). Thus  ChoiceFormat  is not adequate.
  PluralFormat  deals with this by breaking the problem
 into two parts:
  It uses  PluralRules  that can define more complex
     conditions for a plural case than just a single interval. These plural
     rules define both what plural cases exist in a language and to
     which numbers these cases apply.
  It provides predefined plural rules for many languages. Thus the programmer
     need not worry about the plural cases of a language and
     does not have to define the plural cases; they can simply
     use the predefined keywords. The whole plural formatting of messages can
     be done using localized patterns from resource bundles. For predefined plural
     rules see the CLDR  Language Plural Rules  page at
    http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html
  Usage of  PluralFormat Note: Typically plural formatting is done via  MessageFormat 
 with a  plural  argument type
 rather than using a stand-alone  PluralFormat .
  
 This discussion assumes that you use  PluralFormat  with
 a predefined set of plural rules. You can create one using one of
 the constructors that takes a  ULocale  object. To
 specify the message pattern you can either pass it to the
 constructor or set it explicitly using the
  applyPattern()  method. The  format() 
 method takes a number object and selects the message of the
 matching plural case. This message will be returned.

  Patterns and Their Interpretation 
 The pattern text defines the message output for each plural case of the
 specified locale. Syntax:
  
 pluralStyle = [offsetValue] (selector '{' message '}')+
 offsetValue = ""offset:"" number
 selector = explicitValue | keyword
 explicitValue = '=' number  // adjacent no white space in between
 keyword = [^[[:Pattern_Syntax:][:Pattern_White_Space:]]]+
 message: see  MessageFormat 
 There are 6 predefined case keywords in CLDR/ICU - 'zero' 'one' 'two' 'few' 'many' and
 'other'. You always have to define a message text for the default plural case
 "" other "" which is contained in every rule set.
 If you do not specify a message text for a particular plural case the
 message text of the plural case "" other "" gets assigned to this
 plural case.
  
 When formatting the input number is first matched against the explicitValue clauses.
 If there is no exact-number match then a keyword is selected by calling
 the  PluralRules  with the input number  minus the offset .
 (The offset defaults to 0 if it is omitted from the pattern string.)
 If there is no clause with that keyword then the ""other"" clauses is returned.
  
 An unquoted pound sign ( # ) in the selected sub-message
 itself (i.e. outside of arguments nested in the sub-message)
 is replaced by the input number minus the offset.
 The number-minus-offset value is formatted using a
  NumberFormat  for the  PluralFormat 's locale. If you
 need special number formatting you have to use a  MessageFormat 
 and explicitly specify a  NumberFormat  argument.
  Note:  That argument is formatting without subtracting the offset!
 If you need a custom format and have a non-zero offset then you need to pass the
 number-minus-offset value as a separate parameter.

  For a usage example see the  MessageFormat  class documentation.

  Defining Custom Plural Rules If you need to use  PluralFormat  with custom rules you can
 create a  PluralRules  object and pass it to
  PluralFormat 's constructor. If you also specify a locale in this
 constructor this locale will be used to format the number in the message
 texts.
  
 For more information about  PluralRules  see
  PluralRules ."
android,icu.text,RuleBasedCollator,45,"RuleBasedCollator is a concrete subclass of Collator. It allows customization of the Collator via user-specified rule
 sets. RuleBasedCollator is designed to be fully compliant to the  Unicode Collation Algorithm (UCA)  and conforms to ISO 14651.

  A Collator is thread-safe only when frozen. See { isFrozen()  and  Freezable .

  
 Users are strongly encouraged to read the  User
 Guide  for more information about the collation service before using this class.

  
 Create a RuleBasedCollator from a locale by calling the getInstance(Locale) factory method in the base class
 Collator. Collator.getInstance(Locale) creates a RuleBasedCollator object based on the collation rules defined by the
 argument locale. If a customized collation ordering or attributes is required use the RuleBasedCollator(String)
 constructor with the appropriate rules. The customized RuleBasedCollator will base its ordering on the CLDR root collation while
 re-adjusting the attributes and orders of the characters in the specified rule accordingly.

  
 RuleBasedCollator provides correct collation orders for most locales supported in ICU. If specific data for a locale
 is not available the orders eventually falls back to the
  CLDR root sort order .

  
 For information about the collation rule syntax and details about customization please refer to the  Collation customization  section of the
 User Guide.

  Note  that there are some differences between the Collation rule syntax used in Java and ICU4J:

  According to the JDK documentation:  Modifier '!' : Turns on Thai/Lao vowel-consonant swapping. If this rule is in force when a Thai vowel of the range
 \U0E40-\U0E44 precedes a Thai consonant of the range \U0E01-\U0E2E OR a Lao vowel of the range
 \U0EC0-\U0EC4 precedes a Lao consonant of the range \U0E81-\U0EAE then the vowel is placed after the
 consonant for collation purposes.
  
 If a rule is without the modifier '!' the Thai/Lao vowel-consonant swapping is not turned on.
  
 ICU4J's RuleBasedCollator does not support turning off the Thai/Lao vowel-consonant swapping since the UCA clearly
 states that it has to be supported to ensure a correct sorting order. If a '!' is encountered it is ignored. As mentioned in the documentation of the base class Collator compatibility decomposition mode is not supported. Examples 
 Creating Customized RuleBasedCollators:  
 String simple = ""& a < b < c < d"";
 RuleBasedCollator simpleCollator = new RuleBasedCollator(simple);

 String norwegian = ""& a  A < b  B < c  C < d  D < e  E ""
                    + ""< f  F < g  G < h  H < i  I < j  ""
                    + ""J < k  K < l  L < m  M < n  N < ""
                    + ""o  O < p  P < q  Q <r  R <s  S < ""
                    + ""t  T < u  U < v  V < w  W < x  X ""
                    + ""< y  Y < z  Z < \u00E5 = a\u030A ""
                    + "" \u00C5 = A\u030A ; aa  AA < \u00E6 ""
                    + "" \u00C6 < \u00F8  \u00D8"";
 RuleBasedCollator norwegianCollator = new RuleBasedCollator(norwegian);
  Collator 
 // Create an en_US Collator object
 RuleBasedCollator en_USCollator = (RuleBasedCollator)
     Collator.getInstance(new Locale(""en"" ""US"" """"));
 // Create a da_DK Collator object
 RuleBasedCollator da_DKCollator = (RuleBasedCollator)
     Collator.getInstance(new Locale(""da"" ""DK"" """"));
 // Combine the two
 // First get the collation rules from en_USCollator
 String en_USRules = en_USCollator.getRules();
 // Second get the collation rules from da_DKCollator
 String da_DKRules = da_DKCollator.getRules();
 RuleBasedCollator newCollator =
                             new RuleBasedCollator(en_USRules + da_DKRules);
 // newCollator has the combined rules
  Collator 
 // Create a new Collator object with additional rules
 String addRules = ""& C < ch cH Ch CH"";
 RuleBasedCollator myCollator =
     new RuleBasedCollator(en_USCollator.getRules() + addRules);
 // myCollator contains the new rules
  
 // old rule with main accents
 String oldRules = ""= \u0301 ; \u0300 ; \u0302 ; \u0308 ""
                 + ""; \u0327 ; \u0303 ; \u0304 ; \u0305 ""
                 + ""; \u0306 ; \u0307 ; \u0309 ; \u030A ""
                 + ""; \u030B ; \u030C ; \u030D ; \u030E ""
                 + ""; \u030F ; \u0310 ; \u0311 ; \u0312 ""
                 + ""< a  A ; ae AE ; \u00e6  \u00c6 ""
                 + ""< b  B < c C < e E & C < d  D"";
 // change the order of accent characters
 String addOn = ""& \u0300 ; \u0308 ; \u0302"";
 RuleBasedCollator myCollator = new RuleBasedCollator(oldRules + addOn);
  Collator 
 // get en_US Collator rules
 RuleBasedCollator en_USCollator
                        = (RuleBasedCollator)Collator.getInstance(Locale.US);
 // add a few Japanese characters to sort before English characters
 // suppose the last character before the first base letter 'a' in
 // the English collation rule is \u2212
 String jaString = ""& \u2212 <\u3041 \u3042 <\u3043 ""
                   + ""\u3044"";
 RuleBasedCollator myJapaneseCollator
              = new RuleBasedCollator(en_USCollator.getRules() + jaString);
  
 This class is not subclassable"
android,icu.text,AlphabeticIndex.Record,3,"A (name data) pair to be sorted by name into one of the index buckets.
 The user data is not used by the index implementation."
android,icu.text,Collator,37,"[icu enhancement]  ICU's replacement for  Collator .Â Methods fields and other functionality specific to ICU are labeled ' [icu] '.

  Collator performs locale-sensitive string comparison. A concrete
 subclass RuleBasedCollator allows customization of the collation
 ordering by the use of rule sets.

  A Collator is thread-safe only when frozen. See  isFrozen()  and  Freezable .

  Following the  Unicode
 Consortium 's specifications for the
  Unicode Collation
 Algorithm (UCA)  there are 5 different levels of strength used
 in comparisons:

  PRIMARY strength: Typically this is used to denote differences between
     base characters (for example ""a"" < ""b"").
     It is the strongest difference. For example dictionaries are divided
     into different sections by base character.
  SECONDARY strength: Accents in the characters are considered secondary
     differences (for example ""as"" < ""Ã s"" < ""at""). Other
     differences
     between letters can also be considered secondary differences depending
     on the language. A secondary difference is ignored when there is a
     primary difference anywhere in the strings.
  TERTIARY strength: Upper and lower case differences in characters are
     distinguished at tertiary strength (for example ""ao"" < ""Ao"" <
     ""aÃ²""). In addition a variant of a letter differs from the base
     form on the tertiary strength (such as ""A"" and ""â’¶""). Another
     example is the
     difference between large and small Kana. A tertiary difference is ignored
     when there is a primary or secondary difference anywhere in the strings.
  QUATERNARY strength: When punctuation is ignored
     (see  
     Ignoring Punctuations in the User Guide ) at PRIMARY to TERTIARY
     strength an additional strength level can
     be used to distinguish words with and without punctuation (for example
     ""ab"" < ""a-b"" < ""aB"").
     This difference is ignored when there is a PRIMARY SECONDARY or TERTIARY
     difference. The QUATERNARY strength should only be used if ignoring
     punctuation is required.
  IDENTICAL strength:
     When all other strengths are equal the IDENTICAL strength is used as a
     tiebreaker. The Unicode code point values of the NFD form of each string
     are compared just in case there is no difference.
     For example Hebrew cantellation marks are only distinguished at this
     strength. This strength should be used sparingly as only code point
     value differences between two strings is an extremely rare occurrence.
     Using this strength substantially decreases the performance for both
     comparison and collation key generation APIs. This strength also
     increases the size of the collation key.
  For more information about the collation service see the
  User Guide .

  Examples of use
  
 // Get the Collator for US English and set its strength to PRIMARY
 Collator usCollator = Collator.getInstance(Locale.US);
 usCollator.setStrength(Collator.PRIMARY);
 if (usCollator.compare(""abc"" ""ABC"") == 0) {
     System.out.println(""Strings are equivalent"");
 }

 The following example shows how to compare two strings using the
 Collator for the default locale.

 // Compare two strings in the default locale
 Collator myCollator = Collator.getInstance();
 myCollator.setDecomposition(NO_DECOMPOSITION);
 if (myCollator.compare(""Ã \u0325"" ""a\u0325Ì€"") != 0) {
     System.out.println(""Ã \u0325 is not equals to a\u0325Ì€ without decomposition"");
     myCollator.setDecomposition(CANONICAL_DECOMPOSITION);
     if (myCollator.compare(""Ã \u0325"" ""a\u0325Ì€"") != 0) {
         System.out.println(""Error: Ã \u0325 should be equals to a\u0325Ì€ with decomposition"");
     }
     else {
         System.out.println(""Ã \u0325 is equals to a\u0325Ì€ with decomposition"");
     }
 }
 else {
     System.out.println(""Error: Ã \u0325 should be not equals to a\u0325Ì€ without decomposition"");
 }"
android,icu.text,DateFormat.Field,3,"The instances of this inner class are used as attribute keys and values
 in AttributedCharacterIterator that
 DateFormat.formatToCharacterIterator() method returns.

  There is no public constructor to this class the only instances are the
 constants defined here."
android,icu.text,DateIntervalInfo,11,"DateIntervalInfo is a public class for encapsulating localizable
 date time interval patterns. It is used by DateIntervalFormat.

  
 For most users ordinary use of DateIntervalFormat does not need to create
 DateIntervalInfo object directly.
 DateIntervalFormat will take care of it when creating a date interval
 formatter when user pass in skeleton and locale.

  
 For power users who want to create their own date interval patterns
 or want to re-set date interval patterns they could do so by
 directly creating DateIntervalInfo and manipulating it.

  
 Logically the interval patterns are mappings
 from (skeleton the_largest_different_calendar_field)
 to (date_interval_pattern).

  
 A skeleton
  
 only keeps the field pattern letter and ignores all other parts
 in a pattern such as space punctuations and string literals.
  
 hides the order of fields.
  
 might hide a field's pattern letter length.

 For those non-digit calendar fields the pattern letter length is
 important such as MMM MMMM and MMMMM; EEE and EEEE
 and the field's pattern letter length is honored.

 For the digit calendar fields  such as M or MM d or dd yy or yyyy
 the field pattern length is ignored and the best match which is defined
 in date time patterns will be returned without honor the field pattern
 letter length in skeleton.
  
 The calendar fields we support for interval formatting are:
 year month date day-of-week am-pm hour hour-of-day minute and
 second (though we do not currently have specific intervalFormat data for
 skeletons with seconds).
 Those calendar fields can be defined in the following order:
 year > month > date > am-pm > hour >  minute > second

 The largest different calendar fields between 2 calendars is the
 first different calendar field in above order.

 For example: the largest different calendar fields between ""Jan 10 2007""
 and ""Feb 20 2008"" is year.

  
 There is a set of pre-defined static skeleton strings.
 There are pre-defined interval patterns for those pre-defined skeletons
 in locales' resource files.
 For example for a skeleton YEAR_ABBR_MONTH_DAY which is  ""yMMMd""
 in  en_US if the largest different calendar field between date1 and date2
 is ""year"" the date interval pattern  is ""MMM d yyyy - MMM d yyyy""
 such as ""Jan 10 2007 - Jan 10 2008"".
 If the largest different calendar field between date1 and date2 is ""month""
 the date interval pattern is ""MMM d - MMM d yyyy""
 such as ""Jan 10 - Feb 10 2007"".
 If the largest different calendar field between date1 and date2 is ""day""
 the date interval pattern is """"MMM d-d yyyy"" such as ""Jan 10-20 2007"".

 For date skeleton the interval patterns when year or month or date is
 different are defined in resource files.
 For time skeleton the interval patterns when am/pm or hour or minute is
 different are defined in resource files.


  
 There are 2 dates in interval pattern. For most locales the first date
 in an interval pattern is the earlier date. There might be a locale in which
 the first date in an interval pattern is the later date.
 We use fallback format for the default order for the locale.
 For example if the fallback format is ""{0} - {1}"" it means
 the first date in the interval pattern for this locale is earlier date.
 If the fallback format is ""{1} - {0}"" it means the first date is the
 later date.
 For a particular interval pattern the default order can be overriden
 by prefixing ""latestFirst:"" or ""earliestFirst:"" to the interval pattern.
 For example if the fallback format is ""{0}-{1}""
 but for skeleton ""yMMMd"" the interval pattern when day is different is
 ""latestFirst:d-d MMM yy"" it means by default the first date in interval
 pattern is the earlier date. But for skeleton ""yMMMd"" when day is different
 the first date in ""d-d MMM yy"" is the later date.

  
 The recommended way to create a DateIntervalFormat object is to pass in
 the locale.
 By using a Locale parameter the DateIntervalFormat object is
 initialized with the pre-defined interval patterns for a given or
 default locale.
  
 Users can also create DateIntervalFormat object
 by supplying their own interval patterns.
 It provides flexibility for power usage.

  
 After a DateIntervalInfo object is created clients may modify
 the interval patterns using setIntervalPattern function as so desired.
 Currently users can only set interval patterns when the following
 calendar fields are different: ERA YEAR MONTH DATE  DAY_OF_MONTH
 DAY_OF_WEEK AM_PM  HOUR HOUR_OF_DAY MINUTE and SECOND.
 Interval patterns when other calendar fields are different is not supported.
  
 DateIntervalInfo objects are cloneable.
 When clients obtain a DateIntervalInfo object
 they can feel free to modify it as necessary.
  
 DateIntervalInfo are not expected to be subclassed.
 Data for a calendar is loaded out of resource bundles.
 Through ICU 4.4 date interval patterns are only supported in the Gregoria
 calendar; non-Gregorian calendars are supported from ICU 4.4.1."
android,icu.text,ListFormatter,6,"Immutable class for formatting a list using data from CLDR (or supplied
 separately). The class is not subclassable."
android,icu.text,MessagePattern.Part,9,"A message pattern ""part"" representing a pattern parsing event.
 There is a part for the start and end of a message or argument
 for quoting and escaping of and with ASCII apostrophes
 and for syntax elements of ""complex"" arguments."
android,icu.text,SearchIterator,23,"SearchIterator  is an abstract base class that provides
 methods to search for a pattern within a text string. Instances of
  SearchIterator  maintain a current position and scan over the
 target text returning the indices the pattern is matched and the length
 of each match.
  SearchIterator  defines a protocol for text searching.
 Subclasses provide concrete implementations of various search algorithms.
 For example  StringSearch  implements language-sensitive pattern
 matching based on the comparison rules defined in a
  RuleBasedCollator  object.
  
 Other options for searching include using a BreakIterator to restrict
 the points at which matches are detected.
  SearchIterator  provides an API that is similar to that of
 other text iteration classes such as  BreakIterator . Using
 this class it is easy to scan through text looking for all occurrences of
 a given pattern. The following example uses a  StringSearch 
 object to find all instances of ""fox"" in the target string. Any other
 subclass of  SearchIterator  can be used in an identical
 manner.
  
 String target = ""The quick brown fox jumped over the lazy fox"";
 String pattern = ""fox"";
 SearchIterator iter = new StringSearch(pattern target);
 for (int pos = iter.first(); pos != SearchIterator.DONE;
         pos = iter.next()) {
     System.out.println(""Found match at "" + pos +
             "" length is "" + iter.getMatchLength());
 }"
android,icu.text,Transliterator,27,"Transliterator  is an abstract class that transliterates text from one format to another. The most common
 kind of transliterator is a script or alphabet transliterator. For example a Russian to Latin transliterator
 changes Russian text written in Cyrillic characters to phonetically equivalent Latin characters. It does not
  translate  Russian to English! Transliteration unlike translation operates on characters without reference
 to the meanings of words and sentences.

  
 Although script conversion is its most common use a transliterator can actually perform a more general class of
 tasks. In fact  Transliterator  defines a very general API which specifies only that a segment of the
 input text is replaced by new text. The particulars of this conversion are determined entirely by subclasses of
  Transliterator .

  Transliterators are stateless Transliterator  objects are  stateless ; they retain no information between calls to
  transliterate() . As a result threads may share transliterators without synchronizing them. This might
 seem to limit the complexity of the transliteration operation. In practice subclasses perform complex
 transliterations by delaying the replacement of text until it is known that no other replacements are possible. In
 other words although the  Transliterator  objects are stateless the source text itself embodies all the
 needed information and delayed operation allows arbitrary complexity.

  Batch transliteration 
 The simplest way to perform transliteration is all at once on a string of existing text. This is referred to as
  batch  transliteration. For example given a string  input  and a transliterator  t 
 the call

  String result = t.transliterate(input);
  Replaceable Keyboard transliteration 
 Somewhat more involved is  keyboard  or incremental transliteration. This is the transliteration of text that
 is arriving from some source (typically the user's keyboard) one character at a time or in some other piecemeal
 fashion.

  
 In keyboard transliteration a  Replaceable  buffer stores the text. As text is inserted as much as
 possible is transliterated on the fly. This means a GUI that displays the contents of the buffer may show text being
 modified as each new character arrives.

  
 Consider the simple rule-based Transliterator:

  
 th>{theta} 
 t>{tau}
  
 t>|{tau} 
 {tau}h>{theta}
  transliterate() 
 Keyboard transliteration methods maintain a set of three indices that are updated with each call to
  transliterate()  including the cursor start and limit. These indices are changed by the method and
 they are passed in and out via a Position object. The  start  index marks the beginning of the substring
 that the transliterator will look at. It is advanced as text becomes committed (but it is not the committed index;
 that's the  cursor ). The  cursor  index described above marks the point at which the
 transliterator last stopped either because it reached the end or because it required more characters to
 disambiguate between possible inputs. The  cursor  can also be explicitly set by rules.
 Any characters before the  cursor  index are frozen; future keyboard
 transliteration calls within this input sequence will not change them. New text is inserted at the  limit 
 index which marks the end of the substring that the transliterator looks at.

  
 Because keyboard transliteration assumes that more characters are to arrive it is conservative in its operation. It
 only transliterates when it can do so unambiguously. Otherwise it waits for more characters to arrive. When the
 client code knows that no more characters are forthcoming perhaps because the user has performed some input
 termination operation then it should call  finishTransliteration()  to complete any pending
 transliterations.

  Inverses 
 Pairs of transliterators may be inverses of one another. For example if transliterator  A  transliterates
 characters by incrementing their Unicode value (so ""abc"" -> ""def"") and transliterator  B  decrements character
 values then  A  is an inverse of  B  and vice versa. If we compose  A  with  B  in a compound
 transliterator the result is the indentity transliterator that is a transliterator that does not change its input
 text.

 The  Transliterator  method  getInverse()  returns a transliterator's inverse if one exists
 or  null  otherwise. However the result of  getInverse()  usually will  not  be a true
 mathematical inverse. This is because true inverse transliterators are difficult to formulate. For example consider
 two transliterators:  AB  which transliterates the character 'A' to 'B' and  BA  which transliterates
 'B' to 'A'. It might seem that these are exact inverses since

  ""A"" x  AB  -> ""B"" 
 ""B"" x  BA  -> ""A"" ""ABCD"" x  AB  -> ""BBCD"" 
 ""BBCD"" x  BA  -> ""AACD"" AB BA BA AB AB .getInverse() BA Filtering Each transliterator has a filter which restricts changes to those characters selected by the filter. The
 filter affects just the characters that are changed -- the characters outside of the filter are still part of the
 context for the filter. For example in the following even though 'x' is filtered out and doesn't convert to y it does affect the conversion of 'a'.

  
 String rules = ""x > y; x{a} > b; "";
 Transliterator tempTrans = Transliterator.createFromRules(""temp"" rules Transliterator.FORWARD);
 tempTrans.setFilter(new UnicodeSet(""[a]""));
 String tempResult = tempTrans.transform(""xa"");
 // results in ""xb""
 IDs and display names 
 A transliterator is designated by a short identifier string or  ID . IDs follow the format
  source-destination  where  source  describes the entity being replaced and  destination 
 describes the entity replacing  source . The entities may be the names of scripts particular sequences of
 characters or whatever else it is that the transliterator converts to or from. For example a transliterator from
 Russian to Latin might be named ""Russian-Latin"". A transliterator from keyboard escape sequences to Latin-1
 characters might be named ""KeyboardEscape-Latin1"". By convention system entity names are in English with the
 initial letters of words capitalized; user entity names may follow any format so long as they do not contain dashes.

  
 In addition to programmatic IDs transliterator objects have display names for presentation in user interfaces
 returned by  getDisplayName(String) .

  Composed transliterators 
 In addition to built-in system transliterators like ""Latin-Greek"" there are also built-in  composed 
 transliterators. These are implemented by composing two or more component transliterators. For example if we have
 scripts ""A"" ""B"" ""C"" and ""D"" and we want to transliterate between all pairs of them then we need to write 12
 transliterators: ""A-B"" ""A-C"" ""A-D"" ""B-A""... ""D-A"" ""D-B"" ""D-C"". If it is possible to convert all scripts to an
 intermediate script ""M"" then instead of writing 12 rule sets we only need to write 8: ""A~M"" ""B~M"" ""C~M"" ""D~M""
 ""M~A"" ""M~B"" ""M~C"" ""M~D"". (This might not seem like a big win but it's really 2 n  vs.  n 2  -  n  so as  n  gets larger the gain becomes significant. With 9 scripts it's 18 vs. 72
 rule sets a big difference.) Note the use of ""~"" rather than ""-"" for the script separator here; this indicates that
 the given transliterator is intended to be composed with others rather than be used as is.

  
 Composed transliterators can be instantiated as usual. For example the system transliterator ""Devanagari-Gujarati""
 is a composed transliterator built internally as ""Devanagari~InterIndic;InterIndic~Gujarati"". When this
 transliterator is instantiated it appears externally to be a standard transliterator (e.g. getID() returns
 ""Devanagari-Gujarati"").

  Rule syntax A set of rules determines how to perform translations.
 Rules within a rule set are separated by semicolons (';').
 To include a literal semicolon prefix it with a backslash ('\').
 Unicode Pattern_White_Space is ignored.
 If the first non-blank character on a line is '#'
 the entire line is ignored as a comment.

  Each set of rules consists of two groups one forward and one
 reverse. This is a convention that is not enforced; rules for one
 direction may be omitted with the result that translations in
 that direction will not modify the source text. In addition
 bidirectional forward-reverse rules may be specified for
 symmetrical transformations.

  Note: Another description of the Transliterator rule syntax is available in
  section
 Transform Rules Syntax of UTS #35: Unicode LDML .
 The rules are shown there using arrow symbols â† and â†’ and â†”.
 ICU supports both those and the equivalent ASCII symbols < and > and <>.

  Rule statements take one of the following forms:

  $alefmadda=\\u0622; Variable definition.  The name on the
         left is assigned the text on the right. In this example
         after this statement instances of the left hand name
         "" $alefmadda "" will be replaced by
         the Unicode character U+0622. Variable names must begin
         with a letter and consist only of letters digits and
         underscores. Case is significant. Duplicate names cause
         an exception to be thrown that is variables cannot be
         redefined. The right hand side may contain well-formed
         text of any length including no text at all ("" $empty=; "").
         The right hand side may contain embedded  UnicodeSet 
         patterns for example "" $softvowel=[eiyEIY] "". ai>$alefmadda; Forward translation rule.  This rule
         states that the string on the left will be changed to the
         string on the right when performing forward
         transliteration. ai<$alefmadda; Reverse translation rule.  This rule
         states that the string on the right will be changed to
         the string on the left when performing reverse
         transliteration. ai<>$alefmadda; Bidirectional translation rule.  This
         rule states that the string on the right will be changed
         to the string on the left when performing forward
         transliteration and vice versa when performing reverse
         transliteration. Translation rules consist of a  match pattern  and an  output
 string . The match pattern consists of literal characters
 optionally preceded by context and optionally followed by
 context. Context characters like literal pattern characters
 must be matched in the text being transliterated. However unlike
 literal pattern characters they are not replaced by the output
 text. For example the pattern "" abc{def} ""
 indicates the characters "" def "" must be
 preceded by "" abc "" for a successful match.
 If there is a successful match "" def "" will
 be replaced but not "" abc "". The final ' } '
 is optional so "" abc{def "" is equivalent to
 "" abc{def} "". Another example is "" {123}456 ""
 (or "" 123}456 "") in which the literal
 pattern "" 123 "" must be followed by "" 456 "".

  The output string of a forward or reverse rule consists of
 characters to replace the literal pattern characters. If the
 output string contains the character ' | ' this is
 taken to indicate the location of the  cursor  after
 replacement. The cursor is the point in the text at which the
 next replacement if any will be applied. The cursor is usually
 placed within the replacement text; however it can actually be
 placed into the precending or following context by using the
 special character '@'. Examples:

  
     a {foo} z > | @ bar; # foo -> bar move cursor before a
     {foo} xyz > bar @@|; #Â foo -> bar cursor between y and z
  UnicodeSet UnicodeSet  patterns may appear anywhere that
 makes sense. They may appear in variable definitions.
 Contrariwise  UnicodeSet  patterns may themselves
 contain variable references such as "" $a=[a-z];$not_a=[^$a] ""
 or "" $range=a-z;$ll=[$range] "".

  UnicodeSet  patterns may also be embedded directly
 into rule strings. Thus the following two rules are equivalent:

  
     $vowel=[aeiou]; $vowel>'*'; # One way to do this
     [aeiou]>'*'; # Another way
  See  UnicodeSet  for more documentation and examples.

  Segments Segments of the input string can be matched and copied to the
 output string. This makes certain sets of rules simpler and more
 general and makes reordering possible. For example:

  
     ([a-z]) > $1 $1; # double lowercase letters
     ([:Lu:]) ([:Ll:]) > $2 $1; # reverse order of Lu-Ll pairs
  The segment of the input string to be copied is delimited by
 "" ( "" and "" ) "". Up to
 nine segments may be defined. Segments may not overlap. In the
 output string "" $1 "" through "" $9 ""
 represent the input string segments in left-to-right order of
 definition.

  Anchors Patterns can be anchored to the beginning or the end of the text. This is done with the
 special characters ' ^ ' and ' $ '. For example:

  
   ^ aÂ Â  > 'BEG_A'; Â Â # match 'a' at start of text
   Â  aÂ Â  > 'A'; # match other instances of 'a'
   Â  z $ > 'END_Z'; Â Â # match 'z' at end of text
   Â  zÂ Â  > 'Z';Â Â Â Â Â Â  # match other instances of 'z'
  It is also possible to match the beginning or the end of the text using a  UnicodeSet .
 This is done by including a virtual anchor character ' $ ' at the end of the
 set pattern. Although this is usually the match chafacter for the end anchor the set will
 match either the beginning or the end of the text depending on its placement. For
 example:

  
   $x = [a-z$]; Â Â # match 'a' through 'z' OR anchor
   $x 1Â Â Â  > 2;Â Â  # match '1' after a-z or at the start
   Â Â  3 $x > 4; Â Â # match '3' before a-z or at the end
  Example The following example rules illustrate many of the features of
 the rule language.

  Rule 1. abc{def}>x|y Rule 2. xyz>r Rule 3. yz>q Applying these rules to the string "" adefabcdefz ""
 yields the following results:

  |adefabcdefz Initial state no rules match. Advance
         cursor. a|defabcdefz Still no match. Rule 1 does not match
         because the preceding context is not present. ad|efabcdefz Still no match. Keep advancing until
         there is a match... ade|fabcdefz ... adef|abcdefz ... adefa|bcdefz ... adefab|cdefz ... adefabc|defz Rule 1 matches; replace "" def ""
         with "" xy "" and back up the cursor
         to before the ' y '. adefabcx|yz Although "" xyz "" is
         present rule 2 does not match because the cursor is
         before the ' y ' not before the ' x '.
         Rule 3 does match. Replace "" yz ""
         with "" q "". adefabcxq| The cursor is at the end;
         transliteration is complete. The order of rules is significant. If multiple rules may match
 at some point the first matching rule is applied.

  Forward and reverse rules may have an empty output string.
 Otherwise an empty left or right hand side of any statement is a
 syntax error.

  Single quotes are used to quote any character other than a
 digit or letter. To specify a single quote itself inside or
 outside of quotes use two single quotes in a row. For example
 the rule "" '>'>o''clock "" changes the
 string "" > "" to the string "" o'clock "".

  Notes While a Transliterator is being built from rules it checks that
 the rules are added in proper order. For example if the rule
 ""a>x"" is followed by the rule ""ab>y""
 then the second rule will throw an exception. The reason is that
 the second rule can never be triggered since the first rule
 always matches anything it matches. In other words the first
 rule  masks  the second rule."
android,icu.text,LocaleDisplayNames.UiListItem,4,Struct-like class used to return information for constructing a UI list each corresponding to a locale.
android,icu.text,Normalizer2,21,"Unicode normalization functionality for standard Unicode normalization or
 for using custom mapping tables.
 All instances of this class are unmodifiable/immutable.
 The Normalizer2 class is not intended for public subclassing.
  
 The primary functions are to produce a normalized string and to detect whether
 a string is already normalized.
 The most commonly used normalization forms are those defined in
 http://www.unicode.org/unicode/reports/tr15/
 However this API supports additional normalization forms for specialized purposes.
 For example NFKC_Casefold is provided via getInstance(""nfkc_cf"" COMPOSE)
 and can be used in implementations of UTS #46.
  
 Not only are the standard compose and decompose modes supplied
 but additional modes are provided as documented in the Mode enum.
  
 Some of the functions in this class identify normalization boundaries.
 At a normalization boundary the portions of the string
 before it and starting from it do not interact and can be handled independently.
  
 The spanQuickCheckYes() stops at a normalization boundary.
 When the goal is a normalized string then the text before the boundary
 can be copied and the remainder can be processed with normalizeSecondAndAppend().
  
 The hasBoundaryBefore() hasBoundaryAfter() and isInert() functions test whether
 a character is guaranteed to be at a normalization boundary
 regardless of context.
 This is used for moving from one normalization boundary to the next
 or preceding boundary and for performing iterative normalization.
  
 Iterative normalization is useful when only a small portion of a
 longer string needs to be processed.
 For example in ICU iterative normalization is used by the NormalizationTransliterator
 (to avoid replacing already-normalized text) and ucol_nextSortKeyPart()
 (to process only the substring for which sort key bytes are computed).
  
 The set of normalization boundaries returned by these functions may not be
 complete: There may be more boundaries that could be returned.
 Different functions may return different boundaries."
android,icu.text,RelativeDateTimeFormatter,14,"Formats simple relative dates. There are two types of relative dates that
 it handles:
  relative dates with a quantity e.g ""in 5 days"" relative dates without a quantity e.g ""next Tuesday"" 
 This API is very basic and is intended to be a building block for more
 fancy APIs. The caller tells it exactly what to display in a locale
 independent way. While this class automatically provides the correct plural
 forms the grammatical form is otherwise as neutral as possible. It is the
 caller's responsibility to handle cut-off logic such as deciding between
 displaying ""in 7 days"" or ""in 1 week."" This API supports relative dates
 involving one single unit. This API does not support relative dates
 involving compound units.
 e.g ""in 5 days and 4 hours"" nor does it support parsing.
 This class is both immutable and thread-safe.
  
 Here are some examples of use:
  
 RelativeDateTimeFormatter fmt = RelativeDateTimeFormatter.getInstance();
 fmt.format(1 Direction.NEXT RelativeUnit.DAYS); // ""in 1 day""
 fmt.format(3 Direction.NEXT RelativeUnit.DAYS); // ""in 3 days""
 fmt.format(3.2 Direction.LAST RelativeUnit.YEARS); // ""3.2 years ago""

 fmt.format(Direction.LAST AbsoluteUnit.SUNDAY); // ""last Sunday""
 fmt.format(Direction.THIS AbsoluteUnit.SUNDAY); // ""this Sunday""
 fmt.format(Direction.NEXT AbsoluteUnit.SUNDAY); // ""next Sunday""
 fmt.format(Direction.PLAIN AbsoluteUnit.SUNDAY); // ""Sunday""

 fmt.format(Direction.LAST AbsoluteUnit.DAY); // ""yesterday""
 fmt.format(Direction.THIS AbsoluteUnit.DAY); // ""today""
 fmt.format(Direction.NEXT AbsoluteUnit.DAY); // ""tomorrow""

 fmt.format(Direction.PLAIN AbsoluteUnit.NOW); // ""now""
  
 In the future we may add more forms such as abbreviated/short forms
 (3 secs ago) and relative day periods (""yesterday afternoon"") etc."
android,icu.text,UFormat,0,"An abstract class that extends  Format  to provide
 additional ICU protocol specifically the  getLocale() 
 API.  All ICU format classes are subclasses of this class."
android,icu.text,UnicodeSet,86,"A mutable set of Unicode characters and multicharacter strings.
 Objects of this class represent  character classes  used
 in regular expressions. A character specifies a subset of Unicode
 code points.  Legal code points are U+0000 to U+10FFFF inclusive.

 Note: method freeze() will not only make the set immutable but
 also makes important methods much higher performance:
 contains(c) containsNone(...) span(...) spanBack(...) etc.
 After the object is frozen any subsequent call that wants to change
 the object will throw UnsupportedOperationException.

  The UnicodeSet class is not designed to be subclassed.

  UnicodeSet  supports two APIs. The first is the
  operand  API that allows the caller to modify the value of
 a  UnicodeSet  object. It conforms to Java 2's
  java.util.Set  interface although
  UnicodeSet  does not actually implement that
 interface. All methods of  Set  are supported with the
 modification that they take a character range or single character
 instead of an  Object  and they take a
  UnicodeSet  instead of a  Collection .  The
 operand API may be thought of in terms of boolean logic: a boolean
 OR is implemented by  add  a boolean AND is implemented
 by  retain  a boolean XOR is implemented by
  complement  taking an argument and a boolean NOT is
 implemented by  complement  with no argument.  In terms
 of traditional set theory function names  add  is a
 union  retain  is an intersection  remove 
 is an asymmetric difference and  complement  with no
 argument is a set complement with respect to the superset range
  MIN_VALUE-MAX_VALUE The second API is the
  applyPattern() / toPattern()  API from the
  java.text.Format -derived classes.  Unlike the
 methods that add characters add categories and control the logic
 of the set the method  applyPattern()  sets all
 attributes of a  UnicodeSet  at once based on a
 string pattern.

  Pattern syntax applyPattern() toPattern() [] No characters [a] The character 'a' [ae] The characters 'a' and 'e' [a-e] The characters 'a' through 'e' inclusive in Unicode code
       point order [\\u4E01] The character U+4E01 [a{ab}{ac}] The character 'a' and the multicharacter strings ""ab"" and
       ""ac"" [\p{Lu}] All characters in the general category Uppercase Letter Property patterns specify a set of characters having a certain
 property as defined by the Unicode standard.  Both the POSIX-like
 ""[:Lu:]"" and the Perl-like syntax ""\p{Lu}"" are recognized.  For a
 complete list of supported property patterns see the User's Guide
 for UnicodeSet at
  
 http://www.icu-project.org/userguide/unicodeSet.html .
 Actual determination of property data is defined by the underlying
 Unicode database as implemented by UCharacter.

  Patterns specify individual characters ranges of characters and
 Unicode property sets.  When elements are concatenated they
 specify their union.  To complement a set place a '^' immediately
 after the opening '['.  Property patterns are inverted by modifying
 their delimiters; ""[:^foo]"" and ""\P{foo}"".  In any other location
 '^' has no special meaning.

  Ranges are indicated by placing two a '-' between two
 characters as in ""a-z"".  This specifies the range of all
 characters from the left to the right in Unicode order.  If the
 left character is greater than or equal to the
 right character it is a syntax error.  If a '-' occurs as the first
 character after the opening '[' or '[^' or if it occurs as the
 last character before the closing ']' then it is taken as a
 literal.  Thus ""[a\\-b]"" ""[-ab]"" and ""[ab-]"" all indicate the same
 set of three characters 'a' 'b' and '-'.

  Sets may be intersected using the '&' operator or the asymmetric
 set difference may be taken using the '-' operator for example
 ""[[:L:]&[\\u0000-\\u0FFF]]"" indicates the set of all Unicode letters
 with values less than 4096.  Operators ('&' and '|') have equal
 precedence and bind left-to-right.  Thus
 ""[[:L:]-[a-z]-[\\u0100-\\u01FF]]"" is equivalent to
 ""[[[:L:]-[a-z]]-[\\u0100-\\u01FF]]"".  This only really matters for
 difference; intersection is commutative.

  [a] The set containing 'a'
  [a-z] The set containing 'a'
 through 'z' and all letters in between in Unicode order
  [^a-z] The set containing
 all characters but 'a' through 'z'
 that is U+0000 through 'a'-1 and 'z'+1 through U+10FFFF
  [[ pat1 ][ pat2 ]] The union of sets specified by  pat1  and  pat2 [[ pat1 ]&[ pat2 ]] The intersection of sets specified by  pat1  and  pat2 [[ pat1 ]-[ pat2 ]] The asymmetric difference of sets specified by  pat1  and
  pat2 [:Lu:] or \p{Lu} The set of characters having the specified
 Unicode property; in
 this case Unicode uppercase letters
  [:^Lu:] or \P{Lu} The set of characters  not  having the given
 Unicode property
  Warning : you cannot add an empty string ("""") to a UnicodeSet. Formal syntax pattern :=Â   ('[' '^'? item* ']') |
       property item :=Â   char | (char '-' char) | pattern-expr pattern-expr :=Â   pattern | pattern-expr pattern |
       pattern-expr op pattern op :=Â   '&' | '-' special :=Â   '[' | ']' | '-' char :=Â   any character that is not  special 
       | ('\\'  any character ) 
       | ('\u' hex hex hex hex) hex :=Â   any character for which
        Character.digit(c 16) 
       returns a non-negative result property :=Â   a Unicode property set pattern Legend:  a := b a  may be replaced by  b a? zero or one instance of  a a* one or more instances of  a a | b either  a  or  b 'a' the literal string between the quotes  To iterate over contents of UnicodeSet the following are available:
  ranges()  to iterate through the ranges strings()  to iterate through the strings iterator()  to iterate through the entire contents in a single loop.
 That method is however not particularly efficient since it ""boxes"" each code point into a String.
  for UnicodeSetIterator for To replace count elements or delete spans see  UnicodeSetSpanner ."
android,mtp,MtpConstants,1,A class containing constants in the MTP and PTP specifications.
android,mtp,MtpDevice,23,"This class represents an MTP or PTP device connected on the USB host bus. An application can
 instantiate an object of this type by referencing an attached  UsbDevice  and then use methods in this class to get information about the
 device and objects stored on it as well as open the connection and transfer data."
android,mtp,MtpDeviceInfo,8,"This class encapsulates information about an MTP device.
 This corresponds to the DeviceInfo Dataset described in
 section 5.1.1 of the MTP specification."
android,mtp,MtpObjectInfo,28,"This class encapsulates information about an object on an MTP device.
 This corresponds to the ObjectInfo Dataset described in
 section 5.3.1 of the MTP specification."
android,mtp,MtpObjectInfo.Builder,21,Builds a new object info instance.
android,mtp,MtpStorageInfo,5,"This class encapsulates information about a storage unit on an MTP device.
 This corresponds to the StorageInfo Dataset described in
 section 5.2.2 of the MTP specification."
android,mtp,MtpEvent,10,"This class encapsulates information about a MTP event.
 This corresponds to the events described in appendix G of the MTP specification."
android,net.nsd,NsdManager,5,"The Network Service Discovery Manager class provides the API to discover services
 on a network. As an example if device A and device B are connected over a Wi-Fi
 network a game registered on device A can be discovered by a game on device
 B. Another example use case is an application discovering printers on the network.

   The API currently supports DNS based service discovery and discovery is currently
 limited to a local network over Multicast DNS. DNS service discovery is described at
 http://files.dns-sd.org/draft-cheshire-dnsext-dns-sd.txt

   The API is asynchronous and responses to requests from an application are on listener
 callbacks on a separate internal thread.

   There are three main operations the API supports - registration discovery and resolution.
  
                          Application start
                                 |
                                 |
                                 |                  onServiceRegistered()
                     Register any local services  /
                      to be advertised with       \
 *                       registerService()            onRegistrationFailed()
                                 |
                                 |
                          discoverServices()
                                 |
                      Maintain a list to track
                        discovered services
                                 |
                                 |--------->
                                 |          |
                                 |      onServiceFound()
                                 |          |
                                 |     add service to list
                                 |          |
                                 |
                                 |          |
                                 |      onServiceLost()
                                 |          |
                                 |   remove service from list
                                 |          |
                                 |
 An application that needs to advertise itself over a network for other applications to
 discover it can do so with a call to  registerService(NsdServiceInfo int NsdManager.RegistrationListener) . If Example is a http based
 application that can provide HTML data to peer services it can register a name ""Example""
 with service type ""_http._tcp"". A successful registration is notified with a callback to
  RegistrationListener#onServiceRegistered  and a failure to register is notified
 over  RegistrationListener#onRegistrationFailed  A peer application looking for http services can initiate a discovery for ""_http._tcp""
 with a call to  discoverServices(String int NsdManager.DiscoveryListener) . A service found is notified with a callback
 to  DiscoveryListener#onServiceFound  and a service lost is notified on
  DiscoveryListener#onServiceLost .

   Once the peer application discovers the ""Example"" http service and either needs to read the
 attributes of the service or wants to receive data from the ""Example"" application it can
 initiate a resolve with  resolveService(NsdServiceInfo NsdManager.ResolveListener)  to resolve the attributes host and port
 details. A successful resolve is notified on  ResolveListener#onServiceResolved  and a
 failure is notified on  ResolveListener#onResolveFailed .

 Applications can reserve for a service type at
 http://www.iana.org/form/ports-service. Existing services can be found at
 http://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xml"
android,net.nsd,NsdServiceInfo,14,A class representing service information for network service discovery
android,media.tv,TvContentRating,10,"A class representing a TV content rating. When a TV input service inserts the content rating
 information on a program into the database this class can be used to generate the formatted
 string for
  TvContract.Programs#COLUMN_CONTENT_RATING .
 To create a  TvContentRating  object use the
  TvContentRating.createRating  method with valid rating system string
 constants.

  It is possible for an application to define its own content rating system by supplying a
 content rating system definition XML resource (see example below) and declaring a broadcast
 receiver that filters  TvInputManager#ACTION_QUERY_CONTENT_RATING_SYSTEMS  in its manifest.

   Example: Rating system definition for the TV Parental Guidelines 
 <rating-system-definitions xmlns:android=""http://schemas.android.com/apk/res/android""
     android:versionCode=""1"">
     <rating-system-definition android:name=""US_TV""
         android:country=""US""
         android:description=""@string/description_us_tv"">
         <sub-rating-definition android:name=""US_TV_D""
             android:title=""D""
             android:description=""@string/description_us_tv_d"" />
         <sub-rating-definition android:name=""US_TV_L""
             android:title=""L""
             android:description=""@string/description_us_tv_l"" />
         <sub-rating-definition android:name=""US_TV_S""
             android:title=""S""
             android:description=""@string/description_us_tv_s"" />
         <sub-rating-definition android:name=""US_TV_V""
             android:title=""V""
             android:description=""@string/description_us_tv_v"" />
         <sub-rating-definition android:name=""US_TV_FV""
             android:title=""FV""
             android:description=""@string/description_us_tv_fv"" />

         <rating-definition android:name=""US_TV_Y""
             android:title=""TV-Y""
             android:description=""@string/description_us_tv_y""
             android:icon=""@drawable/icon_us_tv_y""
             android:contentAgeHint=""0"" />
         <rating-definition android:name=""US_TV_Y7""
             android:title=""TV-Y7""
             android:description=""@string/description_us_tv_y7""
             android:icon=""@drawable/icon_us_tv_y7""
             android:contentAgeHint=""7"">
             <sub-rating android:name=""US_TV_FV"" />
         </rating-definition>
         <rating-definition android:name=""US_TV_G""
             android:title=""TV-G""
             android:description=""@string/description_us_tv_g""
             android:icon=""@drawable/icon_us_tv_g""
             android:contentAgeHint=""0"" />
         <rating-definition android:name=""US_TV_PG""
             android:title=""TV-PG""
             android:description=""@string/description_us_tv_pg""
             android:icon=""@drawable/icon_us_tv_pg""
             android:contentAgeHint=""14"">
             <sub-rating android:name=""US_TV_D"" />
             <sub-rating android:name=""US_TV_L"" />
             <sub-rating android:name=""US_TV_S"" />
             <sub-rating android:name=""US_TV_V"" />
         </rating-definition>
         <rating-definition android:name=""US_TV_14""
             android:title=""TV-14""
             android:description=""@string/description_us_tv_14""
             android:icon=""@drawable/icon_us_tv_14""
             android:contentAgeHint=""14"">
             <sub-rating android:name=""US_TV_D"" />
             <sub-rating android:name=""US_TV_L"" />
             <sub-rating android:name=""US_TV_S"" />
             <sub-rating android:name=""US_TV_V"" />
         </rating-definition>
         <rating-definition android:name=""US_TV_MA""
             android:title=""TV-MA""
             android:description=""@string/description_us_tv_ma""
             android:icon=""@drawable/icon_us_tv_ma""
             android:contentAgeHint=""17"">
             <sub-rating android:name=""US_TV_L"" />
             <sub-rating android:name=""US_TV_S"" />
             <sub-rating android:name=""US_TV_V"" />
         </rating-definition>
         <rating-order>
             <rating android:name=""US_TV_Y"" />
             <rating android:name=""US_TV_Y7"" />
         </rating-order>
         <rating-order>
             <rating android:name=""US_TV_G"" />
             <rating android:name=""US_TV_PG"" />
             <rating android:name=""US_TV_14"" />
             <rating android:name=""US_TV_MA"" />
         </rating-order>
     </rating-system-definition>
 </rating-system-definitions> System defined rating strings TvContentRating For example to create an object that represents TV-PG rating with suggestive dialogue and
 coarse language from the TV Parental Guidelines in the United States one can use the following
 code snippet:

  
 TvContentRating rating = TvContentRating.createRating(
         ""com.android.tv""
         ""US_TV""
         ""US_TV_PG""
         ""US_TV_D"" ""US_TV_L"");
  System defined string for domains Constant Value Description com.android.tv Used for creating system defined content ratings System defined strings for rating systems Constant Value Description AR_TV TV content rating system for Argentina AU_TV TV content rating system for Australia BR_TV TV content rating system for Brazil CA_TV_EN TV content rating system for Canada (English) CA_TV_FR TV content rating system for Canada (French) DVB DVB content rating system ES_DVB DVB content rating system for Spain FR_DVB DVB content rating system for France ISDB ISDB content rating system KR_TV TV content rating system for South Korea SG_TV TV content rating system for Singapore US_MV Movie content rating system for the United States US_TV TV content rating system for the United States System defined strings for ratings Rating System Constant Value Description AR_TV AR_TV_ATP Suitable for all audiences. Programs may contain mild violence language and mature
         situations AR_TV_SAM_13 Suitable for ages 13 and up. Programs may contain mild to moderate language and mild
         violence and sexual references AR_TV_SAM_16 Suitable for ages 16 and up. Programs may contain more intensive violence and coarse
         language partial nudity and moderate sexual references AR_TV_SAM_18 Suitable for mature audiences only. Programs contain strong violence coarse language
         and explicit sexual references AU_TV AU_TV_P Recommended for younger children aged between 2 and 11 years AU_TV_C Recommended for older children aged between 5 and 14 years AU_TV_G Recommended for all ages AU_TV_PG Parental guidance is recommended for young viewers under 15 AU_TV_M Recommended for mature audiences aged 15 years and over AU_TV_MA Not suitable for children and teens under 15 due to sexual descriptions course
         language adult themes or drug use AU_TV_AV Not suitable for children and teens under 15. This category is used specifically for
         violent programs AU_TV_R Not for children under 18. Content may include graphic violence sexual situations
         coarse language and explicit drug use BR_TV BR_TV_L Content is suitable for all audiences BR_TV_10 Content suitable for viewers over the age of 10 BR_TV_12 Content suitable for viewers over the age of 12 BR_TV_14 Content suitable for viewers over the age of 14 BR_TV_16 Content suitable for viewers over the age of 16 BR_TV_18 Content suitable for viewers over the age of 18 CA_TV_EN CA_TV_EN_EXEMPT Exempt from ratings CA_TV_EN_C Suitable for children ages 2â€“7 CA_TV_EN_C8 Suitable for children ages 8 and older CA_TV_EN_G Suitable for the entire family CA_TV_EN_PG May contain moderate violence profanity nudity and sexual references CA_TV_EN_14 Intended for viewers ages 14 and older CA_TV_EN_18 Intended for viewers ages 18 and older CA_TV_FR CA_TV_FR_E Exempt from ratings CA_TV_FR_G Appropriate for all ages CA_TV_FR_8 Appropriate for children 8 CA_TV_FR_13 Suitable for children 13 CA_TV_FR_16 Recommended for children over the age of 16 CA_TV_FR_18 Only to be viewed by adults DVB DVB_4 Recommended for ages 4 and over DVB_5 Recommended for ages 5 and over DVB_6 Recommended for ages 6 and over DVB_7 Recommended for ages 7 and over DVB_8 Recommended for ages 8 and over DVB_9 Recommended for ages 9 and over DVB_10 Recommended for ages 10 and over DVB_11 Recommended for ages 11 and over DVB_12 Recommended for ages 12 and over DVB_13 Recommended for ages 13 and over DVB_14 Recommended for ages 14 and over DVB_15 Recommended for ages 15 and over DVB_16 Recommended for ages 16 and over DVB_17 Recommended for ages 17 and over DVB_18 Recommended for ages 18 and over ES_DVB ES_DVB_ALL Recommended for all ages ES_DVB_C Recommended for children ES_DVB_X Recommended for adults ES_DVB_4 Recommended for ages 4 and over ES_DVB_5 Recommended for ages 5 and over ES_DVB_6 Recommended for ages 6 and over ES_DVB_7 Recommended for ages 7 and over ES_DVB_8 Recommended for ages 8 and over ES_DVB_9 Recommended for ages 9 and over ES_DVB_10 Recommended for ages 10 and over ES_DVB_11 Recommended for ages 11 and over ES_DVB_12 Recommended for ages 12 and over ES_DVB_13 Recommended for ages 13 and over ES_DVB_14 Recommended for ages 14 and over ES_DVB_15 Recommended for ages 15 and over ES_DVB_16 Recommended for ages 16 and over ES_DVB_17 Recommended for ages 17 and over ES_DVB_18 Recommended for ages 18 and over FR_DVB FR_DVB_U Recommended for all ages FR_DVB_4 Recommended for ages 4 and over FR_DVB_5 Recommended for ages 5 and over FR_DVB_6 Recommended for ages 6 and over FR_DVB_7 Recommended for ages 7 and over FR_DVB_8 Recommended for ages 8 and over FR_DVB_9 Recommended for ages 9 and over FR_DVB_10 Recommended for ages 10 and over FR_DVB_11 Recommended for ages 11 and over FR_DVB_12 Recommended for ages 12 and over FR_DVB_13 Recommended for ages 13 and over FR_DVB_14 Recommended for ages 14 and over FR_DVB_15 Recommended for ages 15 and over FR_DVB_16 Recommended for ages 16 and over FR_DVB_17 Recommended for ages 17 and over FR_DVB_18 Recommended for ages 18 and over ISDB ISDB_4 Recommended for ages 4 and over ISDB_5 Recommended for ages 5 and over ISDB_6 Recommended for ages 6 and over ISDB_7 Recommended for ages 7 and over ISDB_8 Recommended for ages 8 and over ISDB_9 Recommended for ages 9 and over ISDB_10 Recommended for ages 10 and over ISDB_11 Recommended for ages 11 and over ISDB_12 Recommended for ages 12 and over ISDB_13 Recommended for ages 13 and over ISDB_14 Recommended for ages 14 and over ISDB_15 Recommended for ages 15 and over ISDB_16 Recommended for ages 16 and over ISDB_17 Recommended for ages 17 and over ISDB_18 Recommended for ages 18 and over ISDB_19 Recommended for ages 19 and over ISDB_20 Recommended for ages 20 and over KR_TV KR_TV_ALL Appropriate for all ages KR_TV_7 May contain material inappropriate for children younger than 7 and parental
         discretion should be used KR_TV_12 May deemed inappropriate for those younger than 12 and parental discretion should be
         used KR_TV_15 May be inappropriate for children under 15 and that parental discretion should be
         used KR_TV_19 For adults only SG_TV SG_TV_G Suitable for all ages SG_TV_PG Suitable for all but parents should guide their young SG_TV_PG13 Suitable for persons aged 13 and above but parental guidance is advised for children
         below 13 SG_TV_NC16 Suitable for persons aged 16 and above SG_TV_M18 Suitable for persons aged 18 and above SG_TV_R21 Suitable for adults aged 21 and above US_MV US_MV_G General audiences US_MV_PG Parental guidance suggested US_MV_PG13 Parents strongly cautioned US_MV_R Restricted under 17 requires accompanying parent or adult guardian US_MV_NC17 No one 17 and under admitted US_TV US_TV_Y This program is designed to be appropriate for all children US_TV_Y7 This program is designed for children age 7 and above US_TV_G Most parents would find this program suitable for all ages US_TV_PG This program contains material that parents may find unsuitable for younger children
          US_TV_14 This program contains some material that many parents would find unsuitable for
         children under 14 years of age US_TV_MA This program is specifically designed to be viewed by adults and therefore may be
         unsuitable for children under 17 System defined strings for sub-ratings Rating System Constant Value Description BR_TV BR_TV_D Drugs Applicable to BR_TV_L BR_TV_10 BR_TV_12 BR_TV_14 BR_TV_16 and BR_TV_18
          BR_TV_S Sex Applicable to BR_TV_L BR_TV_10 BR_TV_12 BR_TV_14 BR_TV_16 and BR_TV_18
          BR_TV_V Violence Applicable to BR_TV_L BR_TV_10 BR_TV_12 BR_TV_14 BR_TV_16 and
         BR_TV_18 US_TV US_TV_D Suggestive dialogue (Usually means talks about sex) Applicable to US_TV_PG and
         US_TV_14 US_TV_L Coarse language Applicable to US_TV_PG US_TV_14 and US_TV_MA US_TV_S Sexual content Applicable to US_TV_PG US_TV_14 and US_TV_MA US_TV_V Violence Applicable to US_TV_PG US_TV_14 and US_TV_MA US_TV_FV Fantasy violence (Children's programming only) Applicable to US_TV_Y7"
android,media.tv,TvContract.PreviewPrograms,0,Column definitions for the preview TV programs table.
android,media.tv,TvContract.Programs.Genres,3,Canonical genres for TV programs.
android,media.tv,TvInputInfo.Builder,4,A convenience builder for creating  TvInputInfo  objects.
android,media.tv,TvInputService.HardwareSession,4,"Base class for a TV input session which represents an external device connected to a
 hardware TV input.

  This class is for an input which provides channels for the external set-top box to the
 application. Once a TV input returns an implementation of this class on
  TvInputService.onCreateSession(java.lang.String)  the framework will create a separate session for
 a hardware TV Input (e.g. HDMI 1) and forward the application's surface to the session so
 that the user can see the screen of the hardware TV Input when she tunes to a channel from
 this TV input. The implementation of this class is expected to change the channel of the
 external set-top box via a proprietary protocol when  HardwareSession#onTune  is
 requested by the application.

  Note that this class is not for inputs for internal hardware like built-in tuner and HDMI
 1."
android,media.tv,TvInputService.Session,36,Base class for derived classes to implement to provide a TV input session.
android,media.tv,TvRecordingClient.RecordingCallback,5,"Callback used to receive various status updates on the
  TvInputService.RecordingSession"
android,media.tv,TvTrackInfo.Builder,11,A builder class for creating  TvTrackInfo  objects.
android,media.tv,TvContract,22,"The contract between the TV provider and applications. Contains definitions for the supported
 URIs and columns.
  Overview TvContract defines a basic database of TV content metadata such as channel and program
 information. The information is stored in  Channels  and  Programs  tables.

  A row in the  Channels  table represents information about a TV channel. The data
         format can vary greatly from standard to standard or according to service provider thus
         the columns here are mostly comprised of basic entities that are usually seen to users
         regardless of standard such as channel number and name. A row in the  Programs  table represents a set of data describing a TV program such
         as program title and start time."
android,media.tv,TvContract.Channels,1,Column definitions for the TV channels table.
android,media.tv,TvContract.Channels.Logo,0,"A sub-directory of a single TV channel that represents its primary logo.

  To access this directory append  CONTENT_DIRECTORY  to the raw
 channel URI.  The resulting URI represents an image file and should be interacted
 using ContentResolver.openAssetFileDescriptor.

  Note that this sub-directory also supports opening the logo as an asset file in write
 mode.  Callers can create or replace the primary logo associated with this channel by
 opening the asset file and writing the full-size photo contents into it. (Make sure there
 is no padding around the logo image.) When the file is closed the image will be parsed
 sized down if necessary and stored.

  Usage example:
  
 public void writeChannelLogo(long channelId byte[] logo) {
     Uri channelLogoUri = TvContract.buildChannelLogoUri(channelId);
     try {
         AssetFileDescriptor fd =
             getContentResolver().openAssetFileDescriptor(channelLogoUri ""rw"");
         OutputStream os = fd.createOutputStream();
         os.write(logo);
         os.close();
         fd.close();
     } catch (IOException e) {
         // Handle error cases.
     }
 }"
android,media.tv,TvContract.Programs,0,"Column definitions for the TV programs table.

  By default the query results will be sorted by
  Programs#COLUMN_START_TIME_UTC_MILLIS  in ascending order."
android,media.tv,TvContract.RecordedPrograms,0,"Column definitions for the recorded TV programs table.

  By default the query results will be sorted by  COLUMN_START_TIME_UTC_MILLIS  in
 ascending order."
android,media.tv,TvContract.WatchNextPrograms,0,"Column definitions for the ""watch next"" TV programs table."
android,media.tv,TvInputManager,9,"Central system API to the overall TV input framework (TIF) architecture which arbitrates
 interaction between applications and the selected TV inputs.

  There are three primary parties involved in the TV input framework (TIF) architecture:

  The  TV input manager  as expressed by this class is the central point of the
 system that manages interaction between all other parts. It is expressed as the client-side API
 here which exists in each application context and communicates with a global system service that
 manages the interaction across all processes.
  A  TV input  implemented by  TvInputService  represents an input source
 of TV which can be a pass-through input such as HDMI or a tuner input which provides broadcast
 TV programs. The system binds to the TV input per applicationâ€™s request.
 on implementing TV inputs.
  Applications  talk to the TV input manager to list TV inputs and check their
 status. Once an application find the input to use it uses  TvView  or
  TvRecordingClient  for further interaction such as watching and recording broadcast TV
 programs."
android,media.tv,TvInputManager.TvInputCallback,5,Callback used to monitor status of the TV inputs.
android,media.tv,TvInputService,3,"The TvInputService class represents a TV input or source such as HDMI or built-in tuner which
 provides pass-through video or broadcast TV programs.

  Applications will not normally use this service themselves instead relying on the standard
 interaction provided by  TvView . Those implementing TV input services should normally do
 so by deriving from this class and providing their own session implementation based on
  TvInputService.Session . All TV input services must require that clients hold the
  Manifest.permission.BIND_TV_INPUT  in order to interact with the service; if this
 permission is not specified in the manifest the system will refuse to bind to that TV input
 service."
android,media.tv,TvInputService.RecordingSession,9,Base class for derived classes to implement to provide a TV input recording session.
android,media.tv,TvInputInfo,19,This class is used to specify meta information of a TV input.
android,media.tv,TvRecordingClient,6,"The public interface object used to interact with a specific TV input service for TV program
 recording."
android,media.tv,TvTrackInfo,16,Encapsulates the format of tracks played in  TvInputService .
android,media.tv,TvView,34,"Displays TV contents. The TvView class provides a high level interface for applications to show
 TV programs from various TV sources that implement  TvInputService . (Note that the list of
 TV inputs available on the system can be obtained by calling
  TvInputManager#getTvInputList() .)

  Once the application supplies the URI for a specific TV channel to  tune(String Uri) 
 method it takes care of underlying service binding (and unbinding if the current TvView is
 already bound to a service) and automatically allocates/deallocates resources needed. In addition
 to a few essential methods to control how the contents are presented it also provides a way to
 dispatch input events to the connected TvInputService in order to enable custom key actions for
 the TV input."
android,media.tv,TvView.TimeShiftPositionCallback,2,Callback used to receive time shift position changes.
android,media.tv,TvView.TvInputCallback,11,Callback used to receive various status updates on the  TvView .
android,net.rtp,AudioCodec,2,"This class defines a collection of audio codecs to be used with
  AudioStream s. Their parameters are designed to be exchanged using
 Session Description Protocol (SDP). Most of the values listed here can be
 found in RFC 3551 while others are described in separated standards.

  Few simple configurations are defined as public static instances for the
 convenience of direct uses. More complicated ones could be obtained using
  getCodec(int java.lang.String java.lang.String) . For example one can use the
 following snippet to create a mode-1-only AMR codec. 
 AudioCodec codec = AudioCodec.getCodec(100 ""AMR/8000"" ""mode-set=1"");"
android,net.rtp,AudioGroup,6,"An AudioGroup is an audio hub for the speaker the microphone and
  AudioStream s. Each of these components can be logically turned on
 or off by calling  setMode(int)  or  RtpStream#setMode(int) .
 The AudioGroup will go through these components and process them one by one
 within its execution loop. The loop consists of four steps. First for each
 AudioStream not in  RtpStream#MODE_SEND_ONLY  decodes its incoming
 packets and stores in its buffer. Then if the microphone is enabled
 processes the recorded audio and stores in its buffer. Third if the speaker
 is enabled mixes all AudioStream buffers and plays back. Finally for each
 AudioStream not in  RtpStream#MODE_RECEIVE_ONLY  mixes all other
 buffers and sends back the encoded packets. An AudioGroup does nothing if
 there is no AudioStream in it.

  Few things must be noticed before using these classes. The performance is
 highly related to the system load and the network bandwidth. Usually a
 simpler  AudioCodec  costs fewer CPU cycles but requires more network
 bandwidth and vise versa. Using two AudioStreams at the same time doubles
 not only the load but also the bandwidth. The condition varies from one
 device to another and developers should choose the right combination in
 order to get the best result. It is sometimes useful to keep multiple AudioGroups at the same time. For
 example a Voice over IP (VoIP) application might want to put a conference
 call on hold in order to make a new call but still allow people in the
 conference call talking to each other. This can be done easily using two
 AudioGroups but there are some limitations. Since the speaker and the
 microphone are globally shared resources only one AudioGroup at a time is
 allowed to run in a mode other than  MODE_ON_HOLD . The others will
 be unable to acquire these resources and fail silently. Using this class requires
  Manifest.permission.RECORD_AUDIO  permission. Developers
 should set the audio mode to  AudioManager#MODE_IN_COMMUNICATION 
 using  AudioManager#setMode(int)  and change it back when none of
 the AudioGroups is in use."
android,net.rtp,AudioStream,7,"An AudioStream is a  RtpStream  which carrys audio payloads over
 Real-time Transport Protocol (RTP). Two different classes are developed in
 order to support various usages such as audio conferencing. An AudioStream
 represents a remote endpoint which consists of a network mapping and a
 configured  AudioCodec . On the other side An  AudioGroup 
 represents a local endpoint which mixes all the AudioStreams and optionally
 interacts with the speaker and the microphone at the same time. The simplest
 usage includes one for each endpoints. For other combinations developers
 should be aware of the limitations described in  AudioGroup .

  An AudioStream becomes busy when it joins an AudioGroup. In this case most
 of the setter methods are disabled. This is designed to ease the task of
 managing native resources. One can always make an AudioStream leave its
 AudioGroup by calling  join(android.net.rtp.AudioGroup)  with  null  and put it
 back after the modification is done. Using this class requires
  Manifest.permission.INTERNET  permission."
android,net.rtp,RtpStream,10,"RtpStream represents the base class of streams which send and receive network
 packets with media payloads over Real-time Transport Protocol (RTP).

  Using this class requires
  Manifest.permission.INTERNET  permission."
android,net.http,HttpResponseCache,12,"Caches HTTP and HTTPS responses to the filesystem so they may be reused
 saving time and bandwidth. This class supports  HttpURLConnection  and  HttpsURLConnection ;
 there is no platform-provided cache for  DefaultHttpClient  or
  AndroidHttpClient . Installation and instances are thread
 safe.

  Installing an HTTP response cache application-specific
 cache directory protected void onCreate(Bundle savedInstanceState) {
       ...

       try {
           File httpCacheDir = new File(context.getCacheDir() ""http"");
           long httpCacheSize = 10 * 1024 * 1024; // 10 MiB
           HttpResponseCache.install(httpCacheDir httpCacheSize);
       } catch (IOException e) {
           Log.i(TAG ""HTTP response cache installation failed:"" + e);
       }
   }

   protected void onStop() {
       ...

       HttpResponseCache cache = HttpResponseCache.getInstalled();
       if (cache != null) {
           cache.flush();
       }
   } For some applications it may be preferable to create the cache in the
 external storage directory.  There are no access controls on the
 external storage directory so it should not be used for caches that could
 contain private data.  Although it often has more free space
 external storage is optional andâ€”even if availableâ€”can disappear
 during use. Retrieve the external cache directory using  Context.getExternalCacheDir() . If this method returns null
 your application should fall back to either not caching or caching on
 non-external storage. If the external storage is removed during use the
 cache hit rate will drop to zero and ongoing cache reads will fail.

  Flushing the cache forces its data to the filesystem. This ensures that
 all responses written to the cache will be readable the next time the
 activity starts.

  Cache Optimization Request Count:  the number
         of HTTP requests issued since this cache was created.
      Network Count:  the
         number of those requests that required network use.
      Hit Count:  the number of
         those requests whose responses were served by the cache.
  GET The best way to improve the cache hit rate is by configuring the web
 server to return cacheable responses. Although this client honors all  HTTP/1.1 (RFC 2068)  cache
 headers it doesn't cache partial responses.

  Force a Network Response no-cache connection.addRequestProperty(""Cache-Control"" ""no-cache"");
  max-age=0 connection.addRequestProperty(""Cache-Control"" ""max-age=0"");
  Force a Cache Response something only-if-cached try {
         connection.addRequestProperty(""Cache-Control"" ""only-if-cached"");
         InputStream cached = connection.getInputStream();
         // the resource was cached! show it
     } catch (FileNotFoundException e) {
         // the resource was not cached
     }
  max-stale int maxStale = 60 * 60 * 24 * 28; // tolerate 4-weeks stale
         connection.addRequestProperty(""Cache-Control"" ""max-stale="" + maxStale);
  Working With Earlier Releases try {
           File httpCacheDir = new File(context.getCacheDir() ""http"");
           long httpCacheSize = 10 * 1024 * 1024; // 10 MiB
           Class.forName(""android.net.http.HttpResponseCache"")
                   .getMethod(""install"" File.class long.class)
                   .invoke(null httpCacheDir httpCacheSize);
       } catch (Exception httpResponseCacheNotAvailable) {
       }"
android,net.http,SslCertificate,10,SSL certificate info (certificate details) class
android,net.http,SslCertificate.DName,4,"A distinguished name helper class: a 3-tuple of:
  the most specific common name (CN) the most specific organization (O) the most specific organizational unit (OU)"
android,net.http,SslError,6,"This class represents a set of one or more SSL errors and the associated SSL
 certificate."
android,net.http,X509TrustManagerExtensions,3,"X509TrustManager wrapper exposing Android-added features.
  
 The checkServerTrusted method allows callers to perform additional
 verification of certificate chains after they have been successfully verified
 by the platform."
android,net.ssl,SSLEngines,2,"Static utility methods for accessing additional functionality of supported instances of
  SSLEngine .  Engines from the platform TLS provider will be compatible with all
 methods in this class."
android,net.ssl,SSLSockets,2,"Static utility methods for accessing additional functionality of supported instances of
  SSLSocket .  Sockets from the platform TLS provider will be compatible with all
 methods in this class."
android,net.sip,SipAudioCall,20,"Handles an Internet audio call over SIP. You can instantiate this class with  SipManager 
 using  SipManager#makeAudioCall  and   SipManager#takeAudioCall .

  Note:  Using this class require the
    Manifest.permission.INTERNET  and
    Manifest.permission.USE_SIP  permissions. In addition  startAudio()  requires the
    Manifest.permission.RECORD_AUDIO 
    Manifest.permission.ACCESS_WIFI_STATE  and
    Manifest.permission.WAKE_LOCK  permissions; and  setSpeakerMode()  requires the
    Manifest.permission.MODIFY_AUDIO_SETTINGS  permission."
android,net.sip,SipAudioCall.Listener,10,"Listener for events relating to a SIP call such as when a call is being
 recieved (""on ringing"") or a call is outgoing (""on calling"").
  Many of these events are also received by  SipSession.Listener ."
android,net.sip,SipErrorCode,1,"Defines error codes returned during SIP actions. For example during
  SipRegistrationListener#onRegistrationFailed 
  SipSession.Listener#onError 
  SipSession.Listener#onCallChangeFailed  and
  SipSession.Listener#onRegistrationFailed ."
android,net.sip,SipManager,20,"Provides APIs for SIP tasks such as initiating SIP connections and provides access to related
 SIP services. This class is the starting point for any SIP actions. You can acquire an instance
 of it with  newInstance() . The APIs in this class allows you to: Create a  SipSession  to get ready for making calls or listen for incoming calls. See
  createSipSession()  and  getSessionFor() . Initiate and receive generic SIP calls or audio-only SIP calls. Generic SIP calls may
 be video audio or other and are initiated with  open() . Audio-only SIP calls
 should be handled with a  SipAudioCall  which you can acquire with  makeAudioCall()  and  takeAudioCall() . Register and unregister with a SIP service provider with
       register()  and  unregister() . Verify session connectivity with  isOpened()  and
       isRegistered() . Note:  Not all Android-powered devices support VOIP calls using
 SIP. You should always call  isVoipSupported()  to verify that the device supports VOIP calling and  isApiSupported()  to verify that the device supports
 the SIP APIs. Your application must also request the  Manifest.permission.INTERNET  and  Manifest.permission.USE_SIP 
 permissions."
android,net.sip,SipProfile,14,"Defines a SIP profile including a SIP account domain and server information.
  You can create a  SipProfile  using  SipProfile.Builder . You can also retrieve one from a  SipSession  using  SipSession#getLocalProfile  and  SipSession#getPeerProfile ."
android,net.sip,SipProfile.Builder,10,Helper class for creating a  SipProfile .
android,net.sip,SipSession,13,"Represents a SIP session that is associated with a SIP dialog or a standalone
 transaction not within a dialog.
  You can get a  SipSession  from  SipManager  with  SipManager#createSipSession  (when initiating calls) or  SipManager#getSessionFor  (when receiving calls)."
android,net.sip,SipSession.Listener,12,"Listener for events relating to a SIP session such as when a session is being registered
 (""on registering"") or a call is outgoing (""on calling"").
  Many of these events are also received by  SipAudioCall.Listener ."
android,net.sip,SipSession.State,1,"Defines SIP session states such as ""registering"" ""outgoing call"" and ""in call""."
android,net.wifi.hotspot2,ConfigParser,1,Utility class for building PasspointConfiguration from an installation file.
android,net.wifi.hotspot2,PasspointConfiguration,9,"Class representing Passpoint configuration.  This contains configurations specified in
 PerProviderSubscription (PPS) Management Object (MO) tree.

 For more info refer to Hotspot 2.0 PPS MO defined in section 9.1 of the Hotspot 2.0
 Release 2 Technical Specification."
android,net.wifi.hotspot2.omadm,PpsMoParser,1,"Utility class for converting OMA-DM (Open Mobile Alliance's Device Management)
 PPS-MO (PerProviderSubscription Management Object) XML tree to a
  PasspointConfiguration  object.

 Currently this only supports PerProviderSubscription/HomeSP and
 PerProviderSubscription/Credential subtree for Hotspot 2.0 Release 1 support.

 For more info refer to Hotspot 2.0 PPS MO defined in section 9.1 of the Hotspot 2.0
 Release 2 Technical Specification.

 Below is a sample XML string for a Release 1 PPS MO tree:

  1.2 PerProviderSubscription urn:wfa:mo:hotspot2dot0Â­perprovidersubscription:1.0 i001 HomeSP FriendlyName Century House FQDN mi6.co.uk RoamingConsortiumOI 112233445566 Credential Realm shaken.stirred.com UsernamePassword Username james Password Ym9uZDAwNw== EAPMethod EAPType 21 InnerMethod MS-CHAP-V2"
android,net.wifi.hotspot2.pps,Credential,19,"Class representing Credential subtree in the PerProviderSubscription (PPS)
 Management Object (MO) tree.
 For more info refer to Hotspot 2.0 PPS MO defined in section 9.1 of the Hotspot 2.0
 Release 2 Technical Specification.

 In addition to the fields in the Credential subtree this will also maintain necessary
 information for the private key and certificates associated with this credential."
android,net.wifi.hotspot2.pps,Credential.CertificateCredential,9,"Certificate based credential.  This is used for EAP-TLS.
 Contains fields under PerProviderSubscription/Credential/DigitalCertificate subtree."
android,net.wifi.hotspot2.pps,Credential.SimCredential,9,"SIM (Subscriber Identify Module) based credential.
 Contains fields under PerProviderSubscription/Credential/SIM subtree."
android,net.wifi.hotspot2.pps,Credential.UserCredential,13,"Username-password based credential.
 Contains the fields under PerProviderSubscription/Credential/UsernamePassword subtree."
android,net.wifi.hotspot2.pps,HomeSp,11,"Class representing HomeSP subtree in PerProviderSubscription (PPS)
 Management Object (MO) tree.

 For more info refer to Hotspot 2.0 PPS MO defined in section 9.1 of the Hotspot 2.0
 Release 2 Technical Specification."
android,net.wifi.aware,AttachCallback,2,"Base class for Aware attach callbacks. Should be extended by applications and set when calling
  WifiAwareManager#attach(AttachCallback android.os.Handler) . These are callbacks
 applying to the Aware connection as a whole - not to specific publish or subscribe sessions -
 for that see  DiscoverySessionCallback ."
android,net.wifi.aware,Characteristics,5,The characteristics of the Wi-Fi Aware implementation.
android,net.wifi.aware,DiscoverySession,4,"A class representing a single publish or subscribe Aware session. This object
 will not be created directly - only its child classes are available:
  PublishDiscoverySession  and  SubscribeDiscoverySession . This
 class provides functionality common to both publish and subscribe discovery sessions:
  Sending messages:  sendMessage(android.net.wifi.aware.PeerHandle int byte[])  method.
       Creating a network-specifier when requesting a Aware connection using
       WifiAwareNetworkSpecifier.Builder .
  
 The  close()  method must be called to destroy discovery sessions once they are
 no longer needed."
android,net.wifi.aware,DiscoverySessionCallback,10,"Base class for Aware session events callbacks. Should be extended by
 applications wanting notifications. The callbacks are set when a
 publish or subscribe session is created using
  WifiAwareSession#publish(PublishConfig DiscoverySessionCallback
 android.os.Handler)  or
  WifiAwareSession#subscribe(SubscribeConfig DiscoverySessionCallback
 android.os.Handler) .
  
 A single callback is set at session creation - it cannot be replaced."
android,net.wifi.aware,IdentityChangedListener,1,"Base class for a listener which is called with the MAC address of the Aware interface whenever
 it is changed. Change may be due to device joining a cluster starting a cluster or discovery
 interface change (addresses are randomized at regular intervals). The implication is that
 peers you've been communicating with may no longer recognize you and you need to re-establish
 your identity - e.g. by starting a discovery session. This actual MAC address of the
 interface may also be useful if the application uses alternative (non-Aware) discovery but needs
 to set up a Aware connection. The provided Aware discovery interface MAC address can then be used
 in  WifiAwareSession#createNetworkSpecifierOpen(int byte[])  or
  WifiAwareSession#createNetworkSpecifierPassphrase(int byte[] String) ."
android,net.wifi.aware,SubscribeConfig,5,"Defines the configuration of a Aware subscribe session. Built using
  SubscribeConfig.Builder . Subscribe is done using
  WifiAwareSession#subscribe(SubscribeConfig DiscoverySessionCallback
 android.os.Handler)  or
  SubscribeDiscoverySession#updateSubscribe(SubscribeConfig) ."
android,net.wifi.aware,WifiAwareNetworkSpecifier,2,"Network specifier object used to request a Wi-Fi Aware network. Apps should use the
  WifiAwareNetworkSpecifier.Builder  class to create an instance."
android,net.wifi.aware,WifiAwareNetworkSpecifier.Builder,4,"A builder class for a Wi-Fi Aware network specifier to set up an Aware connection with a
 peer."
android,net.wifi.aware,ParcelablePeerHandle,2,"A Parcelable  PeerHandle . Can be constructed from a  PeerHandle  and then passed
 to any of the APIs which take a  PeerHandle  as inputs."
android,net.wifi.aware,PeerHandle,2,"Opaque object used to represent a Wi-Fi Aware peer. Obtained from discovery sessions in
  DiscoverySessionCallback#onServiceDiscovered(PeerHandle byte[] java.util.List)  or
 received messages in  DiscoverySessionCallback#onMessageReceived(PeerHandle byte[])  and
 used when sending messages eg  DiscoverySession#sendMessage(PeerHandle int byte[]) 
 or when configuring a network link to a peer e.g.
  DiscoverySession#createNetworkSpecifierOpen(PeerHandle)  or
  DiscoverySession#createNetworkSpecifierPassphrase(PeerHandle String) .
  
 Note that while a  PeerHandle  can be used to track a particular peer (i.e. you can compare
 the values received from subsequent messages) - it is good practice not to rely on it. Instead
 use an application level peer identifier encoded in the message
  DiscoverySession#sendMessage(PeerHandle int byte[])  and/or in the Publish
 configuration's service-specific information field
  PublishConfig.Builder#setServiceSpecificInfo(byte[])  or match filter
  PublishConfig.Builder#setMatchFilter(java.util.List) .
  A parcelable handle object is available with  ParcelablePeerHandle ."
android,net.wifi.aware,PublishConfig,5,"Defines the configuration of a Aware publish session. Built using
  PublishConfig.Builder . A publish session is created using
  WifiAwareSession#publish(PublishConfig DiscoverySessionCallback
 android.os.Handler)  or updated using
  PublishDiscoverySession#updatePublish(PublishConfig) ."
android,net.wifi.aware,PublishConfig.Builder,8,Builder used to build  PublishConfig  objects.
android,net.wifi.aware,PublishDiscoverySession,1,"A class representing a Aware publish session. Created when
  WifiAwareSession#publish(PublishConfig DiscoverySessionCallback
 android.os.Handler)  is called and a discovery session is created and returned in
  DiscoverySessionCallback#onPublishStarted(PublishDiscoverySession) . See
 baseline functionality of all discovery sessions in  DiscoverySession . This
 object allows updating an existing/running publish discovery session using
  updatePublish(android.net.wifi.aware.PublishConfig) ."
android,net.wifi.aware,SubscribeConfig.Builder,9,Builder used to build  SubscribeConfig  objects.
android,net.wifi.aware,SubscribeDiscoverySession,1,"A class representing a Aware subscribe session. Created when
  WifiAwareSession#subscribe(SubscribeConfig
 DiscoverySessionCallback android.os.Handler) 
 is called and a discovery session is created and returned in
  DiscoverySessionCallback#onSubscribeStarted(SubscribeDiscoverySession) .
 See baseline functionality of all discovery sessions in  DiscoverySession .
 This object allows updating an existing/running subscribe discovery session using
  updateSubscribe(android.net.wifi.aware.SubscribeConfig) ."
android,net.wifi.aware,WifiAwareManager,4,"This class provides the primary API for managing Wi-Fi Aware operations:
 discovery and peer-to-peer data connections.
  
 The class provides access to:
  Initialize a Aware cluster (peer-to-peer synchronization). Refer to
  attach(android.net.wifi.aware.AttachCallback android.os.Handler) .
  Create discovery sessions (publish or subscribe sessions). Refer to
  WifiAwareSession#publish(PublishConfig DiscoverySessionCallback Handler)  and
  WifiAwareSession#subscribe(SubscribeConfig DiscoverySessionCallback Handler) .
  Create a Aware network specifier to be used with
  ConnectivityManager#requestNetwork(NetworkRequest ConnectivityManager.NetworkCallback) 
 to set-up a Aware connection with a peer. Refer to  WifiAwareNetworkSpecifier.Builder .
  
     Aware may not be usable when Wi-Fi is disabled (and other conditions). To validate that
     the functionality is available use the  isAvailable()  function. To track
     changes in Aware usability register for the  ACTION_WIFI_AWARE_STATE_CHANGED 
     broadcast. Note that this broadcast is not sticky - you should register for it and then
     check the above API to avoid a race condition.
  
     An application must use  attach(android.net.wifi.aware.AttachCallback android.os.Handler)  to initialize a
     Aware cluster - before making any other Aware operation. Aware cluster membership is a
     device-wide operation - the API guarantees that the device is in a cluster or joins a
     Aware cluster (or starts one if none can be found). Information about attach success (or
     failure) are returned in callbacks of  AttachCallback . Proceed with Aware
     discovery or connection setup only after receiving confirmation that Aware attach
     succeeded -  AttachCallback#onAttached(WifiAwareSession) . When an
     application is finished using Aware it  must  use the
      WifiAwareSession#close()  API to indicate to the Aware service that the device
     may detach from the Aware cluster. The device will actually disable Aware once the last
     application detaches.
  
     Once a Aware attach is confirmed use the
      WifiAwareSession#publish(PublishConfig DiscoverySessionCallback Handler) 
     or
      WifiAwareSession#subscribe(SubscribeConfig DiscoverySessionCallback
     Handler)  to create publish or subscribe Aware discovery sessions. Events are called on the
     provided callback object  DiscoverySessionCallback . Specifically the
      DiscoverySessionCallback#onPublishStarted(PublishDiscoverySession) 
     and
      DiscoverySessionCallback#onSubscribeStarted(
SubscribeDiscoverySession) 
     return  PublishDiscoverySession  and
      SubscribeDiscoverySession 
     objects respectively on which additional session operations can be performed e.g. updating
     the session  PublishDiscoverySession#updatePublish(PublishConfig)  and
      SubscribeDiscoverySession#updateSubscribe(SubscribeConfig) . Sessions can
     also be used to send messages using the
      DiscoverySession#sendMessage(PeerHandle int byte[])  APIs. When an
     application is finished with a discovery session it  must  terminate it using the
      DiscoverySession#close()  API.
  
    Creating connections between Aware devices is managed by the standard
     ConnectivityManager#requestNetwork(NetworkRequest
    ConnectivityManager.NetworkCallback) .
    The  NetworkRequest  object should be constructed with:
     NetworkRequest.Builder#addTransportType(int)  of
         NetworkCapabilities.TRANSPORT_WIFI_AWARE .
         NetworkRequest.Builder#setNetworkSpecifier(String)  using
         WifiAwareNetworkSpecifier.Builder ."
android,net.wifi.aware,WifiAwareNetworkInfo,6,"Wi-Fi Aware-specific network information. The information can be extracted from the
  NetworkCapabilities  of the network using
  NetworkCapabilities#getTransportInfo() .
 The  NetworkCapabilities  is provided by the connectivity service to apps e.g. received
 through the
  ConnectivityManager.NetworkCallback.onCapabilitiesChanged(android.net.Network android.net.NetworkCapabilities)  callback.
  
 The Wi-Fi Aware-specific network information include the peer's scoped link-local IPv6 address
 for the Wi-Fi Aware link as well as (optionally) the port and transport protocol specified by
 the peer.
 The scoped link-local IPv6 port and transport protocol can then be used to create a
  Socket  connection to the peer.
  
 Note: these are the peer's IPv6 and port information - not the local device's!"
android,net.wifi.aware,WifiAwareSession,5,"This class represents a Wi-Fi Aware session - an attachment to the Wi-Fi Aware service through
 which the app can execute discovery operations."
android,net,ConnectivityManager,42,"Class that answers queries about the state of network connectivity. It also
 notifies applications when network connectivity changes.
  
 The primary responsibilities of this class are to:
  Monitor network connections (Wi-Fi GPRS UMTS etc.) Send broadcast intents when network connectivity changes Attempt to ""fail over"" to another network when connectivity to a network
 is lost Provide an API that allows applications to query the coarse-grained or fine-grained
 state of the available networks Provide an API that allows applications to request and select networks for their data
 traffic"
android,net,Credentials,3,"A class for representing UNIX credentials passed via ancillary data
 on UNIX domain sockets. See ""man 7 unix"" on a desktop linux distro."
android,net,DhcpInfo,1,A simple object for retrieving the results of a DHCP request.
android,net,DnsResolver,5,"Dns resolver class for asynchronous dns querying

 Note that if a client sends a query with more than 1 record in the question section but
 the remote dns server does not support this it may not respond at all leading to a timeout."
android,net,InetAddresses,2,Utility methods for  InetAddress  implementations.
android,net,IpSecAlgorithm,6,This class represents a single algorithm that can be used by an  IpSecTransform .
android,net,IpSecManager.UdpEncapsulationSocket,5,"This class provides access to a UDP encapsulation Socket.

  UdpEncapsulationSocket  wraps a system-provided datagram socket intended for IKEv2
 signalling and UDP encapsulated IPsec traffic. Instances can be obtained by calling  IpSecManager#openUdpEncapsulationSocket . The provided socket cannot be re-bound by the
 caller. The caller should not close the  FileDescriptor  returned by  getFileDescriptor()  but should use  close()  instead.

  Allowing the user to close or unbind a UDP encapsulation socket could impact the traffic
 of the next user who binds to that port. To prevent this scenario these sockets are held
 open by the system so that they may only be closed by calling  close()  or when the user
 process exits."
android,net,IpSecTransform,3,"This class represents a transform which roughly corresponds to an IPsec Security Association.

  Transforms are created using  IpSecTransform.Builder . Each  IpSecTransform 
 object encapsulates the properties and state of an IPsec security association. That includes
 but is not limited to algorithm choice key material and allocated system resources."
android,net,LinkProperties,22,"Describes the properties of a network link.

 A link represents a connection to a network.
 It may have multiple addresses and multiple gateways
 multiple dns servers but only one http proxy and one
 network interface.

 Note that this is just a holder of data.  Modifying it
 does not affect live networks."
android,net,NetworkSpecifier,0,"Describes specific properties of a requested network for use in a  NetworkRequest .

 Applications cannot instantiate this class by themselves but can obtain instances of
 subclasses of this class via other APIs."
android,net,ProxyInfo,10,"Describes a proxy configuration.

 Proxy configurations are already integrated within the  java.net  and
 Apache HTTP stack. So  URLConnection  and Apache's  HttpClient  will use
 them automatically.

 Other HTTP stacks will need to obtain the proxy info from
  Proxy#PROXY_CHANGE_ACTION  broadcast as the extra  Proxy#EXTRA_PROXY_INFO ."
android,net,SocketKeepalive,3,"Allows applications to request that the system periodically send specific packets on their
 behalf using hardware offload to save battery power.

 To request that the system send keepalives call one of the methods that return a
  SocketKeepalive  object such as  ConnectivityManager#createSocketKeepalive 
 passing in a non-null callback. If the  SocketKeepalive  is successfully
 started the callback's  onStarted  method will be called. If an error occurs
  onError  will be called specifying one of the  ERROR_*  constants in this
 class.

 To stop an existing keepalive call  SocketKeepalive#stop . The system will call
  SocketKeepalive.Callback#onStopped  if the operation was successful or
  SocketKeepalive.Callback#onError  if an error occurred.

 For cellular the device MUST support at least 1 keepalive slot.

 For WiFi the device SHOULD support keepalive offload. If it does not it MUST reply with
  SocketKeepalive.Callback#onError  with  ERROR_UNSUPPORTED  to any keepalive offload
 request. If it does it MUST support at least 3 concurrent keepalive slots."
android,net,SSLCertificateSocketFactory,17,"SSLSocketFactory implementation with several extra features:

  Timeout specification for SSL handshake operations
  Hostname verification in most cases (see WARNINGs below)
  Optional SSL session caching with  SSLSessionCache Optionally bypass all SSL certificate checks
  createSocket() Socket#connect(java.net.SocketAddress int) The recommended way to verify the server's identity is to use
  HttpsURLConnection#getDefaultHostnameVerifier()  to get a
  HostnameVerifier  to verify the certificate hostname.

  Warning : Some methods on this class return connected sockets and some return
 unconnected sockets.  For the methods that return connected sockets setting
 connection- or handshake-related properties on those sockets will have no effect.

  On development devices ""setprop socket.relaxsslcheck yes"" bypasses all
 SSL certificate and hostname checks for testing purposes.  This setting
 requires root access."
android,net,TrafficStats,35,"Class that provides network traffic statistics. These statistics include
 bytes transmitted and received and network packets transmitted and received
 over all interfaces over the mobile interface and on a per-UID basis.
  
 These statistics may not be available on all platforms. If the statistics are
 not supported by this device  UNSUPPORTED  will be returned.
  
 Note that the statistics returned by this class reset and start from zero
 after every reboot. To access more robust historical network statistics data
 use  NetworkStatsManager  instead."
android,net,Uri.Builder,17,"Helper class for building or manipulating URI references. Not safe for
 concurrent use.

  An absolute hierarchical URI reference follows the pattern:
  <scheme>://<authority><absolute path>?<query>#<fragment> Relative URI references (which are always hierarchical) follow one
 of two patterns:  <relative or absolute path>?<query>#<fragment> 
 or  //<authority><absolute path>?<query>#<fragment> An opaque URI follows this pattern:
  <scheme>:<opaque part>#<fragment> Use  Uri#buildUpon()  to obtain a builder representing an existing URI."
android,net,UrlQuerySanitizer.IllegalCharacterValueSanitizer,1,"Sanitize values based on which characters they contain. Illegal
 characters are replaced with either space or '_' depending upon
 whether space is a legal character or not."
android,net,UrlQuerySanitizer.ParameterValuePair,0,A simple tuple that holds parameter-value pairs.
android,net,VpnService.Builder,19,"Helper class to create a VPN interface. This class should be always
 used within the scope of the outer  VpnService ."
android,net,CaptivePortal,4,"A class allowing apps handling the  ConnectivityManager#ACTION_CAPTIVE_PORTAL_SIGN_IN 
 activity to indicate to the system different outcomes of captive portal sign in.  This class is
 passed as an extra named  ConnectivityManager#EXTRA_CAPTIVE_PORTAL  with the
  ACTION_CAPTIVE_PORTAL_SIGN_IN  activity."
android,net,IpPrefix,9,"This class represents an IP prefix i.e. a contiguous block of IP addresses aligned on a
 power of two boundary (also known as an ""IP subnet""). A prefix is specified by two pieces of
 information:

  A starting IP address (IPv4 or IPv6). This is the first IP address of the prefix.
  A prefix length. This specifies the length of the prefix by specifing the number of bits
     in the IP address starting from the most significant bit in network byte order that
     are constant for all addresses in the prefix.
  192.0.2.0/24 192.0.2.0 192.0.2.255 2001:db8:1:2 2001:db8:1:2:: 2001:db8:1:2:ffff:ffff:ffff:ffff"
android,net,IpSecManager,10,"This class contains methods for managing IPsec sessions. Once configured the kernel will apply
 confidentiality (encryption) and integrity (authentication) to IP traffic.

  Note that not all aspects of IPsec are permitted by this API. Applications may create
 transport mode security associations and apply them to individual sockets. Applications looking
 to create a VPN should use  VpnService ."
android,net,IpSecManager.SecurityParameterIndex,4,"This class represents a reserved SPI.

  Objects of this type are used to track reserved security parameter indices. They can be
 obtained by calling  IpSecManager#allocateSecurityParameterIndex  and must be released
 by calling  close()  when they are no longer needed."
android,net,LocalSocket,26,"Creates a (non-server) socket in the UNIX-domain namespace. The interface
 here is not entirely unlike that of java.net.Socket. This class and the streams
 returned from it may be used from multiple threads."
android,net,LocalSocketAddress,2,"A UNIX-domain (AF_LOCAL) socket address. For use with
 android.net.LocalSocket and android.net.LocalServerSocket.

 On the Android system these names refer to names in the Linux
 abstract (non-filesystem) UNIX domain namespace."
android,net,MailTo,8,"MailTo URL parser

 This class parses a mailto scheme URL and then can be queried for
 the parsed parameters. This implements RFC 2368."
android,net,Network,15,"Identifies a  Network .  This is supplied to applications via
  ConnectivityManager.NetworkCallback  in response to the active
  ConnectivityManager#requestNetwork  or passive
  ConnectivityManager#registerNetworkCallback  calls.
 It is used to direct traffic to the given  Network  either on a  Socket  basis
 through a targeted  SocketFactory  or process-wide via
  ConnectivityManager#bindProcessToNetwork ."
android,net,NetworkCapabilities,11,"Representation of the capabilities of an active network. Instances are
 typically obtained through
  NetworkCallback#onCapabilitiesChanged(Network NetworkCapabilities) 
 or  ConnectivityManager#getNetworkCapabilities(Network) .
  
 This replaces the old  ConnectivityManager#TYPE_MOBILE  method of
 network selection. Rather than indicate a need for Wi-Fi because an
 application needs high bandwidth and risk obsolescence when a new fast
 network appears (like LTE) the application should specify it needs high
 bandwidth. Similarly if an application needs an unmetered network for a bulk
 transfer it can specify that rather than assuming all cellular based
 connections are metered and all Wi-Fi based connections are not."
android,net,Proxy,4,"A convenience class for accessing the user and default proxy
 settings."
android,net,SocketKeepalive.Callback,4,"The callback which app can use to learn the status changes of  SocketKeepalive . See
  SocketKeepalive ."
android,net,SSLSessionCache,0,"File-based cache of established SSL sessions.  When re-establishing a
 connection to the same server using an SSL session cache can save some time
 power and bandwidth by skipping directly to an encrypted stream.
 This is a persistent cache which can span executions of the application."
android,net,ConnectivityManager.NetworkCallback,7,"Base class for  NetworkRequest  callbacks. Used for notifications about network
 changes. Should be extended by applications wanting notifications.

 A  NetworkCallback  is registered by calling
  ConnectivityManager.requestNetwork(android.net.NetworkRequest android.net.ConnectivityManager.NetworkCallback) 
  ConnectivityManager.registerNetworkCallback(android.net.NetworkRequest android.net.ConnectivityManager.NetworkCallback) 
 or  ConnectivityManager.registerDefaultNetworkCallback(android.net.ConnectivityManager.NetworkCallback) . A  NetworkCallback  is
 unregistered by calling  ConnectivityManager.unregisterNetworkCallback(android.net.ConnectivityManager.NetworkCallback) .
 A  NetworkCallback  should be registered at most once at any time.
 A  NetworkCallback  that has been unregistered can be registered again."
android,net,IpSecTransform.Builder,5,This class is used to build  IpSecTransform  objects.
android,net,LinkAddress,9,"Identifies an IP address on a network link.

 A  LinkAddress  consists of:
  An IP address and prefix length (e.g.  2001:db8::1/64  or  192.0.2.1/24 ).
 The address must be unicast as multicast addresses cannot be assigned to interfaces.
  Address flags: A bitmask of  OsConstants.IFA_F_*  values representing properties
 of the address (e.g.  android.system.OsConstants.IFA_F_OPTIMISTIC ).
  Address scope: One of the  OsConstants.IFA_F_*  values; defines the scope in which
 the address is unique (e.g.
  android.system.OsConstants.RT_SCOPE_LINK  or
  android.system.OsConstants.RT_SCOPE_UNIVERSE )."
android,net,LocalServerSocket,4,"Non-standard class for creating an inbound UNIX-domain socket
 in the Linux abstract namespace."
android,net,MacAddress,11,"Representation of a MAC address.

 This class only supports 48 bits long addresses and does not support 64 bits long addresses.
 Instances of this class are immutable."
android,net,NetworkInfo,16,"Describes the status of a network interface.
  Use  ConnectivityManager#getActiveNetworkInfo()  to get an instance that represents
 the current network connection."
android,net,RouteInfo,11,"Represents a network route.
  
 This is used both to describe static network configuration and live network
 configuration information.

 A route contains three pieces of information:
  a destination  IpPrefix  specifying the network destinations covered by this route.
     If this is  null  it indicates a default route of the address family (IPv4 or IPv6)
     implied by the gateway IP address.
  a gateway  InetAddress  indicating the next hop to use.  If this is  null  it
     indicates a directly-connected route.
  an interface (which may be unspecified).
  null"
android,net,Uri,39,"Immutable URI reference. A URI reference includes a URI and a fragment the
 component of the URI following a '#'. Builds and parses URI references
 which conform to
  RFC 2396 .

  In the interest of performance this class performs little to no
 validation. Behavior is undefined for invalid input. This class is very
 forgiving--in the face of invalid input it will return garbage
 rather than throw an exception unless otherwise specified."
android,net,NetworkRequest,7,"Defines a request for a network made through  NetworkRequest.Builder  and used
 to request a network via  ConnectivityManager#requestNetwork  or listen for changes
 via  ConnectivityManager#registerNetworkCallback ."
android,net,NetworkRequest.Builder,7,"Builder used to create  NetworkRequest  objects.  Specify the Network features
 needed in terms of  NetworkCapabilities  features"
android,net,UrlQuerySanitizer,31,"Sanitizes the Query portion of a URL. Simple example:
  
 UrlQuerySanitizer sanitizer = new UrlQuerySanitizer();
 sanitizer.setAllowUnregisteredParamaters(true);
 sanitizer.parseUrl(""http://example.com/?name=Joe+User"");
 String name = sanitizer.getValue(""name""));
 // name now contains ""Joe_User""
  

 Register ValueSanitizers to customize the way individual
 parameters are sanitized:
  
 UrlQuerySanitizer sanitizer = new UrlQuerySanitizer();
 sanitizer.registerParamater(""name"" UrlQuerySanitizer.createSpaceLegal());
 sanitizer.parseUrl(""http://example.com/?name=Joe+User"");
 String name = sanitizer.getValue(""name""));
 // name now contains ""Joe User"". (The string is first decoded which
 // converts the '+' to a ' '. Then the string is sanitized which
 // converts the ' ' to an '_'. (The ' ' is converted because the default
 unregistered parameter sanitizer does not allow any special characters
 and ' ' is a special character.)
  

 There are several ways to create ValueSanitizers. In order of increasing
 sophistication:
  Call one of the UrlQuerySanitizer.createXXX() methods.
  Construct your own instance of
 UrlQuerySanitizer.IllegalCharacterValueSanitizer.
  Subclass UrlQuerySanitizer.ValueSanitizer to define your own value
 sanitizer."
android,net,VpnService,9,"VpnService is a base class for applications to extend and build their
 own VPN solutions. In general it creates a virtual network interface
 configures addresses and routing rules and returns a file descriptor
 to the application. Each read from the descriptor retrieves an outgoing
 packet which was routed to the interface. Each write to the descriptor
 injects an incoming packet just like it was received from the interface.
 The interface is running on Internet Protocol (IP) so packets are
 always started with IP headers. The application then completes a VPN
 connection by processing and exchanging packets with the remote server
 over a tunnel.

  Letting applications intercept packets raises huge security concerns.
 A VPN application can easily break the network. Besides two of them may
 conflict with each other. The system takes several actions to address
 these issues. Here are some key points:
  User action is required the first time an application creates a VPN
       connection. There can be only one VPN connection running at the same time. The
       existing interface is deactivated when a new one is created. A system-managed notification is shown during the lifetime of a
       VPN connection. A system-managed dialog gives the information of the current VPN
       connection. It also provides a button to disconnect. The network is restored automatically when the file descriptor is
       closed. It also covers the cases when a VPN application is crashed
       or killed by the system. There are two primary methods in this class:  prepare(Context)  and
  Builder#establish . The former deals with user action and stops
 the VPN connection created by another application. The latter creates
 a VPN interface using the parameters supplied to the  Builder .
 An application must call  prepare(Context)  to grant the right to use
 other methods in this class and the right can be revoked at any time.
 Here are the general steps to create a VPN connection:
  When the user presses the button to connect call  prepare(Context) 
       and launch the returned intent if non-null. When the application becomes prepared start the service. Create a tunnel to the remote server and negotiate the network
       parameters for the VPN connection. Supply those parameters to a  Builder  and create a VPN
       interface by calling  Builder#establish . Process and exchange packets between the tunnel and the returned
       file descriptor. When  onRevoke()  is invoked close the file descriptor and
       shut down the tunnel gracefully. Services extending this class need to be declared with an appropriate
 permission and intent filter. Their access must be secured by
  Manifest.permission.BIND_VPN_SERVICE  permission and
 their intent filter must match  SERVICE_INTERFACE  action. Here
 is an example of declaring a VPN service in  AndroidManifest.xml :
  
 <service android:name="".ExampleVpnService""
         android:permission=""android.permission.BIND_VPN_SERVICE"">
     <intent-filter>
         <action android:name=""android.net.VpnService""/>
     </intent-filter>
 </service>  The Android system starts a VPN in the background by calling
  startService() . In Android 8.0
 (API level 26) and higher the system places VPN apps on the temporary
 whitelist for a short period so the app can start in the background. The VPN
 app must promote itself to the foreground after it's launched or the system
 will shut down the app.

  Developer's guide To learn more about developing VPN apps read the
  VPN developer's guide ."
android,net.wifi,ScanResult,3,"Describes information about a detected access point. In addition
 to the attributes described here the supplicant keeps track of
  quality   noise  and  maxbitrate  attributes
 but does not currently report them to external clients."
android,net.wifi,WifiConfiguration,5,"A class representing a configured Wi-Fi network including the
 security configuration."
android,net.wifi,WifiConfiguration.AuthAlgorithm,0,Recognized IEEE 802.11 authentication algorithms.
android,net.wifi,WifiConfiguration.PairwiseCipher,0,Recognized pairwise ciphers for WPA.
android,net.wifi,WifiConfiguration.Status,0,Possible status of a network configuration.
android,net.wifi,WifiEnterpriseConfig,31,"Enterprise configuration details for Wi-Fi. Stores details about the EAP method
 and any associated credentials."
android,net.wifi,WifiEnterpriseConfig.Eap,0,The Extensible Authentication Protocol method used
android,net.wifi,WifiManager.LocalOnlyHotspotCallback,3,Callback class for applications to receive updates about the LocalOnlyHotspot status.
android,net.wifi,WifiManager.MulticastLock,6,"Allows an application to receive Wifi Multicast packets.
 Normally the Wifi stack filters out packets not explicitly
 addressed to this device.  Acquring a MulticastLock will
 cause the stack to receive packets addressed to multicast
 addresses.  Processing these extra packets can cause a noticeable
 battery drain and should be disabled when not needed."
android,net.wifi,WifiNetworkSpecifier,5,"Network specifier object used to request a local Wi-Fi network. Apps should use the
  WifiNetworkSpecifier.Builder  class to create an instance."
android,net.wifi,WifiNetworkSpecifier.Builder,11,Builder used to create  WifiNetworkSpecifier  objects.
android,net.wifi,WifiConfiguration.GroupCipher,0,"Recognized group ciphers.
  
 CCMP = AES in Counter mode with CBC-MAC [RFC 3610 IEEE 802.11i/D7.0]
 TKIP = Temporal Key Integrity Protocol [IEEE 802.11i/D7.0]
 WEP104 = WEP (Wired Equivalent Privacy) with 104-bit key
 WEP40 = WEP (Wired Equivalent Privacy) with 40-bit key (original 802.11)
 GCMP_256 = AES in Galois/Counter Mode"
android,net.wifi,WifiConfiguration.GroupMgmtCipher,0,"Recognized group management ciphers.
  
 BIP_CMAC_256 = Cipher-based Message Authentication Code 256 bits
 BIP_GMAC_128 = Galois Message Authentication Code 128 bits
 BIP_GMAC_256 = Galois Message Authentication Code 256 bits"
android,net.wifi,WifiConfiguration.KeyMgmt,0,Recognized key management schemes.
android,net.wifi,WifiConfiguration.Protocol,0,Recognized security protocols.
android,net.wifi,WifiEnterpriseConfig.Phase2,0,The inner authentication method used
android,net.wifi,WifiInfo,16,"Describes the state of any Wifi connection that is active or
 is in the process of being set up."
android,net.wifi,WifiManager.WifiLock,7,"Allows an application to keep the Wi-Fi radio awake.
 Normally the Wi-Fi radio may turn off when the user has not used the device in a while.
 Acquiring a WifiLock will keep the radio on until the lock is released.  Multiple
 applications may hold WifiLocks and the radio will only be allowed to turn off when no
 WifiLocks are held in any application.
  
 Before using a WifiLock consider carefully if your application requires Wi-Fi access or
 could function over a mobile network if available.  A program that needs to download large
 files should hold a WifiLock to ensure that the download will complete but a program whose
 network usage is occasional or low-bandwidth should not hold a WifiLock to avoid adversely
 affecting battery life.
  
 Note that WifiLocks cannot override the user-level ""Wi-Fi Enabled"" setting nor Airplane
 Mode.  They simply keep the radio from turning off when Wi-Fi is already on but the device
 is idle.
  
 Any application using a WifiLock must request the  android.permission.WAKE_LOCK 
 permission in an  <uses-permission>  element of the application's manifest."
android,net.wifi,WifiManager,46,"This class provides the primary API for managing all aspects of Wi-Fi
 connectivity.
  
 On releases before  Build.VERSION_CODES.N  this object
 should only be obtained from an  Context#getApplicationContext()  and not from any other derived context to avoid memory
 leaks within the calling process.
  
 It deals with several categories of items:
  The list of configured networks. The list can be viewed and updated and
 attributes of individual entries can be modified. The currently active Wi-Fi network if any. Connectivity can be
 established or torn down and dynamic information about the state of the
 network can be queried. Results of access point scans containing enough information to make
 decisions about what access point to connect to. It defines the names of various Intent actions that are broadcast upon
 any sort of change in Wi-Fi state.
  
 This is the API to use when performing Wi-Fi specific operations. To perform
 operations that pertain to network connectivity at an abstract level use
  ConnectivityManager ."
android,net.wifi,WifiManager.LocalOnlyHotspotReservation,3,"LocalOnlyHotspotReservation that contains the  WifiConfiguration  for the active
 LocalOnlyHotspot request.
  
 Applications requesting LocalOnlyHotspot for sharing will receive an instance of the
 LocalOnlyHotspotReservation in the
  LocalOnlyHotspotCallback#onStarted(LocalOnlyHotspotReservation)  call.  This
 reservation contains the relevant  WifiConfiguration .
 When an application is done with the LocalOnlyHotspot they should call  LocalOnlyHotspotReservation#close() .  Once this happens the application will not receive
 any further callbacks. If the LocalOnlyHotspot is stopped due to a
 user triggered mode change applications will be notified via the  LocalOnlyHotspotCallback#onStopped()  callback."
android,net.wifi,WifiManager.WpsCallback,3,Interface for callback invocation on a start WPS action
android,net.wifi,WifiNetworkSuggestion,5,"The Network Suggestion object is used to provide a Wi-Fi network for consideration when
 auto-connecting to networks. Apps cannot directly create this object they must use
  WifiNetworkSuggestion.Builder#build()  to obtain an instance of this object.
 
 Apps can provide a list of such networks to the platform using
  WifiManager#addNetworkSuggestions(List) ."
android,net.wifi,WifiNetworkSuggestion.Builder,13,Builder used to create  WifiNetworkSuggestion  objects.
android,net.wifi,WpsInfo,3,A class representing Wi-Fi Protected Setup
android,net.wifi.p2p.nsd,WifiP2pDnsSdServiceInfo,1,"A class for storing Bonjour service information that is advertised
 over a Wi-Fi peer-to-peer setup."
android,net.wifi.p2p.nsd,WifiP2pDnsSdServiceRequest,3,"A class for creating a Bonjour service discovery request for use with
  WifiP2pManager#addServiceRequest  and  WifiP2pManager#removeServiceRequest"
android,net.wifi.p2p.nsd,WifiP2pServiceInfo,2,"A class for storing service information that is advertised
 over a Wi-Fi peer-to-peer setup"
android,net.wifi.p2p.nsd,WifiP2pServiceRequest,4,"A class for creating a service discovery request for use with
  WifiP2pManager#addServiceRequest  and  WifiP2pManager#removeServiceRequest This class is used to create service discovery request for custom
 vendor specific service discovery protocol  WifiP2pServiceInfo#SERVICE_TYPE_VENDOR_SPECIFIC 
 or to search all service protocols  WifiP2pServiceInfo#SERVICE_TYPE_ALL .

  For the purpose of creating a UPnP or Bonjour service request use
  WifiP2pUpnpServiceRequest  or  WifiP2pDnsSdServiceRequest  respectively."
android,net.wifi.p2p.nsd,WifiP2pUpnpServiceInfo,1,"A class for storing Upnp service information that is advertised
 over a Wi-Fi peer-to-peer setup."
android,net.wifi.p2p.nsd,WifiP2pUpnpServiceRequest,2,"A class for creating a Upnp service discovery request for use with
  WifiP2pManager#addServiceRequest  and  WifiP2pManager#removeServiceRequest"
android,net.wifi.p2p,WifiP2pConfig,3,A class representing a Wi-Fi P2p configuration for setting up a connection
android,net.wifi.p2p,WifiP2pDevice,10,"A class representing a Wi-Fi p2p device

 Note that the operations are not thread safe"
android,net.wifi.p2p,WifiP2pDeviceList,5,"A class representing a Wi-Fi P2p device list.

 Note that the operations are not thread safe."
android,net.wifi.p2p,WifiP2pGroup,10,"A class representing a Wi-Fi P2p group. A p2p group consists of a single group
 owner and one or more clients. In the case of a group with only two devices one
 will be the group owner and the other will be a group client."
android,net.wifi.p2p,WifiP2pInfo,3,A class representing connection information about a Wi-Fi p2p group
android,net.wifi.p2p,WifiP2pManager,25,"This class provides the API for managing Wi-Fi peer-to-peer connectivity. This lets an
 application discover available peers setup connection to peers and query for the list of peers.
 When a p2p connection is formed over wifi the device continues to maintain the uplink
 connection over mobile or any other available network for internet connectivity on the device.

   The API is asynchronous and responses to requests from an application are on listener
 callbacks provided by the application. The application needs to do an initialization with
  initialize(Context Looper WifiP2pManager.ChannelListener)  before doing any p2p operation.

   Most application calls need a  ActionListener  instance for receiving callbacks
  ActionListener#onSuccess  or  ActionListener#onFailure . Action callbacks
 indicate whether the initiation of the action was a success or a failure.
 Upon failure the reason of failure can be one of  ERROR   P2P_UNSUPPORTED 
 or  BUSY .

   An application can initiate discovery of peers with  discoverPeers(WifiP2pManager.Channel WifiP2pManager.ActionListener) . An initiated
 discovery request from an application stays active until the device starts connecting to a peer
 forms a p2p group or there is an explicit  stopPeerDiscovery(WifiP2pManager.Channel WifiP2pManager.ActionListener) .
 Applications can listen to  WIFI_P2P_DISCOVERY_CHANGED_ACTION  to know if a peer-to-peer
 discovery is running or stopped. Additionally  WIFI_P2P_PEERS_CHANGED_ACTION  indicates
 if the peer list has changed.

   When an application needs to fetch the current list of peers it can request the list
 of peers with  requestPeers(WifiP2pManager.Channel WifiP2pManager.PeerListListener) . When the peer list is available
  PeerListListener#onPeersAvailable  is called with the device list.

   An application can initiate a connection request to a peer through  connect(WifiP2pManager.Channel WifiP2pConfig WifiP2pManager.ActionListener) . See
  WifiP2pConfig  for details on setting up the configuration. For communication with legacy
 Wi-Fi devices that do not support p2p an app can create a group using  createGroup(WifiP2pManager.Channel WifiP2pConfig WifiP2pManager.ActionListener) 
 which creates an access point whose details can be fetched with  requestGroupInfo(WifiP2pManager.Channel WifiP2pManager.GroupInfoListener) .

   After a successful group formation through  createGroup(WifiP2pManager.Channel WifiP2pConfig WifiP2pManager.ActionListener)  or through  connect(WifiP2pManager.Channel WifiP2pConfig WifiP2pManager.ActionListener) 
 use  requestConnectionInfo(WifiP2pManager.Channel WifiP2pManager.ConnectionInfoListener)  to fetch the connection details. The connection info
  WifiP2pInfo  contains the address of the group owner
  WifiP2pInfo#groupOwnerAddress  and a flag  WifiP2pInfo#isGroupOwner  to indicate
 if the current device is a p2p group owner. A p2p client can thus communicate with
 the p2p group owner through a socket connection. If the current device is the p2p group owner
  WifiP2pInfo#groupOwnerAddress  is anonymized unless the caller holds the
  android.Manifest.permission#LOCAL_MAC_ADDRESS  permission.

   With peer discovery using  discoverPeers(WifiP2pManager.Channel WifiP2pManager.ActionListener)  an application discovers the neighboring
 peers but has no good way to figure out which peer to establish a connection with. For example
 if a game application is interested in finding all the neighboring peers that are also running
 the same game it has no way to find out until after the connection is setup. Pre-association
 service discovery is meant to address this issue of filtering the peers based on the running
 services.

  With pre-association service discovery an application can advertise a service for a
 application on a peer device prior to a connection setup between the devices.
 Currently DNS based service discovery (Bonjour) and Upnp are the higher layer protocols
 supported. Get Bonjour resources at dns-sd.org and Upnp resources at upnp.org
 As an example a video application can discover a Upnp capable media renderer
 prior to setting up a Wi-fi p2p connection with the device.

   An application can advertise a Upnp or a Bonjour service with a call to
  addLocalService(WifiP2pManager.Channel WifiP2pServiceInfo WifiP2pManager.ActionListener) . After a local service is added
 the framework automatically responds to a peer application discovering the service prior
 to establishing a p2p connection. A call to  removeLocalService(WifiP2pManager.Channel WifiP2pServiceInfo WifiP2pManager.ActionListener)  removes a local
 service and  clearLocalServices(WifiP2pManager.Channel WifiP2pManager.ActionListener)  can be used to clear all local services.

   An application that is looking for peer devices that support certain services
 can do so with a call to   discoverServices(WifiP2pManager.Channel WifiP2pManager.ActionListener) . Prior to initiating the discovery
 application can add service discovery request with a call to  addServiceRequest(WifiP2pManager.Channel WifiP2pServiceRequest WifiP2pManager.ActionListener) 
 remove a service discovery request with a call to  removeServiceRequest(WifiP2pManager.Channel WifiP2pServiceRequest WifiP2pManager.ActionListener)  or clear
 all requests with a call to  clearServiceRequests(WifiP2pManager.Channel WifiP2pManager.ActionListener) . When no service requests remain
 a previously running service discovery will stop.

 The application is notified of a result of service discovery request through listener callbacks
 set through  setDnsSdResponseListeners(WifiP2pManager.Channel WifiP2pManager.DnsSdServiceResponseListener WifiP2pManager.DnsSdTxtRecordListener)  for Bonjour or
  setUpnpServiceResponseListener(WifiP2pManager.Channel WifiP2pManager.UpnpServiceResponseListener)  for Upnp.

  Note: 
 Registering an application handler with  initialize(Context Looper WifiP2pManager.ChannelListener)  requires the permissions
  Manifest.permission.ACCESS_WIFI_STATE  and
  Manifest.permission.CHANGE_WIFI_STATE  to perform any further peer-to-peer
 operations."
android,net.wifi.p2p,WifiP2pConfig.Builder,7,"Builder used to build  WifiP2pConfig  objects for
 creating or joining a group."
android,net.wifi.p2p,WifiP2pManager.Channel,1,"A channel that connects the application to the Wifi p2p framework.
 Most p2p operations require a Channel as an argument. An instance of Channel is obtained
 by doing a call on  WifiP2pManager.initialize(Context Looper WifiP2pManager.ChannelListener)"
android,net.wifi.rtt,CivicLocationKeys,0,"Civic Address key types used to define address elements.

  These keys can be used with  ResponderLocation.toCivicLocationSparseArray() 
 to look-up the corresponding string values."
android,net.wifi.rtt,RangingRequest,5,"Defines the ranging request to other devices. The ranging request is built using
  RangingRequest.Builder .
 A ranging request is executed using
  WifiRttManager#startRanging(RangingRequest java.util.concurrent.Executor RangingResultCallback) .
  
 The ranging request is a batch request - specifying a set of devices (specified using
  RangingRequest.Builder#addAccessPoint(ScanResult)  and
  RangingRequest.Builder#addAccessPoints(List) )."
android,net.wifi.rtt,RangingRequest.Builder,5,Builder class used to construct  RangingRequest  objects.
android,net.wifi.rtt,RangingResult,14,"Ranging result for a request started by
  WifiRttManager#startRanging(RangingRequest java.util.concurrent.Executor RangingResultCallback) .
 Results are returned in  RangingResultCallback#onRangingResults(List) .
  
 A ranging result is the distance measurement result for a single device specified in the
  RangingRequest ."
android,net.wifi.rtt,RangingResultCallback,2,"Base class for ranging result callbacks. Should be extended by applications and set when calling
  WifiRttManager#startRanging(RangingRequest java.util.concurrent.Executor RangingResultCallback) .
 If the ranging operation fails in whole (not attempted) then  onRangingFailure(int) 
 will be called with a failure code. If the ranging operation is performed for each of the
 requested peers then the  onRangingResults(java.util.List)  will be called with the set of
 results (@link  RangingResult  each of which has its own success/failure code
  RangingResult#getStatus() ."
android,net.wifi.rtt,ResponderLocation,26,"ResponderLocation is both a Location Configuration Information (LCI) decoder and a Location Civic
 Report (LCR) decoder for information received from a Wi-Fi Access Point (AP) during Wi-Fi RTT
 ranging process.

  This is based on the IEEE P802.11-REVmc/D8.0 spec section 9.4.2.22 under Measurement Report
 Element. Subelement location data-fields parsed from separate input LCI and LCR Information
 Elements are unified in this class. Note: The information provided by this class is broadcast by a responder (usually an Access
 Point) and passed on as-is. There is no guarantee this information is accurate or correct and
 as a result developers should carefully consider how this information should be used and provide
 corresponding advice to users."
android,net.wifi.rtt,WifiRttManager,2,"This class provides the primary API for measuring distance (range) to other devices using the
 IEEE 802.11mc Wi-Fi Round Trip Time (RTT) technology.
  
 The devices which can be ranged include:
  Access Points (APs)
  Wi-Fi Aware peers
  
 Ranging requests are triggered using
  startRanging(android.net.wifi.rtt.RangingRequest java.util.concurrent.Executor android.net.wifi.rtt.RangingResultCallback) . Results (in case of
 successful operation) are returned in the  RangingResultCallback#onRangingResults(List) 
 callback.
  
     Wi-Fi RTT may not be usable at some points e.g. when Wi-Fi is disabled. To validate that
     the functionality is available use the  isAvailable()  function. To track
     changes in RTT usability register for the  ACTION_WIFI_RTT_STATE_CHANGED 
     broadcast. Note that this broadcast is not sticky - you should register for it and then
     check the above API to avoid a race condition."
android,nfc,NdefMessage,8,"Represents an immutable NDEF Message.
  
 NDEF (NFC Data Exchange Format) is a light-weight binary format
 used to encapsulate typed data. It is specified by the NFC Forum
 for transmission and storage with NFC however it is transport agnostic.
  
 NDEF defines messages and records. An NDEF Record contains
 typed data such as MIME-type media a URI or a custom
 application payload. An NDEF Message is a container for
 one or more NDEF Records.
  
 When an Android device receives an NDEF Message
 (for example by reading an NFC tag) it processes it through
 a dispatch mechanism to determine an activity to launch.
 The type of the  first  record in the message has
 special importance for message dispatch so design this record
 carefully.
  
 Use  NdefMessage(byte[])  to construct an NDEF Message from
 binary data or  NdefMessage(android.nfc.NdefRecord[])  to
 construct from one or more  NdefRecord s.
  NdefMessage  and  NdefRecord  implementations are
 always available even on Android devices that do not have NFC hardware.
  NdefRecord s are intended to be immutable (and thread-safe)
 however they may contain mutable fields. So take care not to modify
 mutable fields passed into constructors or modify mutable fields
 obtained by getter methods unless such modification is explicitly
 marked as safe."
android,nfc,NdefRecord,18,"Represents an immutable NDEF Record.
  
 NDEF (NFC Data Exchange Format) is a light-weight binary format
 used to encapsulate typed data. It is specified by the NFC Forum
 for transmission and storage with NFC however it is transport agnostic.
  
 NDEF defines messages and records. An NDEF Record contains
 typed data such as MIME-type media a URI or a custom
 application payload. An NDEF Message is a container for
 one or more NDEF Records.
  
 This class represents logical (complete) NDEF Records and can not be
 used to represent chunked (partial) NDEF Records. However
  NdefMessage#NdefMessage(byte[])  can be used to parse a message
 containing chunked records and will return a message with unchunked
 (complete) records.
  
 A logical NDEF Record always contains a 3-bit TNF (Type Name Field)
 that provides high level typing for the rest of the record. The
 remaining fields are variable length and not always present:
  type : detailed typing for the payload id : identifier meta-data not commonly used payload : the actual payload 
 Helpers such as  NdefRecord#createUri   NdefRecord#createMime 
 and  NdefRecord#createExternal  are included to create well-formatted
 NDEF Records with correctly set tnf type id and payload fields please
 use these helpers whenever possible.
  
 Use the constructor  NdefRecord(short byte[] byte[] byte[]) 
 if you know what you are doing and what to set the fields individually.
 Only basic validation is performed with this constructor so it is possible
 to create records that do not confirm to the strict NFC Forum
 specifications.
  
 The binary representation of an NDEF Record includes additional flags to
 indicate location with an NDEF message provide support for chunking of
 NDEF records and to pack optional fields. This class does not expose
 those details. To write an NDEF Record as binary you must first put it
 into an  NdefMessage  then call  NdefMessage#toByteArray() .
  NdefMessage  and  NdefRecord  implementations are
 always available even on Android devices that do not have NFC hardware.
  NdefRecord s are intended to be immutable (and thread-safe)
 however they may contain mutable fields. So take care not to modify
 mutable fields passed into constructors or modify mutable fields
 obtained by getter methods unless such modification is explicitly
 marked as safe."
android,nfc,NfcAdapter,18,"Represents the local NFC adapter.
  
 Use the helper  getDefaultAdapter(android.content.Context)  to get the default NFC
 adapter for this Android device."
android,nfc,NfcEvent,0,"Wraps information associated with any NFC event.

  Immutable object with direct access to the (final) fields.

  An  NfcEvent  object is usually included in callbacks from
  NfcAdapter . Check the documentation of the callback to see
 which fields may be set.

  This wrapper object is used (instead of parameters
 in the callback) because it allows new fields to be added without breaking
 API compatibility."
android,nfc,NfcManager,1,"High level manager used to obtain an instance of an  NfcAdapter .
  
 Use  Context.getSystemService(java.lang.String) 
 with  Context#NFC_SERVICE  to create an  NfcManager 
 then call  getDefaultAdapter()  to obtain the  NfcAdapter .
  
 Alternately you can just call the static helper
  NfcAdapter#getDefaultAdapter(android.content.Context) ."
android,nfc,Tag,5,"Represents an NFC tag that has been discovered.
  Tag  is an immutable object that represents the state of a NFC tag at
 the time of discovery. It can be used as a handle to  TagTechnology  classes
 to perform advanced operations or directly queried for its ID via  getId()  and the
 set of technologies it contains via  getTechList() . Arrays passed to and
 returned by this class are  not  cloned so be careful not to modify them.
  
 A new tag object is created every time a tag is discovered (comes into range) even
 if it is the same physical tag. If a tag is removed and then returned into range then
 only the most recent tag object can be successfully used to create a  TagTechnology .

  Tag Dispatch Tag NfcAdapter#EXTRA_TAG Intent Context#startActivity The Tag dispatch mechanism was designed to give a high probability of dispatching
 a tag to the correct activity without showing the user an activity chooser dialog.
 This is important for NFC interactions because they are very transient -- if a user has to
 move the Android device to choose an application then the connection will likely be broken.

  1. Foreground activity dispatch NfcAdapter#enableForegroundDispatch NfcAdapter#enableForegroundDispatch 2. NDEF data dispatch NdefRecord NdefMessage Context#startActivity NfcAdapter#ACTION_NDEF_DISCOVERED NfcAdapter#ACTION_NDEF_DISCOVERED NfcAdapter#ACTION_NDEF_DISCOVERED 3. Tag Technology dispatch Context#startActivity NfcAdapter#ACTION_TECH_DISCOVERED TagTechnology android.nfc.tech NfcAdapter#ACTION_TECH_DISCOVERED 4. Fall-back dispatch Context#startActivity NfcAdapter#ACTION_TAG_DISCOVERED NfcAdapter#ACTION_TAG_DISCOVERED NFC Tag Background 
 Tags can have a wide range of capabilities. Simple tags just offer read/write semantics
 and contain some one time
 programmable areas to make read-only. More complex tags offer math operations
 and per-sector access control and authentication. The most sophisticated tags
 contain operating environments allowing complex interactions with the
 code executing on the tag. Use  TagTechnology  classes to access a broad
 range of capabilities available in NFC tags."
android,nfc.cardemulation,CardEmulation,13,"This class can be used to query the state of
 NFC card emulation services.

 For a general introduction into NFC card emulation
 please read the  
 NFC card emulation developer guide . Use of this class requires the
  PackageManager#FEATURE_NFC_HOST_CARD_EMULATION  to be present
 on the device."
android,nfc.cardemulation,HostApduService,5,"HostApduService is a convenience  Service  class that can be
 extended to emulate an NFC card inside an Android
 service component."
android,nfc.cardemulation,HostNfcFService,4,"HostNfcFService is a convenience  Service  class that can be
 extended to emulate an NFC-F card inside an Android service component.

  NFC Protocols Cards emulated by this class are based on the NFC-Forum NFC-F
 protocol (based on the JIS-X 6319-4 specification.) System Code and NFCID2 registration A  HostNfcFService  can register
 exactly one System Code and one NFCID2. For details about the use of
 System Code and NFCID2 see the NFC Forum Digital specification. To statically register a System Code and NFCID2 with the service a  SERVICE_META_DATA 
 entry must be included in the declaration of the service.

  All  HostNfcFService  declarations in the manifest must require the
  Manifest.permission.BIND_NFC_SERVICE  permission
 in their <service> tag to ensure that only the platform can bind to your service. An example of a HostNfcFService manifest declaration is shown below:

   <service android:name="".MyHostNfcFService"" android:exported=""true"" android:permission=""android.permission.BIND_NFC_SERVICE"">
     <intent-filter>
         <action android:name=""android.nfc.cardemulation.action.HOST_NFCF_SERVICE""/>
     </intent-filter>
     <meta-data android:name=""android.nfc.cardemulation.host_nfcf_service"" android:resource=""@xml/nfcfservice""/>
 </service> 
 <host-nfcf-service xmlns:android=""http://schemas.android.com/apk/res/android""
           android:description=""@string/servicedesc"">
       <system-code-filter android:name=""4000""/>
       <nfcid2-filter android:name=""02FE000000000000""/>
        <t3tPmm-filter android:name=""FFFFFFFFFFFFFFFF""/>
 </host-nfcf-service>
  The  <host-nfcf-service>  is required
 to contain a
  <android:description> 
 attribute that contains a user-friendly description of the service that may be shown in UI.
  The  <host-nfcf-service>  must
 contain:
  Exactly one  <system-code-filter>  tag. Exactly one  <nfcid2-filter>  tag. Zero or one  <t3tPmm-filter>  tag. Alternatively the System Code and NFCID2 can be dynamically registererd for a service
 by using the  NfcFCardEmulation#registerSystemCodeForService(ComponentName String)  and
  NfcFCardEmulation#setNfcid2ForService(ComponentName String)  methods.
  Service selection When a remote NFC devices wants to communicate with your service it
 sends a SENSF_REQ command to the NFC controller requesting a System Code.
 If a  NfcFCardEmulation  has registered
 this system code and has been enabled by the foreground application the
 NFC controller will respond with the NFCID2 that is registered for this service.
 The reader can then continue data exchange with this service by using the NFCID2. Data exchange After service selection all frames addressed to the NFCID2 of this service will
 be sent through  processNfcFPacket(byte[] android.os.Bundle)  until the NFC link is
 broken. When the NFC link is broken  onDeactivated(int)  will be called."
android,nfc.cardemulation,NfcFCardEmulation,8,"This class can be used to query the state of
 NFC-F card emulation services.

 For a general introduction into NFC card emulation
 please read the  
 NFC card emulation developer guide . Use of this class requires the
  PackageManager#FEATURE_NFC_HOST_CARD_EMULATION_NFCF 
 to be present on the device."
android,nfc.cardemulation,OffHostApduService,1,"OffHostApduService is a convenience  Service  class that can be
 extended to describe one or more NFC applications that are residing
 off-host for example on an embedded secure element or a UICC."
android,nfc.tech,IsoDep,12,"Provides access to ISO-DEP (ISO 14443-4) properties and I/O operations on a  Tag .

  Acquire an  IsoDep  object using  get(Tag) .
  The primary ISO-DEP I/O operation is  transceive(byte[]) . Applications must
 implement their own protocol stack on top of  transceive(byte[]) .
  Tags that enumerate the  IsoDep  technology in  Tag#getTechList 
 will also enumerate
  NfcA  or  NfcB  (since IsoDep builds on top of either of these).

  Note:  Methods that perform I/O operations
 require the  Manifest.permission.NFC  permission."
android,nfc.tech,MifareUltralight,12,"Provides access to MIFARE Ultralight properties and I/O operations on a  Tag .

  Acquire a  MifareUltralight  object using  get(Tag) .

  MIFARE Ultralight compatible tags have 4 byte pages  PAGE_SIZE .
 The primary operations on an Ultralight tag are  readPages(int)  and
  writePage(int byte[]) .

  The original MIFARE Ultralight consists of a 64 byte EEPROM. The first
 4 pages are for the OTP area manufacturer data and locking bits. They are
 readable and some bits are writable. The final 12 pages are the user
 read/write area. For more information see the NXP data sheet MF0ICU1.

  The MIFARE Ultralight C consists of a 192 byte EEPROM. The first 4 pages
 are for OTP manufacturer data and locking bits. The next 36 pages are the
 user read/write area. The next 4 pages are additional locking bits counters
 and authentication configuration and are readable. The final 4 pages are for
 the authentication key and are not readable. For more information see the
 NXP data sheet MF0ICU2.

  Implementation of this class on a Android NFC device is optional.
 If it is not implemented then
  MifareUltralight  will never be enumerated in  Tag#getTechList .
 If it is enumerated then all  MifareUltralight  I/O operations will be supported.
 In either case  NfcA  will also be enumerated on the tag
 because all MIFARE Ultralight tags are also  NfcA  tags.

  Note:  Methods that perform I/O operations
 require the  Manifest.permission.NFC  permission."
android,nfc.tech,Ndef,13,"Provides access to NDEF content and operations on a  Tag .

  Acquire a  Ndef  object using  get(Tag) .

  NDEF is an NFC Forum data format. The data formats are implemented in
  NdefMessage  and
  NdefRecord . This class provides methods to
 retrieve and modify the  NdefMessage 
 on a tag.

  There are currently four NFC Forum standardized tag types that can be
 formatted to contain NDEF data.
  NFC Forum Type 1 Tag ( NFC_FORUM_TYPE_1 ) such as the Innovision Topaz
  NFC Forum Type 2 Tag ( NFC_FORUM_TYPE_2 ) such as the NXP MIFARE Ultralight
  NFC Forum Type 3 Tag ( NFC_FORUM_TYPE_3 ) such as Sony Felica
  NFC Forum Type 4 Tag ( NFC_FORUM_TYPE_4 ) such as NXP MIFARE Desfire
  Ndef Some vendors have their own well defined specifications for storing NDEF data
 on tags that do not fall into the above categories. Android devices with NFC
 should enumerate and implement  Ndef  under these vendor specifications
 where possible but it is not mandatory.  getType()  returns a String
 describing this specification for example  MIFARE_CLASSIC  is
  com.nxp.ndef.mifareclassic .

  Android devices that support MIFARE Classic must also correctly
 implement  Ndef  on MIFARE Classic tags formatted to NDEF.

  For guaranteed compatibility across all Android devices with NFC it is
 recommended to use NFC Forum Types 1-4 in new deployments of NFC tags
 with NDEF payload. Vendor NDEF formats will not work on all Android devices.

  Note:  Methods that perform I/O operations
 require the  Manifest.permission.NFC  permission."
android,nfc.tech,NdefFormatable,7,"Provide access to NDEF format operations on a  Tag .

  Acquire a  NdefFormatable  object using  get(Tag) .

  Android devices with NFC must only enumerate and implement this
 class for tags for which it can format to NDEF.

  Unfortunately the procedures to convert unformated tags to NDEF formatted
 tags are not specified by NFC Forum and are not generally well-known. So
 there is no mandatory set of tags for which all Android devices with NFC
 must support  NdefFormatable .

  Note:  Methods that perform I/O operations
 require the  Manifest.permission.NFC  permission."
android,nfc.tech,NfcA,11,"Provides access to NFC-A (ISO 14443-3A) properties and I/O operations on a  Tag .

  Acquire a  NfcA  object using  get(Tag) .
  The primary NFC-A I/O operation is  transceive(byte[]) . Applications must
 implement their own protocol stack on top of  transceive(byte[]) .

  Note:  Methods that perform I/O operations
 require the  Manifest.permission.NFC  permission."
android,nfc.tech,NfcBarcode,7,"Provides access to tags containing just a barcode.

  Acquire an  NfcBarcode  object using  get(Tag) ."
android,nfc.tech,NfcF,11,"Provides access to NFC-F (JIS 6319-4) properties and I/O operations on a  Tag .

  Acquire a  NfcF  object using  get(Tag) .
  The primary NFC-F I/O operation is  transceive(byte[]) . Applications must
 implement their own protocol stack on top of  transceive(byte[]) .

  Note:  Methods that perform I/O operations
 require the  Manifest.permission.NFC  permission."
android,nfc.tech,NfcV,9,"Provides access to NFC-V (ISO 15693) properties and I/O operations on a  Tag .

  Acquire a  NfcV  object using  get(Tag) .
  The primary NFC-V I/O operation is  transceive(byte[]) . Applications must
 implement their own protocol stack on top of  transceive(byte[]) .

  Note:  Methods that perform I/O operations
 require the  Manifest.permission.NFC  permission."
android,nfc.tech,MifareClassic,24,"Provides access to MIFARE Classic properties and I/O operations on a  Tag .

  Acquire a  MifareClassic  object using  get(Tag) .

  MIFARE Classic is also known as MIFARE Standard.
  MIFARE Classic tags are divided into sectors and each sector is sub-divided into
 blocks. Block size is always 16 bytes ( BLOCK_SIZE . Sector size varies.
  MIFARE Classic Mini are 320 bytes ( SIZE_MINI ) with 5 sectors each of 4 blocks.
  MIFARE Classic 1k are 1024 bytes ( SIZE_1K ) with 16 sectors each of 4 blocks.
  MIFARE Classic 2k are 2048 bytes ( SIZE_2K ) with 32 sectors each of 4 blocks.
  MIFARE Classic 4k are 4096 bytes ( SIZE_4K ). The first 32 sectors contain 4 blocks
 and the last 8 sectors contain 16 blocks.
  MIFARE Classic tags require authentication on a per-sector basis before any
 other I/O operations on that sector can be performed. There are two keys per sector
 and ACL bits determine what I/O operations are allowed on that sector after
 authenticating with a key.  and
 .

  Three well-known authentication keys are defined in this class:
  KEY_DEFAULT   KEY_MIFARE_APPLICATION_DIRECTORY 
  KEY_NFC_FORUM .
  KEY_DEFAULT  is the default factory key for MIFARE Classic.
  KEY_MIFARE_APPLICATION_DIRECTORY  is the well-known key for
 MIFARE Classic cards that have been formatted according to the
 MIFARE Application Directory (MAD) specification.
  KEY_NFC_FORUM  is the well-known key for MIFARE Classic cards that
 have been formatted according to the NXP specification for NDEF on MIFARE Classic.

  Implementation of this class on a Android NFC device is optional.
 If it is not implemented then
  MifareClassic  will never be enumerated in  Tag#getTechList .
 If it is enumerated then all  MifareClassic  I/O operations will be supported
 and  Ndef#MIFARE_CLASSIC  NDEF tags will also be supported. In either case
  NfcA  will also be enumerated on the tag because all MIFARE Classic tags are also
  NfcA .

  Note:  Methods that perform I/O operations
 require the  Manifest.permission.NFC  permission."
android,nfc.tech,NfcB,9,"Provides access to NFC-B (ISO 14443-3B) properties and I/O operations on a  Tag .

  Acquire a  NfcB  object using  get(Tag) .
  The primary NFC-B I/O operation is  transceive(byte[]) . Applications must
 implement their own protocol stack on top of  transceive(byte[]) .

  Note:  Methods that perform I/O operations
 require the  Manifest.permission.NFC  permission."
android,os.health,HealthStats,23,"A HealthStats object contains system health data about an application.

  Data Types 
 Each of the keys references data in one of five data types:

  
 A  measurement  metric contains a sinlge  long  value. That value may
 be a count a time or some other type of value. The unit for a measurement
 (COUNT MS etc) will always be in the name of the constant for the key to
 retrieve it. For example the
  UidHealthStats.MEASUREMENT_WIFI_TX_MS 
 value is the number of milliseconds (ms) that were spent transmitting on wifi by an
 application.  The
  UidHealthStats.MEASUREMENT_MOBILE_RX_PACKETS 
 measurement is the number of packets received on behalf of an application.
 The  UidHealthStats.MEASUREMENT_TOUCH_USER_ACTIVITY_COUNT 
 measurement is the number of times the user touched the screen causing the
 screen to stay awake.


  
 A  timer  metric contains an  int  count and a  long  time
 measured in milliseconds. Timers track how many times a resource was used and
 the total duration for that usage. For example the
  UidHealthStats.TIMER_FLASHLIGHT 
 timer tracks how many times the application turned on the flashlight and for
 how many milliseconds total it kept it on.

  
 A  measurement map  metric is a mapping of  String  names to
  Long  values.  The names typically are application provided names. For
 example the
  PackageHealthStats.MEASUREMENTS_WAKEUP_ALARMS_COUNT 
 measurement map is a mapping of the tag provided to the
  AlarmManager  when the alarm is scheduled.

  
 A  timer map  metric is a mapping of  String  names to
  TimerStat  objects. The names are typically application
 provided names.  For example the
  UidHealthStats.TIMERS_WAKELOCKS_PARTIAL 
 is a mapping of tag provided to the  PowerManager  when the
 wakelock is created to the number of times and for how long each wakelock was
 active.

  
 Lastly a  health stats  metric is a mapping of  String 
 names to a recursive  HealthStats  object containing
 more detailed information. For example the
  UidHealthStats.STATS_PACKAGES 
 metric is a mapping of the package names for each of the APKs sharing a uid to
 the information recorded for that apk.  The returned HealthStats objects will
 each be associated with a different set of constants.  For the HealthStats
 returned for UidHealthStats.STATS_PACKAGES the keys come from the
  PackageHealthStats   class.

  
 The keys that are available are subject to change depending on what a particular
 device or software version is capable of recording. Applications must handle the absence of
 data without crashing."
android,os.health,PackageHealthStats,0,"Keys for  HealthStats  returned from
  HealthStats#getStats(int)  with the
  UidHealthStats#STATS_PACKAGES  key."
android,os.health,PidHealthStats,0,"Keys for  HealthStats  returned from
  HealthStats#getStats(int)  with the
  UidHealthStats#STATS_PIDS  key.
  
 The values coming from PidHealthStats are a little bit different from
 the other HealthStats values.  These values are not aggregate or historical
 values but instead live values from when the snapshot is taken.  These
 tend to be more useful in debugging rogue processes than in gathering
 aggregate metrics across the fleet of devices."
android,os.health,ProcessHealthStats,0,"Keys for  HealthStats  returned from
  HealthStats#getStats(int)  with the
  UidHealthStats#STATS_PROCESSES  key."
android,os.health,ServiceHealthStats,0,"Keys for  HealthStats  returned from
  HealthStats#getStats(int)  with the
  PackageHealthStats#STATS_SERVICES  key."
android,os.health,SystemHealthManager,3,Provides access to data about how various system resources are used by applications.
android,os.health,TimerStat,6,A TimerStat object stores a count and a time.
android,os.health,UidHealthStats,0,"Keys for  HealthStats  returned from
  SystemHealthManager#takeUidSnapshot(int) 
  SystemHealthManager#takeMyUidSnapshot()  and
  SystemHealthManager#takeUidSnapshots(int[]) ."
android,os.storage,OnObbStateChangeListener,1,"Used for receiving notifications from  StorageManager  about OBB file
 states."
android,os.storage,StorageManager,21,"StorageManager is the interface to the systems storage service. The storage
 manager handles storage-related items such as Opaque Binary Blobs (OBBs).
  
 OBBs contain a filesystem that maybe be encrypted on disk and mounted
 on-demand from an application. OBBs are a good way of providing large amounts
 of binary assets without packaging them into APKs as they may be multiple
 gigabytes in size. However due to their size they're most likely stored in
 a shared storage pool accessible from all programs. The system does not
 guarantee the security of the OBB file itself: if any program modifies the
 OBB there is no guarantee that a read from that OBB will produce the
 expected output."
android,os.storage,StorageVolume,13,"Information about a shared/external storage volume for a specific user.

  
 A device always has one (and one only) primary storage volume but it could have extra volumes
 like SD cards and USB drives. This object represents the logical view of a storage
 volume for a specific user: different users might have different views for the same physical
 volume (for example if the volume is a built-in emulated storage).

  
 The storage volume is not necessarily mounted applications should use  getState()  to
 verify its state.

  
 Applications willing to read or write to this storage volume needs to get a permission from the
 user first which can be achieved in the following ways:

  To get access to standard directories (like the  Environment#DIRECTORY_PICTURES ) they
 can use the  createAccessIntent(java.lang.String) . This is the recommend way since it provides a
 simpler API and narrows the access to the given directory (and its descendants).
  To get access to any directory (and its descendants) they can use the Storage Acess
 Framework APIs (such as  Intent#ACTION_OPEN_DOCUMENT  and
  Intent#ACTION_OPEN_DOCUMENT_TREE  although these APIs do not guarantee the user will
 select this specific volume.
  To get read and write access to the primary storage volume applications can declare the
  Manifest.permission.READ_EXTERNAL_STORAGE  and
  Manifest.permission.WRITE_EXTERNAL_STORAGE  permissions respectively with the
 latter including the former. This approach is discouraged since users may be hesitant to grant
 broad access to all files contained on a storage device.
  It can be obtained through  StorageManager#getStorageVolumes()  and
  StorageManager#getPrimaryStorageVolume()  and also as an extra in some broadcasts
 (see  EXTRA_STORAGE_VOLUME ).

  
 See  Environment#getExternalStorageDirectory()  for more info about shared/external
 storage semantics."
android,os.strictmode,CleartextNetworkViolation,0,
android,os.strictmode,ContentUriWithoutPermissionViolation,0,
android,os.strictmode,DiskReadViolation,0,
android,os.strictmode,DiskWriteViolation,0,
android,os.strictmode,ImplicitDirectBootViolation,0,"Subclass of  Violation  that is used when a process implicitly relies
 on automatic Direct Boot filtering."
android,os.strictmode,InstanceCountViolation,1,
android,os.strictmode,IntentReceiverLeakedViolation,0,
android,os.strictmode,LeakedClosableViolation,0,
android,os.strictmode,SqliteObjectLeakedViolation,0,
android,os.strictmode,UnbufferedIoViolation,0,See # Builder#detectUnbufferedIo()
android,os.strictmode,CredentialProtectedWhileLockedViolation,0,"Subclass of  Violation  that is used when a process accesses filesystem
 paths stored in credential protected storage areas while the user is locked.
  
 When a user is locked credential protected storage is unavailable and files
 stored in these locations appear to not exist which can result in subtle app
 bugs if they assume default behaviors or empty states. Instead apps should
 store data needed while a user is locked under device protected storage
 areas."
android,os.strictmode,CustomViolation,0,
android,os.strictmode,FileUriExposedViolation,0,
android,os.strictmode,NetworkViolation,0,
android,os.strictmode,NonSdkApiUsedViolation,0,"Subclass of  Violation  that is used when a process accesses
 a non SDK API."
android,os.strictmode,ServiceConnectionLeakedViolation,0,
android,os.strictmode,UntaggedSocketViolation,0,
android,os.strictmode,Violation,0,Root class for all StrictMode violations.
android,os.strictmode,WebViewMethodCalledOnWrongThreadViolation,0,
android,os.strictmode,ResourceMismatchViolation,0,
android,opengl,EGL14,33,EGL 1.4
android,opengl,EGLContext,1,Wrapper class for native EGLContext objects.
android,opengl,EGLSync,1,Wrapper class for native EGLSync objects.
android,opengl,ETC1,9,"Methods for encoding and decoding ETC1 textures.
  
 The standard for the ETC1 texture format can be found at
 http://www.khronos.org/registry/gles/extensions/OES/OES_compressed_ETC1_RGB8_texture.txt
  
 The PKM file format is of a 16-byte header that describes the image bounds
 followed by the encoded ETC1 texture data."
android,opengl,GLES10,123,
android,opengl,GLES10Ext,2,
android,opengl,GLES20,190,OpenGL ES 2.0
android,opengl,GLES30,163,OpenGL ES 3.0
android,opengl,GLU,6,A set of GL utilities inspired by the OpenGL Utility Toolkit.
android,opengl,EGL15,10,EGL 1.5
android,opengl,EGLConfig,1,Wrapper class for native EGLConfig objects.
android,opengl,EGLDisplay,1,Wrapper class for native EGLDisplay objects.
android,opengl,EGLExt,1,EGL Extensions
android,opengl,EGLImage,1,Wrapper class for native EGLImage objects.
android,opengl,EGLObjectHandle,3,Base class for wrapped EGL objects.
android,opengl,EGLSurface,1,Wrapper class for native EGLSurface objects.
android,opengl,GLES31Ext,48,
android,opengl,Visibility,3,"A collection of utility methods for computing the visibility of triangle
 meshes."
android,opengl,ETC1Util,6,Utility methods for using ETC1 compressed textures.
android,opengl,ETC1Util.ETC1Texture,3,A utility class encapsulating a compressed ETC1 texture.
android,opengl,GLDebugHelper,2,"A helper class for debugging OpenGL ES applications.

 Wraps the supplied GL interface with a new GL interface that adds support for
 error checking and logging."
android,opengl,GLES11,69,
android,opengl,GLES11Ext,120,
android,opengl,GLES31,99,OpenGL ES 3.1
android,opengl,GLES32,60,OpenGL ES 3.2
android,opengl,GLSurfaceView,26,"An implementation of SurfaceView that uses the dedicated surface for
 displaying OpenGL rendering.
  
 A GLSurfaceView provides the following features:
  Manages a surface which is a special piece of memory that can be
 composited into the Android view system.
  Manages an EGL display which enables OpenGL to render into a surface.
  Accepts a user-provided Renderer object that does the actual rendering.
  Renders on a dedicated thread to decouple rendering performance from the
 UI thread.
  Supports both on-demand and continuous rendering.
  Optionally wraps traces and/or error-checks the renderer's OpenGL calls."
android,opengl,GLUtils,8,Utility class to help bridging OpenGL ES and Android APIs.
android,opengl,Matrix,18,"Matrix math utilities. These methods operate on OpenGL ES format
 matrices and vectors stored in float arrays.
  
 Matrices are 4 x 4 column-vector matrices stored in column-major
 order:
  
  m[offset +  0] m[offset +  4] m[offset +  8] m[offset + 12]
  m[offset +  1] m[offset +  5] m[offset +  9] m[offset + 13]
  m[offset +  2] m[offset +  6] m[offset + 10] m[offset + 14]
  m[offset +  3] m[offset +  7] m[offset + 11] m[offset + 15] 
 v[offset + 0]
 v[offset + 1]
 v[offset + 2]
 v[offset + 3]"
android,preference,CheckBoxPreference,0,"A  Preference  that provides checkbox widget
 functionality.
  
 This preference will store a boolean into the SharedPreferences."
android,preference,DialogPreference,29,"A base class for  Preference  objects that are
 dialog-based. These preferences will when clicked open a dialog showing the
 actual preference controls."
android,preference,EditTextPreference,11,"A  Preference  that allows for string
 input.
  
 It is a subclass of  DialogPreference  and shows the  EditText 
 in a dialog. This  EditText  can be modified either programmatically
 via  getEditText()  or through XML by setting any EditText
 attributes on the EditTextPreference.
  
 This preference will store a string into the SharedPreferences.
  
 See  EditText Attributes ."
android,preference,ListPreference,19,"A  Preference  that displays a list of entries as
 a dialog.
  
 This preference will store a string into the SharedPreferences. This string will be the value
 from the  setEntryValues(java.lang.CharSequence[])  array."
android,preference,MultiSelectListPreference,14,"A  Preference  that displays a list of entries as
 a dialog.
  
 This preference will store a set of strings into the SharedPreferences.
 This set will contain one or more values from the
  setEntryValues(java.lang.CharSequence[])  array."
android,preference,PreferenceFragment,17,"Shows a hierarchy of  Preference  objects as
 lists. These preferences will
 automatically save to  SharedPreferences  as the user interacts with
 them. To retrieve an instance of  SharedPreferences  that the
 preference hierarchy in this fragment will use call
  PreferenceManager#getDefaultSharedPreferences(android.content.Context) 
 with a context in the same package as this fragment.
  
 Furthermore the preferences shown will follow the visual style of system
 preferences. It is easy to create a hierarchy of preferences (that can be
 shown on multiple screens) via XML. For these reasons it is recommended to
 use this fragment (as a superclass) to deal with preferences in applications.
  
 A  PreferenceScreen  object should be at the top of the preference
 hierarchy. Furthermore subsequent  PreferenceScreen  in the hierarchy
 denote a screen break--that is the preferences contained within subsequent
  PreferenceScreen  should be shown on another screen. The preference
 framework handles showing these other screens from the preference hierarchy.
  
 The preference hierarchy can be formed in multiple ways:
   From an XML file specifying the hierarchy
   From different  Activity  that each specify its own
 preferences in an XML file via  Activity  meta-data
   From an object hierarchy rooted with  PreferenceScreen 
 To inflate from XML use the  addPreferencesFromResource(int) . The
 root element should be a  PreferenceScreen . Subsequent elements can point
 to actual  Preference  subclasses. As mentioned above subsequent
  PreferenceScreen  in the hierarchy will result in the screen break.
  
 To specify an  Intent  to query  Activity  that each
 have preferences use  addPreferencesFromIntent(Intent) . Each
  Activity  can specify meta-data in the manifest (via the key
  PreferenceManager#METADATA_KEY_PREFERENCES ) that points to an XML
 resource. These XML resources will be inflated into a single preference
 hierarchy and shown by this fragment.
  
 To specify an object hierarchy rooted with  PreferenceScreen  use
  setPreferenceScreen(android.preference.PreferenceScreen) .
  
 As a convenience this fragment implements a click listener for any
 preference in the current hierarchy see
  onPreferenceTreeClick(android.preference.PreferenceScreen android.preference.Preference) ."
android,preference,Preference,90,"Represents the basic Preference UI building
 block displayed by a  PreferenceActivity  in the form of a
  ListView . This class provides the  View  to be displayed in
 the activity and associates with a  SharedPreferences  to
 store/retrieve the preference data.
  
 When specifying a preference hierarchy in XML each element can point to a
 subclass of  Preference  similar to the view hierarchy and layouts.
  
 This class contains a  key  that will be used as the key into the
  SharedPreferences . It is up to the subclass to decide how to store
 the value."
android,preference,Preference.BaseSavedState,0,A base class for managing the instance state of a  Preference .
android,preference,PreferenceActivity,41,"This is the base class for an activity to show a hierarchy of preferences
 to the user.  Prior to  Build.VERSION_CODES.HONEYCOMB 
 this class only allowed the display of a single set of preference; this
 functionality should now be found in the new  PreferenceFragment 
 class.  If you are using PreferenceActivity in its old mode the documentation
 there applies to the deprecated APIs here.

  This activity shows one or more headers of preferences each of which
 is associated with a  PreferenceFragment  to display the preferences
 of that header.  The actual layout and display of these associations can
 however vary; currently there are two major approaches it may take:

  On a small screen it may display only the headers as a single list when first launched.
 Selecting one of the header items will only show the PreferenceFragment of that header (on
 Android N and lower a new Activity is launched).
  On a large screen it may display both the headers and current PreferenceFragment together as
 panes. Selecting a header item switches to showing the correct PreferenceFragment for that item.
  Subclasses of PreferenceActivity should implement
  onBuildHeaders(List )  to populate the header list with the desired
 items.  Doing this implicitly switches the class into its new ""headers
 + fragments"" mode rather than the old style of just showing a single
 preferences list."
android,preference,PreferenceActivity.Header,7,Description of a single Header item that the user can select.
android,preference,PreferenceCategory,3,"Used to group  Preference  objects
 and provide a disabled title above the group."
android,preference,PreferenceGroup,16,"A container for multiple
  Preference  objects. It is a base class for  Preference objects that are
 parents such as  PreferenceCategory  and  PreferenceScreen ."
android,preference,PreferenceManager,17,"Used to help create  Preference  hierarchies
 from activities or XML.
  
 In most cases clients should use
  PreferenceActivity#addPreferencesFromIntent  or
  PreferenceActivity#addPreferencesFromResource(int) ."
android,preference,PreferenceScreen,10,"Represents a top-level  Preference  that
 is the root of a Preference hierarchy. A  PreferenceActivity 
 points to an instance of this class to show the preferences. To instantiate
 this class use  PreferenceManager#createPreferenceScreen(Context) .
  
 This class can appear in two places:
   When a  PreferenceActivity  points to this it is used as the root
 and is not shown (only the contained preferences are shown).
   When it appears inside another preference hierarchy it is shown and
 serves as the gateway to another screen of preferences (either by showing
 another screen of preferences as a  Dialog  or via a
  Context#startActivity(android.content.Intent)  from the
  Preference#getIntent() ). The children of this  PreferenceScreen 
 are NOT shown in the screen that this  PreferenceScreen  is shown in.
 Instead a separate screen will be shown when this preference is clicked.
  Here's an example XML layout of a PreferenceScreen: 
 <PreferenceScreen
        xmlns:android=""http://schemas.android.com/apk/res/android""
        android:key=""first_preferencescreen"">
    <CheckBoxPreference
            android:key=""wifi enabled""
            android:title=""WiFi"" />
    <PreferenceScreen
            android:key=""second_preferencescreen""
            android:title=""WiFi settings"">
        <CheckBoxPreference
                android:key=""prefer wifi""
                android:title=""Prefer WiFi"" />
        ... other preferences here ...
    </PreferenceScreen>
 </PreferenceScreen>  
 In this example the ""first_preferencescreen"" will be used as the root of the
 hierarchy and given to a  PreferenceActivity . The first screen will
 show preferences ""WiFi"" (which can be used to quickly enable/disable WiFi)
 and ""WiFi settings"". The ""WiFi settings"" is the ""second_preferencescreen"" and when
 clicked will show another screen of preferences such as ""Prefer WiFi"" (and
 the other preferences that are children of the ""second_preferencescreen"" tag)."
android,preference,RingtonePreference,14,"A  Preference  that allows the user to choose a ringtone from those on the device.
 The chosen ringtone's URI will be persisted as a string.
  
 If the user chooses the ""Default"" item the saved string will be one of
  System#DEFAULT_RINGTONE_URI 
  System#DEFAULT_NOTIFICATION_URI  or
  System#DEFAULT_ALARM_ALERT_URI . If the user chooses the ""Silent""
 item the saved string will be an empty string."
android,preference,SwitchPreference,7,"A  Preference  that provides a two-state toggleable option.
  
 This preference will store a boolean into the SharedPreferences."
android,preference,TwoStatePreference,16,"Common base class for preferences that have two selectable states persist a
 boolean value in SharedPreferences and may have dependent preferences that are
 enabled/disabled based on the current state."
android,print.pdf,PrintedPdfDocument,4,"This class is a helper for creating a PDF file for given print attributes. It is useful for
 implementing printing via the native Android graphics APIs.
  
 This class computes the page width page height and content rectangle from the provided print
 attributes and these precomputed values can be accessed via  getPageWidth() 
  getPageHeight()  and  getPageContentRect()  respectively. The
  startPage(int)  methods creates pages whose
  PageInfo  is initialized with the precomputed
 values for width height and content rectangle.
  
 A typical use of the APIs looks like this:
  
 // open a new document
 PrintedPdfDocument document = new PrintedPdfDocument(context
         printAttributes);

 // start a page
 Page page = document.startPage(0);

 // draw something on the page
 View content = getContentView();
 content.draw(page.getCanvas());

 // finish the page
 document.finishPage(page);
 . . .
 // add more pages
 . . .
 // write the document content
 document.writeTo(getOutputStream());

 //close the document
 document.close();"
android,printservice,CustomPrinterIconCallback,1,Callback for  PrinterDiscoverySession#onRequestCustomPrinterIcon .
android,printservice,PrintDocument,2,"This class represents a printed document from the perspective of a print
 service. It exposes APIs to query the document and obtain its data.
  Note:   All methods of this class must be executed on the
 main application thread."
android,printservice,PrinterDiscoverySession,13,"This class encapsulates the interaction between a print service and the
 system during printer discovery. During printer discovery you are responsible
 for adding discovered printers removing previously added printers that
 disappeared and updating already added printers.
  
 During the lifetime of this session you may be asked to start and stop
 performing printer discovery multiple times. You will receive a call to  PrinterDiscoverySession#onStartPrinterDiscovery(List)  to start printer
 discovery and a call to  PrinterDiscoverySession#onStopPrinterDiscovery() 
 to stop printer discovery. When the system is no longer interested in printers
 discovered by this session you will receive a call to  onDestroy()  at
 which point the system will no longer call into the session and all the session
 methods will do nothing.
  
 Discovered printers are added by invoking  PrinterDiscoverySession#addPrinters(List) . Added printers that disappeared are
 removed by invoking  PrinterDiscoverySession#removePrinters(List) . Added
 printers whose properties or capabilities changed are updated through a call to
  PrinterDiscoverySession#addPrinters(List) . The printers added in this
 session can be acquired via  getPrinters()  where the returned printers
 will be an up-to-date snapshot of the printers that you reported during the
 session. Printers are  not  persisted across sessions.
  
 The system will make a call to  onValidatePrinters(java.util.List)  if you
 need to update some printers. It is possible that you add a printer without
 specifying its capabilities. This enables you to avoid querying all discovered
 printers for their capabilities rather querying the capabilities of a printer
 only if necessary. For example the system will request that you update a printer
 if it gets selected by the user. When validating printers you do not need to
 provide the printers' capabilities but may do so.
  
 If the system is interested in being constantly updated for the state of a
 printer you will receive a call to  onStartPrinterStateTracking(android.print.PrinterId) 
 after which you will have to do a best effort to keep the system updated for
 changes in the printer state and capabilities. You also  must 
 update the printer capabilities if you did not provide them when adding it or
 the printer will be ignored. When the system is no longer interested in getting
 updates for a printer you will receive a call to  onStopPrinterStateTracking(android.print.PrinterId) .
  Note:   All callbacks in this class are executed on the main
 application thread. You also have to invoke any method of this class on the main
 application thread."
android,printservice,PrintJob,24,"This class represents a print job from the perspective of a print
 service. It provides APIs for observing the print job state and
 performing operations on the print job.
  Note:   All methods of this class must be invoked on
 the main application thread."
android,printservice,PrintService,9,"This is the base class for implementing print services. A print service knows
 how to discover and interact one or more printers via one or more protocols.
  Printer discovery 
 A print service is responsible for discovering printers adding discovered printers
 removing added printers and updating added printers. When the system is interested
 in printers managed by your service it will call  onCreatePrinterDiscoverySession()  from which you must return a new  PrinterDiscoverySession  instance. The returned session encapsulates the interaction
 between the system and your service during printer discovery. For description of this
 interaction refer to the documentation for  PrinterDiscoverySession .
  
 For every printer discovery session all printers have to be added since system does
 not retain printers across sessions. Hence each printer known to this print service
 should be added only once during a discovery session. Only an already added printer
 can be removed or updated. Removed printers can be added again.
  Print jobs 
 When a new print job targeted to a printer managed by this print service is is queued
 i.e. ready for processing by the print service you will receive a call to  onPrintJobQueued(android.printservice.PrintJob) . The print service may handle the print job immediately
 or schedule that for an appropriate time in the future. The list of all active print
 jobs for this service is obtained by calling  getActivePrintJobs() . Active
 print jobs are ones that are queued or started.
  
 A print service is responsible for setting a print job's state as appropriate
 while processing it. Initially a print job is queued i.e.  PrintJob#isQueued()  returns true which means that the document to be printed is
 spooled by the system and the print service can begin processing it. You can obtain
 the printed document by calling  PrintJob#getDocument() 
 whose data is accessed via  PrintDocument#getData() .
 After the print service starts printing the data it should set the print job's
 state to started by calling  PrintJob#start()  after which
  PrintJob#isStarted()  would return true. Upon successful
 completion the print job should be marked as completed by calling  PrintJob#complete()  after which  PrintJob#isCompleted()  would return true. In case of a failure the print job should
 be marked as failed by calling  PrintJob#fail(String)  after which  PrintJob#isFailed()  would
 return true.
  
 If a print job is queued or started and the user requests to cancel it the print
 service will receive a call to  onRequestCancelPrintJob(android.printservice.PrintJob)  which
 requests from the service to do best effort in canceling the job. In case the job
 is successfully canceled its state has to be marked as cancelled by calling  PrintJob#cancel()  after which  PrintJob#isCancelled()  would return true.
  Lifecycle 
 The lifecycle of a print service is managed exclusively by the system and follows
 the established service lifecycle. Additionally starting or stopping a print service
 is triggered exclusively by an explicit user action through enabling or disabling it
 in the device settings. After the system binds to a print service it calls  onConnected() . This method can be overriden by clients to perform post binding setup.
 Also after the system unbinds from a print service it calls  onDisconnected() .
 This method can be overriden by clients to perform post unbinding cleanup. Your should
 not do any work after the system disconnected from your print service since the
 service can be killed at any time to reclaim memory. The system will not disconnect
 from a print service if there are active print jobs for the printers managed by it.
  Declaration 
 A print service is declared as any other service in an AndroidManifest.xml but it must
 also specify that it handles the  Intent  with action  android.printservice.PrintService . Failure to declare this intent
 will cause the system to ignore the print service. Additionally a print service must
 request the  android.permission.BIND_PRINT_SERVICE  permission to ensure that only the system can
 bind to it. Failure to declare this intent will cause the system to ignore the print
 service. Following is an example declaration:
  
 <service android:name="".MyPrintService""
         android:permission=""android.permission.BIND_PRINT_SERVICE"">
     <intent-filter>
         <action android:name=""android.printservice.PrintService"" />
     </intent-filter>
     . . .
 </service>
  Configuration 
 A print service can be configured by specifying an optional settings activity which
 exposes service specific settings an optional add printers activity which is used for
 manual addition of printers vendor name etc. It is a responsibility of the system
 to launch the settings and add printers activities when appropriate.
  
 A print service is configured by providing a  meta-data 
 entry in the manifest when declaring the service. A service declaration with a meta-data
 tag is presented below:
   <service android:name="".MyPrintService""
         android:permission=""android.permission.BIND_PRINT_SERVICE"">
     <intent-filter>
         <action android:name=""android.printservice.PrintService"" />
     </intent-filter>
     <meta-data android:name=""android.printservice"" android:resource=""@xml/printservice"" />
 </service> 
 For more details for how to configure your print service via the meta-data refer to
  SERVICE_META_DATA  and  < print-service > .
  Note:   All callbacks in this class are executed on the main
 application thread. You should also invoke any method of this class on the main
 application thread."
android,media,AsyncPlayer,3,"Plays a series of audio URIs but does all the hard work on another thread
 so that any slowness with preparing or loading doesn't block the calling thread."
android,media,AudioDeviceCallback,2,"AudioDeviceCallback defines the mechanism by which applications can receive notifications
 of audio device connection and disconnection events."
android,media,AudioDeviceInfo,13,Class to provide information about the audio devices.
android,media,AudioFocusRequest,4,"A class to encapsulate information about an audio focus request.
 An  AudioFocusRequest  instance is built by  Builder  and is used to
 request and abandon audio focus respectively
 with  AudioManager#requestAudioFocus(AudioFocusRequest)  and
  AudioManager#abandonAudioFocusRequest(AudioFocusRequest) .

  What is audio focus? Audio focus is a concept introduced in API 8. It is used to convey the fact that a user can
 only focus on a single audio stream at a time e.g. listening to music or a podcast but not
 both at the same time. In some cases multiple audio streams can be playing at the same time
 but there is only one the user would really listen to (focus on) while the other plays in
 the background. An example of this is driving directions being spoken while music plays at
 a reduced volume (a.k.a. ducking).
  When an application requests audio focus it expresses its intention to â€œownâ€ audio focus to
 play audio. Letâ€™s review the different types of focus requests the return value after a request
 and the responses to a loss.
  Note: applications should not play anything until granted focus. The different types of focus requests There are four focus request types. A successful focus request with each will yield different
 behaviors by the system and the other application that previously held audio focus.
  AudioManager#AUDIOFOCUS_GAIN  expresses the fact that your application is now the
 sole source of audio that the user is listening to. The duration of the audio playback is
 unknown and is possibly very long: after the user finishes interacting with your application
 (s)he doesnâ€™t expect another audio stream to resume. Examples of uses of this focus gain are
 for music playback for a game or a video player. AudioManager#AUDIOFOCUS_GAIN_TRANSIENT  is for a situation when you know your
 application is temporarily grabbing focus from the current owner but the user expects playback
 to go back to where it was once your application no longer requires audio focus. An example is
 for playing an alarm or during a VoIP call. The playback is known to be finite: the alarm will
 time-out or be dismissed the VoIP call has a beginning and an end. When any of those events
 ends and if the user was listening to music when it started the user expects music to resume
 but didnâ€™t wish to listen to both at the same time. AudioManager#AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK : this focus request type is similar
 to  AUDIOFOCUS_GAIN_TRANSIENT  for the temporary aspect of the focus request but it also
 expresses the fact during the time you own focus you allow another application to keep playing
 at a reduced volume â€œduckedâ€. Examples are when playing driving directions or notifications
 itâ€™s ok for music to keep playing but not loud enough that it would prevent the directions to
 be hard to understand. A typical attenuation by the â€œduckedâ€ application is a factor of 0.2f
 (or -14dB) that can for instance be applied with  MediaPlayer.setVolume(0.2f)  when
 using this class for playback. AudioManager#AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE  is also for a temporary request
 but also expresses that your application expects the device to not play anything else. This is
 typically used if you are doing audio recording or speech recognition and donâ€™t want for
 examples notifications to be played by the system during that time. An  AudioFocusRequest  instance always contains one of the four types of requests
 explained above. It is passed when building an  AudioFocusRequest  instance with its
 builder in the  Builder  constructor
  AudioFocusRequest.Builder#AudioFocusRequest.Builder(int)  or
 with  AudioFocusRequest.Builder#setFocusGain(int)  after copying an existing instance with
  AudioFocusRequest.Builder#AudioFocusRequest.Builder(AudioFocusRequest) .

  Qualifying your focus request Use case requiring a focus request Any focus request is qualified by the  AudioAttributes 
 (see  Builder#setAudioAttributes(AudioAttributes) ) that describe the audio use case that
 will follow the request (once it's successful or granted). It is recommended to use the
 same  AudioAttributes  for the request as the attributes you are using for audio/media
 playback.
  If no attributes are set default attributes of  AudioAttributes#USAGE_MEDIA  are used.

  Delayed focus Audio focus can be ""locked"" by the system for a number of reasons: during a phone call when
 the car to which the device is connected plays an emergency message... To support these
 situations the application can request to be notified when its request is fulfilled by flagging
 its request as accepting delayed focus with  Builder#setAcceptsDelayedFocusGain(boolean) .
  If focus is requested while being locked by the system
  AudioManager#requestAudioFocus(AudioFocusRequest)  will return
  AudioManager#AUDIOFOCUS_REQUEST_DELAYED . When focus isn't locked anymore the focus
 listener set with  Builder#setOnAudioFocusChangeListener(OnAudioFocusChangeListener) 
 or with  Builder#setOnAudioFocusChangeListener(OnAudioFocusChangeListener Handler)  will
 be called to notify the application it now owns audio focus.

  Pausing vs ducking When an application requested audio focus with
  AudioManager#AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK  the system will duck the current focus
 owner.
  Note: this behavior is  new for Android O  whereas applications targeting
 SDK level up to API 25 had to implement the ducking themselves when they received a focus
 loss of  AudioManager#AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK .
  But ducking is not always the behavior expected by the user. A typical example is when the
 device plays driving directions while the user is listening to an audio book or podcast and
 expects the audio playback to pause instead of duck as it is hard to understand a navigation
 prompt and spoken content at the same time. Therefore the system will not automatically duck
 when it detects it would be ducking spoken content: such content is detected when the
  AudioAttributes  of the player are qualified by
  AudioAttributes#CONTENT_TYPE_SPEECH . Refer for instance to
  AudioAttributes.Builder#setContentType(int)  and
  MediaPlayer#setAudioAttributes(AudioAttributes)  if you are writing a media playback
 application for audio book podcasts... Since the system will not automatically duck applications
 that play speech it calls their focus listener instead to notify them of
  AudioManager#AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK  so they can pause instead. Note that
 this behavior is independent of the use of  AudioFocusRequest  but tied to the use
 of  AudioAttributes .
  If your application requires pausing instead of ducking for any other reason than playing
 speech you can also declare so with  Builder#setWillPauseWhenDucked(boolean)  which will
 cause the system to call your focus listener instead of automatically ducking.

  Example The example below covers the following steps to be found in any application that would play
 audio and use audio focus. Here we play an audio book and our application is intended to pause
 rather than duck when it loses focus. These steps consist in:
  Creating  AudioAttributes  to be used for the playback and the focus request. Configuring and creating the  AudioFocusRequest  instance that defines the intended
     focus behaviors. Requesting audio focus and checking the return code to see if playback can happen right
     away or is delayed. Implementing a focus change listener to respond to focus gains and losses. 
 // initialization of the audio attributes and focus request
 mAudioManager = (AudioManager) Context.getSystemService(Context.AUDIO_SERVICE);
 mPlaybackAttributes = new AudioAttributes.Builder()
         .setUsage(AudioAttributes.USAGE_MEDIA)
         .setContentType(AudioAttributes.CONTENT_TYPE_SPEECH)
         .build();
 mFocusRequest = new AudioFocusRequest.Builder(AudioManager.AUDIOFOCUS_GAIN)
         .setAudioAttributes(mPlaybackAttributes)
         .setAcceptsDelayedFocusGain(true)
         .setWillPauseWhenDucked(true)
         .setOnAudioFocusChangeListener(this mMyHandler)
         .build();
 mMediaPlayer = new MediaPlayer();
 mMediaPlayer.setAudioAttributes(mPlaybackAttributes);
 final Object mFocusLock = new Object();

 boolean mPlaybackDelayed = false;

 // requesting audio focus
 int res = mAudioManager.requestAudioFocus(mFocusRequest);
 synchronized (mFocusLock) {
     if (res == AudioManager.AUDIOFOCUS_REQUEST_FAILED) {
         mPlaybackDelayed = false;
     } else if (res == AudioManager.AUDIOFOCUS_REQUEST_GRANTED) {
         mPlaybackDelayed = false;
         playbackNow();
     } else if (res == AudioManager.AUDIOFOCUS_REQUEST_DELAYED) {
        mPlaybackDelayed = true;
     }
 }

 // implementation of the OnAudioFocusChangeListener
 @Override
 public void onAudioFocusChange(int focusChange) {
     switch (focusChange) {
         case AudioManager.AUDIOFOCUS_GAIN:
             if (mPlaybackDelayed || mResumeOnFocusGain) {
                 synchronized (mFocusLock) {
                     mPlaybackDelayed = false;
                     mResumeOnFocusGain = false;
                 }
                 playbackNow();
             }
             break;
         case AudioManager.AUDIOFOCUS_LOSS:
             synchronized (mFocusLock) {
                 // this is not a transient loss we shouldn't automatically resume for now
                 mResumeOnFocusGain = false;
                 mPlaybackDelayed = false;
             }
             pausePlayback();
             break;
         case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT:
         case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK:
             // we handle all transient losses the same way because we never duck audio books
             synchronized (mFocusLock) {
                 // we should only resume if playback was interrupted
                 mResumeOnFocusGain = mMediaPlayer.isPlaying();
                 mPlaybackDelayed = false;
             }
             pausePlayback();
             break;
     }
 }

 // Important:
 // Also set ""mResumeOnFocusGain"" to false when the user pauses or stops playback: this way your
 // application doesn't automatically restart when it gains focus even though the user had
 // stopped it."
android,media,AudioFocusRequest.Builder,8,"Builder class for  AudioFocusRequest  objects.
  See  AudioFocusRequest  for an example of building an instance with this builder.
  The default values for the instance to be built are:
  focus listener and handler none AudioAttributes attributes with usage set to
      AudioAttributes#USAGE_MEDIA pauses on duck false supports delayed focus grant false"
android,media,AudioFormat,11,"The  AudioFormat  class is used to access a number of audio format and
 channel configuration constants. They are for instance used
 in  AudioTrack  and  AudioRecord  as valid values in individual parameters of
 constructors like  AudioTrack#AudioTrack(int int int int int int)  where the fourth
 parameter is one of the  AudioFormat.ENCODING_*  constants.
 The  AudioFormat  constants are also used in  MediaFormat  to specify
 audio related values commonly used in media such as for  MediaFormat#KEY_CHANNEL_MASK .
  The  AudioFormat.Builder  class can be used to create instances of
 the  AudioFormat  format class.
 Refer to
  AudioFormat.Builder  for documentation on the mechanics of the configuration and building
 of such instances. Here we describe the main concepts that the  AudioFormat  class
 allow you to convey in each instance they are:
  sample rate encoding channel masks Closely associated with the  AudioFormat  is the notion of an
  audio frame  which is used throughout the documentation
 to represent the minimum size complete unit of audio data.

  Sample rate Expressed in Hz the sample rate in an  AudioFormat  instance expresses the number
 of audio samples for each channel per second in the content you are playing or recording. It is
 not the sample rate
 at which content is rendered or produced. For instance a sound at a media sample rate of 8000Hz
 can be played on a device operating at a sample rate of 48000Hz; the sample rate conversion is
 automatically handled by the platform it will not play at 6x speed.

  As of API  Build.VERSION_CODES.M 
 sample rates up to 192kHz are supported
 for  AudioRecord  and  AudioTrack  with sample rate conversion
 performed as needed.
 To improve efficiency and avoid lossy conversions it is recommended to match the sample rate
 for  AudioRecord  and  AudioTrack  to the endpoint device
 sample rate and limit the sample rate to no more than 48kHz unless there are special
 device capabilities that warrant a higher rate.

  Encoding Audio encoding is used to describe the bit representation of audio data which can be
 either linear PCM or compressed audio such as AC3 or DTS.
  For linear PCM the audio encoding describes the sample size 8 bits 16 bits or 32 bits
 and the sample representation integer or float.
  ENCODING_PCM_8BIT : The audio sample is a 8 bit unsigned integer in the
 range [0 255] with a 128 offset for zero. This is typically stored as a Java byte in a
 byte array or ByteBuffer. Since the Java byte is  signed 
 be careful with math operations and conversions as the most significant bit is inverted.
  ENCODING_PCM_16BIT : The audio sample is a 16 bit signed integer
 typically stored as a Java short in a short array but when the short
 is stored in a ByteBuffer it is native endian (as compared to the default Java big endian).
 The short has full range from [-32768 32767]
 and is sometimes interpreted as fixed point Q.15 data.
  ENCODING_PCM_FLOAT : Introduced in
 API  Build.VERSION_CODES.LOLLIPOP  this encoding specifies that
 the audio sample is a 32 bit IEEE single precision float. The sample can be
 manipulated as a Java float in a float array though within a ByteBuffer
 it is stored in native endian byte order.
 The nominal range of  ENCODING_PCM_FLOAT  audio data is [-1.0 1.0].
 It is implementation dependent whether the positive maximum of 1.0 is included
 in the interval. Values outside of the nominal range are clamped before
 sending to the endpoint device. Beware that
 the handling of NaN is undefined; subnormals may be treated as zero; and
 infinities are generally clamped just like other values for  AudioTrack 
 â€“ try to avoid infinities because they can easily generate a NaN.
  
 To achieve higher audio bit depth than a signed 16 bit integer short
 it is recommended to use  ENCODING_PCM_FLOAT  for audio capture processing
 and playback.
 Floats are efficiently manipulated by modern CPUs
 have greater precision than 24 bit signed integers
 and have greater dynamic range than 32 bit signed integers.
  AudioRecord  as of API  Build.VERSION_CODES.M  and
  AudioTrack  as of API  Build.VERSION_CODES.LOLLIPOP 
 support  ENCODING_PCM_FLOAT .
  For compressed audio the encoding specifies the method of compression
 for example  ENCODING_AC3  and  ENCODING_DTS . The compressed
 audio data is typically stored as bytes in
 a byte array or ByteBuffer. When a compressed audio encoding is specified
 for an  AudioTrack  it creates a direct (non-mixed) track
 for output to an endpoint (such as HDMI) capable of decoding the compressed audio.
 For (most) other endpoints which are not capable of decoding such compressed audio
 you will need to decode the data first typically by creating a  MediaCodec .
 Alternatively one may use  MediaPlayer  for playback of compressed
 audio files or streams.
  When compressed audio is sent out through a direct  AudioTrack 
 it need not be written in exact multiples of the audio access unit;
 this differs from  MediaCodec  input buffers.

  Channel mask Channel masks are used in  AudioTrack  and  AudioRecord  to describe
 the samples and their arrangement in the audio frame. They are also used in the endpoint (e.g.
 a USB audio interface a DAC connected to headphones) to specify allowable configurations of a
 particular device.
  As of API  Build.VERSION_CODES.M  there are two types of channel masks:
 channel position masks and channel index masks.

  Channel position masks Build.VERSION_CODES.BASE channel count channel position mask 1 CHANNEL_OUT_MONO 2 CHANNEL_OUT_STEREO 3 CHANNEL_OUT_STEREO  |  CHANNEL_OUT_FRONT_CENTER 4 CHANNEL_OUT_QUAD 5 CHANNEL_OUT_QUAD  |  CHANNEL_OUT_FRONT_CENTER 6 CHANNEL_OUT_5POINT1 7 CHANNEL_OUT_5POINT1  |  CHANNEL_OUT_BACK_CENTER 8 CHANNEL_OUT_7POINT1_SURROUND CHANNEL_OUT_STEREO CHANNEL_OUT_FRONT_LEFT CHANNEL_OUT_FRONT_RIGHT Channel index masks Build.VERSION_CODES.M th CHANNEL_OUT_QUAD CHANNEL_OUT_FRONT_LEFT CHANNEL_OUT_FRONT_RIGHT CHANNEL_OUT_BACK_LEFT CHANNEL_OUT_BACK_RIGHT 1 << channelNumber 0xF 0x5 AudioTrack (1 << channelCount) - 1 Use cases Channel position mask for an endpoint: CHANNEL_OUT_FRONT_LEFT 
   CHANNEL_OUT_FRONT_CENTER  etc. for HDMI home theater purposes.
  Channel position mask for an audio stream:  Creating an  AudioTrack 
  to output movie content where 5.1 multichannel output is to be written.
  Channel index mask for an endpoint:  USB devices for which input and output do not
  correspond to left or right speaker or microphone.
  Channel index mask for an audio stream:  An  AudioRecord  may only want the
  third and fourth audio channels of the endpoint (i.e. the second channel pair) and not care the
  about position it corresponds to in which case the channel index mask is  0xC .
  Multichannel  AudioRecord  sessions should use channel index masks.
  Audio Frame For linear PCM an audio frame consists of a set of samples captured at the same time
 whose count and
 channel association are given by the  channel mask 
 and whose sample contents are specified by the  encoding .
 For example a stereo 16 bit PCM frame consists of
 two 16 bit linear PCM samples with a frame size of 4 bytes.
 For compressed audio an audio frame may alternately
 refer to an access unit of compressed data bytes that is logically grouped together for
 decoding and bitstream access (e.g.  MediaCodec )
 or a single byte of compressed data (e.g.  AudioTrack#getBufferSizeInFrames() )
 or the linear PCM frame result from decoding the compressed data
 (e.g. AudioTrack#getPlaybackHeadPosition() )
 depending on the context where audio frame is used.
 For the purposes of  AudioFormat#getFrameSizeInBytes()  a compressed data format
 returns a frame size of 1 byte."
android,media,AudioManager,70,AudioManager provides access to volume and ringer mode control.
android,media,AudioManager.AudioRecordingCallback,1,"Interface for receiving update notifications about the recording configuration. Extend
 this abstract class and register it with
  AudioManager#registerAudioRecordingCallback(AudioRecordingCallback Handler) 
 to be notified.
 Use  AudioManager#getActiveRecordingConfigurations()  to query the current
 configuration."
android,media,AudioPlaybackCaptureConfiguration.Builder,5,Builder for creating  AudioPlaybackCaptureConfiguration  instances.
android,media,AudioPlaybackConfiguration,5,"The AudioPlaybackConfiguration class collects the information describing an audio playback
 session."
android,media,AudioPresentation.Builder,8,A builder class for creating  AudioPresentation  objects.
android,media,AudioTimestamp,0,"Structure that groups a position in frame units relative to an assumed audio stream
 together with the estimated time when that frame enters or leaves the audio
 processing pipeline on that device. This can be used to coordinate events
 and interactions with the external environment.
  
 The time is based on the implementation's best effort using whatever knowledge
 is available to the system but cannot account for any delay unknown to the implementation."
android,media,AudioTrack.Builder,8,"Builder class for  AudioTrack  objects.
 Use this class to configure and create an  AudioTrack  instance. By setting audio
 attributes and audio format parameters you indicate which of those vary from the default
 behavior on the device.
   Here is an example where  Builder  is used to specify all  AudioFormat 
 parameters to be used by a new  AudioTrack  instance:

  
 AudioTrack player = new AudioTrack.Builder()
         .setAudioAttributes(new AudioAttributes.Builder()
                  .setUsage(AudioAttributes.USAGE_ALARM)
                  .setContentType(AudioAttributes.CONTENT_TYPE_MUSIC)
                  .build())
         .setAudioFormat(new AudioFormat.Builder()
                 .setEncoding(AudioFormat.ENCODING_PCM_16BIT)
                 .setSampleRate(44100)
                 .setChannelMask(AudioFormat.CHANNEL_OUT_STEREO)
                 .build())
         .setBufferSizeInBytes(minBuffSize)
         .build();
  
 If the audio attributes are not set with  setAudioAttributes(android.media.AudioAttributes) 
 attributes comprising  AudioAttributes#USAGE_MEDIA  will be used.
  If the audio format is not specified or is incomplete its channel configuration will be
  AudioFormat#CHANNEL_OUT_STEREO  and the encoding will be
  AudioFormat#ENCODING_PCM_16BIT .
 The sample rate will depend on the device actually selected for playback and can be queried
 with  AudioTrack.getSampleRate()  method.
  If the buffer size is not specified with  setBufferSizeInBytes(int) 
 and the mode is  AudioTrack#MODE_STREAM  the minimum buffer size is used.
  If the transfer mode is not specified with  setTransferMode(int) 
  MODE_STREAM  will be used.
  If the session ID is not specified with  setSessionId(int)  a new one will
 be generated.
  Offload is false by default."
android,media,AudioTrack.StreamEventCallback,3,"Abstract class to receive event notifications about the stream playback in offloaded mode.
 See  AudioTrack#registerStreamEventCallback(Executor StreamEventCallback)  to register
 the callback on the given  AudioTrack  instance."
android,media,DrmInitData.SchemeInitData,2,Scheme initialization data.
android,media,ExifInterface,16,"This is a class for reading and writing Exif tags in a JPEG file or a RAW image file.
  
 Supported formats are: JPEG DNG CR2 NEF NRW ARW RW2 ORF PEF SRW RAF and HEIF.
  
 Attribute mutation is supported for JPEG image files.
  
 Note: It is recommended to use the  AndroidX ExifInterface
 Library  since it is a superset of this class. In addition to the functionalities of this
 class it supports parsing extra metadata such as exposure and data compression information
 as well as setting extra metadata such as GPS and datetime information."
android,media,FaceDetector.Face,4,"A Face contains all the information identifying the location
 of a face in a bitmap."
android,media,Image.Plane,3,"A single color plane of image data. The number and meaning of the planes in an Image are determined by the
 format of the Image. Once the Image has been closed any access to the the plane's
 ByteBuffer will fail."
android,media,ImageReader,13,"The ImageReader class allows direct application access to image data
 rendered into a  Surface Several Android media API classes accept Surface objects as targets to
 render to including  MediaPlayer   MediaCodec 
  CameraDevice   ImageWriter  and
  RenderScript Allocations . The image
 sizes and formats that can be used with each source vary and should be
 checked in the documentation for the specific API. The image data is encapsulated in  Image  objects and multiple such
 objects can be accessed at the same time up to the number specified by the
  maxImages  constructor parameter. New images sent to an ImageReader
 through its  Surface  are queued until accessed through the  acquireLatestImage() 
 or  acquireNextImage()  call. Due to memory limits an image source will
 eventually stall or drop Images in trying to render to the Surface if the
 ImageReader does not obtain and release Images at a rate equal to the
 production rate."
android,media,ImageWriter,9,"The ImageWriter class allows an application to produce Image data into a
  Surface  and have it be consumed by another component
 like  CameraDevice .
  
 Several Android API classes can provide input  Surface  objects for ImageWriter to produce data into including
  MediaCodec  (encoder)
  CameraCaptureSession 
 (reprocessing input)  ImageReader  etc.
  
 The input Image data is encapsulated in  Image  objects. To produce
 Image data into a destination  Surface  the
 application can get an input Image via  dequeueInputImage()  then write
 Image data into it. Multiple such  Image  objects can be dequeued at
 the same time and queued back in any order up to the number specified by the
  maxImages  constructor parameter.
  
 If the application already has an Image from  ImageReader  the
 application can directly queue this Image into the ImageWriter (via
  queueInputImage(Image) ) potentially with zero buffer copies. This
 even works if the image format of the ImageWriter is
  ImageFormat#PRIVATE  and prior to Android P is the only
 way to enqueue images into such an ImageWriter. Starting in Android P
 private images may also be accessed through their hardware buffers
 (when available) through the  Image#getHardwareBuffer()  method.
 Attempting to access the planes of a private image will return an
 empty array.
  
 Once new input Images are queued into an ImageWriter it's up to the
 downstream components (e.g.  ImageReader  or
  CameraDevice ) to consume the Images. If the
 downstream components cannot consume the Images at least as fast as the
 ImageWriter production rate the  dequeueInputImage()  call will
 eventually block and the application will have to drop input frames.
  
 If the consumer component that provided the input  Surface 
 abandons the  Surface   queueing 
 or  dequeueing  an  Image  will throw an
  IllegalStateException ."
android,media,MediaActionSound,3,"A class for producing sounds that match those produced by various actions
 taken by the media and camera APIs.   This class is recommended for use with the  android.hardware.camera2  API since the
 camera2 API does not play any sounds on its own for any capture or video recording actions. With the older  Camera  API use this class to play an appropriate
 camera operation sound when implementing a custom still or video recording mechanism (through the
 Camera preview callbacks with
  Camera.setPreviewCallback  or through GPU
 processing with  Camera.setPreviewTexture  for
 example) or when implementing some other camera-like function in your application. There is no need to play sounds when using
  Camera.takePicture  or
  MediaRecorder  for still images or video respectively
 as the Android framework will play the appropriate sounds when needed for
 these calls."
android,media,MediaCas,12,"MediaCas can be used to obtain keys for descrambling protected media streams in
 conjunction with  MediaDescrambler . The MediaCas APIs are
 designed to support conditional access such as those in the ISO/IEC13818-1.
 The CA system is identified by a 16-bit integer CA_system_id. The scrambling
 algorithms are usually proprietary and implemented by vendor-specific CA plugins
 installed on the device.
  
 The app is responsible for constructing a MediaCas object for the CA system it
 intends to use. The app can query if a certain CA system is supported using static
 method  isSystemIdSupported(int) . It can also obtain the entire list of supported
 CA systems using static method  enumeratePlugins() .
  
 Once the MediaCas object is constructed the app should properly provision it by
 using method  provision(String)  and/or  processEmm(byte[]) . The EMMs (Entitlement
 management messages) can be distributed out-of-band or in-band with the stream.
  
 To descramble elementary streams the app first calls  openSession()  to
 generate a  Session  object that will uniquely identify a session. A session
 provides a context for subsequent key updates and descrambling activities. The ECMs
 (Entitlement control messages) are sent to the session via method
  Session#processEcm .
  
 The app next constructs a MediaDescrambler object and initializes it with the
 session using  MediaDescrambler#setMediaCasSession . This ties the
 descrambler to the session and the descrambler can then be used to descramble
 content secured with the session's key either during extraction or during decoding
 with  MediaCodec .
  
 If the app handles sample extraction using its own extractor it can use
 MediaDescrambler to descramble samples into clear buffers (if the session's license
 doesn't require secure decoders) or descramble a small amount of data to retrieve
 information necessary for the downstream pipeline to process the sample (if the
 session's license requires secure decoders).
  
 If the session requires a secure decoder a MediaDescrambler needs to be provided to
 MediaCodec to descramble samples queued by  MediaCodec#queueSecureInputBuffer 
 into protected buffers. The app should use  MediaCodec#configure(MediaFormat
 android.view.Surface int MediaDescrambler)  instead of the normal  MediaCodec#configure(MediaFormat android.view.Surface MediaCrypto int)  method
 to configure MediaCodec.
  Using Android's MediaExtractor 
 If the app uses  MediaExtractor  it can delegate the CAS session
 management to MediaExtractor by calling  MediaExtractor#setMediaCas .
 MediaExtractor will take over and call  openSession()   processEmm(byte[]) 
 and/or  Session#processEcm  etc.. if necessary.
  
 When using  MediaExtractor  the app would still need a MediaDescrambler
 to use with  MediaCodec  if the licensing requires a secure decoder. The
 session associated with the descrambler of a track can be retrieved by calling
  MediaExtractor#getCasInfo  and used to initialize a MediaDescrambler
 object for MediaCodec.
  Listeners The app may register a listener to receive events from the CA system using
 method  setEventListener(MediaCas.EventListener Handler) . The exact format of the event is scheme-specific
 and is not specified by this API."
android,media,MediaCas.PluginDescriptor,3,"Describe a CAS plugin with its CA_system_ID and string name.

 Returned as results of  MediaCas.enumeratePlugins() ."
android,media,MediaCas.Session,6,Class for an open session with the CA system.
android,media,MediaCodec,41,"MediaCodec class can be used to access low-level media codecs i.e. encoder/decoder components.
 It is part of the Android low-level multimedia support infrastructure (normally used together
 with  MediaExtractor   MediaSync   MediaMuxer   MediaCrypto 
  MediaDrm   Image   Surface  and  AudioTrack .)
  
 In broad terms a codec processes input data to generate output data. It processes data
 asynchronously and uses a set of input and output buffers. At a simplistic level you request
 (or receive) an empty input buffer fill it up with data and send it to the codec for
 processing. The codec uses up the data and transforms it into one of its empty output buffers.
 Finally you request (or receive) a filled output buffer consume its contents and release it
 back to the codec.
 
  Data Types 
 Codecs operate on three kinds of data: compressed data raw audio data and raw video data.
 All three kinds of data can be processed using  ByteBuffer  but you should use
 a  Surface  for raw video data to improve codec performance. Surface uses native video
 buffers without mapping or copying them to ByteBuffers; thus it is much more efficient.
 You normally cannot access the raw video data when using a Surface but you can use the
  ImageReader  class to access unsecured decoded (raw) video frames. This may still be more
 efficient than using ByteBuffers as some native buffers may be mapped into  ByteBuffer#isDirect  ByteBuffers. When using ByteBuffer mode you can access raw video
 frames using the  Image  class and  getInput / OutputImage(int) .
 
  Compressed Buffers 
 Input buffers (for decoders) and output buffers (for encoders) contain compressed data according
 to the  MediaFormat#KEY_MIME . For video types this is normally a single
 compressed video frame. For audio data this is normally a single access unit (an encoded audio
 segment typically containing a few milliseconds of audio as dictated by the format type) but
 this requirement is slightly relaxed in that a buffer may contain multiple encoded access units
 of audio. In either case buffers do not start or end on arbitrary byte boundaries but rather on
 frame/access unit boundaries unless they are flagged with  BUFFER_FLAG_PARTIAL_FRAME .
 
  Raw Audio Buffers 
 Raw audio buffers contain entire frames of PCM audio data which is one sample for each channel
 in channel order. Each PCM audio sample is either a 16 bit signed integer or a float
 in native byte order.
 Raw audio buffers in the float PCM encoding are only possible
 if the MediaFormat's  MediaFormat#KEY_PCM_ENCODING 
 is set to  AudioFormat#ENCODING_PCM_FLOAT  during MediaCodec
  configure(â€¦) 
 and confirmed by  getOutputFormat()  for decoders
 or  getInputFormat()  for encoders.
 A sample method to check for float PCM in the MediaFormat is as follows:
 
  
 static boolean isPcmFloat(MediaFormat format) {
  return format.getInteger(MediaFormat.KEY_PCM_ENCODING AudioFormat.ENCODING_PCM_16BIT)
      == AudioFormat.ENCODING_PCM_FLOAT;
 } 
 // Assumes the buffer PCM encoding is 16 bit.
 short[] getSamplesForChannel(MediaCodec codec int bufferId int channelIx) {
  ByteBuffer outputBuffer = codec.getOutputBuffer(bufferId);
  MediaFormat format = codec.getOutputFormat(bufferId);
  ShortBuffer samples = outputBuffer.order(ByteOrder.nativeOrder()).asShortBuffer();
  int numChannels = format.getInteger(MediaFormat.KEY_CHANNEL_COUNT);
  if (channelIx < 0 || channelIx >= numChannels) {
    return null;
  }
  short[] res = new short[samples.remaining() / numChannels];
  for (int i = 0; i < res.length; ++i) {
    res[i] = samples.get(i * numChannels + channelIx);
  }
  return res;
 } Raw Video Buffers 
 In ByteBuffer mode video buffers are laid out according to their  MediaFormat#KEY_COLOR_FORMAT . You can get the supported color formats as an array
 from  getCodecInfo() . MediaCodecInfo#getCapabilitiesForType . CodecCapabilities#colorFormats .
 Video codecs may support three kinds of color formats:
  native raw video format:  This is marked by  CodecCapabilities#COLOR_FormatSurface  and it can be used with an input or output Surface. flexible YUV buffers  (such as  CodecCapabilities#COLOR_FormatYUV420Flexible ): These can be used with an input/output Surface
 as well as in ByteBuffer mode by using  getInput / OutputImage(int) . other specific formats:  These are normally only supported in ByteBuffer
 mode. Some color formats are vendor specific. Others are defined in  CodecCapabilities .
 For color formats that are equivalent to a flexible format you can still use  getInput / OutputImage(int) . 
 All video codecs support flexible YUV 4:2:0 buffers since  Build.VERSION_CODES.LOLLIPOP_MR1 .
 
  Accessing Raw Video ByteBuffers on Older Devices 
 Prior to  Build.VERSION_CODES.LOLLIPOP  and  Image  support you need to
 use the  MediaFormat#KEY_STRIDE  and  MediaFormat#KEY_SLICE_HEIGHT  output format
 values to understand the layout of the raw output buffers.
  
 Note that on some devices the slice-height is advertised as 0. This could mean either that the
 slice-height is the same as the frame height or that the slice-height is the frame height
 aligned to some value (usually a power of 2). Unfortunately there is no standard and simple way
 to tell the actual slice height in this case. Furthermore the vertical stride of the  U 
 plane in planar formats is also not specified or defined though usually it is half of the slice
 height.
  
 The  MediaFormat#KEY_WIDTH  and  MediaFormat#KEY_HEIGHT  keys specify the size of the
 video frames; however for most encondings the video (picture) only occupies a portion of the
 video frame. This is represented by the 'crop rectangle'.
  
 You need to use the following keys to get the crop rectangle of raw output images from the
  output format . If these keys are not present the video occupies the
 entire video frame.The crop rectangle is understood in the context of the output frame
  before  applying any  MediaFormat#KEY_ROTATION .
  Format Key Type Description ""crop-left"" Integer The left-coordinate (x) of the crop rectangle ""crop-top"" Integer The top-coordinate (y) of the crop rectangle ""crop-right"" Integer The right-coordinate (x)  MINUS 1  of the crop rectangle ""crop-bottom"" Integer The bottom-coordinate (y)  MINUS 1  of the crop rectangle 
    The right and bottom coordinates can be understood as the coordinates of the right-most
    valid column/bottom-most valid row of the cropped output image.
    
 The size of the video frame (before rotation) can be calculated as such:
  
 MediaFormat format = decoder.getOutputFormat(â€¦);
 int width = format.getInteger(MediaFormat.KEY_WIDTH);
 if (format.containsKey(""crop-left"") && format.containsKey(""crop-right"")) {
    width = format.getInteger(""crop-right"") + 1 - format.getInteger(""crop-left"");
 }
 int height = format.getInteger(MediaFormat.KEY_HEIGHT);
 if (format.containsKey(""crop-top"") && format.containsKey(""crop-bottom"")) {
    height = format.getInteger(""crop-bottom"") + 1 - format.getInteger(""crop-top"");
 }
  
 Also note that the meaning of  BufferInfo#offset  was not consistent across
 devices. On some devices the offset pointed to the top-left pixel of the crop rectangle while on
 most devices it pointed to the top-left pixel of the entire frame.
 
  States 
 During its life a codec conceptually exists in one of three states: Stopped Executing or
 Released. The Stopped collective state is actually the conglomeration of three states:
 Uninitialized Configured and Error whereas the Executing state conceptually progresses through
 three sub-states: Flushed Running and End-of-Stream.
  
 When you create a codec using one of the factory methods the codec is in the Uninitialized
 state. First you need to configure it via  configure(â€¦)  which brings
 it to the Configured state then call  start()  to move it to the Executing state. In this
 state you can process data through the buffer queue manipulation described above.
  
 The Executing state has three sub-states: Flushed Running and End-of-Stream. Immediately after
  start()  the codec is in the Flushed sub-state where it holds all the buffers. As soon
 as the first input buffer is dequeued the codec moves to the Running sub-state where it spends
 most of its life. When you queue an input buffer with the  end-of-stream marker  the codec transitions to the End-of-Stream sub-state. In this state the
 codec no longer accepts further input buffers but still generates output buffers until the
 end-of-stream is reached on the output. You can move back to the Flushed sub-state at any time
 while in the Executing state using  flush() .
  
 Call  stop()  to return the codec to the Uninitialized state whereupon it may be configured
 again. When you are done using a codec you must release it by calling  release() .
  
 On rare occasions the codec may encounter an error and move to the Error state. This is
 communicated using an invalid return value from a queuing operation or sometimes via an
 exception. Call  reset()  to make the codec usable again. You can call it from any state to
 move the codec back to the Uninitialized state. Otherwise call  release()  to move to the
 terminal Released state.
 
  Creation 
 Use  MediaCodecList  to create a MediaCodec for a specific  MediaFormat . When
 decoding a file or a stream you can get the desired format from  MediaExtractor#getTrackFormat . Inject any specific features that
 you want to add using  MediaFormat#setFeatureEnabled  then
 call  MediaCodecList#findDecoderForFormat  to get the
 name of a codec that can handle that specific media format. Finally create the codec using
  createByCodecName(String) .
  Note:  On  Build.VERSION_CODES.LOLLIPOP  the format to
  MediaCodecList.findDecoder / EncoderForFormat  must not contain a  MediaFormat#KEY_FRAME_RATE . Use
  format.setString(MediaFormat.KEY_FRAME_RATE null) 
 to clear any existing frame rate setting in the format.
  
 You can also create the preferred codec for a specific MIME type using  createDecoder / EncoderByType(java.lang.String) .
 This however cannot be used to inject features and may create a codec that cannot handle the
 specific desired media format.
 
  Creating secure decoders 
 On versions  Build.VERSION_CODES.KITKAT_WATCH  and earlier secure codecs might
 not be listed in  MediaCodecList  but may still be available on the system. Secure codecs
 that exist can be instantiated by name only by appending  "".secure""  to the name of a
 regular codec (the name of all secure codecs must end in  "".secure"" .)  createByCodecName(String)  will throw an  IOException  if the codec is not present on the system.
  
 From  Build.VERSION_CODES.LOLLIPOP  onwards you should use the  CodecCapabilities#FEATURE_SecurePlayback  feature in the media format to create a secure decoder.
 
  Initialization 
 After creating the codec you can set a callback using  setCallback  if you
 want to process data asynchronously. Then  configure  the codec using the
 specific media format. This is when you can specify the output  Surface  for video
 producers â€“ codecs that generate raw video data (e.g. video decoders). This is also when
 you can set the decryption parameters for secure codecs (see  MediaCrypto ). Finally since
 some codecs can operate in multiple modes you must specify whether you want it to work as a
 decoder or an encoder.
  
 Since  Build.VERSION_CODES.LOLLIPOP  you can query the resulting input and
 output format in the Configured state. You can use this to verify the resulting configuration
 e.g. color formats before starting the codec.
  
 If you want to process raw input video buffers natively with a video consumer â€“ a codec
 that processes raw video input such as a video encoder â€“ create a destination Surface for
 your input data using  createInputSurface()  after configuration. Alternately set up the
 codec to use a previously created  persistent input
 surface  by calling  setInputSurface(Surface) .
 
  Codec-specific Data 
 Some formats notably AAC audio and MPEG4 H.264 and H.265 video formats require the actual data
 to be prefixed by a number of buffers containing setup data or codec specific data. When
 processing such compressed formats this data must be submitted to the codec after  start()  and before any frame data. Such data must be marked using the flag  BUFFER_FLAG_CODEC_CONFIG  in a call to  queueInputBuffer .
  
 Codec-specific data can also be included in the format passed to  configure  in
 ByteBuffer entries with keys ""csd-0"" ""csd-1"" etc. These keys are always included in the track
  MediaFormat  obtained from the  MediaExtractor#getTrackFormat .
 Codec-specific data in the format is automatically submitted to the codec upon  start() ;
 you  MUST NOT  submit this data explicitly. If the format did not contain codec
 specific data you can choose to submit it using the specified number of buffers in the correct
 order according to the format requirements. In case of H.264 AVC you can also concatenate all
 codec-specific data and submit it as a single codec-config buffer.
  
 Android uses the following codec-specific data buffers. These are also required to be set in
 the track format for proper  MediaMuxer  track configuration. Each parameter set and the
 codec-specific-data sections marked with ( * ) must start with a start code of
  ""\x00\x00\x00\x01"" .
  td.NA { background: #ccc; } .mid > tr > td { vertical-align: middle; } Format CSD buffer #0 CSD buffer #1 CSD buffer #2 AAC Decoder-specific information from ESDS * Not Used Not Used VORBIS Identification header Setup header Not Used OPUS Identification header Pre-skip in nanosecs 
       (unsigned 64-bit  ByteOrder#nativeOrder  integer.) 
       This overrides the pre-skip value in the identification header. Seek Pre-roll in nanosecs 
       (unsigned 64-bit  ByteOrder#nativeOrder  integer.) FLAC mandatory metadata block (called the STREAMINFO block) 
       optionally followed by any number of other metadata blocks Not Used Not Used MPEG-4 Decoder-specific information from ESDS * Not Used Not Used H.264 AVC SPS (Sequence Parameter Sets * ) PPS (Picture Parameter Sets * ) Not Used H.265 HEVC VPS (Video Parameter Sets * ) + 
    SPS (Sequence Parameter Sets * ) + 
    PPS (Picture Parameter Sets * ) Not Used Not Used VP9 VP9  CodecPrivate  Data
       (optional) Not Used Not Used Note:  care must be taken if the codec is flushed immediately or shortly
 after start before any output buffer or output format change has been returned as the codec
 specific data may be lost during the flush. You must resubmit the data using buffers marked with
  BUFFER_FLAG_CODEC_CONFIG  after such flush to ensure proper codec operation.
  
 Encoders (or codecs that generate compressed data) will create and return the codec specific data
 before any valid output buffer in output buffers marked with the  codec-config flag . Buffers containing codec-specific-data have no
 meaningful timestamps.
 
  Data Processing 
 Each codec maintains a set of input and output buffers that are referred to by a buffer-ID in
 API calls. After a successful call to  start()  the client ""owns"" neither input nor output
 buffers. In synchronous mode call  dequeueInput / OutputBuffer(â€¦)  to obtain (get ownership of) an input or output
 buffer from the codec. In asynchronous mode you will automatically receive available buffers via
 the  Callback#onInputBufferAvailable / Callback#onOutputBufferAvailable  callbacks.
  
 Upon obtaining an input buffer fill it with data and submit it to the codec using  queueInputBuffer  â€“ or  queueSecureInputBuffer  if using decryption. Do not submit multiple input buffers with the same
 timestamp (unless it is  codec-specific data  marked as such).
  
 The codec in turn will return a read-only output buffer via the  Callback#onOutputBufferAvailable  callback in asynchronous mode or in
 response to a  dequeueOutputBuffer  call in synchronous mode. After the
 output buffer has been processed call one of the  releaseOutputBuffer  methods to return the buffer to the codec.
  
 While you are not required to resubmit/release buffers immediately to the codec holding onto
 input and/or output buffers may stall the codec and this behavior is device dependent.
  Specifically it is possible that a codec may hold off on generating output buffers until
  all  outstanding buffers have been released/resubmitted.  Therefore try to
 hold onto to available buffers as little as possible.
  
 Depending on the API version you can process data in three ways:
  Processing Mode API version <= 20 Jelly Bean/KitKat API version >= 21 Lollipop and later Synchronous API using buffer arrays Supported Deprecated Synchronous API using buffers Not Available Supported Asynchronous API using buffers Not Available Supported Asynchronous Processing using Buffers 
 Since  Build.VERSION_CODES.LOLLIPOP  the preferred method is to process data
 asynchronously by setting a callback before calling  configure . Asynchronous
 mode changes the state transitions slightly because you must call  start()  after  flush()  to transition the codec to the Running sub-state and start receiving input buffers.
 Similarly upon an initial call to  start  the codec will move directly to the Running
 sub-state and start passing available input buffers via the callback.
  
 MediaCodec is typically used like this in asynchronous mode:
  
 MediaCodec codec = MediaCodec.createByCodecName(name);
 MediaFormat mOutputFormat; // member variable
 codec.setCallback(new MediaCodec.Callback() {
  @Override
  void onInputBufferAvailable(MediaCodec mc int inputBufferId) {
    ByteBuffer inputBuffer = codec.getInputBuffer(inputBufferId);
    // fill inputBuffer with valid data
    â€¦
    codec.queueInputBuffer(inputBufferId â€¦);
  }
 
  @Override
  void onOutputBufferAvailable(MediaCodec mc int outputBufferId â€¦) {
    ByteBuffer outputBuffer = codec.getOutputBuffer(outputBufferId);
    MediaFormat bufferFormat = codec.getOutputFormat(outputBufferId); // option A
    // bufferFormat is equivalent to mOutputFormat
    // outputBuffer is ready to be processed or rendered.
    â€¦
    codec.releaseOutputBuffer(outputBufferId â€¦);
  }
 
  @Override
  void onOutputFormatChanged(MediaCodec mc MediaFormat format) {
    // Subsequent data will conform to new format.
    // Can ignore if using getOutputFormat(outputBufferId)
    mOutputFormat = format; // option B
  }
 
  @Override
  void onError(â€¦) {
    â€¦
  }
 });
 codec.configure(format â€¦);
 mOutputFormat = codec.getOutputFormat(); // option B
 codec.start();
 // wait for processing to complete
 codec.stop();
 codec.release(); Synchronous Processing using Buffers 
 Since  Build.VERSION_CODES.LOLLIPOP  you should retrieve input and output
 buffers using  getInput / OutputBuffer(int)  and/or
  getInput / OutputImage(int)  even when using the
 codec in synchronous mode. This allows certain optimizations by the framework e.g. when
 processing dynamic content. This optimization is disabled if you call  getInput / OutputBuffers() .
 
  Note:  do not mix the methods of using buffers and buffer arrays at the same
 time. Specifically only call  getInput / OutputBuffers  directly after  start()  or after having dequeued an output buffer ID with the value of  INFO_OUTPUT_FORMAT_CHANGED .
  
 MediaCodec is typically used like this in synchronous mode:
  
 MediaCodec codec = MediaCodec.createByCodecName(name);
 codec.configure(format â€¦);
 MediaFormat outputFormat = codec.getOutputFormat(); // option B
 codec.start();
 for (;;) {
  int inputBufferId = codec.dequeueInputBuffer(timeoutUs);
  if (inputBufferId >= 0) {
    ByteBuffer inputBuffer = codec.getInputBuffer(â€¦);
    // fill inputBuffer with valid data
    â€¦
    codec.queueInputBuffer(inputBufferId â€¦);
  }
  int outputBufferId = codec.dequeueOutputBuffer(â€¦);
  if (outputBufferId >= 0) {
    ByteBuffer outputBuffer = codec.getOutputBuffer(outputBufferId);
    MediaFormat bufferFormat = codec.getOutputFormat(outputBufferId); // option A
    // bufferFormat is identical to outputFormat
    // outputBuffer is ready to be processed or rendered.
    â€¦
    codec.releaseOutputBuffer(outputBufferId â€¦);
  } else if (outputBufferId == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {
    // Subsequent data will conform to new format.
    // Can ignore if using getOutputFormat(outputBufferId)
    outputFormat = codec.getOutputFormat(); // option B
  }
 }
 codec.stop();
 codec.release(); Synchronous Processing using Buffer Arrays (deprecated) 
 In versions  Build.VERSION_CODES.KITKAT_WATCH  and before the set of input and
 output buffers are represented by the  ByteBuffer[]  arrays. After a successful call to
  start()  retrieve the buffer arrays using  getInput / OutputBuffers() . Use the buffer ID-s as indices into these arrays (when
 non-negative) as demonstrated in the sample below. Note that there is no inherent correlation
 between the size of the arrays and the number of input and output buffers used by the system
 although the array size provides an upper bound.
  
 MediaCodec codec = MediaCodec.createByCodecName(name);
 codec.configure(format â€¦);
 codec.start();
 ByteBuffer[] inputBuffers = codec.getInputBuffers();
 ByteBuffer[] outputBuffers = codec.getOutputBuffers();
 for (;;) {
  int inputBufferId = codec.dequeueInputBuffer(â€¦);
  if (inputBufferId >= 0) {
    // fill inputBuffers[inputBufferId] with valid data
    â€¦
    codec.queueInputBuffer(inputBufferId â€¦);
  }
  int outputBufferId = codec.dequeueOutputBuffer(â€¦);
  if (outputBufferId >= 0) {
    // outputBuffers[outputBufferId] is ready to be processed or rendered.
    â€¦
    codec.releaseOutputBuffer(outputBufferId â€¦);
  } else if (outputBufferId == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {
    outputBuffers = codec.getOutputBuffers();
  } else if (outputBufferId == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {
    // Subsequent data will conform to new format.
    MediaFormat format = codec.getOutputFormat();
  }
 }
 codec.stop();
 codec.release(); End-of-stream Handling 
 When you reach the end of the input data you must signal it to the codec by specifying the
  BUFFER_FLAG_END_OF_STREAM  flag in the call to  queueInputBuffer . You can do this on the last valid input buffer or by submitting an additional
 empty input buffer with the end-of-stream flag set. If using an empty buffer the timestamp will
 be ignored.
  
 The codec will continue to return output buffers until it eventually signals the end of the
 output stream by specifying the same end-of-stream flag in the  BufferInfo  set in  dequeueOutputBuffer  or returned via  Callback#onOutputBufferAvailable . This can be set on the last valid output buffer or on an empty buffer
 after the last valid output buffer. The timestamp of such empty buffer should be ignored.
  
 Do not submit additional input buffers after signaling the end of the input stream unless the
 codec has been flushed or stopped and restarted.
 
  Using an Output Surface 
 The data processing is nearly identical to the ByteBuffer mode when using an output  Surface ; however the output buffers will not be accessible and are represented as  null 
 values. E.g.  getOutputBuffer / Image(int)  will
 return  null  and  getOutputBuffers()  will return an array containing only  null -s.
  
 When using an output Surface you can select whether or not to render each output buffer on the
 surface. You have three choices:
  Do not render the buffer:  Call  releaseOutputBuffer(bufferId false) . Render the buffer with the default timestamp:  Call  releaseOutputBuffer(bufferId true) . Render the buffer with a specific timestamp:  Call  releaseOutputBuffer(bufferId timestamp) . 
 Since  Build.VERSION_CODES.M  the default timestamp is the  BufferInfo#presentationTimeUs  of the buffer (converted to nanoseconds).
 It was not defined prior to that.
  
 Also since  Build.VERSION_CODES.M  you can change the output Surface
 dynamically using  setOutputSurface .
  
 When rendering output to a Surface the Surface may be configured to drop excessive frames (that
 are not consumed by the Surface in a timely manner). Or it may be configured to not drop excessive
 frames. In the latter mode if the Surface is not consuming output frames fast enough it will
 eventually block the decoder. Prior to  Build.VERSION_CODES.Q  the exact behavior
 was undefined with the exception that View surfaces (SuerfaceView or TextureView) always dropped
 excessive frames. Since  Build.VERSION_CODES.Q  the default behavior is to drop
 excessive frames. Applications can opt out of this behavior for non-View surfaces (such as
 ImageReader or SurfaceTexture) by targeting SDK  Build.VERSION_CODES.Q  and
 setting the key  ""allow-frame-drop""  to  0  in their configure format.
 
  Transformations When Rendering onto Surface MediaFormat#KEY_ROTATION video scaling
 mode 
 Prior to the  Build.VERSION_CODES.M  release software decoders may not
 have applied the rotation when being rendered onto a Surface. Unfortunately there is no standard
 and simple way to identify software decoders or if they apply the rotation other than by trying
 it out.
  
 There are also some caveats.
  
 Note that the pixel aspect ratio is not considered when displaying the output onto the
 Surface. This means that if you are using  VIDEO_SCALING_MODE_SCALE_TO_FIT  mode you
 must position the output Surface so that it has the proper final display aspect ratio. Conversely
 you can only use  VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING  mode for content with
 square pixels (pixel aspect ratio or 1:1).
  
 Note also that as of  Build.VERSION_CODES.N  release  VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING  mode may not work correctly for videos rotated
 by 90 or 270 degrees.
  
 When setting the video scaling mode note that it must be reset after each time the output
 buffers change. Since the  INFO_OUTPUT_BUFFERS_CHANGED  event is deprecated you can
 do this after each time the output format changes.
 
  Using an Input Surface 
 When using an input Surface there are no accessible input buffers as buffers are automatically
 passed from the input surface to the codec. Calling  dequeueInputBuffer  will throw an  IllegalStateException  and  getInputBuffers() 
 returns a bogus  ByteBuffer[]  array that  MUST NOT  be written into.
  
 Call  signalEndOfInputStream()  to signal end-of-stream. The input surface will stop
 submitting data to the codec immediately after this call.
  Seeking & Adaptive Playback Support 
 Video decoders (and in general codecs that consume compressed video data) behave differently
 regarding seek and format change whether or not they support and are configured for adaptive
 playback. You can check if a decoder supports  CodecCapabilities#FEATURE_AdaptivePlayback  via  CodecCapabilities#isFeatureSupported . Adaptive
 playback support for video decoders is only activated if you configure the codec to decode onto a
  Surface .
 
  Stream Boundary and Key Frames 
 It is important that the input data after  start()  or  flush()  starts at a suitable
 stream boundary: the first frame must a key frame. A  key frame  can be decoded
 completely on its own (for most codecs this means an I-frame) and no frames that are to be
 displayed after a key frame refer to frames before the key frame.
  
 The following table summarizes suitable key frames for various video formats.
  Format Suitable key frame VP9/VP8 a suitable intraframe where no subsequent frames refer to frames prior to this frame. (There is no specific name for such key frame.) H.265 HEVC IDR or CRA H.264 AVC IDR MPEG-4 H.263 MPEG-2 a suitable I-frame where no subsequent frames refer to frames prior to this frame. (There is no specific name for such key frame.) For decoders that do not support adaptive playback (including when not decoding onto a
 Surface) 
 In order to start decoding data that is not adjacent to previously submitted data (i.e. after a
 seek) you  MUST  flush the decoder. Since all output buffers are immediately
 revoked at the point of the flush you may want to first signal then wait for the end-of-stream
 before you call  flush . It is important that the input data after a flush starts at a
 suitable stream boundary/key frame.
  Note:  the format of the data submitted after a flush must not change;  flush()  does not support format discontinuities; for that a full  stop()  -  configure(â€¦)  -  start()  cycle is necessary.
 
  Also note:  if you flush the codec too soon after  start()  â€“
 generally before the first output buffer or output format change is received â€“ you
 will need to resubmit the codec-specific-data to the codec. See the  codec-specific-data section  for more info.
 
  For decoders that support and are configured for adaptive playback 
 In order to start decoding data that is not adjacent to previously submitted data (i.e. after a
 seek) it is  not necessary  to flush the decoder; however input data after the
 discontinuity must start at a suitable stream boundary/key frame.
  
 For some video formats - namely H.264 H.265 VP8 and VP9 - it is also possible to change the
 picture size or configuration mid-stream. To do this you must package the entire new
 codec-specific configuration data together with the key frame into a single buffer (including
 any start codes) and submit it as a  regular  input buffer.
  
 You will receive an  INFO_OUTPUT_FORMAT_CHANGED  return value from  dequeueOutputBuffer  or a  Callback#onOutputBufferAvailable  callback just after the picture-size change takes place and before any
 frames with the new size have been returned.
  Note:  just as the case for codec-specific data be careful when calling
  flush()  shortly after you have changed the picture size. If you have not received
 confirmation of the picture size change you will need to repeat the request for the new picture
 size.
 
  Error handling 
 The factory methods  createByCodecName  and  createDecoder / EncoderByType  throw  IOException  on failure
 which you must catch or declare to pass up. MediaCodec methods throw  IllegalStateException  when the method is called from a codec state that does not allow it; this
 is typically due to incorrect application API usage. Methods involving secure buffers may throw
  CryptoException  which has further error information obtainable from  CryptoException#getErrorCode .
  
 Internal codec errors result in a  CodecException  which may be due to media content
 corruption hardware failure resource exhaustion and so forth even when the application is
 correctly using the API. The recommended action when receiving a  CodecException 
 can be determined by calling  CodecException#isRecoverable  and  CodecException#isTransient :
  recoverable errors:  If  isRecoverable()  returns true then call
  stop()   configure(â€¦)  and  start()  to recover. transient errors:  If  isTransient()  returns true then resources are
 temporarily unavailable and the method may be retried at a later time. fatal errors:  If both  isRecoverable()  and  isTransient() 
 return false then the  CodecException  is fatal and the codec must be  reset  or  released . 
 Both  isRecoverable()  and  isTransient()  do not return true at the same time."
android,media,MediaCodec.CryptoInfo,3,"Metadata describing the structure of an encrypted input sample.
  
 A buffer's data is considered to be partitioned into ""subSamples"". Each subSample starts with
 a run of plain unencrypted bytes followed by a run of encrypted bytes. Either of these runs
 may be empty. If pattern encryption applies each of the encrypted runs is encrypted only
 partly according to a repeating pattern of ""encrypt"" and ""skip"" blocks.
  numBytesOfClearData  can be null to indicate that all data is encrypted and
  numBytesOfEncryptedData  can be null to indicate that all data is clear. At least one
 of  numBytesOfClearData  and  numBytesOfEncryptedData  must be non-null.
  
 This information encapsulates per-sample metadata as outlined in ISO/IEC FDIS 23001-7:2016
 ""Common encryption in ISO base media file format files"".
  ISO-CENC Schemes AES-CTR AES-CBC Without Patterns cenc cbc1 With Patterns cens cbcs CryptoInfo mode setPattern(MediaCodec.CryptoInfo.Pattern) blocksToEncrypt blocksToSkip setPattern(MediaCodec.CryptoInfo.Pattern) HLS SAMPLE-AES Audio setPattern(MediaCodec.CryptoInfo.Pattern) 1 0"
android,media,MediaCodecInfo,9,"Provides information about a given media codec available on the device. You can
 iterate through all codecs available by querying  MediaCodecList . For example
 here's how to find an encoder that supports a given MIME type:
  
 private static MediaCodecInfo selectCodec(String mimeType) {
     int numCodecs = MediaCodecList.getCodecCount();
     for (int i = 0; i < numCodecs; i++) {
         MediaCodecInfo codecInfo = MediaCodecList.getCodecInfoAt(i);

         if (!codecInfo.isEncoder()) {
             continue;
         }

         String[] types = codecInfo.getSupportedTypes();
         for (int j = 0; j < types.length; j++) {
             if (types[j].equalsIgnoreCase(mimeType)) {
                 return codecInfo;
             }
         }
     }
     return null;
 }"
android,media,MediaCodecInfo.AudioCapabilities,5,A class that supports querying the audio capabilities of a codec.
android,media,MediaCodecInfo.CodecCapabilities,10,"Encapsulates the capabilities of a given codec component.
 For example what profile/level combinations it supports and what colorspaces
 it is capable of providing the decoded data in as well as some
 codec-type specific capability flags.
  You can get an instance for a given  MediaCodecInfo  object with
  MediaCodecInfo#getCapabilitiesForType  passing a MIME type."
android,media,MediaCodecInfo.CodecProfileLevel,2,"Encapsulates the profiles available for a codec component.
  You can get a set of  MediaCodecInfo.CodecProfileLevel  objects for a given
  MediaCodecInfo  object from the
  MediaCodecInfo.CodecCapabilities#profileLevels  field."
android,media,MediaCodecInfo.EncoderCapabilities,3,A class that supports querying the encoding capabilities of a codec.
android,media,MediaCodecInfo.VideoCapabilities,13,A class that supports querying the video capabilities of a codec.
android,media,MediaCodecInfo.VideoCapabilities.PerformancePoint,5,"Video performance points are a set of standard performance points defined by number of
 pixels pixel rate and frame rate. Performance point represents an upper bound. This
 means that it covers all performance points with fewer pixels pixel rate and frame
 rate."
android,media,MediaCodecList,5,"Allows you to enumerate available codecs each specified as a  MediaCodecInfo  object
 find a codec supporting a given format and query the capabilities
 of a given codec.
  See  MediaCodecInfo  for sample usage."
android,media,MediaController2,5,"This API is not generally intended for third party application developers.
 Use the  AndroidX Media2 session
 Library  for consistent behavior across all devices.

 Allows an app to interact with an active  MediaSession2  or a
  MediaSession2Service  which would provide  MediaSession2 . Media buttons and other
 commands can be sent to the session."
android,media,MediaController2.ControllerCallback,5,"This API is not generally intended for third party application developers.
 Use the  AndroidX Media2 session
 Library  for consistent behavior across all devices.
  
 Interface for listening to change in activeness of the  MediaSession2 ."
android,media,MediaDescription.Builder,9,Builder for  MediaDescription  objects.
android,media,MediaDrm,51,"MediaDrm can be used to obtain keys for decrypting protected media streams in
 conjunction with  MediaCrypto .  The MediaDrm APIs
 are designed to support the ISO/IEC 23001-7: Common Encryption standard but
 may also be used to implement other encryption schemes.
  
 Encrypted content is prepared using an encryption server and stored in a content
 library. The encrypted content is streamed or downloaded from the content library to
 client devices via content servers.  Licenses to view the content are obtained from
 a License Server.
  
 Keys are requested from the license server using a key request. The key
 response is delivered to the client app which provides the response to the
 MediaDrm API.
  
 A Provisioning server may be required to distribute device-unique credentials to
 the devices.
  
 Enforcing requirements related to the number of devices that may play content
 simultaneously can be performed either through key renewal or using the secure
 stop methods.
  
 The following sequence diagram shows the interactions between the objects
 involved while playing back encrypted content:
  
 The app first constructs  MediaExtractor  and
  MediaCodec  objects. It accesses the DRM-scheme-identifying UUID
 typically from metadata in the content and uses this UUID to construct an instance
 of a MediaDrm object that is able to support the DRM scheme required by the content.
 Crypto schemes are assigned 16 byte UUIDs.  The method  isCryptoSchemeSupported(UUID) 
 can be used to query if a given scheme is supported on the device.
  
 The app calls  openSession()  to generate a sessionId that will uniquely identify
 the session in subsequent interactions. The app next uses the MediaDrm object to
 obtain a key request message and send it to the license server then provide
 the server's response to the MediaDrm object.
  
 Once the app has a sessionId it can construct a MediaCrypto object from the UUID and
 sessionId.  The MediaCrypto object is registered with the MediaCodec in the
  MediaCodec#configure  method to enable the codec to decrypt content.
  
 When the app has constructed  MediaExtractor 
  MediaCodec  and  MediaCrypto  objects
 it proceeds to pull samples from the extractor and queue them into the decoder.  For
 encrypted content the samples returned from the extractor remain encrypted they
 are only decrypted when the samples are delivered to the decoder.
  
 MediaDrm methods throw  MediaDrm.MediaDrmStateException 
 when a method is called on a MediaDrm object that has had an unrecoverable failure
 in the DRM plugin or security hardware.
  MediaDrm.MediaDrmStateException  extends
  IllegalStateException  with the addition of a developer-readable
 diagnostic information string associated with the exception.
  
 In the event of a mediaserver process crash or restart while a MediaDrm object
 is active MediaDrm methods may throw  MediaDrmResetException .
 To recover the app must release the MediaDrm object then create and initialize
 a new one.
  
 As  MediaDrmResetException  and
  MediaDrm.MediaDrmStateException  both extend
  IllegalStateException  they should be in an earlier catch()
 block than  IllegalStateException  if handled separately.
  Callbacks Applications should register for informational events in order
 to be informed of key state updates during playback or streaming.
 Registration for these events is done via a call to
  setOnEventListener(MediaDrm.OnEventListener) . In order to receive the respective
 callback associated with this listener applications are required to create
 MediaDrm objects on a thread with its own Looper running (main UI
 thread by default has a Looper running)."
android,media,MediaDrm.CryptoSession,4,"In addition to supporting decryption of DASH Common Encrypted Media the
 MediaDrm APIs provide the ability to securely deliver session keys from
 an operator's session key server to a client device based on the factory-installed
 root of trust and then perform encrypt decrypt sign and verify operations
 with the session key on arbitrary user data.
  
 The CryptoSession class implements generic encrypt/decrypt/sign/verify methods
 based on the established session keys.  These keys are exchanged using the
 getKeyRequest/provideKeyResponse methods.
  
 Applications of this capability could include securing various types of
 purchased or private content such as applications books and other media
 photos or media delivery protocols.
  
 Operators can create session key servers that are functionally similar to a
 license key server except that instead of receiving license key requests and
 providing encrypted content keys which are used specifically to decrypt A/V media
 content the session key server receives session key requests and provides
 encrypted session keys which can be used for general purpose crypto operations.
  
 A CryptoSession is obtained using  MediaDrm.getCryptoSession(byte[] String String)"
android,media,MediaDrm.KeyRequest,3,"Contains the opaque data an app uses to request keys from a license server.
 These request types may or may not be generated by a given plugin. Refer
 to plugin vendor documentation for more information."
android,media,MediaDrm.KeyStatus,2,"Defines the status of a key.
 A KeyStatus for each key in a session is provided to the
  OnKeyStatusChangeListener#onKeyStatusChange 
 listener."
android,media,MediaDrm.MetricsConstants,0,"Definitions for the metrics that are reported via the
  MediaDrm.getMetrics()  call."
android,media,MediaDrm.ProvisionRequest,2,"Contains the opaque data an app uses to request a certificate from a provisioning
 server"
android,media,MediaExtractor.MetricsConstants,0,
android,media,MediaFormat,30,"Encapsulates the information describing the format of media data be it audio or video as
 well as optional feature metadata.
  
 The format of the media data is specified as key/value pairs. Keys are strings. Values can
 be integer long float String or ByteBuffer.
  
 The feature metadata is specificed as string/boolean pairs.
  
 Keys common to all audio/video formats  all keys not marked optional are mandatory :

  Name Value Type Description KEY_MIME String The type of the format. KEY_MAX_INPUT_SIZE Integer optional maximum size of a buffer of input data KEY_BIT_RATE Integer encoder-only  desired bitrate in bits/second Name Value Type Description KEY_WIDTH Integer KEY_HEIGHT Integer KEY_COLOR_FORMAT Integer set by the user
         for encoders readable in the output format of decoders KEY_FRAME_RATE Integer or Float required for  encoders 
         optional for  decoders KEY_CAPTURE_RATE Integer KEY_I_FRAME_INTERVAL Integer (or Float) encoder-only 
         time-interval between key frames.
         Float support added in  Build.VERSION_CODES.N_MR1 KEY_INTRA_REFRESH_PERIOD Integer encoder-only  optional KEY_LATENCY Integer encoder-only  optional KEY_MAX_WIDTH Integer decoder-only  optional max-resolution width KEY_MAX_HEIGHT Integer decoder-only  optional max-resolution height KEY_REPEAT_PREVIOUS_FRAME_AFTER Long encoder in surface-mode
         only  optional KEY_PUSH_BLANK_BUFFERS_ON_STOP Integer(1) decoder rendering
         to a surface only  optional KEY_TEMPORAL_LAYERING String encoder only  optional
         temporal-layering schema KEY_MAX_WIDTH KEY_MAX_HEIGHT MediaCodecInfo.CodecCapabilities#FEATURE_AdaptivePlayback Name Value Type Description KEY_CHANNEL_COUNT Integer KEY_SAMPLE_RATE Integer KEY_PCM_ENCODING Integer optional KEY_IS_ADTS Integer optional if  decoding  AAC audio content setting this key to 1 indicates that each audio frame is prefixed by the ADTS header. KEY_AAC_PROFILE Integer encoder-only  optional if content is AAC audio specifies the desired profile. KEY_AAC_SBR_MODE Integer encoder-only  optional if content is AAC audio specifies the desired SBR mode. KEY_AAC_DRC_TARGET_REFERENCE_LEVEL Integer decoder-only  optional if content is AAC audio specifies the target reference level. KEY_AAC_ENCODED_TARGET_LEVEL Integer decoder-only  optional if content is AAC audio specifies the target reference level used at encoder. KEY_AAC_DRC_BOOST_FACTOR Integer decoder-only  optional if content is AAC audio specifies the DRC boost factor. KEY_AAC_DRC_ATTENUATION_FACTOR Integer decoder-only  optional if content is AAC audio specifies the DRC attenuation factor. KEY_AAC_DRC_HEAVY_COMPRESSION Integer decoder-only  optional if content is AAC audio specifies whether to use heavy compression. KEY_AAC_MAX_OUTPUT_CHANNEL_COUNT Integer decoder-only  optional if content is AAC audio specifies the maximum number of channels the decoder outputs. KEY_AAC_DRC_EFFECT_TYPE Integer decoder-only  optional if content is AAC audio specifies the MPEG-D DRC effect type to use. KEY_CHANNEL_MASK Integer optional a mask of audio channel assignments KEY_FLAC_COMPRESSION_LEVEL Integer encoder-only  optional if content is FLAC audio specifies the desired compression level. KEY_MIME String The type of the format. KEY_LANGUAGE String The language of the content. KEY_MIME String The type of the format. KEY_WIDTH Integer KEY_HEIGHT Integer KEY_COLOR_FORMAT Integer set by the user
         for encoders readable in the output format of decoders KEY_TILE_WIDTH Integer required if the image has grid KEY_TILE_HEIGHT Integer required if the image has grid KEY_GRID_ROWS Integer required if the image has grid KEY_GRID_COLUMNS Integer required if the image has grid"
android,media,MediaMetadataRetriever,23,"MediaMetadataRetriever class provides a unified interface for retrieving
 frame and meta data from an input media file."
android,media,MediaMetadataRetriever.BitmapParams,3,
android,media,MediaMuxer.OutputFormat,0,Defines the output format. These constants are used with constructor.
android,media,MediaPlayer,91,"MediaPlayer class can be used to control playback
 of audio/video files and streams. An example on how to use the methods in
 this class can be found in  VideoView .

  Topics covered here are:
  State Diagram Valid and Invalid States Permissions Register informational and error callbacks"
android,media,MediaPlayer.DrmInfo,2,Encapsulates the DRM properties of the source.
android,media,MediaPlayer.MetricsConstants,0,
android,media,MediaPlayer.TrackInfo,6,Class for MediaPlayer to return each audio/video/subtitle track's metadata.
android,media,MediaRecorder.AudioEncoder,0,"Defines the audio encoding. These constants are used with
  MediaRecorder#setAudioEncoder(int) ."
android,media,MediaRecorder.VideoSource,0,"Defines the video source. These constants are used with
  MediaRecorder#setVideoSource(int) ."
android,media,MediaRouter.Callback,9,"Interface for receiving events about media routing changes.
 All methods of this interface will be called from the application's main thread.
  
 A Callback will only receive events relevant to routes that the callback
 was registered for unless the  MediaRouter#CALLBACK_FLAG_UNFILTERED_EVENTS 
 flag was specified in  MediaRouter#addCallback(int Callback int) ."
android,media,MediaRouter.RouteCategory,6,Definition of a category of routes. All routes belong to a category.
android,media,MediaRouter.RouteGroup,11,Information about a route that consists of multiple other routes in a group.
android,media,MediaRouter.RouteInfo,22,Information about a media route.
android,media,MediaRouter.SimpleCallback,8,"Stub implementation of  MediaRouter.Callback .
 Each abstract method is defined as a no-op. Override just the ones
 you need."
android,media,MediaRouter.UserRouteInfo,16,"Information about a route that the application may define and modify.
 A user route defaults to  RouteInfo#PLAYBACK_TYPE_REMOTE  and
  RouteInfo#PLAYBACK_VOLUME_FIXED ."
android,media,MediaRouter.VolumeCallback,2,"Interface for receiving events about volume changes.
 All methods of this interface will be called from the application's main thread.

  A VolumeCallback will only receive events relevant to routes that the callback
 was registered for."
android,media,MediaScannerConnection,7,"MediaScannerConnection provides a way for applications to pass a
 newly created or downloaded media file to the media scanner service.
 The media scanner service will read metadata from the file and add
 the file to the media content provider.
 The MediaScannerConnectionClient provides an interface for the
 media scanner service to return the Uri for a newly scanned file
 to the client of the MediaScannerConnection class."
android,media,MediaSession2,9,"This API is not generally intended for third party application developers.
 Use the  AndroidX Media2 session
 Library  for consistent behavior across all devices.
  
 Allows a media app to expose its transport controls and playback information in a process to
 other processes including the Android framework and other apps."
android,media,MediaSession2.ControllerInfo,7,"This API is not generally intended for third party application developers.
 Use the  AndroidX Media2 session
 Library  for consistent behavior across all devices.
  
 Information of a controller."
android,media,MediaSession2Service.MediaNotification,2,"This API is not generally intended for third party application developers.
 Use the  AndroidX Media2 session
 Library  for consistent behavior across all devices.
  
 Returned by  MediaSession2Service.onUpdateNotification(android.media.MediaSession2)  for making session service
 foreground service to keep playback running in the background. It's highly recommended to
 show media style notification here."
android,media,MediaSync,14,"MediaSync class can be used to synchronously play audio and video streams.
 It can be used to play audio-only or video-only stream too.

  MediaSync is generally used like this:
  
 MediaSync sync = new MediaSync();
 sync.setSurface(surface);
 Surface inputSurface = sync.createInputSurface();
 ...
 // MediaCodec videoDecoder = ...;
 videoDecoder.configure(format inputSurface ...);
 ...
 sync.setAudioTrack(audioTrack);
 sync.setCallback(new MediaSync.Callback() {
     @Override
     public void onAudioBufferConsumed(MediaSync sync ByteBuffer audioBuffer int bufferId) {
         ...
     }
 } null);
 // This needs to be done since sync is paused on creation.
 sync.setPlaybackParams(new PlaybackParams().setSpeed(1.f));

 for (;;) {
   ...
   // send video frames to surface for rendering e.g. call
   // videoDecoder.releaseOutputBuffer(videoOutputBufferIx videoPresentationTimeNs);
   // More details are available as below.
   ...
   sync.queueAudio(audioByteBuffer bufferId audioPresentationTimeUs); // non-blocking.
   // The audioByteBuffer and bufferId will be returned via callback.
   // More details are available as below.
   ...
     ...
 }
 sync.setPlaybackParams(new PlaybackParams().setSpeed(0.f));
 sync.release();
 sync = null;

 // The following code snippet illustrates how video/audio raw frames are created by
 // MediaCodec's how they are fed to MediaSync and how they are returned by MediaSync.
 // This is the callback from MediaCodec.
 onOutputBufferAvailable(MediaCodec codec int bufferId BufferInfo info) {
     // ...
     if (codec == videoDecoder) {
         // surface timestamp must contain media presentation time in nanoseconds.
         codec.releaseOutputBuffer(bufferId 1000 * info.presentationTime);
     } else {
         ByteBuffer audioByteBuffer = codec.getOutputBuffer(bufferId);
         sync.queueAudio(audioByteBuffer bufferId info.presentationTime);
     }
     // ...
 }

 // This is the callback from MediaSync.
 onAudioBufferConsumed(MediaSync sync ByteBuffer buffer int bufferId) {
     // ...
     audioDecoder.releaseBuffer(bufferId false);
     // ...
 }

  
 For video the client needs to call  createInputSurface()  to obtain a surface on
 which it will render video frames.
  
 For audio the client needs to set up audio track correctly e.g. using  AudioTrack#MODE_STREAM . The audio buffers are sent to MediaSync directly via  queueAudio(ByteBuffer int long)  and are returned to the client via  Callback#onAudioBufferConsumed 
 asynchronously. The client should not modify an audio buffer till it's returned.
  
 The client can optionally pre-fill audio/video buffers by setting playback rate to 0.0
 and then feed audio/video buffers to corresponding components. This can reduce possible
 initial underrun."
android,media,MediaSync.Callback,1,"MediaSync callback interface. Used to notify the user asynchronously
 of various MediaSync events."
android,media,MediaSyncEvent,4,"The MediaSyncEvent class defines events that can be used to synchronize playback or capture
 actions between different players and recorders.
  For instance  AudioRecord#startRecording(MediaSyncEvent)  is used to start capture
 only when the playback on a particular audio session is complete.
 The audio session ID is retrieved from a player (e.g  MediaPlayer   AudioTrack  or
  ToneGenerator ) by use of the getAudioSessionId() method."
android,media,MediaTimestamp,6,"An immutable object that represents the linear correlation between the media time
 and the system time. It contains the media clock rate together with the media timestamp
 of an anchor frame and the system time when that frame was presented or is committed
 to be presented.
  
 The phrase ""present"" means that audio/video produced on device is detectable by an external
 observer off device.
 The time is based on the implementation's best effort using whatever knowledge
 is available to the system but cannot account for any delay unknown to the implementation.
 The anchor frame could be any frame including a just-rendered frame or even a theoretical
 or in-between frame based on the source of the MediaTimestamp.
 When the anchor frame is a just-rendered one the media time stands for
 current position of the playback or recording."
android,media,MicrophoneInfo,15,"Class providing information on a microphone. It indicates the location and orientation of the
 microphone on the device as well as useful information like frequency response and sensitivity.
 It can be used by applications implementing special pre processing effects like noise suppression
 of beam forming that need to know about precise microphone characteristics in order to adapt
 their algorithms."
android,media,MicrophoneInfo.Coordinate3F,1,
android,media,Rating,14,"A class to encapsulate rating information used as content metadata.
 A rating is defined by its rating style (see  RATING_HEART 
  RATING_THUMB_UP_DOWN   RATING_3_STARS   RATING_4_STARS 
  RATING_5_STARS  or  RATING_PERCENTAGE ) and the actual rating value (which may
 be defined as ""unrated"") both of which are defined when the rating instance is constructed
 through one of the factory methods."
android,media,RemoteController,7,"The RemoteController class is used to control media playback display and update media metadata
 and playback status published by applications using the  RemoteControlClient  class.
  
 A RemoteController shall be registered through
  AudioManager#registerRemoteController(RemoteController)  in order for the system to send
 media event updates to the  OnClientUpdateListener  listener set in the class constructor.
 Implement the methods of the interface to receive the information published by the active
  RemoteControlClient  instances.
  By default an  OnClientUpdateListener  implementation will not receive bitmaps for
 album art. Use  setArtworkConfiguration(int int)  to receive images as well.
  
 Registration requires the  OnClientUpdateListener  listener to be one of the enabled
 notification listeners (see  NotificationListenerService )."
android,media,RemoteController.MetadataEditor,1,"A class to read the metadata published by a  RemoteControlClient  or send a
  RemoteControlClient  new values for keys that can be edited."
android,media,Ringtone,13,"Ringtone provides a quick method for playing a ringtone notification or
 other similar types of sounds.
  
 For ways of retrieving  Ringtone  objects or to show a ringtone
 picker see  RingtoneManager ."
android,media,RingtoneManager,21,"RingtoneManager provides access to ringtones notification and other types
 of sounds. It manages querying the different media providers and combines the
 results into a single cursor. It also provides a  Ringtone  for each
 ringtone. We generically call these sounds ringtones however the
  TYPE_RINGTONE  refers to the type of sounds that are suitable for the
 phone ringer.
  
 To show a ringtone picker to the user use the
  ACTION_RINGTONE_PICKER  intent to launch the picker as a subactivity."
android,media,Session2CommandGroup,5,"This API is not generally intended for third party application developers.
 Use the  AndroidX Media2 session
 Library  for consistent behavior across all devices.
  
 A set of  Session2Command  which represents a command group."
android,media,Session2Token,10,"This API is not generally intended for third party application developers.
 Use the  AndroidX Media2 session
 Library  for consistent behavior across all devices.
  
 Represents an ongoing  MediaSession2  or a  MediaSession2Service .
 If it's representing a session service it may not be ongoing.
  
 This may be passed to apps by the session owner to allow them to create a
  MediaController2  to communicate with the session.
  
 It can be also obtained by  MediaSessionManager ."
android,media,SoundPool,18,"The SoundPool class manages and plays audio resources for applications.

  A SoundPool is a collection of samples that can be loaded into memory
 from a resource inside the APK or from a file in the file system. The
 SoundPool library uses the MediaPlayer service to decode the audio
 into a raw 16-bit PCM mono or stereo stream. This allows applications
 to ship with compressed streams without having to suffer the CPU load
 and latency of decompressing during playback. In addition to low-latency playback SoundPool can also manage the number
 of audio streams being rendered at once. When the SoundPool object is
 constructed the maxStreams parameter sets the maximum number of streams
 that can be played at a time from this single SoundPool. SoundPool tracks
 the number of active streams. If the maximum number of streams is exceeded
 SoundPool will automatically stop a previously playing stream based first
 on priority and then by age within that priority. Limiting the maximum
 number of streams helps to cap CPU loading and reducing the likelihood that
 audio mixing will impact visuals or UI performance. Sounds can be looped by setting a non-zero loop value. A value of -1
 causes the sound to loop forever. In this case the application must
 explicitly call the stop() function to stop the sound. Any other non-zero
 value will cause the sound to repeat the specified number of times e.g.
 a value of 3 causes the sound to play a total of 4 times. The playback rate can also be changed. A playback rate of 1.0 causes
 the sound to play at its original frequency (resampled if necessary
 to the hardware output frequency). A playback rate of 2.0 causes the
 sound to play at twice its original frequency and a playback rate of
 0.5 causes it to play at half its original frequency. The playback
 rate range is 0.5 to 2.0. Priority runs low to high i.e. higher numbers are higher priority.
 Priority is used when a call to play() would cause the number of active
 streams to exceed the value established by the maxStreams parameter when
 the SoundPool was created. In this case the stream allocator will stop
 the lowest priority stream. If there are multiple streams with the same
 low priority it will choose the oldest stream to stop. In the case
 where the priority of the new stream is lower than all the active
 streams the new sound will not play and the play() function will return
 a streamID of zero. Let's examine a typical use case: A game consists of several levels of
 play. For each level there is a set of unique sounds that are used only
 by that level. In this case the game logic should create a new SoundPool
 object when the first level is loaded. The level data itself might contain
 the list of sounds to be used by this level. The loading logic iterates
 through the list of sounds calling the appropriate SoundPool.load()
 function. This should typically be done early in the process to allow time
 for decompressing the audio to raw PCM format before they are needed for
 playback. Once the sounds are loaded and play has started the application can
 trigger sounds by calling SoundPool.play(). Playing streams can be
 paused or resumed and the application can also alter the pitch by
 adjusting the playback rate in real-time for doppler or synthesis
 effects. Note that since streams can be stopped due to resource constraints the
 streamID is a reference to a particular instance of a stream. If the stream
 is stopped to allow a higher priority stream to play the stream is no
 longer valid. However the application is allowed to call methods on
 the streamID without error. This may help simplify program logic since
 the application need not concern itself with the stream lifecycle. In our example when the player has completed the level the game
 logic should call SoundPool.release() to release all the native resources
 in use and then set the SoundPool reference to null. If the player starts
 another level a new SoundPool is created sounds are loaded and play
 resumes."
android,media,SoundPool.Builder,3,Builder class for  SoundPool  objects.
android,media,SubtitleData,4,"Class encapsulating subtitle data as received through the
  MediaPlayer.OnSubtitleDataListener  interface.
 The subtitle data includes:
   the track index  the start time (in microseconds) of the data  the duration (in microseconds) of the data  the actual data. MediaPlayer.TrackInfo MediaFormat#MIMETYPE_TEXT_CEA_608 MediaFormat#MIMETYPE_TEXT_CEA_708 MediaFormat#MIMETYPE_TEXT_VTT 
 Here is an example of iterating over the tracks of a  MediaPlayer  and checking which
 encoding is used for the subtitle tracks:
  
 MediaPlayer mp = new MediaPlayer();
 mp.setDataSource(myContentLocation);
 mp.prepare(); // synchronous prepare ready to use when method returns
 final TrackInfo[] trackInfos = mp.getTrackInfo();
 for (TrackInfo info : trackInfo) {
     if (info.getTrackType() == TrackInfo.MEDIA_TRACK_TYPE_SUBTITLE) {
         final String mime = info.getFormat().getString(MediaFormat.KEY_MIME);
         if (MediaFormat.MIMETYPE_TEXT_CEA_608.equals(mime) {
             // subtitle encoding is CEA 608
         } else if (MediaFormat.MIMETYPE_TEXT_CEA_708.equals(mime) {
             // subtitle encoding is CEA 708
         } else if (MediaFormat.MIMETYPE_TEXT_VTT.equals(mime) {
             // subtitle encoding is WebVTT
         }
     }
 }
  
 See
  MediaPlayer#setOnSubtitleDataListener(android.media.MediaPlayer.OnSubtitleDataListener android.os.Handler) 
 to receive subtitle data from a MediaPlayer object."
android,media,ToneGenerator,6,"This class provides methods to play DTMF tones (ITU-T Recommendation Q.23)
 call supervisory tones (3GPP TS 22.001 CEPT) and proprietary tones (3GPP TS 31.111).
 Depending on call state and routing options tones are mixed to the downlink audio
 or output to the speaker phone or headset.
 This API is not for generating tones over the uplink audio path."
android,media,VolumeProvider,6,"Handles requests to adjust or set the volume on a session. This is also used
 to push volume updates back to the session. The provider must call
  setCurrentVolume(int)  each time the volume being provided changes.
  
 You can set a volume provider on a session by calling
  MediaSession#setPlaybackToRemote ."
android,media,VolumeShaper.Configuration.Builder,8,"Builder class for a  VolumeShaper.Configuration  object.
   Here is an example where  Builder  is used to define the
  VolumeShaper.Configuration .

  
 VolumeShaper.Configuration LINEAR_RAMP =
         new VolumeShaper.Configuration.Builder()
             .setInterpolatorType(VolumeShaper.Configuration.INTERPOLATOR_TYPE_LINEAR)
             .setCurve(new float[] { 0.f 1.f } // times
                       new float[] { 0.f 1.f }) // volumes
             .setDuration(1000)
             .build();"
android,media,AudioAttributes.Builder,7,"Builder class for  AudioAttributes  objects.
   Here is an example where  Builder  is used to define the
  AudioAttributes  to be used by a new  AudioTrack  instance:

  
 AudioTrack myTrack = new AudioTrack(
         new AudioAttributes.Builder()
             .setUsage(AudioAttributes.USAGE_MEDIA)
             .setContentType(AudioAttributes.CONTENT_TYPE_MUSIC)
             .build()
         myFormat myBuffSize AudioTrack.MODE_STREAM mySession);
  By default all types of information (usage content type flags) conveyed by an
  AudioAttributes  instance are set to ""unknown"". Unknown information will be
 interpreted as a default value that is dependent on the context of use for instance a
  MediaPlayer  will use a default usage of  AudioAttributes#USAGE_MEDIA ."
android,media,AudioPlaybackCaptureConfiguration,5,"Configuration for capturing audio played by other apps.

  When capturing audio signals played by other apps (and yours)
  you will only capture a mix of the audio signals played by players
  (such as AudioTrack or MediaPlayer) which present the following characteristics:
    the usage value MUST be  AudioAttributes#USAGE_UNKNOWN  or
        AudioAttributes#USAGE_GAME 
       or  AudioAttributes#USAGE_MEDIA . All other usages CAN NOT be captured.   AND the capture policy set by their app (with  AudioManager#setAllowedCapturePolicy )
       or on each player (with  AudioAttributes.Builder#setAllowedCapturePolicy ) is
        AudioAttributes#ALLOW_CAPTURE_BY_ALL  whichever is the most strict.   AND their app attribute allowAudioPlaybackCapture in their manifest
       MUST either be:   set to ""true""   not set and their  targetSdkVersion  MUST be equal to or greater than
             Build.VERSION_CODES.Q .
            Ie. Apps that do not target at least Android Q must explicitly opt-in to be captured
            by a MediaProjection.   AND their apps MUST be in the same user profile as your app
       (eg work profile cannot capture user profile apps and vice-versa).  An example for creating a capture configuration for capturing all media playback:

  
     MediaProjection mediaProjection;
     // Retrieve a audio capable projection from the MediaProjectionManager
     AudioPlaybackCaptureConfiguration config =
         new AudioPlaybackCaptureConfiguration.Builder(mediaProjection)
         .addMatchingUsage(AudioAttributes.USAGE_MEDIA)
         .build();
     AudioRecord record = new AudioRecord.Builder()
         .setAudioPlaybackCaptureConfig(config)
         .build();"
android,media,AudioRecord,44,"The AudioRecord class manages the audio resources for Java applications
 to record audio from the audio input hardware of the platform. This is
 achieved by ""pulling"" (reading) the data from the AudioRecord object. The
 application is responsible for polling the AudioRecord object in time using one of
 the following three methods:   read(byte[] int int)   read(short[] int int) 
 or  read(java.nio.ByteBuffer int) . The choice of which method to use will be based
 on the audio data storage format that is the most convenient for the user of AudioRecord.
  Upon creation an AudioRecord object initializes its associated audio buffer that it will
 fill with the new audio data. The size of this buffer specified during the construction
 determines how long an AudioRecord can record before ""over-running"" data that has not
 been read yet. Data should be read from the audio hardware in chunks of sizes inferior to
 the total recording buffer size."
android,media,AudioRecord.Builder,5,"Builder class for  AudioRecord  objects.
 Use this class to configure and create an  AudioRecord  instance. By setting the
 recording source and audio format parameters you indicate which of
 those vary from the default behavior on the device.
   Here is an example where  Builder  is used to specify all  AudioFormat 
 parameters to be used by a new  AudioRecord  instance:

  
 AudioRecord recorder = new AudioRecord.Builder()
         .setAudioSource(MediaRecorder.AudioSource.VOICE_COMMUNICATION)
         .setAudioFormat(new AudioFormat.Builder()
                 .setEncoding(AudioFormat.ENCODING_PCM_16BIT)
                 .setSampleRate(32000)
                 .setChannelMask(AudioFormat.CHANNEL_IN_MONO)
                 .build())
         .setBufferSizeInBytes(2*minBuffSize)
         .build();
  
 If the audio source is not set with  setAudioSource(int) 
  MediaRecorder.AudioSource#DEFAULT  is used.
  If the audio format is not specified or is incomplete its channel configuration will be
  AudioFormat#CHANNEL_IN_MONO  and the encoding will be
  AudioFormat#ENCODING_PCM_16BIT .
 The sample rate will depend on the device actually selected for capture and can be queried
 with  AudioRecord.getSampleRate()  method.
  If the buffer size is not specified with  setBufferSizeInBytes(int) 
 the minimum buffer size for the source is used."
android,media,AudioRecord.MetricsConstants,0,
android,media,CameraProfile,2,"The CameraProfile class is used to retrieve the pre-defined still image
 capture (jpeg) quality levels (0-100) used for low medium and high
 quality settings in the Camera application."
android,media,FaceDetector,2,"Identifies the faces of people in a
  Bitmap  graphic object."
android,media,MediaCodec.BufferInfo,1,"Per buffer metadata includes an offset and size specifying
 the range of valid data in the associated codec (output) buffer."
android,media,MediaCodec.Callback,4,"MediaCodec callback interface. Used to notify the user asynchronously
 of various MediaCodec events."
android,media,MediaCodec.CryptoInfo.Pattern,3,"Metadata describing an encryption pattern for the protected bytes in a subsample.  An
 encryption pattern consists of a repeating sequence of crypto blocks comprised of a
 number of encrypted blocks followed by a number of unencrypted or skipped blocks."
android,media,MediaCodec.MetricsConstants,0,
android,media,MediaController2.Builder,3,"This API is not generally intended for third party application developers.
 Use the  AndroidX Media2 session
 Library  for consistent behavior across all devices.
  
 Builder for  MediaController2 .
  
 Any incoming event from the  MediaSession2  will be handled on the callback
 executor. If it's not set  Context#getMainExecutor()  will be used by default."
android,media,MediaCrypto,5,"MediaCrypto class can be used in conjunction with  MediaCodec 
 to decode encrypted media data.

 Crypto schemes are assigned 16 byte UUIDs
 the method  isCryptoSchemeSupported(UUID)  can be used to query if a given
 scheme is supported on the device."
android,media,MediaDataSource,2,"For supplying media data to the framework. Implement this if your app has
 special requirements for the way media data is obtained.

  Methods of this interface may be called on multiple different
 threads. There will be a thread synchronization point between each call to ensure that
 modifications to the state of your MediaDataSource are visible to future calls. This means
 you don't need to do your own synchronization unless you're modifying the
 MediaDataSource from another thread while it's being used by the framework."
android,media,MediaDescrambler,5,"MediaDescrambler class can be used in conjunction with  MediaCodec 
 and  MediaExtractor  to decode media data scrambled by conditional
 access (CA) systems such as those in the ISO/IEC13818-1.

 A MediaDescrambler object is initialized from a session opened by a MediaCas object
 and can be used to descramble media streams scrambled with that session's keys.

 Scrambling schemes are identified by 16-bit unsigned integer as in CA_system_id."
android,media,MediaDescription,12,"A simple set of metadata for a media item suitable for display. This can be
 created using the Builder or retrieved from existing metadata using
  MediaMetadata#getDescription() ."
android,media,MediaExtractor.CasInfo,3,Describes the conditional access system used to scramble a track.
android,media,MediaMetadata,13,Contains metadata about an item such as the title artist etc.
android,media,MediaMuxer,8,"MediaMuxer facilitates muxing elementary streams. Currently MediaMuxer supports MP4 Webm
 and 3GP file as the output. It also supports muxing B-frames in MP4 since Android Nougat.
  
 It is generally used like this:

  
 MediaMuxer muxer = new MediaMuxer(""temp.mp4"" OutputFormat.MUXER_OUTPUT_MPEG_4);
 // More often the MediaFormat will be retrieved from MediaCodec.getOutputFormat()
 // or MediaExtractor.getTrackFormat().
 MediaFormat audioFormat = new MediaFormat(...);
 MediaFormat videoFormat = new MediaFormat(...);
 int audioTrackIndex = muxer.addTrack(audioFormat);
 int videoTrackIndex = muxer.addTrack(videoFormat);
 ByteBuffer inputBuffer = ByteBuffer.allocate(bufferSize);
 boolean finished = false;
 BufferInfo bufferInfo = new BufferInfo();

 muxer.start();
 while(!finished) {
   // getInputBuffer() will fill the inputBuffer with one frame of encoded
   // sample from either MediaCodec or MediaExtractor set isAudioSample to
   // true when the sample is audio data set up all the fields of bufferInfo
   // and return true if there are no more samples.
   finished = getInputBuffer(inputBuffer isAudioSample bufferInfo);
   if (!finished) {
     int currentTrackIndex = isAudioSample ? audioTrackIndex : videoTrackIndex;
     muxer.writeSampleData(currentTrackIndex inputBuffer bufferInfo);
   }
 };
 muxer.stop();
 muxer.release();
  Metadata Track 
  Per-frame metadata is useful in carrying extra information that correlated with video or audio to
  facilitate offline processing e.g. gyro signals from the sensor could help video stabilization when
  doing offline processing. Metadata track is only supported in MP4 container. When adding a new
  metadata track track's mime format must start with prefix ""application/"" e.g. ""applicaton/gyro"".
  Metadata's format/layout will be defined by the application. Writing metadata is nearly the same as
  writing video/audio data except that the data will not be from mediacodec. Application just needs
  to pass the bytebuffer that contains the metadata and also the associated timestamp to the
   writeSampleData(int ByteBuffer MediaCodec.BufferInfo)  api. The timestamp must be in the same time base as video and audio. The
  generated MP4 file uses TextMetaDataSampleEntry defined in section 12.3.3.2 of the ISOBMFF to signal
  the metadata's mime format. When using MediaExtractor  to extract the file with
  metadata track the mime format of the metadata will be extracted into  MediaFormat .
 
  
   MediaMuxer muxer = new MediaMuxer(""temp.mp4"" OutputFormat.MUXER_OUTPUT_MPEG_4);
   // SetUp Video/Audio Tracks.
   MediaFormat audioFormat = new MediaFormat(...);
   MediaFormat videoFormat = new MediaFormat(...);
   int audioTrackIndex = muxer.addTrack(audioFormat);
   int videoTrackIndex = muxer.addTrack(videoFormat);
 
   // Setup Metadata Track
   MediaFormat metadataFormat = new MediaFormat(...);
   metadataFormat.setString(KEY_MIME ""application/gyro"");
   int metadataTrackIndex = muxer.addTrack(metadataFormat);
 
   muxer.start();
   while(..) {
       // Allocate bytebuffer and write gyro data(xyz) into it.
       ByteBuffer metaData = ByteBuffer.allocate(bufferSize);
       metaData.putFloat(x);
       metaData.putFloat(y);
       metaData.putFloat(z);
       BufferInfo metaInfo = new BufferInfo();
       // Associate this metadata with the video frame by setting
       // the same timestamp as the video frame.
       metaInfo.presentationTimeUs = currentVideoTrackTimeUs;
       metaInfo.offset = 0;
       metaInfo.flags = 0;
       metaInfo.size = bufferSize;
       muxer.writeSampleData(metadataTrackIndex metaData metaInfo);
   };
   muxer.stop();
   muxer.release();
 }"
android,media,MediaSession2.Builder,5,"This API is not generally intended for third party application developers.
 Use the  AndroidX Media2 session
 Library  for consistent behavior across all devices.
  
 Builder for  MediaSession2 .
  
 Any incoming event from the  MediaController2  will be handled on the callback
 executor. If it's not set  Context#getMainExecutor()  will be used by default."
android,media,MediaSession2.SessionCallback,5,"This API is not generally intended for third party application developers.
 Use the  AndroidX Media2 session
 Library  for consistent behavior across all devices.
  
 Callback to be called for all incoming commands from  MediaController2 s."
android,media,PlaybackParams,9,"Structure for common playback params.

 Used by  AudioTrack AudioTrack#getPlaybackParams()  and
  AudioTrack#setPlaybackParams(PlaybackParams) 
 to control playback behavior.
  audio fallback mode: 
 select out-of-range parameter handling.
  PlaybackParams#AUDIO_FALLBACK_MODE_DEFAULT :
   System will determine best handling.  PlaybackParams#AUDIO_FALLBACK_MODE_MUTE :
   Play silence for params normally out of range. PlaybackParams#AUDIO_FALLBACK_MODE_FAIL :
   Return  IllegalArgumentException  from
    AudioTrack.setPlaybackParams(PlaybackParams) . pitch:  increases or decreases the tonal frequency of the audio content.
 It is expressed as a multiplicative factor where normal pitch is 1.0f.
  speed:  increases or decreases the time to
 play back a set of audio or video frames.
 It is expressed as a multiplicative factor where normal speed is 1.0f.
   Different combinations of speed and pitch may be used for audio playback;
 some common ones:
  Pitch equals 1.0f.  Speed change will be done with pitch preserved
 often called  timestretching . Pitch equals speed.  Speed change will be done by  resampling 
 similar to  AudioTrack#setPlaybackRate(int) ."
android,media,RemoteControlClient.MetadataEditor,6,"Class used to modify metadata in a  RemoteControlClient  object.
 Use  RemoteControlClient#editMetadata(boolean)  to create an instance of an editor
 on which you set the metadata for the RemoteControlClient instance. Once all the information
 has been set use  apply()  to make it the new metadata that should be displayed
 for the associated client. Once the metadata has been ""applied"" you cannot reuse this
 instance of the MetadataEditor."
android,media,Session2Command,7,"This API is not generally intended for third party application developers.
 Use the  AndroidX Media2 session
 Library  for consistent behavior across all devices.
  
 Define a command that a  MediaController2  can send to a  MediaSession2 .
  
 If  getCommandCode()  isn't  COMMAND_CODE_CUSTOM ) it's predefined command.
 If  getCommandCode()  is  COMMAND_CODE_CUSTOM ) it's custom command and
  getCustomAction()  shouldn't be  null .
  
 Refer to the
  AndroidX SessionCommand 
 class for the list of valid commands."
android,media,Session2Command.Result,2,"This API is not generally intended for third party application developers.
 Use the  AndroidX Media2 session
 Library  for consistent behavior across all devices.
  
 Contains the result of  Session2Command ."
android,media,SyncParams,9,"Structure for common A/V sync params.

 Used by  MediaSync  {link MediaSync#getSyncParams()} and
 {link MediaSync#setSyncParams(SyncParams)}
 to control A/V sync behavior.
  audio adjust mode: 
 select handling of audio track when changing playback speed due to sync.
  SyncParams#AUDIO_ADJUST_MODE_DEFAULT :
   System will determine best handling.  SyncParams#AUDIO_ADJUST_MODE_STRETCH :
   Change the speed of audio playback without altering its pitch. SyncParams#AUDIO_ADJUST_MODE_RESAMPLE :
   Change the speed of audio playback by resampling the audio. sync source:  select
 clock source for sync.
  SyncParams#SYNC_SOURCE_DEFAULT :
   System will determine best selection. SyncParams#SYNC_SOURCE_SYSTEM_CLOCK :
   Use system clock for sync source. SyncParams#SYNC_SOURCE_AUDIO :
   Use audio track for sync source. SyncParams#SYNC_SOURCE_VSYNC :
   Syncronize media to vsync. tolerance:  specifies the amount of allowed playback rate
 change to keep media in sync with the sync source. The handling of this depends
 on the sync source but must not be negative and must be less than one.
  frameRate:  initial hint for video frame rate. Used when
 sync source is vsync. Negative values can be used to clear a previous hint."
android,media,ThumbnailUtils,8,Utilities for generating visual thumbnails from files.
android,media,VolumeShaper,5,"The  VolumeShaper  class is used to automatically control audio volume during media
 playback allowing simple implementation of transition effects and ducking.
 It is created from implementations of  VolumeAutomation 
 such as  MediaPlayer  and  AudioTrack  (referred to as ""players"" below)
 by  MediaPlayer#createVolumeShaper  or  AudioTrack#createVolumeShaper .

 A  VolumeShaper  is intended for short volume changes.
 If the audio output sink changes during
 a  VolumeShaper  transition the precise curve position may be lost and the
  VolumeShaper  may advance to the end of the curve for the new audio output sink.

 The  VolumeShaper  appears as an additional scaling on the audio output
 and adjusts independently of track or stream volume controls."
android,media,VolumeShaper.Configuration,10,"The  VolumeShaper.Configuration  class contains curve
 and duration information.
 It is constructed by the  VolumeShaper.Configuration.Builder .
  
 A  VolumeShaper.Configuration  is used by
  VolumeAutomation#createVolumeShaper(Configuration)  to create
 a  VolumeShaper  and
 by  VolumeShaper#replace(Configuration Operation boolean) 
 to replace an existing  configuration .
  
 The  AudioTrack  and  MediaPlayer  classes implement
 the  VolumeAutomation  interface."
android,media,AudioManager.AudioPlaybackCallback,1,"Interface for receiving update notifications about the playback activity on the system.
 Extend this abstract class and register it with
  AudioManager#registerAudioPlaybackCallback(AudioPlaybackCallback Handler) 
 to be notified.
 Use  AudioManager#getActivePlaybackConfigurations()  to query the current
 configuration."
android,media,AudioPresentation,11,"The AudioPresentation class encapsulates the information that describes an audio presentation
 which is available in next generation audio content.

 Used by  MediaExtractor MediaExtractor#getAudioPresentations(int)  and
  AudioTrack AudioTrack#setPresentation(AudioPresentation)  to query available
 presentations and to select one respectively.

 A list of available audio presentations in a media source can be queried using
  MediaExtractor#getAudioPresentations(int) . This list can be presented to a user for
 selection.
 An AudioPresentation can be passed to an offloaded audio decoder via
  AudioTrack#setPresentation(AudioPresentation)  to request decoding of the selected
 presentation. An audio stream may contain multiple presentations that differ by language
 accessibility end point mastering and dialogue enhancement. An audio presentation may also have
 a set of description labels in different languages to help the user to make an informed
 selection.

 Applications that parse media streams and extract presentation information on their own
 can create instances of AudioPresentation by using  AudioPresentation.Builder  class."
android,media,AudioRecordingConfiguration,13,"The AudioRecordingConfiguration class collects the information describing an audio recording
 session.
  Direct polling (see  AudioManager#getActiveRecordingConfigurations() ) or callback
 (see  AudioManager#registerAudioRecordingCallback(android.media.AudioManager.AudioRecordingCallback android.os.Handler) 
 methods are ways to receive information about the current recording configuration of the device.
  An audio recording configuration contains information about the recording format as used by
 the application ( getClientFormat()  as well as the recording format actually used by
 the device ( getFormat() ). The two recording formats may for instance be at different
 sampling rates due to hardware limitations (e.g. application recording at 44.1kHz whereas the
 device always records at 48kHz and the Android framework resamples for the application).
  The configuration also contains the use case for which audio is recorded
 ( getClientAudioSource() ) enabling the ability to distinguish between different
 activities such as ongoing voice recognition or camcorder recording."
android,media,AudioTrack,71,"The AudioTrack class manages and plays a single audio resource for Java applications.
 It allows streaming of PCM audio buffers to the audio sink for playback. This is
 achieved by ""pushing"" the data to the AudioTrack object using one of the
   write(byte[] int int)   write(short[] int int) 
  and  write(float[] int int int)  methods.

  An AudioTrack instance can operate under two modes: static or streaming. 
 In Streaming mode the application writes a continuous stream of data to the AudioTrack using
 one of the  write()  methods. These are blocking and return when the data has been
 transferred from the Java layer to the native layer and queued for playback. The streaming
 mode is most useful when playing blocks of audio data that for instance are:

  too big to fit in memory because of the duration of the sound to play too big to fit in memory because of the characteristics of the audio data
         (high sampling rate bits per sample ...) received or generated while previously queued audio is playing. Upon creation an AudioTrack object initializes its associated audio buffer.
 The size of this buffer specified during the construction determines how long an AudioTrack
 can play before running out of data. 
 For an AudioTrack using the static mode this size is the maximum size of the sound that can
 be played from it. 
 For the streaming mode data will be written to the audio sink in chunks of
 sizes less than or equal to the total buffer size.

 AudioTrack is not final and thus permits subclasses but such use is not recommended."
android,media,AudioTrack.MetricsConstants,0,
android,media,CamcorderProfile,4,"Retrieves the
 predefined camcorder profile settings for camcorder applications.
 These settings are read-only.

  The compressed output from a recording session with a given
 CamcorderProfile contains two tracks: one for audio and one for video.

  Each profile specifies the following set of parameters:
   The file output format
   Video codec format
   Video bit rate in bits per second
   Video frame rate in frames per second
   Video frame width and height
   Audio codec format
   Audio bit rate in bits per second
   Audio sample rate
   Number of audio channels for recording."
android,media,DrmInitData,1,Encapsulates initialization data required by a  MediaDrm  instance.
android,media,Image,10,"A single complete image buffer to use with a media source such as a
  MediaCodec  or a
  CameraDevice . This class allows for efficient direct application access to the pixel
 data of the Image through one or more
  ByteBuffers . Each buffer is encapsulated in a
  Plane  that describes the layout of the pixel data in that plane. Due
 to this direct access and unlike the  Bitmap  class
 Images are not directly usable as UI resources. Since Images are often directly produced or consumed by hardware
 components they are a limited resource shared across the system and should
 be closed as soon as they are no longer needed. For example when using the  ImageReader  class to read out Images
 from various media sources not closing old Image objects will prevent the
 availability of new Images once
  ImageReader#getMaxImages  is
 reached. When this happens the function acquiring new Images will typically
 throw an  IllegalStateException ."
android,media,JetPlayer,19,"JetPlayer provides access to JET content playback and control.

  Please refer to the JET Creator User Manual for a presentation of the JET interactive
 music concept and how to use the JetCreator tool to create content to be player by JetPlayer.

  Use of the JetPlayer class is based around the playback of a number of JET segments
 sequentially added to a playback FIFO queue. The rendering of the MIDI content stored in each
 segment can be dynamically affected by two mechanisms:
  tracks in a segment can be muted or unmuted at any moment individually or through
    a mask (to change the mute state of multiple tracks at once) parts of tracks in a segment can be played at predefined points in the segment in order
    to maintain synchronization with the other tracks in the segment. This is achieved through
    the notion of ""clips"" which can be triggered at any time but that will play only at the
    right time as authored in the corresponding JET file. the playback state the number of segments left to play in the queue application controller events (CC80-83) to mark points in the MIDI segments. getJetPlayer()"
android,media,MediaRecorder.VideoEncoder,0,"Defines the video encoding. These constants are used with
  MediaRecorder#setVideoEncoder(int) ."
android,media,MediaSession2Service,8,"This API is not generally intended for third party application developers.
 Use the  AndroidX Media2 session
 Library  for consistent behavior across all devices.
  
 Service containing  MediaSession2 ."
android,media,AudioAttributes,11,"A class to encapsulate a collection of attributes describing information about an audio
 stream.
  AudioAttributes  supersede the notion of stream types (see for instance
  AudioManager#STREAM_MUSIC  or  AudioManager#STREAM_ALARM ) for defining the
 behavior of audio playback. Attributes allow an application to specify more information than is
 conveyed in a stream type by allowing the application to define:
  usage: ""why"" you are playing a sound what is this sound used for. This is achieved with
     the ""usage"" information. Examples of usage are  USAGE_MEDIA  and  USAGE_ALARM .
     These two examples are the closest to stream types but more detailed use cases are
     available. Usage information is more expressive than a stream type and allows certain
     platforms or routing policies to use this information for more refined volume or routing
     decisions. Usage is the most important information to supply in  AudioAttributes 
     and it is recommended to build any instance with this information supplied see
      AudioAttributes.Builder  for exceptions. content type: ""what"" you are playing. The content type expresses the general category of
     the content. This information is optional. But in case it is known (for instance
      CONTENT_TYPE_MOVIE  for a movie streaming service or  CONTENT_TYPE_MUSIC  for
     a music playback application) this information might be used by the audio framework to
     selectively configure some audio post-processing blocks. flags: ""how"" is playback to be affected see the flag definitions for the specific playback
     behaviors they control.  AudioAttributes  are used for example in one of the  AudioTrack 
 constructors (see  AudioTrack#AudioTrack(AudioAttributes AudioFormat int int int) )
 to configure a  MediaPlayer 
 (see  MediaPlayer#setAudioAttributes(AudioAttributes)  or a
  Notification  (see  Notification.audioAttributes ). An
  AudioAttributes  instance is built through its builder
  AudioAttributes.Builder ."
android,media,AudioFormat.Builder,5,"Builder class for  AudioFormat  objects.
 Use this class to configure and create an AudioFormat instance. By setting format
 characteristics such as audio encoding channel mask or sample rate you indicate which
 of those are to vary from the default behavior on this device wherever this audio format
 is used. See  AudioFormat  for a complete description of the different parameters that
 can be used to configure an  AudioFormat  instance.
  AudioFormat  is for instance used in
  AudioTrack#AudioTrack(AudioAttributes AudioFormat int int int) . In this
 constructor every format characteristic set on the  Builder  (e.g. with
  setSampleRate(int) ) will alter the default values used by an
  AudioTrack . In this case for audio playback with  AudioTrack  the
 sample rate set in the  Builder  would override the platform output sample rate
 which would otherwise be selected by default."
android,media,MediaExtractor,29,"MediaExtractor facilitates extraction of demuxed typically encoded  media data
 from a data source.
  It is generally used like this:
  
 MediaExtractor extractor = new MediaExtractor();
 extractor.setDataSource(...);
 int numTracks = extractor.getTrackCount();
 for (int i = 0; i < numTracks; ++i) {
   MediaFormat format = extractor.getTrackFormat(i);
   String mime = format.getString(MediaFormat.KEY_MIME);
   if (weAreInterestedInThisTrack) {
     extractor.selectTrack(i);
   }
 }
 ByteBuffer inputBuffer = ByteBuffer.allocate(...)
 while (extractor.readSampleData(inputBuffer ...) >= 0) {
   int trackIndex = extractor.getSampleTrackIndex();
   long presentationTimeUs = extractor.getSampleTime();
   ...
   extractor.advance();
 }

 extractor.release();
 extractor = null;
  This class requires the  Manifest.permission.INTERNET  permission
 when used with network-based content."
android,media,MediaMetadata.Builder,6,"Use to build MediaMetadata objects. The system defined metadata keys must
 use the appropriate data type."
android,media,MediaMetadataEditor,13,"An abstract class for editing and storing metadata that can be published by
  RemoteControlClient . See the  RemoteControlClient#editMetadata(boolean) 
 method to instantiate a  RemoteControlClient.MetadataEditor  object."
android,media,MediaRecorder,51,"Used to record audio and video. The recording control is based on a
 simple state machine (see below).

  A common case of using MediaRecorder to record audio works as follows:

  MediaRecorder recorder = new MediaRecorder();
 recorder.setAudioSource(MediaRecorder.AudioSource.MIC);
 recorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP);
 recorder.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB);
 recorder.setOutputFile(PATH_NAME);
 recorder.prepare();
 recorder.start();   // Recording is now started
 ...
 recorder.stop();
 recorder.reset();   // You can reuse the object by going back to setAudioSource() step
 recorder.release(); // Now the object cannot be reused
  Applications may want to register for informational and error
 events in order to be informed of some internal update and possible
 runtime errors during recording. Registration for such events is
 done by setting the appropriate listeners (via calls
 (to  setOnInfoListener(android.media.MediaRecorder.OnInfoListener) setOnInfoListener and/or
  setOnErrorListener(android.media.MediaRecorder.OnErrorListener) setOnErrorListener).
 In order to receive the respective callback associated with these listeners
 applications are required to create MediaRecorder objects on threads with a
 Looper running (the main UI thread by default already has a Looper running).

  Note:  Currently MediaRecorder does not work on the emulator."
android,media,MediaRecorder.AudioSource,0,"Defines the audio source.
 An audio source defines both a default physical source of audio signal and a recording
 configuration. These constants are for instance used
 in  MediaRecorder#setAudioSource(int)  or
  AudioRecord.Builder#setAudioSource(int) ."
android,media,MediaRecorder.MetricsConstants,0,
android,media,MediaRecorder.OutputFormat,0,"Defines the output format. These constants are used with
  MediaRecorder#setOutputFormat(int) ."
android,media,MediaRouter,16,"MediaRouter allows applications to control the routing of media channels
 and streams from the current device to external speakers and destination devices.

  A MediaRouter is retrieved through  Context#getSystemService(String)  of a  Context#MEDIA_ROUTER_SERVICE .

  The media router API is not thread-safe; all interactions with it must be
 done from the main thread of the process."
android,media,RemoteControlClient,8,"RemoteControlClient enables exposing information meant to be consumed by remote controls
 capable of displaying metadata artwork and media transport control buttons.

  A remote control client object is associated with a media button event receiver. This
 event receiver must have been previously registered with
  AudioManager#registerMediaButtonEventReceiver(ComponentName)  before the
 RemoteControlClient can be registered through
  AudioManager#registerRemoteControlClient(RemoteControlClient) .

  Here is an example of creating a RemoteControlClient instance after registering a media
 button event receiver:
  ComponentName myEventReceiver = new ComponentName(getPackageName() MyRemoteControlEventReceiver.class.getName());
 AudioManager myAudioManager = (AudioManager) getSystemService(Context.AUDIO_SERVICE);
 myAudioManager.registerMediaButtonEventReceiver(myEventReceiver);
 // build the PendingIntent for the remote control client
 Intent mediaButtonIntent = new Intent(Intent.ACTION_MEDIA_BUTTON);
 mediaButtonIntent.setComponent(myEventReceiver);
 PendingIntent mediaPendingIntent = PendingIntent.getBroadcast(getApplicationContext() 0 mediaButtonIntent 0);
 // create and register the remote control client
 RemoteControlClient myRemoteControlClient = new RemoteControlClient(mediaPendingIntent);
 myAudioManager.registerRemoteControlClient(myRemoteControlClient);"
android,media,VolumeShaper.Operation,5,"The  VolumeShaper.Operation  class is used to specify operations
 to the  VolumeShaper  that affect the volume change."
android,media,Session2CommandGroup.Builder,3,"This API is not generally intended for third party application developers.
 Use the  AndroidX Media2 session
 Library  for consistent behavior across all devices.
  
 Builds a  Session2CommandGroup  object."
android,media,TimedMetaData,2,"Class that embodies one timed metadata access unit including

   a time stamp and   raw uninterpreted byte-array extracted directly from the container."
android,media,TimedText,2,"Class to hold the timed text's metadata including:
   The characters for rendering  The rendering position for the timed text  To render the timed text applications need to do the following:

   Implement the  MediaPlayer.OnTimedTextListener  interface  Register the  MediaPlayer.OnTimedTextListener  callback on a MediaPlayer object that is used for playback  When a onTimedText callback is received do the following:
   call  getText()  to get the characters for rendering  call  getBounds()  to get the text rendering area/region"
android,sax,Element,10,"An XML element. Provides access to child elements and hooks to listen
 for events related to this element."
android,sax,RootElement,1,"The root XML element. The entry point for this API. Not safe for concurrent
 use.

  For example passing this XML:

  
 <feed xmlns='http://www.w3.org/2005/Atom'>
   <entry>
     <id>bob</id>
   </entry>
 </feed>
  
 static final String ATOM_NAMESPACE = ""http://www.w3.org/2005/Atom"";

 ...

 RootElement root = new RootElement(ATOM_NAMESPACE ""feed"");
 Element entry = root.getChild(ATOM_NAMESPACE ""entry"");
 entry.getChild(ATOM_NAMESPACE ""id"").setEndTextElementListener(
   new EndTextElementListener() {
     public void end(String body) {
       System.out.println(""Entry ID: "" + body);
     }
   });

 XMLReader reader = ...;
 reader.setContentHandler(root.getContentHandler());
 reader.parse(...);
  
 Entry ID: bob"
android,print,PageRange,7,"Represents a range of pages. The start and end page indices of
 the range are zero based and inclusive."
android,print,PrintAttributes.MediaSize,10,"This class specifies a supported media size. Media size is the
 dimension of the media on which the content is printed. For
 example the  NA_LETTER  media size designates a page
 with size 8.5"" x 11""."
android,print,PrintAttributes.Resolution,7,"This class specifies a supported resolution in DPI (dots per inch).
 Resolution defines how many points with different color can be placed
 on one inch in horizontal or vertical direction of the target media.
 For example a printer with 600 DPI can produce higher quality images
 the one with 300 DPI resolution."
android,print,PrintDocumentAdapter,4,"Base class that provides the content of a document to be printed.

  Lifecycle 
 Initially you will receive a call to  onStart() . This callback
 can be used to allocate resources.
  
 Next you will get one or more calls to  onLayout(android.print.PrintAttributes android.print.PrintAttributes android.os.CancellationSignal android.print.PrintDocumentAdapter.LayoutResultCallback android.os.Bundle)  to
 inform you that the print attributes (page size density etc) changed
 giving you an opportunity to layout the content to match the new constraints.
  
 After every call to  onLayout(android.print.PrintAttributes android.print.PrintAttributes android.os.CancellationSignal android.print.PrintDocumentAdapter.LayoutResultCallback android.os.Bundle)  you  may  get
 a call to  onWrite(android.print.PageRange[] android.os.ParcelFileDescriptor android.os.CancellationSignal android.print.PrintDocumentAdapter.WriteResultCallback)  asking you to write a PDF file with the content for
 specific pages.
  
 Finally you will receive a call to  onFinish() . You can use this
 callback to release resources allocated in  onStart() .
  
 The  onStart()  callback is always the first call you will receive and
 is useful for doing one time setup or resource allocation before printing. You
 will not receive a subsequent call here.
  
 The  onLayout(android.print.PrintAttributes android.print.PrintAttributes android.os.CancellationSignal android.print.PrintDocumentAdapter.LayoutResultCallback android.os.Bundle)  callback requires that you layout the content
 based on the current  PrintAttributes . The execution of this method is
 not considered completed until you invoke one of the methods on the passed in
 callback instance. Hence you will not receive a subsequent call to any other
 method of this class until the execution of this method is complete by invoking
 one of the callback methods.
  
 The  onWrite(android.print.PageRange[] android.os.ParcelFileDescriptor android.os.CancellationSignal android.print.PrintDocumentAdapter.WriteResultCallback)  requires that you render and write the content of some
 pages to the provided destination. The execution of this method is not
 considered complete until you invoke one of the methods on the passed in
 callback instance. Hence you will not receive a subsequent call to any other
 method of this class until the execution of this method is complete by invoking
 one of the callback methods. You will never receive a sequence of one or more
 calls to this method without a previous call to  onLayout(android.print.PrintAttributes android.print.PrintAttributes android.os.CancellationSignal android.print.PrintDocumentAdapter.LayoutResultCallback android.os.Bundle) .
  
 The  onFinish()  callback is always the last call you will receive and
 is useful for doing one time cleanup or resource deallocation after printing.
 You will not receive a subsequent call here.
  Implementation 
 The APIs defined in this class are designed to enable doing part or all
 of the work on an arbitrary thread. For example if the printed content
 does not depend on the UI state i.e. on what is shown on the screen then
 you can offload the entire work on a dedicated thread thus making your
 application interactive while the print work is being performed. Note that
 while your activity is covered by the system print UI and a user cannot
 interact with it doing the printing work on the main application thread
 may affect the performance of your other application components as they
 are also executed on that thread.
  
 You can also do work on different threads for example if you print UI
 content you can handle  onStart()  and  onLayout(android.print.PrintAttributes android.print.PrintAttributes android.os.CancellationSignal android.print.PrintDocumentAdapter.LayoutResultCallback android.os.Bundle)  on
 the UI thread (assuming onStart initializes resources needed for layout).
 This will ensure that the UI does not change while you are laying out the
 printed content. Then you can handle  onWrite(android.print.PageRange[] android.os.ParcelFileDescriptor android.os.CancellationSignal android.print.PrintDocumentAdapter.WriteResultCallback)  and  onFinish()  on another
 thread. This will ensure that the main thread is busy for a minimal amount of
 time. Also this assumes that you will generate the printed content in
  onLayout(android.print.PrintAttributes android.print.PrintAttributes android.os.CancellationSignal android.print.PrintDocumentAdapter.LayoutResultCallback android.os.Bundle)  which is not mandatory. If you use multiple
 threads you are responsible for proper synchronization."
android,print,PrintDocumentAdapter.LayoutResultCallback,3,"Base class for implementing a callback for the result of  PrintDocumentAdapter#onLayout(PrintAttributes PrintAttributes
 CancellationSignal LayoutResultCallback Bundle) ."
android,print,PrintDocumentAdapter.WriteResultCallback,3,"Base class for implementing a callback for the result of  PrintDocumentAdapter#onWrite(PageRange[] ParcelFileDescriptor CancellationSignal
 WriteResultCallback) ."
android,print,PrintDocumentInfo,9,"This class encapsulates information about a document for printing
 purposes. This meta-data is used by the platform and print services
 components that interact with printers. For example this class
 contains the number of pages contained in the document it describes and
 this number of pages is shown to the user allowing him/her to select
 the range to print. Also a print service may optimize the printing
 process based on the content type such as document or photo.
  
 Instances of this class are created by the printing application and
 passed to the  PrintDocumentAdapter.LayoutResultCallback#onLayoutFinished(
 PrintDocumentInfo boolean)  callback after successfully laying out the
 content which is performed in  PrintDocumentAdapter#onLayout(PrintAttributes
 PrintAttributes android.os.CancellationSignal PrintDocumentAdapter.LayoutResultCallback
 android.os.Bundle) .
  
 An example usage looks like this:
  

 . . .

 public void onLayout(PrintAttributes oldAttributes PrintAttributes newAttributes
         CancellationSignal cancellationSignal LayoutResultCallback callback
         Bundle metadata) {

        // Assume the app defined a LayoutResult class which contains
        // the layout result data and that the content is a document.
        LayoutResult result = doSomeLayoutWork();

        PrintDocumentInfo info = new PrintDocumentInfo
                .Builder(""printed_file.pdf"")
                .setContentType(PrintDocumentInfo.CONTENT_TYPE_DOCUMENT)
                .setPageCount(result.getPageCount())
                .build();

       callback.onLayoutFinished(info result.getContentChanged());
   }

   . . ."
android,print,PrintDocumentInfo.Builder,3,Builder for creating a  PrintDocumentInfo .
android,print,PrinterInfo,10,"This class represents the description of a printer. Instances of
 this class are created by print services to report to the system
 the printers they manage. The information of this class has two
 major components printer properties such as name id status
 description and printer capabilities which describe the various
 print modes a printer supports such as media sizes margins etc.
  
 Once  PrinterInfo.Builder#build()  the objects are immutable."
android,print,PrintJobInfo.Builder,6,Builder for creating a  PrintJobInfo .
android,print,PrintManager,2,"System level service for accessing the printing capabilities of the platform.

  Print mechanics 
 The key idea behind printing on the platform is that the content to be printed
 should be laid out for the currently selected print options resulting in an
 optimized output and higher user satisfaction. To achieve this goal the platform
 declares a contract that the printing application has to follow which is defined
 by the  PrintDocumentAdapter  class. At a higher level the contract is that
 when the user selects some options from the print UI that may affect the way
 content is laid out for example page size the application receives a callback
 allowing it to layout the content to better fit these new constraints. After a
 layout pass the system may ask the application to render one or more pages one
 or more times. For example an application may produce a single column list for
 smaller page sizes and a multi-column table for larger page sizes.
  Print jobs 
 Print jobs are started by calling the  print(java.lang.String android.print.PrintDocumentAdapter android.print.PrintAttributes)  from an activity which results in bringing up the system print
 UI. Once the print UI is up when the user changes a selected print option that
 affects the way content is laid out the system starts to interact with the
 application following the mechanics described the section above.
  
 Print jobs can be in  PrintJobInfo#STATE_CREATED   PrintJobInfo#STATE_QUEUED   PrintJobInfo#STATE_STARTED 
  PrintJobInfo#STATE_BLOCKED   PrintJobInfo#STATE_COMPLETED   PrintJobInfo#STATE_FAILED  and  PrintJobInfo#STATE_CANCELED  state. Print jobs are stored in dedicated
 system spooler until they are handled which is they are cancelled or completed.
 Active print jobs ones that are not cancelled or completed are considered failed
 if the device reboots as the new boot may be after a very long time. The user may
 choose to restart such print jobs. Once a print job is queued all relevant content
 is stored in the system spooler and its lifecycle becomes detached from this of
 the application that created it.
  
 An applications can query the print spooler for current print jobs it created
 but not print jobs created by other applications.
  PackageManager#FEATURE_PRINTING PackageManager.hasSystemFeature(String)"
android,print,PrintAttributes,10,"This class represents the attributes of a print job. These attributes
 describe how the printed content should be laid out. For example the
 print attributes may state that the content should be laid out on a
 letter size with 300 DPI (dots per inch) resolution have a margin of
 10 mills (thousand of an inch) on all sides and be black and white."
android,print,PrintAttributes.Builder,6,Builder for creating  PrintAttributes .
android,print,PrintAttributes.Margins,7,"This class specifies content margins. Margins define the white space
 around the content where the left margin defines the amount of white
 space on the left of the content and so on."
android,print,PrinterCapabilitiesInfo,11,"This class represents the capabilities of a printer. Instances
 of this class are created by a print service to report the
 capabilities of a printer it manages. The capabilities of a
 printer specify how it can print content. For example what
 are the media sizes supported by the printer what are the
 minimal margins of the printer based on its technical design
 etc."
android,print,PrinterCapabilitiesInfo.Builder,6,"Builder for creating of a  PrinterCapabilitiesInfo . This class is
 responsible to enforce that all required attributes have at least one
 default value. In other words this class creates only well-formed  PrinterCapabilitiesInfo s.
  
 Look at the individual methods for a reference whether a property is
 required or if it is optional."
android,print,PrinterId,6,This class represents the unique id of a printer.
android,print,PrinterInfo.Builder,8,Builder for creating of a  PrinterInfo .
android,print,PrintJob,12,"This class represents a print job from the perspective of an
 application. It contains behavior methods for performing operations
 on it as well as methods for querying its state. A snapshot of the
 print job state is represented by the  PrintJobInfo  class.
 The state of a print job may change over time. An application receives
 instances of this class when creating a print job or querying for
 its print jobs."
android,print,PrintJobId,4,This class represents the id of a print job.
android,print,PrintJobInfo,14,"This class represents the description of a print job. The print job
 state includes properties such as its id print attributes used for
 generating the content and so on. Note that the print jobs state may
 change over time and this class represents a snapshot of this state."
android,se.omapi,Channel,7,"Instances of this class represent an ISO/IEC 7816-4 channel opened to a
 Secure Element. It can be either a logical channel or the basic channel. They
 can be used to send APDUs to the secure element. Channels are opened by
 calling the Session.openBasicChannel(byte[]) or
 Session.openLogicalChannel(byte[]) methods."
android,se.omapi,Reader,5,"Instances of this class represent Secure Element Readers supported to this
 device. These Readers can be physical devices or virtual devices. They can be
 removable or not. They can contain Secure Element that can or cannot be
 removed."
android,se.omapi,SEService,4,"The SEService realises the communication to available Secure Elements on the
 device. This is the entry point of this API. It is used to connect to the
 infrastructure and get access to a list of Secure Element Readers."
android,se.omapi,Session,9,"Instances of this class represent a connection session to one of the Secure
 Elements available on the device. These objects can be used to get a
 communication channel with an Applet in the Secure Element.
 This channel can be the basic channel or a logical channel."
android,os,BatteryManager,4,"The BatteryManager class contains strings and constants used for values
 in the  Intent.ACTION_BATTERY_CHANGED  Intent and
 provides a method for querying battery and charging properties."
android,os,Binder,24,"Base class for a remotable object the core part of a lightweight
 remote procedure call mechanism defined by  IBinder .
 This class is an implementation of IBinder that provides
 standard local implementation of such an object.

  Most developers will not implement this class directly instead using the
  aidl  tool to describe the desired
 interface having it generate the appropriate Binder subclass.  You can
 however derive directly from Binder to implement your own custom RPC
 protocol or simply instantiate a raw Binder object directly to use as a
 token that can be shared across processes.

  This class is just a basic IPC primitive; it has no impact on an application's
 lifecycle and is valid only as long as the process that created it continues to run.
 To use this correctly you must be doing so within the context of a top-level
 application component (a  Service   Activity 
 or  ContentProvider ) that lets the system know your process
 should remain running. You must keep in mind the situations in which your process
 could go away and thus require that you later re-create a new Binder and re-attach
 it when the process starts again.  For example if you are using this within an
  Activity  your activity's process may be killed any time the
 activity is not started; if the activity is later re-created you will need to
 create a new Binder and hand it back to the correct place again; you need to be
 aware that your process may be started for another reason (for example to receive
 a broadcast) that will not involve re-creating the activity and thus run its code
 to create a new Binder."
android,os,Build,3,Information about the current build extracted from system properties.
android,os,Build.Partition,5,Build information for a particular device partition.
android,os,Build.VERSION,0,Various version strings.
android,os,Build.VERSION_CODES,0,"Enumeration of the currently known SDK version codes.  These are the
 values that can be found in  VERSION#SDK .  Version numbers
 increment monotonically with each official platform release."
android,os,CancellationSignal,4,Provides the ability to cancel an operation in progress.
android,os,ConditionVariable,4,"Class that implements the condition variable locking paradigm.

  
 This differs from the built-in java.lang.Object wait() and notify()
 in that this class contains the condition to wait on itself.  That means
 open() close() and block() are sticky.  If open() is called before block()
 block() will not block and instead return immediately.

  
 This class uses itself as the object to wait on so if you wait()
 or notify() on a ConditionVariable the results are undefined."
android,os,Debug.InstructionCount,4,"API for gathering and querying instruction counts.

 Example usage:
  
   Debug.InstructionCount icount = new Debug.InstructionCount();
   icount.resetAndStart();
    [... do lots of stuff ...]
   if (icount.collect()) {
       System.out.println(""Total instructions executed: ""
           + icount.globalTotal());
       System.out.println(""Method invocations: ""
           + icount.globalMethodInvocations());
   }"
android,os,DropBoxManager,5,"Enqueues chunks of data (from various sources -- application crashes kernel
 log records etc.).  The queue is size bounded and will drop old data if the
 enqueued data exceeds the maximum size.  You can think of this as a
 persistent system-wide blob-oriented ""logcat"".

  DropBoxManager entries are not sent anywhere directly but other system
 services and debugging tools may scan and upload entries for processing."
android,os,DropBoxManager.Entry,8,"A single entry retrieved from the drop box.
 This may include a reference to a stream so you must call
  close()  when you are done using it."
android,os,FileObserver,4,"Monitors files (using  inotify )
 to fire an event after files are accessed or changed by by any process on
 the device (including this one).  FileObserver is an abstract class;
 subclasses must implement the event handler  onEvent(int java.lang.String) .

  Each FileObserver instance can monitor multiple files or directories.
 If a directory is monitored events will be triggered for all files and
 subdirectories inside the monitored directory. An event mask is used to specify which changes or actions to report.
 Event type constants are used to describe the possible changes in the
 event mask as well as what actually happened in event callbacks."
android,os,FileUtils,6,Utility methods useful for working with files.
android,os,Handler,34,"A Handler allows you to send and process  Message  and Runnable
 objects associated with a thread's  MessageQueue .  Each Handler
 instance is associated with a single thread and that thread's message
 queue.  When you create a new Handler it is bound to the thread /
 message queue of the thread that is creating it -- from that point on
 it will deliver messages and runnables to that message queue and execute
 them as they come out of the message queue.

  There are two main uses for a Handler: (1) to schedule messages and
 runnables to be executed at some point in the future; and (2) to enqueue
 an action to be performed on a different thread than your own.

  Scheduling messages is accomplished with the
  post(Runnable)   postAtTime(java.lang.Runnable long) 
  postDelayed(Runnable Object long)   sendEmptyMessage(int) 
  sendMessage(Message)   sendMessageAtTime(Message long)  and
  sendMessageDelayed(Message long)  methods.  The  post  versions allow
 you to enqueue Runnable objects to be called by the message queue when
 they are received; the  sendMessage  versions allow you to enqueue
 a  Message  object containing a bundle of data that will be
 processed by the Handler's  handleMessage(Message)  method (requiring that
 you implement a subclass of Handler).

  When posting or sending to a Handler you can either
 allow the item to be processed as soon as the message queue is ready
 to do so or specify a delay before it gets processed or absolute time for
 it to be processed.  The latter two allow you to implement timeouts
 ticks and other timing-based behavior.

  When a
 process is created for your application its main thread is dedicated to
 running a message queue that takes care of managing the top-level
 application objects (activities broadcast receivers etc) and any windows
 they create.  You can create your own threads and communicate back with
 the main application thread through a Handler.  This is done by calling
 the same  post  or  sendMessage  methods as before but from
 your new thread.  The given Runnable or Message will then be scheduled
 in the Handler's message queue and processed when appropriate."
android,os,HardwarePropertiesManager,3,"The HardwarePropertiesManager class provides a mechanism of accessing hardware state of a
 device: CPU GPU and battery temperatures CPU usage per core fan speed etc."
android,os,LocaleList,17,"LocaleList is an immutable list of Locales typically used to keep an ordered list of user
 preferences for locales."
android,os,MemoryFile,8,"MemoryFile is a wrapper for  SharedMemory  which can optionally be set to purgeable.

 Applications should generally prefer to use  SharedMemory  which offers more flexible
 access & control over the shared memory region than MemoryFile does.

 Purgeable files may have their contents reclaimed by the kernel
 in low memory conditions (only if allowPurging is set to true).
 After a file is purged attempts to read or write the file will
 cause an IOException to be thrown."
android,os,MessageQueue,6,"Low-level class holding the list of messages to be dispatched by a
  Looper .  Messages are not added directly to a MessageQueue
 but rather through  Handler  objects associated with the Looper.

  You can retrieve the MessageQueue for the current thread with
  Looper#myQueue() ."
android,os,Messenger,8,"Reference to a Handler which others can use to send messages to it.
 This allows for the implementation of message-based communication across
 processes by creating a Messenger pointing to a Handler in one process
 and handing that Messenger to another process.

  Note: the implementation underneath is just a simple wrapper around
 a  Binder  that is used to perform the communication.  This means
 semantically you should treat it as such: this class does not impact process
 lifecycle management (you must be using some higher-level component to tell
 the system that your process needs to continue running) the connection will
 break if your process goes away for any reason etc."
android,os,ParcelFileDescriptor,25,"The FileDescriptor returned by  Parcel#readFileDescriptor  allowing
 you to close it when done with it."
android,os,ParcelFileDescriptor.AutoCloseInputStream,4,"An InputStream you can create on a ParcelFileDescriptor which will
 take care of calling  ParcelFileDescriptor#close  for you when the stream is closed."
android,os,ParcelUuid,7,"This class is a Parcelable wrapper around  UUID  which is an
 immutable representation of a 128-bit universally unique
 identifier."
android,os,PatternMatcher,6,"A simple pattern matcher which is safe to use on untrusted data: it does
 not provide full reg-exp support only simple globbing that can not be
 used maliciously."
android,os,PowerManager,14,"This class gives you control of the power state of the device.

  Device battery life will be significantly affected by the use of this API. 
 Do not acquire  WakeLock s unless you really need them use the minimum levels
 possible and be sure to release them as soon as possible.
  
 The primary API you'll use is  newWakeLock() .
 This will create a  PowerManager.WakeLock  object.  You can then use methods
 on the wake lock object to control the power state of the device.
  
 In practice it's quite simple:
  PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE);
 PowerManager.WakeLock wl = pm.newWakeLock(PowerManager.SCREEN_DIM_WAKE_LOCK ""My Tag"");
 wl.acquire();
   ..screen will stay on during this section..
 wl.release();
  
 The following wake lock levels are defined with varying effects on system power.
  These levels are mutually exclusive - you may only specify one of them. Flag Value CPU Screen Keyboard PARTIAL_WAKE_LOCK On* Off Off SCREEN_DIM_WAKE_LOCK On Dim Off SCREEN_BRIGHT_WAKE_LOCK On Bright Off FULL_WAKE_LOCK On Bright Bright 
 * If you hold a partial wake lock the CPU will continue to run regardless of any
 display timeouts or the state of the screen and even after the user presses the power button.
 In all other wake locks the CPU will run but the user can still put the device to sleep
 using the power button. 
 In addition you can add two more flags which affect behavior of the screen only.
  These flags have no effect when combined with a  PARTIAL_WAKE_LOCK . Flag Value Description ACQUIRE_CAUSES_WAKEUP Normal wake locks don't actually turn on the illumination.  Instead they cause
         the illumination to remain on once it turns on (e.g. from user activity).  This flag
         will force the screen and/or keyboard to turn on immediately when the WakeLock is
         acquired.  A typical use would be for notifications which are important for the user to
         see immediately. ON_AFTER_RELEASE If this flag is set the user activity timer will be reset when the WakeLock is
         released causing the illumination to remain on a bit longer.  This can be used to
         reduce flicker if you are cycling between wake lock conditions. 
 Any application using a WakeLock must request the  android.permission.WAKE_LOCK 
 permission in an  <uses-permission>  element of the application's manifest."
android,os,PowerManager.WakeLock,9,"A wake lock is a mechanism to indicate that your application needs
 to have the device stay on.
  
 Any application using a WakeLock must request the  android.permission.WAKE_LOCK 
 permission in an  <uses-permission>  element of the application's manifest.
 Obtain a wake lock by calling  PowerManager#newWakeLock(int String) .
  
 Call  acquire()  to acquire the wake lock and force the device to stay
 on at the level that was requested when the wake lock was created.
  
 Call  release()  when you are done and don't need the lock anymore.
 It is very important to do this as soon as possible to avoid running down the
 device's battery excessively."
android,os,RecoverySystem,4,"RecoverySystem contains methods for interacting with the Android
 recovery system (the separate partition that can be used to install
 system updates wipe user data etc.)"
android,os,RemoteCallbackList,13,"Takes care of the grunt work of maintaining a list of remote interfaces
 typically for the use of performing callbacks from a
  Service  to its clients.  In particular this:

   Keeps track of a set of registered  IInterface  callbacks
 taking care to identify them through their underlying unique  IBinder 
 (by calling  IInterface#asBinder .
   Attaches a  IBinder.DeathRecipient  to
 each registered interface so that it can be cleaned out of the list if its
 process goes away.
   Performs locking of the underlying list of interfaces to deal with
 multithreaded incoming calls and a thread-safe way to iterate over a
 snapshot of the list without holding its lock.
  To use this class simply create a single instance along with your
 service and call its  register(E)  and  unregister(E)  methods
 as client register and unregister with your service.  To call back on to
 the registered clients use  beginBroadcast() 
  getBroadcastItem(int)  and  finishBroadcast() .

  If a registered callback's process goes away this class will take
 care of automatically removing it from the list.  If you want to do
 additional work in this situation you can create a subclass that
 implements the  onCallbackDied(E)  method."
android,os,ResultReceiver,4,"Generic interface for receiving a callback result from someone.  Use this
 by creating a subclass and implement  onReceiveResult(int Bundle)  which you can
 then pass to others and send through IPC and receive results they
 supply with  send(int Bundle) .

  Note: the implementation underneath is just a simple wrapper around
 a  Binder  that is used to perform the communication.  This means
 semantically you should treat it as such: this class does not impact process
 lifecycle management (you must be using some higher-level component to tell
 the system that your process needs to continue running) the connection will
 break if your process goes away for any reason etc."
android,os,SharedMemory,10,SharedMemory enables the creation mapping and protection control over anonymous shared memory.
android,os,StatFs,12,"Retrieve overall information about the space on a filesystem. This is a
 wrapper for Unix statvfs()."
android,os,StrictMode,8,"StrictMode is a developer tool which detects things you might be doing by accident and brings
 them to your attention so you can fix them.

  StrictMode is most commonly used to catch accidental disk or network access on the
 application's main thread where UI operations are received and animations take place. Keeping
 disk and network operations off the main thread makes for much smoother more responsive
 applications. By keeping your application's main thread responsive you also prevent  ANR dialogs  from being shown to
 users.

  Note that even though an Android device's disk is often on flash memory many
 devices run a filesystem on top of that memory with very limited concurrency. It's often the case
 that almost all disk accesses are fast but may in individual cases be dramatically slower when
 certain I/O is happening in the background from other processes. If possible it's best to assume
 that such things are not fast.

  Example code to enable from early in your  Application   Activity  or other application component's  Application.onCreate() 
 method:

  
 public void onCreate() {
     if (DEVELOPER_MODE) {
         StrictMode.setThreadPolicy(new  ThreadPolicy.Builder ()
                 .detectDiskReads()
                 .detectDiskWrites()
                 .detectNetwork()   // or .detectAll() for all detectable problems
                 .penaltyLog()
                 .build());
         StrictMode.setVmPolicy(new  VmPolicy.Builder ()
                 .detectLeakedSqlLiteObjects()
                 .detectLeakedClosableObjects()
                 .penaltyLog()
                 .penaltyDeath()
                 .build());
     }
     super.onCreate();
 }
  You can decide what should happen when a violation is detected. For example using  StrictMode.ThreadPolicy.Builder.penaltyLog()  you can watch the output of  adb logcat  while you
 use your application to see the violations as they happen.

  If you find violations that you feel are problematic there are a variety of tools to help
 solve them: threads  Handler   AsyncTask   IntentService  etc. But don't feel compelled to fix everything that StrictMode
 finds. In particular many cases of disk access are often necessary during the normal activity
 lifecycle. Use StrictMode to find things you did by accident. Network requests on the UI thread
 are almost always a problem though.

  StrictMode is not a security mechanism and is not guaranteed to find all disk or
 network accesses. While it does propagate its state across process boundaries when doing  Binder  calls it's still ultimately a best effort mechanism. Notably disk or network
 access from JNI calls won't necessarily trigger it. Future versions of Android may catch more (or
 fewer) operations so you should never leave StrictMode enabled in applications distributed on
 Google Play."
android,os,StrictMode.ThreadPolicy.Builder,22,"Creates  ThreadPolicy  instances. Methods whose names start with  detect 
 specify what problems we should look for. Methods whose names start with  penalty 
 specify what we should do when we detect a problem.

  You can call as many  detect  and  penalty  methods as you like. Currently
 order is insignificant: all penalties apply to all detected problems.

  For example detect everything and log anything that's found:

  
 StrictMode.ThreadPolicy policy = new StrictMode.ThreadPolicy.Builder()
     .detectAll()
     .penaltyLog()
     .build();
 StrictMode.setThreadPolicy(policy);"
android,os,SystemClock,7,"Core timekeeping facilities.

   Three different clocks are available and they should not be confused:

  System#currentTimeMillis 
     is the standard ""wall"" clock (time and date) expressing milliseconds
     since the epoch.  The wall clock can be set by the user or the phone
     network (see  setCurrentTimeMillis(long) ) so the time may jump
     backwards or forwards unpredictably.  This clock should only be used
     when correspondence with real-world dates and times is important such
     as in a calendar or alarm clock application.  Interval or elapsed
     time measurements should use a different clock.  If you are using
     System.currentTimeMillis() consider listening to the
      ACTION_TIME_TICK 
      ACTION_TIME_CHANGED 
     and  ACTION_TIMEZONE_CHANGED Intent 
     broadcasts to find out when the time changes.

      uptimeMillis()  is counted in milliseconds since the
     system was booted.  This clock stops when the system enters deep
     sleep (CPU off display dark device waiting for external input)
     but is not affected by clock scaling idle or other power saving
     mechanisms.  This is the basis for most interval timing
     such as  Thread#sleep(long) 
      Object#wait(long)  and
      System#nanoTime .  This clock is guaranteed
     to be monotonic and is suitable for interval timing when the
     interval does not span device sleep.  Most methods that accept a
     timestamp value currently expect the  uptimeMillis()  clock.

      elapsedRealtime()  and  elapsedRealtimeNanos() 
     return the time since the system was booted and include deep sleep.
     This clock is guaranteed to be monotonic and continues to tick even
     when the CPU is in power saving modes so is the recommend basis
     for general purpose interval timing.

   Standard functions like  Thread#sleep(long)  and  Object#wait(long) 
     are always available.  These functions use the  uptimeMillis() 
     clock; if the device enters sleep the remainder of the time will be
     postponed until the device wakes up.  These synchronous functions may
     be interrupted with  Thread#interrupt  and
     you must handle  InterruptedException .

      SystemClock.sleep(millis)  is a utility function
     very similar to  Thread#sleep(long)  but it
     ignores  InterruptedException .  Use this function for delays if
     you do not use  Thread#interrupt  as it will
     preserve the interrupted state of the thread.

       The  Handler  class can schedule asynchronous
     callbacks at an absolute or relative time.  Handler objects also use the
      uptimeMillis()  clock and require an  event loop  (normally present in any GUI application).

       The  AlarmManager  can trigger one-time or
     recurring events which occur even when the device is in deep sleep
     or your application is not running.  Events may be scheduled with your
     choice of  System.currentTimeMillis()  (RTC) or
      elapsedRealtime()  (ELAPSED_REALTIME) and cause an
      Intent  broadcast when they occur."
android,os,TestLooperManager,7,"Blocks a looper from executing any messages and allows the holder of this object
 to control when and which messages get executed until it is released.
  
 A TestLooperManager should be acquired using
  Instrumentation.acquireLooperManager(Looper) . Until  release()  is called
 the Looper thread will not execute any messages except when  execute(android.os.Message)  is called.
 The test code may use  next()  to acquire messages that have been queued to this
  Looper / MessageQueue  and then  execute(Message)  to run any that desires."
android,os,Trace,6,"Writes trace events to the system trace buffer.  These trace events can be
 collected and visualized using the Systrace tool.

  This tracing mechanism is independent of the method tracing mechanism
 offered by  Debug#startMethodTracing .  In particular it enables
 tracing of events that occur across multiple processes.
  For information about using the Systrace tool read  Analyzing Display and Performance
 with Systrace ."
android,os,UserManager,25,"Manages users and user details on a multi-user system. There are two major categories of
 users: fully customizable users with their own login and managed profiles that share a workspace
 with a related user.
  
 Users are different from accounts which are managed by
  AccountManager . Each user can have their own set of accounts.
  
 See  DevicePolicyManager#ACTION_PROVISION_MANAGED_PROFILE  for more on managed profiles."
android,os,VibrationEffect,5,"A VibrationEffect describes a haptic effect to be performed by a  Vibrator .

 These effects may be any number of things from single shot vibrations to complex waveforms."
android,os,WorkSource,10,"Describes the source of some work that may be done by someone else.
 Currently the public representation of what a work source is is not
 defined; this is an opaque container."
android,os,AsyncTask,15,"AsyncTask enables proper and easy use of the UI thread. This class allows you
 to perform background operations and publish results on the UI thread without
 having to manipulate threads and/or handlers. AsyncTask is designed to be a helper class around  Thread  and  Handler 
 and does not constitute a generic threading framework. AsyncTasks should ideally be
 used for short operations (a few seconds at the most.) If you need to keep threads
 running for long periods of time it is highly recommended you use the various APIs
 provided by the  java.util.concurrent  package such as  Executor 
  ThreadPoolExecutor  and  FutureTask . An asynchronous task is defined by a computation that runs on a background thread and
 whose result is published on the UI thread. An asynchronous task is defined by 3 generic
 types called  Params   Progress  and  Result 
 and 4 steps called  onPreExecute   doInBackground 
  onProgressUpdate  and  onPostExecute ."
android,os,BaseBundle,33,"A mapping from String keys to values of various types. In most cases you
 should work directly with either the  Bundle  or
  PersistableBundle  subclass."
android,os,Bundle,61,A mapping from String keys to various  Parcelable  values.
android,os,CountDownTimer,4,"Schedule a countdown until a time in the future with
 regular notifications on intervals along the way.

 Example of showing a 30 second countdown in a text field:

  
 new CountDownTimer(30000 1000) {

     public void onTick(long millisUntilFinished) {
         mTextField.setText(""seconds remaining: "" + millisUntilFinished / 1000);
     }

     public void onFinish() {
         mTextField.setText(""done!"");
     }
  }.start();
  onTick(long) onTick(long) onTick(long)"
android,os,Debug.MemoryInfo,11,"This class is used to retrieved various statistics about the memory mappings for this
 process. The returned info is broken down by dalvik native and other. All results are in kB."
android,os,Environment,14,Provides access to environment variables.
android,os,Looper,14,"Class used to run a message loop for a thread.  Threads by default do
 not have a message loop associated with them; to create one call
  prepare()  in the thread that is to run the loop and then
  loop()  to have it process messages until the loop is stopped.

  Most interaction with a message loop is through the
  Handler  class.

  This is a typical example of the implementation of a Looper thread
 using the separation of  prepare()  and  loop()  to create an
 initial Handler to communicate with the Looper.

  
  class LooperThread extends Thread {
      public Handler mHandler;

      public void run() {
          Looper.prepare();

          mHandler = new Handler() {
              public void handleMessage(Message msg) {
                  // process incoming messages here
              }
          };

          Looper.loop();
      }
  }"
android,os,Message,23,"Defines a message containing a description and arbitrary data object that can be
 sent to a  Handler .  This object contains two extra int fields and an
 extra object field that allow you to not do allocations in many cases.

  While the constructor of Message is public the best way to get
 one of these is to call  Message.obtain()  or one of the
  Handler#obtainMessage  methods which will pull
 them from a pool of recycled objects."
android,os,CpuUsageInfo,4,CPU usage information per core.
android,os,Debug,68,"Provides various debugging methods for Android applications including
 tracing and allocation counts.
  Logging Trace Files Debug can create log files that give details about an application such as
 a call stack and start/stop times for any running methods. See  Inspect Trace Logs with
 Traceview  for information about reading trace files. To start logging
 trace files call one of the startMethodTracing() methods. To stop tracing
 call  stopMethodTracing() ."
android,os,HandlerThread,6,"A  Thread  that has a  Looper .
 The  Looper  can then be used to create  Handler s.
  
 Note that just like with a regular  Thread   Thread.start()  must still be called."
android,os,Parcel,117,"Container for a message (data and object references) that can
 be sent through an IBinder.  A Parcel can contain both flattened data
 that will be unflattened on the other side of the IPC (using the various
 methods here for writing specific types or the general
  Parcelable  interface) and references to live  IBinder 
 objects that will result in the other side receiving a proxy IBinder
 connected with the original IBinder in the Parcel.

  Parcel is  not  a general-purpose
 serialization mechanism.  This class (and the corresponding
  Parcelable  API for placing arbitrary objects into a Parcel) is
 designed as a high-performance IPC transport.  As such it is not
 appropriate to place any Parcel data in to persistent storage: changes
 in the underlying implementation of any of the data in the Parcel can
 render older data unreadable. The bulk of the Parcel API revolves around reading and writing data
 of various types.  There are six major classes of such functions available. Primitives The most basic data functions are for writing and reading primitive
 data types:  writeByte(byte)   readByte()   writeDouble(double) 
  readDouble()   writeFloat(float)   readFloat()   writeInt(int) 
  readInt()   writeLong(long)   readLong() 
  writeString(String)   readString() .  Most other
 data operations are built on top of these.  The given data is written and
 read using the endianess of the host CPU. Primitive Arrays There are a variety of methods for reading and writing raw arrays
 of primitive objects which generally result in writing a 4-byte length
 followed by the primitive data items.  The methods for reading can either
 read the data into an existing array or create and return a new array.
 These available types are: writeBooleanArray(boolean[]) 
  readBooleanArray(boolean[])   createBooleanArray() writeByteArray(byte[]) 
  writeByteArray(byte[] int int)   readByteArray(byte[]) 
  createByteArray() writeCharArray(char[])   readCharArray(char[]) 
  createCharArray() writeDoubleArray(double[])   readDoubleArray(double[]) 
  createDoubleArray() writeFloatArray(float[])   readFloatArray(float[]) 
  createFloatArray() writeIntArray(int[])   readIntArray(int[]) 
  createIntArray() writeLongArray(long[])   readLongArray(long[]) 
  createLongArray() writeStringArray(java.lang.String[])   readStringArray(java.lang.String[]) 
  createStringArray() .
  writeSparseBooleanArray(android.util.SparseBooleanArray) 
  readSparseBooleanArray() .
  Parcelables The  Parcelable  protocol provides an extremely efficient (but
 low-level) protocol for objects to write and read themselves from Parcels.
 You can use the direct methods  writeParcelable(android.os.Parcelable int) 
 and  readParcelable(java.lang.ClassLoader)  or
  writeParcelableArray(T[] int)  and
  readParcelableArray(java.lang.ClassLoader)  to write or read.  These
 methods write both the class type and its data to the Parcel allowing
 that class to be reconstructed from the appropriate class loader when
 later reading. There are also some methods that provide a more efficient way to work
 with Parcelables:  writeTypedObject(T int)   writeTypedArray(T[] int) 
  writeTypedList(List )   readTypedObject(Parcelable.Creator ) 
  createTypedArray(Parcelable.Creator )  and  createTypedArrayList(Parcelable.Creator ) .  These methods
 do not write the class information of the original object: instead the
 caller of the read function must know what type to expect and pass in the
 appropriate  Parcelable.Creator  instead to
 properly construct the new object and read its data.  (To more efficient
 write and read a single Parcelable object that is not null you can directly
 call  Parcelable#writeToParcel  and
  Parcelable.Creator#createFromParcel 
 yourself.) Bundles A special type-safe container called  Bundle  is available
 for key/value maps of heterogeneous values.  This has many optimizations
 for improved performance when reading and writing data and its type-safe
 API avoids difficult to debug type errors when finally marshalling the
 data contents into a Parcel.  The methods to use are
  writeBundle(android.os.Bundle)   readBundle()  and
  readBundle(java.lang.ClassLoader) .

  Active Objects An unusual feature of Parcel is the ability to read and write active
 objects.  For these objects the actual contents of the object is not
 written rather a special token referencing the object is written.  When
 reading the object back from the Parcel you do not get a new instance of
 the object but rather a handle that operates on the exact same object that
 was originally written.  There are two forms of active objects available. Binder  objects are a core facility of Android's general cross-process
 communication system.  The  IBinder  interface describes an abstract
 protocol with a Binder object.  Any such interface can be written in to
 a Parcel and upon reading you will receive either the original object
 implementing that interface or a special proxy implementation
 that communicates calls back to the original object.  The methods to use are
  writeStrongBinder(android.os.IBinder) 
  writeStrongInterface(android.os.IInterface)   readStrongBinder() 
  writeBinderArray(android.os.IBinder[])   readBinderArray(android.os.IBinder[]) 
  createBinderArray() 
  writeBinderList(java.util.List)   readBinderList(java.util.List) 
  createBinderArrayList() . FileDescriptor objects representing raw Linux file descriptor identifiers
 can be written and  ParcelFileDescriptor  objects returned to operate
 on the original file descriptor.  The returned file descriptor is a dup
 of the original file descriptor: the object and fd is different but
 operating on the same underlying file stream with the same position etc.
 The methods to use are  writeFileDescriptor(java.io.FileDescriptor) 
  readFileDescriptor() .

  Untyped Containers A final class of methods are for writing and reading standard Java
 containers of arbitrary types.  These all revolve around the
  writeValue(java.lang.Object)  and  readValue(java.lang.ClassLoader)  methods
 which define the types of objects allowed.  The container methods are
  writeArray(java.lang.Object[])   readArray(java.lang.ClassLoader) 
  writeList(java.util.List)   readList(java.util.List java.lang.ClassLoader) 
  readArrayList(java.lang.ClassLoader) 
  writeMap(java.util.Map)   readMap(java.util.Map java.lang.ClassLoader) 
  writeSparseArray(android.util.SparseArray) 
  readSparseArray(java.lang.ClassLoader) ."
android,os,ParcelFileDescriptor.AutoCloseOutputStream,1,"An OutputStream you can create on a ParcelFileDescriptor which will
 take care of calling  ParcelFileDescriptor#close  for you when the stream is closed."
android,os,Process,19,Tools for managing OS processes.
android,os,ProxyFileDescriptorCallback,5,"Callback that handles file system requests from ProxyFileDescriptor.

 All callback methods except for onRelease should throw  ErrnoException 
 with proper errno on errors. See
  errno(3)  and
  OsConstants .

 Typical errnos are

  OsConstants.EIO  for general I/O issues
  OsConstants.ENOENT  when the file is not found
  OsConstants.EBADF  if the file doesn't allow read/write operations
     based on how it was opened.  (For example trying to write a file that was opened read-only.)
  OsConstants.ENOSPC  if you cannot handle a write operation to
     space/quota limitations."
android,os,StrictMode.ThreadPolicy,1,"StrictMode  policy applied to a certain thread.

  The policy is enabled by  StrictMode.setThreadPolicy(StrictMode.ThreadPolicy) . The current policy can be retrieved
 with  StrictMode.getThreadPolicy() .

  Note that multiple penalties may be provided and they're run in order from least to most
 severe (logging before process death for example). There's currently no mechanism to choose
 different penalties for different detected actions."
android,os,StrictMode.VmPolicy,1,"StrictMode  policy applied to all threads in the virtual machine's process.

  The policy is enabled by  StrictMode.setVmPolicy(StrictMode.VmPolicy) ."
android,os,StrictMode.VmPolicy.Builder,21,"Creates  VmPolicy  instances. Methods whose names start with  detect  specify
 what problems we should look for. Methods whose names start with  penalty  specify
 what we should do when we detect a problem.

  You can call as many  detect  and  penalty  methods as you like. Currently
 order is insignificant: all penalties apply to all detected problems.

  For example detect everything and log anything that's found:

  
 StrictMode.VmPolicy policy = new StrictMode.VmPolicy.Builder()
     .detectAll()
     .penaltyLog()
     .build();
 StrictMode.setVmPolicy(policy);"
android,os,Vibrator,9,"Class that operates the vibrator on the device.
  
 If your process exits any vibration you started will stop."
android,os,PersistableBundle,7,"A mapping from String keys to values of various types. The set of types
 supported by this class is purposefully restricted to simple objects that can
 safely be persisted to and restored from disk."
android,os,TokenWatcher,8,"A TokenWatcher watches a collection of  IBinder s. IBinders are added
 to the collection by calling  acquire(IBinder String)  and removed by calling  release(IBinder) . IBinders are also implicitly removed when they become weakly
 reachable. Each IBinder may be added at most once.

 The  acquired()  method is invoked by posting to the specified handler
 whenever the size of the watched collection becomes nonzero.  The  released()  method is invoked on the specified handler whenever the size of
 the watched collection becomes zero."
android,os,UserHandle,8,Representation of a user on the device.
android,security,AttestedKeyPair,2,"The  AttestedKeyPair  class contains a  KeyPair  instance of
 keys generated by Keystore and owned by KeyChain as well as an attestation
 record for the key.

  Such keys can be obtained by calling
  DevicePolicyManager.generateKeyPair(ComponentName String KeyGenParameterSpec int) ."
android,security,ConfirmationCallback,4,Callback class used when signaling that a prompt is no longer being presented.
android,security,ConfirmationPrompt,3,"Class used for displaying confirmation prompts.

  Confirmation prompts are prompts shown to the user to confirm a given text and are
 implemented in a way that a positive response indicates with high confidence that the user has
 seen the given text even if the Android framework (including the kernel) was
 compromised. Implementing confirmation prompts with these guarantees requires dedicated
 hardware-support and may not always be available.

  Confirmation prompts are typically used with an external entitity - the  Relying Party  -
 in the following way. The setup steps are as follows:
   Before first use the application generates a key-pair with the
  CONFIRMATION tag  set. Device attestation
 e.g.  getCertificateChain()  is used to
 generate a certificate chain that includes the public key ( Kpub  in the following)
 of the newly generated key.
   The application sends  Kpub  and the certificate chain resulting from device
 attestation to the  Relying Party .
   The  Relying Party  validates the certificate chain which involves checking the root
 certificate is what is expected (e.g. a certificate from Google) each certificate signs the
 next one in the chain ending with  Kpub  and that the attestation certificate
 asserts that  Kpub  has the
  CONFIRMATION tag  set.
 Additionally the relying party stores  Kpub  and associates it with the device
 it was received from.
  The  Relying Party  is typically an external device (for example connected via
 Bluetooth) or application server.

  Before executing a transaction which requires a high assurance of user content the
 application does the following:
   The application gets a cryptographic nonce from the  Relying Party  and passes this as
 the  extraData  (via the Builder helper class) to the
  presentPrompt()  method. The  Relying Party  stores the nonce locally
 since it'll use it in a later step.
   If the user approves the prompt a  Confirmation Response  is returned in the
  ConfirmationCallback#onConfirmed  callback as the
  dataThatWasConfirmed  parameter. This blob contains the text that was shown to the
 user the  extraData  parameter and possibly other data.
   The application signs the  Confirmation Response  with the previously created key and
 sends the blob and the signature to the  Relying Party .
   The  Relying Party  checks that the signature was made with  Kpub  and then
 extracts  promptText  matches what is expected and  extraData  matches the
 previously created nonce. If all checks passes the transaction is executed.
  A common way of implementing the "" promptText  is what is expected"" check in the
 last bullet is to have the  Relying Party  generate  promptText  and store it
 along the nonce in the  extraData  blob."
android,security,ConfirmationPrompt.Builder,3,A builder that collects arguments to be shown on the system-provided confirmation prompt.
android,security,KeyChain,7,"The  KeyChain  class provides access to private keys and
 their corresponding certificate chains in credential storage.

  Applications accessing the  KeyChain  normally go through
 these steps:

  Receive a callback from an  X509KeyManager  that a private key is requested.

  Call  choosePrivateKeyAlias  to allow the user to select from a
 list of currently available private keys and corresponding
 certificate chains. The chosen alias will be returned by the
 callback  KeyChainAliasCallback#alias  or null if no private
 key is available or the user cancels the request.

  Call  getPrivateKey(Context String)  and  getCertificateChain(Context String)  to
 retrieve the credentials to return to the corresponding  X509KeyManager  callbacks.

  An application may remember the value of a selected alias to
 avoid prompting the user with  choosePrivateKeyAlias  on subsequent connections. If the alias is
 no longer valid null will be returned on lookups using that value

  An application can request the installation of private keys and
 certificates via the  Intent  provided by  createInstallIntent() . Private keys installed via this  Intent  will be accessible via  choosePrivateKeyAlias(Activity KeyChainAliasCallback String[] Principal[] Uri String)  while
 Certificate Authority (CA) certificates will be trusted by all
 applications through the default  X509TrustManager ."
android,security,KeyPairGeneratorSpec,10,"This provides the required parameters needed for initializing the
  KeyPairGenerator  that works with
  Android KeyStore
 facility . The Android KeyStore facility is accessed through a
  KeyPairGenerator  API using the  AndroidKeyStore 
 provider. The  context  passed in may be used to pop up some UI to ask
 the user to unlock or initialize the Android KeyStore facility.
  
 After generation the  keyStoreAlias  is used with the
  KeyStore.getEntry(String java.security.KeyStore.ProtectionParameter) 
 interface to retrieve the  PrivateKey  and its associated
  Certificate  chain.
  
 The KeyPair generator will create a self-signed certificate with the subject
 as its X.509v3 Subject Distinguished Name and as its X.509v3 Issuer
 Distinguished Name along with the other parameters specified with the
  Builder .
  
 The self-signed X.509 certificate may be replaced at a later time by a
 certificate signed by a real Certificate Authority."
android,security,KeyStoreParameter,1,"This provides the optional parameters that can be specified for
  KeyStore  entries that work with
  Android KeyStore
 facility . The Android KeyStore facility is accessed through a
  KeyStore  API using the  AndroidKeyStore 
 provider. The  context  passed in may be used to pop up some UI to ask
 the user to unlock or initialize the Android KeyStore facility.
  
 Any entries placed in the  KeyStore  may be retrieved later. Note that
 there is only one logical instance of the  KeyStore  per application
 UID so apps using the  sharedUid  facility will also share a
  KeyStore .
  
 Keys may be generated using the  KeyPairGenerator  facility with a
  KeyPairGeneratorSpec  to specify the entry's  alias . A
 self-signed X.509 certificate will be attached to generated entries but that
 may be replaced at a later time by a certificate signed by a real Certificate
 Authority."
android,security,KeyStoreParameter.Builder,2,"Builder class for  KeyStoreParameter  objects.
  
 This will build protection parameters for use with the
  Android KeyStore
 facility .
  
 This can be used to require that KeyStore entries be stored encrypted.
  
 Example:

  
 KeyStoreParameter params = new KeyStoreParameter.Builder(mContext)
         .setEncryptionRequired()
         .build();"
android,security,KeyPairGeneratorSpec.Builder,10,"Builder class for  KeyPairGeneratorSpec  objects.
  
 This will build a parameter spec for use with the
  Android KeyStore
 facility .
  
 The required fields must be filled in with the builder.
  
 Example:

  
 Calendar start = Calendar.getInstance();
 Calendar end = Calendar.getInstance();
 end.add(Calendar.YEAR 1);

 KeyPairGeneratorSpec spec =
         new KeyPairGeneratorSpec.Builder(mContext).setAlias(""myKey"")
                 .setSubject(new X500Principal(""CN=myKey"")).setSerialNumber(BigInteger.valueOf(1337))
                 .setStartDate(start.getTime()).setEndDate(end.getTime()).build();"
android,security,NetworkSecurityPolicy,3,"Network security policy.

  Network stacks/components should honor this policy to make it possible to centrally control
 the relevant aspects of network security behavior.

  The policy currently consists of a single flag: whether cleartext network traffic is
 permitted. See  isCleartextTrafficPermitted() ."
android,security.keystore,KeyGenParameterSpec,26,"AlgorithmParameterSpec  for initializing a  KeyPairGenerator  or a
  KeyGenerator  of the  Android Keystore
 system . The spec determines authorized uses of the key such as whether user authentication
 is required for using the key what operations are authorized (e.g. signing but not
 decryption) with what parameters (e.g. only with a particular padding scheme or digest) and
 the key's validity start and end dates. Key use authorizations expressed in the spec apply
 only to secret keys and private keys -- public keys can be used for any supported operations.

  To generate an asymmetric key pair or a symmetric key create an instance of this class using
 the  Builder  initialize a  KeyPairGenerator  or a  KeyGenerator  of the
 desired key type (e.g.  EC  or  AES  -- see
  KeyProperties . KEY_ALGORITHM  constants) from the  AndroidKeyStore  provider
 with the  KeyGenParameterSpec  instance and then generate a key or key pair using
  KeyGenerator#generateKey()  or  KeyPairGenerator#generateKeyPair() .

  The generated key pair or key will be returned by the generator and also stored in the Android
 Keystore under the alias specified in this spec. To obtain the secret or private key from the
 Android Keystore use  KeyStore.getKey(String null) 
 or  KeyStore.getEntry(String null) .
 To obtain the public key from the Android Keystore use
  KeyStore.getCertificate(String)  and then
  Certificate#getPublicKey() .

  To help obtain algorithm-specific public parameters of key pairs stored in the Android
 Keystore generated private keys implement  ECKey  or
  RSAKey  interfaces whereas public keys implement
  ECPublicKey  or  RSAPublicKey 
 interfaces.

  For asymmetric key pairs a self-signed X.509 certificate will be also generated and stored in
 the Android Keystore. This is because the  KeyStore  abstraction does not
 support storing key pairs without a certificate. The subject serial number and validity dates
 of the certificate can be customized in this spec. The self-signed certificate may be replaced at
 a later time by a certificate signed by a Certificate Authority (CA).

  NOTE: If a private key is not authorized to sign the self-signed certificate then the
 certificate will be created with an invalid signature which will not verify. Such a certificate
 is still useful because it provides access to the public key. To generate a valid signature for
 the certificate the key needs to be authorized for all of the following:
  KeyProperties#PURPOSE_SIGN  operation without requiring the user to be authenticated (see
  Builder#setUserAuthenticationRequired(boolean) ) signing/origination at this moment in time (see  Builder#setKeyValidityStart(Date) 
 and  Builder#setKeyValidityForOriginationEnd(Date) ) suitable digest (RSA keys only) padding scheme  KeyProperties#SIGNATURE_PADDING_RSA_PKCS1 . NOTE: The key material of the generated symmetric and private keys is not accessible. The key
 material of the public keys is accessible.

  Instances of this class are immutable.

  Known issues PublicKey unrestrictedPublicKey =
         KeyFactory.getInstance(publicKey.getAlgorithm()).generatePublic(
                 new X509EncodedKeySpec(publicKey.getEncoded()));
  Example: NIST P-256 EC key pair for signing/verification using ECDSA key1 KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(
         KeyProperties.KEY_ALGORITHM_EC ""AndroidKeyStore"");
 keyPairGenerator.initialize(
         new KeyGenParameterSpec.Builder(
                 ""key1""
                 KeyProperties.PURPOSE_SIGN)
                 .setAlgorithmParameterSpec(new ECGenParameterSpec(""secp256r1""))
                 .setDigests(KeyProperties.DIGEST_SHA256
                         KeyProperties.DIGEST_SHA384
                         KeyProperties.DIGEST_SHA512)
                 // Only permit the private key to be used if the user authenticated
                 // within the last five minutes.
                 .setUserAuthenticationRequired(true)
                 .setUserAuthenticationValidityDurationSeconds(5 * 60)
                 .build());
 KeyPair keyPair = keyPairGenerator.generateKeyPair();
 Signature signature = Signature.getInstance(""SHA256withECDSA"");
 signature.initSign(keyPair.getPrivate());
 ...

 // The key pair can also be obtained from the Android Keystore any time as follows:
 KeyStore keyStore = KeyStore.getInstance(""AndroidKeyStore"");
 keyStore.load(null);
 PrivateKey privateKey = (PrivateKey) keyStore.getKey(""key1"" null);
 PublicKey publicKey = keyStore.getCertificate(""key1"").getPublicKey();
  Example: RSA key pair for signing/verification using RSA-PSS key1 KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(
         KeyProperties.KEY_ALGORITHM_RSA ""AndroidKeyStore"");
 keyPairGenerator.initialize(
         new KeyGenParameterSpec.Builder(
                 ""key1""
                 KeyProperties.PURPOSE_SIGN)
                 .setDigests(KeyProperties.DIGEST_SHA256 KeyProperties.DIGEST_SHA512)
                 .setSignaturePaddings(KeyProperties.SIGNATURE_PADDING_RSA_PSS)
                 .build());
 KeyPair keyPair = keyPairGenerator.generateKeyPair();
 Signature signature = Signature.getInstance(""SHA256withRSA/PSS"");
 signature.initSign(keyPair.getPrivate());
 ...

 // The key pair can also be obtained from the Android Keystore any time as follows:
 KeyStore keyStore = KeyStore.getInstance(""AndroidKeyStore"");
 keyStore.load(null);
 PrivateKey privateKey = (PrivateKey) keyStore.getKey(""key1"" null);
 PublicKey publicKey = keyStore.getCertificate(""key1"").getPublicKey();
  Example: RSA key pair for encryption/decryption using RSA OAEP key1 KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(
         KeyProperties.KEY_ALGORITHM_RSA ""AndroidKeyStore"");
 keyPairGenerator.initialize(
         new KeyGenParameterSpec.Builder(
                 ""key1""
                 KeyProperties.PURPOSE_DECRYPT)
                 .setDigests(KeyProperties.DIGEST_SHA256 KeyProperties.DIGEST_SHA512)
                 .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_RSA_OAEP)
                 .build());
 KeyPair keyPair = keyPairGenerator.generateKeyPair();
 Cipher cipher = Cipher.getInstance(""RSA/ECB/OAEPWithSHA-256AndMGF1Padding"");
 cipher.init(Cipher.DECRYPT_MODE keyPair.getPrivate());
 ...

 // The key pair can also be obtained from the Android Keystore any time as follows:
 KeyStore keyStore = KeyStore.getInstance(""AndroidKeyStore"");
 keyStore.load(null);
 PrivateKey privateKey = (PrivateKey) keyStore.getKey(""key1"" null);
 PublicKey publicKey = keyStore.getCertificate(""key1"").getPublicKey();
  Example: AES key for encryption/decryption in GCM mode key2 KeyGenerator keyGenerator = KeyGenerator.getInstance(
         KeyProperties.KEY_ALGORITHM_AES ""AndroidKeyStore"");
 keyGenerator.init(
         new KeyGenParameterSpec.Builder(""key2""
                 KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT)
                 .setBlockModes(KeyProperties.BLOCK_MODE_GCM)
                 .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE)
                 .build());
 SecretKey key = keyGenerator.generateKey();

 Cipher cipher = Cipher.getInstance(""AES/GCM/NoPadding"");
 cipher.init(Cipher.ENCRYPT_MODE key);
 ...

 // The key can also be obtained from the Android Keystore any time as follows:
 KeyStore keyStore = KeyStore.getInstance(""AndroidKeyStore"");
 keyStore.load(null);
 key = (SecretKey) keyStore.getKey(""key2"" null);
  Example: HMAC key for generating a MAC using SHA-256 key2 KeyGenerator keyGenerator = KeyGenerator.getInstance(
         KeyProperties.KEY_ALGORITHM_HMAC_SHA256 ""AndroidKeyStore"");
 keyGenerator.init(
         new KeyGenParameterSpec.Builder(""key2"" KeyProperties.PURPOSE_SIGN).build());
 SecretKey key = keyGenerator.generateKey();
 Mac mac = Mac.getInstance(""HmacSHA256"");
 mac.init(key);
 ...

 // The key can also be obtained from the Android Keystore any time as follows:
 KeyStore keyStore = KeyStore.getInstance(""AndroidKeyStore"");
 keyStore.load(null);
 key = (SecretKey) keyStore.getKey(""key2"" null);"
android,security.keystore,KeyGenParameterSpec.Builder,25,Builder of  KeyGenParameterSpec  instances.
android,security.keystore,KeyInfo,19,"Information about a key from the  Android
 Keystore system . This class describes whether the key material is available in
 plaintext outside of secure hardware whether user authentication is required for using the key
 and whether this requirement is enforced by secure hardware the key's origin what uses the key
 is authorized for (e.g. only in  GCM  mode or signing only) whether the key should be
 encrypted at rest the key's and validity start and end dates.

  Instances of this class are immutable.

  Example: Symmetric Key KeyInfo SecretKey SecretKey key = ...; // Android Keystore key

 SecretKeyFactory factory = SecretKeyFactory.getInstance(key.getAlgorithm() ""AndroidKeyStore"");
 KeyInfo keyInfo;
 try {
     keyInfo = (KeyInfo) factory.getKeySpec(key KeyInfo.class);
 } catch (InvalidKeySpecException e) {
     // Not an Android KeyStore key.
 } Example: Private Key KeyInfo PrivateKey PrivateKey key = ...; // Android KeyStore key

 KeyFactory factory = KeyFactory.getInstance(key.getAlgorithm() ""AndroidKeyStore"");
 KeyInfo keyInfo;
 try {
     keyInfo = factory.getKeySpec(key KeyInfo.class);
 } catch (InvalidKeySpecException e) {
     // Not an Android KeyStore key.
 }"
android,security.keystore,KeyProperties,0,Properties of  Android Keystore  keys.
android,security.keystore,KeyProtection,17,"Specification of how a key or key pair is secured when imported into the
  Android Keystore system . This class
 specifies authorized uses of the imported key such as whether user authentication is required
 for using the key what operations the key is authorized for (e.g. decryption but not signing)
 with what parameters (e.g. only with a particular padding scheme or digest) and the key's
 validity start and end dates. Key use authorizations expressed in this class apply only to secret
 keys and private keys -- public keys can be used for any supported operations.

  To import a key or key pair into the Android Keystore create an instance of this class using
 the  Builder  and pass the instance into  KeyStore.setEntry 
 with the key or key pair being imported.

  To obtain the secret/symmetric or private key from the Android Keystore use
  KeyStore.getKey(String null)  or
  KeyStore.getEntry(String null) .
 To obtain the public key from the Android Keystore use
  KeyStore.getCertificate(String)  and then
  Certificate#getPublicKey() .

  To help obtain algorithm-specific public parameters of key pairs stored in the Android
 Keystore its private keys implement  ECKey  or
  RSAKey  interfaces whereas its public keys implement
  ECPublicKey  or  RSAPublicKey 
 interfaces.

  NOTE: The key material of keys stored in the Android Keystore is not accessible.

  Instances of this class are immutable.

  Known issues PublicKey unrestrictedPublicKey =
         KeyFactory.getInstance(publicKey.getAlgorithm()).generatePublic(
                 new X509EncodedKeySpec(publicKey.getEncoded()));
  Example: AES key for encryption/decryption in GCM mode key1 Key#getEncoded() RAW SecretKey key = ...; // AES key

 KeyStore keyStore = KeyStore.getInstance(""AndroidKeyStore"");
 keyStore.load(null);
 keyStore.setEntry(
         ""key1""
         new KeyStore.SecretKeyEntry(key)
         new KeyProtection.Builder(KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT)
                 .setBlockMode(KeyProperties.BLOCK_MODE_GCM)
                 .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE)
                 .build());
 // Key imported obtain a reference to it.
 SecretKey keyStoreKey = (SecretKey) keyStore.getKey(""key1"" null);
 // The original key can now be discarded.

 Cipher cipher = Cipher.getInstance(""AES/GCM/NoPadding"");
 cipher.init(Cipher.ENCRYPT_MODE keyStoreKey);
 ...
  Example: HMAC key for generating MACs using SHA-512 key1 Key#getEncoded() RAW SecretKey key = ...; // HMAC key of algorithm ""HmacSHA512"".

 KeyStore keyStore = KeyStore.getInstance(""AndroidKeyStore"");
 keyStore.load(null);
 keyStore.setEntry(
         ""key1""
         new KeyStore.SecretKeyEntry(key)
         new KeyProtection.Builder(KeyProperties.PURPOSE_SIGN).build());
 // Key imported obtain a reference to it.
 SecretKey keyStoreKey = (SecretKey) keyStore.getKey(""key1"" null);
 // The original key can now be discarded.

 Mac mac = Mac.getInstance(""HmacSHA512"");
 mac.init(keyStoreKey);
 ...
  Example: EC key pair for signing/verification using ECDSA key2 Key#getEncoded() PKCS#8 X.509 PrivateKey privateKey = ...;   // EC private key
 Certificate[] certChain = ...; // Certificate chain with the first certificate
                                // containing the corresponding EC public key.

 KeyStore keyStore = KeyStore.getInstance(""AndroidKeyStore"");
 keyStore.load(null);
 keyStore.setEntry(
         ""key2""
         new KeyStore.PrivateKeyEntry(privateKey certChain)
         new KeyProtection.Builder(KeyProperties.PURPOSE_SIGN)
                 .setDigests(KeyProperties.DIGEST_SHA256 KeyProperties.DIGEST_SHA512)
                 .build());
 // Key pair imported obtain a reference to it.
 PrivateKey keyStorePrivateKey = (PrivateKey) keyStore.getKey(""key2"" null);
 PublicKey publicKey = keyStore.getCertificate(""key2"").getPublicKey();
 // The original private key can now be discarded.

 Signature signature = Signature.getInstance(""SHA256withECDSA"");
 signature.initSign(keyStorePrivateKey);
 ...
  Example: RSA key pair for signing/verification using PKCS#1 padding key2 Key#getEncoded() PKCS#8 X.509 PrivateKey privateKey = ...;   // RSA private key
 Certificate[] certChain = ...; // Certificate chain with the first certificate
                                // containing the corresponding RSA public key.

 KeyStore keyStore = KeyStore.getInstance(""AndroidKeyStore"");
 keyStore.load(null);
 keyStore.setEntry(
         ""key2""
         new KeyStore.PrivateKeyEntry(privateKey certChain)
         new KeyProtection.Builder(KeyProperties.PURPOSE_SIGN)
                 .setDigests(KeyProperties.DIGEST_SHA256)
                 .setSignaturePaddings(KeyProperties.SIGNATURE_PADDING_RSA_PKCS1)
                 // Only permit this key to be used if the user
                 // authenticated within the last ten minutes.
                 .setUserAuthenticationRequired(true)
                 .setUserAuthenticationValidityDurationSeconds(10 * 60)
                 .build());
 // Key pair imported obtain a reference to it.
 PrivateKey keyStorePrivateKey = (PrivateKey) keyStore.getKey(""key2"" null);
 PublicKey publicKey = keyStore.getCertificate(""key2"").getPublicKey();
 // The original private key can now be discarded.

 Signature signature = Signature.getInstance(""SHA256withRSA"");
 signature.initSign(keyStorePrivateKey);
 ...
  Example: RSA key pair for encryption/decryption using PKCS#1 padding key2 Key#getEncoded() PKCS#8 X.509 PrivateKey privateKey = ...;   // RSA private key
 Certificate[] certChain = ...; // Certificate chain with the first certificate
                                // containing the corresponding RSA public key.

 KeyStore keyStore = KeyStore.getInstance(""AndroidKeyStore"");
 keyStore.load(null);
 keyStore.setEntry(
         ""key2""
         new KeyStore.PrivateKeyEntry(privateKey certChain)
         new KeyProtection.Builder(KeyProperties.PURPOSE_DECRYPT)
                 .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_RSA_PKCS1)
                 .build());
 // Key pair imported obtain a reference to it.
 PrivateKey keyStorePrivateKey = (PrivateKey) keyStore.getKey(""key2"" null);
 PublicKey publicKey = keyStore.getCertificate(""key2"").getPublicKey();
 // The original private key can now be discarded.

 Cipher cipher = Cipher.getInstance(""RSA/ECB/PKCS1Padding"");
 cipher.init(Cipher.DECRYPT_MODE keyStorePrivateKey);
 ..."
android,security.keystore,KeyProtection.Builder,17,Builder of  KeyProtection  instances.
android,security.keystore,WrappedKeyEntry,4,"An  Entry  that holds a wrapped key. Wrapped keys contain encrypted key data and
 description information that can be used to securely import key material into a hardware-backed
 Keystore.

  
   The wrapped key is in DER-encoded ASN.1 format specified by the following schema:
  
     KeyDescription ::= SEQUENCE(
         keyFormat INTEGER                   # Values from KeyFormat enum.
         keyParams AuthorizationList
     )

     SecureKeyWrapper ::= SEQUENCE(
         version INTEGER                     # Contains value 0
         encryptedTransportKey OCTET_STRING
         initializationVector OCTET_STRING
         keyDescription KeyDescription
         encryptedKey OCTET_STRING
         tag OCTET_STRING
     )
  keyFormat is an integer from the KeyFormat enum defining the format of the plaintext
       key material.
      keyParams is the characteristics of the key to be imported (as with generateKey or
       importKey).  If the secure import is successful these characteristics must be
       associated with the key exactly as if the key material had been insecurely imported
       with importKey. See  Key Attestation  for the AuthorizationList format.
      encryptedTransportKey is a 256-bit AES key XORed with a masking key and then encrypted
       in RSA-OAEP mode (SHA-256 digest SHA-1 MGF1 digest) with the wrapping key specified by
       wrappingKeyBlob.
      keyDescription is a KeyDescription above.
      encryptedKey is the key material of the key to be imported in format keyFormat and
       encrypted with encryptedEphemeralKey in AES-GCM mode with the DER-encoded
       representation of keyDescription provided as additional authenticated data.
      tag is the tag produced by the AES-GCM encryption of encryptedKey.
      
     Imported wrapped keys will have KeymasterDefs.KM_ORIGIN_SECURELY_IMPORTED"
android,service.carrier,CarrierIdentifier,13,"Used to pass info to CarrierConfigService implementations so they can decide what values to
 return. Instead of passing mcc mnc gid1 gid2 spn imsi to locate carrier information
 CarrierIdentifier also include carrier id  TelephonyManager#getSimCarrierId() 
 a platform-wide unique identifier for each carrier. CarrierConfigService can directly use
 carrier id as the key to look up the carrier info."
android,service.carrier,CarrierMessagingClientService,1,"If the default SMS app has a service that extends this class the system always tries to bind
 it so that the process is always running which allows the app to have a persistent connection
 to the server.

  The service must have an
  TelephonyManager.ACTION_CARRIER_MESSAGING_CLIENT_SERVICE 
 action in the intent handler and be protected with
  Manifest.permission.BIND_CARRIER_MESSAGING_CLIENT_SERVICE .
 However the service does not have to be exported.

  The service must be associated with a non-main process meaning it must have an
  android:process  tag in its manifest entry.

  An app can use
  PackageManager.setComponentEnabledSetting(ComponentName int int) 
 to disable or enable the service. An app should use it to disable the service when it no longer
 needs to be running.

  When the owner process crashes the service will be re-bound automatically after a
 back-off.

  Note the process may still be killed if the system is under heavy memory pressure in which
 case the process will be re-started later.

  Example: First define a subclass in the application:
  
 public class MyCarrierMessagingClientService extends CarrierMessagingClientService {
 }
  AndroidManifest.xml 
 <service
    android:name="".MyCarrierMessagingClientService""
    android:exported=""false""
    android:process="":persistent""
    android:permission=""android.permission.BIND_CARRIER_MESSAGING_CLIENT_SERVICE"">
    <intent-filter>
        <action android:name=""android.telephony.action.CARRIER_MESSAGING_CLIENT_SERVICE"" />
    </intent-filter>
 </service>"
android,service.carrier,CarrierMessagingService,11,"A service that receives calls from the system when new SMS and MMS are
 sent or received.
  To extend this class you must declare the service in your manifest file with
 the  Manifest.permission.BIND_CARRIER_SERVICES  permission
 and include an intent filter with the  SERVICE_INTERFACE  action. For example: 
 <service android:name="".MyMessagingService""
          android:label=""@string/service_name""
          android:permission=""android.permission.BIND_CARRIER_SERVICES"">
     <intent-filter>
         <action android:name=""android.service.carrier.CarrierMessagingService"" />
     </intent-filter>
 </service>"
android,service.carrier,CarrierMessagingService.SendMmsResult,2,The result of sending an MMS.
android,service.carrier,CarrierMessagingService.SendMultipartSmsResult,2,The result of sending a multipart SMS.
android,service.carrier,CarrierMessagingService.SendSmsResult,2,The result of sending an SMS.
android,service.carrier,CarrierService,3,"A service that exposes carrier-specific functionality to the system.
  
 To extend this class you must declare the service in your manifest file to require the
  Manifest.permission.BIND_CARRIER_SERVICES  permission and include an intent
 filter with the  CARRIER_SERVICE_INTERFACE . If the service should have a long-lived
 binding set  android.service.carrier.LONG_LIVED_BINDING  to  true  in the
 service's metadata. For example:
  <service android:name="".MyCarrierService""
       android:label=""@string/service_name""
       android:permission=""android.permission.BIND_CARRIER_SERVICES"">
  <intent-filter>
      <action android:name=""android.service.carrier.CarrierService"" />
  </intent-filter>
  <meta-data android:name=""android.service.carrier.LONG_LIVED_BINDING""
             android:value=""true"" />
 </service>"
android,service.carrier,MessagePdu,3,A parcelable list of PDUs representing contents of a possibly multi-part SMS.
android,service.dreams,DreamService,46,"Extend this class to implement a custom dream (available to the user as a ""Daydream"").

  Dreams are interactive screensavers launched when a charging device is idle or docked in a
 desk dock. Dreams provide another modality for apps to express themselves tailored for
 an exhibition/lean-back experience. The  DreamService  lifecycle is as follows: onAttachedToWindow() Use this for initial setup such as calling  setContentView() . onDreamingStarted() Your dream has started so you should begin animations or other behaviors here. onDreamingStopped() Use this to stop the things you started in  onDreamingStarted() . onDetachedFromWindow() Use this to dismantle resources (for example detach from handlers
        and listeners). In addition onCreate and onDestroy (from the Service interface) will also be called but
 initialization and teardown should be done by overriding the hooks above. To be available to the system your  DreamService  should be declared in the
 manifest as follows: 
 <service
     android:name="".MyDream""
     android:exported=""true""
     android:icon=""@drawable/my_icon""
     android:label=""@string/my_dream_label"" >

     <intent-filter>
         <action android:name=""android.service.dreams.DreamService"" />
         <category android:name=""android.intent.category.DEFAULT"" />
     </intent-filter>

     <!-- Point to additional information for this dream (optional) -->
     <meta-data
         android:name=""android.service.dream""
         android:resource=""@xml/my_dream"" />
 </service>
  If specified with the  <meta-data>  element
 additional information for the dream is defined using the
  <dream>  element in a separate XML file.
 Currently the only addtional
 information you can provide is for a settings activity that allows the user to configure
 the dream behavior. For example: res/xml/my_dream.xml 
 <dream xmlns:android=""http://schemas.android.com/apk/res/android""
     android:settingsActivity=""com.example.app/.MyDreamSettingsActivity"" />
  This makes a Settings button available alongside your dream's listing in the
 system settings which when pressed opens the specified activity. To specify your dream layout call  setContentView(View)  typically during the
  onAttachedToWindow()  callback. For example: 
 public class MyDream extends DreamService {

     @Override
     public void onAttachedToWindow() {
         super.onAttachedToWindow();

         // Exit dream upon user touch
         setInteractive(false);
         // Hide system UI
         setFullscreen(true);
         // Set the dream layout
         setContentView(R.layout.dream);
     }
 }
  When targeting api level 21 and above you must declare the service in your manifest file
 with the  Manifest.permission.BIND_DREAM_SERVICE  permission. For example: 
 <service
     android:name="".MyDream""
     android:exported=""true""
     android:icon=""@drawable/my_icon""
     android:label=""@string/my_dream_label""
     android:permission=""android.permission.BIND_DREAM_SERVICE"">
   <intent-filter>
     <action android:name=â€android.service.dreams.DreamServiceâ€ />
     <category android:name=â€android.intent.category.DEFAULTâ€ />
   </intent-filter>
 </service>"
android,service.media,CameraPrewarmService,4,"Extend this class to implement a camera prewarm service. See
  MediaStore.META_DATA_STILL_IMAGE_CAMERA_PREWARM_SERVICE ."
android,service.media,MediaBrowserService,13,"Base class for media browser services.
  
 Media browser services enable applications to browse media content provided by an application
 and ask the application to start playing it. They may also be used to control content that
 is already playing by way of a  MediaSession .
  SERVICE_INTERFACE 
 <service android:name="".MyMediaBrowserService""
          android:label=""@string/service_name"" >
     <intent-filter>
         <action android:name=""android.media.browse.MediaBrowserService"" />
     </intent-filter>
 </service>"
android,service.media,MediaBrowserService.BrowserRoot,2,"Contains information that the browser service needs to send to the client
 when first connected."
android,service.media,MediaBrowserService.Result,2,"Completion handler for asynchronous callback methods in  MediaBrowserService .
  
 Each of the methods that takes one of these to send the result must call
  sendResult(T)  to respond to the caller with the given results. If those
 functions return without calling  sendResult(T)  they must instead call
  detach()  before returning and then may call  sendResult(T)  when
 they are done. If more than one of those methods is called an exception will
 be thrown."
android,service.notification,Condition,10,"The current condition of an  AutomaticZenRule  provided by the
 app that owns the rule. Used to tell the system to enter Do Not
 Disturb mode and request that the system exit Do Not Disturb mode."
android,service.notification,ConditionProviderService,9,"A service that provides conditions about boolean state.
  To extend this class you must declare the service in your manifest file with
 the  Manifest.permission.BIND_CONDITION_PROVIDER_SERVICE  permission
 and include an intent filter with the  SERVICE_INTERFACE  action. If you want users to be
 able to create and update conditions for this service to monitor include the
  META_DATA_RULE_TYPE  and  META_DATA_CONFIGURATION_ACTIVITY  tags and request the
  Manifest.permission.ACCESS_NOTIFICATION_POLICY  permission. For example: 
 <service android:name="".MyConditionProvider""
          android:label=""@string/service_name""
          android:permission=""android.permission.BIND_CONDITION_PROVIDER_SERVICE"">
     <intent-filter>
         <action android:name=""android.service.notification.ConditionProviderService"" />
     </intent-filter>
     <meta-data
               android:name=""android.service.zen.automatic.ruleType""
               android:value=""@string/my_condition_rule"">
           </meta-data>
           <meta-data
               android:name=""android.service.zen.automatic.configurationActivity""
               android:value=""com.my.package/.MyConditionConfigurationActivity"">
           </meta-data>
 </service>  Condition providers cannot be bound by the system on
  ActivityManager#isLowRamDevice()  devices"
android,service.notification,NotificationListenerService,36,"A service that receives calls from the system when new notifications are
 posted or removed or their ranking changed.
  To extend this class you must declare the service in your manifest file with
 the  Manifest.permission.BIND_NOTIFICATION_LISTENER_SERVICE  permission
 and include an intent filter with the  SERVICE_INTERFACE  action. For example: 
 <service android:name="".NotificationListener""
          android:label=""@string/service_name""
          android:permission=""android.permission.BIND_NOTIFICATION_LISTENER_SERVICE"">
     <intent-filter>
         <action android:name=""android.service.notification.NotificationListenerService"" />
     </intent-filter>
 </service> The service should wait for the  onListenerConnected()  event
 before performing any operations. The  requestRebind(android.content.ComponentName) 
 method is the  only  one that is safe to call before  onListenerConnected() 
 or after  onListenerDisconnected() .
   Notification listeners cannot get notification access or be bound by the system on
  ActivityManager#isLowRamDevice()  devices. The system also ignores
 notification listeners running in a work profile. A
  DevicePolicyManager  might block notifications originating from a work
 profile. 
     From  Build.VERSION_CODES#N  onward all callbacks are called on the main thread. Prior
     to N there is no guarantee on what thread the callback will happen."
android,service.notification,NotificationListenerService.Ranking,17,"Stores ranking related information on a currently active notification.

  
 Ranking objects aren't automatically updated as notification events
 occur. Instead ranking information has to be retrieved again via the
 current  RankingMap ."
android,service.notification,NotificationListenerService.RankingMap,5,"Provides access to ranking information on currently active
 notifications.

  
 Note that this object represents a ranking snapshot that only applies to
 notifications active at the time of retrieval."
android,service.notification,StatusBarNotification,20,"Class encapsulating a Notification. Sent by the NotificationManagerService to clients including
 the status bar and any  NotificationListenerService s."
android,service.notification,ZenPolicy,22,"ZenPolicy determines whether to allow certain notifications and their corresponding sounds to
 play when a device is in Do Not Disturb mode.
 ZenPolicy also dictates the visual effects of notifications that are intercepted when
 a device is in Do Not Disturb mode."
android,service.notification,ZenPolicy.Builder,20,"Builder class for  ZenPolicy  objects.
 Provides a convenient way to set the various fields of a  ZenPolicy .  If a field
 is not set it is (@link STATE_UNSET} and will not change the current set policy."
android,service.quicksettings,Tile,13,"A Tile holds the state of a tile that will be displayed
 in Quick Settings.

 A tile in Quick Settings exists as an icon with an accompanied label.
 It also may have content description for accessibility usability.
 The style and layout of the tile may change to match a given
 device."
android,service.quicksettings,TileService,14,"A TileService provides the user a tile that can be added to Quick Settings.
 Quick Settings is a space provided that allows the user to change settings and
 take quick actions without leaving the context of their current app.

  The lifecycle of a TileService is different from some other services in
 that it may be unbound during parts of its lifecycle.  Any of the following
 lifecycle events can happen indepently in a separate binding/creation of the
 service. When a tile is added by the user its TileService will be bound to and
  onTileAdded()  will be called. When a tile should be up to date and listing will be indicated by
  onStartListening()  and  onStopListening() . When the user removes a tile from Quick Settings  onTileRemoved() 
 will be called. TileService will be detected by tiles that match the  .ACTION_QS_TILE 
 and require the permission ""android.permission.BIND_QUICK_SETTINGS_TILE"".
 The label and icon for the service will be used as the default label and
 icon for the tile. Here is an example TileService declaration. 
 <service
     android:name="".MyQSTileService""
     android:label=""@string/my_default_tile_label""
     android:icon=""@drawable/my_default_icon_label""
     android:permission=""android.permission.BIND_QUICK_SETTINGS_TILE"">
     <intent-filter>
         <action android:name=""android.service.quicksettings.action.QS_TILE"" />
     </intent-filter>
 </service>"
android,service.autofill,AutofillService,7,"An  AutofillService  is a service used to automatically fill the contents of the screen
 on behalf of a given user - for more information about autofill read
  Autofill Framework .

  An  AutofillService  is only bound to the Android System for autofill purposes if:
  It requires the  android.permission.BIND_AUTOFILL_SERVICE  permission in its
       manifest.
    The user explicitly enables it using Android Settings (the
        Settings#ACTION_REQUEST_SET_AUTOFILL_SERVICE  intent can be used to launch such
       Settings screen).
  Basic usage The basic autofill process is defined by the workflow below:
  User focus an editable  View .
    View calls  AutofillManager#notifyViewEntered(android.view.View) .
    A  ViewStructure  representing all views in the screen is created.
    The Android System binds to the service and calls  onConnected() .
    The service receives the view structure through the
        onFillRequest(android.service.autofill.FillRequest android.os.CancellationSignal android.service.autofill.FillCallback) .
    The service replies through  FillCallback#onSuccess(FillResponse) .
    The Android System calls  onDisconnected()  and unbinds from the
        AutofillService .
    The Android System displays an autofill UI with the options sent by the service.
    The user picks an option.
    The proper views are autofilled.
  This workflow was designed to minimize the time the Android System is bound to the service;
 for each call it: binds to service waits for the reply and unbinds right away. Furthermore
 those calls are considered stateless: if the service needs to keep state between calls it must
 do its own state management (keeping in mind that the service's process might be killed by the
 Android System when unbound; for example if the device is running low in memory).

  Typically the
  onFillRequest(android.service.autofill.FillRequest android.os.CancellationSignal android.service.autofill.FillCallback)  will:
  Parse the view structure looking for autofillable views (for example using
        AssistStructure.ViewNode.getAutofillHints() .
    Match the autofillable views with the user's data.
    Create a  Dataset  for each set of user's data that match those fields.
    Fill the dataset(s) with the proper  AutofillId s and  AutofillValue s.
    Add the dataset(s) to the  FillResponse  passed to
        FillCallback#onSuccess(FillResponse) .
  For example for a login screen with username and password views where the user only has one
 account in the service the response could be:

  
 new FillResponse.Builder()
     .addDataset(new Dataset.Builder()
         .setValue(id1 AutofillValue.forText(""homer"") createPresentation(""homer""))
         .setValue(id2 AutofillValue.forText(""D'OH!"") createPresentation(""password for homer""))
         .build())
     .build();
  But if the user had 2 accounts instead the response could be:

  
 new FillResponse.Builder()
     .addDataset(new Dataset.Builder()
         .setValue(id1 AutofillValue.forText(""homer"") createPresentation(""homer""))
         .setValue(id2 AutofillValue.forText(""D'OH!"") createPresentation(""password for homer""))
         .build())
     .addDataset(new Dataset.Builder()
         .setValue(id1 AutofillValue.forText(""flanders"") createPresentation(""flanders""))
         .setValue(id2 AutofillValue.forText(""OkelyDokelyDo"") createPresentation(""password for flanders""))
         .build())
     .build();
  If the service does not find any autofillable view in the view structure it should pass
  null  to  FillCallback#onSuccess(FillResponse) ; if the service encountered an error
 processing the request it should call  FillCallback#onFailure(CharSequence) . For
 performance reasons it's paramount that the service calls either
  FillCallback#onSuccess(FillResponse)  or  FillCallback#onFailure(CharSequence)  for
 each  onFillRequest(android.service.autofill.FillRequest android.os.CancellationSignal android.service.autofill.FillCallback)  received - if it
 doesn't the request will eventually time out and be discarded by the Android System.

  Saving user data If the service is also interested on saving the data filled by the user it must set a
  SaveInfo  object in the  FillResponse . See  SaveInfo  for more details and
 examples.

  User authentication The service can provide an extra degree of security by requiring the user to authenticate
 before an app can be autofilled. The authentication is typically required in 2 scenarios:
  To unlock the user data (for example using a master password or fingerprint
       authentication) - see
  FillResponse.Builder#setAuthentication(AutofillId[] android.content.IntentSender android.widget.RemoteViews) .
    To unlock a specific dataset (for example by providing a CVC for a credit card) - see
        Dataset.Builder#setAuthentication(android.content.IntentSender) .
  When using authentication it is recommended to encrypt only the sensitive data and leave
 labels unencrypted so they can be used on presentation views. For example if the user has a
 home and a work address the  Home  and  Work  labels should be stored unencrypted
 (since they don't have any sensitive data) while the address data per se could be stored in an
 encrypted storage. Then when the user chooses the  Home  dataset the platform starts
 the authentication flow and the service can decrypt the sensitive data.

  The authentication mechanism can also be used in scenarios where the service needs multiple
 steps to determine the datasets that can fill a screen. For example when autofilling a financial
 app where the user has accounts for multiple banks the workflow could be:

  The first  FillResponse  contains datasets with the credentials for the financial
       app plus a ""fake"" dataset whose presentation says ""Tap here for banking apps credentials"".
    When the user selects the fake dataset the service displays a dialog with available
       banking apps.
    When the user select a banking app the service replies with a new  FillResponse 
       containing the datasets for that bank.
  Another example of multiple-steps dataset selection is when the service stores the user
 credentials in ""vaults"": the first response would contain fake datasets with the vault names
 and the subsequent response would contain the app credentials stored in that vault.

  Data partitioning The autofillable views in a screen should be grouped in logical groups called ""partitions"".
 Typical partitions are:
  Credentials (username/email address password).
    Address (street city state zip code etc).
    Payment info (credit card number expiration date and verification code).
  For security reasons when a screen has more than one partition it's paramount that the
 contents of a dataset do not spawn multiple partitions specially when one of the partitions
 contains data that is not specific to the application being autofilled. For example a dataset
 should not contain fields for username password and credit card information. The reason for
 this rule is that a malicious app could draft a view structure where the credit card fields
 are not visible so when the user selects a dataset from the username UI the credit card info is
 released to the application without the user knowledge. Similarly it's recommended to always
 protect a dataset that contains sensitive information by requiring dataset authentication
 (see  Dataset.Builder#setAuthentication(android.content.IntentSender) ) and to include
 info about the ""primary"" field of the partition in the custom presentation for ""secondary""
 fieldsâ€”that would prevent a malicious app from getting the ""primary"" fields without the
 user realizing they're being released (for example a malicious app could have fields for a
 credit card number verification code and expiration date crafted in a way that just the latter
 is visible; by explicitly indicating the expiration date is related to a given credit card
 number the service would be providing a visual clue for the users to check what would be
 released upon selecting that field).

  When the service detects that a screen has multiple partitions it should return a
  FillResponse  with just the datasets for the partition that originated the request (i.e.
 the partition that has the  AssistStructure.ViewNode  whose
  AssistStructure.ViewNode.isFocused()  returns  true ); then if
 the user selects a field from a different partition the Android System will make another
  onFillRequest(android.service.autofill.FillRequest android.os.CancellationSignal android.service.autofill.FillCallback)  call for that partition
 and so on.

  Notice that when the user autofill a partition with the data provided by the service and the
 user did not change these fields the autofilled value is sent back to the service in the
 subsequent calls (and can be obtained by calling
  AssistStructure.ViewNode.getAutofillValue() ). This is useful in the
 cases where the service must create datasets for a partition based on the choice made in a
 previous partition. For example the 1st response for a screen that have credentials and address
 partitions could be:

  
 new FillResponse.Builder()
     .addDataset(new Dataset.Builder() // partition 1 (credentials)
         .setValue(id1 AutofillValue.forText(""homer"") createPresentation(""homer""))
         .setValue(id2 AutofillValue.forText(""D'OH!"") createPresentation(""password for homer""))
         .build())
     .addDataset(new Dataset.Builder() // partition 1 (credentials)
         .setValue(id1 AutofillValue.forText(""flanders"") createPresentation(""flanders""))
         .setValue(id2 AutofillValue.forText(""OkelyDokelyDo"") createPresentation(""password for flanders""))
         .build())
     .setSaveInfo(new SaveInfo.Builder(SaveInfo.SAVE_DATA_TYPE_PASSWORD
         new AutofillId[] { id1 id2 })
             .build())
     .build();
  Then if the user selected  flanders  the service would get a new
  onFillRequest(android.service.autofill.FillRequest android.os.CancellationSignal android.service.autofill.FillCallback)  call with the values of
 the fields  id1  and  id2  prepopulated so the service could then fetch the address
 for the Flanders account and return the following  FillResponse  for the address partition:

  
 new FillResponse.Builder()
     .addDataset(new Dataset.Builder() // partition 2 (address)
         .setValue(id3 AutofillValue.forText(""744 Evergreen Terrace"") createPresentation(""744 Evergreen Terrace"")) // street
         .setValue(id4 AutofillValue.forText(""Springfield"") createPresentation(""Springfield"")) // city
         .build())
     .setSaveInfo(new SaveInfo.Builder(SaveInfo.SAVE_DATA_TYPE_PASSWORD | SaveInfo.SAVE_DATA_TYPE_ADDRESS
         new AutofillId[] { id1 id2 }) // username and password
              .setOptionalIds(new AutofillId[] { id3 id4 }) // state and zipcode
             .build())
     .build();
  When the service returns multiple  FillResponse  the last one overrides the previous;
 that's why the  SaveInfo  in the 2nd request above has the info for both partitions.

  Package verification When autofilling app-specific data (like username and password) the service must verify
 the authenticity of the request by obtaining all signing certificates of the app being
 autofilled and only fulfilling the request when they match the values that were
 obtained when the data was first saved â€” such verification is necessary to avoid phishing
 attempts by apps that were sideloaded in the device with the same package name of another app.
 Here's an example on how to achieve that by hashing the signing certificates:

  
 private String getCertificatesHash(String packageName) throws Exception {
   PackageManager pm = mContext.getPackageManager();
   PackageInfo info = pm.getPackageInfo(packageName PackageManager.GET_SIGNATURES);
   ArrayList  hashes = new ArrayList<>(info.signatures.length);
   for (Signature sig : info.signatures) {
     byte[] cert = sig.toByteArray();
     MessageDigest md = MessageDigest.getInstance(""SHA-256"");
     md.update(cert);
     hashes.add(toHexString(md.digest()));
   }
   Collections.sort(hashes);
   StringBuilder hash = new StringBuilder();
   for (int i = 0; i < hashes.size(); i++) {
     hash.append(hashes.get(i));
   }
   return hash.toString();
 }
  If the service did not store the signing certificates data the first time the data was saved
 â€” for example because the data was created by a previous version of the app that did not
 use the Autofill Framework â€” the service should warn the user that the authenticity of the
 app cannot be confirmed (see an example on how to show such warning in the
  Web security  section below) and if the user agrees
 then the service could save the data from the signing ceriticates for future use.

  Ignoring views If the service find views that cannot be autofilled (for example a text field representing
 the response to a Captcha challenge) it should mark those views as ignored by
 calling  FillResponse.Builder#setIgnoredIds(AutofillId...)  so the system does not trigger
 a new  onFillRequest(android.service.autofill.FillRequest android.os.CancellationSignal android.service.autofill.FillCallback)  when these views are
 focused.

  Web security When handling autofill requests that represent web pages (typically
 view structures whose root's  AssistStructure.ViewNode.getClassName() 
 is a  WebView ) the service should take the following steps to verify if
 the structure can be autofilled with the data associated with the app requesting it:

  Use the  AssistStructure.ViewNode.getWebDomain()  to get the
       source of the document.
    Get the canonical domain using the
        Public Suffix List  (see example below).
    Use  Digital Asset Links 
       to obtain the package name and certificate fingerprint of the package corresponding to
       the canonical domain.
    Make sure the certificate fingerprint matches the value returned by Package Manager
       (see ""Package verification"" section above).
  Here's an example on how to get the canonical domain using
  Guava :

  
 private static String getCanonicalDomain(String domain) {
   InternetDomainName idn = InternetDomainName.from(domain);
   while (idn != null && !idn.isTopPrivateDomain()) {
     idn = idn.parent();
   }
   return idn == null ? null : idn.toString();
 }
  If the association between the web domain and app package cannot be verified through the steps
 above but the service thinks that it is appropriate to fill persisted credentials that are
 stored for the web domain the service should warn the user about the potential data
 leakage first and ask for the user to confirm. For example the service could:

  Create a dataset that requires
        Dataset.Builder#setAuthentication(android.content.IntentSender)  to
       unlock.
    Include the web domain in the custom presentation for the
        Dataset.Builder#setValue(AutofillId AutofillValue android.widget.RemoteViews) .
    When the user selects that dataset show a disclaimer dialog explaining that the app is
       requesting credentials for a web domain but the service could not verify if the app owns
       that domain. If the user agrees then the service can unlock the dataset.
    Similarly when adding a  SaveInfo  object for the request the service should
       include the above disclaimer in the  SaveInfo.Builder#setDescription(CharSequence) .
  This same procedure could also be used when the autofillable data is contained inside an
  IFRAME  in which case the WebView generates a new autofill context when a node inside
 the  IFRAME  is focused with the root node containing the  IFRAME 's  src 
 attribute on  AssistStructure.ViewNode.getWebDomain() . A typical and
 legitimate use case for this scenario is a financial app that allows the user
 to login on different bank accounts. For example a financial app  my_financial_app  could
 use a WebView that loads contents from  banklogin.my_financial_app.com  which contains an
  IFRAME  node whose  src  attribute is  login.some_bank.com . When fulfilling
 that request the service could add an
  Dataset.Builder#setAuthentication(android.content.IntentSender) 
 whose presentation displays ""Username for some_bank.com"" and
 ""Password for some_bank.com"". Then when the user taps one of these options the service
 shows the disclaimer dialog explaining that selecting that option would release the
  login.some_bank.com  credentials to the  my_financial_app ; if the user agrees
 then the service returns an unlocked dataset with the  some_bank.com  credentials.

  Note:  The autofill service could also whitelist well-known browser apps and skip the
 verifications above as long as the service can verify the authenticity of the browser app by
 checking its signing certificate.

  Saving when data is split in multiple screens It's tricky to handle save for autofill in these situations because the autofill service must
 wait until the user enters both fields before the autofill save UI can be shown. But it can be
 done by following the steps below:

  In the first
  fill request  the service
 adds a  FillResponse.Builder#setClientState(android.os.Bundle)  in
 the response containing the autofill ids of the partial fields present in the screen.
  In the second
  fill request  the service
 retrieves the  FillRequest#getClientState()  gets the autofill ids
 set in the previous request from the client state and adds these ids and the
  SaveInfo#FLAG_SAVE_ON_ALL_VIEWS_INVISIBLE  to the  SaveInfo  used in the second
 response.
  In the  save request  the service uses the
 proper  FillContext  to get the value of each field (there is one fill
 context per fill request).
  For example in an app that uses 2 steps for the username and password fields the workflow
 would be:
  
  // On first fill request
  AutofillId usernameId = // parse from AssistStructure;
  Bundle clientState = new Bundle();
  clientState.putParcelable(""usernameId"" usernameId);
  fillCallback.onSuccess(
    new FillResponse.Builder()
        .setClientState(clientState)
        .setSaveInfo(new SaveInfo
             .Builder(SaveInfo.SAVE_DATA_TYPE_USERNAME new AutofillId[] {usernameId})
             .build())
        .build());

  // On second fill request
  Bundle clientState = fillRequest.getClientState();
  AutofillId usernameId = clientState.getParcelable(""usernameId"");
  AutofillId passwordId = // parse from AssistStructure
  clientState.putParcelable(""passwordId"" passwordId);
  fillCallback.onSuccess(
    new FillResponse.Builder()
        .setClientState(clientState)
        .setSaveInfo(new SaveInfo
             .Builder(SaveInfo.SAVE_DATA_TYPE_USERNAME | SaveInfo.SAVE_DATA_TYPE_PASSWORD
                      new AutofillId[] {usernameId passwordId})
             .setFlags(SaveInfo.FLAG_SAVE_ON_ALL_VIEWS_INVISIBLE)
             .build())
        .build());

  // On save request
  Bundle clientState = saveRequest.getClientState();
  AutofillId usernameId = clientState.getParcelable(""usernameId"");
  AutofillId passwordId = clientState.getParcelable(""passwordId"");
  List  fillContexts = saveRequest.getFillContexts();

  FillContext usernameContext = fillContexts.get(0);
  ViewNode usernameNode = findNodeByAutofillId(usernameContext.getStructure() usernameId);
  AutofillValue username = usernameNode.getAutofillValue().getTextValue().toString();

  FillContext passwordContext = fillContexts.get(1);
  ViewNode passwordNode = findNodeByAutofillId(passwordContext.getStructure() passwordId);
  AutofillValue password = passwordNode.getAutofillValue().getTextValue().toString();

  save(username password);
   Privacy The  onFillRequest(android.service.autofill.FillRequest android.os.CancellationSignal android.service.autofill.FillCallback)  method is called
 without the user content. The Android system strips some properties of the
  view nodes  passed to this call but not all
 of them. For example the data provided in the  ViewStructure.HtmlInfo 
 objects set by  WebView  is never stripped out.

  Because this data could contain PII (Personally Identifiable Information such as username or
 email address) the service should only use it locally (i.e. in the app's process) for
 heuristics purposes but it should not be sent to external servers.

  Metrics and field classification getFillEventHistory() Prior to Android  Build.VERSION_CODES.P  the metrics covered just the
 scenarios where the service knew how to autofill an activity but Android
  Build.VERSION_CODES.P  introduced a new mechanism called field classification
 which allows the service to dinamically classify the meaning of fields based on the existing user
 data known by the service.

  Typically field classification can be used to detect fields that can be autofilled with
 user data that is not associated with a specific appâ€”such as email and physical
 address. Once the service identifies that a such field was manually filled by the user the
 service could use this signal to improve its heuristics on subsequent requests (for example by
 infering which resource ids are associated with known fields).

  The field classification workflow involves 4 steps:

  Set the user data through  AutofillManager#setUserData(UserData) . This data is
   cached until the system restarts (or the service is disabled) so it doesn't need to be set for
   all requests.
    Identify which fields should be analysed by calling
    FillResponse.Builder#setFieldClassificationIds(AutofillId...) .
    Verify the results through  FillEventHistory.Event#getFieldsClassification() .
    Use the results to dynamically create  Dataset  or  SaveInfo  objects in
   subsequent requests.
  The field classification is an expensive operation and should be used carefully otherwise it
 can reach its rate limit and get blocked by the Android System. Ideally it should be used just
 in cases where the service could not determine how an activity can be autofilled but it has a
 strong suspicious that it could. For example if an activity has four or more fields and one of
 them is a list chances are that these are address fields (like address city state and
 zip code).

  Compatibility mode Apps that use standard Android widgets support autofill out-of-the-box and need to do
 very little to improve their user experience (annotating autofillable views and providing
 autofill hints). However some apps (typically browsers) do their own rendering and the rendered
 content may contain semantic structure that needs to be surfaced to the autofill framework. The
 platform exposes APIs to achieve this however it could take some time until these apps implement
 autofill support.

  To enable autofill for such apps the platform provides a compatibility mode in which the
 platform would fall back to the accessibility APIs to generate the state reported to autofill
 services and fill data. This mode needs to be explicitly requested for a given package up
 to a specified max version code allowing clean migration path when the target app begins to
 support autofill natively. Note that enabling compatibility may degrade performance for the
 target package and should be used with caution. The platform supports whitelisting which packages
 can be targeted in compatibility mode to ensure this mode is used only when needed and as long
 as needed.

  You can request compatibility mode for packages of interest in the meta-data resource
 associated with your service. Below is a sample service declaration:

   <service android:name="".MyAutofillService""
              android:permission=""android.permission.BIND_AUTOFILL_SERVICE"">
     <intent-filter>
         <action android:name=""android.service.autofill.AutofillService"" />
     </intent-filter>
     <meta-data android:name=""android.autofill"" android:resource=""@xml/autofillservice"" />
 </service> In the XML file you can specify one or more packages for which to enable compatibility
 mode. Below is a sample meta-data declaration:

   <autofill-service xmlns:android=""http://schemas.android.com/apk/res/android"">
     <compatibility-package android:name=""foo.bar.baz"" android:maxLongVersionCode=""1000000000""/>
 </autofill-service> Notice that compatibility mode has limitations such as:
  No manual autofill requests. Hence the  FillRequest FillRequest#getFlags()  never have the  FillRequest#FLAG_MANUAL_REQUEST  flag.
  The value of password fields are most likely maskedâ€”for example  ****  instead
 of  1234 . Hence you must be careful when using these values to avoid updating the user
 data with invalid input. For example when you parse the  FillRequest  and detect a
 password field you could check if its
  input type  has password flags and if so don't add it to the  SaveInfo  object.
  The autofill context is not always  AutofillManager#commit()  when an HTML
 form is submitted. Hence you must use other mechanisms to trigger save such as setting the
  SaveInfo#FLAG_SAVE_ON_ALL_VIEWS_INVISIBLE  flag on  SaveInfo.Builder#setFlags(int) 
 or using  SaveInfo.Builder#setTriggerId(AutofillId) .
  Browsers often provide their own autofill management system. When both the browser and
 the platform render an autofill dialog at the same time the result can be confusing to the user.
 Such browsers typically offer an option for users to disable autofill so your service should
 also allow users to disable compatiblity mode for specific apps. That way it is up to the user
 to decide which autofill mechanismâ€”the browser's or the platform'sâ€”should be used."
android,service.autofill,BatchUpdates,3,"Defines actions to be applied to a  RemoteViews .


  It supports 2 types of actions:

  RemoteViews  to be applied to the template.
    Transformation  to be applied on child views.
  Typically used on  CustomDescription  to conditionally display
 differents views based on user input - see
  CustomDescription.Builder#batchUpdate(Validator BatchUpdates)  for more information."
android,service.autofill,BatchUpdates.Builder,3,Builder for  BatchUpdates  objects.
android,service.autofill,CharSequenceTransformation,3,"Replaces a  TextView  child of a  CustomDescription  with the contents of one or
 more regular expressions (regexs).

  When it contains more than one field the fields that match their regex are added to the
 overall transformation result.

  For example a transformation to mask a credit card number contained in just one field would
 be:

  
 new CharSequenceTransformation
     .Builder(ccNumberId Pattern.compile(""^.*(\\d\\d\\d\\d)$"") ""...$1"")
     .build();
  But a transformation that generates a  Exp: MM / YYYY  credit expiration date from two
 fields (month and year) would be:

  
 new CharSequenceTransformation
   .Builder(ccExpMonthId Pattern.compile(""^(\\d\\d)$"") ""Exp: $1"")
   .addField(ccExpYearId Pattern.compile(""^(\\d\\d\\d\\d)$"") "" / $1"");"
android,service.autofill,CharSequenceTransformation.Builder,2,Builder for  CharSequenceTransformation  objects.
android,service.autofill,CustomDescription.Builder,4,Builder for  CustomDescription  objects.
android,service.autofill,Dataset,3,"A  Dataset  object represents a group of fields (key / value pairs) used
 to autofill parts of a screen.

  For more information about the role of datasets in the autofill workflow read
  Build autofill services  and the
  AutofillService 
 documentation.

  Basic usage In its simplest form a dataset contains one or more fields (comprised of
 an  AutofillId  a  AutofillValue  and an optional filter
  Pattern ); and one or more  RemoteViews  for these fields
 (each field could have its own  RemoteViews  or use the default
  RemoteViews  associated with the whole dataset).

  When an autofill service returns datasets in a  FillResponse 
 and the screen input is focused in a view that is present in at least one of these datasets
 the Android System displays a UI containing the  RemoteViews  of
 all datasets pairs that have that view's  AutofillId . Then when the user selects a
 dataset from the UI all views in that dataset are autofilled.

  Dataset authentication In a more sophisticated form the dataset values can be protected until the user authenticates
 the datasetâ€”in that case when a dataset is selected by the user the Android System
 launches an intent set by the service to ""unlock"" the dataset.

  For example when a data set contains credit card information (such as number
 expiration date and verification code) you could provide a dataset presentation saying
 ""Tap to authenticate"". Then when the user taps that option you would launch an activity asking
 the user to enter the credit card code and if the user enters a valid code you could then
 ""unlock"" the dataset.

  You can also use authenticated datasets to offer an interactive UI for the user. For example
 if the activity being autofilled is an account creation screen you could use an authenticated
 dataset to automatically generate a random password for the user.

  See  Dataset.Builder#setAuthentication(IntentSender)  for more details about the dataset
 authentication mechanism.

  Filtering The autofill UI automatically changes which values are shown based on value of the view
 anchoring it following the rules below:
  If the view's  autofill value  is not
  AutofillValue#isText()  or is empty all datasets are shown.
    Datasets that have a filter regex (set through
  Dataset.Builder#setValue(AutofillId AutofillValue Pattern)  or
  Dataset.Builder#setValue(AutofillId AutofillValue Pattern RemoteViews) ) and whose
 regex matches the view's text value converted to lower case are shown.
    Datasets that do not require authentication have a field value that is
  AutofillValue#isText()  and whose  AutofillValue#getTextValue()  starts
 with the lower case value of the view's text are shown.
    All other datasets are hidden."
android,service.autofill,Dataset.Builder,7,"A builder for  Dataset  objects. You must provide at least
 one value for a field or set an authentication intent."
android,service.autofill,DateTransformation,3,"Replaces a  TextView  child of a  CustomDescription  with the contents of a field
 that is expected to have a  AutofillValue#forDate(long) .

  For example a transformation to display a credit card expiration date as month/year would be:

  
 new DateTransformation(ccExpDate new java.text.SimpleDateFormat(""MM/yyyy"")"
android,service.autofill,DateValueSanitizer,3,"Sanitizes a date  AutofillValue  using a  DateFormat .

  For example to sanitize a credit card expiration date to just its month and year:

  
 new DateValueSanitizer(new java.text.SimpleDateFormat(""MM/yyyy"");"
android,service.autofill,FieldClassification,2,"Represents the  field classification 
 results for a given field."
android,service.autofill,FieldClassification.Match,3,Represents the score of a  UserData  entry for the field.
android,service.autofill,FillEventHistory.Event,9,"Description of an event that occured after the latest call to
  FillCallback#onSuccess(FillResponse) ."
android,service.autofill,FillRequest,7,"This class represents a request to an autofill service
 to interpret the screen and provide information to the system which views are
 interesting for saving and what are the possible ways to fill the inputs on
 the screen if applicable."
android,service.autofill,FillResponse,3,"Response for an  AutofillService#onFillRequest(FillRequest android.os.CancellationSignal FillCallback) .

  See the main  AutofillService  documentation for more details and examples."
android,service.autofill,FillResponse.Builder,12,"Builder for  FillResponse  objects. You must to provide at least
 one dataset or set an authentication intent with a presentation view."
android,service.autofill,ImageTransformation,3,"Replaces the content of a child  ImageView  of a
  RemoteViews  with the first image that matches a regular expression
 (regex).

  Typically used to display credit card logos. Example:

  
   new ImageTransformation.Builder(ccNumberId Pattern.compile(""^4815.*$"")
                                   R.drawable.ic_credit_card_logo1 ""Brand 1"")
     .addOption(Pattern.compile(""^1623.*$"") R.drawable.ic_credit_card_logo2 ""Brand 2"")
     .addOption(Pattern.compile(""^42.*$"") R.drawable.ic_credit_card_logo3 ""Brand 3"")
     .build();
  There is no imposed limit in the number of options but keep in mind that regexs are
 expensive to evaluate so use the minimum number of regexs and add the most common first
 (for example if this is a tranformation for a credit card logo and the most common credit card
 issuers are banks X and Y add the regexes that resolves these 2 banks first)."
android,service.autofill,LuhnChecksumValidator,3,"Validator that returns  true  if the number created by concatenating all given fields
 pass a Luhn algorithm checksum. All non-digits are ignored.

  See  SaveInfo.Builder#setValidator(Validator)  for examples."
android,service.autofill,RegexValidator,3,"Defines if a field is valid based on a regular expression (regex).

  See  SaveInfo.Builder#setValidator(Validator)  for examples."
android,service.autofill,SaveCallback,3,"Handles save requests from the  AutofillService  into the  Activity  being
 autofilled."
android,service.autofill,SaveInfo,3,"Information used to indicate that an  AutofillService  is interested on saving the
 user-inputed data for future use through a
  AutofillService#onSaveRequest(SaveRequest SaveCallback) 
 call.

  A  SaveInfo  is always associated with a  FillResponse  and it contains at least
 two pieces of information:

  The type(s) of user data (like password or credit card info) that would be saved.
    The minimum set of views (represented by their  AutofillId ) that need to be changed
       to trigger a save request.
  Typically the  SaveInfo  contains the same  id s as the  Dataset :

  
   new FillResponse.Builder()
       .addDataset(new Dataset.Builder()
           .setValue(id1 AutofillValue.forText(""homer"") createPresentation(""homer"")) // username
           .setValue(id2 AutofillValue.forText(""D'OH!"") createPresentation(""password for homer"")) // password
           .build())
       .setSaveInfo(new SaveInfo.Builder(
           SaveInfo.SAVE_DATA_TYPE_USERNAME | SaveInfo.SAVE_DATA_TYPE_PASSWORD
           new AutofillId[] { id1 id2 }).build())
       .build();
  The save type flags are used to display the appropriate strings in the autofill save UI.
 You can pass multiple values but try to keep it short if possible. In the above example just
  SaveInfo.SAVE_DATA_TYPE_PASSWORD  would be enough.

  There might be cases where the  AutofillService  knows how to fill the screen
 but the user has no data for it. In that case the  FillResponse  should contain just the
  SaveInfo  but no  Dataset :

  
   new FillResponse.Builder()
       .setSaveInfo(new SaveInfo.Builder(SaveInfo.SAVE_DATA_TYPE_PASSWORD
           new AutofillId[] { id1 id2 }).build())
       .build();
  There might be cases where the user data in the  AutofillService  is enough
 to populate some fields but not all and the service would still be interested on saving the
 other fields. In that case the service could set the
  SaveInfo.Builder#setOptionalIds(AutofillId[])  as well:

  
   new FillResponse.Builder()
       .addDataset(new Dataset.Builder()
           .setValue(id1 AutofillValue.forText(""742 Evergreen Terrace"")
               createPresentation(""742 Evergreen Terrace"")) // street
           .setValue(id2 AutofillValue.forText(""Springfield"")
               createPresentation(""Springfield"")) // city
           .build())
       .setSaveInfo(new SaveInfo.Builder(SaveInfo.SAVE_DATA_TYPE_ADDRESS
           new AutofillId[] { id1 id2 }) // street and  city
           .setOptionalIds(new AutofillId[] { id3 id4 }) // state and zipcode
           .build())
       .build();
  Triggering a save request The  AutofillService#onSaveRequest(SaveRequest SaveCallback)  can be triggered after
 any of the following events:
  The  Activity  finishes.
    The app explicitly calls  AutofillManager#commit() .
    All required views become invisible (if the  SaveInfo  was created with the
        FLAG_SAVE_ON_ALL_VIEWS_INVISIBLE  flag).
    The user clicks a specific view (defined by  Builder#setTriggerId(AutofillId) .
  But it is only triggered when all conditions below are met:
  The  SaveInfo  associated with the  FillResponse  is not  null  neither
       has the  FLAG_DELAY_SAVE  flag.
    The  AutofillValue s of all required views (as set by the  requiredIds  passed
       to the  SaveInfo.Builder  constructor are not empty.
    The  AutofillValue  of at least one view (be it required or optional) has changed
       (i.e. it's neither the same value passed in a  Dataset  nor the initial value
       presented in the view).
    There is no  Dataset  in the last  FillResponse  that completely matches the
       screen state (i.e. all required and optional fields in the dataset have the same value as
       the fields in the screen).
    The user explicitly tapped the autofill save UI asking to save data for autofill.
  Customizing the autofill save UI The service can also customize some aspects of the autofill save UI:
  Add a simple subtitle by calling  Builder#setDescription(CharSequence) .
    Add a customized subtitle by calling
        Builder#setCustomDescription(CustomDescription) .
    Customize the button used to reject the save request by calling
        Builder#setNegativeAction(int IntentSender) .
    Decide whether the UI should be shown based on the user input validation by calling
        Builder#setValidator(Validator) ."
android,service.autofill,SaveInfo.Builder,9,A builder for  SaveInfo  objects.
android,service.autofill,SaveRequest,5,This class represents a request to an  AutofillService  to save applicable data entered by the user.
android,service.autofill,TextValueSanitizer,3,"Sanitizes a text  AutofillValue  using a regular expression (regex) substitution.

  For example to remove spaces from groups of 4-digits in a credit card:

  
 new TextValueSanitizer(Pattern.compile(""^(\\d{4})\\s?(\\d{4})\\s?(\\d{4})\\s?(\\d{4})$"")
     ""$1$2$3$4"")"
android,service.autofill,UserData,11,"Defines the user data used for
  field classification ."
android,service.autofill,UserData.Builder,4,A builder for  UserData  objects.
android,service.autofill,Validators,3,"Factory for  Validator  operations.

  See  SaveInfo.Builder#setValidator(Validator)  for examples."
android,service.autofill,VisibilitySetterAction,3,"Action used to change the visibility of other child view in a  CustomDescription RemoteViews .

  See  CustomDescription.Builder#addOnClickAction(int OnClickAction)  for more details."
android,service.autofill,VisibilitySetterAction.Builder,2,Builder for  VisibilitySetterAction  objects.
android,service.autofill,CustomDescription,3,"Defines a custom description for the autofill save UI.

  This is useful when the autofill service needs to show a detailed view of what would be saved;
 for example when the screen contains a credit card it could display a logo of the credit card
 bank the last four digits of the credit card number and its expiration number.

  A custom description is made of 2 parts:
  A  RemoteViews  containing children views.
    Transformation  to populate the children views.
  For the credit card example mentioned above the (simplified) template would be:

  
 <LinearLayout>
   <ImageView android:id=""@+id/templateccLogo""/>
   <TextView android:id=""@+id/templateCcNumber""/>
   <TextView android:id=""@+id/templateExpDate""/>
 </LinearLayout>
  Which in code translates to:

  
   CustomDescription.Builder buider = new Builder(new RemoteViews(pgkName R.layout.cc_template);
  Then the value of each of the 3 children would be changed at runtime based on the the value of
 the screen fields and the  Transformation :

  
 // Image child - different logo for each bank based on credit card prefix
 builder.addChild(R.id.templateccLogo
   new ImageTransformation.Builder(ccNumberId)
     .addOption(Pattern.compile(""^4815.*$"") R.drawable.ic_credit_card_logo1)
     .addOption(Pattern.compile(""^1623.*$"") R.drawable.ic_credit_card_logo2)
     .addOption(Pattern.compile(""^42.*$"") R.drawable.ic_credit_card_logo3)
     .build();
 // Masked credit card number (as .....LAST_4_DIGITS)
 builder.addChild(R.id.templateCcNumber new CharSequenceTransformation
     .Builder(ccNumberId Pattern.compile(""^.*(\\d\\d\\d\\d)$"") ""...$1"")
     .build();
 // Expiration date as MM / YYYY:
 builder.addChild(R.id.templateExpDate new CharSequenceTransformation
     .Builder(ccExpMonthId Pattern.compile(""^(\\d\\d)$"") ""Exp: $1"")
     .addField(ccExpYearId Pattern.compile(""^(\\d\\d)$"") ""/$1"")
     .build();
  See  ImageTransformation   CharSequenceTransformation  for more info about these
 transformations."
android,service.autofill,FillCallback,2,"FillCallback  handles autofill requests from the  AutofillService  into
 the  Activity  being autofilled.

  To learn about using Autofill services in your app read
  Build autofill services ."
android,service.autofill,FillContext,6,"This class represents a context for each fill request made via  AutofillService#onFillRequest(FillRequest CancellationSignal FillCallback) .
 It contains a snapshot of the UI state the view ids that were returned by
 the  AutofillService  as both required to trigger a save
 and optional that can be saved and the id of the corresponding  FillRequest .
  
 This context allows you to inspect the values for the interesting views
 in the context they appeared. Also a reference to the corresponding fill
 request is useful to store meta-data in the client state bundle passed
 to  FillResponse.Builder#setClientState(Bundle)  to avoid interpreting
 the UI state again while saving."
android,service.autofill,FillEventHistory,5,"Describes what happened after the last
  AutofillService#onFillRequest(FillRequest android.os.CancellationSignal FillCallback) 
 call.

  This history is typically used to keep track of previous user actions to optimize further
 requests. For example the service might return email addresses in alphabetical order by
 default but change that order based on the address the user picked on previous requests.

  The history is not persisted over reboots and it's cleared every time the service
 replies to a
  AutofillService#onFillRequest(FillRequest android.os.CancellationSignal FillCallback) 
 by calling  FillCallback#onSuccess(FillResponse)  or
  FillCallback#onFailure(CharSequence)  (if the service doesn't call any of these methods
 the history will clear out after some pre-defined time)."
android,service.autofill,ImageTransformation.Builder,3,Builder for  ImageTransformation  objects.
android,service.restrictions,RestrictionsReceiver,2,"Abstract implementation of a Restrictions Provider BroadcastReceiver. To implement a
 Restrictions Provider extend from this class and implement the abstract methods.
 Export this receiver in the manifest. A profile owner device admin can then register this
 component as a Restrictions Provider using
  DevicePolicyManager#setRestrictionsProvider(ComponentName ComponentName) .
  
 The function of a Restrictions Provider is to transport permission requests from apps on this
 device to an administrator (most likely on a remote device or computer) and deliver back
 responses. The response should be sent back to the app via
  RestrictionsManager#notifyPermissionResponse(String PersistableBundle) ."
android,service.textservice,SpellCheckerService,2,"SpellCheckerService provides an abstract base class for a spell checker.
 This class combines a service to the system with the spell checker service interface that
 spell checker must implement.

  In addition to the normal Service lifecycle methods this class
 introduces a new specific callback that subclasses should override
  createSession()  to provide a spell checker session that is corresponding
 to requested language and so on. The spell checker session returned by this method
 should extend  SpellCheckerService.Session .
  Returning spell check results SpellCheckerService.Session#onGetSuggestions(TextInfo int) 
 should return spell check results.
 It receives  TextInfo  and returns
  SuggestionsInfo  for the input.
 You may want to override
  SpellCheckerService.Session#onGetSuggestionsMultiple(TextInfo[] int boolean)  for
 better performance and quality.
  Please note that  SpellCheckerService.Session#getLocale()  does not return a valid
 locale before  SpellCheckerService.Session#onCreate()"
android,service.textservice,SpellCheckerService.Session,8,This abstract class should be overridden by a concrete implementation of a spell checker.
android,renderscript,Allocation,91,"This class provides the primary method through which data is passed to
 and from RenderScript kernels.  An Allocation provides the backing store for
 a given  Type .   An Allocation also contains a set of usage flags that denote how the
 Allocation could be used. For example an Allocation may have usage flags
 specifying that it can be used from a script as well as input to a  Sampler . A developer must synchronize across these
 different usages using  syncAll(int)  in
 order to ensure that different users of the Allocation have a consistent view
 of memory. For example in the case where an Allocation is used as the output
 of one kernel and as Sampler input in a later kernel a developer must call
  syncAll(Allocation.USAGE_SCRIPT)  prior to launching the
 second kernel to ensure correctness.

  An Allocation can be populated with the  copyFrom(Bitmap)  routines. For
 more complex Element types the  copyFromUnchecked(byte[])  methods can be
 used to copy from byte arrays or similar constructs."
android,renderscript,BaseObj,6,"BaseObj is the base class for all RenderScript objects owned by a RS context.
 It is responsible for lifetime management and resource tracking. This class
 should not be used by a user application.

 * @apiSince 11"
android,renderscript,Byte3,0,"Class for exposing the native RenderScript byte3 type back to the Android system.

 * @apiSince 11"
android,renderscript,Double2,0,"Vector version of the basic double type.
 Provides two double fields packed."
android,renderscript,Double4,0,"Vector version of the basic double type.
 Provides four double fields packed."
android,renderscript,Element,80,"An Element represents one item within an  Allocation .  An Element is roughly equivalent to a C
 type in a RenderScript kernel. Elements may be basic or complex. Some basic
 elements are A single float value (equivalent to a float in a
 kernel) A four-element float vector (equivalent to a float4 in a
 kernel) An unsigned 32-bit integer (equivalent to an unsigned int in
 a kernel) A single signed 8-bit integer (equivalent to a char in a
 kernel) A complex element is roughly equivalent to a C struct
 and contains a number of basic or complex Elements. From Java code a complex
 element contains a list of sub-elements and names that represents a
 particular data structure. Structs used in RS scripts are available to Java
 code by using the  ScriptField_structname  class that is reflected from
 a particular script. Basic Elements are comprised of a  Element.DataType  and a  Element.DataKind . The DataType encodes C type
 information of an Element while the DataKind encodes how that Element should
 be interpreted by a  Sampler . Note that  Allocation  objects with DataKind  Element.DataKind.USER  cannot be used as input for a
  Sampler . In general  Allocation  objects that are intended for use with a
  Sampler  should use bitmap-derived Elements such
 as  RGBA_8888(RenderScript)  or  android.renderscript ."
android,renderscript,FieldPacker,79,"Utility class for packing arguments and structures from Android system objects to
 RenderScript objects.

 This class is only intended to be used to support the
 reflected code generated by the RS tool chain.  It should not
 be called directly.

 * @apiSince 11"
android,renderscript,Float2,0,"Vector version of the basic float type.
 Provides two float fields packed."
android,renderscript,Float4,0,"Vector version of the basic float type.
 Provides four float fields packed."
android,renderscript,Int3,0,"Vector version of the basic int type.
 Provides three int fields packed."
android,renderscript,Long3,0,"Vector version of the basic long type.
 Provides three long fields packed."
android,renderscript,Matrix2f,12,"Class for exposing the native RenderScript rs_matrix2x2 type back to the Android system.

 * @apiSince 11"
android,renderscript,RenderScript,17,"This class provides access to a RenderScript context which controls RenderScript
 initialization resource management and teardown. An instance of the RenderScript
 class must be created before any other RS objects can be created."
android,renderscript,RenderScript.RSErrorHandler,1,"The runtime error handler base class.  An application should derive from this class
 if it wishes to install an error handler.  When errors occur at runtime
 the fields in this class will be filled and the run method will be called."
android,renderscript,Sampler,14,"Sampler object that defines how Allocations can be read as textures within a
 kernel. Samplers are used in conjunction with the  rsSample  runtime
 function to return values from normalized coordinates.

 Any Allocation used with a Sampler must have been created with  Allocation.USAGE_GRAPHICS_TEXTURE ; using a Sampler on
 an  Allocation  that was not created with  Allocation.USAGE_GRAPHICS_TEXTURE  is undefined.
 * @apiSince 11"
android,renderscript,Sampler.Builder,6,"Builder for creating non-standard samplers.  This is only necessary if
 a Sampler with different min and mag modes is desired."
android,renderscript,Script.FieldBase,6,Only intended for use by generated reflected code.
android,renderscript,Script.InvokeID,0,"InvokeID is an identifier for an invoke function. It is used
 as an identifier for ScriptGroup creation.

 This class should not be directly created. Instead use the method in the
 reflected or intrinsic code ""getInvokeID_funcname()""."
android,renderscript,Script.KernelID,0,"KernelID is an identifier for a Script + root function pair. It is used
 as an identifier for ScriptGroup creation.

 This class should not be directly created. Instead use the method in the
 reflected or intrinsic code ""getKernelID_funcname()""."
android,renderscript,ScriptGroup,5,"A group of kernels that are executed
 together with one execution call as if they were a single kernel
  
 In addition to kernels a script group may contain invocable functions as well.
 A script group may take inputs and generate outputs which are consumed and
 produced by its member kernels.
 Inside a script group outputs from one kernel can be passed to another kernel as inputs.
 The API disallows cyclic dependencies among kernels in a script group
 effectively making it a directed acyclic graph (DAG) of kernels.
  
 Grouping kernels together allows for more efficient execution. For example
 runtime and compiler optimization can be applied to reduce computation and
 communication overhead and to make better use of the CPU and the GPU.
 * @apiSince 17"
android,renderscript,ScriptGroup.Binding,0,"Represents a binding of a value to a global variable in a
 kernel or invocable function. Used in closure creation."
android,renderscript,ScriptGroup.Builder,4,"Helper class to build a ScriptGroup. A ScriptGroup is
 created in two steps.
  
 First all kernels to be used by the ScriptGroup should be added.
  
 Second add connections between kernels. There are two types
 of connections: kernel to kernel and kernel to field.
 Kernel to kernel allows a kernel's output to be passed to
 another kernel as input. Kernel to field allows the output of
 one kernel to be bound as a script global. Kernel to kernel is
 higher performance and should be used where possible.
  
 A ScriptGroup must contain a single directed acyclic graph (DAG); it
 cannot contain cycles. Currently all kernels used in a ScriptGroup
 must come from different Script objects. Additionally all kernels
 in a ScriptGroup must have at least one input output or internal
 connection.
  
 Once all connections are made a call to  create()  will
 return the ScriptGroup object."
android,renderscript,ScriptGroup.Builder2,4,"The builder class for creating script groups
  
 A script group is created using closures (see class  Closure ).
 A closure is a function call to a kernel or
 invocable function. Each function argument or global variable accessed inside
 the function is bound to 1) a known value 2) a script group input
 (see class  Input ) or 3) a
 future (see class  Future ).
 A future is the output of a closure either the return value of the
 function or a global variable written by that function.
  
 Closures are created using the  addKernel(Script.KernelID Type Object...)  or  addInvoke(Script.InvokeID Object...) 
 methods.
 When a closure is created futures from previously created closures
 can be used as its inputs.
 External script group inputs can be used as inputs to individual closures as well.
 An external script group input is created using the  addInput()  method.
 A script group is created by a call to the  create(String ScriptGroup.Future...)  method which
 accepts an array of futures as the outputs for the script group.
  
 Closures in a script group can be evaluated in any order as long as the
 following conditions are met:
 1) a closure must be evaluated before any other closures that take its
 futures as inputs;
 2) all closures added before an invoke closure must be evaluated
 before it;
 and 3) all closures added after an invoke closure must be evaluated after
 it.
 As a special case the order that the closures are added is a legal
 evaluation order. However other evaluation orders are possible including
 concurrently evaluating independent closures."
android,renderscript,ScriptGroup.Closure,4,"An opaque class for closures
  
 A closure represents a function call to a kernel or invocable function
 combined with arguments and values for global variables. A closure is
 created using the  ScriptGroup.Builder2.addKernel(Script.KernelID Type Object...)  or
  ScriptGroup.Builder2.addInvoke(Script.InvokeID Object...) 
 method."
android,renderscript,ScriptGroup.Future,0,"An opaque class for futures
  
 A future represents an output of a closure either the return value of
 the function or the value of a global variable written by the function.
 A future is created by calling the  Closure#getReturn   or
  Closure#getGlobal  method."
android,renderscript,ScriptGroup.Input,0,"An opaque class for script group inputs
  
 Created by calling the  Builder2#addInput  method. The value
 is assigned in  ScriptGroup#execute(Object...)  method as
 one of its arguments. Arguments to the execute method should be in
 the same order as intputs are added using the addInput method."
android,renderscript,ScriptIntrinsic,0,"Base class for all Intrinsic scripts. An intrinsic is a script
 that implements a pre-defined function. Intrinsics are
 provided to provide efficient implementations of common
 operations.

 Not intended for direct use.
 * @apiSince 17"
android,renderscript,ScriptIntrinsicBlend,46,"Intrinsic kernels for blending two  Allocation  objects.
 * @apiSince 17"
android,renderscript,ScriptIntrinsicBlur,7,"Intrinsic Gausian blur filter. Applies a gaussian blur of the
 specified radius to all elements of an allocation.


 * @apiSince 17"
android,renderscript,ScriptIntrinsicConvolve5x5,7,"Intrinsic for applying a 5x5 convolve to an allocation.

 * @apiSince 17"
android,renderscript,ScriptIntrinsicHistogram,9,"Intrinsic Histogram filter.


 * @apiSince 19"
android,renderscript,ScriptIntrinsicLUT,9,"Intrinsic for applying a per-channel lookup table. Each
 channel of the input has an independant lookup table. The
 tables are 256 entries in size and can cover the full value
 range of  Element#U8_4 .
 * @apiSince 17"
android,renderscript,Short3,0,"Vector version of the basic short type.
 Provides three short fields packed."
android,renderscript,Short4,0,"Vector version of the basic short type.
 Provides four short fields packed."
android,renderscript,AllocationAdapter,9,"Only intended for use by generated reflected code.

 * @apiSince 11"
android,renderscript,Element.Builder,3,"Builder class for producing complex elements with matching field and name
 pairs.  The builder starts empty.  The order in which elements are added
 is retained for the layout in memory."
android,renderscript,Int2,0,"Vector version of the basic int type.
 Provides two int fields packed."
android,renderscript,Int4,0,"Vector version of the basic int type.
 Provides four int fields packed."
android,renderscript,Long2,0,"Vector version of the basic long type.
 Provides two long fields packed."
android,renderscript,Matrix3f,18,"Class for exposing the native RenderScript rs_matrix3x3 type back to the Android system.

 * @apiSince 11"
android,renderscript,Script.Builder,0,Only intended for use by generated reflected code.
android,renderscript,Script.FieldID,0,"FieldID is an identifier for a Script + exported field pair. It is used
 as an identifier for ScriptGroup creation.

 This class should not be directly created. Instead use the method in the
 reflected or intrinsic code ""getFieldID_funcname()""."
android,renderscript,ScriptIntrinsic3DLUT,5,"Intrinsic for converting RGB to RGBA by using a 3D lookup table.  The
 incoming rgb values are use as normalized xyz coordinates into a 3D
 allocation.  The 8 nearest values are sampled and linearly interpolated.  The
 result is placed in the output."
android,renderscript,ScriptIntrinsicConvolve3x3,7,"Intrinsic for applying a 3x3 convolve to an allocation.

 * @apiSince 17"
android,renderscript,ScriptIntrinsicYuvToRGB,5,"Intrinsic for converting an Android YUV buffer to RGB.

 The input allocation should be supplied in a supported YUV format
 as a YUV element Allocation. The output is RGBA; the alpha channel
 will be set to 255."
android,renderscript,Short2,0,"Class for exposing the native RenderScript Short2 type back to the Android system.

 Vector version of the basic short type.
 Provides two short fields packed."
android,renderscript,Byte2,0,"Class for exposing the native RenderScript byte2 type back to the Android system.

 * @apiSince 11"
android,renderscript,Byte4,0,"Class for exposing the native RenderScript byte4 type back to the Android system.

 * @apiSince 11"
android,renderscript,Double3,0,"Vector version of the basic double type.
 Provides three double fields packed."
android,renderscript,Float3,0,"Vector version of the basic float type.
 Provides three float fields packed."
android,renderscript,Long4,0,"Vector version of the basic long type.
 Provides four long fields packed."
android,renderscript,RenderScript.RSMessageHandler,1,"The base class from which an application should derive in order
 to receive RS messages from scripts. When a script calls  rsSendToClient  the data fields will be filled and the run
 method will be called on a separate thread.  This will occur
 some time after  rsSendToClient  completes in the script
 as  rsSendToClient  is asynchronous. Message handlers are
 not guaranteed to have completed when  RenderScript.finish()  returns."
android,renderscript,Script.LaunchOptions,9,"Class for specifying the specifics about how a kernel will be
 launched.

 This class can specify a potential range of cells on which to
 run a kernel.  If no set is called for a dimension then this
 class will have no impact on that dimension when the kernel
 is executed.

 The forEach kernel launch will operate over the intersection of
 the dimensions.

 Example:
 LaunchOptions with setX(5 15)
 Allocation with dimension X=10 Y=10
 The resulting forEach run would execute over:
 x = 5 to 9 (inclusive) and
 y = 0 to 9 (inclusive)."
android,renderscript,Matrix4f,21,"Class for exposing the native RenderScript rs_matrix4x4 type back to the Android system.

 * @apiSince 11"
android,renderscript,Script,26,"The parent class for all executable scripts. This should not be used by
 applications.
 * @apiSince 11"
android,renderscript,ScriptC,0,"The superclass for all user-defined scripts. This is only
 intended to be used by the generated derived classes.
 * @apiSince 11"
android,renderscript,ScriptIntrinsicBLAS,98,"ScriptIntrinsicBLAS class provides high performance RenderScript APIs to BLAS.

 The BLAS (Basic Linear Algebra Subprograms) are routines that provide standard
 building blocks for performing basic vector and matrix operations.

 For detailed description of BLAS please refer to http://www.netlib.org/blas/"
android,renderscript,ScriptIntrinsicColorMatrix,12,"Intrinsic for applying a color matrix to allocations.

 If the element type is  Element.DataType#UNSIGNED_8 
 it is converted to  Element.DataType#FLOAT_32  and
 normalized from (0-255) to (0-1). If the incoming vector size
 is less than four a  Element#F32_4  is created by
 filling the missing vector channels with zero. This value is
 then multiplied by the 4x4 color matrix as performed by
 rsMatrixMultiply() adding a  Element#F32_4  and then
 writing it to the output  Allocation .

 If the ouptut type is unsigned the value is normalized from
 (0-1) to (0-255) and converted. If the output vector size is
 less than four the unused channels are discarded.

 Supported elements types are  Element#U8   Element#U8_2   Element#U8_3   Element#U8_4 
  Element#F32   Element#F32_2   Element#F32_3  and  Element#F32_4 .
 * @apiSince 17"
android,renderscript,ScriptIntrinsicResize,6,Intrinsic for performing a resize of a 2D allocation.
android,renderscript,Type,11,"A Type describes the  Element  and dimensions used for an  Allocation  or a parallel operation. Types are created through  Type.Builder . A Type always includes an  Element  and an X
 dimension. A Type may be multidimensional up to three dimensions. A nonzero
 value in the Y or Z dimensions indicates that the dimension is present. Note
 that a Type with only a given X dimension and a Type with the same X
 dimension but Y = 1 are not equivalent. A Type also supports inclusion of level of detail (LOD) or cube map
 faces. LOD and cube map faces are booleans to indicate present or not
 present.  A Type also supports YUV format information to support an
  Allocation  in a YUV format. The YUV formats
 supported are  ImageFormat.YV12 
  ImageFormat.NV21  and
  ImageFormat.YUV_420_888"
android,renderscript,Type.Builder,7,Builder class for Type.
android,service.vr,VrListenerService,3,"A service that is bound from the system while running in virtual reality (VR) mode.

  To extend this class you must declare the service in your manifest file with
 the  Manifest.permission.BIND_VR_LISTENER_SERVICE  permission
 and include an intent filter with the  SERVICE_INTERFACE  action. For example: 
 <service android:name="".VrListener""
          android:label=""@string/service_name""
          android:permission=""android.permission.BIND_VR_LISTENER_SERVICE"">
     <intent-filter>
         <action android:name=""android.service.vr.VrListenerService"" />
     </intent-filter>
 </service>
  This service is bound when the system enters VR mode and is unbound when the system leaves VR
 mode. The system will enter VR mode when an application that has previously called
  Activity.setVrModeEnabled(boolean ComponentName)  gains user focus.  The system will only start this
 service if the VR application has specifically targeted this service by specifying
 its  ComponentName  in the call to  Activity.setVrModeEnabled(boolean ComponentName)  and if
 this service is installed and enabled in the current user's settings."
android,service.wallpaper,WallpaperService,5,"A wallpaper service is responsible for showing a live wallpaper behind
 applications that would like to sit on top of it.  This service object
 itself does very little -- its only purpose is to generate instances of
  Engine  as needed.  Implementing a wallpaper thus
 involves subclassing from this subclassing an Engine implementation
 and implementing  onCreateEngine()  to return a new instance of
 your engine."
android,service.wallpaper,WallpaperService.Engine,23,"The actual implementation of a wallpaper.  A wallpaper service may
 have multiple instances running (for example as a real wallpaper
 and as a preview) each of which is represented by its own Engine
 instance.  You must implement  WallpaperService#onCreateEngine() 
 to return your concrete Engine implementation."
android,service.voice,AlwaysOnHotwordDetector,6,"A class that lets a VoiceInteractionService implementation interact with
 always-on keyphrase detection APIs."
android,service.voice,AlwaysOnHotwordDetector.Callback,5,Callbacks for always-on hotword detection.
android,service.voice,AlwaysOnHotwordDetector.EventPayload,2,Additional payload for  Callback#onDetected .
android,service.voice,VoiceInteractionService,12,"Top-level service of the current global voice interactor which is providing
 support for hotwording the back-end of a  VoiceInteractor  etc.
 The current VoiceInteractionService that has been selected by the user is kept
 always running by the system to allow it to do things like listen for hotwords
 in the background to instigate voice interactions.

  Because this service is always running it should be kept as lightweight as
 possible.  Heavy-weight operations (including showing UI) should be implemented
 in the associated  VoiceInteractionSessionService  when
 an actual voice interaction is taking place and that service should run in a
 separate process from this one."
android,service.voice,VoiceInteractionSession,51,"An active voice interaction session providing a facility for the implementation
 to interact with the user in the voice interaction layer.  The user interface is
 initially shown by default and can be created be overriding  onCreateContentView() 
 in which the UI can be built.

  A voice interaction session can be self-contained ultimately calling  finish() 
 when done.  It can also initiate voice interactions with applications by calling
  startVoiceActivity(Intent)"
android,service.voice,VoiceInteractionSession.AbortVoiceRequest,3,"A request to report that the current user interaction can not be completed with voice as per
  VoiceInteractor.AbortVoiceRequest ."
android,service.voice,VoiceInteractionSession.ActivityId,2,"Represents the id of an assist source activity. You can use
  equals(java.lang.Object)  to compare instances of this class."
android,service.voice,VoiceInteractionSession.AssistState,7,"Represents assist state captured when this session was started.
 It contains the various assist data objects and a reference to
 the source activity."
android,service.voice,VoiceInteractionSession.CommandRequest,3,"A generic vendor-specific request as per
  VoiceInteractor.CommandRequest ."
android,service.voice,VoiceInteractionSession.CompleteVoiceRequest,3,"A request to simply inform the user that the voice operation has completed as per
  VoiceInteractor.CompleteVoiceRequest ."
android,service.voice,VoiceInteractionSession.ConfirmationRequest,3,"A request for confirmation from the user of an operation as per
  VoiceInteractor.ConfirmationRequest ."
android,service.voice,VoiceInteractionSession.Insets,0,Information about where interesting parts of the input method UI appear.
android,service.voice,VoiceInteractionSession.PickOptionRequest,5,"A request for the user to pick from a set of option as per
  VoiceInteractor.PickOptionRequest ."
android,service.voice,VoiceInteractionSession.Request,6,"Base class representing a request from a voice-driver app to perform a particular
 voice operation with the user.  See related subclasses for the types of requests
 that are possible."
android,service.voice,VoiceInteractionSessionService,7,An active voice interaction session initiated by a  VoiceInteractionService .
android,speech,RecognitionService,5,"This class provides a base class for recognition service implementations. This class should be
 extended only in case you wish to implement a new speech recognizer. Please note that the
 implementation of this service is stateless."
android,speech,RecognitionService.Callback,9,"This class receives callbacks from the speech recognition service and forwards them to the
 user. An instance of this class is passed to the
  RecognitionService#onStartListening(Intent Callback)  method. Recognizers may call
 these methods on any thread."
android,speech,RecognizerIntent,1,Constants for supporting speech recognition through starting an  Intent
android,speech,RecognizerResultsIntent,0,"Constants for intents related to showing speech recognition results.

 These constants should not be needed for normal utilization of speech recognition. They
 would only be called if you wanted to trigger a view of voice search results in your
 application or implemented if you wanted to offer a different view for voice search results
 with your application.

 The standard behavior here for someone receiving an  ACTION_VOICE_SEARCH_RESULTS  is to
 first retrieve the list of  EXTRA_VOICE_SEARCH_RESULT_STRINGS  and use any provided
 HTML for that result in  EXTRA_VOICE_SEARCH_RESULT_HTML  if available to display
 the search results. If that is not available then the corresponding url for that result in
  EXTRA_VOICE_SEARCH_RESULT_URLS  should be used. And if even that is not available
 then a search url should be constructed from the actual recognition result string."
android,speech,SpeechRecognizer,8,"This class provides access to the speech recognition service. This service allows access to the
 speech recognizer. Do not instantiate this class directly instead call
  SpeechRecognizer#createSpeechRecognizer(Context) . This class's methods must be
 invoked only from the main application thread.

  The implementation of this API is likely to stream audio to remote servers to perform speech
 recognition. As such this API is not intended to be used for continuous recognition which would
 consume a significant amount of battery and bandwidth.

  Please note that the application must have  Manifest.permission.RECORD_AUDIO 
 permission to use this class."
android,speech.tts,SynthesisRequest,10,"Contains data required by engines to synthesize speech. This data is:
  The text to synthesize The synthesis locale represented as a language country and a variant.
   The language is an ISO 639-3 letter language code and the country is an
   ISO 3166 alpha 3 code. The variant is not specified. The name of the voice requested for this synthesis. May be empty if
   the client uses  TextToSpeech#setLanguage  instead of
    TextToSpeech#setVoice The synthesis speech rate with 100 being the normal and
   higher values representing higher speech rates. The voice pitch with 100 being the default pitch. params TextToSpeech#speak TextToSpeech#synthesizeToFile"
android,speech.tts,TextToSpeech,38,"Synthesizes speech from text for immediate playback or to create a sound file.
  A TextToSpeech instance can only be used to synthesize text once it has completed its
 initialization. Implement the  TextToSpeech.OnInitListener  to be
 notified of the completion of the initialization. 
 When you are done using the TextToSpeech instance call the  shutdown()  method
 to release the native resources used by the TextToSpeech engine."
android,speech.tts,TextToSpeech.Engine,0,"Constants and parameter names for controlling text-to-speech. These include:

  
         Intents to ask engine to install data or check its data and
         extras for a TTS engine's check data activity.
      
         Keys for the parameters passed with speak commands e.g.
          Engine#KEY_PARAM_UTTERANCE_ID   Engine#KEY_PARAM_STREAM .
      
         A list of feature strings that engines might support e.g
          Engine#KEY_FEATURE_NETWORK_SYNTHESIS . These values may be passed in to
          TextToSpeech#speak  and  TextToSpeech#synthesizeToFile  to modify
         engine behaviour. The engine can be queried for the set of features it supports
         through  TextToSpeech#getFeatures(java.util.Locale) ."
android,speech.tts,TextToSpeech.EngineInfo,1,Information about an installed text-to-speech engine.
android,speech.tts,TextToSpeechService,13,"Abstract base class for TTS engine implementations. The following methods
 need to be implemented:
  onIsLanguageAvailable(String String String) onLoadLanguage(String String String) onGetLanguage() onSynthesizeText(SynthesisRequest SynthesisCallback) onStop() onSynthesizeText(SynthesisRequest SynthesisCallback) onStop() onGetLanguage() onGetVoices() onIsValidVoiceName(java.lang.String) onLoadVoice(java.lang.String) onGetDefaultVoiceNameFor(java.lang.String java.lang.String java.lang.String) onGetLanguage() onIsLanguageAvailable(String String String) onLoadLanguage(String String String) onGetDefaultVoiceNameFor(java.lang.String java.lang.String java.lang.String) TextToSpeech#setLanguage TextToSpeech#setVoice onGetDefaultVoiceNameFor(java.lang.String java.lang.String java.lang.String) SynthesisRequest"
android,speech.tts,UtteranceProgressListener,8,"Listener for events relating to the progress of an utterance through
 the synthesis queue. Each utterance is associated with a call to
  TextToSpeech#speak  or  TextToSpeech#synthesizeToFile  with an
 associated utterance identifier as per  TextToSpeech.Engine#KEY_PARAM_UTTERANCE_ID .

 The callbacks specified in this method can be called from multiple threads."
android,speech.tts,Voice,11,"Characteristics and features of a Text-To-Speech Voice. Each TTS Engine can expose
 multiple voices for each locale with different set of features."
android,system,Int64Ref,0,A signed 64bit integer reference suitable for passing to lower-level system calls.
android,system,Os,101,"Access to low-level system functionality. Most of these are system calls. Most users will want
 to use higher-level APIs where available but this class provides access to the underlying
 primitives used to implement the higher-level APIs.

  The corresponding constants can be found in  OsConstants ."
android,system,OsConstants,16,Constants and helper functions for use with  Os .
android,system,StructPollfd,1,"Used as an in/out parameter to  Os#poll .
 Corresponds to C's  struct pollfd  from  <poll.h> ."
android,system,StructStat,1,"File information returned by  Os#fstat   Os#lstat  and  Os#stat .
 Corresponds to C's  struct stat  from  <stat.h> ."
android,system,StructStatVfs,1,File information returned by  Os#fstatvfs  and  Os#statvfs .
android,system,StructTimespec,4,Corresponds to C's  struct timespec  from  <time.h> .
android,system,StructTimeval,5,Corresponds to C's  struct timeval  from  sys/time.h .
android,system,StructUtsname,1,"Information returned by  Os#uname .
 Corresponds to C's  struct utsname  from  <sys/utsname.h> ."
android,telephony.cdma,CdmaCellLocation,13,Represents the cell location on a CDMA phone.
android,telephony.data,ApnSetting,23,"An Access Point Name (APN) configuration for a carrier data connection.

  The APN provides configuration to connect a cellular network device to an IP data network. A
 carrier uses the name type and other configuration in an  APNSetting  to decide which IP
 address to assign any security methods to apply and how the device might be connected to
 private networks.

  Use  ApnSetting.Builder  to create new instances."
android,telephony.data,ApnSetting.Builder,21,"Provides a convenient way to set the fields of a  ApnSetting  when creating a new
 instance. The following settings are required to build an  ApnSetting :

  apnTypeBitmask apnName entryName The example below shows how you might create a new  ApnSetting :

  
 // Create an MMS proxy address with a hostname. A network might not be
 // available so supply a dummy (0.0.0.0) IPv4 address to avoid DNS lookup.
 String host = ""mms.example.com"";
 byte[] ipAddress = new byte[4];
 InetAddress mmsProxy;
 try {
   mmsProxy = InetAddress.getByAddress(host ipAddress);
 } catch (UnknownHostException e) {
   e.printStackTrace();
   return;
 }

 ApnSetting apn = new ApnSetting.Builder()
     .setApnTypeBitmask(ApnSetting.TYPE_DEFAULT | ApnSetting.TYPE_MMS)
     .setApnName(""apn.example.com"")
     .setEntryName(""Example Carrier APN"")
     .setMmsc(Uri.parse(""http://mms.example.com:8002""))
     .setMmsProxyAddress(mmsProxy)
     .setMmsProxyPort(8799)
     .build();"
android,telephony.emergency,EmergencyNumber,15,"A parcelable class that wraps and retrieves the information of number service category(s) and
 country code for a specific emergency number."
android,telephony.euicc,DownloadableSubscription,5,"Information about a subscription which is downloadable to an eUICC using
  EuiccManager#downloadSubscription(DownloadableSubscription boolean PendingIntent)"
android,telephony.euicc,EuiccInfo,3,Information about an eUICC chip/device.
android,telephony.euicc,EuiccManager,9,"EuiccManager is the application interface to eUICCs or eSIMs/embedded SIMs.

  You do not instantiate this class directly; instead you retrieve an instance through
  Context#getSystemService(String)  and  Context#EUICC_SERVICE . This instance will be
 created using the default eUICC.

  On a device with multiple eUICCs you may want to create multiple EuiccManagers. To do this
 you can call  createForCardId(int) .

  See  isEnabled()  before attempting to use these APIs."
android,telephony.gsm,GsmCellLocation,9,Represents the cell location on a GSM phone.
android,telephony.gsm,SmsManager,5,"Manages SMS operations such as sending data text and pdu SMS messages.
 Get this object by calling the static method SmsManager.getDefault()."
android,telephony.gsm,SmsMessage,30,A Short Message Service message.
android,telephony.gsm,SmsMessage.SubmitPdu,1,
android,telecom,Call.Callback,16,"Defines callbacks which inform the  InCallService  of changes to a  Call .
 These callbacks can originate from the Telecom framework or a  ConnectionService 
 implementation.
  
 You can handle these callbacks by extending the  Callback  class and overriding the
 callbacks that your  InCallService  is interested in.  The callback methods include the
  Call  for which the callback applies allowing reuse of a single instance of your
  Callback  implementation if desired.
  
 Use  Call#registerCallback(Callback)  to register your callback(s).  Ensure
  Call#unregisterCallback(Callback)  is called when you no longer require callbacks
 (typically in  InCallService#onCallRemoved(Call) ).
 Note: Callbacks which occur before you call  Call#registerCallback(Callback)  will not
 reach your implementation of  Callback  so it is important to register your callback
 as soon as your  InCallService  is notified of a new call via
  InCallService#onCallAdded(Call) ."
android,telecom,Call.Details,25,
android,telecom,Call.RttCall,5,"A class that holds the state that describes the state of the RTT channel to the remote
 party if it is active."
android,telecom,CallScreeningService.CallResponse,5,
android,telecom,CallScreeningService.CallResponse.Builder,6,
android,telecom,Conferenceable,0,"Interface used to identify entities with which another entity can participate in a conference
 call with.  The  ConnectionService  implementation will only recognize
  Conferenceable s which are  Connection s or  Conference s."
android,telecom,Connection.RttModifyStatus,0,"Provides constants to represent the results of responses to session modify requests sent via
  Call#sendRttRequest()"
android,telecom,Connection.RttTextStream,3,Provides methods to read and write RTT data to/from the in-call app.
android,telecom,Connection.VideoProvider,17,"Provides a means of controlling the video session associated with a  Connection .
  
 Implementations create a custom subclass of  VideoProvider  and the
  ConnectionService  creates an instance sets it on the  Connection  using
  Connection#setVideoProvider(VideoProvider) .  Any connection which supports video
 should set the  VideoProvider .
  
 The  VideoProvider  serves two primary purposes: it provides a means for Telecom and
  InCallService  implementations to issue requests related to the video session;
 it provides a means for the  ConnectionService  to report events and information
 related to the video session to Telecom and the  InCallService  implementations.
  InCallService  implementations interact with the  VideoProvider  via
  InCallService.VideoCall ."
android,telecom,DisconnectCause,10,"Describes the cause of a disconnected call. This always includes a code describing the generic
 cause of the disconnect. Optionally it may include a label and/or description to display to the
 user. It is the responsibility of the  ConnectionService  to provide localized versions of
 the label and description. It also may contain a reason for the disconnect which is intended for
 logging and not for display to the user."
android,telecom,InCallService.VideoCall,13,"Used to issue commands to the  Connection.VideoProvider  associated with a
  Call ."
android,telecom,PhoneAccount.Builder,10,Helper class for creating a  PhoneAccount .
android,telecom,RemoteConference,19,"A conference provided to a  ConnectionService  by another  ConnectionService  through
  ConnectionService#conferenceRemoteConnections . Once created a  RemoteConference 
 can be used to control the conference call or monitor changes through
  RemoteConnection.Callback ."
android,telecom,RemoteConnection,30,"A connection provided to a  ConnectionService  by another  ConnectionService 
 running in a different process."
android,telecom,RemoteConnection.VideoProvider.Callback,7,"Callback class used by the  RemoteConnection.VideoProvider  to relay events from
 the  Connection.VideoProvider ."
android,telecom,VideoProfile.CameraCapabilities,6,Represents the camera capabilities important to a Video Telephony provider.
android,telecom,Call,37,Represents an ongoing phone call that the in-call app should present to the user.
android,telecom,CallAudioState,10,"Encapsulates the telecom audio state including the current audio routing supported audio
  routing and mute."
android,telecom,CallRedirectionService,6,"This service can be implemented to interact between Telecom and its implementor
 for making outgoing call with optional redirection/cancellation purposes.

  
 Below is an example manifest registration for a  CallRedirectionService .
  <service android:name=""your.package.YourCallRedirectionServiceImplementation""
          android:permission=""android.permission.BIND_REDIRECTION_SERVICE"">
      <intent-filter>
          <action android:name=""android.telecom.CallRedirectionService""/>
      </intent-filter>
 </service>"
android,telecom,CallScreeningService,4,"This service can be implemented by the default dialer (see
  TelecomManager#getDefaultDialerPackage() ) or a third party app to allow or disallow
 incoming calls before they are shown to a user. A  CallScreeningService  can also see
 outgoing calls for the purpose of providing caller ID services for those calls.
  
 Below is an example manifest registration for a  CallScreeningService .
  <service android:name=""your.package.YourCallScreeningServiceImplementation""
          android:permission=""android.permission.BIND_SCREENING_SERVICE"">
      <intent-filter>
          <action android:name=""android.telecom.CallScreeningService""/>
      </intent-filter>
 </service>
  
 A CallScreeningService performs two functions:
  Call blocking/screening - the service can choose which calls will ring on the user's
     device and which will be silently sent to voicemail. Call identification - services which provide call identification functionality can
     display a user-interface of their choosing which contains identifying information for a call."
android,telecom,Conference,45,Represents a conference call which can contain any number of  Connection  objects.
android,telecom,Connection,78,"Represents a phone call or connection to a remote endpoint that carries voice and/or video
 traffic.
  
 Implementations create a custom subclass of  Connection  and return it to the framework
 as the return value of
  ConnectionService#onCreateIncomingConnection(PhoneAccountHandle ConnectionRequest) 
 or
  ConnectionService#onCreateOutgoingConnection(PhoneAccountHandle ConnectionRequest) .
 Implementations are then responsible for updating the state of the  Connection  and
 must call  destroy()  to signal to the framework that the  Connection  is no
 longer used and associated resources may be recovered.
  
 Subclasses of  Connection  override the  on*  methods to provide the the
  ConnectionService 's implementation of calling functionality.  The  on*  methods are
 called by Telecom to inform an instance of a  Connection  of actions specific to that
  Connection  instance.
  
 Basic call support requires overriding the following methods:  onAnswer() 
  onDisconnect()   onReject()   onAbort() 
 Where a  Connection  has  CAPABILITY_SUPPORT_HOLD  the  onHold()  and
  onUnhold()  methods should be overridden to provide hold support for the
  Connection .
  
 Where a  Connection  supports a variation of video calling (e.g. the
  CAPABILITY_SUPPORTS_VT_*  capability bits)  onAnswer(int)  should be overridden
 to support answering a call as a video call.
  
 Where a  Connection  has  PROPERTY_IS_EXTERNAL_CALL  and
  CAPABILITY_CAN_PULL_CALL   onPullExternalCall()  should be overridden to provide
 support for pulling the external call.
  
 Where a  Connection  supports conference calling  onSeparate()  should be
 overridden.
  
 There are a number of other  on*  methods which a  Connection  can choose to
 implement depending on whether it is concerned with the associated calls from Telecom.  If
 for example call events from a  InCallService  are handled
  onCallEvent(java.lang.String android.os.Bundle)  should be overridden.  Another example is
  onExtrasChanged(android.os.Bundle)  which should be overridden if the  Connection  wishes to
 make use of extra information provided via the  Call#putExtras(Bundle)  and
  Call#removeExtras(String...)  methods."
android,telecom,ConnectionRequest,9,"Simple data container encapsulating a request to some entity to
 create a new  Connection ."
android,telecom,ConnectionService,22,"An abstract service that should be implemented by any apps which either:
  Can make phone calls (VoIP or otherwise) and want those calls to be integrated into the
     built-in phone app.  Referred to as a  system managed ConnectionService . Are a standalone calling app and don't want their calls to be integrated into the
     built-in phone app.  Referred to as a  self managed ConnectionService . ConnectionService 
 1.  Registration in AndroidManifest.xml 
 <service android:name=""com.example.package.MyConnectionService""
    android:label=""@string/some_label_for_my_connection_service""
    android:permission=""android.permission.BIND_TELECOM_CONNECTION_SERVICE"">
  <intent-filter>
   <action android:name=""android.telecom.ConnectionService"" />
  </intent-filter>
 </service>
  
 2.   Registration of  PhoneAccount  with  TelecomManager . 
 See  PhoneAccount  and  TelecomManager#registerPhoneAccount  for more information.
  
 System managed  ConnectionService s must be enabled by the user in the phone app settings
 before Telecom will bind to them.  Self-managed  ConnectionService s must be granted the
 appropriate permission before Telecom will bind to them.
  
 Once registered and enabled by the user in the phone app settings or granted permission telecom
 will bind to a  ConnectionService  implementation when it wants that
  ConnectionService  to place a call or the service has indicated that is has an incoming
 call through  TelecomManager#addNewIncomingCall . The  ConnectionService  can then
 expect a call to  onCreateIncomingConnection(PhoneAccountHandle ConnectionRequest)  or  onCreateOutgoingConnection(PhoneAccountHandle ConnectionRequest) 
 wherein it should provide a new instance of a  Connection  object.  It is through this
  Connection  object that telecom receives state updates and the  ConnectionService 
 receives call-commands such as answer reject hold and disconnect.
  
 When there are no more live calls telecom will unbind from the  ConnectionService ."
android,telecom,InCallService,15,"This service is implemented by an app that wishes to provide functionality for managing
 phone calls."
android,telecom,PhoneAccountSuggestion,7,
android,telecom,GatewayInfo,6,"Encapsulated gateway address information for outgoing call. When calls are made the system
 provides a facility to specify two addresses for the call: one to display as the address being
 dialed and a separate (gateway) address to actually dial. Telecom provides this information to
  ConnectionService s when placing the call as an instance of  GatewayInfo .
  
 The data consists of an address to call an address to display and the package name of the
 service. This data is used in two ways:
   Call the appropriate gateway address.
   Display information about how the call is being routed to the user."
android,telecom,InCallService.VideoCall.Callback,7,"The  InCallService  extends this class to provide a means of receiving callbacks
 from the  Connection.VideoProvider .
  
 When the  InCallService  receives the
  Call.Callback#onVideoCallChanged(Call VideoCall)  callback it should create an
 instance its  VideoCall.Callback  implementation and set it on the
  VideoCall  using  VideoCall#registerCallback(Callback) ."
android,telecom,PhoneAccount,20,"Represents a distinct method to place or receive a phone call. Apps which can place calls and
 want those calls to be integrated into the dialer and in-call UI should build an instance of
 this class and register it with the system using  TelecomManager .
  TelecomManager  uses registered  PhoneAccount s to present the user with
 alternative options when placing a phone call. When building a  PhoneAccount  the app
 should supply a valid  PhoneAccountHandle  that references the connection service
 implementation Telecom will use to interact with the app."
android,telecom,PhoneAccountHandle,8,"The unique identifier for a  PhoneAccount . A  PhoneAccountHandle  is made of two
 parts:
  The component name of the associated connection service. A string identifier that is unique across  PhoneAccountHandle s with the same
      component name. ComponentName UserHandle PhoneAccount TelecomManager"
android,telecom,RemoteConference.Callback,9,Callback base class for  RemoteConference .
android,telecom,RemoteConnection.Callback,18,Callback base class for  RemoteConnection .
android,telecom,RemoteConnection.VideoProvider,12,"RemoteConnection.VideoProvider  associated with a  RemoteConnection .  Used to
 receive video related events and control the video associated with a
  RemoteConnection ."
android,telecom,StatusHints,7,Contains status label and icon displayed in the in-call UI.
android,telecom,TelecomManager,31,"Provides access to information about active calls and registration/call-management functionality.
 Apps can use methods in this class to determine the current call state.
  
 Apps do not instantiate this class directly; instead they retrieve a reference to an instance
 through  Context#getSystemService .
  
 Note that access to some telecom information is permission-protected. Your app cannot access the
 protected information or gain access to protected functionality unless it has the appropriate
 permissions declared in its manifest file. Where permissions apply they are noted in the method
 descriptions."
android,telecom,VideoProfile,12,Represents attributes of video calls.
android,telephony.mbms,DownloadProgressListener,1,"A optional listener class used by download clients to track progress. Apps should extend this
 class and pass an instance into
  MbmsDownloadSession#download(DownloadRequest) 

 This is optionally specified when requesting a download and will only be called while the app
 is running."
android,telephony.mbms,DownloadRequest,11,"Describes a request to download files over cell-broadcast. Instances of this class should be
 created by the app when requesting a download and instances of this class will be passed back
 to the app when the middleware updates the status of the download."
android,telephony.mbms,DownloadStatusListener,1,"A optional listener class used by download clients to track progress. Apps should extend this
 class and pass an instance into
  MbmsDownloadSession#download(DownloadRequest) 

 This is optionally specified when requesting a download and will only be called while the app
 is running."
android,telephony.mbms,FileServiceInfo,3,"Describes a file service available from the carrier from which files can be downloaded via
 cell-broadcast."
android,telephony.mbms,GroupCall,3,"Class used to represent a single MBMS group call. After a call has been started with
  MbmsGroupCallSession#startGroupCall 
 this class is used to hold information about the call and control it."
android,telephony.mbms,MbmsDownloadSessionCallback,3,"A callback class that apps should use to receive information on file downloads over
 cell-broadcast."
android,telephony.mbms,MbmsErrors,0,
android,telephony.mbms,MbmsErrors.DownloadErrors,0,Indicates the errors that are applicable only to the file-download use-case
android,telephony.mbms,MbmsErrors.GroupCallErrors,0,Indicates the errors that are applicable only to the group call use-case.
android,telephony.mbms,DownloadRequest.Builder,6,
android,telephony.mbms,FileInfo,6,Describes a single file that is available over MBMS.
android,telephony.mbms,MbmsDownloadReceiver,0,"The  BroadcastReceiver  responsible for handling intents sent from the middleware. Apps
 that wish to download using MBMS APIs should declare this class in their AndroidManifest.xml as
 follows:
  <receiver
    android:name=""android.telephony.mbms.MbmsDownloadReceiver""
    android:permission=""android.permission.SEND_EMBMS_INTENTS""
    android:enabled=""true""
    android:exported=""true"">
 </receiver>"
android,telephony.mbms,MbmsErrors.GeneralErrors,0,"Indicates the errors that may occur at any point and are applicable to both
 streaming and file-download."
android,telephony.mbms,MbmsErrors.InitializationErrors,0,"Indicates errors that may be generated during initialization by the
 middleware. They are applicable to both streaming and file-download use-cases."
android,telephony.mbms,MbmsErrors.StreamingErrors,0,Indicates the errors that are applicable only to the streaming use-case
android,telephony.mbms,MbmsStreamingSessionCallback,3,"A callback class that is used to receive information from the middleware on MBMS streaming
 services. An instance of this object should be passed into
  MbmsStreamingSession#create(Context Executor int MbmsStreamingSessionCallback) ."
android,telephony.mbms,ServiceInfo,9,"Describes a cell-broadcast service. This class should not be instantiated directly -- use
  StreamingServiceInfo  or  FileServiceInfo"
android,telephony.mbms,StreamingService,3,"Class used to represent a single MBMS stream. After a stream has been started with
  MbmsStreamingSession#startStreaming(StreamingServiceInfo java.util.concurrent.Executor
 StreamingServiceCallback) 
 this class is used to hold information about the stream and control it."
android,telephony.mbms,StreamingServiceCallback,5,"A callback class for use when the application is actively streaming content. The middleware
 will provide updates on the status of the stream via this callback."
android,telephony.mbms,StreamingServiceInfo,2,Describes a single MBMS streaming service.
android,test.mock,MockAccountManager,1,"A mock  AccountManager  class.

  Provided for use by  android.test.IsolatedContext ."
android,test.mock,MockApplication,3,"A mock  Application  class.  All methods are non-functional and throw
  UnsupportedOperationException .  Override it as necessary to provide the
 operations that you need."
android,test.mock,MockContentProvider,12,"Mock implementation of ContentProvider.  All methods are non-functional and throw
  UnsupportedOperationException .  Tests can extend this class to
 implement behavior needed for tests."
android,test.mock,MockContentResolver,2,"An extension of  ContentResolver  that is designed for
      testing.
  
      MockContentResolver overrides Android's normal way of resolving providers by
      authority. To have access to a provider based on its authority users of
      MockContentResolver first instantiate the provider and
      use  MockContentResolver#addProvider(String ContentProvider) . Resolution of an
      authority occurs entirely within MockContentResolver.
  
      Users can also set an authority's entry in the map to null so that a provider is completely
      mocked out."
android,test.mock,MockContext,107,"A mock  Context  class.  All methods are non-functional and throw
  UnsupportedOperationException .  You can use this to inject other dependencies
 mocks or monitors into the classes you are testing."
android,test.mock,MockCursor,43,"A mock  Cursor  class that isolates the test code from real
 Cursor implementation.

  
 All methods including ones related to querying the state of the cursor are
 are non-functional and throw  UnsupportedOperationException ."
android,test.mock,MockResources,35,"A mock  Resources  class. All methods are non-functional and throw
  UnsupportedOperationException . Override it to provide the operations that you
 need."
android,test.mock,MockService,1,"A mock  Service  class.

  Provided for use by  android.test.ServiceTestCase ."
android,test.mock,MockDialogInterface,2,"A mock  DialogInterface  class.  All methods are non-functional and throw
  UnsupportedOperationException . Override it to provide the operations that you
 need."
android,test.mock,MockPackageManager,90,"A mock  PackageManager  class.  All methods are non-functional and throw
  UnsupportedOperationException . Override it to provide the operations that you
 need."
android,test.suitebuilder,TestMethod,8,"Represents a test to be run. Can be constructed without instantiating the TestCase or even
 loading the class."
android,test.suitebuilder,TestSuiteBuilder,6,"Build suites based on a combination of included packages excluded packages
 and predicates that must be satisfied."
android,test.suitebuilder,TestSuiteBuilder.FailedToCreateTests,1,"A special  TestCase  used to indicate a failure during the build()
 step."
android,test,ActivityInstrumentationTestCase,4,"This class provides functional testing of a single activity.  The activity under test will
 be created using the system infrastructure (by calling InstrumentationTestCase.launchActivity())
 and you will then be able to manipulate your Activity directly.  Most of the work is handled
 automatically here by  setUp()  and  tearDown() .

  If you prefer an isolated unit test see  ActivityUnitTestCase ."
android,test,ActivityInstrumentationTestCase2,6,"This class provides functional testing of a single activity.  The activity under test will
 be created using the system infrastructure (by calling InstrumentationTestCase.launchActivity())
 and you will then be able to manipulate your Activity directly.

  Other options supported by this test case include:
  You can run any test method on the UI thread (see  UiThreadTest ). You can inject custom Intents into your Activity (see
  setActivityIntent(android.content.Intent) ). This class replaces  ActivityInstrumentationTestCase  which is deprecated.
 New tests should be written using this base class.

  If you prefer an isolated unit test see  ActivityUnitTestCase ."
android,test,ActivityUnitTestCase,11,"This class provides isolated testing of a single activity.  The activity under test will
 be created with minimal connection to the system infrastructure and you can inject mocked or
 wrappered versions of many of Activity's dependencies.  Most of the work is handled
 automatically here by  setUp()  and  tearDown() .

  If you prefer a functional test see  ActivityInstrumentationTestCase .

  It must be noted that as a true unit test your Activity will not be running in the
 normal system and will not participate in the normal interactions with other Activities.
 The following methods should not be called in this configuration - most of them will throw
 exceptions:
  Activity.createPendingResult(int Intent int) Activity.startActivityIfNeeded(Intent int) Activity.startActivityFromChild(Activity Intent int) Activity.startNextMatchingActivity(Intent) Activity.getCallingActivity() Activity.getCallingPackage() Activity.createPendingResult(int Intent int) Activity.getTaskId() Activity.isTaskRoot() Activity.moveTaskToBack(boolean) The following methods may be called but will not do anything.  For test purposes you can use
 the methods  getStartedActivityIntent()  and  getStartedActivityRequest()  to
 inspect the parameters that they were called with.
  Activity.startActivity(Intent) Activity.startActivityForResult(Intent int) The following methods may be called but will not do anything.  For test purposes you can use
 the methods  isFinishCalled()  and  getFinishedActivityRequest()  to inspect the
 parameters that they were called with.
  Activity.finish() Activity.finishFromChild(Activity) Activity.finishActivity(int)"
android,test,AndroidTestCase,9,Extend this if you need to access Resources or other things that depend on Activity Context.
android,test,AndroidTestRunner,18,
android,test,ApplicationTestCase,7,"This test case provides a framework in which you can test Application classes in
 a controlled environment.  It provides basic support for the lifecycle of a
 Application and hooks by which you can inject various dependencies and control
 the environment in which your Application is tested.

  Lifecycle Support. 
 Every Application is designed to be accessed within a specific sequence of
 method calls (see  Application  for more details).
 In order to support the lifecycle of a Application this test case will make the
 following calls at the following times.

  The test case will not call onCreate() until your test calls
  createApplication() .  This gives you a chance
 to set up or adjust any additional framework or test logic before
 onCreate(). After your test completes the test case  tearDown()  method is
 automatically called and it will stop & destroy your application by calling its
 onDestroy() method. Dependency Injection. 
 Every Application has one inherent dependency the  Context  in
 which it runs.
 This framework allows you to inject a modified mock or isolated replacement for this
 dependencies and thus perform a true unit test.

  If simply run your tests as-is your Application will be injected with a fully-functional
 Context.
 You can create and inject alternative types of Contexts by calling
  AndroidTestCase#setContext(Context) .  You must do this  before  calling
  createApplication() .  The test framework provides a
 number of alternatives for Context including  MockContext 
  RenamingDelegatingContext  and
  ContextWrapper ."
android,test,InstrumentationTestCase,11,A test case that has access to  Instrumentation .
android,test,InstrumentationTestRunner,7,"An  Instrumentation  that runs various types of  TestCase s against
 an Android package (application)."
android,test,IsolatedContext,13,"A mock context which prevents its users from talking to the rest of the device while
 stubbing enough methods to satify code that tries to talk to other packages."
android,test,SingleLaunchActivityTestCase,4,"If you would like to test a single activity with an
  InstrumentationTestCase  this provides some of the boiler plate to
 launch and finish the activity in  setUp()  and  tearDown() .

 This launches the activity only once for the entire class instead of doing it
 in every setup / teardown call."
android,test,ActivityTestCase,0,"This is common code used to support Activity test cases.  For more useful classes please see
  ActivityUnitTestCase  and
  ActivityInstrumentationTestCase ."
android,test,InstrumentationTestSuite,2,"A  TestSuite  that injects  Instrumentation  into
  InstrumentationTestCase  before running them."
android,test,LoaderTestCase,1,"A convenience class for testing  Loader s. This test case
 provides a simple way to synchronously get the result from a Loader making
 it easy to assert that the Loader returns the expected result."
android,test,ProviderTestCase,6,"If you would like to test a single content provider with an
  InstrumentationTestCase  this provides some of the boiler plate in  setUp()  and
  tearDown() ."
android,test,ProviderTestCase2,6,"This test case class provides a framework for testing a single
  ContentProvider  and for testing your app code with an
 isolated content provider. Instead of using the system map of
 providers that is based on the manifests of other applications the test
 case creates its own internal map. It then uses this map to resolve providers
 given an authority. This allows you to inject test providers and to null out
 providers that you do not want to use.
  
      This test case also sets up the following mock objects:
  
          An  IsolatedContext  that stubs out Context methods that might
          affect the rest of the running system while allowing tests to do real file and
          database work.
       
          A  MockContentResolver  that provides the functionality of a
          regular content resolver but uses  IsolatedContext . It stubs out
           ContentResolver#notifyChange(Uri ContentObserver boolean)  to
          prevent the test from affecting the running system.
       
          An instance of the provider under test running in an  IsolatedContext .
       
      This framework is set up automatically by the base class'  setUp()  method. If you
      override this method you must call the super method as the first statement in
      your override.
  
     In order for their tests to be run concrete subclasses must provide their own
     constructor with no arguments. This constructor must call
      ProviderTestCase2(java.lang.Class java.lang.String)  as  its first operation.
  Content Provider Testing"
android,test,RenamingDelegatingContext,15,"This is a class which delegates to the given context but performs database
 and file operations with a renamed database/file name (prefixes default
 names with a given prefix)."
android,test,ServiceTestCase,11,"This test case provides a framework in which you can test Service classes in
 a controlled environment.  It provides basic support for the lifecycle of a
 Service and hooks with which you can inject various dependencies and control
 the environment in which your Service is tested."
android,test,SyncBaseInstrumentation,0,"If you would like to test sync a single provider with an
  InstrumentationTestCase  this provides some of the boiler plate in  setUp()  and
  InstrumentationTestCase.tearDown() ."
android,test,MoreAsserts,36,Contains additional assertion methods not found in JUnit.
android,test,TouchUtils,31,"Reusable methods for generating touch events. These methods can be used with
 InstrumentationTestCase or ActivityInstrumentationTestCase2 to simulate user interaction with
 the application through a touch screen."
android,test,ViewAsserts,18,Some useful assertions about views.
android,telephony,AccessNetworkConstants.AccessNetworkType,0,
android,telephony,AccessNetworkConstants.EutranBand,0,"Frenquency bands for EUTRAN.
 http://www.etsi.org/deliver/etsi_ts/136100_136199/136101/14.03.00_60/ts_136101v140p.pdf"
android,telephony,AccessNetworkConstants.GeranBand,0,"Frequency bands for GERAN.
 http://www.etsi.org/deliver/etsi_ts/145000_145099/145005/14.00.00_60/ts_145005v140000p.pdf"
android,telephony,CarrierConfigManager,4,Provides access to telephony configuration values that are carrier-specific.
android,telephony,CellIdentityCdma,9,CellIdentity is to represent a unique CDMA cell
android,telephony,CellIdentityGsm,14,CellIdentity to represent a unique GSM cell
android,telephony,CellIdentityLte,14,CellIdentity is to represent a unique LTE cell
android,telephony,CellIdentityWcdma,13,CellIdentity to represent a unique UMTS cell
android,telephony,CellInfo,8,Immutable cell information from a point in time.
android,telephony,CellInfoCdma,7,A  CellInfo  representing a CDMA cell that provides identity and measurement info.
android,telephony,CellInfoLte,7,A  CellInfo  representing an LTE cell that provides identity and measurement info.
android,telephony,CellInfoNr,6,A  CellInfo  representing an 5G NR cell that provides identity and measurement info.
android,telephony,CellInfoWcdma,7,A  CellInfo  representing a WCDMA cell that provides identity and measurement info.
android,telephony,CellLocation,2,Abstract class that represents the location of the device.
android,telephony,CellSignalStrengthCdma,15,Signal strength related information.
android,telephony,CellSignalStrengthGsm,10,GSM signal strength related information.
android,telephony,CellSignalStrengthNr,13,5G NR signal strength related information.
android,telephony,CellSignalStrengthTdscdma,9,"Tdscdma signal strength related information.

 This class provides signal strength and signal quality information for the TD-SCDMA air
 interface. For more information see 3gpp 25.225."
android,telephony,CellSignalStrengthWcdma,8,Wcdma signal strength related information.
android,telephony,IccOpenLogicalChannelResponse,6,Response to the  TelephonyManager#iccOpenLogicalChannel  command.
android,telephony,MbmsGroupCallSession,4,This class provides functionality for accessing group call functionality over MBMS.
android,telephony,MbmsStreamingSession,5,This class provides functionality for streaming media over MBMS.
android,telephony,NetworkScan,1,"The caller of
  TelephonyManager#requestNetworkScan(NetworkScanRequest Executor NetworkScanCallback) 
 will receive an instance of  NetworkScan  which contains a callback method
  stopScan()  for stopping the in-progress scan."
android,telephony,NetworkScanRequest,11,"Defines a request to peform a network scan.

 This class defines whether the network scan will be performed only once or periodically until
 cancelled when the scan is performed periodically the time interval is not controlled by the
 user but defined by the modem vendor."
android,telephony,PhoneStateListener,13,"A listener class for monitoring changes in specific telephony states
 on the device including service state signal strength message
 waiting indicator (voicemail) and others.
  
 Override the methods for the state that you wish to receive updates for and
 pass your PhoneStateListener object along with bitwise-or of the LISTEN_
 flags to  TelephonyManager#listen . Methods are
 called when the state changes as well as once on initial registration.
  
 Note that access to some telephony information is
 permission-protected. Your application won't receive updates for protected
 information unless it has the appropriate permissions declared in
 its manifest file. Where permissions apply they are noted in the
 appropriate LISTEN_ flags."
android,telephony,ServiceState,23,"Contains phone state and service related information.

 The following phone information is included in returned ServiceState:

  Service state: IN_SERVICE OUT_OF_SERVICE EMERGENCY_ONLY POWER_OFF
    Duplex mode: UNKNOWN FDD TDD
    Roaming indicator
    Operator name short name and numeric id
    Network selection mode"
android,telephony,SignalStrength,16,Contains phone signal strength related information.
android,telephony,SmsManager,16,"Manages SMS operations such as sending data text and pdu SMS messages.
 Get this object by calling the static method  getDefault() . To create an instance of
  SmsManager  associated with a specific subscription ID call
  getSmsManagerForSubscriptionId(int) . This is typically used for devices that support
 multiple active subscriptions at once.

  For information about how to behave as the default SMS app on Android 4.4 (API level 19)
 and higher see  Telephony ."
android,telephony,SmsManager.FinancialSmsCallback,1,callback for providing asynchronous sms messages for financial app.
android,telephony,SmsMessage.SubmitPdu,1,
android,telephony,SubscriptionInfo,25,A Parcelable class for Subscription Information.
android,telephony,SubscriptionManager.OnOpportunisticSubscriptionsChangedListener,1,"A listener class for monitoring changes to  SubscriptionInfo  records of opportunistic
 subscriptions.
  
 Override the onOpportunisticSubscriptionsChanged method in the object that extends this
 or  SubscriptionManager.addOnOpportunisticSubscriptionsChangedListener(java.util.concurrent.Executor android.telephony.SubscriptionManager.OnOpportunisticSubscriptionsChangedListener) 
 to register your listener and to unregister invoke
  SubscriptionManager.removeOnOpportunisticSubscriptionsChangedListener(android.telephony.SubscriptionManager.OnOpportunisticSubscriptionsChangedListener) 
 Permissions android.Manifest.permission.READ_PHONE_STATE is required
 for #onOpportunisticSubscriptionsChanged to be invoked."
android,telephony,SubscriptionManager.OnSubscriptionsChangedListener,1,"A listener class for monitoring changes to  SubscriptionInfo  records.
  
 Override the onSubscriptionsChanged method in the object that extends this
 class and pass it to  SubscriptionManager.addOnSubscriptionsChangedListener(android.telephony.SubscriptionManager.OnSubscriptionsChangedListener) 
 to register your listener and to unregister invoke
  SubscriptionManager.removeOnSubscriptionsChangedListener(android.telephony.SubscriptionManager.OnSubscriptionsChangedListener) 
 Permissions android.Manifest.permission.READ_PHONE_STATE is required
 for #onSubscriptionsChanged to be invoked."
android,telephony,TelephonyManager.UssdResponseCallback,2,"Used to notify callers of
  TelephonyManager#sendUssdRequest(String UssdResponseCallback Handler)  when the
 network either successfully executes a USSD request or if there was a failure while
 executing the request.
  onReceiveUssdResponse(android.telephony.TelephonyManager java.lang.String java.lang.CharSequence)  will be called if the
 USSD request has succeeded.
  onReceiveUssdResponseFailed(android.telephony.TelephonyManager java.lang.String int)  will be called if the
 USSD request has failed."
android,telephony,TelephonyScanManager.NetworkScanCallback,3,"The caller of
  TelephonyManager#requestNetworkScan(NetworkScanRequest Executor NetworkScanCallback) 
 should implement and provide this callback so that the scan results or errors can be
 returned."
android,telephony,UiccCardInfo,11,The UiccCardInfo represents information about a currently inserted UICC or embedded eUICC.
android,telephony,VisualVoicemailService.VisualVoicemailTask,3,"Represents a visual voicemail event which needs to be handled. While the task is being
 processed telephony will hold a wakelock for the VisualVoicemailService. The service can
 unblock the main thread and pass the task to a worker thread. Once the task is finished
  VisualVoicemailTask#finish()  should be called to signal telephony to release the
 resources. Telephony will call  VisualVoicemailService#onStopped(VisualVoicemailTask) 
 when the task is going to be terminated before completion."
android,telephony,VisualVoicemailSms,6,Represents the content of a visual voicemail SMS. If a incoming SMS matches the  VisualVoicemailSmsFilterSettings  set by the default dialer  VisualVoicemailService#onSmsReceived(VisualVoicemailTask VisualVoicemailSms)  will be called.
android,telephony,VisualVoicemailSmsFilterSettings.Builder,4,Builder class for  VisualVoicemailSmsFilterSettings  objects.
android,telephony,AccessNetworkConstants,0,Contains access network related constants.
android,telephony,CellIdentityTdscdma,12,CellIdentity is to represent a unique TD-SCDMA cell
android,telephony,CellInfoGsm,7,A  CellInfo  representing a GSM cell that provides identity and measurement info.
android,telephony,CellInfoTdscdma,7,A  CellInfo  representing a TD-SCDMA cell that provides identity and measurement info.
android,telephony,CellSignalStrength,5,Abstract base class for cell phone signal strength related information.
android,telephony,CellSignalStrengthLte,14,LTE signal strength related information.
android,telephony,MbmsDownloadSession,15,This class provides functionality for file download over MBMS.
android,telephony,RadioAccessSpecifier,7,"Describes a particular radio access network to be scanned.

 The scan can be performed on either bands or channels for a specific radio access network type."
android,telephony,AccessNetworkConstants.UtranBand,0,"Frenquency bands for UTRAN.
 http://www.etsi.org/deliver/etsi_ts/125100_125199/125104/13.03.00_60/ts_125104v130p.pdf"
android,telephony,AvailableNetworkInfo,9,"Defines available network information which includes corresponding subscription id
 network plmns and corresponding priority to be used for network selection by Opportunistic
 Network Service when passed through  TelephonyManager#updateAvailableNetworks"
android,telephony,CellIdentity,5,"CellIdentity represents the identity of a unique cell. This is the base class for
 CellIdentityXxx which represents cell identity for specific network access technology."
android,telephony,CellIdentityNr,10,Information to represent a unique NR(New Radio 5G) cell.
android,telephony,NeighboringCellInfo,10,"Represents the neighboring cell information including
 Received Signal Strength and Cell ID location."
android,telephony,PhoneNumberFormattingTextWatcher,3,"Watches a  TextView  and if a phone number is entered
 will format it.
  
 Stop formatting when the user
  Inputs non-dialable characters Removes the separator in the middle of string. 
 The formatting will be restarted once the text is cleared."
android,telephony,SubscriptionPlan.Builder,7,Builder for a  SubscriptionPlan .
android,telephony,TelephonyManager,101,"Provides access to information about the telephony services on
 the device. Applications can use the methods in this class to
 determine telephony services and states as well as to access some
 types of subscriber information. Applications can also register
 a listener to receive notification of telephony state changes.
  
 The returned TelephonyManager will use the default subscription for all calls.
 To call an API for a specific subscription use  createForSubscriptionId(int) . e.g.
  
   telephonyManager = defaultSubTelephonyManager.createForSubscriptionId(subId);
  
 Note that access to some telephony information is
 permission-protected. Your application cannot access the protected
 information unless it has the appropriate permissions declared in
 its manifest file. Where permissions apply they are noted in the
 the methods through which you access the protected information."
android,telephony,TelephonyManager.CellInfoCallback,2,Callback for providing asynchronous  CellInfo  on request
android,telephony,PhoneNumberUtils,44,Various utilities for dealing with phone number strings.
android,telephony,SmsMessage,33,A Short Message Service message.
android,telephony,SubscriptionManager,33,"SubscriptionManager is the application interface to SubscriptionController
 and provides information about the current Telephony Subscriptions."
android,telephony,SubscriptionPlan,12,"Description of a billing relationship plan between a carrier and a specific
 subscriber. This information is used to present more useful UI to users such
 as explaining how much mobile data they have remaining and what will happen
 when they run out."
android,telephony,TelephonyScanManager,0,Manages the radio access network scan requests and callbacks.
android,telephony,VisualVoicemailService,5,"This service is implemented by dialer apps that wishes to handle OMTP or similar visual
 voicemails. Telephony binds to this service when the cell service is first connected a visual
 voicemail SMS has been received or when a SIM has been removed. Telephony will only bind to the
 default dialer for such events (See  TelecomManager#getDefaultDialerPackage() ). The
  CarrierMessagingService  precedes the VisualVoicemailService in
 the SMS filtering chain and may intercept the visual voicemail SMS before it reaches this
 service.
  
 To extend this class The service must be declared in the manifest file with
 the  Manifest.permission.BIND_VISUAL_VOICEMAIL_SERVICE  permission and include an
 intent filter with the  SERVICE_INTERFACE  action.
  
 Below is an example manifest registration for a  VisualVoicemailService .
  <service android:name=""your.package.YourVisualVoicemailServiceImplementation""
          android:permission=""android.permission.BIND_VISUAL_VOICEMAIL_SERVICE"">
      <intent-filter>
          <action android:name=""android.telephony.VisualVoicemailService""/>
      </intent-filter>
 </service>"
android,telephony,VisualVoicemailSmsFilterSettings,3,"Class to represent various settings for the visual voicemail SMS filter. When the filter is
 enabled incoming SMS matching the generalized OMTP format:

  [clientPrefix]:[prefix]:([key]=[value];)*

  will be regarded as a visual voicemail SMS and removed before reaching the SMS provider. The
  VisualVoicemailService  in the current default dialer will be bound and
  VisualVoicemailService#onSmsReceived(VisualVoicemailTask VisualVoicemailSms) 
 will called with the information extracted from the SMS.

  Use  VisualVoicemailSmsFilterSettings.Builder  to construct this
 class."
android,text.format,DateFormat,10,"Utility class for producing strings with formatted date/time.

  Most callers should avoid supplying their own format strings to this
 class'  format  methods and rely on the correctly localized ones
 supplied by the system. This class' factory methods return
 appropriately-localized  DateFormat  instances suitable
 for both formatting and parsing dates. For the canonical documentation
 of format strings see  SimpleDateFormat .

  In cases where the system does not provide a suitable pattern
 this class offers the  getBestDateTimePattern(Locale String)  method.

  The  format  methods in this class implement a subset of Unicode
  UTS #35  patterns.
 The subset currently supported by this class includes the following format characters:
  acdEHhLKkLMmsyz . Up to API level 17 only  adEhkMmszy  were supported.
 Note that this class incorrectly implements  k  as if it were  H  for backwards
 compatibility.

  See  SimpleDateFormat  for more documentation
 about patterns or if you need a more complete or correct implementation.
 Note that the non- format  methods in this class are implemented by
  SimpleDateFormat ."
android,text.format,DateUtils,17,"This class contains various date-related utilities for creating text for things like
 elapsed time and date ranges strings for days of the week and months and AM/PM text etc."
android,text.format,Formatter,3,"Utility class to aid in formatting common values that are not covered
 by the  Formatter  class in  java.util"
android,text.format,Time,26,"An alternative to the  Calendar  and
  GregorianCalendar  classes. An instance of the Time class represents
 a moment in time specified with second precision. It is modelled after
 struct tm. This class is not thread-safe and does not consider leap seconds.

  This class has a number of issues and it is recommended that
  GregorianCalendar  is used instead.

  Known issues:
  For historical reasons when performing time calculations all arithmetic currently takes
     place using 32-bit integers. This limits the reliable time range representable from 1902
     until 2037.See the wikipedia article on the
      Year 2038 problem  for details.
     Do not rely on this behavior; it may change in the future.
      Calling  switchTimezone(java.lang.String)  on a date that cannot exist such as a wall time
     that was skipped due to a DST transition will result in a date in 1969 (i.e. -1 or 1 second
     before 1st Jan 1970 UTC). Much of the formatting / parsing assumes ASCII text and is therefore not suitable for
     use with non-ASCII scripts. No support for pseudo-zones like ""GMT-07:00""."
android,text,AndroidCharacter,5,"AndroidCharacter exposes some character properties that used to be not
 easily accessed from java.lang.Character but are now available in ICU."
android,text,Annotation,5,"Annotations are simple key-value pairs that are preserved across
 TextView save/restore cycles and can be used to keep application-specific
 data that needs to be maintained for regions of text."
android,text,AutoText,2,This class accesses a dictionary of corrections to frequent misspellings.
android,text,BidiFormatter.Builder,3,A class for building a BidiFormatter with non-default options.
android,text,BoringLayout.Metrics,1,
android,text,ClipboardManager,3,
android,text,DynamicLayout,12,"DynamicLayout is a text layout that updates itself as the text is edited.
  This is used by widgets to control text layout. You should not need
 to use this class directly unless you are implementing your own widget
 or custom display object or need to call
  Canvas.drawText()  directly."
android,text,DynamicLayout.Builder,13,"Builder for dynamic layouts. The builder is the preferred pattern for constructing
 DynamicLayout objects and should be preferred over the constructors particularly to access
 newer features. To build a dynamic layout first call  obtain(CharSequence TextPaint int)  with the required
 arguments (base paint and width) then call setters for optional parameters and finally
  build()  to build the DynamicLayout object. Parameters not explicitly set will get
 default values."
android,text,Editable.Factory,2,"Factory used by TextView to create new  Editable . You can subclass
 it to provide something other than  SpannableStringBuilder ."
android,text,InputFilter.AllCaps,1,"This filter will capitalize all the lowercase and titlecase letters that are added
 through edits. (Note that if there are no lowercase or titlecase letters in the input the
 text would not be transformed even if the result of capitalization of the string is
 different from the string.)"
android,text,InputFilter.LengthFilter,2,"This filter will constrain edits not to make the length of the text
 greater than the specified length."
android,text,Layout.Directions,0,"Stores information about bidirectional (left-to-right or right-to-left)
 text within the layout of a line."
android,text,LoginFilter,5,Abstract class for filtering login-related text (user names and passwords)
android,text,LoginFilter.PasswordFilterGMail,1,"This filter is compatible with GMail passwords which restricts characters to
 the Latin-1 (ISO8859-1) char set."
android,text,LoginFilter.UsernameFilterGMail,1,"This filter rejects characters in the user name that are not compatible with GMail
 account creation. It prevents the user from entering user names with characters other than
 [a-zA-Z0-9.]."
android,text,PrecomputedText.Params,7,"The information required for building  PrecomputedText .

 Contains information required for precomputing text measurement metadata so it can be done
 in isolation of a  TextView  or  StaticLayout  when final layout
 constraints are not known."
android,text,Spannable.Factory,2,"Factory used by TextView to create new  Spannable . You can subclass
 it to provide something other than  SpannableString ."
android,text,SpannableStringBuilder,30,This is the class for text whose content and markup can both be changed.
android,text,SpannedString,13,"This is the class for text whose content and markup are immutable.
 For mutable markup see  SpannableString ; for mutable text
 see  SpannableStringBuilder ."
android,text,StaticLayout,13,"StaticLayout is a Layout for text that will not be edited after it
 is laid out.  Use  DynamicLayout  for text that may change.
  This is used by widgets to control text layout. You should not need
 to use this class directly unless you are implementing your own widget
 or custom display object or would be tempted to call
  Canvas.drawText()  directly."
android,text,TextPaint,1,"TextPaint is an extension of Paint that leaves room for some extra
 data used during text measuring and drawing."
android,text,TextUtils,40,
android,text,AlteredCharSequence,6,"An AlteredCharSequence is a CharSequence that is largely mirrored from
 another CharSequence except that a specified range of characters are
 mirrored from a different char array instead."
android,text,BidiFormatter,15,"Utility class for formatting text for display in a potentially opposite-directionality context
 without garbling. The directionality of the context is set at formatter creation and the
 directionality of the text can be either estimated or passed in when known.

  To support versions lower than  Build.VERSION_CODES.JELLY_BEAN_MR2 
 you can use the support library's  BidiFormatter  class.

  These APIs provides the following functionality:
  
 1. Bidi Wrapping
 When text in one language is mixed into a document in another opposite-directionality language
 e.g. when an English business name is embedded in some Hebrew text both the inserted string
 and the text surrounding it may be displayed incorrectly unless the inserted string is explicitly
 separated from the surrounding text in a ""wrapper"" that:
  
 - Declares its directionality so that the string is displayed correctly. This can be done in
   Unicode bidi formatting codes by  unicodeWrap(CharSequence)  and similar methods.
  
 - Isolates the string's directionality so it does not unduly affect the surrounding content.
   Currently this can only be done using invisible Unicode characters of the same direction as
   the context (LRM or RLM) in addition to the directionality declaration above thus ""resetting""
   the directionality to that of the context. The ""reset"" may need to be done at both ends of the
   string. Without ""reset"" after the string the string will ""stick"" to a number or logically
   separate opposite-direction text that happens to follow it in-line (even if separated by
   neutral content like spaces and punctuation). Without ""reset"" before the string the same can
   happen there but only with more opposite-direction text not a number. One approach is to
   ""reset"" the direction only after each string on the theory that if the preceding opposite-
   direction text is itself bidi-wrapped the ""reset"" after it will prevent the sticking. (Doing
   the ""reset"" only before each string definitely does not work because we do not want to require
   bidi-wrapping numbers and a bidi-wrapped opposite-direction string could be followed by a
   number.) Still the safest policy is to do the ""reset"" on both ends of each string since RTL
   message translations often contain untranslated Latin-script brand names and technical terms
   and one of these can be followed by a bidi-wrapped inserted value. On the other hand when one
   has such a message it is best to do the ""reset"" manually in the message translation itself
   since the message's opposite-direction text could be followed by an inserted number which we
   would not bidi-wrap anyway. Thus ""reset"" only after the string is the current default. In an
   alternative to ""reset"" recent additions to the HTML CSS and Unicode standards allow the
   isolation to be part of the directionality declaration. This form of isolation is better than
   ""reset"" because it takes less space does not require knowing the context directionality has a
   gentler effect than ""reset"" and protects both ends of the string. However we do not yet allow
   using it because required platforms do not yet support it.
  
 Providing these wrapping services is the basic purpose of the bidi formatter.
  
 2. Directionality estimation
 How does one know whether a string about to be inserted into surrounding text has the same
 directionality? Well in many cases one knows that this must be the case when writing the code
 doing the insertion e.g. when a localized message is inserted into a localized page. In such
 cases there is no need to involve the bidi formatter at all. In some other cases it need not be
 the same as the context but is either constant (e.g. urls are always LTR) or otherwise known.
 In the remaining cases e.g. when the string is user-entered or comes from a database the
 language of the string (and thus its directionality) is not known a priori and must be
 estimated at run-time. The bidi formatter can do this automatically using the default
 first-strong estimation algorithm. It can also be configured to use a custom directionality
 estimation object."
android,text,BoringLayout,23,"A BoringLayout is a very simple Layout implementation for text that
 fits on a single line and is all left-to-right characters.
 You will probably never want to make one of these yourself;
 if you do be sure to call  isBoring(CharSequence TextPaint)  first to make sure
 the text meets the criteria.
  This class is used by widgets to control text layout. You should not need
 to use this class directly unless you are implementing your own widget
 or custom display object in which case
 you are encouraged to use a Layout instead of calling
  Canvas.drawText()  directly."
android,text,Html,7,"This class processes HTML strings into displayable styled text.
 Not all HTML tags are supported."
android,text,Layout,48,"A base class that manages text layout in visual elements on
 the screen.
  For text that will be edited use a  DynamicLayout 
 which will be updated as the text changes.
 For text that will not change use a  StaticLayout ."
android,text,LoginFilter.UsernameFilterGeneric,1,"This filter rejects characters in the user name that are not compatible with Google login.
 It is slightly less restrictive than the above filter in that it allows [a-zA-Z0-9._-+]."
android,text,NoCopySpan.Concrete,0,"Convenience equivalent for when you would just want a new Object() for
 a span but want it to be no-copy.  Use this instead."
android,text,PrecomputedText,18,"A text which has the character metrics data.

 A text object that contains the character metrics data and can be used to improve the performance
 of text layout operations. When a PrecomputedText is created with a given  CharSequence 
 it will measure the text metrics during the creation. This PrecomputedText instance can be set on
  TextView  or  StaticLayout . Since the text layout information will
 be included in this instance  TextView  or  StaticLayout  will not
 have to recalculate this information.

 Note that the  PrecomputedText  created from different parameters of the target  TextView  will be rejected internally and compute the text layout again with the
 current  TextView  parameters.

  
 An example usage is:
  
  static void asyncSetText(TextView textView final String longString Executor bgExecutor) {
      // construct precompute related parameters using the TextView that we will set the text on.
      final PrecomputedText.Params params = textView.getTextMetricsParams();
      final Reference textViewRef = new WeakReference<>(textView);
      bgExecutor.submit(() -> {
          TextView textView = textViewRef.get();
          if (textView == null) return;
          final PrecomputedText precomputedText = PrecomputedText.create(longString params);
          textView.post(() -> {
              TextView textView = textViewRef.get();
              if (textView == null) return;
              textView.setText(precomputedText);
          });
      });
  }
  PrecomputedText TextView NoCopySpan"
android,text,PrecomputedText.Params.Builder,4,A builder for creating  Params .
android,text,Selection,19,"Utility class for manipulating cursors and selections in CharSequences.
 A cursor is a selection where the start and end are at the same offset."
android,text,SpannableString,15,"This is the class for text whose content is immutable but to which
 markup objects can be attached and detached.
 For mutable text see  SpannableStringBuilder ."
android,text,StaticLayout.Builder,15,"Builder for static layouts. The builder is the preferred pattern for constructing
 StaticLayout objects and should be preferred over the constructors particularly to access
 newer features. To build a static layout first call  obtain(CharSequence int int TextPaint int)  with the required
 arguments (text paint and width) then call setters for optional parameters and finally
  build()  to build the StaticLayout object. Parameters not explicitly set will get
 default values."
android,text,TextDirectionHeuristics,0,"Some objects that implement  TextDirectionHeuristic . Use these with
 the  BidiFormatter#unicodeWrap  methods in  BidiFormatter .
 Also notice that these direction heuristics correspond to the same types of constants
 provided in the  View  class for  setTextDirection()  such as  View.TEXT_DIRECTION_RTL .
  To support versions lower than  Build.VERSION_CODES.JELLY_BEAN_MR2 
 you can use the support library's  TextDirectionHeuristicsCompat 
 class."
android,text,TextUtils.SimpleStringSplitter,5,"A simple string splitter.

  If the final character in the string to split is the delimiter then no empty string will
 be returned for the empty string after that delimeter. That is splitting  ""ab""  on
 comma will return  ""a"" ""b""  not  ""a"" ""b"" """" ."
android,text.util,Linkify,10,"Linkify take a piece of text and a regular expression and turns all of the
  regex matches in the text into clickable links.  This is particularly
  useful for matching things like email addresses web URLs etc. and making
  them actionable.

  Alone with the pattern that is to be matched a URL scheme prefix is also
  required.  Any pattern match that does not begin with the supplied scheme
  will have the scheme prepended to the matched text when the clickable URL
  is created.  For instance if you are matching web URLs you would supply
  the scheme  http:// . If the pattern matches example.com which
  does not have a URL scheme prefix the supplied scheme will be prepended to
  create  http://example.com  when the clickable URL link is
  created.

   Note:  When using  MAP_ADDRESSES  or  ALL 
  to match street addresses on API level  Build.VERSION_CODES.O_MR1 
  and earlier methods in this class may throw
   AndroidRuntimeException  or other exceptions if the
  device's WebView implementation is currently being updated because
   WebView.findAddress(String)  is required to match street
  addresses."
android,text.util,Rfc822Token,12,"This class stores an RFC 822-like name address and comment
 and provides methods to convert them to quoted strings."
android,text.util,Rfc822Tokenizer,5,"This class works as a Tokenizer for MultiAutoCompleteTextView for
 address list fields and also provides a method for converting
 a string of addresses (such as might be typed into such a field)
 into a series of Rfc822Tokens."
android,text.method,ArrowKeyMovementMethod,18,"A movement method that provides cursor movement and selection.
 Supports displaying the context menu on DPad Center."
android,text.method,BaseKeyListener,4,"Abstract base class for key listeners.

 Provides a basic foundation for entering and editing text.
 Subclasses should override  onKeyDown(View Editable int KeyEvent)  and  MetaKeyKeyListener.onKeyUp(View Editable int KeyEvent)  to insert
 characters as keys are pressed.
  KeyListener"
android,text.method,BaseMovementMethod,23,Base classes for movement methods.
android,text.method,DateKeyListener,4,"For entering dates in a text field.
  KeyListener"
android,text.method,DateTimeKeyListener,4,"For entering dates and times in the same text field.
  KeyListener"
android,text.method,DialerKeyListener,4,"For dialing-only text entry
  KeyListener"
android,text.method,DigitsKeyListener,8,"For digits-only text entry
  KeyListener"
android,text.method,HideReturnsTransformationMethod,3,"This transformation method causes any carriage return characters (\r)
 to be hidden by displaying them as zero-width non-breaking space
 characters (ï»¿)."
android,text.method,ScrollingMovementMethod,15,A movement method that interprets movement keys by scrolling the text buffer.
android,text.method,TextKeyListener,12,"This is the key listener for typing normal text.  It delegates to
 other key listeners appropriate to the current keyboard and language.
  KeyListener"
android,text.method,CharacterPickerDialog,3,Dialog for choosing accented characters related to a base character.
android,text.method,LinkMovementMethod,10,"A movement method that traverses links in the text buffer and scrolls if necessary.
 Supports clicking on links with DPad Center or Enter."
android,text.method,MetaKeyKeyListener,20,"This base class encapsulates the behavior for tracking the state of
 meta keys such as SHIFT ALT and SYM as well as the pseudo-meta state of selecting text.
  
 Key listeners that care about meta state should inherit from this class;
 you should not instantiate this class directly in a client.
  
 This class provides two mechanisms for tracking meta state that can be used
 together or independently.
  Methods such as  handleKeyDown(long int android.view.KeyEvent)  and
  getMetaState(long)  operate on a meta key state bit mask. Methods such as  onKeyDown(android.view.View android.text.Editable int android.view.KeyEvent)  and
  getMetaState(java.lang.CharSequence int)  operate on meta key state flags stored
 as spans in an  Editable  text buffer.  The spans only describe the current
 meta key state of the text editor; they do not carry any positional information. 
 The behavior of this class varies according to the keyboard capabilities
 described by the  KeyCharacterMap  of the keyboard device such as
 the  KeyCharacterMap#getModifierBehavior() .
  MetaKeyKeyListener  implements chorded and toggled key modifiers.
 When key modifiers are toggled into a latched or locked state the state
 of the modifier is stored in the  Editable  text buffer or in a
 meta state integer managed by the client.  These latched or locked modifiers
 should be considered to be held  in addition to  those that the
 keyboard already reported as being pressed in  KeyEvent#getMetaState() .
 In other words the  MetaKeyKeyListener  augments the meta state
 provided by the keyboard; it does not replace it.  This distinction is important
 to ensure that meta keys not handled by  MetaKeyKeyListener  such as
  KeyEvent#KEYCODE_CAPS_LOCK  or  KeyEvent#KEYCODE_NUM_LOCK  are
 taken into consideration.
  
 To ensure correct meta key behavior the following pattern should be used
 when mapping key codes to characters:
  
 private char getUnicodeChar(TextKeyListener listener KeyEvent event Editable textBuffer) {
     // Use the combined meta states from the event and the key listener.
     int metaState = event.getMetaState() | listener.getMetaState(textBuffer);
     return event.getUnicodeChar(metaState);
 }"
android,text.method,MultiTapKeyListener,6,"This is the standard key listener for alphabetic input on 12-key
 keyboards.  You should generally not need to instantiate this yourself;
 TextKeyListener will do it for you.
  KeyListener"
android,text.method,NumberKeyListener,5,"For numeric text entry
  KeyListener"
android,text.method,PasswordTransformationMethod,6,
android,text.method,QwertyKeyListener,5,"This is the standard key listener for alphabetic input on qwerty
 keyboards.  You should generally not need to instantiate this yourself;
 TextKeyListener will do it for you.
  KeyListener"
android,text.method,TimeKeyListener,4,"For entering times in a text field.
  KeyListener"
android,text.method,ReplacementTransformationMethod,4,"This transformation method causes the characters in the  getOriginal() 
 array to be replaced by the corresponding characters in the
  getReplacement()  array."
android,text.method,SingleLineTransformationMethod,3,"This transformation method causes any newline characters (\n) to be
 displayed as spaces instead of causing line breaks and causes
 carriage return characters (\r) to have no appearance."
android,text.method,Touch,4,
android,text.style,AbsoluteSizeSpan,7,"A span that changes the size of the text it's attached to.
  
 For example the size of the text can be changed to 55dp like this:
  SpannableString string = new SpannableString(""Text with absolute size span"");
string.setSpan(new AbsoluteSizeSpan(55 true) 10 23 Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); Text with text size updated."
android,text.style,AlignmentSpan.Standard,4,"Default implementation of the  AlignmentSpan .
  
 For example a text written in a left to right language like English which is by default
 aligned to the left can be aligned opposite to the layout direction like this:
  SpannableString string = new SpannableString(""Text with opposite alignment"");
string.setSpan(new AlignmentSpan.Standard(Layout.Alignment.ALIGN_OPPOSITE) 0
string.length() Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); Align left to right text opposite to the layout direction. 
 A text written in a right to left language like Hebrew which is by default aligned to the
 right can be aligned opposite to the layout direction like this:
  SpannableString string = new SpannableString(""×˜×§×¡×˜ ×¢× ×™×™×©×•×¨ ×”×¤×•×š"");
string.setSpan(new AlignmentSpan.Standard(Layout.Alignment.ALIGN_OPPOSITE) 0
string.length() Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); Align right to left text opposite to the layout direction."
android,text.style,BackgroundColorSpan,5,"Changes the background color of the text to which the span is attached.
  
 For example to set a green background color for a text you would create a  SpannableString  based on the text and set the span.
  SpannableString string = new SpannableString(""Text with a background color span"");
string.setSpan(new BackgroundColorSpan(color) 12 28 Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); Set a background color for the text."
android,text.style,BulletSpan,8,"A span which styles paragraphs as bullet points (respecting layout direction).
  
 BulletSpans must be attached from the first character to the last character of a single
 paragraph otherwise the bullet point will not be displayed but the first paragraph encountered
 will have a leading margin.
  
 BulletSpans allow configuring the following elements:
  gap width  - the distance in pixels between the bullet point and the paragraph.
 Default value is 2px. color  - the bullet point color. By default the bullet point color is 0 - no color
 so it uses the TextView's text color. bullet radius  - the radius in pixels of the bullet point. Default value is
 4px. SpannableString string = new SpannableString(""Text with\nBullet point"");
string.setSpan(new BulletSpan() 10 22 Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); BulletSpan constructed with default values. 
 To construct a BulletSpan with a gap width of 40px green bullet point and bullet radius of
 20px:
  SpannableString string = new SpannableString(""Text with\nBullet point"");
string.setSpan(new BulletSpan(40 color 20) 10 22 Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); Customized BulletSpan."
android,text.style,ClickableSpan,2,"If an object of this type is attached to the text of a TextView
 with a movement method of LinkMovementMethod the affected spans of
 text can be selected. If selected and clicked the  onClick(View)  method will
 be called.
  
 The text with a  ClickableSpan  attached will be underlined and the link color will be
 used as a text color. The default link color is the theme's accent color or
  android:textColorLink  if this attribute is defined in the theme.
 For example considering that we have a  CustomClickableSpan  that extends
  ClickableSpan  it can be used like this:
  SpannableString string = new SpannableString(""Text with clickable text"");
string.setSpan(new CustomClickableSpan() 10 19 Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); Text with  ClickableSpan ."
android,text.style,DrawableMarginSpan,3,"A span which adds a drawable and a padding to the paragraph it's attached to.
  
 If the height of the drawable is bigger than the height of the line it's attached to then the
 line height is increased to fit the drawable.  DrawableMarginSpan  allows setting a
 padding between the drawable and the text. The default value is 0. The span must be set from the
 beginning of the text otherwise either the span won't be rendered or it will be rendered
 incorrectly.
  
 For example a drawable and a padding of 20px can be added like this:
  SpannableString string = new SpannableString(""Text with a drawable."");
 string.setSpan(new DrawableMarginSpan(drawable 20) 0 string.length()
 Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); Text with a drawable and a padding."
android,text.style,EasyEditSpan,3,"Provides an easy way to edit a portion of text.
  
 The  TextView  uses this span to allow the user to delete a chuck of text in one click.
  TextView  removes the span when the user deletes the whole text or modifies it.
  
 This span can be also used to receive notification when the user deletes or modifies the text;"
android,text.style,ForegroundColorSpan,5,"Changes the color of the text to which the span is attached.
  
 For example to set a green text color you would create a  SpannableString  based on the text and set the span.
  SpannableString string = new SpannableString(""Text with a foreground color span"");
string.setSpan(new ForegroundColorSpan(color) 12 28 Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); Set a text color."
android,text.style,IconMarginSpan,3,"Paragraph affecting span that draws a bitmap at the beginning of a text. The span also allows
 setting a padding between the bitmap and the text. The default value of the padding is 0px. The
 span should be attached from the first character of the text.
  
 For example an  IconMarginSpan  with a bitmap and a padding of 30px can be set
 like this:
  
 SpannableString string = new SpannableString(""Text with icon and padding"");
 string.setSpan(new IconMarginSpan(bitmap 30) 0 string.length()
 Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
  Text with  IconMarginSpan"
android,text.style,ImageSpan,2,"Span that replaces the text it's attached to with a  Drawable  that can be aligned with
 the bottom or with the baseline of the surrounding text. The drawable can be constructed from
 varied sources:
  Bitmap  - see  ImageSpan(android.content.Context android.graphics.Bitmap)  and
  ImageSpan(android.content.Context android.graphics.Bitmap int) Drawable  - see  ImageSpan(android.graphics.drawable.Drawable int) resource id - see  ImageSpan(android.content.Context int int) Uri  - see  ImageSpan(android.content.Context android.net.Uri int) DynamicDrawableSpan#ALIGN_BOTTOM 
 For example an  ImagedSpan  can be used like this:
  
 SpannableString string = new SpannableString(""Bottom: span.\nBaseline: span."");
 // using the default alignment: ALIGN_BOTTOM
 string.setSpan(new ImageSpan(this R.mipmap.ic_launcher) 7 8 Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
 string.setSpan(new ImageSpan(this R.mipmap.ic_launcher DynamicDrawableSpan.ALIGN_BASELINE)
 22 23 Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
  Text with  ImageSpan s aligned bottom and baseline."
android,text.style,LineHeightSpan.Standard,5,"Default implementation of the  LineHeightSpan  which changes the line height of the
 attached paragraph.
  
 For example a paragraph with its line height equal to 100px can be set like this:
  
 SpannableString string = new SpannableString(""This is a multiline paragraph. This is a multiline paragraph."");
 string.setSpan(new LineHeightSpan.Standard(100) 0 string.length() Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
  Text with line height set to 100 pixels. 
 Notice that LineHeightSpan will change the line height of the entire paragraph even though it
 covers only part of the paragraph."
android,text.style,MetricAffectingSpan,2,"The classes that affect character-level text formatting in a way that
 changes the width or height of characters extend this class."
android,text.style,QuoteSpan,8,"A span which styles paragraphs by adding a vertical stripe at the beginning of the text
 (respecting layout direction).
  
 A  QuoteSpan  must be attached from the first character to the last character of a
 single paragraph otherwise the span will not be displayed.
  QuoteSpans  allow configuring the following elements:
  color  - the vertical stripe color. By default the stripe color is 0xff0000ff gap width  - the distance in pixels between the stripe and the paragraph.
 Default value is 2px. stripe width  - the width in pixels of the stripe. Default value is
 2px. QuoteSpan SpannableString string = new SpannableString(""Text with quote span on a long line"");
string.setSpan(new QuoteSpan() 0 string.length() Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); QuoteSpan  constructed with default values. 
 To construct a  QuoteSpan  with a green stripe of 20px in width and a gap width of
 40px:
  SpannableString string = new SpannableString(""Text with quote span on a long line"");
string.setSpan(new QuoteSpan(Color.GREEN 20 40) 0 string.length()
Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); Customized  QuoteSpan ."
android,text.style,ReplacementSpan,4,
android,text.style,ScaleXSpan,6,"Scales horizontally the size of the text to which it's attached by a certain factor.
  
 Values > 1.0 will stretch the text wider. Values < 1.0 will stretch the text narrower.
  
 For example a  ScaleXSpan  that stretches the text size by 100% can be
 constructed like this:
  SpannableString string = new SpannableString(""Text with ScaleX span"");
string.setSpan(new ScaleXSpan(2f) 10 16 Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); Text scaled by 100% with  ScaleXSpan ."
android,text.style,SubscriptSpan,5,"The span that moves the position of the text baseline lower.
  
 The span can be used like this:
  SpannableString string = new SpannableString(""â˜•- C8H10N4O2\n"");
string.setSpan(new SubscriptSpan() 4 5 Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
string.setSpan(new SubscriptSpan() 6 8 Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
string.setSpan(new SubscriptSpan() 9 10 Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
string.setSpan(new SubscriptSpan() 11 12 Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); Text with  SubscriptSpan ."
android,text.style,SuperscriptSpan,5,"The span that moves the position of the text baseline higher.
  
 The span can be used like this:
  SpannableString string = new SpannableString(""1st example"");
string.setSpan(new SuperscriptSpan() 1 3 Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); Text with  SuperscriptSpan . AbsoluteSizeSpan"
android,text.style,TabStopSpan.Standard,1,"The default implementation of TabStopSpan that allows setting the offset of the tab stop
 from the leading margin of the first line of text.
  
 Let's consider that we have the following text:  ""\tParagraph text beginning with tab."" 
 and we want to move the tab stop with 100px. This can be achieved like this:
  
 SpannableString string = new SpannableString(""\tParagraph text beginning with tab."");
 string.setSpan(new TabStopSpan.Standard(100) 0 string.length()
 Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); Text with a tab stop and a  TabStopSpan"
android,text.style,TextAppearanceSpan,20,"Sets the text appearance using the given
  TextAppearance  attributes.
 By default  TextAppearanceSpan  only changes the specified attributes in XML.
  textColorHighlight 
  textColorHint 
  textAllCaps  and
  fallbackLineSpacing 
 are not supported by  TextAppearanceSpan ."
android,text.style,TtsSpan,5,"A span that supplies additional meta-data for the associated text intended
 for text-to-speech engines. If the text is being processed by a
 text-to-speech engine the engine may use the data in this span in addition
 to or instead of its associated text.

 Each instance of a TtsSpan has a type for example  TYPE_DATE 
 or  TYPE_MEASURE . And a list of arguments provided as
 key-value pairs in a bundle.

 The inner classes are there for convenience and provide builders for each
 TtsSpan type."
android,text.style,TtsSpan.CardinalBuilder,2,A builder for TtsSpans of type  TtsSpan.TYPE_CARDINAL .
android,text.style,TtsSpan.DateBuilder,4,A builder for TtsSpans of type  TtsSpan.TYPE_DATE .
android,text.style,TtsSpan.DecimalBuilder,4,A builder for TtsSpans of type  TtsSpan.TYPE_DECIMAL .
android,text.style,TtsSpan.DigitsBuilder,1,A builder for TtsSpans of type  TtsSpan.TYPE_DIGITS .
android,text.style,TtsSpan.MoneyBuilder,5,A builder for TtsSpans of type  TtsSpan.TYPE_MONEY .
android,text.style,TtsSpan.OrdinalBuilder,2,A builder for TtsSpans of type  TtsSpan.TYPE_ORDINAL .
android,text.style,UnderlineSpan,4,"A span that underlines the text it's attached to.
  
 The span can be used like this:
  SpannableString string = new SpannableString(""Text with underline span"");
string.setSpan(new UnderlineSpan() 10 19 Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); Underlined text."
android,text.style,CharacterStyle,3,"The classes that affect character-level text formatting extend this
 class.  Most extend its subclass  MetricAffectingSpan  but simple
 ones may just implement  UpdateAppearance ."
android,text.style,DynamicDrawableSpan,4,"Span that replaces the text it's attached to with a  Drawable  that can be aligned with
 the bottom or with the baseline of the surrounding text.
  
 For an implementation that constructs the drawable from various sources ( Bitmap 
  Drawable  resource id or  Uri ) use  ImageSpan .
  
 A simple implementation of  DynamicDrawableSpan  that uses drawables from resources
 looks like this:
  
 class MyDynamicDrawableSpan extends DynamicDrawableSpan {

 private final Context mContext;
 private final int mResourceId;

 public MyDynamicDrawableSpan(Context context @DrawableRes int resourceId) {
     mContext = context;
     mResourceId = resourceId;
 }

 @Override
 public Drawable getDrawable() {
      Drawable drawable = mContext.getDrawable(mResourceId);
      drawable.setBounds(0 0 drawable.getIntrinsicWidth() drawable.getIntrinsicHeight());
      return drawable;
 }
 } 
 SpannableString string = new SpannableString(""Text with a drawable span"");
 string.setSpan(new MyDynamicDrawableSpan(context R.mipmap.ic_launcher) 12 20 Spanned
 .SPAN_EXCLUSIVE_EXCLUSIVE); Replacing text with a drawable."
android,text.style,LineBackgroundSpan.Standard,5,"Default implementation of the  LineBackgroundSpan  which changes the background
 color of the lines to which the span is attached.
  
 For example an  LineBackgroundSpan  can be used like this:
  
 String text = ""This is a multiline text. LineBackgroundSpan is applied here. This is a multiline text."";
 SpannableString string = new SpannableString(text);
 string.setSpan(new LineBackgroundSpan.Standard(Color.YELLOW) 26 61 Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
  Text with  LineBackgroundSpan"
android,text.style,MaskFilterSpan,2,"Span that allows setting a  MaskFilter  to the text it's attached to.
  
 For example to blur a text a  BlurMaskFilter  can be used:
  
 MaskFilter blurMask = new BlurMaskFilter(5f BlurMaskFilter.Blur.NORMAL);
 SpannableString string = new SpannableString(""Text with blur mask"");
 string.setSpan(new MaskFilterSpan(blurMask) 10 15 Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
  Text blurred with the  MaskFilterSpan ."
android,text.style,StrikethroughSpan,4,"A span that strikes through the text it's attached to.
  
 The span can be used like this:
  SpannableString string = new SpannableString(""Text with strikethrough span"");
string.setSpan(new StrikethroughSpan() 10 23 Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); Strikethrough text."
android,text.style,TtsSpan.Builder,4,"A simple builder for TtsSpans.
 This builder can be used directly but the more specific subclasses of
 this builder like  TtsSpan.TextBuilder  and
  TtsSpan.CardinalBuilder  are likely more useful.

 This class uses generics so methods from this class can return instances
 of its child classes resulting in a fluent API (CRTP pattern)."
android,text.style,TtsSpan.ElectronicBuilder,9,A builder for TtsSpans of type  TtsSpan.TYPE_ELECTRONIC .
android,text.style,TtsSpan.MeasureBuilder,10,A builder for TtsSpans of type  TtsSpan.TYPE_MEASURE .
android,text.style,TtsSpan.TelephoneBuilder,3,A builder for TtsSpans of type  TtsSpan.TYPE_TELEPHONE .
android,text.style,TtsSpan.VerbatimBuilder,1,A builder for TtsSpans of type  TtsSpan.TYPE_VERBATIM .
android,text.style,URLSpan,5,"Implementation of the  ClickableSpan  that allows setting a url string. When
 selecting and clicking on the text to which the span is attached the  URLSpan 
 will try to open the url by launching an an Activity with an  Intent#ACTION_VIEW  intent.
  
 For example a  URLSpan  can be used like this:
  
 SpannableString string = new SpannableString(""Text with a url span"");
 string.setSpan(new URLSpan(""http://www.developer.android.com"") 12 15 Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
  Text with  URLSpan ."
android,text.style,LeadingMarginSpan.Standard,5,"The standard implementation of LeadingMarginSpan which adjusts the
 margin but does not do any rendering."
android,text.style,LocaleSpan,7,Changes the  Locale  of the text to which the span is attached.
android,text.style,RelativeSizeSpan,6,"Uniformly scales the size of the text to which it's attached by a certain proportion.
  
 For example a  RelativeSizeSpan  that increases the text size by 50% can be
 constructed like this:
  SpannableString string = new SpannableString(""Text with relative size span"");
string.setSpan(new RelativeSizeSpan(1.5f) 10 24 Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); Text increased by 50% with  RelativeSizeSpan ."
android,text.style,StyleSpan,6,"Span that allows setting the style of the text it's attached to.
 Possible styles are:  Typeface#NORMAL   Typeface#BOLD   Typeface#ITALIC  and
  Typeface#BOLD_ITALIC .
  
 Note that styles are cumulative -- if both bold and italic are set in
 separate spans or if the base style is bold and a span calls for italic
 you get bold italic.  You can't turn off a style from the base style.
  
 For example the  StyleSpan  can be used like this:
  
 SpannableString string = new SpannableString(""Bold and italic text"");
 string.setSpan(new StyleSpan(Typeface.BOLD) 0 4 Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
 string.setSpan(new StyleSpan(Typeface.ITALIC) 9 15 Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
  Text styled bold and italic with the  StyleSpan ."
android,text.style,SuggestionSpan,12,"Holds suggestion candidates for the text enclosed in this span.

 When such a span is edited in an EditText double tapping on the text enclosed in this span will
 display a popup dialog listing suggestion replacement for that text. The user can then replace
 the original text by one of the suggestions.

 These spans should typically be created by the input method to provide correction and alternates
 for the text."
android,text.style,TtsSpan.FractionBuilder,6,A builder for TtsSpans of type  TtsSpan.TYPE_FRACTION .
android,text.style,TtsSpan.SemioticClassBuilder,4,"A builder for TtsSpans has setters for morphosyntactic features.
 This builder can be used directly but the more specific subclasses of
 this builder like  TtsSpan.TextBuilder  and
  TtsSpan.CardinalBuilder  are likely more useful."
android,text.style,TtsSpan.TextBuilder,1,A builder for TtsSpans of type  TtsSpan.TYPE_TEXT .
android,text.style,TtsSpan.TimeBuilder,2,A builder for TtsSpans of type  TtsSpan.TYPE_TIME .
android,text.style,TypefaceSpan,7,"Span that updates the typeface of the text it's attached to. The  TypefaceSpan  can
 be constructed either based on a font family or based on a  Typeface . When
  TypefaceSpan(java.lang.String)  is used the previous style of the  TextView  is kept.
 When  TypefaceSpan(android.graphics.Typeface)  is used the  Typeface  style replaces the
  TextView 's style.
  
 For example let's consider a  TextView  with
  android:textStyle=""italic""  and a typeface created based on a font from resources
 with a bold style. When applying a  TypefaceSpan  based the typeface the text will
 only keep the bold style overriding the  TextView 's textStyle. When applying a
  TypefaceSpan  based on a font family: ""monospace"" the resulted text will keep the
 italic style.
  
 Typeface myTypeface = Typeface.create(ResourcesCompat.getFont(context R.font.acme)
 Typeface.BOLD);
 SpannableString string = new SpannableString(""Text with typeface span."");
 string.setSpan(new TypefaceSpan(myTypeface) 10 18 Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
 string.setSpan(new TypefaceSpan(""monospace"") 19 22 Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
  Text with  TypefaceSpan s constructed based on a font from resource and
 from a font family."
android,transition,AutoTransition,0,"Utility class for creating a default transition that automatically fades
 moves and resizes views during a scene change.

  An AutoTransition can be described in a resource file by using the
 tag  autoTransition  along with the other standard
 attributes of  R.styleable.Transition ."
android,transition,ChangeScroll,4,"This transition captures the scroll properties of targets before and after
 the scene change and animates any changes."
android,transition,ChangeTransform,8,"This Transition captures scale and rotation for Views before and after the
 scene change and animates those changes during the transition.

 A change in parent is handled as well by capturing the transforms from
 the parent before and after the scene change and animating those during the
 transition."
android,transition,Explode,4,"This transition tracks changes to the visibility of target views in the
 start and end scenes and moves views in or out from the edges of the
 scene. Visibility is determined by both the
  View#setVisibility(int)  state of the view as well as whether it
 is parented in the current view hierarchy. Disappearing Views are
 limited as described in  Visibility#onDisappear(android.view.ViewGroup
 TransitionValues int TransitionValues int) .
  Views move away from the focal View or the center of the Scene if
 no epicenter was provided."
android,transition,PathMotion,1,"This base class can be extended to provide motion along a Path to Transitions.

  
 Transitions such as  ChangeBounds  move Views typically
 in a straight path between the start and end positions. Applications that desire to
 have these motions move in a curve can change how Views interpolate in two dimensions
 by extending PathMotion and implementing  getPath(float float float float) .
  This may be used in XML as an element inside a transition. <changeBounds>
     <pathMotion class=""my.app.transition.MyPathMotion""/>
 </changeBounds>"
android,transition,Slide,6,"This transition tracks changes to the visibility of target views in the
 start and end scenes and moves views in or out from one of the edges of the
 scene. Visibility is determined by both the
  View#setVisibility(int)  state of the view as well as whether it
 is parented in the current view hierarchy. Disappearing Views are
 limited as described in  Visibility#onDisappear(android.view.ViewGroup
 TransitionValues int TransitionValues int) ."
android,transition,TransitionListenerAdapter,5,"This adapter class provides empty implementations of the methods from  Transition.TransitionListener .
 Any custom listener that cares only about a subset of the methods of this listener can
 simply subclass this adapter class instead of implementing the interface directly."
android,transition,ArcMotion,7,"A PathMotion that generates a curved path along an arc on an imaginary circle containing
 the two points. If the horizontal distance between the points is less than the vertical
 distance then the circle's center point will be horizontally aligned with the end point. If the
 vertical distance is less than the horizontal distance then the circle's center point
 will be vertically aligned with the end point.
  
 When the two points are near horizontal or vertical the curve of the motion will be
 small as the center of the circle will be far from both points. To force curvature of
 the path  setMinimumHorizontalAngle(float)  and
  setMinimumVerticalAngle(float)  may be used to set the minimum angle of the
 arc between two points.
  This may be used in XML as an element inside a transition. <changeBounds>
   <arcMotion android:minimumHorizontalAngle=""15""
              android:minimumVerticalAngle=""0""
              android:maximumAngle=""90""/>
 </changeBounds>"
android,transition,ChangeBounds,7,"This transition captures the layout bounds of target views before and after
 the scene change and animates those changes during the transition.

  A ChangeBounds transition can be described in a resource file by using the
 tag  changeBounds  using its attributes of
  R.styleable.ChangeBounds  along with the other standard
 attributes of  R.styleable.Transition ."
android,transition,ChangeClipBounds,4,"ChangeClipBounds captures the  View.getClipBounds()  before and after the
 scene change and animates those changes during the transition."
android,transition,ChangeImageTransform,4,"This Transition captures an ImageView's matrix before and after the
 scene change and animates it during the transition.

  In combination with ChangeBounds ChangeImageTransform allows ImageViews
 that change size shape or  ImageView.ScaleType  to animate contents
 smoothly."
android,transition,Fade,3,"This transition tracks changes to the visibility of target views in the
 start and end scenes and fades views in or out when they become visible
 or non-visible. Visibility is determined by both the
  View#setVisibility(int)  state of the view as well as whether it
 is parented in the current view hierarchy.

  The ability of this transition to fade out a particular view and the
 way that that fading operation takes place is based on
 the situation of the view in the view hierarchy. For example if a view was
 simply removed from its parent then the view will be added into a  ViewGroupOverlay  while fading. If a visible view is
 changed to be  View#GONE  or  View#INVISIBLE  then the
 visibility will be changed to  View#VISIBLE  for the duration of
 the animation. However if a view is in a hierarchy which is also altering
 its visibility the situation can be more complicated. In general if a
 view that is no longer in the hierarchy in the end scene still has a
 parent (so its parent hierarchy was removed but it was not removed from
 its parent) then it will be left alone to avoid side-effects from
 improperly removing it from its parent. The only exception to this is if
 the previous  Scene  was
  Scene#getSceneForLayout(android.view.ViewGroup int android.content.Context)  then it is considered safe to un-parent
 the starting scene view in order to fade it out. A Fade transition can be described in a resource file by using the
 tag  fade  along with the standard
 attributes of  R.styleable.Fade  and
  R.styleable.Transition ."
android,transition,Scene,7,"A scene represents the collection of values that various properties in the
 View hierarchy will have when the scene is applied. A Scene can be
 configured to automatically run a Transition when it is applied which will
 animate the various property changes that take place during the
 scene change."
android,transition,SidePropagation,3,"A  TransitionPropagation  that propagates based on the distance to the side
 and orthogonally the distance to epicenter. If the transitioning View is visible in
 the start of the transition then it will transition sooner when closer to the side and
 later when farther. If the view is not visible in the start of the transition then
 it will transition later when closer to the side and sooner when farther from the edge.
 This is the default TransitionPropagation used with  Slide ."
android,transition,Transition,45,"A Transition holds information about animations that will be run on its
 targets during a scene change. Subclasses of this abstract class may
 choreograph several child transitions ( TransitionSet  or they may
 perform custom animations themselves. Any Transition has two main jobs:
 (1) capture property values and (2) play animations based on changes to
 captured property values. A custom transition knows what property values
 on View objects are of interest to it and also knows how to animate
 changes to those values. For example the  Fade  transition tracks
 changes to visibility-related properties and is able to construct and run
 animations that fade items in or out based on changes to those properties.

  Note: Transitions may not work correctly with either  SurfaceView 
 or  TextureView  due to the way that these views are displayed
 on the screen. For SurfaceView the problem is that the view is updated from
 a non-UI thread so changes to the view due to transitions (such as moving
 and resizing the view) may be out of sync with the display inside those bounds.
 TextureView is more compatible with transitions in general but some
 specific transitions (such as  Fade ) may not be compatible
 with TextureView because they rely on  ViewOverlay  functionality
 which does not currently work with TextureView. Transitions can be declared in XML resource files inside the  res/transition 
 directory. Transition resources consist of a tag name for one of the Transition
 subclasses along with attributes to define some of the attributes of that transition.
 For example here is a minimal resource file that declares a  ChangeBounds  transition:

  <changeBounds/> This TransitionSet contains  Explode  for visibility
  ChangeBounds   ChangeTransform 
 and  ChangeClipBounds  and
  ChangeImageTransform : <transitionSet xmlns:android=""http://schemas.android.com/apk/res/android"">
    <explode/>
    <changeBounds/>
    <changeTransform/>
    <changeClipBounds/>
    <changeImageTransform/>
</transitionSet> Custom transition classes may be instantiated with a  transition  tag: <transition class=""my.app.transition.CustomTransition""/> Custom transition classes loaded from XML should have a public constructor taking
 a  Context  and  AttributeSet . Note that attributes for the transition are not required just as they are
 optional when declared in code; Transitions created from XML resources will use
 the same defaults as their code-created equivalents. Here is a slightly more
 elaborate example which declares a  TransitionSet  transition with
  ChangeBounds  and  Fade  child transitions: <transitionSet xmlns:android=""http://schemas.android.com/apk/res/android""
     android:transitionOrdering=""sequential"">
    <changeBounds/>
    <fade android:fadingMode=""fade_out"" >
        <targets>
            <target android:targetId=""@id/grayscaleContainer"" />
        </targets>
    </fade>
</transitionSet> In this example the transitionOrdering attribute is used on the TransitionSet
 object to change from the default  TransitionSet#ORDERING_TOGETHER  behavior
 to be  TransitionSet#ORDERING_SEQUENTIAL  instead. Also the  Fade 
 transition uses a fadingMode of  Fade#OUT  instead of the default
 out-in behavior. Finally note the use of the  targets  sub-tag which
 takes a set of  target  tags each
 of which lists a specific  targetId   targetClass 
  targetName   excludeId   excludeClass  or
  excludeName  which this transition acts upon.
 Use of targets is optional but can be used to either limit the time spent checking
 attributes on unchanging views or limiting the types of animations run on specific views.
 In this case we know that only the  grayscaleContainer  will be
 disappearing so we choose to limit the  Fade  transition to only that view. R.styleable.Transition R.styleable.TransitionSet R.styleable.TransitionTarget R.styleable.Fade R.styleable.Slide R.styleable.ChangeTransform"
android,transition,TransitionPropagation,3,"Extend  TransitionPropagation  to customize start delays for Animators created
 in  Transition.createAnimator(ViewGroup TransitionValues TransitionValues) . A Transition such as  Explode 
 defaults to using  CircularPropagation  and Views closer to the
 epicenter will move out of the scene later and into the scene sooner than Views farther
 from the epicenter giving the appearance of inertia. With no TransitionPropagation all
 Views will react simultaneously to the start of the transition."
android,transition,CircularPropagation,2,"A propagation that varies with the distance to the epicenter of the Transition
 or center of the scene if no epicenter exists. When a View is visible in the
 start of the transition Views farther from the epicenter will transition
 sooner than Views closer to the epicenter. When a View is not in the start
 of the transition or is not visible at the start of the transition it will
 transition sooner when closer to the epicenter and later when farther from
 the epicenter. This is the default TransitionPropagation used with
  Explode ."
android,transition,PatternPathMotion,3,"A PathMotion that takes a Path pattern and applies it to the separation between two points.
 The starting point of the Path will be moved to the origin and the end point will be scaled
 and rotated so that it matches with the target end point.
  This may be used in XML as an element inside a transition. <changeBounds>
     <patternPathMotion android:patternPathData=""M0 0 L0 100 L100 100""/>
 </changeBounds>"
android,transition,Transition.EpicenterCallback,1,"Class to get the epicenter of Transition. Use
  Transition.setEpicenterCallback(android.transition.Transition.EpicenterCallback)  to
 set the callback used to calculate the epicenter of the Transition. Override
  Transition.getEpicenter()  to return the rectangular region in screen coordinates of
 the epicenter of the transition."
android,transition,TransitionInflater,3,"This class inflates scenes and transitions from resource files.

 Information on XML resource descriptions for transitions can be found for
  R.styleable.Transition   R.styleable.TransitionSet 
  R.styleable.TransitionTarget   R.styleable.Fade 
 and  R.styleable.TransitionManager ."
android,transition,TransitionManager,8,"This class manages the set of transitions that fire when there is a
 change of  Scene . To use the manager add scenes along with
 transition objects with calls to  setTransition(android.transition.Scene android.transition.Transition) 
 or  setTransition(android.transition.Scene android.transition.Scene android.transition.Transition) . Setting specific
 transitions for scene changes is not required; by default a Scene change
 will use  AutoTransition  to do something reasonable for most
 situations. Specifying other transitions for particular scene changes is
 only necessary if the application wants different transition behavior
 in these situations.

  TransitionManagers can be declared in XML resource files inside the
  res/transition  directory. TransitionManager resources consist of
 the  transitionManager tag name containing one or more
  transition  tags each of which describe the relationship of
 that transition to the from/to scene information in that tag.
 For example here is a resource file that declares several scene
 transitions: <transitionManager xmlns:android=""http://schemas.android.com/apk/res/android"">
    <transition android:fromScene=""@layout/transition_scene1""
                android:toScene=""@layout/transition_scene2""
                android:transition=""@transition/changebounds""/>
    <transition android:fromScene=""@layout/transition_scene2""
                android:toScene=""@layout/transition_scene1""
                android:transition=""@transition/changebounds""/>
    <transition android:toScene=""@layout/transition_scene3""
                android:transition=""@transition/changebounds_fadein_together""/>
    <transition android:fromScene=""@layout/transition_scene3""
                android:toScene=""@layout/transition_scene1""
                android:transition=""@transition/changebounds_fadeout_sequential""/>
    <transition android:fromScene=""@layout/transition_scene3""
                android:toScene=""@layout/transition_scene2""
                android:transition=""@transition/changebounds_fadeout_sequential""/>
</transitionManager> For each of the  fromScene  and  toScene  attributes
 there is a reference to a standard XML layout file. This is equivalent to
 creating a scene from a layout in code by calling
  Scene#getSceneForLayout(ViewGroup int Context) . For the
  transition  attribute there is a reference to a resource
 file in the  res/transition  directory which describes that
 transition. R.styleable.Transition R.styleable.TransitionSet R.styleable.TransitionTarget R.styleable.Fade R.styleable.TransitionManager"
android,transition,TransitionSet,29,"A TransitionSet is a parent of child transitions (including other
 TransitionSets). Using TransitionSets enables more complex
 choreography of transitions where some sets play  ORDERING_TOGETHER  and
 others play  ORDERING_SEQUENTIAL . For example  AutoTransition 
 uses a TransitionSet to sequentially play a Fade(Fade.OUT) followed by
 a  ChangeBounds  followed by a Fade(Fade.OUT) transition.

  A TransitionSet can be described in a resource file by using the
 tag  transitionSet  along with the standard
 attributes of  R.styleable.TransitionSet  and
  R.styleable.Transition . Child transitions of the
 TransitionSet object can be loaded by adding those child tags inside the
 enclosing  transitionSet  tag. For example the following xml
 describes a TransitionSet that plays a Fade and then a ChangeBounds
 transition on the affected view targets: 
     <transitionSet xmlns:android=""http://schemas.android.com/apk/res/android""
             android:transitionOrdering=""sequential"">
         <fade/>
         <changeBounds/>
     </transitionSet>"
android,transition,TransitionValues,3,"Data structure which holds cached values for the transition.
 The view field is the target which all of the values pertain to.
 The values field is a map which holds information for fields
 according to names selected by the transitions. These names should
 be unique to avoid clobbering values stored by other transitions
 such as the convention project:transition_name:property_name. For
 example the platform might store a property ""alpha"" in a transition
 ""Fader"" as ""android:fader:alpha"".

  These values are cached during the
  Transition#captureStartValues(TransitionValues) 
 capture} phases of a scene change once when the start values are captured
 and again when the end values are captured. These start/end values are then
 passed into the transitions via the
 for  Transition#createAnimator(ViewGroup TransitionValues TransitionValues) 
 method."
android,transition,VisibilityPropagation,5,"Base class for  TransitionPropagation s that care about
 View Visibility and the center position of the View."
android,transition,Visibility,12,"This transition tracks changes to the visibility of target views in the
 start and end scenes. Visibility is determined not just by the
  View#setVisibility(int)  state of views but also whether
 views exist in the current view hierarchy. The class is intended to be a
 utility for subclasses such as  Fade  which use this visibility
 information to determine the specific animations to run when visibility
 changes occur. Subclasses should implement one or both of the methods
  onAppear(android.view.ViewGroup android.transition.TransitionValues int android.transition.TransitionValues int) 
  onDisappear(android.view.ViewGroup android.transition.TransitionValues int android.transition.TransitionValues int)  or
  onAppear(android.view.ViewGroup android.view.View android.transition.TransitionValues android.transition.TransitionValues) 
  onDisappear(android.view.ViewGroup android.view.View android.transition.TransitionValues android.transition.TransitionValues) ."
android,service.chooser,ChooserTarget,8,"A ChooserTarget represents a deep-link into an application as returned by a
  ChooserTargetService .

  A chooser target represents a specific deep link target into an application exposed
 for selection by the user. This might be a frequently emailed contact a recently active
 group messaging conversation a folder in a cloud storage app a collection of related
 items published on a social media service or any other contextually relevant grouping
 of target app + relevant metadata. Creators of chooser targets should consult the relevant design guidelines for the type
 of target they are presenting. For example targets involving people should be presented
 with a circular icon."
android,service.chooser,ChooserTargetService,2,"A service that receives calls from the system when the user is asked to choose
 a target for an intent explicitly by another app. The calling app must have invoked
  ACTION_CHOOSER  as handled by the system;
 applications do not have the ability to query a ChooserTargetService directly.

  Which ChooserTargetServices are queried depends on a system-level policy decision
 made at the moment the chooser is invoked including but not limited to user time
 spent with the app package or associated components in the foreground recency of usage
 or frequency of usage. These will generally correlate with the order that app targets
 are shown in the list of intent handlers shown in the system chooser or resolver. To extend this class you must declare the service in your manifest file with
 the  Manifest.permission.BIND_CHOOSER_TARGET_SERVICE  permission
 and include an intent filter with the  SERVICE_INTERFACE  action. For example: 
     <service android:name="".MyChooserTargetService""
             android:label=""@string/service_name""
             android:permission=""android.permission.BIND_CHOOSER_TARGET_SERVICE"">
         <intent-filter>
             <action android:name=""android.service.chooser.ChooserTargetService"" />
         </intent-filter>
     </service>
  For the system to query your service you must add a <meta-data> element to the
 Activity in your manifest that can handle Intents that you would also like to provide
 optional deep links for. For example a chat app might offer deep links to recent active
 conversations instead of invoking a generic picker after the app itself is chosen as a target.
  The meta-data element should have the name
  android.service.chooser.chooser_target_service  and a value corresponding to
 the component name of your service. Example: 
     <activity android:name="".MyShareActivity""
             android:label=""@string/share_activity_label"">
         <intent-filter>
             <action android:name=""android.intent.action.SEND"" />
         </intent-filter>
         <meta-data android:name=""android.service.chooser.chooser_target_service""
                 android:value="".MyChooserTargetService"" />
     </activity>"
android,view.accessibility,AccessibilityEvent,25,"This class represents accessibility events that are sent by the system when
 something notable happens in the user interface. For example when a
  Button  is clicked a  View  is focused etc.
  
 An accessibility event is fired by an individual view which populates the event with
 data for its state and requests from its parent to send the event to interested
 parties. The parent can optionally modify or even block the event based on its broader
 understanding of the user interface's context.
  
 The main purpose of an accessibility event is to communicate changes in the UI to an
  AccessibilityService . The service may then inspect
 if needed the user interface by examining the View hierarchy as represented by a tree of
  AccessibilityNodeInfo s (snapshot of a View state)
 which can be used for exploring the window content. Note that the privilege for accessing
 an event's source thus the window content has to be explicitly requested. For more
 details refer to  AccessibilityService . If an
 accessibility service has not requested to retrieve the window content the event will
 not contain reference to its source. Also for events of type
  TYPE_NOTIFICATION_STATE_CHANGED  the source is never available.
  
 This class represents various semantically different accessibility event
 types. Each event type has an associated set of related properties. In other
 words each event type is characterized via a subset of the properties exposed
 by this class. For each event type there is a corresponding constant defined
 in this class. Follows a specification of the event types and their associated properties:"
android,view.accessibility,AccessibilityManager,17,"System level service that serves as an event dispatch for  AccessibilityEvent s
 and provides facilities for querying the accessibility state of the system.
 Accessibility events are generated when something notable happens in the user interface
 for example an  Activity  starts the focus or selection of a
  View  changes etc. Parties interested in handling accessibility
 events implement and register an accessibility service which extends
  AccessibilityService ."
android,view.accessibility,AccessibilityNodeInfo.AccessibilityAction,5,"A class defining an action that can be performed on an  AccessibilityNodeInfo .
 Each action has a unique id that is mandatory and optional data.
  
 There are three categories of actions:
  Standard actions  - These are actions that are reported and
 handled by the standard UI widgets in the platform. For each standard action
 there is a static constant defined in this class e.g.  ACTION_FOCUS .
 These actions will have  null  labels.
  Custom actions action  - These are actions that are reported
 and handled by custom widgets. i.e. ones that are not part of the UI toolkit. For
 example an application may define a custom action for clearing the user history.
  Overriden standard actions  - These are actions that override
 standard actions to customize them. For example an app may add a label to the
 standard  ACTION_CLICK  action to indicate to the user that this action clears
 browsing history.
  
 Actions are typically added to an  AccessibilityNodeInfo  by using
  AccessibilityNodeInfo#addAction(AccessibilityAction)  within
  View#onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo)  and are performed
 within  View#performAccessibilityAction(int Bundle) .
  Note:  Views which support these actions should invoke
  View#setImportantForAccessibility(int)  with
  View#IMPORTANT_FOR_ACCESSIBILITY_YES  to ensure an  AccessibilityService 
 can discover the set of supported actions."
android,view.accessibility,AccessibilityNodeInfo.CollectionInfo,6,"Class with information if a node is a collection. Use
  CollectionInfo#obtain(int int boolean)  to get an instance. Recycling is
 handled by the  AccessibilityNodeInfo  to which this object is attached.
  
 A collection of items has rows and columns and may be hierarchical.
 For example a horizontal list is a collection with one column as
 many rows as the list items and is not hierarchical; A table is a
 collection with several rows several columns and is not hierarchical;
 A vertical tree is a hierarchical collection with one column and
 as many rows as the first level children."
android,view.accessibility,AccessibilityNodeInfo.RangeInfo,5,"Class with information if a node is a range. Use
  RangeInfo#obtain(int float float float)  to get an instance. Recycling is
 handled by the  AccessibilityNodeInfo  to which this object is attached."
android,view.accessibility,AccessibilityNodeProvider,5,"This class is the contract a client should implement to enable support of a
 virtual view hierarchy rooted at a given view for accessibility purposes. A virtual
 view hierarchy is a tree of imaginary Views that is reported as a part of the view
 hierarchy when an  AccessibilityService  explores the window content.
 Since the virtual View tree does not exist this class is responsible for
 managing the  AccessibilityNodeInfo s describing that tree to accessibility
 services.
  
 The main use case of these APIs is to enable a custom view that draws complex content
 for example a monthly calendar grid to be presented as a tree of logical nodes
 for example month days each containing events thus conveying its logical structure.
  
 A typical use case is to override  View#getAccessibilityNodeProvider()  of the
 View that is a root of a virtual View hierarchy to return an instance of this class.
 In such a case this instance is responsible for managing  AccessibilityNodeInfo s
 describing the virtual sub-tree rooted at the View including the one representing the
 View itself. Similarly the returned instance is responsible for performing accessibility
 actions on any virtual view or the root view itself. For example:"
android,view.accessibility,AccessibilityRecord,51,"Represents a record in an  AccessibilityEvent  and contains information
 about state change of its source  View . When a view fires
 an accessibility event it requests from its parent to dispatch the
 constructed event. The parent may optionally append a record for itself
 for providing more context to
  AccessibilityService s. Hence
 accessibility services can facilitate additional accessibility records
 to enhance feedback.
  
 Once the accessibility event containing a record is dispatched the record is
 made immutable and calling a state mutation method generates an error.
  Note:  Not all properties are applicable to all accessibility
 event types. For detailed information please refer to  AccessibilityEvent ."
android,view.accessibility,AccessibilityNodeInfo,141,"This class represents a node of the window content as well as actions that
 can be requested from its source. From the point of view of an
  AccessibilityService  a window's content is
 presented as a tree of accessibility node infos which may or may not map one-to-one
 to the view hierarchy. In other words a custom view is free to report itself as
 a tree of accessibility node info.
  
 Once an accessibility node info is delivered to an accessibility service it is
 made immutable and calling a state mutation method generates an error.
  
 Please refer to  AccessibilityService  for
 details about how to obtain a handle to window content as a tree of accessibility
 node info as well as details about the security model."
android,view.accessibility,AccessibilityNodeInfo.CollectionItemInfo,8,"Class with information if a node is a collection item. Use
  CollectionItemInfo#obtain(int int int int boolean) 
 to get an instance. Recycling is handled by the  AccessibilityNodeInfo  to which this
 object is attached.
  
 A collection item is contained in a collection it starts at
 a given row and column in the collection and spans one or
 more rows and columns. For example a header of two related
 table columns starts at the first row and the first column
 spans one row and two columns."
android,view.accessibility,AccessibilityNodeInfo.TouchDelegateInfo,5,"Class with information of touch delegated views and regions from  TouchDelegate  for
 the  AccessibilityNodeInfo ."
android,view.accessibility,AccessibilityRequestPreparer,2,"Object responsible to ensuring that a  View  is prepared to meet a synchronous request for
 accessibility data.
  
 Because accessibility requests arrive to  View s synchronously on the UI thread a View
 that requires information from other processes can struggle to meet those requests. Registering
 an instance of this class with  AccessibilityManager  allows a View to be notified when
 a request is about to be made and to asynchronously inform the accessibility system when it is
 ready to meet the request.
  Note:  This class should only be needed in exceptional situations where a
  View  cannot otherwise synchronously meet the request for accessibility data."
android,view.accessibility,AccessibilityWindowInfo,22,"This class represents a state snapshot of a window for accessibility
 purposes. The screen content contains one or more windows where some
 windows can be descendants of other windows which is the windows are
 hierarchically ordered. Note that there is no root window. Hence the
 screen content can be seen as a collection of window trees."
android,view.accessibility,CaptioningManager,6,"Contains methods for accessing and monitoring preferred video captioning state and visual
 properties."
android,view.accessibility,CaptioningManager.CaptioningChangeListener,4,"Listener for changes in captioning properties including enabled state
 and user style preferences."
android,view.accessibility,CaptioningManager.CaptionStyle,6,"Specifies visual properties for video captions including foreground and
 background colors edge properties and typeface."
android,view.autofill,AutofillId,5,A unique identifier for an autofill node inside an  Activity .
android,view.autofill,AutofillManager,28,"The  AutofillManager  class provides ways for apps and custom views to
 integrate with the Autofill Framework lifecycle.

  To learn about using Autofill in your app read
 the  Autofill Framework  guides.

  Autofill lifecycle The autofill lifecycle starts with the creation of an autofill context associated with an
 activity context. The autofill context is created when one of the following methods is called for
 the first time in an activity context and the current user has an enabled autofill service:

  notifyViewEntered(android.view.View) notifyViewEntered(android.view.View int android.graphics.Rect) requestAutofill(android.view.View) Typically the context is automatically created when the first view of the activity is
 focused because  View.onFocusChanged()  indirectly calls
  notifyViewEntered(android.view.View) . App developers can call  requestAutofill(android.view.View)  to
 explicitly create it (for example a custom view developer could offer a contextual menu action
 in a text-field view to let users manually request autofill).

  After the context is created the Android System creates a  ViewStructure 
 that represents the view hierarchy by calling
  View#dispatchProvideAutofillStructure(android.view.ViewStructure int)  in the root views
 of all application windows. By default  dispatchProvideAutofillStructure()  results in
 subsequent calls to  View#onProvideAutofillStructure(android.view.ViewStructure int)  and
  View#onProvideAutofillVirtualStructure(android.view.ViewStructure int)  for each view in
 the hierarchy.

  The resulting  ViewStructure  is then passed to the autofill service which
 parses it looking for views that can be autofilled. If the service finds such views it returns
 a data structure to the Android System containing the following optional info:

  Datasets used to autofill subsets of views in the activity.
    Id of views that the service can save their values for future autofilling.
  When the service returns datasets the Android System displays an autofill dataset picker
 UI associated with the view when the view is focused on and is part of a dataset.
 The application can be notified when the UI is shown by registering an
  AutofillCallback  through  registerCallback(android.view.autofill.AutofillManager.AutofillCallback) . When the user
 selects a dataset from the UI all views present in the dataset are autofilled through
 calls to  View#autofill(AutofillValue)  or  View#autofill(SparseArray) .

  When the service returns ids of savable views the Android System keeps track of changes
 made to these views so they can be used to determine if the autofill save UI is shown later.

  The context is then finished when one of the following occurs:

  commit()  is called or all savable views are gone.
    cancel()  is called.
  Finally after the autofill context is commited (i.e. not cancelled) the Android System
 shows an autofill save UI if the value of savable views have changed. If the user selects the
 option to Save the current value of the views is then sent to the autofill service.

  Additional notes It is safe to call  AutofillManager  methods from any thread.
 
  
 Requires the  PackageManager#FEATURE_AUTOFILL  feature which can be detected using  PackageManager.hasSystemFeature(String) ."
android,view.autofill,AutofillManager.AutofillCallback,2,"Callback for autofill related events.

  Typically used for applications that display their own ""auto-complete"" views so they can
 enable / disable such views when the autofill UI is shown / hidden."
android,view.autofill,AutofillValue,17,"Abstracts how a  View  can be autofilled by an
  AutofillService .

  Each  AutofillValue  is associated with a  type  as defined by
  View#getAutofillType() ."
android,util,ArrayMap,26,"ArrayMap is a generic key->value mapping data structure that is
 designed to be more memory efficient than a traditional  HashMap .
 It keeps its mappings in an array data structure -- an integer array of hash
 codes for each item and an Object array of the key/value pairs.  This allows it to
 avoid having to create an extra object for every entry put in to the map and it
 also tries to control the growth of the size of these arrays more aggressively
 (since growing them only requires copying the entries in the array not rebuilding
 a hash map).

  Note that this implementation is not intended to be appropriate for data structures
 that may contain large numbers of items.  It is generally slower than a traditional
 HashMap since lookups require a binary search and adds and removes require inserting
 and deleting entries in the array.  For containers holding up to hundreds of items
 the performance difference is not significant less than 50%. Because this container is intended to better balance memory use unlike most other
 standard Java containers it will shrink its array as items are removed from it.  Currently
 you have no control over this shrinking -- if you set a capacity and then remove an
 item it may reduce the capacity to better match the current size.  In the future an
 explicit call to set the capacity should turn off this aggressive shrinking behavior."
android,util,Base64,7,"Utilities for encoding and decoding the Base64 representation of
 binary data.  See RFCs  2045  and  3548 ."
android,util,Base64OutputStream,3,"An OutputStream that does Base64 encoding on the data written to
 it writing the resulting data to another OutputStream."
android,util,Config,0,
android,util,DisplayMetrics,6,"A structure describing general information about a display such as its
 size density and font scaling.
  To access the DisplayMetrics members retrieve display metrics like this: context.getResources().getDisplayMetrics();"
android,util,EventLogTags,2,
android,util,FloatProperty,2,"An implementation of  Property  to be used specifically with fields of type
  float . This type-specific subclass enables performance benefit by allowing
 calls to a  setValue()  function that takes the primitive
  float  type and avoids autoboxing and other overhead associated with the
  Float  class."
android,util,JsonWriter,16,"Writes a JSON ( RFC 4627 )
 encoded value to a stream one token at a time. The stream includes both
 literal values (strings numbers booleans and nulls) as well as the begin
 and end delimiters of objects and arrays.

  Encoding JSON JsonWriter To write  arrays  first call  beginArray() .
       Write each of the array's elements with the appropriate  value(boolean) 
       methods or by nesting other arrays and objects. Finally close the array
       using  endArray() .
    To write  objects  first call  beginObject() .
       Write each of the object's properties by alternating calls to
        name(String)  with the property's value. Write property values with the
       appropriate  value(boolean)  method or by nesting other objects or arrays.
       Finally close the object using  endObject() .
  Example [
   {
     ""id"": 912345678901
     ""text"": ""How do I write JSON on Android?""
     ""geo"": null
     ""user"": {
       ""name"": ""android_newb""
       ""followers_count"": 41
      }
   }
   {
     ""id"": 912345678902
     ""text"": ""@android_newb just use android.util.JsonWriter!""
     ""geo"": [50.454722 -104.606667]
     ""user"": {
       ""name"": ""jesse""
       ""followers_count"": 2
     }
   }
 ] public void writeJsonStream(OutputStream out List<Message> messages) throws IOException {
     JsonWriter writer = new JsonWriter(new OutputStreamWriter(out ""UTF-8""));
     writer.setIndent(""  "");
     writeMessagesArray(writer messages);
     writer.close();
   }

   public void writeMessagesArray(JsonWriter writer List<Message> messages) throws IOException {
     writer.beginArray();
     for (Message message : messages) {
       writeMessage(writer message);
     }
     writer.endArray();
   }

   public void writeMessage(JsonWriter writer Message message) throws IOException {
     writer.beginObject();
     writer.name(""id"").value(message.getId());
     writer.name(""text"").value(message.getText());
     if (message.getGeo() != null) {
       writer.name(""geo"");
       writeDoublesArray(writer message.getGeo());
     } else {
       writer.name(""geo"").nullValue();
     }
     writer.name(""user"");
     writeUser(writer message.getUser());
     writer.endObject();
   }

   public void writeUser(JsonWriter writer User user) throws IOException {
     writer.beginObject();
     writer.name(""name"").value(user.getName());
     writer.name(""followers_count"").value(user.getFollowersCount());
     writer.endObject();
   }

   public void writeDoublesArray(JsonWriter writer List<Double> doubles) throws IOException {
     writer.beginArray();
     for (Double value : doubles) {
       writer.value(value);
     }
     writer.endArray();
   } Each  JsonWriter  may be used to write a single JSON stream.
 Instances of this class are not thread safe. Calls that would result in a
 malformed JSON string will fail with an  IllegalStateException ."
android,util,MutableBoolean,0,
android,util,MutableFloat,0,
android,util,Patterns,2,Commonly used regular expression patterns.
android,util,Property,6,"A property is an abstraction that can be used to represent a  mutable value that is held
 in a  host  object. The Property's  set(java.lang.Object java.lang.Object)  or  get(java.lang.Object) 
 methods can be implemented in terms of the private fields of the host object or via ""setter"" and
 ""getter"" methods or by some other mechanism as appropriate."
android,util,ArraySet,23,"ArraySet is a generic set data structure that is designed to be more memory efficient than a
 traditional  HashSet .  The design is very similar to
  ArrayMap  with all of the caveats described there.  This implementation is
 separate from ArrayMap however so the Object array contains only one item for each
 entry in the set (instead of a pair for a mapping).

  Note that this implementation is not intended to be appropriate for data structures
 that may contain large numbers of items.  It is generally slower than a traditional
 HashSet since lookups require a binary search and adds and removes require inserting
 and deleting entries in the array.  For containers holding up to hundreds of items
 the performance difference is not significant less than 50%. Because this container is intended to better balance memory use unlike most other
 standard Java containers it will shrink its array as items are removed from it.  Currently
 you have no control over this shrinking -- if you set a capacity and then remove an
 item it may reduce the capacity to better match the current size.  In the future an
 explicit call to set the capacity should turn off this aggressive shrinking behavior."
android,util,AtomicFile,7,"Helper class for performing atomic operations on a file by creating a
 backup file until a write has successfully completed.  If you need this
 on older versions of the platform you can use
  AtomicFile  in the v4 support library.
  
 Atomic file guarantees file integrity by ensuring that a file has
 been completely written and sync'd to disk before removing its backup.
 As long as the backup file exists the original file is considered
 to be invalid (left over from a previous attempt to write the file).
  
 Atomic file does not confer any file locking semantics.
 Do not use this class when the file may be accessed or modified concurrently
 by multiple threads or processes.  The caller is responsible for ensuring
 appropriate mutual exclusion invariants whenever it accesses the file."
android,util,Base64InputStream,8,"An InputStream that does Base64 decoding on the data read through
 it."
android,util,DebugUtils,1,Various utilities for debugging and logging.
android,util,EventLog.Event,5,A previously logged event read from the logs. Instances are thread safe.
android,util,EventLogTags.Description,0,
android,util,FloatMath,0,"Math routines similar to those found in  Math .

  Historically these methods were faster than the equivalent double-based
  Math  methods. On versions of Android with a JIT they
 became slower and have since been re-implemented to wrap calls to
  Math .  Math  should be used in
 preference.

  All methods were removed from the public API in version 23."
android,util,Half,45,"The  Half  class is a wrapper and a utility class to manipulate half-precision 16-bit
  IEEE 754 
 floating point data types (also called fp16 or binary16). A half-precision float can be
 created from or converted to single-precision floats and is stored in a short data type.
 To distinguish short values holding half-precision floats from regular short values
 it is recommended to use the  @HalfFloat  annotation. The IEEE 754 standard specifies an fp16 as having the following format: Sign bit: 1 bit Exponent width: 5 bits Significand: 10 bits The format is laid out as follows: 
 1   11111   1111111111
 ^   --^--   -----^----
 sign  |          |_______ significand
       |
       -- exponent
  Half-precision floating points can be useful to save memory and/or
 bandwidth at the expense of range and precision when compared to single-precision
 floating points (fp32). To help you decide whether fp16 is the right storage type for you need please
 refer to the table below that shows the available precision throughout the range of
 possible values. The  precision  column indicates the step size between two
 consecutive numbers in a specific part of the range. Range start Precision 0 1 â„ 16777216 1 â„ 16384 1 â„ 16777216 1 â„ 8192 1 â„ 8388608 1 â„ 4096 1 â„ 4194304 1 â„ 2048 1 â„ 2097152 1 â„ 1024 1 â„ 1048576 1 â„ 512 1 â„ 524288 1 â„ 256 1 â„ 262144 1 â„ 128 1 â„ 131072 1 â„ 64 1 â„ 65536 1 â„ 32 1 â„ 32768 1 â„ 16 1 â„ 16384 1 â„ 8 1 â„ 8192 1 â„ 4 1 â„ 4096 1 â„ 2 1 â„ 2048 1 1 â„ 1024 2 1 â„ 512 4 1 â„ 256 8 1 â„ 128 16 1 â„ 64 32 1 â„ 32 64 1 â„ 16 128 1 â„ 8 256 1 â„ 4 512 1 â„ 2 1024 1 2048 2 4096 4 8192 8 16384 16 32768 32 This table shows that numbers higher than 1024 lose all fractional precision."
android,util,IntProperty,2,"An implementation of  Property  to be used specifically with fields of type
  int . This type-specific subclass enables performance benefit by allowing
 calls to a  setValue()  function that takes the primitive
  int  type and avoids autoboxing and other overhead associated with the
  Integer  class."
android,util,LruCache,18,"A cache that holds strong references to a limited number of values. Each time
 a value is accessed it is moved to the head of a queue. When a value is
 added to a full cache the value at the end of that queue is evicted and may
 become eligible for garbage collection.

  If your cached values hold resources that need to be explicitly released
 override  entryRemoved(boolean K V V) .

  If a cache miss should be computed on demand for the corresponding keys
 override  create(K) . This simplifies the calling code allowing it to
 assume a value will always be returned even when there's a cache miss.

  By default the cache size is measured in the number of entries. Override
  sizeOf(K V)  to size the cache in different units. For example this cache
 is limited to 4MiB of bitmaps:
  int cacheSize = 4 * 1024 * 1024; // 4MiB
   LruCache<String Bitmap> bitmapCache = new LruCache<String Bitmap>(cacheSize) {
       protected int sizeOf(String key Bitmap value) {
           return value.getByteCount();
       }
   } This class is thread-safe. Perform multiple cache operations atomically by
 synchronizing on the cache:  synchronized (cache) {
     if (cache.get(key) == null) {
         cache.put(key value);
     }
   } This class does not allow null to be used as a key or value. A return
 value of null from  get(K)   put(K V)  or  remove(K)  is
 unambiguous: the key was not in the cache.

  This class appeared in Android 3.1 (Honeycomb MR1); it's available as part
 of  Android's
 Support Package  for earlier releases."
android,util,MutableChar,0,
android,util,EventLog,8,"Access to the system diagnostic event record.  System diagnostic events are
 used to record certain system-level events (such as garbage collection
 activity manager state system watchdogs and other low level activity)
 which may be automatically collected and analyzed during system development.

  This is  not  the main ""logcat"" debugging log ( Log )!
 These diagnostic events are for system integrators not application authors.

  Events use integer tag codes corresponding to /system/etc/event-log-tags.
 They carry a payload of one or more int long or String values.  The
 event-log-tags file defines the payload contents for each type code."
android,util,JsonReader,18,"Reads a JSON ( RFC 4627 )
 encoded value as a stream of tokens. This stream includes both literal
 values (strings numbers booleans and nulls) as well as the begin and
 end delimiters of objects and arrays. The tokens are traversed in
 depth-first order the same order that they appear in the JSON document.
 Within JSON objects name/value pairs are represented by a single token.

  Parsing JSON JsonReader Next create handler methods for each structure in your JSON text. You'll
 need a method for each object type and for each array type.
  Within  array handling  methods first call  beginArray()  to consume the array's opening bracket. Then create a
       while loop that accumulates values terminating when  hasNext() 
       is false. Finally read the array's closing bracket by calling  endArray() .
    Within  object handling  methods first call  beginObject()  to consume the object's opening brace. Then create a
       while loop that assigns values to local variables based on their name.
       This loop should terminate when  hasNext()  is false. Finally
       read the object's closing brace by calling  endObject() .
  When a nested object or array is encountered delegate to the
 corresponding handler method.

  When an unknown name is encountered strict parsers should fail with an
 exception. Lenient parsers should call  skipValue()  to recursively
 skip the value's nested tokens which may otherwise conflict.

  If a value may be null you should first check using  peek() .
 Null literals can be consumed using either  nextNull()  or  skipValue() .

  Example [
   {
     ""id"": 912345678901
     ""text"": ""How do I read JSON on Android?""
     ""geo"": null
     ""user"": {
       ""name"": ""android_newb""
       ""followers_count"": 41
      }
   }
   {
     ""id"": 912345678902
     ""text"": ""@android_newb just use android.util.JsonReader!""
     ""geo"": [50.454722 -104.606667]
     ""user"": {
       ""name"": ""jesse""
       ""followers_count"": 2
     }
   }
 ] public List<Message> readJsonStream(InputStream in) throws IOException {
     JsonReader reader = new JsonReader(new InputStreamReader(in ""UTF-8""));
     try {
       return readMessagesArray(reader);
     } finally {
       reader.close();
     }
   }

   public List<Message> readMessagesArray(JsonReader reader) throws IOException {
     List<Message> messages = new ArrayList<Message>();

     reader.beginArray();
     while (reader.hasNext()) {
       messages.add(readMessage(reader));
     }
     reader.endArray();
     return messages;
   }

   public Message readMessage(JsonReader reader) throws IOException {
     long id = -1;
     String text = null;
     User user = null;
     List<Double> geo = null;

     reader.beginObject();
     while (reader.hasNext()) {
       String name = reader.nextName();
       if (name.equals(""id"")) {
         id = reader.nextLong();
       } else if (name.equals(""text"")) {
         text = reader.nextString();
       } else if (name.equals(""geo"") && reader.peek() != JsonToken.NULL) {
         geo = readDoublesArray(reader);
       } else if (name.equals(""user"")) {
         user = readUser(reader);
       } else {
         reader.skipValue();
       }
     }
     reader.endObject();
     return new Message(id text user geo);
   }

   public List<Double> readDoublesArray(JsonReader reader) throws IOException {
     List<Double> doubles = new ArrayList<Double>();

     reader.beginArray();
     while (reader.hasNext()) {
       doubles.add(reader.nextDouble());
     }
     reader.endArray();
     return doubles;
   }

   public User readUser(JsonReader reader) throws IOException {
     String username = null;
     int followersCount = -1;

     reader.beginObject();
     while (reader.hasNext()) {
       String name = reader.nextName();
       if (name.equals(""name"")) {
         username = reader.nextString();
       } else if (name.equals(""followers_count"")) {
         followersCount = reader.nextInt();
       } else {
         reader.skipValue();
       }
     }
     reader.endObject();
     return new User(username followersCount);
   } Number Handling [1 ""1""] nextInt() nextString() 9007199254740993 Each  JsonReader  may be used to read a single JSON stream. Instances
 of this class are not thread safe."
android,util,LayoutDirection,0,"A class for defining layout directions. A layout direction can be left-to-right (LTR)
 or right-to-left (RTL). It can also be inherited (from a parent) or deduced from the default
 language script of a locale."
android,util,Log,17,"API for sending log output.

  Generally you should use the  Log.v()   Log.d() 
  Log.i()   Log.w()  and  Log.e()  methods to write logs.
 You can then  view the logs in logcat .

  The order in terms of verbosity from least to most is
 ERROR WARN INFO DEBUG VERBOSE.  Verbose should never be compiled
 into an application except during development.  Debug logs are compiled
 in but stripped at runtime.  Error warning and info logs are always kept.

  Tip:  A good convention is to declare a  TAG  constant
 in your class:

  private static final String TAG = ""MyActivity""; Tip:  Don't forget that when you make a call like
  Log.v(TAG ""index="" + i);"
android,util,LogPrinter,1,"Implementation of a  Printer  that sends its output
 to the system log."
android,util,LongSparseArray,16,"SparseArray mapping longs to Objects.  Unlike a normal array of Objects
 there can be gaps in the indices.  It is intended to be more memory efficient
 than using a HashMap to map Longs to Objects both because it avoids
 auto-boxing keys and its data structure doesn't rely on an extra entry object
 for each mapping.

  Note that this container keeps its mappings in an array data structure
 using a binary search to find keys.  The implementation is not intended to be appropriate for
 data structures
 that may contain large numbers of items.  It is generally slower than a traditional
 HashMap since lookups require a binary search and adds and removes require inserting
 and deleting entries in the array.  For containers holding up to hundreds of items
 the performance difference is not significant less than 50%. To help with performance the container includes an optimization when removing
 keys: instead of compacting its array immediately it leaves the removed entry marked
 as deleted.  The entry can then be re-used for the same key or compacted later in
 a single garbage collection step of all removed entries.  This garbage collection will
 need to be performed at any time the array needs to be grown or the the map size or
 entry values are retrieved. It is possible to iterate over the items in this container using
  keyAt(int)  and  valueAt(int) . Iterating over the keys using
  keyAt(int)  with ascending values of the index will return the
 keys in ascending order or the values corresponding to the keys in ascending
 order in the case of  valueAt(int) ."
android,util,MonthDisplayHelper,13,"Helps answer common questions that come up when displaying a month in a
 6 row calendar grid format.

 Not thread safe."
android,util,MutableLong,0,
android,util,MutableShort,0,
android,util,MutableByte,0,
android,util,MutableDouble,0,
android,util,MutableInt,0,
android,util,Pair,4,"Container to ease passing around a tuple of two objects. This object provides a sensible
 implementation of equals() returning true if equals() is true on each of the contained
 objects."
android,util,PrintStreamPrinter,1,"Implementation of a  Printer  that sends its output
 to a  PrintStream ."
android,util,PrintWriterPrinter,1,"Implementation of a  Printer  that sends its output
 to a  PrintWriter ."
android,view.contentcapture,ContentCaptureCondition,7,"Defines a condition for when content capture should be allowed.

  See  ContentCaptureManager#getContentCaptureConditions()  for more."
android,view.contentcapture,ContentCaptureContext,6,"Context associated with a  ContentCaptureSession  - see  ContentCaptureManager  for
 more info."
android,view.contentcapture,ContentCaptureContext.Builder,2,Builder for  ContentCaptureContext  objects.
android,view.contentcapture,ContentCaptureManager,5,"Content capture is mechanism used to let apps notify the Android system of events associated with
 views.

  Before using this manager you should check if it's available. Example:
  
  ContentCaptureManager mgr = context.getSystemService(ContentCaptureManager.class);
  if (mgr != null && mgr.isContentCaptureEnabled()) {
    // ...
  }
   To support content capture you must notifiy the Android system of the following events:

  When a visible view is laid out call
    ContentCaptureSession#notifyViewAppeared(ViewStructure) .
    When a view becomes invisible or is removed from the view hierarchy call
    ContentCaptureSession#notifyViewDisappeared(android.view.autofill.AutofillId) .
    When the view represents text and the text value changed call  ContentCaptureSession#notifyViewTextChanged(android.view.autofill.AutofillId CharSequence) .
  You can get a blank content capture structure using
  ContentCaptureSession#newViewStructure(View)  then populate its relevant fields.
 Here's an example of the relevant methods for an  EditText -like view:

  
 public class MyEditText extends View {

 private void populateContentCaptureStructure(@NonNull ViewStructure structure) {
   structure.setText(getText() getSelectionStart() getSelectionEnd());
   structure.setHint(getHint());
   structure.setInputType(getInputType());
   // set other properties like setTextIdEntry() setTextLines() setTextStyle()
   // setMinTextEms() setMaxTextEms() setMaxTextLength()
 }

 private void onTextChanged() {
   if (isLaidOut() && isTextEditable()) {
     ContentCaptureManager mgr = mContext.getSystemService(ContentCaptureManager.class);
     if (cm != null && cm.isContentCaptureEnabled()) {
        ContentCaptureSession session = getContentCaptureSession();
        if (session != null) {
          session.notifyViewTextChanged(getAutofillId() getText());
        }
   }
 }
  The main integration point with content capture is the  ContentCaptureSession . A ""main""
 session is automatically created by the Android system when content capture is enabled for the
 activity. The session could have a  ContentCaptureContext  to provide more contextual info
 about it such as the locus associated with the view hierarchy
 (see  LocusId  for more info about locus). By default the main session
 doesn't have a  ContentCaptureContext  but you can change it after its created. Example:

  
 protected void onCreate(Bundle savedInstanceState) {
   // Initialize view structure
   ContentCaptureSession session = rootView.getContentCaptureSession();
   if (session != null) {
     session.setContentCaptureContext(ContentCaptureContext.forLocusId(""chat_UserA_UserB""));
   }
 }
  If your activity contains view hierarchies with a different contextual meaning you should
 created child sessions for each view hierarchy root. For example if your activity is a browser
 you could use the main session for the main URL being rendered then child sessions for each
  IFRAME :

  
 ContentCaptureSession mMainSession;

 protected void onCreate(Bundle savedInstanceState) {
    // Initialize view structure...
    mMainSession = rootView.getContentCaptureSession();
    if (mMainSession != null) {
      mMainSession.setContentCaptureContext(
          ContentCaptureContext.forLocusId(""https://example.com""));
    }
 }

 private void loadIFrame(View iframeRootView String url) {
   if (mMainSession != null) {
      ContentCaptureSession iFrameSession = mMainSession.newChild(
          ContentCaptureContext.forLocusId(url));
      }
      iframeRootView.setContentCaptureSession(iFrameSession);
   }
   // Load iframe...
 }"
android,view.contentcapture,ContentCaptureSession,13,Session used when notifying the Android system about events associated with views.
android,view.contentcapture,ContentCaptureSessionId,5,Identifier for a Content Capture session.
android,view.contentcapture,DataRemovalRequest,5,"Class used by apps to remove content capture data associated with  LocusId .

  An app which has tagged data with a LocusId can therefore delete them later. This is intended
 to let apps propagate deletions of user data into the operating system."
android,view.contentcapture,DataRemovalRequest.Builder,3,Builder for  DataRemovalRequest  objects.
android,view.contentcapture,DataRemovalRequest.LocusIdRequest,2,Representation of a request to remove data associated with a  LocusId .
android,view.animation,AccelerateDecelerateInterpolator,1,"An interpolator where the rate of change starts and ends slowly but
 accelerates through the middle."
android,view.animation,AccelerateInterpolator,1,"An interpolator where the rate of change starts out slowly and
 and then accelerates."
android,view.animation,AlphaAnimation,3,"An animation that controls the alpha level of an object.
 Useful for fading things in and out. This animation ends up
 changing the alpha property of a  Transformation"
android,view.animation,Animation.Description,0,Utility class to parse a string description of a size.
android,view.animation,AnimationSet,19,"Represents a group of Animations that should be played together.
 The transformation of each individual animation are composed
 together into a single transform.
 If AnimationSet sets any properties that its children also set
 (for example duration or fillBefore) the values of AnimationSet
 override the child values.

  The way that AnimationSet inherits behavior from Animation is important to
 understand. Some of the Animation attributes applied to AnimationSet affect the
 AnimationSet itself some are pushed down to the children and some are ignored
 as follows:
  duration repeatMode fillBefore fillAfter: These properties when set
     on an AnimationSet object will be pushed down to all child animations. repeatCount fillEnabled: These properties are ignored for AnimationSet. startOffset shareInterpolator: These properties apply to the AnimationSet itself. Build.VERSION_CODES.ICE_CREAM_SANDWICH setDuration(500) android:duration=""500"""
android,view.animation,AnimationUtils,7,Defines common utilities for working with animations.
android,view.animation,AnticipateOvershootInterpolator,1,"An interpolator where the change starts backward then flings forward and overshoots
 the target value and finally goes back to the final value."
android,view.animation,BaseInterpolator,0,An abstract class which is extended by default interpolators.
android,view.animation,BounceInterpolator,1,An interpolator where the change bounces at the end.
android,view.animation,Animation,47,"Abstraction for an Animation that can be applied to Views Surfaces or
 other objects. See the  animation package
 description file ."
android,view.animation,AnticipateInterpolator,1,An interpolator where the change starts backward then flings forward.
android,view.animation,CycleInterpolator,1,"Repeats the animation for a specified number of cycles. The
 rate of change follows a sinusoidal pattern."
android,view.animation,DecelerateInterpolator,1,"An interpolator where the rate of change starts out quickly and
 and then decelerates."
android,view.animation,GridLayoutAnimationController,10,"A layout animation controller is used to animated a grid layout's children.

 While  LayoutAnimationController  relies only on the index of the child
 in the view group to compute the animation delay this class uses both the
 X and Y coordinates of the child within a grid.

 In addition the animation direction can be controlled. The default direction
 is  DIRECTION_LEFT_TO_RIGHT | DIRECTION_TOP_TO_BOTTOM . You can
 also set the animation priority to columns or rows. The default priority is
 none.

 Information used to compute the animation delay of each child are stored
 in an instance of
  GridLayoutAnimationController.AnimationParameters 
 itself stored in the  ViewGroup.LayoutParams  of the view."
android,view.animation,GridLayoutAnimationController.AnimationParameters,0,"The set of parameters that has to be attached to each view contained in
 the view group animated by the grid layout animation controller. These
 parameters are used to compute the start time of each individual view's
 animation."
android,view.animation,LayoutAnimationController,16,"A layout animation controller is used to animated a layout's or a view
 group's children. Each child uses the same animation but for every one of
 them the animation starts at a different time. A layout animation controller
 is used by  ViewGroup  to compute the delay by which each
 child's animation start must be offset. The delay is computed by using
 characteristics of each child like its index in the view group.

 This standard implementation computes the delay by multiplying a fixed
 amount of miliseconds by the index of the child in its parent view group.
 Subclasses are supposed to override
  getDelayForView(android.view.View)  to implement a different way
 of computing the delay. For instance a
  GridLayoutAnimationController  will compute the
 delay based on the column and row indices of the child in its parent view
 group.

 Information used to compute the animation delay of each child are stored
 in an instance of
  LayoutAnimationController.AnimationParameters 
 itself stored in the  ViewGroup.LayoutParams  of the view."
android,view.animation,LayoutAnimationController.AnimationParameters,0,"The set of parameters that has to be attached to each view contained in
 the view group animated by the layout animation controller. These
 parameters are used to compute the start time of each individual view's
 animation."
android,view.animation,LinearInterpolator,1,An interpolator where the rate of change is constant
android,view.animation,OvershootInterpolator,1,"An interpolator where the change flings forward and overshoots the last value
 then comes back."
android,view.animation,PathInterpolator,1,"An interpolator that can traverse a Path that extends from  Point (0 0)  to  (1 1) . The x coordinate along the  Path 
 is the input value and the output is the y coordinate of the line at that point.
 This means that the Path must conform to a function  y = f(x) .

  The  Path  must not have gaps in the x direction and must not
 loop back on itself such that there can be two points sharing the same x coordinate.
 It is alright to have a disjoint line in the vertical direction: 
     Path path = new Path();
     path.lineTo(0.25f 0.25f);
     path.moveTo(0.25f 0.5f);
     path.lineTo(1f 1f);"
android,view.animation,RotateAnimation,2,"An animation that controls the rotation of an object. This rotation takes
 place in the X-Y plane. You can specify the point to use for the center of
 the rotation where (00) is the top left point. If not specified (00) is
 the default rotation point."
android,view.animation,ScaleAnimation,2,"An animation that controls the scale of an object. You can specify the point
 to use for the center of scaling."
android,view.animation,Transformation,10,"Defines the transformation to be applied at
 one point in time of an Animation."
android,view.animation,TranslateAnimation,2,"An animation that controls the position of an object. See the
  full package  description for details and
 sample code."
android,view.inspector,IntFlagMapping,2,"Maps the values of an  int  property to sets of string for properties that encode flags.

 An  InspectionCompanion  may provide an instance of this class to a  PropertyMapper 
 for flag values packed into primitive  int  properties.

 Each flag has a mask and a target value for non-exclusive flags the target can also be used as
 the mask. A given integer value is compared against each flag to find what flags are active for
 it by bitwise anding it with the mask and comparing the result against the target that is
  (value & mask) == target ."
android,view.inspector,StaticInspectionCompanionProvider,1,An inspection companion provider that finds companions as inner classes or generated code.
android,view.inspector,WindowInspector,1,Provides access to window inspection information.
android,view.inputmethod,BaseInputConnection,31,"Base class for implementors of the InputConnection interface taking care
 of most of the common behavior for providing a connection to an Editable.
 Implementors of this class will want to be sure to implement
  getEditable()  to provide access to their own editable object and
 to refer to the documentation in  InputConnection ."
android,view.inputmethod,CompletionInfo,7,"Information about a single text completion that an editor has reported to
 an input method.

  This class encapsulates a completion offered by an application
 that wants it to be presented to the user by the IME. Usually apps
 present their completions directly in a scrolling list for example
 (UI developers will usually use or extend
  to implement this).
 However in some cases the editor may not be visible as in the
 case in extract mode where the IME has taken over the full
 screen. In this case the editor can choose to send their
 completions to the IME for display.

  Most applications who want to send completions to an IME should use
  AutoCompleteTextView  as this class makes this
 process easy. In this case the application would not have to deal directly
 with this class.

  An application who implements its own editor and wants direct control
 over this would create an array of CompletionInfo objects and send it to the IME using
  InputMethodManager#displayCompletions(View CompletionInfo[]) .
 The IME would present the completions however they see fit and
 call back to the editor through
  InputConnection#commitCompletion(CompletionInfo) .
 The application can then pick up the commit event by overriding
  TextView.onCommitCompletion(CompletionInfo) ."
android,view.inputmethod,CorrectionInfo,6,"Information about a single text correction that an editor has reported to
 an input method."
android,view.inputmethod,CursorAnchorInfo,17,"Positional information about the text insertion point and characters in the composition string.

  This class encapsulates locations of the text insertion point and the composition string in
 the screen coordinates so that IMEs can render their UI components near where the text is
 actually inserted."
android,view.inputmethod,CursorAnchorInfo.Builder,7,Builder for  CursorAnchorInfo . This class is not designed to be thread-safe.
android,view.inputmethod,EditorInfo,4,"An EditorInfo describes several attributes of a text editing object
 that an input method is communicating with (typically an EditText) most
 importantly the type of text content it contains and the current cursor position."
android,view.inputmethod,ExtractedText,2,"Information about text that has been extracted for use by an input method.

 This contains information about a portion of the currently edited text
 that the IME should display into its own interface while in extracted mode."
android,view.inputmethod,InputBinding,7,"Information given to an  InputMethod  about a client connecting
 to it."
android,view.inputmethod,InputConnectionWrapper,27,Wrapper class for proxying calls to another InputConnection.  Subclass and have fun!
android,view.inputmethod,InputMethodSubtype.InputMethodSubtypeBuilder,11,"InputMethodSubtypeBuilder is a builder class of InputMethodSubtype.
 This class is designed to be used with
  InputMethodManager.setAdditionalInputMethodSubtypes(String InputMethodSubtype[]) .
 The developer needs to be aware of what each parameter means."
android,view.inputmethod,ExtractedTextRequest,2,"Description of what an input method would like from an application when
 extract text from its input editor."
android,view.inputmethod,InputContentInfo,7,A container object with which input methods can send content files to the target application.
android,view.inputmethod,InputMethodInfo,17,"This class is used to specify meta information of an input method.

  It should be defined in an XML resource file with an  <input-method>  element.
 For more information see the guide to
  
 Creating an Input Method ."
android,view.inputmethod,InputMethodManager,39,"Central system API to the overall input method framework (IMF) architecture
 which arbitrates interaction between applications and the current input method.

  Topics covered here:
  Architecture Overview Applications Input Methods Security Architecture Overview There are three primary parties involved in the input method
 framework (IMF) architecture:  The  input method manager  as expressed by this class
 is the central point of the system that manages interaction between all
 other parts.  It is expressed as the client-side API here which exists
 in each application context and communicates with a global system service
 that manages the interaction across all processes.
   An  input method (IME)  implements a particular
 interaction model allowing the user to generate text.  The system binds
 to the current input method that is in use causing it to be created and run
 and tells it when to hide and show its UI.  Only one IME is running at a time.
   Multiple  client applications  arbitrate with the input
 method manager for input focus and control over the state of the IME.  Only
 one such client is ever active (working with the IME) at a time.
  Applications In most cases applications that are using the standard
  TextView  or its subclasses will have little they need
 to do to work well with soft input methods.  The main things you need to
 be aware of are:  Properly set the  R.attr.inputType  in your editable
 text views so that the input method will have enough context to help the
 user in entering text into them.
   Deal well with losing screen space when the input method is
 displayed.  Ideally an application should handle its window being resized
 smaller but it can rely on the system performing panning of the window
 if needed.  You should set the  R.attr.windowSoftInputMode 
 attribute on your activity or the corresponding values on windows you
 create to help the system determine whether to pan or resize (it will
 try to determine this automatically but may get it wrong).
   You can also control the preferred soft input state (open closed etc)
 for your window using the same  R.attr.windowSoftInputMode 
 attribute.
  More finer-grained control is available through the APIs here to directly
 interact with the IMF and its IME -- either showing or hiding the input
 area letting the user pick an input method etc. For the rare people amongst us writing their own text editors you
 will need to implement  View.onCreateInputConnection(EditorInfo) 
 to return a new instance of your own  InputConnection  interface
 allowing the IME to interact with your editor. Input Methods An input method (IME) is implemented
 as a  Service  typically deriving from
  InputMethodService .  It must provide
 the core  InputMethod  interface though this is normally handled by
  InputMethodService  and implementors will
 only need to deal with the higher-level API there. InputMethodService Security There are a lot of security issues associated with input methods
 since they essentially have freedom to completely drive the UI and monitor
 everything the user enters.  The Android input method framework also allows
 arbitrary third party IMEs so care must be taken to restrict their
 selection and interactions. Here are some key points about the security architecture behind the
 IMF: Only the system is allowed to directly access an IME's
  InputMethod  interface via the
  Manifest.permission.BIND_INPUT_METHOD  permission.  This is
 enforced in the system by not binding to an input method service that does
 not require this permission so the system can guarantee no other untrusted
 clients are accessing the current input method outside of its control. There may be many client processes of the IMF but only one may
 be active at a time.  The inactive clients can not interact with key
 parts of the IMF through the mechanisms described below. Clients of an input method are only given access to its
  InputMethodSession  interface.  One instance of this interface is
 created for each client and only calls from the session associated with
 the active client will be processed by the current IME.  This is enforced
 by  AbstractInputMethodService  for normal
 IMEs but must be explicitly handled by an IME that is customizing the
 raw  InputMethodSession  implementation. Only the active client's  InputConnection  will accept
 operations.  The IMF tells each client process whether it is active and
 the framework enforces that in inactive processes calls on to the current
 InputConnection will be ignored.  This ensures that the current IME can
 only deliver events and text edits to the UI that the user sees as
 being in focus. An IME can never interact with an  InputConnection  while
 the screen is off.  This is enforced by making all clients inactive while
 the screen is off and prevents bad IMEs from driving the UI when the user
 can not be aware of its behavior. A client application can ask that the system let the user pick a
 new IME but can not programmatically switch to one itself.  This avoids
 malicious applications from switching the user to their own IME which
 remains running when the user navigates away to another application.  An
 IME on the other hand  is  allowed to programmatically switch
 the system to another IME since it already has full control of user
 input. The user must explicitly enable a new IME in settings before
 they can switch to it to confirm with the system that they know about it
 and want to make it available for use. PackageManager#FEATURE_INPUT_METHODS PackageManager.hasSystemFeature(String)"
android,view.inputmethod,InputMethodSubtype,16,"This class is used to specify meta information of a subtype contained in an input method editor
 (IME). Subtype can describe locale (e.g. en_US fr_FR...) and mode (e.g. voice keyboard...)
 and is used for IME switch and settings. The input method subtype allows the system to bring up
 the specified subtype of the designated IME directly.

  It should be defined in an XML resource file of the input method with the
  <subtype>  element which resides within an  <input-method>  element.
 For more information see the guide to
  
 Creating an Input Method ."
android,view.textservice,SentenceSuggestionsInfo,6,"This class contains a metadata of suggestions returned from a text service
 (e.g.  SpellCheckerService ).
 The text service uses this class to return the suggestions
 for a sentence. See  SuggestionsInfo  which is used for suggestions for a word.
 This class extends the functionality of  SuggestionsInfo  as far as this class enables
 you to put multiple  SuggestionsInfo s on a sentence with the offsets and the lengths
 of all  SuggestionsInfo s."
android,view.textservice,SpellCheckerInfo,11,This class is used to specify meta information of a spell checker.
android,view.textservice,SpellCheckerSession,8,"The SpellCheckerSession interface provides the per client functionality of SpellCheckerService.


  Applications In most cases applications that are using the standard
  TextView  or its subclasses will have little they need
 to do to work well with spell checker services.  The main things you need to
 be aware of are:  Properly set the  R.attr.inputType  in your editable
 text views so that the spell checker will have enough context to help the
 user in editing text in them.
  For the rare people amongst us writing client applications that use the spell checker service
 directly you will need to use  getSuggestions(android.view.textservice.TextInfo int)  or
  getSuggestions(android.view.textservice.TextInfo[] int boolean)  for obtaining results from the spell checker
 service by yourself. Security There are a lot of security issues associated with spell checkers
 since they could monitor all the text being sent to them
 through for instance  TextView .
 The Android spell checker framework also allows
 arbitrary third party spell checkers so care must be taken to restrict their
 selection and interactions. Here are some key points about the security architecture behind the
 spell checker framework: Only the system is allowed to directly access a spell checker framework's
  SpellCheckerService  interface via the
  Manifest.permission.BIND_TEXT_SERVICE  permission.  This is
 enforced in the system by not binding to a spell checker service that does
 not require this permission.

  The user must explicitly enable a new spell checker in settings before
 they can be enabled to confirm with the system that they know about it
 and want to make it available for use."
android,view.textservice,SpellCheckerSubtype,11,"This class is used to specify meta information of a subtype contained in a spell checker.
 Subtype can describe locale (e.g. en_US fr_FR...) used for settings."
android,view.textservice,SuggestionsInfo,8,This class contains a metadata of suggestions from the text service
android,view.textservice,TextInfo,6,This class contains a metadata of the input of TextService
android,view.textservice,TextServicesManager,1,"System API to the overall text services which arbitrates interaction between applications
 and text services.

 The user can change the current text services in Settings. And also applications can specify
 the target text services.

  Architecture Overview There are three primary parties involved in the text services
 framework (TSF) architecture:  The  text services manager  as expressed by this class
 is the central point of the system that manages interaction between all
 other parts.  It is expressed as the client-side API here which exists
 in each application context and communicates with a global system service
 that manages the interaction across all processes.
   A  text service  implements a particular
 interaction model allowing the client application to retrieve information of text.
 The system binds to the current text service that is in use causing it to be created and run.
   Multiple  client applications  arbitrate with the text service
 manager for connections to text services.
  Text services sessions The  spell checker session  is one of the text services.
  SpellCheckerSession"
android,webkit,ClientCertRequest,7,"ClientCertRequest: The user receives an instance of this class as
 a parameter of  WebViewClient#onReceivedClientCertRequest .
 The request includes the parameters to choose the client certificate
 such as the host name and the port number requesting the cert the acceptable
 key types and the principals.

 The user should call one of the class methods to indicate how to deal
 with the client certificate request. All methods should be called on
 UI thread.

 WebView caches the  proceed(PrivateKey X509Certificate[])  and  cancel()  responses in memory
 and uses them to handle future client certificate requests for the same
 host/port pair. The user can clear the cached data using
  WebView#clearClientCertPreferences ."
android,webkit,ConsoleMessage,4,"Public class representing a JavaScript console message from WebCore. This could be a issued
 by a call to one of the  console  logging functions (e.g.
  console.log('...') ) or a JavaScript error on the  page. To receive notifications
 of these messages override the
  WebChromeClient#onConsoleMessage(ConsoleMessage)  function."
android,webkit,CookieManager,18,"Manages the cookies used by an application's  WebView  instances.
  
 CookieManager represents cookies as strings in the same format as the
 HTTP  Cookie  and  Set-Cookie  header fields (defined in
  RFC6265bis )."
android,webkit,CookieSyncManager,8,"The CookieSyncManager is used to synchronize the browser cookie store
 between RAM and permanent storage. To get the best performance browser cookies are
 saved in RAM. A separate thread saves the cookies between driven by a timer.
  

 To use the CookieSyncManager the host application has to call the following
 when the application starts:
  CookieSyncManager.createInstance(context) 

 To set up for sync the host application has to call CookieSyncManager.getInstance().startSync() 

 in Activity.onResume() and call
  
 CookieSyncManager.getInstance().stopSync()
  

 in Activity.onPause(). 

 To get instant sync instead of waiting for the timer to trigger the host can
 call
  CookieSyncManager.getInstance().sync() 

 The sync interval is 5 minutes so you will want to force syncs
 manually anyway for instance in  WebViewClient#onPageFinished . Note that even sync() happens
 asynchronously so don't do it just as your activity is shutting
 down."
android,webkit,DateSorter,3,"Sorts dates into the following groups:
   Today
   Yesterday
   seven days ago
   one month ago
   older than a month ago"
android,webkit,JsPromptResult,1,"Public class for handling JavaScript prompt requests. The WebChromeClient will receive a
  WebChromeClient#onJsPrompt(WebView String String String JsPromptResult)  call with a
 JsPromptResult instance as a parameter. This parameter is used to return the result of this user
 dialog prompt back to the WebView instance. The client can call cancel() to cancel the dialog or
 confirm() with the user's input to confirm the dialog."
android,webkit,JsResult,2,"An instance of this class is passed as a parameter in various  WebChromeClient  action
 notifications. The object is used as a handle onto the underlying JavaScript-originated request
 and provides a means for the client to indicate whether this action should proceed."
android,webkit,MimeTypeMap,6,"Two-way map that maps MIME-types to file extensions and vice versa.

  See also  URLConnection.guessContentTypeFromName(String) 
 and  URLConnection.guessContentTypeFromStream(InputStream) . This
 class and  URLConnection  share the same MIME-type database."
android,webkit,PermissionRequest,4,"This class defines a permission request and is used when web content
 requests access to protected resources. The permission request related events
 are delivered via  WebChromeClient#onPermissionRequest  and
  WebChromeClient#onPermissionRequestCanceled .

 Either  grant()  or  deny()  must be called in UI
 thread to respond to the request.

 New protected resources whose names are not defined here may be requested in
 future versions of WebView even when running on an older Android release. To
 avoid unintentionally granting requests for new permissions you should pass the
 specific permissions you intend to grant to  grant() 
 and avoid writing code like this example:
  
 permissionRequest.grant(permissionRequest.getResources())  // This is wrong!!!"
android,webkit,SafeBrowsingResponse,3,"Used to indicate an action to take when hitting a malicious URL. Instances of this class are
 created by the WebView and passed to  WebViewClient.onSafeBrowsingHit(WebView WebResourceRequest int SafeBrowsingResponse) . The
 host application must call  showInterstitial(boolean)   proceed(boolean)  or
  backToSafety(boolean)  to set the WebView's response to the Safe Browsing hit.

  
 If reporting is enabled all reports will be sent according to the privacy policy referenced by
  WebView.getSafeBrowsingPrivacyPolicyUrl() ."
android,webkit,ServiceWorkerClient,1,"Base class for clients to capture Service Worker related callbacks
 see  ServiceWorkerController  for usage example."
android,webkit,ServiceWorkerController,3,"Manages Service Workers used by WebView.

  Example usage:
  
 ServiceWorkerController swController = ServiceWorkerController.getInstance();
 swController.setServiceWorkerClient(new ServiceWorkerClient() {
   @Override
   public WebResourceResponse shouldInterceptRequest(WebResourceRequest request) {
     // Capture request here and generate response or allow pass-through
     // by returning null.
     return null;
   }
 });"
android,webkit,ServiceWorkerWebSettings,8,"Manages settings state for all Service Workers. These settings are not tied to
 the lifetime of any WebView because service workers can outlive WebView instances.
 The settings are similar to  WebSettings  but only settings relevant to
 Service Workers are supported."
android,webkit,SslErrorHandler,2,"Represents a request for handling an SSL error. Instances of this class are
 created by the WebView and passed to
  WebViewClient#onReceivedSslError . The host application must call
 either  proceed()  or  cancel()  to set the WebView's response
 to the request."
android,webkit,TracingConfig.Builder,5,"Builder used to create  TracingConfig  objects.
  
 Examples:
  
   // Create a configuration with default options:  TracingConfig.CATEGORIES_NONE 
   //  TracingConfig.RECORD_CONTINUOUSLY .
    new TracingConfig.Builder().build() 

   // Record trace events from the ""web developer"" predefined category sets.
   // Uses a ring buffer (the default  TracingConfig.RECORD_CONTINUOUSLY  mode) for
   // internal storage during tracing.
    new TracingConfig.Builder().addCategories(CATEGORIES_WEB_DEVELOPER).build() 

   // Record trace events from the ""rendering"" and ""input latency"" predefined
   // category sets.
    new TracingConfig.Builder().addCategories(CATEGORIES_RENDERING
                                     CATEGORIES_INPUT_LATENCY).build() 

   // Record only the trace events from the ""browser"" category.
    new TracingConfig.Builder().addCategories(""browser"").build() 

   // Record only the trace events matching the ""blink*"" and ""renderer*"" patterns
   // (e.g. ""blink.animations"" ""renderer_host"" and ""renderer.scheduler"" categories).
    new TracingConfig.Builder().addCategories(""blink*""""renderer*"").build() 

   // Record events from the ""web developer"" predefined category set and events from
   // the ""disabled-by-default-v8.gc"" category to understand where garbage collection
   // is being triggered. Uses a limited size buffer for internal storage during tracing.
    new TracingConfig.Builder().addCategories(CATEGORIES_WEB_DEVELOPER)
                              .addCategories(""disabled-by-default-v8.gc"")
                              .setTracingMode(RECORD_UNTIL_FULL).build()"
android,webkit,URLUtil,16,
android,webkit,WebChromeClient.FileChooserParams,7,Parameters used in the  WebChromeClient.onShowFileChooser(WebView ValueCallback  WebChromeClient.FileChooserParams)  method.
android,webkit,WebIconDatabase,7,"Functions for manipulating the icon database used by WebView.
 These functions require that a WebView be constructed before being invoked
 and WebView.getIconDatabase() will return a WebIconDatabase object. This
 WebIconDatabase object is a single instance and all methods operate on that
 single object.
 The main use-case for this class is calling  open(String) 
 to enable favicon functionality on all WebView instances in this process."
android,webkit,WebMessage,2,"The Java representation of the HTML5 PostMessage event. See
 https://html.spec.whatwg.org/multipage/comms.html#the-messageevent-interfaces
 for definition of a MessageEvent in HTML5."
android,webkit,WebMessagePort,4,"The Java representation of the
  
 HTML5 message ports. A Message port represents one endpoint of a Message Channel. In Android
 webview there is no separate Message Channel object. When a message channel
 is created both ports are tangled to each other and started and then
 returned in a MessagePort array see  WebView#createWebMessageChannel 
 for creating a message channel.

  When a message port is first created or received via transfer it does not
 have a WebMessageCallback to receive web messages. The messages are queued until
 a WebMessageCallback is set.

  A message port should be closed when it is not used by the embedder application
 anymore. A closed port cannot be transferred or cannot be reopened to send
 messages. Close can be called multiple times.

  When a port is transferred to JS it cannot be used to send or receive messages
 at the Java side anymore. Different from HTML5 Spec a port cannot be transferred
 if one of these has ever happened: i. a message callback was set ii. a message was
 posted on it. A transferred port cannot be closed by the application since
 the ownership is also transferred.

  It is possible to transfer both ports of a channel to JS for example for
 communication between subframes."
android,webkit,WebMessagePort.WebMessageCallback,1,"The listener for handling MessagePort events. The message callback
 methods are called on the main thread. If the embedder application
 wants to receive the messages on a different thread it can do this
 by passing a Handler in
   WebMessagePort#setWebMessageCallback(WebMessageCallback Handler) .
 In the latter case the application should be extra careful for thread safety
 since WebMessagePort methods should be called on main thread."
android,webkit,WebResourceResponse,11,"Encapsulates a resource response. Applications can return an instance of this
 class from  WebViewClient#shouldInterceptRequest  to provide a custom
 response when the WebView requests a particular resource."
android,webkit,WebView.HitTestResult,2,
android,webkit,WebView.WebViewTransport,2,Transportation object for returning WebView across thread boundaries.
android,webkit,WebViewClient,23,
android,webkit,WebViewDatabase,9,"This class allows developers to determine whether any WebView used in the
 application has stored any of the following types of browsing data and
 to clear any such stored data for all WebViews in the application.
  Username/password pairs for web forms HTTP authentication username/password pairs Data entered into text fields (e.g. for autocomplete suggestions)"
android,webkit,WebViewFragment,6,"A fragment that displays a WebView.
  
 The WebView is automically paused or resumed when the Fragment is paused or resumed."
android,webkit,WebViewRenderProcess,1,WebViewRenderProcess provides an opaque handle to a  WebView  renderer.
android,webkit,WebViewRenderProcessClient,2,"Used to receive callbacks on  WebView  renderer events.

 WebViewRenderProcessClient instances may be set or retrieved via  WebView#setWebViewRenderProcessClient(WebViewRenderProcessClient)  and  WebView#getWebViewRenderProcessClient() .

 Instances may be attached to multiple WebViews and thus a single renderer event may cause
 a callback to be called multiple times with different WebView parameters."
android,webkit,GeolocationPermissions,6,"This class is used to manage permissions for the WebView's Geolocation
 JavaScript API.

 Geolocation permissions are applied to an origin which consists of the
 host scheme and port of a URI. In order for web content to use the
 Geolocation API permission must be granted for that content's origin.

 This class stores Geolocation permissions. An origin's permission state can
 be either allowed or denied. This class uses Strings to represent
 an origin.

 When an origin attempts to use the Geolocation API but no permission state
 is currently set for that origin
  WebChromeClient#onGeolocationPermissionsShowPrompt(StringGeolocationPermissions.Callback) 
 is called. This allows the permission state to be set for that origin.

 The methods of this class can be used to modify and interrogate the stored
 Geolocation permissions at any time."
android,webkit,HttpAuthHandler,3,"Represents a request for HTTP authentication. Instances of this class are
 created by the WebView and passed to
  WebViewClient#onReceivedHttpAuthRequest . The host application must
 call either  proceed(String String)  or  cancel()  to set the WebView's
 response to the request."
android,webkit,RenderProcessGoneDetail,2,"This class provides more specific information about why the render process
 exited. The application may use this to decide how to handle the situation.
 * @apiSince 26"
android,webkit,TracingConfig,3,Holds tracing configuration information and predefined settings.
android,webkit,TracingController,4,"Manages tracing of WebViews. In particular provides functionality for the app
 to enable/disable tracing of parts of code and to collect tracing data.
 This is useful for profiling performance issues debugging and memory usage
 analysis in production and real life scenarios.
  
 The resulting trace data is sent back as a byte sequence in json format. This
 file can be loaded in ""chrome://tracing"" for further analysis.
  
 Example usage:
  
 TracingController tracingController = TracingController.getInstance();
 tracingController.start(new TracingConfig.Builder()
                  .addCategories(TracingConfig.CATEGORIES_WEB_DEVELOPER).build());
 ...
 tracingController.stop(new FileOutputStream(""trace.json"")
                        Executors.newSingleThreadExecutor());"
android,webkit,WebBackForwardList,5,"This class contains the back/forward list for a WebView.
 WebView.copyBackForwardList() will return a copy of this class used to
 inspect the entries in the list."
android,webkit,WebChromeClient,27,
android,webkit,WebResourceError,2,"Encapsulates information about errors occured during loading of web resources. See
  WebViewClient#onReceivedError(WebView WebResourceRequest WebResourceError)"
android,webkit,WebStorage.Origin,3,"This class encapsulates information about the amount of storage
 currently used by an origin for the JavaScript storage APIs.
 An origin comprises the host scheme and port of a URI.
 See  WebStorage  for details."
android,webkit,WebHistoryItem,5,"A convenience class for accessing fields in an entry in the back/forward list
 of a WebView. Each WebHistoryItem is a snapshot of the requested history
 item."
android,webkit,WebSettings,100,"Manages settings state for a WebView. When a WebView is first created it
 obtains a set of default settings. These default settings will be returned
 from any getter call. A  WebSettings  object obtained from
  WebView#getSettings()  is tied to the life of the WebView. If a WebView has
 been destroyed any method call on  WebSettings  will throw an
  IllegalStateException ."
android,webkit,WebStorage,7,"This class is used to manage the JavaScript storage APIs provided by the
  WebView . It manages the Application Cache API the Web SQL Database
 API and the HTML5 Web Storage API.

 The Application Cache API provides a mechanism to create and maintain an
 application cache to power offline Web applications. Use of the Application
 Cache API can be attributed to an origin  WebStorage.Origin  however
 it is not possible to set per-origin quotas. Note that there can be only
 one application cache per application.

 The Web SQL Database API provides storage which is private to a given origin.
 Similar to the Application Cache use of the Web SQL Database can be attributed
 to an origin. It is also possible to set per-origin quotas."
android,webkit,WebView,156,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content ."
android,webkit,WebView.VisualStateCallback,1,"Callback interface supplied to  WebView.postVisualStateCallback(long WebView.VisualStateCallback)  for receiving
 notifications about the visual state."
android,dalvik.bytecode,OpcodeInfo,0,Information about Dalvik opcodes.
android,view.textclassifier,ConversationAction,7,Represents the action suggested by a  TextClassifier  on a given conversation.
android,view.textclassifier,ConversationActions,4,Represents a list of actions suggested by a  TextClassifier  on a given conversation.
android,view.textclassifier,ConversationActions.Message,6,Represents a message in the conversation.
android,view.textclassifier,ConversationActions.Message.Builder,4,Builder class to construct a  Message
android,view.textclassifier,ConversationActions.Request,8,A request object for generating conversation action suggestions.
android,view.textclassifier,ConversationActions.Request.Builder,5,Builder object to construct the  Request  object.
android,view.textclassifier,SelectionEvent,28,"A selection event.
 Specify index parameters as word token indices."
android,view.textclassifier,TextClassification,14,"Information for generating a widget to handle classified text.

  A TextClassification object contains icons labels onClickListeners and intents that may
 be used to build a widget that can be used to act on classified text. There is the concept of a
  primary action  and other  secondary actions .

  e.g. building a view that when clicked shares the classified text with the preferred app:

  // Called preferably outside the UiThread.
   TextClassification classification = textClassifier.classifyText(allText 10 25);

   // Called on the UiThread.
   Button button = new Button(context);
   button.setCompoundDrawablesWithIntrinsicBounds(classification.getIcon() null null null);
   button.setText(classification.getLabel());
   button.setOnClickListener(v -> classification.getActions().get(0).getActionIntent().send());
  e.g. starting an action mode with menu items that can handle the classified text:

  // Called preferably outside the UiThread.
   final TextClassification classification = textClassifier.classifyText(allText 10 25);

   // Called on the UiThread.
   view.startActionMode(new ActionMode.Callback() {

       public boolean onCreateActionMode(ActionMode mode Menu menu) {
           for (int i = 0; i < classification.getActions().size(); ++i) {
              RemoteAction action = classification.getActions().get(i);
              menu.add(Menu.NONE i 20 action.getTitle())
                 .setIcon(action.getIcon());
           }
           return true;
       }

       public boolean onActionItemClicked(ActionMode mode MenuItem item) {
           classification.getActions().get(item.getItemId()).getActionIntent().send();
           return true;
       }

       ...
   });"
android,view.textclassifier,TextClassification.Request,9,A request object for generating TextClassification.
android,view.textclassifier,TextClassificationContext,6,A representation of the context in which text classification would be performed.
android,view.textclassifier,TextClassificationContext.Builder,2,A builder for building a TextClassification context.
android,view.textclassifier,TextClassificationSessionId,5,This class represents the id of a text classification session.
android,view.textclassifier,TextClassifier.EntityConfig,8,"Configuration object for specifying what entity types to identify.

 Configs are initially based on a predefined preset and can be modified from there."
android,view.textclassifier,TextClassifierEvent,14,"This class represents events that are sent by components to the  TextClassifier  to report
 something of note that relates to a feature powered by the TextClassifier. The TextClassifier may
 log these events or use them to improve future responses to queries.
  
 Each category of events has its their own subclass. Events of each type have an associated
 set of related properties. You can find their specification in the subclasses."
android,view.textclassifier,TextClassifierEvent.Builder,9,Builder to build a text classifier event.
android,view.textclassifier,TextClassifierEvent.ConversationActionsEvent,0,"This class represents events that are related to the conversation actions feature.
  
     // Conversation (contextual) actions/replies generated.
     new ConversationActionsEvent.Builder(TYPE_ACTIONS_GENERATED)
         .setEventContext(classificationContext)
         .setResultId(conversationActions.getId())
         .setEntityTypes(getTypes(conversationActions))
         .setActionIndices(range(conversationActions.getActions().size()))
         .setEventIndex(0)
         .build();

     // Conversation actions/replies presented to user.
     new ConversationActionsEvent.Builder(TYPE_ACTIONS_SHOWN)
         .setEventContext(classificationContext)
         .setResultId(conversationActions.getId())
         .setEntityTypes(getTypes(conversationActions))
         .setActionIndices(range(conversationActions.getActions().size()))
         .setEventIndex(1)
         .build();

     // User clicked the ""Reply"" button to compose their custom reply.
     new ConversationActionsEvent.Builder(TYPE_MANUAL_REPLY)
         .setEventContext(classificationContext)
         .setResultId(conversationActions.getId())
         .setEventIndex(2)
         .build();

     // User selected a smart (contextual) action/reply.
     new ConversationActionsEvent.Builder(TYPE_SMART_ACTION)
         .setEventContext(classificationContext)
         .setResultId(conversationActions.getId())
         .setEntityTypes(conversationActions.get(1).getType())
         .setScore(conversationAction.get(1).getConfidenceScore())
         .setActionIndices(1)
         .setEventIndex(2)
         .build();"
android,view.textclassifier,TextClassifierEvent.TextLinkifyEvent,0,"This class represents events that are related to the smart linkify feature.
  
     // User clicked on a link.
     new TextLinkifyEvent.Builder(TYPE_LINK_CLICKED)
         .setEventContext(classificationContext)
         .setResultId(textClassification.getId())
         .setEntityTypes(textClassification.getEntity(0))
         .setScore(textClassification.getConfidenceScore(entityType))
         .setEventIndex(0)
         .build();

     // Smart (contextual) actions presented to the user in response to a link click.
     new TextLinkifyEvent.Builder(TYPE_ACTIONS_SHOWN)
         .setEventContext(classificationContext)
         .setResultId(textClassification.getId())
         .setEntityTypes(textClassification.getEntity(0))
         .setScore(textClassification.getConfidenceScore(entityType))
         .setActionIndices(range(textClassification.getActions().size()))
         .setEventIndex(1)
         .build();

     // User chooses smart action at index 0.
     new TextLinkifyEvent.Builder(TYPE_SMART_ACTION)
         .setEventContext(classificationContext)
         .setResultId(textClassification.getId())
         .setEntityTypes(textClassification.getEntity(0))
         .setScore(textClassification.getConfidenceScore(entityType))
         .setActionIndices(0)
         .setEventIndex(2)
         .build();"
android,view.textclassifier,TextClassifierEvent.TextLinkifyEvent.Builder,1,Builder class for  TextLinkifyEvent .
android,view.textclassifier,TextClassifierEvent.TextSelectionEvent,5,"This class represents events that are related to the smart text selection feature.
  
     // User started a selection. e.g. ""York"" in text ""New York City NY"".
     new TextSelectionEvent.Builder(TYPE_SELECTION_STARTED)
         .setEventContext(classificationContext)
         .setEventIndex(0)
         .build();

     // System smart-selects a recognized entity. e.g. ""New York City"".
     new TextSelectionEvent.Builder(TYPE_SMART_SELECTION_MULTI)
         .setEventContext(classificationContext)
         .setResultId(textSelection.getId())
         .setRelativeWordStartIndex(-1) // Goes back one word to ""New"" from ""York"".
         .setRelativeWordEndIndex(2)    // Goes forward 2 words from ""York"" to start of """".
         .setEntityTypes(textClassification.getEntity(0))
         .setScore(textClassification.getConfidenceScore(entityType))
         .setEventIndex(1)
         .build();

     // User resets the selection to the original selection. i.e. ""York"".
     new TextSelectionEvent.Builder(TYPE_SELECTION_RESET)
         .setEventContext(classificationContext)
         .setResultId(textSelection.getId())
         .setRelativeSuggestedWordStartIndex(-1) // Repeated from above.
         .setRelativeSuggestedWordEndIndex(2)    // Repeated from above.
         .setRelativeWordStartIndex(0)           // Original selection is always at (0 1].
         .setRelativeWordEndIndex(1)
         .setEntityTypes(textClassification.getEntity(0))
         .setScore(textClassification.getConfidenceScore(entityType))
         .setEventIndex(2)
         .build();

     // User modified the selection. e.g. ""New"".
     new TextSelectionEvent.Builder(TYPE_SELECTION_MODIFIED)
         .setEventContext(classificationContext)
         .setResultId(textSelection.getId())
         .setRelativeSuggestedWordStartIndex(-1) // Repeated from above.
         .setRelativeSuggestedWordEndIndex(2)    // Repeated from above.
         .setRelativeWordStartIndex(-1)          // Goes backward one word from ""York"" to
         ""New"".
         .setRelativeWordEndIndex(0)             // Goes backward one word to exclude ""York"".
         .setEntityTypes(textClassification.getEntity(0))
         .setScore(textClassification.getConfidenceScore(entityType))
         .setEventIndex(3)
         .build();

     // Smart (contextual) actions (at indices 0 1 2) presented to the user.
     // e.g. ""Map"" ""Ride share"" ""Explore"".
     new TextSelectionEvent.Builder(TYPE_ACTIONS_SHOWN)
         .setEventContext(classificationContext)
         .setResultId(textClassification.getId())
         .setEntityTypes(textClassification.getEntity(0))
         .setScore(textClassification.getConfidenceScore(entityType))
         .setActionIndices(0 1 2)
         .setEventIndex(4)
         .build();

     // User chooses the ""Copy"" action.
     new TextSelectionEvent.Builder(TYPE_COPY_ACTION)
         .setEventContext(classificationContext)
         .setResultId(textClassification.getId())
         .setEntityTypes(textClassification.getEntity(0))
         .setScore(textClassification.getConfidenceScore(entityType))
         .setEventIndex(5)
         .build();

     // User chooses smart action at index 1. i.e. ""Ride share"".
     new TextSelectionEvent.Builder(TYPE_SMART_ACTION)
         .setEventContext(classificationContext)
         .setResultId(textClassification.getId())
         .setEntityTypes(textClassification.getEntity(0))
         .setScore(textClassification.getConfidenceScore(entityType))
         .setActionIndices(1)
         .setEventIndex(5)
         .build();

     // Selection dismissed.
     new TextSelectionEvent.Builder(TYPE_SELECTION_DESTROYED)
         .setEventContext(classificationContext)
         .setResultId(textClassification.getId())
         .setEntityTypes(textClassification.getEntity(0))
         .setScore(textClassification.getConfidenceScore(entityType))
         .setEventIndex(6)
         .build();"
android,view.textclassifier,TextClassifierEvent.TextSelectionEvent.Builder,5,Builder class for  TextSelectionEvent .
android,view.textclassifier,TextLanguage,8,"Represents the result of language detection of a piece of text.
  
 This contains a list of locales each paired with a confidence score sorted in decreasing
 order of those scores. E.g. for a given input text the model may return
  [<""en"" 0.85> <""fr"" 0.15>] . This sample result means the model reports that it is
 85% likely that the entire text is in English and 15% likely that the entire text is in French
 etc. It does not mean that 85% of the input is in English and 15% is in French."
android,view.textclassifier,TextLanguage.Builder,4,Builder used to build TextLanguage objects.
android,view.textclassifier,TextLanguage.Request,5,A request object for detecting the language of a piece of text.
android,view.textclassifier,TextLinks,6,"A collection of links representing subsequences of text and the entity types (phone number
 address url etc) they may be."
android,view.textclassifier,TextLinks.Request,7,A request object for generating TextLinks.
android,view.textclassifier,TextLinks.TextLinkSpan,2,"A ClickableSpan for a TextLink.

  Applies only to TextViews."
android,view.textclassifier,TextSelection,10,Information about where text selection should be.
android,view.textclassifier,TextSelection.Builder,4,Builder used to build  TextSelection  objects.
android,view.textclassifier,TextSelection.Request.Builder,3,A builder for building TextSelection requests.
android,view.textclassifier,TextClassification.Builder,10,"Builder for building  TextClassification  objects.

  e.g.

  TextClassification classification = new TextClassification.Builder()
          .setText(classifiedText)
          .setEntityType(TextClassifier.TYPE_EMAIL 0.9)
          .setEntityType(TextClassifier.TYPE_OTHER 0.1)
          .addAction(remoteAction1)
          .addAction(remoteAction2)
          .build();"
android,view.textclassifier,TextClassificationManager,5,Interface to the text classification service.
android,view.textclassifier,TextClassifier.EntityConfig.Builder,5,Builder class to construct the  EntityConfig  object.
android,view.textclassifier,TextClassifierEvent.ConversationActionsEvent.Builder,1,Builder class for  ConversationActionsEvent .
android,view.textclassifier,TextClassifierEvent.LanguageDetectionEvent,0,"This class represents events that are related to the language detection feature.
  
     // Translate action shown for foreign text.
     new LanguageDetectionEvent.Builder(TYPE_ACTIONS_SHOWN)
         .setEventContext(classificationContext)
         .setResultId(textClassification.getId())
         .setEntityTypes(language)
         .setScore(score)
         .setActionIndices(textClassification.getActions().indexOf(translateAction))
         .setEventIndex(0)
         .build();

     // Translate action selected.
     new LanguageDetectionEvent.Builder(TYPE_SMART_ACTION)
         .setEventContext(classificationContext)
         .setResultId(textClassification.getId())
         .setEntityTypes(language)
         .setScore(score)
         .setActionIndices(textClassification.getActions().indexOf(translateAction))
         .setEventIndex(1)
         .build();"
android,view.textclassifier,ConversationAction.Builder,5,Builder class to construct  ConversationAction .
android,view.textclassifier,TextClassification.Request.Builder,4,A builder for building TextClassification requests.
android,view.textclassifier,TextClassifierEvent.LanguageDetectionEvent.Builder,1,Builder class for  LanguageDetectionEvent .
android,view.textclassifier,TextLanguage.Request.Builder,2,A builder for building TextLanguage requests.
android,view.textclassifier,TextLinks.Builder,5,A builder to construct a TextLinks instance.
android,view.textclassifier,TextLinks.Request.Builder,4,A builder for building TextLinks requests.
android,view.textclassifier,TextLinks.TextLink,9,A link identifying a substring of text and possible entity types for it.
android,view.textclassifier,TextSelection.Request,8,A request object for generating TextSelection.
android,java.awt.font,NumericShaper,15,"The  NumericShaper  class is used to convert Latin-1 (European)
 digits to other Unicode decimal digits.  Users of this class will
 primarily be people who wish to present data using
 national digit shapes but find it more convenient to represent the
 data internally using Latin-1 (European) digits.  This does not
 interpret the deprecated numeric shape selector character (U+206E).
  
 Instances of  NumericShaper  are typically applied
 as attributes to text with the
  TextAttribute#NUMERIC_SHAPING  attribute
 of the  TextAttribute  class.
 For example this code snippet causes a  TextLayout  to
 shape European digits to Arabic in an Arabic context: 
 Map map = new HashMap();
 map.put(TextAttribute.NUMERIC_SHAPING
     NumericShaper.getContextualShaper(NumericShaper.ARABIC));
 FontRenderContext frc = ...;
 TextLayout layout = new TextLayout(text map frc);
 layout.draw(g2d x y);
  NumericShaper 
 char[] text = ...;
 // shape all EUROPEAN digits (except zero) to ARABIC digits
 NumericShaper shaper = NumericShaper.getShaper(NumericShaper.ARABIC);
 shaper.shape(text start count);

 // shape European digits to ARABIC digits if preceding text is Arabic or
 // shape European digits to TAMIL digits if preceding text is Tamil or
 // leave European digits alone if there is no preceding text or
 // preceding text is neither Arabic nor Tamil
 NumericShaper shaper =
     NumericShaper.getContextualShaper(NumericShaper.ARABIC |
                                         NumericShaper.TAMIL
                                       NumericShaper.EUROPEAN);
 shaper.shape(text start count);
  Bit mask- and enum-based Unicode ranges This class supports two different programming interfaces to
 represent Unicode ranges for script-specific digits: bit
 mask-based ones such as  NumericShaper.ARABIC  and
 enum-based ones such as  NumericShaper.Range#ARABIC .
 Multiple ranges can be specified by ORing bit mask-based constants
 such as:
  
 NumericShaper.ARABIC | NumericShaper.TAMIL
  Set NumericShaper.Range 
 EnumSet.of(NumericShaper.Scirpt.ARABIC NumericShaper.Range.TAMIL)
  If the two interfaces are mixed (including serialization)
 Unicode range values are mapped to their counterparts where such
 mapping is possible such as  NumericShaper.Range.ARABIC 
 from/to  NumericShaper.ARABIC .  If any unmappable range
 values are specified such as  NumericShaper.Range.BALINESE 
 those ranges are ignored.

  Decimal Digits Precedence A Unicode range may have more than one set of decimal digits. If
 multiple decimal digits sets are specified for the same Unicode
 range one of the sets will take precedence as follows.

  Unicode Range NumericShaper  Constants Precedence Arabic NumericShaper#ARABIC NumericShaper#EASTERN_ARABIC NumericShaper#EASTERN_ARABIC NumericShaper.Range#ARABIC NumericShaper.Range#EASTERN_ARABIC NumericShaper.Range#EASTERN_ARABIC Tai Tham NumericShaper.Range#TAI_THAM_HORA NumericShaper.Range#TAI_THAM_THAM NumericShaper.Range#TAI_THAM_THAM"
android,java.awt.font,TextAttribute,0,"The  TextAttribute  class defines attribute keys and
 attribute values used for text rendering.
  TextAttribute  instances are used as attribute keys to
 identify attributes in classes handling text attributes. Other
 constants defined in this class can be used as attribute values.
  
 For each text attribute the documentation provides:
  the type of its value
    the relevant predefined constants if any
    the default effect if the attribute is absent
    the valid values if there are limitations
    a description of the effect.
  Values The values of attributes must always be immutable.
    Where value limitations are given any value outside of that
   set is reserved for future use; the value will be treated as
   the default.
    The value  null  is treated the same as the
   default value and results in the default behavior.
    If the value is not of the proper type the attribute
   will be ignored.
    The identity of the value does not matter only the actual
   value.  For example  TextAttribute.WEIGHT_BOLD  and
    new Float(2.0) 
   indicate the same  WEIGHT .
    Attribute values of type  Number  (used for
    WEIGHT   WIDTH   POSTURE 
    SIZE   JUSTIFICATION  and
    TRACKING ) can vary along their natural range and are
   not restricted to the predefined constants.
    Number.floatValue()  is used to get the actual value
   from the  Number .
    The values for  WEIGHT   WIDTH  and
    POSTURE  are interpolated by the system which
   can select the 'nearest available' font or use other techniques to
   approximate the user's request."
android,dalvik.system,BaseDexClassLoader,6,"Base class for common functionality between various dex-based
  ClassLoader  implementations."
android,dalvik.system,DelegateLastClassLoader,3,"A  ClassLoader  implementation that implements a  delegate last  lookup policy.
 For every class or resource this loader is requested to load the following lookup order
 is employed:

  The boot classpath is always searched first Then the list of  dex  files associated with this classloaders's
      dexPath  is searched. Finally this classloader will delegate to the specified  parent ."
android,dalvik.system,DexClassLoader,0,"A class loader that loads classes from  .jar  and  .apk  files
 containing a  classes.dex  entry. This can be used to execute code not
 installed as part of an application.

  Prior to API level 26 this class loader requires an
 application-private writable directory to cache optimized classes.
 Use  Context.getCodeCacheDir()  to create such a directory:
  File dexOutputDir = context.getCodeCacheDir();
  Do not cache optimized classes on external storage. 
 External storage does not provide access controls necessary to protect your
 application from code injection attacks."
android,dalvik.system,DexFile,8,"Loads DEX files. This class is meant for internal use and should not be used
 by applications."
android,dalvik.system,InMemoryDexClassLoader,0,"A  ClassLoader  implementation that loads classes from a
 buffer containing a DEX file. This can be used to execute code that
 has not been written to the local file system."
android,dalvik.system,PathClassLoader,0,"Provides a simple  ClassLoader  implementation that operates on a list
 of files and directories in the local file system but does not attempt to
 load classes from the network. Android uses this class for its system class
 loader and for its application class loader(s)."
android,view,AbsSavedState,3,"A  Parcelable  implementation that should be used by inheritance
 hierarchies to ensure the state of all classes along the chain is saved."
android,view,ActionMode,22,"Represents a contextual mode of the user interface. Action modes can be used to provide
 alternative interaction modes and replace parts of the normal UI until finished.
 Examples of good action modes include text selection and contextual actions."
android,view,ActionMode.Callback2,1,"Extension of  ActionMode.Callback  to provide content rect information. This is
 required for ActionModes with dynamic positioning such as the ones with type
  ActionMode#TYPE_FLOATING  to ensure the positioning doesn't obscure app content. If
 an app fails to provide a subclass of this class a default implementation will be used."
android,view,ActionProvider,9,"An ActionProvider defines rich menu interaction in a single component.
 ActionProvider can generate action views for use in the action bar
 dynamically populate submenus of a MenuItem and handle default menu
 item invocations.

  An ActionProvider can be optionally specified for a  MenuItem  and will be
 responsible for creating the action view that appears in the  ActionBar 
 in place of a simple button in the bar. When the menu item is presented in a way that
 does not allow custom action views (e.g. in an overflow menu) the ActionProvider
 can perform a default action. There are two ways to use an action provider:
  
 Set the action provider on a  MenuItem  directly by calling
  MenuItem#setActionProvider(ActionProvider) .
  
 Declare the action provider in an XML menu resource. For example:
  
   <item android:id=""@+id/my_menu_item""
     android:title=""Title""
     android:icon=""@drawable/my_menu_item_icon""
     android:showAsAction=""ifRoom""
     android:actionProviderClass=""foo.bar.SomeActionProvider"" />"
android,view,Choreographer,4,"Coordinates the timing of animations input and drawing.
  
 The choreographer receives timing pulses (such as vertical synchronization)
 from the display subsystem then schedules work to occur as part of rendering
 the next display frame.
  
 Applications typically interact with the choreographer indirectly using
 higher level abstractions in the animation framework or the view hierarchy.
 Here are some examples of things you can do using the higher-level APIs.
  To post an animation to be processed on a regular time basis synchronized with
 display frame rendering use  ValueAnimator.start() . To post a  Runnable  to be invoked once at the beginning of the next display
 frame use  View#postOnAnimation . To post a  Runnable  to be invoked once at the beginning of the next display
 frame after a delay use  View#postOnAnimationDelayed . To post a call to  View#invalidate()  to occur once at the beginning of the
 next display frame use  View#postInvalidateOnAnimation()  or
  View#postInvalidateOnAnimation(int int int int) . To ensure that the contents of a  View  scroll smoothly and are drawn in
 sync with display frame rendering do nothing.  This already happens automatically.
  View#onDraw  will be called at the appropriate time. 
 However there are a few cases where you might want to use the functions of the
 choreographer directly in your application.  Here are some examples.
  If your application does its rendering in a different thread possibly using GL
 or does not use the animation framework or view hierarchy at all
 and you want to ensure that it is appropriately synchronized with the display then use
  Choreographer#postFrameCallback . ... and that's about it. 
 Each  Looper  thread has its own choreographer.  Other threads can
 post callbacks to run on the choreographer but they will run on the  Looper 
 to which the choreographer belongs."
android,view,ContextThemeWrapper,9,"A context wrapper that allows you to modify or replace the theme of the
 wrapped context."
android,view,Display.HdrCapabilities,8,"Encapsulates the HDR capabilities of a given display.
 For example what HDR types it supports and details about the desired luminance data.
  You can get an instance for a given  Display  object with
  Display#getHdrCapabilities ."
android,view,Display.Mode,9,A mode supported by a given display.
android,view,DisplayCutout,12,"Represents the area of the display that is not functional for displaying content.

  DisplayCutout  is immutable."
android,view,DragAndDropPermissions,3,"DragAndDropPermissions  controls the access permissions for the content URIs associated
 with a  DragEvent .
  
 Permission are granted when this object is created by  Activity.requestDragAndDropPermissions .
 Which permissions are granted is defined by the set of flags passed to  View#startDragAndDrop(android.content.ClipData View.DragShadowBuilder Object int)  by the app that started the drag operation.
  
 The lifecycle of the permissions is bound to the activity used to call  requestDragAndDropPermissions . The
 permissions are revoked when this activity is destroyed or when  release()  is called
 whichever occurs first.
  
 If you anticipate that your application will receive a large number of drops (e.g. document
 editor) you should try to call  release()  on the obtained permissions as soon as they
 are no longer required. Permissions can be added to your activity's
  Activity#onSaveInstanceState  bundle and later retrieved in order to manually release
 the permissions once they are no longer needed.
  
 Learn more about  drag permissions
 in multi-window mode ."
android,view,DragEvent,10,"Represents an event that is sent out by the system at various times during a drag and drop
 operation. It is a data structure that contains several important pieces of data about
 the operation and the underlying data.
  
  View objects that receive a DragEvent call  getAction()  which returns
  an action type that indicates the state of the drag and drop operation. This allows a View
  object to react to a change in state by changing its appearance or performing other actions.
  For example a View can react to the  ACTION_DRAG_ENTERED  action type by
  by changing one or more colors in its displayed image.
  
  During a drag and drop operation the system displays an image that the user drags. This image
  is called a drag shadow. Several action types reflect the position of the drag shadow relative
  to the View receiving the event.
  
  Most methods return valid data only for certain event actions. This is summarized in the
  following table. Each possible  getAction()  value is listed in the first column. The
  other columns indicate which method or methods return valid data for that getAction() value:
  getAction() Value getClipDescription() getLocalState() getX() getY() getClipData() getResult() ACTION_DRAG_STARTED X X X X ACTION_DRAG_ENTERED X X ACTION_DRAG_LOCATION X X X X ACTION_DRAG_EXITED X X ACTION_DROP X X X X X ACTION_DRAG_ENDED X X 
  The  getAction() 
   getLocalState() describeContents() 
   writeToParcel(Parcel int)  and
   toString()  methods always return valid data."
android,view,FocusFinder,5,"The algorithm used for finding the next focusable view in a given direction
 from a view that currently has focus."
android,view,FrameMetrics,1,"Class containing timing data for various milestones in a frame
 lifecycle reported by the rendering subsystem.
  
 Supported metrics can be queried via their corresponding identifier."
android,view,FrameStats,5,This is the base class for frame statistics.
android,view,GestureDetector,6,"Detects various gestures and events using the supplied  MotionEvent s.
 The  OnGestureListener  callback will notify users when a particular
 motion event has occurred. This class should only be used with  MotionEvent s
 reported via touch (don't use for trackball events).

 To use this class:
  Create an instance of the  GestureDetector  for your  View In the  View#onTouchEvent(MotionEvent)  method ensure you call
           onTouchEvent(android.view.MotionEvent) . The methods defined in your callback
          will be executed when the events occur.
   If listening for  OnContextClickListener#onContextClick(MotionEvent) 
          you must call  onGenericMotionEvent(android.view.MotionEvent) 
          in  View#onGenericMotionEvent(MotionEvent) ."
android,view,HapticFeedbackConstants,0,"Constants to be used to perform haptic feedback effects via
  View#performHapticFeedback(int)"
android,view,InputDevice,24,"Describes the capabilities of a particular input device.
  
 Each input device may support multiple classes of input.  For example a multi-function
 keyboard may compose the capabilities of a standard keyboard together with a track pad mouse
 or other pointing device.
  
 Some input devices present multiple distinguishable sources of input.
 Applications can query the framework about the characteristics of each distinct source.
  
 As a further wrinkle different kinds of input sources uses different coordinate systems
 to describe motion events.  Refer to the comments on the input source constants for
 the appropriate interpretation."
android,view,InputDevice.MotionRange,9,Provides information about the range of values for a particular  MotionEvent  axis.
android,view,KeyboardShortcutGroup,5,A group of  KeyboardShortcutInfo .
android,view,KeyboardShortcutInfo,6,Information about a Keyboard Shortcut.
android,view,KeyCharacterMap,17,Describes the keys provided by a keyboard device and their associated labels.
android,view,KeyEvent,56,"Object used to report key and button events.
  
 Each key press is described by a sequence of key events.  A key press
 starts with a key event with  ACTION_DOWN .  If the key is held
 sufficiently long that it repeats then the initial down is followed
 additional key events with  ACTION_DOWN  and a non-zero value for
  getRepeatCount() .  The last key event is a  ACTION_UP 
 for the key up.  If the key press is canceled the key up event will have the
  FLAG_CANCELED  flag set.
  
 Key events are generally accompanied by a key code ( getKeyCode() )
 scan code ( getScanCode() ) and meta state ( getMetaState() ).
 Key code constants are defined in this class.  Scan code constants are raw
 device-specific codes obtained from the OS and so are not generally meaningful
 to applications unless interpreted using the  KeyCharacterMap .
 Meta states describe the pressed state of key modifiers
 such as  META_SHIFT_ON  or  META_ALT_ON .
  
 Key codes typically correspond one-to-one with individual keys on an input device.
 Many keys and key combinations serve quite different functions on different
 input devices so care must be taken when interpreting them.  Always use the
  KeyCharacterMap  associated with the input device when mapping keys
 to characters.  Be aware that there may be multiple key input devices active
 at the same time and each will have its own key character map.
  
 As soft input methods can use multiple and inventive ways of inputting text
 there is no guarantee that any key press on a soft keyboard will generate a key
 event: this is left to the IME's discretion and in fact sending such events is
 discouraged.  You should never rely on receiving KeyEvents for any key on a soft
 input method.  In particular the default software keyboard will never send any
 key event to any application targetting Jelly Bean or later and will only send
 events for some presses of the delete and return keys to applications targetting
 Ice Cream Sandwich or earlier.  Be aware that other software input methods may
 never send key events regardless of the version.  Consider using editor actions
 like  EditorInfo.IME_ACTION_DONE  if you need
 specific interaction with the software keyboard as it gives more visibility to
 the user as to how your application will react to key presses.
  
 When interacting with an IME the framework may deliver key events
 with the special action  ACTION_MULTIPLE  that either specifies
 that single repeated key code or a sequence of characters to insert.
  
 In general the framework cannot guarantee that the key events it delivers
 to a view always constitute complete key sequences since some events may be dropped
 or modified by containing views before they are delivered.  The view implementation
 should be prepared to handle  FLAG_CANCELED  and should tolerate anomalous
 situations such as receiving a new  ACTION_DOWN  without first having
 received an  ACTION_UP  for the prior key press.
  
 Refer to  InputDevice  for more information about how different kinds of
 input devices and sources represent keys and buttons."
android,view,KeyEvent.DispatcherState,6,"Use with  KeyEvent#dispatch(Callback DispatcherState Object) 
 for more advanced key dispatching such as long presses."
android,view,LayoutInflater,18,"Instantiates a layout XML file into its corresponding  View 
 objects. It is never used directly. Instead use
  Activity.getLayoutInflater()  or
  Context#getSystemService  to retrieve a standard LayoutInflater instance
 that is already hooked up to the current context and correctly configured
 for the device you are running on.

  
 To create a new LayoutInflater with an additional  Factory  for your
 own views you can use  cloneInContext(Context)  to clone an existing
 ViewFactory and then call  setFactory(LayoutInflater.Factory)  on it to include your
 Factory.

  
 For performance reasons view inflation relies heavily on pre-processing of
 XML files that is done at build time. Therefore it is not currently possible
 to use LayoutInflater with an XmlPullParser over a plain XML file at runtime;
 it only works with an XmlPullParser returned from a compiled resource
 (R. something  file.)"
android,view,MotionEvent.PointerCoords,4,"Transfer object for pointer coordinates.

 Objects of this type can be used to specify the pointer coordinates when
 creating new  MotionEvent  objects and to query pointer coordinates
 in bulk.

 Refer to  InputDevice  for information about how different kinds of
 input devices and sources represent pointer coordinates."
android,view,OrientationEventListener,4,"Helper class for receiving notifications from the SensorManager when
 the orientation of the device has changed."
android,view,OrientationListener,5,"Helper class for receiving notifications from the SensorManager when
 the orientation of the device has changed."
android,view,PointerIcon,6,"Represents an icon that can be used as a mouse pointer.
  
 Pointer icons can be provided either by the system using system types
 or by applications using bitmaps or application resources."
android,view,ScaleGestureDetector,17,"Detects scaling transformation gestures using the supplied  MotionEvent s.
 The  OnScaleGestureListener  callback will notify users when a particular
 gesture event has occurred.

 This class should only be used with  MotionEvent s reported via touch.

 To use this class:
  Create an instance of the  ScaleGestureDetector  for your
       View In the  View#onTouchEvent(MotionEvent)  method ensure you call
           onTouchEvent(android.view.MotionEvent) . The methods defined in your
          callback will be executed when the events occur."
android,view,ScaleGestureDetector.SimpleOnScaleGestureListener,3,"A convenience class to extend when you only want to listen for a subset
 of scaling-related events. This implements all methods in
  OnScaleGestureListener  but does nothing.
  OnScaleGestureListener#onScale(ScaleGestureDetector)  returns
  false  so that a subclass can retrieve the accumulated scale
 factor in an overridden onScaleEnd.
  OnScaleGestureListener#onScaleBegin(ScaleGestureDetector)  returns
  true ."
android,view,SearchEvent,1,Class that contains information about an event that triggers a search.
android,view,SoundEffectConstants,1,Constants to be used to play sound effects via  View#playSoundEffect(int)
android,view,SurfaceControl,6,"Handle to an on-screen Surface managed by the system compositor. The SurfaceControl is
 a combination of a buffer source and metadata about how to display the buffers.
 By constructing a  Surface  from this SurfaceControl you can submit buffers to be
 composited. Using  SurfaceControl.Transaction  you can manipulate various
 properties of how the buffer will be displayed on-screen. SurfaceControl's are
 arranged into a scene-graph like hierarchy and as such any SurfaceControl may have
 a parent. Geometric properties like transform crop and Z-ordering will be inherited
 from the parent as if the child were content in the parents buffer stream."
android,view,SurfaceView,13,"Provides a dedicated drawing surface embedded inside of a view hierarchy.
 You can control the format of this surface and if you like its size; the
 SurfaceView takes care of placing the surface at the correct location on the
 screen

  The surface is Z ordered so that it is behind the window holding its
 SurfaceView; the SurfaceView punches a hole in its window to allow its
 surface to be displayed. The view hierarchy will take care of correctly
 compositing with the Surface any siblings of the SurfaceView that would
 normally appear on top of it. This can be used to place overlays such as
 buttons on top of the Surface though note however that it can have an
 impact on performance since a full alpha-blended composite will be performed
 each time the Surface changes.

   The transparent region that makes the surface visible is based on the
 layout positions in the view hierarchy. If the post-layout transform
 properties are used to draw a sibling view on top of the SurfaceView the
 view may not be properly composited with the surface.

  Access to the underlying surface is provided via the SurfaceHolder interface
 which can be retrieved by calling  getHolder() .

  The Surface will be created for you while the SurfaceView's window is
 visible; you should implement  SurfaceHolder.Callback#surfaceCreated 
 and  SurfaceHolder.Callback#surfaceDestroyed  to discover when the
 Surface is created and destroyed as the window is shown and hidden.

  One of the purposes of this class is to provide a surface in which a
 secondary thread can render into the screen. If you are going to use it
 this way you need to be aware of some threading semantics:

   All SurfaceView and
  SurfaceHolder.Callback  methods will be called
 from the thread running the SurfaceView's window (typically the main thread
 of the application). They thus need to correctly synchronize with any
 state that is also touched by the drawing thread.
   You must ensure that the drawing thread only touches the underlying
 Surface while it is valid -- between
  SurfaceHolder.Callback#surfaceCreated 
 and
  SurfaceHolder.Callback#surfaceDestroyed .
  Note:  Starting in platform version
  Build.VERSION_CODES.N  SurfaceView's window position is
 updated synchronously with other View rendering. This means that translating
 and scaling a SurfaceView on screen will not cause rendering artifacts. Such
 artifacts may occur on previous versions of the platform when its window is
 positioned asynchronously."
android,view,TouchDelegate,3,"Helper class to handle situations where you want a view to have a larger touch area than its
 actual view bounds. The view whose touch area is changed is called the delegate view. This
 class should be used by an ancestor of the delegate. To use a TouchDelegate first create an
 instance that specifies the bounds that should be mapped to the delegate and the delegate
 view itself.
  
 The ancestor should then forward all of its touch events received in its
  View.onTouchEvent(MotionEvent)  to  onTouchEvent(android.view.MotionEvent) ."
android,view,View,612,"This class represents the basic building block for user interface components. A View
 occupies a rectangular area on the screen and is responsible for drawing and
 event handling. View is the base class for  widgets  which are
 used to create interactive UI components (buttons text fields etc.). The
  ViewGroup  subclass is the base class for  layouts  which
 are invisible containers that hold other Views (or other ViewGroups) and define
 their layout properties."
android,view,View.AccessibilityDelegate,10,"This class represents a delegate that can be registered in a  View 
 to enhance accessibility support via composition rather via inheritance.
 It is specifically targeted to widget developers that extend basic View
 classes i.e. classes in package android.view that would like their
 applications to be backwards compatible."
android,view,View.MeasureSpec,4,"A MeasureSpec encapsulates the layout requirements passed from parent to child.
 Each MeasureSpec represents a requirement for either the width or the height.
 A MeasureSpec is comprised of a size and a mode. There are three possible
 modes:
  UNSPECIFIED 
 The parent has not imposed any constraint on the child. It can be whatever size
 it wants.
  EXACTLY 
 The parent has determined an exact size for the child. The child is going to be
 given those bounds regardless of how big it wants to be.
  AT_MOST 
 The child can be as large as it wants up to the specified size."
android,view,ViewAnimationUtils,1,Defines common utilities for working with View's animations.
android,view,ViewConfiguration,41,Contains methods to standard constants used in the UI for timeouts sizes and distances.
android,view,ViewDebug,7,Various debugging/tracing tools related to  View  and the view hierarchy.
android,view,ViewGroup,175,"A  ViewGroup  is a special view that can contain other views
 (called children.) The view group is the base class for layouts and views
 containers. This class also defines the
  ViewGroup.LayoutParams  class which serves as the base
 class for layouts parameters.
  
 Also see  LayoutParams  for layout attributes."
android,view,ViewGroup.MarginLayoutParams,9,"Per-child layout information for layouts that support margins.
 See
  ViewGroup Margin Layout Attributes 
 for a list of all child view attributes that this class supports."
android,view,ViewOutlineProvider,1,Interface by which a View builds its  Outline  used for shadow casting and clipping.
android,view,ViewPropertyAnimator,37,"This class enables automatic and optimized animation of select properties on View objects.
 If only one or two properties on a View object are being animated then using an
  ObjectAnimator  is fine; the property setters called by ObjectAnimator
 are well equipped to do the right thing to set the property and invalidate the view
 appropriately. But if several properties are animated simultaneously or if you just want a
 more convenient syntax to animate a specific property then ViewPropertyAnimator might be
 more well-suited to the task.

  This class may provide better performance for several simultaneous animations because
 it will optimize invalidate calls to take place only once for several properties instead of each
 animated property independently causing its own invalidation. Also the syntax of using this
 class could be easier to use because the caller need only tell the View object which
 property to animate and the value to animate either to or by and this class handles the
 details of configuring the underlying Animator class and starting it. This class is not constructed by the caller but rather by the View whose properties
 it will animate. Calls to  View.animate()  will return a reference
 to the appropriate ViewPropertyAnimator object for that View."
android,view,ViewStructure,55,"ViewStructure  is a container for storing additional
 per-view data generated by  View#onProvideStructure  and  View#onProvideAutofillStructure .

  To learn more about using Autofill in your app read the
  Autofill Framework  guides."
android,view,ViewStructure.HtmlInfo.Builder,2,Builder for  HtmlInfo  objects.
android,view,ViewTreeObserver,25,"A view tree observer is used to register listeners that can be notified of global
 changes in the view tree. Such global events include but are not limited to
 layout of the whole tree beginning of the drawing pass touch mode change....

 A ViewTreeObserver should never be instantiated by applications as it is provided
 by the views hierarchy. Refer to  View.getViewTreeObserver() 
 for more information."
android,view,Window,135,"Abstract base class for a top-level window look and behavior policy.  An
 instance of this class should be used as the top-level view added to the
 window manager. It provides standard UI policies such as a background title
 area default key processing etc.

  The only existing implementation of this abstract class is
 android.view.PhoneWindow which you should instantiate when needing a
 Window."
android,view,WindowAnimationFrameStats,3,"This class contains window animation frame statistics. For example a window
 animation is usually performed when the application is transitioning from one
 activity to another. The frame statistics are a snapshot for the time interval
 from  FrameStats.getStartTimeNano()  to  FrameStats.getEndTimeNano() .
  
 The key idea is that in order to provide a smooth user experience the system should
 run window animations at a specific time interval obtained by calling  FrameStats.getRefreshPeriodNano() . If the system does not render a frame every refresh
 period the user will see irregular window transitions. The time when the frame was
 actually presented on the display by calling  FrameStats.getFramePresentedTimeNano(int) ."
android,view,WindowContentFrameStats,5,"This class contains window content frame statistics. For example a window content
 is rendred in frames when a view is scrolled. The frame statistics are a snapshot
 for the time interval from  FrameStats.getStartTimeNano()  to  FrameStats.getEndTimeNano() .
  
 The key idea is that in order to provide a smooth user experience an application
 has to draw a frame at a specific time interval obtained by calling  FrameStats.getRefreshPeriodNano() . If the application does not render a frame every refresh
 period the user will see irregular UI transitions.
  
 An application posts a frame for presentation by synchronously rendering its contents
 in a buffer which is then posted or posting a buffer to which the application is
 asychronously rendering the content via GL. After the frame is posted and rendered
 (potentially asynchronosly) it is presented to the user. The time a frame was posted
 can be obtained via  getFramePostedTimeNano(int)  the time a frame content
 was rendered and ready for dsiplay (GL case) via  getFrameReadyTimeNano(int) 
 and the time a frame was presented on the screen via  FrameStats.getFramePresentedTimeNano(int) ."
android,view,WindowId.FocusObserver,2,"Subclass for observing changes to the focus state of an  WindowId .
 You should use the same instance of this class for observing multiple
  WindowId  objects since this class is fairly heavy-weight -- the
 base class includes all of the mechanisms for connecting to and receiving updates
 from the window."
android,view,WindowInsets.Builder,7,Builder for WindowInsets.
android,view,WindowManager.LayoutParams,10,
android,view,GestureDetector.SimpleOnGestureListener,10,"A convenience class to extend when you only want to listen for a subset
 of all the gestures. This implements all methods in the
  OnGestureListener   OnDoubleTapListener  and  OnContextClickListener 
 but does nothing and return  false  for all applicable methods."
android,view,Gravity,9,"Standard constants and tools for placing an object within a potentially
 larger container."
android,view,InputEvent,6,Common base class for input events.
android,view,InputQueue,0,"An input queue provides a mechanism for an application to receive incoming
 input events.  Currently only usable from native code."
android,view,KeyCharacterMap.KeyData,0,Describes the character mappings associated with a key.
android,view,MenuInflater,1,"This class is used to instantiate menu XML files into Menu objects.
  
 For performance reasons menu inflation relies heavily on pre-processing of
 XML files that is done at build time. Therefore it is not currently possible
 to use MenuInflater with an XmlPullParser over a plain XML file at runtime;
 it only works with an XmlPullParser returned from a compiled resource (R.
  something  file.)"
android,view,MotionEvent,91,"Object used to report movement (mouse pen finger trackball) events.
 Motion events may hold either absolute or relative movements and other data
 depending on the type of device.

  Overview 
 Motion events describe movements in terms of an action code and a set of axis values.
 The action code specifies the state change that occurred such as a pointer going
 down or up.  The axis values describe the position and other movement properties.
  
 For example when the user first touches the screen the system delivers a touch
 event to the appropriate  View  with the action code  ACTION_DOWN 
 and a set of axis values that include the X and Y coordinates of the touch and
 information about the pressure size and orientation of the contact area.
  
 Some devices can report multiple movement traces at the same time.  Multi-touch
 screens emit one movement trace for each finger.  The individual fingers or
 other objects that generate movement traces are referred to as  pointers .
 Motion events contain information about all of the pointers that are currently active
 even if some of them have not moved since the last event was delivered.
  
 The number of pointers only ever changes by one as individual pointers go up and down
 except when the gesture is canceled.
  
 Each pointer has a unique id that is assigned when it first goes down
 (indicated by  ACTION_DOWN  or  ACTION_POINTER_DOWN ).  A pointer id
 remains valid until the pointer eventually goes up (indicated by  ACTION_UP 
 or  ACTION_POINTER_UP ) or when the gesture is canceled (indicated by
  ACTION_CANCEL ).
  
 The MotionEvent class provides many methods to query the position and other properties of
 pointers such as  getX(int)   getY(int)   getAxisValue(int) 
  getPointerId(int)   getToolType(int)  and many others.  Most of these
 methods accept the pointer index as a parameter rather than the pointer id.
 The pointer index of each pointer in the event ranges from 0 to one less than the value
 returned by  getPointerCount() .
  
 The order in which individual pointers appear within a motion event is undefined.
 Thus the pointer index of a pointer can change from one event to the next but
 the pointer id of a pointer is guaranteed to remain constant as long as the pointer
 remains active.  Use the  getPointerId(int)  method to obtain the
 pointer id of a pointer to track it across all subsequent motion events in a gesture.
 Then for successive motion events use the  findPointerIndex(int)  method
 to obtain the pointer index for a given pointer id in that motion event.
  
 Mouse and stylus buttons can be retrieved using  getButtonState() .  It is a
 good idea to check the button state while handling  ACTION_DOWN  as part
 of a touch event.  The application may choose to perform some different action
 if the touch event starts due to a secondary button click such as presenting a
 context menu.
  Batching 
 For efficiency motion events with  ACTION_MOVE  may batch together
 multiple movement samples within a single object.  The most current
 pointer coordinates are available using  getX(int)  and  getY(int) .
 Earlier coordinates within the batch are accessed using  getHistoricalX(int int) 
 and  getHistoricalY(int int) .  The coordinates are ""historical"" only
 insofar as they are older than the current coordinates in the batch; however
 they are still distinct from any other coordinates reported in prior motion events.
 To process all coordinates in the batch in time order first consume the historical
 coordinates then consume the current coordinates.
  
 Example: Consuming all samples for all pointers in a motion event in time order.
  
 void printSamples(MotionEvent ev) {
     final int historySize = ev.getHistorySize();
     final int pointerCount = ev.getPointerCount();
     for (int h = 0; h < historySize; h++) {
         System.out.printf(""At time %d:"" ev.getHistoricalEventTime(h));
         for (int p = 0; p < pointerCount; p++) {
             System.out.printf(""  pointer %d: (%f%f)""
                 ev.getPointerId(p) ev.getHistoricalX(p h) ev.getHistoricalY(p h));
         }
     }
     System.out.printf(""At time %d:"" ev.getEventTime());
     for (int p = 0; p < pointerCount; p++) {
         System.out.printf(""  pointer %d: (%f%f)""
             ev.getPointerId(p) ev.getX(p) ev.getY(p));
     }
 }
  Device Types 
 The interpretation of the contents of a MotionEvent varies significantly depending
 on the source class of the device.
  
 On pointing devices with source class  InputDevice#SOURCE_CLASS_POINTER 
 such as touch screens the pointer coordinates specify absolute
 positions such as view X/Y coordinates.  Each complete gesture is represented
 by a sequence of motion events with actions that describe pointer state transitions
 and movements.  A gesture starts with a motion event with  ACTION_DOWN 
 that provides the location of the first pointer down.  As each additional
 pointer that goes down or up the framework will generate a motion event with
  ACTION_POINTER_DOWN  or  ACTION_POINTER_UP  accordingly.
 Pointer movements are described by motion events with  ACTION_MOVE .
 Finally a gesture end either when the final pointer goes up as represented
 by a motion event with  ACTION_UP  or when gesture is canceled
 with  ACTION_CANCEL .
  
 Some pointing devices such as mice may support vertical and/or horizontal scrolling.
 A scroll event is reported as a generic motion event with  ACTION_SCROLL  that
 includes the relative scroll offset in the  AXIS_VSCROLL  and
  AXIS_HSCROLL  axes.  See  getAxisValue(int)  for information
 about retrieving these additional axes.
  
 On trackball devices with source class  InputDevice#SOURCE_CLASS_TRACKBALL 
 the pointer coordinates specify relative movements as X/Y deltas.
 A trackball gesture consists of a sequence of movements described by motion
 events with  ACTION_MOVE  interspersed with occasional  ACTION_DOWN 
 or  ACTION_UP  motion events when the trackball button is pressed or released.
  
 On joystick devices with source class  InputDevice#SOURCE_CLASS_JOYSTICK 
 the pointer coordinates specify the absolute position of the joystick axes.
 The joystick axis values are normalized to a range of -1.0 to 1.0 where 0.0 corresponds
 to the center position.  More information about the set of available axes and the
 range of motion can be obtained using  InputDevice#getMotionRange .
 Some common joystick axes are  AXIS_X   AXIS_Y 
  AXIS_HAT_X   AXIS_HAT_Y   AXIS_Z  and  AXIS_RZ .
  
 Refer to  InputDevice  for more information about how different kinds of
 input devices and sources represent pointer coordinates.
  Consistency Guarantees 
 Motion events are always delivered to views as a consistent stream of events.
 What constitutes a consistent stream varies depending on the type of device.
 For touch events consistency implies that pointers go down one at a time
 move around as a group and then go up one at a time or are canceled.
  
 While the framework tries to deliver consistent streams of motion events to
 views it cannot guarantee it.  Some events may be dropped or modified by
 containing views in the application before they are delivered thereby making
 the stream of events inconsistent.  Views should always be prepared to
 handle  ACTION_CANCEL  and should tolerate anomalous
 situations such as receiving a new  ACTION_DOWN  without first having
 received an  ACTION_UP  for the prior gesture."
android,view,Surface,11,"Handle onto a raw buffer that is being managed by the screen compositor.

  A Surface is generally created by or from a consumer of image buffers (such as a
  SurfaceTexture   MediaRecorder  or
  Allocation ) and is handed to some kind of producer (such as
  OpenGL 
  MediaPlayer  or
  CameraDevice ) to draw
 into. Note:  A Surface acts like a
  weak reference  to the consumer it is associated with. By
 itself it will not keep its parent consumer from being reclaimed."
android,view,SurfaceControl.Transaction,9,An atomic set of changes to a set of SurfaceControl.
android,view,Display,28,"Provides information about the size and density of a logical display.
  
 The display area is described in two different ways.
  The application display area specifies the part of the display that may contain
 an application window excluding the system decorations.  The application display area may
 be smaller than the real display area because the system subtracts the space needed
 for decor elements such as the status bar.  Use the following methods to query the
 application display area:  getSize(Point)   getRectSize(Rect)  and  getMetrics(DisplayMetrics) . The real display area specifies the part of the display that contains content
 including the system decorations.  Even so the real display area may be smaller than the
 physical size of the display if the window manager is emulating a smaller display
 using (adb shell wm size).  Use the following methods to query the
 real display area:  getRealSize(Point)   getRealMetrics(DisplayMetrics) . 
 A logical display does not necessarily represent a particular physical display device
 such as the built-in screen or an external monitor.  The contents of a logical
 display may be presented on one or more physical displays according to the devices
 that are currently attached and whether mirroring has been enabled."
android,view,MotionEvent.PointerProperties,4,"Transfer object for pointer properties.

 Objects of this type can be used to specify the pointer id and tool type
 when creating new  MotionEvent  objects and to query pointer properties in bulk."
android,view,PixelCopy,6,"Provides a mechanisms to issue pixel copy requests to allow for copy
 operations from  Surface  to  Bitmap"
android,view,SurfaceControl.Builder,6,"Builder class for  SurfaceControl  objects.

 By default the surface will be hidden and have ""unset"" bounds meaning it can
 be as large as the bounds of its parent if a buffer or child so requires.

 It is necessary to set at least a name via  Builder#setName"
android,view,TextureView,26,"A TextureView can be used to display a content stream. Such a content
 stream can for instance be a video or an OpenGL scene. The content stream
 can come from the application's process as well as a remote process. TextureView can only be used in a hardware accelerated window. When
 rendered in software TextureView will draw nothing. Unlike  SurfaceView  TextureView does not create a separate
 window but behaves as a regular View. This key difference allows a
 TextureView to be moved transformed animated etc. For instance you
 can make a TextureView semi-translucent by calling
  myView.setAlpha(0.5f) . Using a TextureView is simple: all you need to do is get its
  SurfaceTexture . The  SurfaceTexture  can then be used to
 render content. The following example demonstrates how to render the
 camera preview into a TextureView: 
  public class LiveCameraActivity extends Activity implements TextureView.SurfaceTextureListener {
      private Camera mCamera;
      private TextureView mTextureView;

      protected void onCreate(Bundle savedInstanceState) {
          super.onCreate(savedInstanceState);

          mTextureView = new TextureView(this);
          mTextureView.setSurfaceTextureListener(this);

          setContentView(mTextureView);
      }

      public void onSurfaceTextureAvailable(SurfaceTexture surface int width int height) {
          mCamera = Camera.open();

          try {
              mCamera.setPreviewTexture(surface);
              mCamera.startPreview();
          } catch (IOException ioe) {
              // Something bad happened
          }
      }

      public void onSurfaceTextureSizeChanged(SurfaceTexture surface int width int height) {
          // Ignored Camera does all the work for us
      }

      public boolean onSurfaceTextureDestroyed(SurfaceTexture surface) {
          mCamera.stopPreview();
          mCamera.release();
          return true;
      }

      public void onSurfaceTextureUpdated(SurfaceTexture surface) {
          // Invoked every time there's a new Camera preview frame
      }
  }
  A TextureView's SurfaceTexture can be obtained either by invoking
  getSurfaceTexture()  or by using a  SurfaceTextureListener .
 It is important to know that a SurfaceTexture is available only after the
 TextureView is attached to a window (and  onAttachedToWindow()  has
 been invoked.) It is therefore highly recommended you use a listener to
 be notified when the SurfaceTexture becomes available. It is important to note that only one producer can use the TextureView.
 For instance if you use a TextureView to display the camera preview you
 cannot use  lockCanvas()  to draw onto the TextureView at the same
 time."
android,view,VelocityTracker,11,"Helper for tracking the velocity of touch events for implementing
 flinging and other such gestures.

 Use  obtain()  to retrieve a new instance of the class when you are going
 to begin tracking.  Put the motion events you receive into it with
  addMovement(android.view.MotionEvent) .  When you want to determine the velocity call
  computeCurrentVelocity(int)  and then call  getXVelocity(int) 
 and  getYVelocity(int)  to retrieve the velocity for each pointer id."
android,view,View.DragShadowBuilder,3,"Creates an image that the system displays during the drag and drop
 operation. This is called a ""drag shadow"". The default implementation
 for a DragShadowBuilder based on a View returns an image that has exactly the same
 appearance as the given View. The default also positions the center of the drag shadow
 directly under the touch point. If no View is provided (the constructor with no parameters
 is used) and  onProvideShadowMetrics()  and
  onDrawShadow()  are not overridden then the
 default is an invisible drag shadow.
  
 You are not required to use the View you provide to the constructor as the basis of the
 drag shadow. The  onDrawShadow()  method allows you to draw
 anything you want as the drag shadow.
  
  You pass a DragShadowBuilder object to the system when you start the drag. The system
  calls  onProvideShadowMetrics()  to get the
  size and position of the drag shadow. It uses this data to construct a
   Canvas  object then it calls  onDrawShadow() 
  so that your application can draw the shadow image in the Canvas."
android,view,ViewGroupOverlay,2,"A group overlay is an extra layer that sits on top of a ViewGroup
 (the ""host view"") which is drawn after all other content in that view
 (including the view group's children). Interaction with the overlay
 layer is done by adding and removing views and drawables.

  ViewGroupOverlay is a subclass of  ViewOverlay  adding the ability to
 manage views for overlays on ViewGroups in addition to the drawable
 support in ViewOverlay."
android,view,ViewOverlay,3,"An overlay is an extra layer that sits on top of a View (the ""host view"")
 which is drawn after all other content in that view (including children
 if the view is a ViewGroup). Interaction with the overlay layer is done
 by adding and removing drawables.

  An overlay requested from a ViewGroup is of type  ViewGroupOverlay 
 which also supports adding and removing views."
android,view,View.BaseSavedState,1,"Base class for derived classes that want to save and restore their own
 state in  View.onSaveInstanceState() ."
android,view,ViewGroup.LayoutParams,2,"LayoutParams are used by views to tell their parents how they want to be
 laid out. See
  ViewGroup Layout Attributes 
 for a list of all child view attributes that this class supports.

  
 The base LayoutParams class just describes how big the view wants to be
 for both width and height. For each dimension it can specify one of:
  FILL_PARENT (renamed MATCH_PARENT in API Level 8 and higher) which
 means that the view wants to be as big as its parent (minus padding)
   WRAP_CONTENT which means that the view wants to be just big enough
 to enclose its content (plus padding)
   an exact number"
android,view,ViewStructure.HtmlInfo,2,Simplified representation of the HTML properties of a node that represents an HTML element.
android,view,ViewStub,12,"A ViewStub is an invisible zero-sized View that can be used to lazily inflate
 layout resources at runtime.

 When a ViewStub is made visible or when  inflate()   is invoked the layout resource
 is inflated. The ViewStub then replaces itself in its parent with the inflated View or Views.
 Therefore the ViewStub exists in the view hierarchy until  setVisibility(int)  or
  inflate()  is invoked.

 The inflated View is added to the ViewStub's parent with the ViewStub's layout
 parameters. Similarly you can define/override the inflate View's id by using the
 ViewStub's inflatedId property. For instance:

  
     <ViewStub android:id=""@+id/stub""
               android:inflatedId=""@+id/subTree""
               android:layout=""@layout/mySubTree""
               android:layout_width=""120dip""
               android:layout_height=""40dip"" />
  
     ViewStub stub = findViewById(R.id.stub);
     View inflated = stub.inflate();
  inflate()"
android,view,WindowId,8,"Safe identifier for a window.  This currently allows you to retrieve and observe
 the input focus state of the window.  Most applications will
 not use this instead relying on the simpler (and more efficient) methods available
 on  View .  This classes is useful when window input interactions need to be
 done across processes: the class itself is a Parcelable that can be passed to other
 processes for them to interact with your window and it provides a limited safe API
 that doesn't allow the other process to negatively harm your window."
android,view,WindowInsets,28,"Describes a set of insets for window content.

  WindowInsets are immutable and may be expanded to include more inset types in the future.
 To adjust insets use one of the supplied clone methods to obtain a new WindowInsets instance
 with the adjusted properties. Note: Before  P  WindowInsets instances were only
 immutable during a single layout pass (i.e. would return the same values between
  View#onApplyWindowInsets  and  View#onLayout  but could return other values
 otherwise). Starting with  P  WindowInsets are
 always immutable and implement equality."
android,java.beans,IndexedPropertyChangeEvent,1,"An ""IndexedPropertyChange"" event gets delivered whenever a component that
 conforms to the JavaBeansâ„¢ specification (a ""bean"") changes a bound
 indexed property. This class is an extension of  PropertyChangeEvent 
 but contains the index of the property that has changed.
  
 Null values may be provided for the old and the new values if their
 true values are not known.
  
 An event source may send a null object as the name to indicate that an
 arbitrary set of if its properties have changed.  In this case the
 old and new values should also be null."
android,java.beans,PropertyChangeEvent,6,"A ""PropertyChange"" event gets delivered whenever a bean changes a ""bound""
 or ""constrained"" property.  A PropertyChangeEvent object is sent as an
 argument to the PropertyChangeListener and VetoableChangeListener methods.
  
 Normally PropertyChangeEvents are accompanied by the name and the old
 and new value of the changed property.  If the new value is a primitive
 type (such as int or boolean) it must be wrapped as the
 corresponding java.lang.* Object type (such as Integer or Boolean).
  
 Null values may be provided for the old and the new values if their
 true values are not known.
  
 An event source may send a null object as the name to indicate that an
 arbitrary set of if its properties have changed.  In this case the
 old and new values should also be null."
android,java.beans,PropertyChangeListenerProxy,2,"A class which extends the  EventListenerProxy 
 specifically for adding a  PropertyChangeListener 
 with a ""bound"" property.
 Instances of this class can be added
 as  PropertyChangeListener s to a bean
 which supports firing property change events.
  
 If the object has a  getPropertyChangeListeners  method
 then the array returned could be a mixture of  PropertyChangeListener 
 and  PropertyChangeListenerProxy  objects."
android,java.beans,PropertyChangeSupport,14,"This is a utility class that can be used by beans that support bound
 properties.  It manages a list of listeners and dispatches
  PropertyChangeEvent s to them.  You can use an instance of this class
 as a member field of your bean and delegate these types of work to it.
 The  PropertyChangeListener  can be registered for all properties
 or for a property specified by name.
  
 Here is an example of  PropertyChangeSupport  usage that follows
 the rules and recommendations laid out in the JavaBeansâ„¢ specification:
  
 public class MyBean {
     private final PropertyChangeSupport pcs = new PropertyChangeSupport(this);

     public void addPropertyChangeListener(PropertyChangeListener listener) {
         this.pcs.addPropertyChangeListener(listener);
     }

     public void removePropertyChangeListener(PropertyChangeListener listener) {
         this.pcs.removePropertyChangeListener(listener);
     }

     private String value;

     public String getValue() {
         return this.value;
     }

     public void setValue(String newValue) {
         String oldValue = this.value;
         this.value = newValue;
         this.pcs.firePropertyChange(""value"" oldValue newValue);
     }

     [...]
 }
  
 A  PropertyChangeSupport  instance is thread-safe.
  
 This class is serializable.  When it is serialized it will save
 (and restore) any listeners that are themselves serializable.  Any
 non-serializable listeners will be skipped during serialization."
android,java.lang.invoke,CallSite,4,"A  CallSite  is a holder for a variable  MethodHandle 
 which is called its  target .
 An  invokedynamic  instruction linked to a  CallSite  delegates
 all calls to the site's current target.
 A  CallSite  may be associated with several  invokedynamic 
 instructions or it may be ""free floating"" associated with none.
 In any case it may be invoked through an associated method handle
 called its  dynamic invoker .
  CallSite  is an abstract class which does not allow
 direct subclassing by users.  It has three immediate
 concrete subclasses that may be either instantiated or subclassed.
  If a mutable target is not required an  invokedynamic  instruction
 may be permanently bound by means of a  ConstantCallSite .
  If a mutable target is required which has volatile variable semantics
 because updates to the target must be immediately and reliably witnessed by other threads
 a  VolatileCallSite  may be used.
  Otherwise if a mutable target is required
 a  MutableCallSite  may be used.
  
 A non-constant call site may be  relinked  by changing its target.
 The new target must have the same  MethodHandle#type() 
 as the previous target.
 Thus though a call site can be relinked to a series of
 successive targets it cannot change its type.
  
 Here is a sample use of call sites and bootstrap methods which links every
 dynamic call site to print its arguments:
  static void test() throws Throwable {
    // THE FOLLOWING LINE IS PSEUDOCODE FOR A JVM INSTRUCTION
    InvokeDynamic[#bootstrapDynamic].baz(""baz arg"" 2 3.14);
 }
 private static void printArgs(Object... args) {
  System.out.println(java.util.Arrays.deepToString(args));
 }
 private static final MethodHandle printArgs;
 static {
  MethodHandles.Lookup lookup = MethodHandles.lookup();
  Class thisClass = lookup.lookupClass();  // (who am I?)
  printArgs = lookup.findStatic(thisClass
      ""printArgs"" MethodType.methodType(void.class Object[].class));
 }
 private static CallSite bootstrapDynamic(MethodHandles.Lookup caller String name MethodType type) {
  // ignore caller and name but match the type:
  return new ConstantCallSite(printArgs.asType(type));
 }"
android,java.lang.invoke,ConstantCallSite,3,"A  ConstantCallSite  is a  CallSite  whose target is permanent and can never be changed.
 An  invokedynamic  instruction linked to a  ConstantCallSite  is permanently
 bound to the call site's target."
android,java.lang.invoke,MethodHandles,22,"This class consists exclusively of static methods that operate on or return
 method handles. They fall into several categories:
  Lookup methods which help create method handles for methods and fields.
  Combinator methods which combine or transform pre-existing method handles into new ones.
  Other factory methods to create method handles that emulate other common JVM operations or control flow patterns."
android,java.lang.invoke,MethodHandles.Lookup,19,"A  lookup object  is a factory for creating method handles
 when the creation requires access checking.
 Method handles do not perform
 access checks when they are called but rather when they are created.
 Therefore method handle access
 restrictions must be enforced when a method handle is created.
 The caller class against which those restrictions are enforced
 is known as the  lookup class .
  
 A lookup class which needs to create method handles will call
  MethodHandles.lookup  to create a factory for itself.
 When the  Lookup  factory object is created the identity of the lookup class is
 determined and securely stored in the  Lookup  object.
 The lookup class (or its delegates) may then use factory methods
 on the  Lookup  object to create method handles for access-checked members.
 This includes all methods constructors and fields which are allowed to the lookup class
 even private ones.

  Lookup Factory Methods Lookup bytecode behavior lookup expression member bytecode behavior lookup.findGetter(C.class""f""FT.class) FT f; (T) this.f; lookup.findStaticGetter(C.class""f""FT.class) static FT f; (T) C.f; lookup.findSetter(C.class""f""FT.class) FT f; this.f = x; lookup.findStaticSetter(C.class""f""FT.class) static FT f; C.f = arg; lookup.findVirtual(C.class""m""MT) T m(A*); (T) this.m(arg*); lookup.findStatic(C.class""m""MT) static T m(A*); (T) C.m(arg*); lookup.findSpecial(C.class""m""MTthis.class) T m(A*); (T) super.m(arg*); lookup.findConstructor(C.classMT) C(A*); new C(arg*); lookup.unreflectGetter(aField) ( static )? FT f; (FT) aField.get(thisOrNull); lookup.unreflectSetter(aField) ( static )? FT f; aField.set(thisOrNull arg); lookup.unreflect(aMethod) ( static )? T m(A*); (T) aMethod.invoke(thisOrNull arg*); lookup.unreflectConstructor(aConstructor) C(A*); (C) aConstructor.newInstance(arg*); lookup.unreflect(aMethod) ( static )? T m(A*); (T) aMethod.invoke(thisOrNull arg*); C refc MT T A* A* C MT FT type this C protected this arg thisOrNull this aMethod aField aConstructor 
 In cases where the given member is of variable arity (i.e. a method or constructor)
 the returned method handle will also be of  MethodHandle#asVarargsCollector .
 In all other cases the returned method handle will be of fixed arity.
  Discussion: 
 The equivalence between looked-up method handles and underlying
 class members and bytecode behaviors
 can break down in a few ways:
  If  C  is not symbolically accessible from the lookup class's loader
 the lookup can still succeed even when there is no equivalent
 Java expression or bytecoded constant.
  Likewise if  T  or  MT 
 is not symbolically accessible from the lookup class's loader
 the lookup can still succeed.
 For example lookups for  MethodHandle.invokeExact  and
  MethodHandle.invoke  will always succeed regardless of requested type.
  If there is a security manager installed it can forbid the lookup
 on various grounds ( see below ).
 By contrast the  ldc  instruction on a  CONSTANT_MethodHandle 
 constant is not subject to security manager checks.
  If the looked-up method has a
  very large arity 
 the method handle creation may fail due to the method handle
 type having too many parameters.
  Access checking Lookup java.lang.reflect.Method.invoke 
 All access checks start from a  Lookup  object which
 compares its recorded lookup class against all requests to
 create method handles.
 A single  Lookup  object can be used to create any number
 of access-checked method handles all checked against a single
 lookup class.
  
 A  Lookup  object can be shared with other trusted code
 such as a metaobject protocol.
 A shared  Lookup  object delegates the capability
 to create method handles on private members of the lookup class.
 Even if privileged code uses the  Lookup  object
 the access checking is confined to the privileges of the
 original lookup class.
  
 A lookup can fail because
 the containing class is not accessible to the lookup class or
 because the desired class member is missing or because the
 desired class member is not accessible to the lookup class or
 because the lookup object is not trusted enough to access the member.
 In any of these cases a  ReflectiveOperationException  will be
 thrown from the attempted lookup.  The exact class will be one of
 the following:
  NoSuchMethodException â€” if a method is requested but does not exist
  NoSuchFieldException â€” if a field is requested but does not exist
  IllegalAccessException â€” if the member exists but an access check fails
  
 In general the conditions under which a method handle may be
 looked up for a method  M  are no more restrictive than the conditions
 under which the lookup class could have compiled verified and resolved a call to  M .
 Where the JVM would raise exceptions like  NoSuchMethodError 
 a method handle lookup will generally raise a corresponding
 checked exception such as  NoSuchMethodException .
 And the effect of invoking the method handle resulting from the lookup
 is  exactly equivalent 
 to executing the compiled verified and resolved call to  M .
 The same point is true of fields and constructors.
  Discussion: 
 Access checks only apply to named and reflected methods
 constructors and fields.
 Other method handle creation methods such as
  MethodHandle#asType 
 do not require any access checks and are used
 independently of any  Lookup  object.
  
 If the desired member is  protected  the usual JVM rules apply
 including the requirement that the lookup class must be either be in the
 same package as the desired member or must inherit that member.
 (See the Java Virtual Machine Specification sections 4.9.2 5.4.3.5 and 6.4.)
 In addition if the desired member is a non-static field or method
 in a different package the resulting method handle may only be applied
 to objects of the lookup class or one of its subclasses.
 This requirement is enforced by narrowing the type of the leading
  this  parameter from  C 
 (which will necessarily be a superclass of the lookup class)
 to the lookup class itself.
  
 The JVM imposes a similar requirement on  invokespecial  instruction
 that the receiver argument must match both the resolved method  and 
 the current class.  Again this requirement is enforced by narrowing the
 type of the leading parameter to the resulting method handle.
 (See the Java Virtual Machine Specification section 4.10.1.9.)
  
 The JVM represents constructors and static initializer blocks as internal methods
 with special names ( ""<init>""  and  ""<clinit>"" ).
 The internal syntax of invocation instructions allows them to refer to such internal
 methods as if they were normal methods but the JVM bytecode verifier rejects them.
 A lookup of such an internal method will produce a  NoSuchMethodException .
  
 In some cases access between nested classes is obtained by the Java compiler by creating
 an wrapper method to access a private method of another class
 in the same top-level declaration.
 For example a nested class  C.D 
 can access private members within other related classes such as
  C   C.D.E  or  C.B 
 but the Java compiler may need to generate wrapper methods in
 those related classes.  In such cases a  Lookup  object on
  C.E  would be unable to those private members.
 A workaround for this limitation is the  Lookup#in  method
 which can transform a lookup on  C.E  into one on any of those other
 classes without special elevation of privilege.
  
 The accesses permitted to a given lookup object may be limited
 according to its set of  lookupModes 
 to a subset of members normally accessible to the lookup class.
 For example the  publicLookup 
 method produces a lookup object which is only allowed to access
 public members in public classes.
 The caller sensitive method  lookup 
 produces a lookup object with full capabilities relative to
 its caller class to emulate all supported bytecode behaviors.
 Also the  Lookup#in  method may produce a lookup object
 with fewer access modes than the original lookup object.

  Discussion of private access: 
 We say that a lookup has  private access 
 if its  lookup modes 
 include the possibility of accessing  private  members.
 As documented in the relevant methods elsewhere
 only lookups with private access possess the following capabilities:
  access private fields methods and constructors of the lookup class
  create method handles which invoke  caller sensitive  methods
     such as  Class.forName create method handles which  Lookup#findSpecial  instructions
  avoid  package access checks 
     for classes accessible to the lookup class
  create  Lookup#in  which have private access to other classes
     within the same package member
  
 Each of these permissions is a consequence of the fact that a lookup object
 with private access can be securely traced back to an originating class
 whose  bytecode behaviors  and Java language access permissions
 can be reliably determined and emulated by method handles.

  Security manager interactions Class invokestatic getfield security manager API MethodHandles.Lookup Class 
 If a security manager is present member lookups are subject to
 additional checks.
 From one to three calls are made to the security manager.
 Any of these calls can refuse access by throwing a
  SecurityException .
 Define  smgr  as the security manager
  lookc  as the lookup class of the current lookup object
  refc  as the containing class in which the member
 is being sought and  defc  as the class in which the
 member is actually defined.
 The value  lookc  is defined as  not present 
 if the current lookup object does not have
  private access .
 The calls are made according to the following rules:
  Step 1: 
     If  lookc  is not present or if its class loader is not
     the same as or an ancestor of the class loader of  refc 
     then  SecurityManager#checkPackageAccess  is called
     where  refcPkg  is the package of  refc .
  Step 2: 
     If the retrieved member is not public and
      lookc  is not present then
      SecurityManager#checkPermission 
     with  RuntimePermission(""accessDeclaredMembers"")  is called.
  Step 3: 
     If the retrieved member is not public
     and if  lookc  is not present
     and if  defc  and  refc  are different
     then  SecurityManager#checkPackageAccess  is called
     where  defcPkg  is the package of  defc .
  Caller sensitive methods caller-sensitive 
 If a method handle for a caller-sensitive method is requested
 the general rules for  bytecode behaviors  apply
 but they take account of the lookup class in a special way.
 The resulting method handle behaves as if it were called
 from an instruction contained in the lookup class
 so that the caller-sensitive method detects the lookup class.
 (By contrast the invoker of the method handle is disregarded.)
 Thus in the case of caller-sensitive methods
 different lookup classes may give rise to
 differently behaving method handles.
  
 In cases where the lookup object is
  publicLookup() 
 or some other lookup object without
  private access 
 the lookup class is disregarded.
 In such cases no caller-sensitive method handle can be created
 access is forbidden and the lookup fails with an
  IllegalAccessException .
  Discussion: 
 For example the caller-sensitive method
  Class.forName(x) 
 can return varying classes or throw varying exceptions
 depending on the class loader of the class that calls it.
 A public lookup of  Class.forName  will fail because
 there is no reasonable way to determine its bytecode behavior.
  
 If an application caches method handles for broad sharing
 it should use  publicLookup()  to create them.
 If there is a lookup of  Class.forName  it will fail
 and the application must take appropriate action in that case.
 It may be that a later lookup perhaps during the invocation of a
 bootstrap method can incorporate the specific identity
 of the caller making the method accessible.
  
 The function  MethodHandles.lookup  is caller sensitive
 so that there can be a secure foundation for lookups.
 Nearly all other methods in the JSR 292 API rely on lookup
 objects to check access requests."
android,java.lang.invoke,MethodType,31,"A method type represents the arguments and return type accepted and
 returned by a method handle or the arguments and return type passed
 and expected  by a method handle caller.  Method types must be properly
 matched between a method handle and all its callers
 and the JVM's operations enforce this matching at specifically
 during calls to  MethodHandle#invokeExact 
 and  MethodHandle#invoke  and during execution
 of  invokedynamic  instructions.
  
 The structure is a return type accompanied by any number of parameter types.
 The types (primitive  void  and reference) are represented by  Class  objects.
 (For ease of exposition we treat  void  as if it were a type.
 In fact it denotes the absence of a return type.)
  
 All instances of  MethodType  are immutable.
 Two instances are completely interchangeable if they compare equal.
 Equality depends on pairwise correspondence of the return and parameter types and on nothing else.
  
 This type can be created only by factory methods.
 All factory methods may cache values though caching is not guaranteed.
 Some factory methods are static while others are virtual methods which
 modify precursor method types e.g. by changing a selected parameter.
  
 Factory methods which operate on groups of parameter types
 are systematically presented in two versions so that both Java arrays and
 Java lists can be used to work with groups of parameter types.
 The query methods  parameterArray  and  parameterList 
 also provide a choice between arrays and lists.
  MethodType  objects are sometimes derived from bytecode instructions
 such as  invokedynamic  specifically from the type descriptor strings associated
 with the instructions in a class file's constant pool.
  
 Like classes and strings method types can also be represented directly
 in a class file's constant pool as constants.
 A method type may be loaded by an  ldc  instruction which refers
 to a suitable  CONSTANT_MethodType  constant pool entry.
 The entry refers to a  CONSTANT_Utf8  spelling for the descriptor string.
 (For full details on method type constants
 see sections 4.4.8 and 5.4.3.5 of the Java Virtual Machine Specification.)
  
 When the JVM materializes a  MethodType  from a descriptor string
 all classes named in the descriptor must be accessible and will be loaded.
 (But the classes need not be initialized as is the case with a  CONSTANT_Class .)
 This loading may occur at any time before the  MethodType  object is first derived."
android,java.lang.invoke,MutableCallSite,3,"A  MutableCallSite  is a  CallSite  whose target variable
 behaves like an ordinary field.
 An  invokedynamic  instruction linked to a  MutableCallSite  delegates
 all calls to the site's current target.
 The  CallSite#dynamicInvoker  of a mutable call site
 also delegates each call to the site's current target.
  
 Here is an example of a mutable call site which introduces a
 state variable into a method handle chain.
  MutableCallSite name = new MutableCallSite(MethodType.methodType(String.class));
 MethodHandle MH_name = name.dynamicInvoker();
 MethodType MT_str1 = MethodType.methodType(String.class);
 MethodHandle MH_upcase = MethodHandles.lookup()
    .findVirtual(String.class ""toUpperCase"" MT_str1);
 MethodHandle worker1 = MethodHandles.filterReturnValue(MH_name MH_upcase);
 name.setTarget(MethodHandles.constant(String.class ""Rocky""));
 assertEquals(""ROCKY"" (String) worker1.invokeExact());
 name.setTarget(MethodHandles.constant(String.class ""Fred""));
 assertEquals(""FRED"" (String) worker1.invokeExact());
 // (mutation can be continued indefinitely)
  
 The same call site may be used in several places at once.
  MethodType MT_str2 = MethodType.methodType(String.class String.class);
 MethodHandle MH_cat = lookup().findVirtual(String.class
  ""concat"" methodType(String.class String.class));
 MethodHandle MH_dear = MethodHandles.insertArguments(MH_cat 1 "" dear?"");
 MethodHandle worker2 = MethodHandles.filterReturnValue(MH_name MH_dear);
 assertEquals(""Fred dear?"" (String) worker2.invokeExact());
 name.setTarget(MethodHandles.constant(String.class ""Wilma""));
 assertEquals(""WILMA"" (String) worker1.invokeExact());
 assertEquals(""Wilma dear?"" (String) worker2.invokeExact());
  Non-synchronization of target values: 
 A write to a mutable call site's target does not force other threads
 to become aware of the updated value.  Threads which do not perform
 suitable synchronization actions relative to the updated call site
 may cache the old target value and delay their use of the new target
 value indefinitely.
 (This is a normal consequence of the Java Memory Model as applied
 to object fields.)
  
 For target values which will be frequently updated consider using
 a  VolatileCallSite  instead."
android,java.lang.invoke,VolatileCallSite,3,"A  VolatileCallSite  is a  CallSite  whose target acts like a volatile variable.
 An  invokedynamic  instruction linked to a  VolatileCallSite  sees updates
 to its call site target immediately even if the update occurs in another thread.
 There may be a performance penalty for such tight coupling between threads.
  
 In other respects a  VolatileCallSite  is interchangeable
 with  MutableCallSite ."
android,java.lang.invoke,MethodHandle,13,"A method handle is a typed directly executable reference to an underlying method
 constructor field or similar low-level operation with optional
 transformations of arguments or return values.
 These transformations are quite general and include such patterns as
  conversion 
  insertion 
  deletion 
 and  substitution .

  Method handle contents type descriptor 
 Every method handle reports its type descriptor via the  type  accessor.
 This type descriptor is a  MethodType  object
 whose structure is a series of classes one of which is
 the return type of the method (or  void.class  if none).
  
 A method handle's type controls the types of invocations it accepts
 and the kinds of transformations that apply to it.
  
 A method handle contains a pair of special invoker methods
 called  invokeExact  and  invoke .
 Both invoker methods provide direct access to the method handle's
 underlying method constructor field or other operation
 as modified by transformations of arguments and return values.
 Both invokers accept calls which exactly match the method handle's own type.
 The plain inexact invoker also accepts a range of other call types.
  
 Method handles are immutable and have no visible state.
 Of course they can be bound to underlying methods or data which exhibit state.
 With respect to the Java Memory Model any method handle will behave
 as if all of its (internal) fields are final variables.  This means that any method
 handle made visible to the application will always be fully formed.
 This is true even if the method handle is published through a shared
 variable in a data race.
  
 Method handles cannot be subclassed by the user.
 Implementations may (or may not) create internal subclasses of  MethodHandle 
 which may be visible via the  Object.getClass 
 operation.  The programmer should not draw conclusions about a method handle
 from its specific class as the method handle class hierarchy (if any)
 may change from time to time or across implementations from different vendors.

  Method handle compilation invokeExact invoke Object Object signature polymorphism 
 As is usual with virtual methods source-level calls to  invokeExact 
 and  invoke  compile to an  invokevirtual  instruction.
 More unusually the compiler must record the actual argument types
 and may not perform method invocation conversions on the arguments.
 Instead it must push them on the stack according to their own unconverted types.
 The method handle object itself is pushed on the stack before the arguments.
 The compiler then calls the method handle with a symbolic type descriptor which
 describes the argument and return types.
  
 To issue a complete symbolic type descriptor the compiler must also determine
 the return type.  This is based on a cast on the method invocation expression
 if there is one or else  Object  if the invocation is an expression
 or else  void  if the invocation is a statement.
 The cast may be to a primitive type (but not  void ).
  
 As a corner case an uncasted  null  argument is given
 a symbolic type descriptor of  java.lang.Void .
 The ambiguity with the type  Void  is harmless since there are no references of type
  Void  except the null reference.

  Method handle invocation invokevirtual invokeExact invoke invokevirtual 
 When the  invokevirtual  is executed after linking
 the receiving method handle's type is first checked by the JVM
 to ensure that it matches the symbolic type descriptor.
 If the type match fails it means that the method which the
 caller is invoking is not present on the individual
 method handle being invoked.
  
 In the case of  invokeExact  the type descriptor of the invocation
 (after resolving symbolic type names) must exactly match the method type
 of the receiving method handle.
 In the case of plain inexact  invoke  the resolved type descriptor
 must be a valid argument to the receiver's  asType  method.
 Thus plain  invoke  is more permissive than  invokeExact .
  
 After type matching a call to  invokeExact  directly
 and immediately invoke the method handle's underlying method
 (or other behavior as the case may be).
  
 A call to plain  invoke  works the same as a call to
  invokeExact  if the symbolic type descriptor specified by the caller
 exactly matches the method handle's own type.
 If there is a type mismatch  invoke  attempts
 to adjust the type of the receiving method handle
 as if by a call to  asType 
 to obtain an exactly invokable method handle  M2 .
 This allows a more powerful negotiation of method type
 between caller and callee.
  
 ( Note:  The adjusted method handle  M2  is not directly observable
 and implementations are therefore not required to materialize it.)

  Invocation checking WrongMethodTypeException invokeExact asType invoke 
 Thus a method type mismatch which might show up as a linkage error
 in a statically typed program can show up as
 a dynamic  WrongMethodTypeException 
 in a program which uses method handles.
  
 Because method types contain ""live""  Class  objects
 method type matching takes into account both types names and class loaders.
 Thus even if a method handle  M  is created in one
 class loader  L1  and used in another  L2 
 method handle calls are type-safe because the caller's symbolic type
 descriptor as resolved in  L2 
 is matched against the original callee method's symbolic type descriptor
 as resolved in  L1 .
 The resolution in  L1  happens when  M  is created
 and its type is assigned while the resolution in  L2  happens
 when the  invokevirtual  instruction is linked.
  
 Apart from the checking of type descriptors
 a method handle's capability to call its underlying method is unrestricted.
 If a method handle is formed on a non-public method by a class
 that has access to that method the resulting handle can be used
 in any place by any caller who receives a reference to it.
  
 Unlike with the Core Reflection API where access is checked every time
 a reflective method is invoked
 method handle access checking is performed
  when the method handle is created .
 In the case of  ldc  (see below) access checking is performed as part of linking
 the constant pool entry underlying the constant method handle.
  
 Thus handles to non-public methods or to methods in non-public classes
 should generally be kept secret.
 They should not be passed to untrusted code unless their use from
 the untrusted code would be harmless.

  Method handle creation MethodHandles.Lookup Lookup.findStatic Lookup.unreflect 
 Like classes and strings method handles that correspond to accessible
 fields methods and constructors can also be represented directly
 in a class file's constant pool as constants to be loaded by  ldc  bytecodes.
 A new type of constant pool entry  CONSTANT_MethodHandle 
 refers directly to an associated  CONSTANT_Methodref 
  CONSTANT_InterfaceMethodref  or  CONSTANT_Fieldref 
 constant pool entry.
 (For full details on method handle constants
 see sections 4.4.8 and 5.4.3.5 of the Java Virtual Machine Specification.)
  
 Method handles produced by lookups or constant loads from methods or
 constructors with the variable arity modifier bit ( 0x0080 )
 have a corresponding variable arity as if they were defined with
 the help of  asVarargsCollector .
  
 A method reference may refer either to a static or non-static method.
 In the non-static case the method handle type includes an explicit
 receiver argument prepended before any other arguments.
 In the method handle's type the initial receiver argument is typed
 according to the class under which the method was initially requested.
 (E.g. if a non-static method handle is obtained via  ldc 
 the type of the receiver is the class named in the constant pool entry.)
  
 Method handle constants are subject to the same link-time access checks
 their corresponding bytecode instructions and the  ldc  instruction
 will throw corresponding linkage errors if the bytecode behaviors would
 throw such errors.
  
 As a corollary of this access to protected members is restricted
 to receivers only of the accessing class or one of its subclasses
 and the accessing class must in turn be a subclass (or package sibling)
 of the protected member's defining class.
 If a method reference refers to a protected non-static method or field
 of a class outside the current package the receiver argument will
 be narrowed to the type of the accessing class.
  
 When a method handle to a virtual method is invoked the method is
 always looked up in the receiver (that is the first argument).
  
 A non-virtual method handle to a specific virtual method implementation
 can also be created.  These do not perform virtual lookup based on
 receiver type.  Such a method handle simulates the effect of
 an  invokespecial  instruction to the same method.

  Usage examples Object x y; String s; int i;
 MethodType mt; MethodHandle mh;
 MethodHandles.Lookup lookup = MethodHandles.lookup();
 // mt is (charchar)String
 mt = MethodType.methodType(String.class char.class char.class);
 mh = lookup.findVirtual(String.class ""replace"" mt);
 s = (String) mh.invokeExact(""daddy""'d''n');
 // invokeExact(Ljava/lang/String;CC)Ljava/lang/String;
 assertEquals(s ""nanny"");
 // weakly typed invocation (using MHs.invoke)
 s = (String) mh.invokeWithArguments(""sappy"" 'p' 'v');
 assertEquals(s ""savvy"");
 // mt is (Object[])List
 mt = MethodType.methodType(java.util.List.class Object[].class);
 mh = lookup.findStatic(java.util.Arrays.class ""asList"" mt);
 assert(mh.isVarargsCollector());
 x = mh.invoke(""one"" ""two"");
 // invoke(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/Object;
 assertEquals(x java.util.Arrays.asList(""one""""two""));
 // mt is (ObjectObjectObject)Object
 mt = MethodType.genericMethodType(3);
 mh = mh.asType(mt);
 x = mh.invokeExact((Object)1 (Object)2 (Object)3);
 // invokeExact(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
 assertEquals(x java.util.Arrays.asList(123));
 // mt is ()int
 mt = MethodType.methodType(int.class);
 mh = lookup.findVirtual(java.util.List.class ""size"" mt);
 i = (int) mh.invokeExact(java.util.Arrays.asList(123));
 // invokeExact(Ljava/util/List;)I
 assert(i == 3);
 mt = MethodType.methodType(void.class String.class);
 mh = lookup.findVirtual(java.io.PrintStream.class ""println"" mt);
 mh.invokeExact(System.out ""Hello world."");
 // invokeExact(Ljava/io/PrintStream;Ljava/lang/String;)V
  invokeExact invoke assertEquals Objects.equals Exceptions invokeExact invoke Throwable Throwable Signature polymorphism invokeExact invoke signature polymorphism 
 In source code a call to a signature polymorphic method will
 compile regardless of the requested symbolic type descriptor.
 As usual the Java compiler emits an  invokevirtual 
 instruction with the given symbolic type descriptor against the named method.
 The unusual part is that the symbolic type descriptor is derived from
 the actual argument and return types not from the method declaration.
  
 When the JVM processes bytecode containing signature polymorphic calls
 it will successfully link any such call regardless of its symbolic type descriptor.
 (In order to retain type safety the JVM will guard such calls with suitable
 dynamic type checks as described elsewhere.)
  
 Bytecode generators including the compiler back end are required to emit
 untransformed symbolic type descriptors for these methods.
 Tools which determine symbolic linkage are required to accept such
 untransformed descriptors without reporting linkage errors.

  Interoperation between method handles and the Core Reflection API Lookup Method Lookup.unreflect 
 As a special case
 when the Core Reflection API is used to view the signature polymorphic
 methods  invokeExact  or plain  invoke  in this class
 they appear as ordinary non-polymorphic methods.
 Their reflective appearance as viewed by
  Class.getDeclaredMethod 
 is unaffected by their special status in this API.
 For example  Method.getModifiers 
 will report exactly those modifier bits required for any similarly
 declared method including in this case  native  and  varargs  bits.
  
 As with any reflected method these methods (when reflected) may be
 invoked via  java.lang.reflect.Method.invoke .
 However such reflective calls do not result in method handle invocations.
 Such a call if passed the required argument
 (a single one of type  Object[] ) will ignore the argument and
 will throw an  UnsupportedOperationException .
  
 Since  invokevirtual  instructions can natively
 invoke method handles under any symbolic type descriptor this reflective view conflicts
 with the normal presentation of these methods via bytecodes.
 Thus these two native methods when reflectively viewed by
  Class.getDeclaredMethod  may be regarded as placeholders only.
  
 In order to obtain an invoker method for a particular type descriptor
 use  MethodHandles.exactInvoker 
 or  MethodHandles.invoker .
 The  Lookup.findVirtual 
 API is also able to return a method handle
 to call  invokeExact  or plain  invoke 
 for any specified type descriptor .

  Interoperation between method handles and Java generics invokevirtual 
 Method handles do not represent
 their function-like types in terms of Java parameterized (generic) types
 because there are three mismatches between function-like types and parameterized
 Java types.
  Method types range over all possible arities
 from no arguments to up to the   maximum number  of allowed arguments.
 Generics are not variadic and so cannot represent this. Method types can specify arguments of primitive types
 which Java generic types cannot range over. Higher order functions over method handles (combinators) are
 often generic across a wide range of function types including
 those of multiple arities.  It is impossible to represent such
 genericity with a Java type parameter. Arity limits A  long  or  double  argument counts (for purposes of arity limits) as two argument slots.
  A non-static method consumes an extra argument for the object on which the method is called.
  A constructor consumes an extra argument for the object which is being constructed.
  Since a method handleâ€™s  invoke  method (or other signature-polymorphic method) is non-virtual
     it consumes an extra argument for the method handle itself in addition to any non-virtual receiver object.
  IllegalArgumentException"
android,java.lang.ref,PhantomReference,1,"Phantom reference objects which are enqueued after the collector
 determines that their referents may otherwise be reclaimed.  Phantom
 references are most often used for scheduling pre-mortem cleanup actions in
 a more flexible way than is possible with the Java finalization mechanism.

   If the garbage collector determines at a certain point in time that the
 referent of a phantom reference is  phantom reachable  then at that
 time or at some later time it will enqueue the reference.

   In order to ensure that a reclaimable object remains so the referent of
 a phantom reference may not be retrieved: The  get  method of a
 phantom reference always returns  null .

   Unlike soft and weak references phantom references are not
 automatically cleared by the garbage collector as they are enqueued.  An
 object that is reachable via phantom references will remain so until all
 such references are cleared or themselves become unreachable."
android,java.lang.ref,Reference,5,"Abstract base class for reference objects.  This class defines the
 operations common to all reference objects.  Because reference objects are
 implemented in close cooperation with the garbage collector this class may
 not be subclassed directly."
android,java.lang.ref,ReferenceQueue,3,"Reference queues to which registered reference objects are appended by the
 garbage collector after the appropriate reachability changes are detected."
android,java.lang.ref,SoftReference,1,"Soft reference objects which are cleared at the discretion of the garbage
 collector in response to memory demand.

   Suppose that the garbage collector determines at a certain point in time
 that an object is  softly
 reachable .  At that time it may choose to clear atomically all soft
 references to that object and all soft references to any other
 softly-reachable objects from which that object is reachable through a chain
 of strong references.  At the same time or at some later time it will
 enqueue those newly-cleared soft references that are registered with
 reference queues.

   All soft references to softly-reachable objects are guaranteed to have
 been cleared before the virtual machine throws an
  OutOfMemoryError .  Otherwise no constraints are placed upon the
 time at which a soft reference will be cleared or the order in which a set
 of such references to different objects will be cleared.  Virtual machine
 implementations are however encouraged to bias against clearing
 recently-created or recently-used soft references.

  Avoid Soft References for Caching The lack of information on the value to your application of each reference
 limits the usefulness of soft references. References that are cleared too
 early cause unnecessary work; those that are cleared too late waste memory.

  Most applications should use an  android.util.LruCache  instead of
 soft references. LruCache has an effective eviction policy and lets the user
 tune how much memory is allotted."
android,java.lang.ref,WeakReference,0,"Weak reference objects which do not prevent their referents from being
 made finalizable finalized and then reclaimed.  Weak references are most
 often used to implement canonicalizing mappings.

   Suppose that the garbage collector determines at a certain point in time
 that an object is  weakly
 reachable .  At that time it will atomically clear all weak references to
 that object and all weak references to any other weakly-reachable objects
 from which that object is reachable through a chain of strong and soft
 references.  At the same time it will declare all of the formerly
 weakly-reachable objects to be finalizable.  At the same time or at some
 later time it will enqueue those newly-cleared weak references that are
 registered with reference queues."
android,java.lang.reflect,AccessibleObject,10,"The AccessibleObject class is the base class for Field Method and
 Constructor objects.  It provides the ability to flag a reflected
 object as suppressing default Java language access control checks
 when it is used.  The access checks--for public default (package)
 access protected and private members--are performed when Fields
 Methods or Constructors are used to set or get fields to invoke
 methods or to create and initialize new instances of classes
 respectively.

  Setting the  accessible  flag in a reflected object
 permits sophisticated applications with sufficient privilege such
 as Java Object Serialization or other persistence mechanisms to
 manipulate objects in a manner that would normally be prohibited.

  By default a reflected object is  not  accessible."
android,java.lang.reflect,Array,21,"The  Array  class provides static methods to dynamically create and
 access Java arrays.

  Array  permits widening conversions to occur during a get or set
 operation but throws an  IllegalArgumentException  if a narrowing
 conversion would occur."
android,java.lang.reflect,Constructor,19,"Constructor  provides information about and access to a single
 constructor for a class.

  Constructor  permits widening conversions to occur when matching the
 actual parameters to newInstance() with the underlying
 constructor's formal parameters but throws an
  IllegalArgumentException  if a narrowing conversion would occur."
android,java.lang.reflect,Executable,18,"A shared superclass for the common functionality of  Method 
 and  Constructor ."
android,java.lang.reflect,Field,33,"A  Field  provides information about and dynamic access to a
 single field of a class or an interface.  The reflected field may
 be a class (static) field or an instance field.

  A  Field  permits widening conversions to occur during a get or
 set access operation but throws an  IllegalArgumentException  if a
 narrowing conversion would occur."
android,java.lang.reflect,Method,24,"A  Method  provides information about and access to a single method
 on a class or interface.  The reflected method may be a class method
 or an instance method (including an abstract method).

  A  Method  permits widening conversions to occur when matching the
 actual parameters to invoke with the underlying method's formal
 parameters but it throws an  IllegalArgumentException  if a
 narrowing conversion would occur."
android,java.lang.reflect,Modifier,19,"The Modifier class provides  static  methods and
 constants to decode class and member access modifiers.  The sets of
 modifiers are represented as integers with distinct bit positions
 representing different modifiers.  The values for the constants
 representing the modifiers are taken from the tables in sections 4.1 4.4 4.5 and 4.7 of
  The Javaâ„¢ Virtual Machine Specification ."
android,java.lang.reflect,Parameter,18,"Information about method parameters.

 A  Parameter  provides information about method parameters
 including its name and modifiers.  It also provides an alternate
 means of obtaining attributes for the parameter."
android,java.lang.reflect,Proxy,4,"Proxy  provides static methods for creating dynamic proxy
 classes and instances and it is also the superclass of all
 dynamic proxy classes created by those methods.

  To create a proxy for some interface  Foo :
  
     InvocationHandler handler = new MyInvocationHandler(...);
     Class<?> proxyClass = Proxy.getProxyClass(Foo.class.getClassLoader() Foo.class);
     Foo f = (Foo) proxyClass.getConstructor(InvocationHandler.class).
                     newInstance(handler);
  
     Foo f = (Foo) Proxy.newProxyInstance(Foo.class.getClassLoader()
                                          new Class<?>[] { Foo.class }
                                          handler);
  A  dynamic proxy class  (simply referred to as a  proxy
 class  below) is a class that implements a list of interfaces
 specified at runtime when the class is created with behavior as
 described below.

 A  proxy interface  is such an interface that is implemented
 by a proxy class.

 A  proxy instance  is an instance of a proxy class.

 Each proxy instance has an associated  invocation handler 
 object which implements the interface  InvocationHandler .
 A method invocation on a proxy instance through one of its proxy
 interfaces will be dispatched to the  InvocationHandler#invoke  method of the instance's invocation handler passing the proxy
 instance a  java.lang.reflect.Method  object identifying
 the method that was invoked and an array of type  Object 
 containing the arguments.  The invocation handler processes the
 encoded method invocation as appropriate and the result that it
 returns will be returned as the result of the method invocation on
 the proxy instance.

  A proxy class has the following properties:

  Proxy classes are  public final and not abstract  if
 all proxy interfaces are public. Proxy classes are  non-public final and not abstract  if
 any of the proxy interfaces is non-public. The unqualified name of a proxy class is unspecified.  The space
 of class names that begin with the string  ""$Proxy"" 
 should be however reserved for proxy classes.

  A proxy class extends  java.lang.reflect.Proxy .

  A proxy class implements exactly the interfaces specified at its
 creation in the same order.

  If a proxy class implements a non-public interface then it will
 be defined in the same package as that interface.  Otherwise the
 package of a proxy class is also unspecified.  Note that package
 sealing will not prevent a proxy class from being successfully defined
 in a particular package at runtime and neither will classes already
 defined by the same class loader and the same package with particular
 signers.

  Since a proxy class implements all of the interfaces specified at
 its creation invoking  getInterfaces  on its
  Class  object will return an array containing the same
 list of interfaces (in the order specified at its creation) invoking
  getMethods  on its  Class  object will return
 an array of  Method  objects that include all of the
 methods in those interfaces and invoking  getMethod  will
 find methods in the proxy interfaces as would be expected.

  The  Proxy#isProxyClass  method will
 return true if it is passed a proxy class-- a class returned by
  Proxy.getProxyClass  or the class of an object returned by
  Proxy.newProxyInstance -- and false otherwise.

  The  java.security.ProtectionDomain  of a proxy class
 is the same as that of system classes loaded by the bootstrap class
 loader such as  java.lang.Object  because the code for a
 proxy class is generated by trusted system code.  This protection
 domain will typically be granted
  java.security.AllPermission .

  Each proxy class has one public constructor that takes one argument
 an implementation of the interface  InvocationHandler  to set
 the invocation handler for a proxy instance.  Rather than having to use
 the reflection API to access the public constructor a proxy instance
 can be also be created by calling the  Proxy#newProxyInstance  method which combines the actions of calling
  Proxy#getProxyClass  with invoking the
 constructor with an invocation handler.
  A proxy instance has the following properties:

  Given a proxy instance  proxy  and one of the
 interfaces implemented by its proxy class  Foo  the
 following expression will return true:
  proxy instanceof Foo 
 and the following cast operation will succeed (rather than throwing
 a  ClassCastException ):
  (Foo) proxy Each proxy instance has an associated invocation handler the one
 that was passed to its constructor.  The static
  Proxy#getInvocationHandler  method
 will return the invocation handler associated with the proxy instance
 passed as its argument.

  An interface method invocation on a proxy instance will be
 encoded and dispatched to the invocation handler's  InvocationHandler#invoke  method as described in the
 documentation for that method.

  An invocation of the  hashCode 
  equals  or  toString  methods declared in
  java.lang.Object  on a proxy instance will be encoded and
 dispatched to the invocation handler's  invoke  method in
 the same manner as interface method invocations are encoded and
 dispatched as described above.  The declaring class of the
  Method  object passed to  invoke  will be
  java.lang.Object .  Other public methods of a proxy
 instance inherited from  java.lang.Object  are not
 overridden by a proxy class so invocations of those methods behave
 like they do for instances of  java.lang.Object .
  Methods Duplicated in Multiple Proxy Interfaces When two or more interfaces of a proxy class contain a method with
 the same name and parameter signature the order of the proxy class's
 interfaces becomes significant.  When such a  duplicate method 
 is invoked on a proxy instance the  Method  object passed
 to the invocation handler will not necessarily be the one whose
 declaring class is assignable from the reference type of the interface
 that the proxy's method was invoked through.  This limitation exists
 because the corresponding method implementation in the generated proxy
 class cannot determine which interface it was invoked through.
 Therefore when a duplicate method is invoked on a proxy instance
 the  Method  object for the method in the foremost interface
 that contains the method (either directly or inherited through a
 superinterface) in the proxy class's list of interfaces is passed to
 the invocation handler's  invoke  method regardless of the
 reference type through which the method invocation occurred.

  If a proxy interface contains a method with the same name and
 parameter signature as the  hashCode   equals 
 or  toString  methods of  java.lang.Object 
 when such a method is invoked on a proxy instance the
  Method  object passed to the invocation handler will have
  java.lang.Object  as its declaring class.  In other words
 the public non-final methods of  java.lang.Object 
 logically precede all of the proxy interfaces for the determination of
 which  Method  object to pass to the invocation handler.

  Note also that when a duplicate method is dispatched to an
 invocation handler the  invoke  method may only throw
 checked exception types that are assignable to one of the exception
 types in the  throws  clause of the method in  all  of
 the proxy interfaces that it can be invoked through.  If the
  invoke  method throws a checked exception that is not
 assignable to any of the exception types declared by the method in one
 of the proxy interfaces that it can be invoked through then an
 unchecked  UndeclaredThrowableException  will be thrown by
 the invocation on the proxy instance.  This restriction means that not
 all of the exception types returned by invoking
  getExceptionTypes  on the  Method  object
 passed to the  invoke  method can necessarily be thrown
 successfully by the  invoke  method."
android,java.lang.reflect,ReflectPermission,0,Legacy security code; do not use.
android,java.io,BufferedInputStream,8,"A  BufferedInputStream  adds
 functionality to another input stream-namely
 the ability to buffer the input and to
 support the  mark  and  reset 
 methods. When  the  BufferedInputStream 
 is created an internal buffer array is
 created. As bytes  from the stream are read
 or skipped the internal buffer is refilled
 as necessary  from the contained input stream
 many bytes at a time. The  mark 
 operation  remembers a point in the input
 stream and the  reset  operation
 causes all the  bytes read since the most
 recent  mark  operation to be
 reread before new bytes are  taken from
 the contained input stream."
android,java.io,BufferedReader,10,"Reads text from a character-input stream buffering characters so as to
 provide for the efficient reading of characters arrays and lines.

   The buffer size may be specified or the default size may be used.  The
 default is large enough for most purposes.

   In general each read request made of a Reader causes a corresponding
 read request to be made of the underlying character or byte stream.  It is
 therefore advisable to wrap a BufferedReader around any Reader whose read()
 operations may be costly such as FileReaders and InputStreamReaders.  For
 example

  
 BufferedReader in
   = new BufferedReader(new FileReader(""foo.in""));
   Programs that use DataInputStreams for textual input can be localized by
 replacing each DataInputStream with an appropriate BufferedReader."
android,java.io,BufferedWriter,6,"Writes text to a character-output stream buffering characters so as to
 provide for the efficient writing of single characters arrays and strings.

   The buffer size may be specified or the default size may be accepted.
 The default is large enough for most purposes.

   A newLine() method is provided which uses the platform's own notion of
 line separator as defined by the system property  line.separator .
 Not all platforms use the newline character ('\n') to terminate lines.
 Calling this method to terminate each output line is therefore preferred to
 writing a newline character directly.

   In general a Writer sends its output immediately to the underlying
 character or byte stream.  Unless prompt output is required it is advisable
 to wrap a BufferedWriter around any Writer whose write() operations may be
 costly such as FileWriters and OutputStreamWriters.  For example

  
 PrintWriter out
   = new PrintWriter(new BufferedWriter(new FileWriter(""foo.out"")));"
android,java.io,ByteArrayOutputStream,10,"This class implements an output stream in which the data is
 written into a byte array. The buffer automatically grows as data
 is written to it.
 The data can be retrieved using  toByteArray()  and
  toString() .
  
 Closing a  ByteArrayOutputStream  has no effect. The methods in
 this class can be called after the stream has been closed without
 generating an  IOException ."
android,java.io,CharArrayReader,8,"This class implements a character buffer that can be used as a
 character-input stream."
android,java.io,DataInputStream,18,"A data input stream lets an application read primitive Java data
 types from an underlying input stream in a machine-independent
 way. An application uses a data output stream to write data that
 can later be read by a data input stream.
  
 DataInputStream is not necessarily safe for multithreaded access.
 Thread safety is optional and is the responsibility of users of
 methods in this class."
android,java.io,FilterOutputStream,5,"This class is the superclass of all classes that filter output
 streams. These streams sit on top of an already existing output
 stream (the  underlying  output stream) which it uses as its
 basic sink of data but possibly transforming the data along the
 way or providing additional functionality.
  
 The class  FilterOutputStream  itself simply overrides
 all methods of  OutputStream  with versions that pass
 all requests to the underlying output stream. Subclasses of
  FilterOutputStream  may further override some of these
 methods as well as provide additional methods and fields."
android,java.io,FilterReader,8,"Abstract class for reading filtered character streams.
 The abstract class  FilterReader  itself
 provides default methods that pass all requests to
 the contained stream. Subclasses of  FilterReader 
 should override some of these methods and may also provide
 additional methods and fields."
android,java.io,FilterWriter,5,"Abstract class for writing filtered character streams.
 The abstract class  FilterWriter  itself
 provides default methods that pass all requests to the
 contained stream. Subclasses of  FilterWriter 
 should override some of these methods and may also
 provide additional methods and fields."
android,java.io,InputStreamReader,5,"An InputStreamReader is a bridge from byte streams to character streams: It
 reads bytes and decodes them into characters using a specified  charset .  The charset that it uses
 may be specified by name or may be given explicitly or the platform's
 default charset may be accepted.

   Each invocation of one of an InputStreamReader's read() methods may
 cause one or more bytes to be read from the underlying byte-input stream.
 To enable the efficient conversion of bytes to characters more bytes may
 be read ahead from the underlying stream than are necessary to satisfy the
 current read operation.

   For top efficiency consider wrapping an InputStreamReader within a
 BufferedReader.  For example:

  
 BufferedReader in
   = new BufferedReader(new InputStreamReader(System.in));"
android,java.io,LineNumberInputStream,8,"This class is an input stream filter that provides the added
 functionality of keeping track of the current line number.
  
 A line is a sequence of bytes ending with a carriage return
 character ( '\r' ) a newline character
 ( '\n' ) or a carriage return character followed
 immediately by a linefeed character. In all three cases the line
 terminating character(s) are returned as a single newline character.
  
 The line number begins at  0  and is incremented by
  1  when a  read  returns a newline character."
android,java.io,ObjectInputStream,31,"An ObjectInputStream deserializes primitive data and objects previously
 written using an ObjectOutputStream.

  ObjectOutputStream and ObjectInputStream can provide an application with
 persistent storage for graphs of objects when used with a FileOutputStream
 and FileInputStream respectively.  ObjectInputStream is used to recover
 those objects previously serialized. Other uses include passing objects
 between hosts using a socket stream or for marshaling and unmarshaling
 arguments and parameters in a remote communication system.

  ObjectInputStream ensures that the types of all objects in the graph
 created from the stream match the classes present in the Java Virtual
 Machine.  Classes are loaded as required using the standard mechanisms.

  Only objects that support the java.io.Serializable or
 java.io.Externalizable interface can be read from streams.

  The method  readObject  is used to read an object from the
 stream.  Java's safe casting should be used to get the desired type.  In
 Java strings and arrays are objects and are treated as objects during
 serialization. When read they need to be cast to the expected type.

  Primitive data types can be read from the stream using the appropriate
 method on DataInput.

  The default deserialization mechanism for objects restores the contents
 of each field to the value and type it had when it was written.  Fields
 declared as transient or static are ignored by the deserialization process.
 References to other objects cause those objects to be read from the stream
 as necessary.  Graphs of objects are restored correctly using a reference
 sharing mechanism.  New objects are always allocated when deserializing
 which prevents existing objects from being overwritten.

  Reading an object is analogous to running the constructors of a new
 object.  Memory is allocated for the object and initialized to zero (NULL).
 No-arg constructors are invoked for the non-serializable classes and then
 the fields of the serializable classes are restored from the stream starting
 with the serializable class closest to java.lang.object and finishing with
 the object's most specific class.

  For example to read from a stream as written by the example in
 ObjectOutputStream:
  
      FileInputStream fis = new FileInputStream(""t.tmp"");
      ObjectInputStream ois = new ObjectInputStream(fis);

      int i = ois.readInt();
      String today = (String) ois.readObject();
      Date date = (Date) ois.readObject();

      ois.close();
  Classes control how they are serialized by implementing either the
 java.io.Serializable or java.io.Externalizable interfaces.

  Implementing the Serializable interface allows object serialization to
 save and restore the entire state of the object and it allows classes to
 evolve between the time the stream is written and the time it is read.  It
 automatically traverses references between objects saving and restoring
 entire graphs.

  Serializable classes that require special handling during the
 serialization and deserialization process should implement the following
 methods:

  
 private void writeObject(java.io.ObjectOutputStream stream)
     throws IOException;
 private void readObject(java.io.ObjectInputStream stream)
     throws IOException ClassNotFoundException;
 private void readObjectNoData()
     throws ObjectStreamException;
  The readObject method is responsible for reading and restoring the state
 of the object for its particular class using data written to the stream by
 the corresponding writeObject method.  The method does not need to concern
 itself with the state belonging to its superclasses or subclasses.  State is
 restored by reading data from the ObjectInputStream for the individual
 fields and making assignments to the appropriate fields of the object.
 Reading primitive data types is supported by DataInput.

  Any attempt to read object data which exceeds the boundaries of the
 custom data written by the corresponding writeObject method will cause an
 OptionalDataException to be thrown with an eof field value of true.
 Non-object reads which exceed the end of the allotted data will reflect the
 end of data in the same way that they would indicate the end of the stream:
 bytewise reads will return -1 as the byte read or number of bytes read and
 primitive reads will throw EOFExceptions.  If there is no corresponding
 writeObject method then the end of default serialized data marks the end of
 the allotted data.

  Primitive and object read calls issued from within a readExternal method
 behave in the same manner--if the stream is already positioned at the end of
 data written by the corresponding writeExternal method object reads will
 throw OptionalDataExceptions with eof set to true bytewise reads will
 return -1 and primitive reads will throw EOFExceptions.  Note that this
 behavior does not hold for streams written with the old
  ObjectStreamConstants.PROTOCOL_VERSION_1  protocol in which the
 end of data written by writeExternal methods is not demarcated and hence
 cannot be detected.

  The readObjectNoData method is responsible for initializing the state of
 the object for its particular class in the event that the serialization
 stream does not list the given class as a superclass of the object being
 deserialized.  This may occur in cases where the receiving party uses a
 different version of the deserialized instance's class than the sending
 party and the receiver's version extends classes that are not extended by
 the sender's version.  This may also occur if the serialization stream has
 been tampered; hence readObjectNoData is useful for initializing
 deserialized objects properly despite a ""hostile"" or incomplete source
 stream.

  Serialization does not read or assign values to the fields of any object
 that does not implement the java.io.Serializable interface.  Subclasses of
 Objects that are not serializable can be serializable. In this case the
 non-serializable class must have a no-arg constructor to allow its fields to
 be initialized.  In this case it is the responsibility of the subclass to
 save and restore the state of the non-serializable class. It is frequently
 the case that the fields of that class are accessible (public package or
 protected) or that there are get and set methods that can be used to restore
 the state.

  Any exception that occurs while deserializing an object will be caught by
 the ObjectInputStream and abort the reading process.

  Implementing the Externalizable interface allows the object to assume
 complete control over the contents and format of the object's serialized
 form.  The methods of the Externalizable interface writeExternal and
 readExternal are called to save and restore the objects state.  When
 implemented by a class they can write and read their own state using all of
 the methods of ObjectOutput and ObjectInput.  It is the responsibility of
 the objects to handle any versioning that occurs.

  Enum constants are deserialized differently than ordinary serializable or
 externalizable objects.  The serialized form of an enum constant consists
 solely of its name; field values of the constant are not transmitted.  To
 deserialize an enum constant ObjectInputStream reads the constant name from
 the stream; the deserialized constant is then obtained by calling the static
 method  Enum.valueOf(Class String)  with the enum constant's
 base type and the received constant name as arguments.  Like other
 serializable or externalizable objects enum constants can function as the
 targets of back references appearing subsequently in the serialization
 stream.  The process by which enum constants are deserialized cannot be
 customized: any class-specific readObject readObjectNoData and readResolve
 methods defined by enum types are ignored during deserialization.
 Similarly any serialPersistentFields or serialVersionUID field declarations
 are also ignored--all enum types have a fixed serialVersionUID of 0L."
android,java.io,ObjectInputStream.GetField,11,Provide access to the persistent fields read from the input stream.
android,java.io,ObjectStreamField,10,"A description of a Serializable field from a Serializable class.  An array
 of ObjectStreamFields is used to declare the Serializable fields of a class."
android,java.io,OutputStreamWriter,6,"An OutputStreamWriter is a bridge from character streams to byte streams:
 Characters written to it are encoded into bytes using a specified  charset .  The charset that it uses
 may be specified by name or may be given explicitly or the platform's
 default charset may be accepted.

   Each invocation of a write() method causes the encoding converter to be
 invoked on the given character(s).  The resulting bytes are accumulated in a
 buffer before being written to the underlying output stream.  The size of
 this buffer may be specified but by default it is large enough for most
 purposes.  Note that the characters passed to the write() methods are not
 buffered.

   For top efficiency consider wrapping an OutputStreamWriter within a
 BufferedWriter so as to avoid frequent converter invocations.  For example:

  
 Writer out
   = new BufferedWriter(new OutputStreamWriter(System.out));
   A  surrogate pair  is a character represented by a sequence of two
  char  values: A  high  surrogate in the range '\uD800' to
 '\uDBFF' followed by a  low  surrogate in the range '\uDC00' to
 '\uDFFF'.

   A  malformed surrogate element  is a high surrogate that is not
 followed by a low surrogate or a low surrogate that is not preceded by a
 high surrogate.

   This class always replaces malformed surrogate elements and unmappable
 character sequences with the charset's default  substitution sequence .
 The  CharsetEncoder  class should be used when more
 control over the encoding process is required."
android,java.io,PipedWriter,5,Piped character-output streams.
android,java.io,PrintWriter,36,"Prints formatted representations of objects to a text-output stream.  This
 class implements all of the  print  methods found in  PrintStream .  It does not contain methods for writing raw bytes for which
 a program should use unencoded byte streams.

   Unlike the  PrintStream  class if automatic flushing is enabled
 it will be done only when one of the  println   printf  or
  format  methods is invoked rather than whenever a newline character
 happens to be output.  These methods use the platform's own notion of line
 separator rather than the newline character.

   Methods in this class never throw I/O exceptions although some of its
 constructors may.  The client may inquire as to whether any errors have
 occurred by invoking  checkError() ."
android,java.io,PushbackInputStream,11,"A  PushbackInputStream  adds
 functionality to another input stream namely
 the  ability to ""push back"" or ""unread""
 one byte. This is useful in situations where
 it is  convenient for a fragment of code
 to read an indefinite number of data bytes
 that  are delimited by a particular byte
 value; after reading the terminating byte
 the  code fragment can ""unread"" it so that
 the next read operation on the input stream
 will reread the byte that was pushed back.
 For example bytes representing the  characters
 constituting an identifier might be terminated
 by a byte representing an  operator character;
 a method whose job is to read just an identifier
 can read until it  sees the operator and
 then push the operator back to be re-read."
android,java.io,Console,9,"Methods to access the character-based console device if any associated
 with the current Java virtual machine.

   Whether a virtual machine has a console is dependent upon the
 underlying platform and also upon the manner in which the virtual
 machine is invoked.  If the virtual machine is started from an
 interactive command line without redirecting the standard input and
 output streams then its console will exist and will typically be
 connected to the keyboard and display from which the virtual machine
 was launched.  If the virtual machine is started automatically for
 example by a background job scheduler then it will typically not
 have a console.
  
 If this virtual machine has a console then it is represented by a
 unique instance of this class which can be obtained by invoking the
  System.console()  method.  If no console device is
 available then an invocation of that method will return  null .
  
 Read and write operations are synchronized to guarantee the atomic
 completion of critical operations; therefore invoking methods
  readLine()   readPassword()   format() 
  printf()  as well as the read format and write operations
 on the objects returned by  reader()  and  writer()  may
 block in multithreaded scenarios.
  
 Invoking  close()  on the objects returned by the  reader() 
 and the  writer()  will not close the underlying stream of those
 objects.
  
 The console-read methods return  null  when the end of the
 console input stream is reached for example by typing control-D on
 Unix or control-Z on Windows.  Subsequent read operations will succeed
 if additional characters are later entered on the console's input
 device.
  
 Unless otherwise specified passing a  null  argument to any method
 in this class will cause a  NullPointerException  to be thrown.
  Security note: 
 If an application needs to read a password or other secure data it should
 use  readPassword()  or  readPassword(java.lang.String java.lang.Object)  and
 manually zero the returned character array after processing to minimize the
 lifetime of sensitive data in memory.

  Console cons;
 char[] passwd;
 if ((cons = System.console()) != null &&
     (passwd = cons.readPassword(""[%s]"" ""Password:"")) != null) {
     ...
     java.util.Arrays.fill(passwd ' ');
 }"
android,java.io,FileInputStream,9,"A  FileInputStream  obtains input bytes
 from a file in a file system. What files
 are  available depends on the host environment.

  FileInputStream  is meant for reading streams of raw bytes
 such as image data. For reading streams of characters consider using
  FileReader ."
android,java.io,FileOutputStream,7,"A file output stream is an output stream for writing data to a
  File  or to a  FileDescriptor . Whether or not
 a file is available or may be created depends upon the underlying
 platform.  Some platforms in particular allow a file to be opened
 for writing by only one  FileOutputStream  (or other
 file-writing object) at a time.  In such situations the constructors in
 this class will fail if the file involved is already open.

  FileOutputStream  is meant for writing streams of raw bytes
 such as image data. For writing streams of characters consider using
  FileWriter ."
android,java.io,FileReader,0,"Convenience class for reading character files.  The constructors of this
 class assume that the default character encoding and the default byte-buffer
 size are appropriate.  To specify these values yourself construct an
 InputStreamReader on a FileInputStream.

  FileReader  is meant for reading streams of characters.
 For reading streams of raw bytes consider using a
  FileInputStream ."
android,java.io,ObjectStreamClass,8,"Serialization's descriptor for classes.  It contains the name and
 serialVersionUID of the class.  The ObjectStreamClass for a specific class
 loaded in this Java VM can be found/created using the lookup method.

  The algorithm to compute the SerialVersionUID is described in
  Object
 Serialization Specification Section 4.6 Stream Unique Identifiers ."
android,java.io,SerializablePermission,0,This legacy security is not supported on Android. Do not use.
android,java.io,StringWriter,11,"A character stream that collects its output in a string buffer which can
 then be used to construct a string.
  
 Closing a  StringWriter  has no effect. The methods in this class
 can be called after the stream has been closed without generating an
  IOException ."
android,java.io,ByteArrayInputStream,8,"A  ByteArrayInputStream  contains
 an internal buffer that contains bytes that
 may be read from the stream. An internal
 counter keeps track of the next byte to
 be supplied by the  read  method.
  
 Closing a  ByteArrayInputStream  has no effect. The methods in
 this class can be called after the stream has been closed without
 generating an  IOException ."
android,java.io,FileDescriptor,2,"Instances of the file descriptor class serve as an opaque handle
 to the underlying machine-specific structure representing an open
 file an open socket or another source or sink of bytes. The
 main practical use for a file descriptor is to create a
  FileInputStream  or  FileOutputStream  to
 contain it.
  
 Applications should not create their own file descriptors."
android,java.io,FilePermission,2,Legacy security code; do not use.
android,java.io,FilterInputStream,9,"A  FilterInputStream  contains
 some other input stream which it uses as
 its  basic source of data possibly transforming
 the data along the way or providing  additional
 functionality. The class  FilterInputStream 
 itself simply overrides all  methods of
  InputStream  with versions that
 pass all requests to the contained  input
 stream. Subclasses of  FilterInputStream 
 may further override some of  these methods
 and may also provide additional methods
 and fields."
android,java.io,InputStream,9,"This abstract class is the superclass of all classes representing
 an input stream of bytes.

   Applications that need to define a subclass of  InputStream 
 must always provide a method that returns the next byte of input."
android,java.io,LineNumberReader,8,"A buffered character-input stream that keeps track of line numbers.  This
 class defines methods  setLineNumber(int)  and  getLineNumber()  for setting and getting the current line number
 respectively.

   By default line numbering begins at 0. This number increments at every
  line terminator  as the data is read and can be changed
 with a call to  setLineNumber(int) .  Note however that
  setLineNumber(int)  does not actually change the current position in
 the stream; it only changes the value that will be returned by
  getLineNumber() .

   A line is considered to be  terminated  by any one of a
 line feed ('\n') a carriage return ('\r') or a carriage return followed
 immediately by a linefeed."
android,java.io,ObjectOutputStream,31,"An ObjectOutputStream writes primitive data types and graphs of Java objects
 to an OutputStream.  The objects can be read (reconstituted) using an
 ObjectInputStream.  Persistent storage of objects can be accomplished by
 using a file for the stream.  If the stream is a network socket stream the
 objects can be reconstituted on another host or in another process.

  Only objects that support the java.io.Serializable interface can be
 written to streams.  The class of each serializable object is encoded
 including the class name and signature of the class the values of the
 object's fields and arrays and the closure of any other objects referenced
 from the initial objects.

  The method writeObject is used to write an object to the stream.  Any
 object including Strings and arrays is written with writeObject. Multiple
 objects or primitives can be written to the stream.  The objects must be
 read back from the corresponding ObjectInputstream with the same types and
 in the same order as they were written.

  Primitive data types can also be written to the stream using the
 appropriate methods from DataOutput. Strings can also be written using the
 writeUTF method.

  The default serialization mechanism for an object writes the class of the
 object the class signature and the values of all non-transient and
 non-static fields.  References to other objects (except in transient or
 static fields) cause those objects to be written also. Multiple references
 to a single object are encoded using a reference sharing mechanism so that
 graphs of objects can be restored to the same shape as when the original was
 written.

  For example to write an object that can be read by the example in
 ObjectInputStream:
  
      FileOutputStream fos = new FileOutputStream(""t.tmp"");
      ObjectOutputStream oos = new ObjectOutputStream(fos);

      oos.writeInt(12345);
      oos.writeObject(""Today"");
      oos.writeObject(new Date());

      oos.close();
  Classes that require special handling during the serialization and
 deserialization process must implement special methods with these exact
 signatures:
  
 private void readObject(java.io.ObjectInputStream stream)
     throws IOException ClassNotFoundException;
 private void writeObject(java.io.ObjectOutputStream stream)
     throws IOException
 private void readObjectNoData()
     throws ObjectStreamException;
  The writeObject method is responsible for writing the state of the object
 for its particular class so that the corresponding readObject method can
 restore it.  The method does not need to concern itself with the state
 belonging to the object's superclasses or subclasses.  State is saved by
 writing the individual fields to the ObjectOutputStream using the
 writeObject method or by using the methods for primitive data types
 supported by DataOutput.

  Serialization does not write out the fields of any object that does not
 implement the java.io.Serializable interface.  Subclasses of Objects that
 are not serializable can be serializable. In this case the non-serializable
 class must have a no-arg constructor to allow its fields to be initialized.
 In this case it is the responsibility of the subclass to save and restore
 the state of the non-serializable class. It is frequently the case that the
 fields of that class are accessible (public package or protected) or that
 there are get and set methods that can be used to restore the state.

  Serialization of an object can be prevented by implementing writeObject
 and readObject methods that throw the NotSerializableException.  The
 exception will be caught by the ObjectOutputStream and abort the
 serialization process.

  Implementing the Externalizable interface allows the object to assume
 complete control over the contents and format of the object's serialized
 form.  The methods of the Externalizable interface writeExternal and
 readExternal are called to save and restore the objects state.  When
 implemented by a class they can write and read their own state using all of
 the methods of ObjectOutput and ObjectInput.  It is the responsibility of
 the objects to handle any versioning that occurs.

  Enum constants are serialized differently than ordinary serializable or
 externalizable objects.  The serialized form of an enum constant consists
 solely of its name; field values of the constant are not transmitted.  To
 serialize an enum constant ObjectOutputStream writes the string returned by
 the constant's name method.  Like other serializable or externalizable
 objects enum constants can function as the targets of back references
 appearing subsequently in the serialization stream.  The process by which
 enum constants are serialized cannot be customized; any class-specific
 writeObject and writeReplace methods defined by enum types are ignored
 during serialization.  Similarly any serialPersistentFields or
 serialVersionUID field declarations are also ignored--all enum types have a
 fixed serialVersionUID of 0L.

  Primitive data excluding serializable fields and externalizable data is
 written to the ObjectOutputStream in block-data records. A block data record
 is composed of a header and data. The block data header consists of a marker
 and the number of bytes to follow the header.  Consecutive primitive data
 writes are merged into one block-data record.  The blocking factor used for
 a block-data record will be 1024 bytes.  Each block-data record will be
 filled up to 1024 bytes or be written whenever there is a termination of
 block-data mode.  Calls to the ObjectOutputStream methods writeObject
 defaultWriteObject and writeFields initially terminate any existing
 block-data record."
android,java.io,ObjectOutputStream.PutField,10,"Provide programmatic access to the persistent fields to be written
 to ObjectOutput."
android,java.io,PipedInputStream,6,"A piped input stream should be connected
 to a piped output stream; the piped  input
 stream then provides whatever data bytes
 are written to the piped output  stream.
 Typically data is read from a  PipedInputStream 
 object by one thread  and data is written
 to the corresponding  PipedOutputStream 
 by some  other thread. Attempting to use
 both objects from a single thread is not
 recommended as it may deadlock the thread.
 The piped input stream contains a buffer
 decoupling read operations from write operations
 within limits.
 A pipe is said to be  broken  if a
 thread that was providing data bytes to the connected
 piped output stream is no longer alive."
android,java.io,PipedOutputStream,5,"A piped output stream can be connected to a piped input stream
 to create a communications pipe. The piped output stream is the
 sending end of the pipe. Typically data is written to a
  PipedOutputStream  object by one thread and data is
 read from the connected  PipedInputStream  by some
 other thread. Attempting to use both objects from a single thread
 is not recommended as it may deadlock the thread.
 The pipe is said to be  broken  if a
 thread that was reading data bytes from the connected piped input
 stream is no longer alive."
android,java.io,PipedReader,5,Piped character-input streams.
android,java.io,PrintStream,33,"A  PrintStream  adds functionality to another output stream
 namely the ability to print representations of various data values
 conveniently.  Two other features are provided as well.  Unlike other output
 streams a  PrintStream  never throws an
  IOException ; instead exceptional situations merely set an
 internal flag that can be tested via the  checkError  method.
 Optionally a  PrintStream  can be created so as to flush
 automatically; this means that the  flush  method is
 automatically invoked after a byte array is written one of the
  println  methods is invoked or a newline character or byte
 ( '\n' ) is written.

   All characters printed by a  PrintStream  are converted into
 bytes using the platform's default character encoding.  The  PrintWriter  class should be used in situations that require writing
 characters rather than bytes."
android,java.io,PushbackReader,11,"A character-stream reader that allows characters to be pushed back into the
 stream."
android,java.io,Reader,10,"Abstract class for reading character streams.  The only methods that a
 subclass must implement are read(char[] int int) and close().  Most
 subclasses however will override some of the methods defined here in order
 to provide higher efficiency additional functionality or both."
android,java.io,StreamTokenizer,16,"The  StreamTokenizer  class takes an input stream and
 parses it into ""tokens"" allowing the tokens to be
 read one at a time. The parsing process is controlled by a table
 and a number of flags that can be set to various states. The
 stream tokenizer can recognize identifiers numbers quoted
 strings and various comment styles.
  
 Each byte read from the input stream is regarded as a character
 in the range  '\u0000'  through  '\u00FF' .
 The character value is used to look up five possible attributes of
 the character:  white space   alphabetic 
  numeric   string quote  and  comment character .
 Each character can have zero or more of these attributes.
  
 In addition an instance has four flags. These flags indicate:
  Whether line terminators are to be returned as tokens or treated
     as white space that merely separates tokens.
  Whether C-style comments are to be recognized and skipped.
  Whether C++-style comments are to be recognized and skipped.
  Whether the characters of identifiers are converted to lowercase.
  
 A typical application first constructs an instance of this class
 sets up the syntax tables and then repeatedly loops calling the
  nextToken  method in each iteration of the loop until
 it returns the value  TT_EOF ."
android,java.io,StringBufferInputStream,5,"This class allows an application to create an input stream in
 which the bytes read are supplied by the contents of a string.
 Applications can also read bytes from a byte array by using a
  ByteArrayInputStream .
  
 Only the low eight bits of each character in the string are used by
 this class."
android,java.io,Writer,10,"Abstract class for writing to character streams.  The only methods that a
 subclass must implement are write(char[] int int) flush() and close().
 Most subclasses however will override some of the methods defined here in
 order to provide higher efficiency additional functionality or both."
android,java.io,BufferedOutputStream,3,"The class implements a buffered output stream. By setting up such
 an output stream an application can write bytes to the underlying
 output stream without necessarily causing a call to the underlying
 system for each byte written."
android,java.io,CharArrayWriter,13,"This class implements a character buffer that can be used as an Writer.
 The buffer automatically grows when data is written to the stream.  The data
 can be retrieved using toCharArray() and toString().
  
 Note: Invoking close() on this class has no effect and methods
 of this class can be called after the stream has closed
 without generating an IOException."
android,java.io,DataOutputStream,15,"A data output stream lets an application write primitive Java data
 types to an output stream in a portable way. An application can
 then use a data input stream to read the data back in."
android,java.io,File,50,"An abstract representation of file and directory pathnames.

   User interfaces and operating systems use system-dependent  pathname
 strings  to name files and directories.  This class presents an
 abstract system-independent view of hierarchical pathnames.  An
  abstract pathname  has two components:

   An optional system-dependent  prefix  string
      such as a disk-drive specifier  ""/"" Â for the UNIX root
      directory or  ""\\\"" Â for a Microsoft Windows UNC pathname and
   A sequence of zero or more string  names .
  empty  The conversion of a pathname string to or from an abstract pathname is
 inherently system-dependent.  When an abstract pathname is converted into a
 pathname string each name is separated from the next by a single copy of
 the default  separator character .  The default name-separator
 character is defined by the system property  file.separator  and
 is made available in the public static fields  separator  and  separatorChar  of this class.
 When a pathname string is converted into an abstract pathname the names
 within it may be separated by the default name-separator character or by any
 other name-separator character that is supported by the underlying system.

   A pathname whether abstract or in string form may be either
  absolute  or  relative .  An absolute pathname is complete in
 that no other information is required in order to locate the file that it
 denotes.  A relative pathname in contrast must be interpreted in terms of
 information taken from some other pathname.  By default the classes in the
  java.io  package always resolve relative pathnames against the
 current user directory.  This directory is named by the system property
  user.dir  and is typically the directory in which the Java
 virtual machine was invoked.

   The  parent  of an abstract pathname may be obtained by invoking
 the  getParent()  method of this class and consists of the pathname's
 prefix and each name in the pathname's name sequence except for the last.
 Each directory's absolute pathname is an ancestor of any  File 
 object with an absolute abstract pathname which begins with the directory's
 absolute pathname.  For example the directory denoted by the abstract
 pathname  ""/usr""  is an ancestor of the directory denoted by the
 pathname  ""/usr/local/bin"" .

   The prefix concept is used to handle root directories on UNIX platforms
 and drive specifiers root directories and UNC pathnames on Microsoft Windows platforms
 as follows:

   For UNIX platforms the prefix of an absolute pathname is always
  ""/"" .  Relative pathnames have no prefix.  The abstract pathname
 denoting the root directory has the prefix  ""/""  and an empty
 name sequence.

   For Microsoft Windows platforms the prefix of a pathname that contains a drive
 specifier consists of the drive letter followed by  "":""  and
 possibly followed by  ""\\""  if the pathname is absolute.  The
 prefix of a UNC pathname is  ""\\\"" ; the hostname and the share
 name are the first two names in the name sequence.  A relative pathname that
 does not specify a drive has no prefix.

   Instances of this class may or may not denote an actual file-system
 object such as a file or a directory.  If it does denote such an object
 then that object resides in a  partition .  A partition is an
 operating system-specific portion of storage for a file system.  A single
 storage device (e.g. a physical disk-drive flash memory CD-ROM) may
 contain multiple partitions.  The object if any will reside on the
 partition  named  by some ancestor of the absolute
 form of this pathname.

   A file system may implement restrictions to certain operations on the
 actual file-system object such as reading writing and executing.  These
 restrictions are collectively known as  access permissions .  The file
 system may have multiple sets of access permissions on a single object.
 For example one set may apply to the object's  owner  and another
 may apply to all other users.  The access permissions on an object may
 cause some methods in this class to fail.

   Instances of the  File  class are immutable; that is once
 created the abstract pathname represented by a  File  object
 will never change.

  Interoperability with  java.nio.file  package  The  java.nio.file 
 package defines interfaces and classes for the Java virtual machine to access
 files file attributes and file systems. This API may be used to overcome
 many of the limitations of the  java.io.File  class.
 The  toPath  method may be used to obtain a  Path  that uses the abstract path represented by a  File  object to
 locate a file. The resulting  Path  may be used with the  Files  class to provide more efficient and extensive access to
 additional file operations file attributes and I/O exceptions to help
 diagnose errors when an operation on a file fails.

  On Android strings are converted to UTF-8 byte sequences when sending filenames to
 the operating system and byte sequences returned by the operating system (from the
 various  list  methods) are converted to strings by decoding them as UTF-8
 byte sequences."
android,java.io,FileWriter,0,"Convenience class for writing character files.  The constructors of this
 class assume that the default character encoding and the default byte-buffer
 size are acceptable.  To specify these values yourself construct an
 OutputStreamWriter on a FileOutputStream.

  Whether or not a file is available or may be created depends upon the
 underlying platform.  Some platforms in particular allow a file to be
 opened for writing by only one  FileWriter  (or other file-writing
 object) at a time.  In such situations the constructors in this class
 will fail if the file involved is already open.

  FileWriter  is meant for writing streams of characters.
 For writing streams of raw bytes consider using a
  FileOutputStream ."
android,java.io,OutputStream,5,"This abstract class is the superclass of all classes representing
 an output stream of bytes. An output stream accepts output bytes
 and sends them to some sink.
  
 Applications that need to define a subclass of
  OutputStream  must always provide at least a method
 that writes one byte of output."
android,java.io,RandomAccessFile,40,"Instances of this class support both reading and writing to a
 random access file. A random access file behaves like a large
 array of bytes stored in the file system. There is a kind of cursor
 or index into the implied array called the  file pointer ;
 input operations read bytes starting at the file pointer and advance
 the file pointer past the bytes read. If the random access file is
 created in read/write mode then output operations are also available;
 output operations write bytes starting at the file pointer and advance
 the file pointer past the bytes written. Output operations that write
 past the current end of the implied array cause the array to be
 extended. The file pointer can be read by the
  getFilePointer  method and set by the  seek 
 method.
  
 It is generally true of all the reading routines in this class that
 if end-of-file is reached before the desired number of bytes has been
 read an  EOFException  (which is a kind of
  IOException ) is thrown. If any byte cannot be read for
 any reason other than end-of-file an  IOException  other
 than  EOFException  is thrown. In particular an
  IOException  may be thrown if the stream has been closed."
android,java.io,SequenceInputStream,4,"A  SequenceInputStream  represents
 the logical concatenation of other input
 streams. It starts out with an ordered
 collection of input streams and reads from
 the first one until end of file is reached
 whereupon it reads from the second one
 and so on until end of file is reached
 on the last of the contained input streams."
android,java.io,StringReader,8,A character stream whose source is a string.
android,java.math,BigDecimal,60,"An immutable arbitrary-precision signed decimal.

  A value is represented by an arbitrary-precision ""unscaled value"" and a signed 32-bit ""scale""
 combined thus:  unscaled * 10<sup>-scale</sup> . See  unscaledValue()  and  scale() .

  Most operations allow you to supply a  MathContext  to specify a desired rounding mode."
android,java.math,BigInteger,44,"An immutable arbitrary-precision signed integer.

  Fast Cryptography Slow Two's Complement Bitwise Operations BitSet"
android,java.math,MathContext,5,"Immutable objects describing settings such as rounding mode and digit
 precision for the numerical operations provided by class  BigDecimal ."
android,java.nio.channels.spi,AbstractInterruptibleChannel,5,"Base implementation class for interruptible channels.

   This class encapsulates the low-level machinery required to implement
 the asynchronous closing and interruption of channels.  A concrete channel
 class must invoke the  begin  and  end  methods
 before and after respectively invoking an I/O operation that might block
 indefinitely.  In order to ensure that the  end  method is always
 invoked these methods should be used within a
  try Â ...Â  finally  block:

  
 boolean completed = false;
 try {
     begin();
     completed = ...;    // Perform blocking I/O operation
     return ...;         // Return result
 } finally {
     end(completed);
 }  The  completed  argument to the  end  method tells
 whether or not the I/O operation actually completed that is whether it had
 any effect that would be visible to the invoker.  In the case of an
 operation that reads bytes for example this argument should be
  true  if and only if some bytes were actually transferred into the
 invoker's target buffer.

   A concrete channel class must also implement the  implCloseChannel  method in such a way that if it is
 invoked while another thread is blocked in a native I/O operation upon the
 channel then that operation will immediately return either by throwing an
 exception or by returning normally.  If a thread is interrupted or the
 channel upon which it is blocked is asynchronously closed then the channel's
  end  method will throw the appropriate exception.

   This class performs the synchronization required to implement the  Channel  specification.  Implementations of the  implCloseChannel  method need not synchronize against
 other threads that might be attempting to close the channel."
android,java.nio.channels.spi,AbstractSelectableChannel,10,"Base implementation class for selectable channels.

   This class defines methods that handle the mechanics of channel
 registration deregistration and closing.  It maintains the current
 blocking mode of this channel as well as its current set of selection keys.
 It performs all of the synchronization required to implement the  SelectableChannel  specification.  Implementations of the
 abstract protected methods defined in this class need not synchronize
 against other threads that might be engaged in the same operations."
android,java.nio.channels.spi,AbstractSelectionKey,2,"Base implementation class for selection keys.

   This class tracks the validity of the key and implements cancellation."
android,java.nio.channels.spi,AbstractSelector,9,"Base implementation class for selectors.

   This class encapsulates the low-level machinery required to implement
 the interruption of selection operations.  A concrete selector class must
 invoke the  begin  and  end  methods before and
 after respectively invoking an I/O operation that might block
 indefinitely.  In order to ensure that the  end  method is always
 invoked these methods should be used within a
  try Â ...Â  finally  block:

  
 try {
     begin();
     // Perform blocking I/O operation here
     ...
 } finally {
     end();
 }  This class also defines methods for maintaining a selector's
 cancelled-key set and for removing a key from its channel's key set and
 declares the abstract  register  method that is invoked by a
 selectable channel's  AbstractSelectableChannel#register 
 method in order to perform the actual work of registering a channel."
android,java.nio.channels.spi,AsynchronousChannelProvider,5,"Service-provider class for asynchronous channels.

   An asynchronous channel provider is a concrete subclass of this class that
 has a zero-argument constructor and implements the abstract methods specified
 below.  A given invocation of the Java virtual machine maintains a single
 system-wide default provider instance which is returned by the  provider  method.  The first invocation of that method will locate
 the default provider as specified below.

   All of the methods in this class are safe for use by multiple concurrent
 threads."
android,java.nio.channels.spi,SelectorProvider,8,"Service-provider class for selectors and selectable channels.

   A selector provider is a concrete subclass of this class that has a
 zero-argument constructor and implements the abstract methods specified
 below.  A given invocation of the Java virtual machine maintains a single
 system-wide default provider instance which is returned by the  provider  method.  The first invocation of that method will locate
 the default provider as specified below.

   The system-wide default provider is used by the static  open 
 methods of the  DatagramChannel   Pipe   Selector   ServerSocketChannel  and  SocketChannel  classes.  It is also
 used by the  System.inheritedChannel() 
 method. A program may make use of a provider other than the default provider
 by instantiating that provider and then directly invoking the  open 
 methods defined in this class.

   All of the methods in this class are safe for use by multiple concurrent
 threads."
android,java.nio.channels,AsynchronousChannelGroup,9,"A grouping of asynchronous channels for the purpose of resource sharing.

   An asynchronous channel group encapsulates the mechanics required to
 handle the completion of I/O operations initiated by  AsynchronousChannel  that are bound to the group. A group has an associated
 thread pool to which tasks are submitted to handle I/O events and dispatch to
  CompletionHandler  that consume the result of
 asynchronous operations performed on channels in the group. In addition to
 handling I/O events the pooled threads may also execute other tasks required
 to support the execution of asynchronous I/O operations.

   An asynchronous channel group is created by invoking the  withFixedThreadPool  or  withCachedThreadPool  methods defined here. Channels are bound to a group by
 specifying the group when constructing the channel. The associated thread
 pool is  owned  by the group; termination of the group results in the
 shutdown of the associated thread pool.

   In addition to groups created explicitly the Java virtual machine
 maintains a system-wide  default group  that is constructed
 automatically. Asynchronous channels that do not specify a group at
 construction time are bound to the default group. The default group has an
 associated thread pool that creates new threads as needed. The default group
 may be configured by means of system properties defined in the table below.
 Where the  ThreadFactory  for the
 default group is not configured then the pooled threads of the default group
 are  Thread#isDaemon  threads.

  System property Description java.nio.channels.DefaultThreadPool.threadFactory  The value of this property is taken to be the fully-qualified name
     of a concrete  ThreadFactory 
     class. The class is loaded using the system class loader and instantiated.
     The factory's  newThread  method is invoked to create each thread for the default
     group's thread pool. If the process to load and instantiate the value
     of the property fails then an unspecified error is thrown during the
     construction of the default group.  java.nio.channels.DefaultThreadPool.initialSize  The value of the  initialSize  parameter for the default
     group (see  withCachedThreadPool ).
     The value of the property is taken to be the  String 
     representation of an  Integer  that is the initial size parameter.
     If the value cannot be parsed as an  Integer  it causes an
     unspecified error to be thrown during the construction of the default
     group."
android,java.nio.channels,AsynchronousFileChannel,15,"An asynchronous channel for reading writing and manipulating a file.

   An asynchronous file channel is created when a file is opened by invoking
 one of the  open  methods defined by this class. The file contains
 a variable-length sequence of bytes that can be read and written and whose
 current size can be  queried . The size of the file increases
 when bytes are written beyond its  current size; the size of the file decreases
 when it is  truncated .

   An asynchronous file channel does not have a  current position 
 within the file. Instead the file position is specified to each read and
 write method that initiates asynchronous operations. A  CompletionHandler 
 is specified as a parameter and is invoked to consume the result of the I/O
 operation. This class also defines read and write methods that initiate
 asynchronous operations returning a  Future  to represent the pending
 result of the operation. The  Future  may be used to check if the
 operation has completed wait for its completion and retrieve the result.

   In addition to read and write operations this class defines the
 following operations:   Updates made to a file may be  forced
   out  to the underlying storage device ensuring that data are not
   lost in the event of a system crash.    A region of a file may be  locked  against
   access by other programs.    An  AsynchronousFileChannel  is associated with a thread pool to
 which tasks are submitted to handle I/O events and dispatch to completion
 handlers that consume the results of I/O operations on the channel. The
 completion handler for an I/O operation initiated on a channel is guaranteed
 to be invoked by one of the threads in the thread pool (This ensures that the
 completion handler is run by a thread with the expected  identity ).
 Where an I/O operation completes immediately and the initiating thread is
 itself a thread in the thread pool then the completion handler may be invoked
 directly by the initiating thread. When an  AsynchronousFileChannel  is
 created without specifying a thread pool then the channel is associated with
 a system-dependent default thread pool that may be shared with other
 channels. The default thread pool is configured by the system properties
 defined by the  AsynchronousChannelGroup  class.

   Channels of this type are safe for use by multiple concurrent threads. The
  Channel#close  method may be invoked at any time as specified
 by the  Channel  interface. This causes all outstanding asynchronous
 operations on the channel to complete with the exception  AsynchronousCloseException . Multiple read and write operations may be
 outstanding at the same time. When multiple read and write operations are
 outstanding then the ordering of the I/O operations and the order that the
 completion handlers are invoked is not specified; they are not in particular
 guaranteed to execute in the order that the operations were initiated. The
  ByteBuffers  used when reading or writing are not
 safe for use by multiple concurrent I/O operations. Furthermore after an I/O
 operation is initiated then care should be taken to ensure that the buffer is
 not accessed until after the operation has completed.

   As with  FileChannel  the view of a file provided by an instance of
 this class is guaranteed to be consistent with other views of the same file
 provided by other instances in the same program.  The view provided by an
 instance of this class may or may not however be consistent with the views
 seen by other concurrently-running programs due to caching performed by the
 underlying operating system and delays induced by network-filesystem protocols.
 This is true regardless of the language in which these other programs are
 written and whether they are running on the same machine or on some other
 machine.  The exact nature of any such inconsistencies are system-dependent
 and are therefore unspecified."
android,java.nio.channels,AsynchronousServerSocketChannel,9,"An asynchronous channel for stream-oriented listening sockets.

   An asynchronous server-socket channel is created by invoking the
  open  method of this class.
 A newly-created asynchronous server-socket channel is open but not yet bound.
 It can be bound to a local address and configured to listen for connections
 by invoking the  bind  method. Once bound
 the  accept  method
 is used to initiate the accepting of connections to the channel's socket.
 An attempt to invoke the  accept  method on an unbound channel will
 cause a  NotYetBoundException  to be thrown.

   Channels of this type are safe for use by multiple concurrent threads
 though at most one accept operation can be outstanding at any time.
 If a thread initiates an accept operation before a previous accept operation
 has completed then an  AcceptPendingException  will be thrown.

   Socket options are configured using the  setOption  method. Channels of this type support the following options:
  Option Name Description SO_RCVBUF  The size of the socket receive buffer  SO_REUSEADDR  Re-use address  Usage Example: 
  final AsynchronousServerSocketChannel listener =
      AsynchronousServerSocketChannel.open().bind(new InetSocketAddress(5000));

  listener.accept(null new CompletionHandler<AsynchronousSocketChannelVoid>() {
      public void completed(AsynchronousSocketChannel ch Void att) {
          // accept the next connection
          listener.accept(null this);

          // handle this connection
          handle(ch);
      }
      public void failed(Throwable exc Void att) {
          ...
      }
  });"
android,java.nio.channels,AsynchronousSocketChannel,19,"An asynchronous channel for stream-oriented connecting sockets.

   Asynchronous socket channels are created in one of two ways. A newly-created
  AsynchronousSocketChannel  is created by invoking one of the  open  methods defined by this class. A newly-created channel is open but
 not yet connected. A connected  AsynchronousSocketChannel  is created
 when a connection is made to the socket of an  AsynchronousServerSocketChannel .
 It is not possible to create an asynchronous socket channel for an arbitrary
 pre-existing  socket .

   A newly-created channel is connected by invoking its  connect 
 method; once connected a channel remains connected until it is closed.  Whether
 or not a socket channel is connected may be determined by invoking its  getRemoteAddress  method. An attempt to invoke an I/O
 operation upon an unconnected channel will cause a  NotYetConnectedException 
 to be thrown.

   Channels of this type are safe for use by multiple concurrent threads.
 They support concurrent reading and writing though at most one read operation
 and one write operation can be outstanding at any time.
 If a thread initiates a read operation before a previous read operation has
 completed then a  ReadPendingException  will be thrown. Similarly an
 attempt to initiate a write operation before a previous write has completed
 will throw a  WritePendingException .

   Socket options are configured using the  setOption  method. Asynchronous socket channels support the following options:
  Option Name Description SO_SNDBUF  The size of the socket send buffer  SO_RCVBUF  The size of the socket receive buffer  SO_KEEPALIVE  Keep connection alive  SO_REUSEADDR  Re-use address  TCP_NODELAY  Disable the Nagle algorithm"
android,java.nio.channels,Channels,10,"Utility methods for channels and streams.

   This class defines static methods that support the interoperation of the
 stream classes of the  java.io  package with the channel
 classes of this package."
android,java.nio.channels,DatagramChannel,19,"A selectable channel for datagram-oriented sockets.

   A datagram channel is created by invoking one of the  open  methods
 of this class. It is not possible to create a channel for an arbitrary
 pre-existing datagram socket. A newly-created datagram channel is open but not
 connected. A datagram channel need not be connected in order for the  send  and  receive  methods to be used.  A datagram channel may be
 connected by invoking its  connect  method in order to
 avoid the overhead of the security checks are otherwise performed as part of
 every send and receive operation.  A datagram channel must be connected in
 order to use the  read  and  write  methods since those methods do not
 accept or return socket addresses.

   Once connected a datagram channel remains connected until it is
 disconnected or closed.  Whether or not a datagram channel is connected may
 be determined by invoking its  isConnected  method.

   Socket options are configured using the  setOption  method. A datagram channel to an Internet Protocol socket supports
 the following options:
  Option Name Description SO_SNDBUF  The size of the socket send buffer  SO_RCVBUF  The size of the socket receive buffer  SO_REUSEADDR  Re-use address  SO_BROADCAST  Allow transmission of broadcast datagrams  IP_TOS  The Type of Service (ToS) octet in the Internet Protocol (IP) header  IP_MULTICAST_IF  The network interface for Internet Protocol (IP) multicast datagrams  IP_MULTICAST_TTL  The  time-to-live  for Internet Protocol (IP) multicast
       datagrams  IP_MULTICAST_LOOP  Loopback for Internet Protocol (IP) multicast datagrams   Datagram channels are safe for use by multiple concurrent threads.  They
 support concurrent reading and writing though at most one thread may be
 reading and at most one thread may be writing at any given time."
android,java.nio.channels,FileChannel,22,"A channel for reading writing mapping and manipulating a file.

   A file channel is a  SeekableByteChannel  that is connected to
 a file. It has a current  position  within its file which can
 be both  queried  and  modified .  The file itself contains a variable-length sequence
 of bytes that can be read and written and whose current  size  can be queried.  The size of the file increases
 when bytes are written beyond its current size; the size of the file
 decreases when it is  truncated .  The
 file may also have some associated  metadata  such as access
 permissions content type and last-modification time; this class does not
 define methods for metadata access.

   In addition to the familiar read write and close operations of byte
 channels this class defines the following file-specific operations:   Bytes may be  read  or
    written  at an absolute
   position in a file in a way that does not affect the channel's current
   position.    A region of a file may be  mapped 
   directly into memory; for large files this is often much more efficient
   than invoking the usual  read  or  write  methods.
     Updates made to a file may be  forced
   out  to the underlying storage device ensuring that data are not
   lost in the event of a system crash.    Bytes can be transferred from a file  to
   some other channel  and  vice
   versa  in a way that can be optimized by many operating systems
   into a very fast transfer directly to or from the filesystem cache.
     A region of a file may be  FileLock 
   against access by other programs.    File channels are safe for use by multiple concurrent threads.  The
  Channel#close  method may be invoked at any time as specified
 by the  Channel  interface.  Only one operation that involves the
 channel's position or can change its file's size may be in progress at any
 given time; attempts to initiate a second such operation while the first is
 still in progress will block until the first operation completes.  Other
 operations in particular those that take an explicit position may proceed
 concurrently; whether they in fact do so is dependent upon the underlying
 implementation and is therefore unspecified.

   The view of a file provided by an instance of this class is guaranteed
 to be consistent with other views of the same file provided by other
 instances in the same program.  The view provided by an instance of this
 class may or may not however be consistent with the views seen by other
 concurrently-running programs due to caching performed by the underlying
 operating system and delays induced by network-filesystem protocols.  This
 is true regardless of the language in which these other programs are
 written and whether they are running on the same machine or on some other
 machine.  The exact nature of any such inconsistencies are system-dependent
 and are therefore unspecified.

   A file channel is created by invoking one of the  open 
 methods defined by this class. A file channel can also be obtained from an
 existing  FileInputStream   FileOutputStream  or  RandomAccessFile  object by invoking
 that object's  getChannel  method which returns a file channel that
 is connected to the same underlying file. Where the file channel is obtained
 from an existing stream or random access file then the state of the file
 channel is intimately connected to that of the object whose  getChannel 
 method returned the channel.  Changing the channel's position whether
 explicitly or by reading or writing bytes will change the file position of
 the originating object and vice versa. Changing the file's length via the
 file channel will change the length seen via the originating object and vice
 versa.  Changing the file's content by writing bytes will change the content
 seen by the originating object and vice versa.

   At various points this class specifies that an
 instance that is ""open for reading"" ""open for writing"" or ""open for
 reading and writing"" is required.  A channel obtained via the  getChannel  method of a  FileInputStream  instance will be open for reading.  A channel
 obtained via the  getChannel 
 method of a  FileOutputStream  instance will be open for
 writing.  Finally a channel obtained via the  getChannel  method of a  RandomAccessFile  instance will be open for reading if the instance
 was created with mode  ""r""  and will be open for reading and writing
 if the instance was created with mode  ""rw"" .

   A file channel that is open for writing may be in
  append mode  for example if it was obtained from a file-output stream
 that was created by invoking the  FileOutputStream(Fileboolean)  constructor and passing  true  for
 the second parameter.  In this mode each invocation of a relative write
 operation first advances the position to the end of the file and then writes
 the requested data.  Whether the advancement of the position and the writing
 of the data are done in a single atomic operation is system-dependent and
 therefore unspecified."
android,java.nio.channels,SelectionKey,13,"A token representing the registration of a  SelectableChannel  with a
  Selector .

   A selection key is created each time a channel is registered with a
 selector.  A key remains valid until it is  cancelled  by invoking its
  cancel  method by closing its channel or by closing its
 selector.  Cancelling a key does not immediately remove it from its
 selector; it is instead added to the selector's  cancelled-key set  for removal during the
 next selection operation.  The validity of a key may be tested by invoking
 its  isValid  method.

   A selection key contains two  operation sets  represented as
 integer values.  Each bit of an operation set denotes a category of
 selectable operations that are supported by the key's channel.

   The  interest set  determines which operation categories will
   be tested for readiness the next time one of the selector's selection
   methods is invoked.  The interest set is initialized with the value given
   when the key is created; it may later be changed via the  interestOps(int)  method.   The  ready set  identifies the operation categories for which
   the key's channel has been detected to be ready by the key's selector.
   The ready set is initialized to zero when the key is created; it may later
   be updated by the selector during a selection operation but it cannot be
   updated directly.   That a selection key's ready set indicates that its channel is ready for
 some operation category is a hint but not a guarantee that an operation in
 such a category may be performed by a thread without causing the thread to
 block.  A ready set is most likely to be accurate immediately after the
 completion of a selection operation.  It is likely to be made inaccurate by
 external events and by I/O operations that are invoked upon the
 corresponding channel.

   This class defines all known operation-set bits but precisely which
 bits are supported by a given channel depends upon the type of the channel.
 Each subclass of  SelectableChannel  defines an  SelectableChannel#validOps()  method which returns a set
 identifying just those operations that are supported by the channel.  An
 attempt to set or test an operation-set bit that is not supported by a key's
 channel will result in an appropriate run-time exception.

   It is often necessary to associate some application-specific data with a
 selection key for example an object that represents the state of a
 higher-level protocol and handles readiness notifications in order to
 implement that protocol.  Selection keys therefore support the
  attachment  of a single arbitrary object to a key.  An object can be
 attached via the  attach  method and then later retrieved via
 the  attachment  method.

   Selection keys are safe for use by multiple concurrent threads.  The
 operations of reading and writing the interest set will in general be
 synchronized with certain operations of the selector.  Exactly how this
 synchronization is performed is implementation-dependent: In a naive
 implementation reading or writing the interest set may block indefinitely
 if a selection operation is already in progress; in a high-performance
 implementation reading or writing the interest set may block briefly if at
 all.  In any case a selection operation will always use the interest-set
 value that was current at the moment that the operation began."
android,java.nio.channels,FileChannel.MapMode,1,A typesafe enumeration for file-mapping modes.
android,java.nio.channels,FileLock,10,"A token representing a lock on a region of a file.

   A file-lock object is created each time a lock is acquired on a file via
 one of the  FileChannel#lock(longlongboolean)  or  FileChannel#tryLock(longlongboolean)  methods of the
  FileChannel  class or the  AsynchronousFileChannel#lock(longlongbooleanObjectCompletionHandler) 
 or  AsynchronousFileChannel#tryLock(longlongboolean) 
 methods of the  AsynchronousFileChannel  class.

   A file-lock object is initially valid.  It remains valid until the lock
 is released by invoking the  release  method by closing the
 channel that was used to acquire it or by the termination of the Java
 virtual machine whichever comes first.  The validity of a lock may be
 tested by invoking its  isValid  method.

   A file lock is either  exclusive  or  shared .  A shared lock
 prevents other concurrently-running programs from acquiring an overlapping
 exclusive lock but does allow them to acquire overlapping shared locks.  An
 exclusive lock prevents other programs from acquiring an overlapping lock of
 either type.  Once it is released a lock has no further effect on the locks
 that may be acquired by other programs.

   Whether a lock is exclusive or shared may be determined by invoking its
  isShared  method.  Some platforms do not support shared
 locks in which case a request for a shared lock is automatically converted
 into a request for an exclusive lock.

   The locks held on a particular file by a single Java virtual machine do
 not overlap.  The  overlaps  method may be used to test
 whether a candidate lock range overlaps an existing lock.

   A file-lock object records the file channel upon whose file the lock is
 held the type and validity of the lock and the position and size of the
 locked region.  Only the validity of a lock is subject to change over time;
 all other aspects of a lock's state are immutable.

   File locks are held on behalf of the entire Java virtual machine.
 They are not suitable for controlling access to a file by multiple
 threads within the same virtual machine.

   File-lock objects are safe for use by multiple concurrent threads."
android,java.nio.channels,MembershipKey,8,"A token representing the membership of an Internet Protocol (IP) multicast
 group.

   A membership key may represent a membership to receive all datagrams sent
 to the group or it may be  source-specific  meaning that it
 represents a membership that receives only datagrams from a specific source
 address. Whether or not a membership key is source-specific may be determined
 by invoking its  sourceAddress  method.

   A membership key is valid upon creation and remains valid until the
 membership is dropped by invoking the  drop  method or
 the channel is closed. The validity of the membership key may be tested
 by invoking its  isValid  method.

   Where a membership key is not source-specific and the underlying operation
 system supports source filtering then the  block  and  unblock  methods can be used to block or unblock multicast datagrams
 from particular source addresses."
android,java.nio.channels,Pipe,3,"A pair of channels that implements a unidirectional pipe.

   A pipe consists of a pair of channels: A writable  Pipe.SinkChannel  channel and a readable  Pipe.SourceChannel 
 channel.  Once some bytes are written to the sink channel they can be read
 from source channel in exactlyAthe order in which they were written.

   Whether or not a thread writing bytes to a pipe will block until another
 thread reads those bytes or some previously-written bytes from the pipe is
 system-dependent and therefore unspecified.  Many pipe implementations will
 buffer up to a certain number of bytes between the sink and source channels
 but such buffering should not be assumed."
android,java.nio.channels,Pipe.SinkChannel,1,A channel representing the writable end of a  Pipe .
android,java.nio.channels,Pipe.SourceChannel,1,A channel representing the readable end of a  Pipe .
android,java.nio.channels,SelectableChannel,9,"A channel that can be multiplexed via a  Selector .

   In order to be used with a selector an instance of this class must
 first be  registered  via the  register  method.  This method returns a new  SelectionKey  object
 that represents the channel's registration with the selector.

   Once registered with a selector a channel remains registered until it
 is  deregistered .  This involves deallocating whatever resources were
 allocated to the channel by the selector.

   A channel cannot be deregistered directly; instead the key representing
 its registration must be  cancelled .  Cancelling a key requests that
 the channel be deregistered during the selector's next selection operation.
 A key may be cancelled explicitly by invoking its  SelectionKey#cancel()  method.  All of a channel's keys are cancelled
 implicitly when the channel is closed whether by invoking its  Channel#close  method or by interrupting a thread blocked in an I/O
 operation upon the channel.

   If the selector itself is closed then the channel will be deregistered
 and the key representing its registration will be invalidated without
 further delay.

   A channel may be registered at most once with any particular selector.

   Whether or not a channel is registered with one or more selectors may be
 determined by invoking the  isRegistered  method.

   Selectable channels are safe for use by multiple concurrent
 threads."
android,java.nio.channels,Selector,10,"A multiplexor of  SelectableChannel  objects.

   A selector may be created by invoking the  open  method of
 this class which will use the system's default  selector provider  to
 create a new selector.  A selector may also be created by invoking the
  openSelector 
 method of a custom selector provider.  A selector remains open until it is
 closed via its  close  method.

   A selectable channel's registration with a selector is represented by a
  SelectionKey  object.  A selector maintains three sets of selection
 keys:

   The  key set  contains the keys representing the current
   channel registrations of this selector.  This set is returned by the
    keys  method.   The  selected-key set  is the set of keys such that each
   key's channel was detected to be ready for at least one of the operations
   identified in the key's interest set during a prior selection operation.
   This set is returned by the  selectedKeys  method.
   The selected-key set is always a subset of the key set.   The  cancelled-key  set is the set of keys that have been
   cancelled but whose channels have not yet been deregistered.  This set is
   not directly accessible.  The cancelled-key set is always a subset of the
   key set.   All three sets are empty in a newly-created selector.

   A key is added to a selector's key set as a side effect of registering a
 channel via the channel's  SelectableChannel#register(Selectorint)  method.  Cancelled keys are removed from the key set during
 selection operations.  The key set itself is not directly modifiable.

   A key is added to its selector's cancelled-key set when it is cancelled
 whether by closing its channel or by invoking its  SelectionKey#cancel  method.  Cancelling a key will cause its channel to be deregistered
 during the next selection operation at which time the key will removed from
 all of the selector's key sets.

   Keys are added to the selected-key set by selection
 operations.  A key may be removed directly from the selected-key set by
 invoking the set's  remove 
 method or by invoking the  remove  method
 of an  iterator  obtained from the
 set.  Keys are never removed from the selected-key set in any other way;
 they are not in particular removed as a side effect of selection
 operations.  Keys may not be added directly to the selected-key set."
android,java.nio.channels,ServerSocketChannel,8,"A selectable channel for stream-oriented listening sockets.

   A server-socket channel is created by invoking the  open 
 method of this class.  It is not possible to create a channel for an arbitrary
 pre-existing  ServerSocket . A newly-created server-socket channel is
 open but not yet bound.  An attempt to invoke the  accept 
 method of an unbound server-socket channel will cause a  NotYetBoundException 
 to be thrown. A server-socket channel can be bound by invoking one of the
  bind  methods defined by this class.

   Socket options are configured using the  setOption  method. Server-socket channels support the following options:
  Option Name Description SO_RCVBUF  The size of the socket receive buffer  SO_REUSEADDR  Re-use address   Server-socket channels are safe for use by multiple concurrent threads."
android,java.nio.channels,SocketChannel,20,"A selectable channel for stream-oriented connecting sockets.

   A socket channel is created by invoking one of the  open 
 methods of this class.  It is not possible to create a channel for an arbitrary
 pre-existing socket. A newly-created socket channel is open but not yet
 connected.  An attempt to invoke an I/O operation upon an unconnected
 channel will cause a  NotYetConnectedException  to be thrown.  A
 socket channel can be connected by invoking its  connect 
 method; once connected a socket channel remains connected until it is
 closed.  Whether or not a socket channel is connected may be determined by
 invoking its  isConnected  method.

   Socket channels support  non-blocking connection: Â A socket
 channel may be created and the process of establishing the link to the
 remote socket may be initiated via the  connect  method for
 later completion by the  finishConnect  method.
 Whether or not a connection operation is in progress may be determined by
 invoking the  isConnectionPending  method.

   Socket channels support  asynchronous shutdown  which is similar
 to the asynchronous close operation specified in the  Channel  class.
 If the input side of a socket is shut down by one thread while another
 thread is blocked in a read operation on the socket's channel then the read
 operation in the blocked thread will complete without reading any bytes and
 will return  -1 .  If the output side of a socket is shut down by one
 thread while another thread is blocked in a write operation on the socket's
 channel then the blocked thread will receive an  AsynchronousCloseException .

   Socket options are configured using the  setOption  method. Socket channels support the following options:
  Option Name Description SO_SNDBUF  The size of the socket send buffer  SO_RCVBUF  The size of the socket receive buffer  SO_KEEPALIVE  Keep connection alive  SO_REUSEADDR  Re-use address  SO_LINGER  Linger on close if data is present (when configured in blocking mode
          only)  TCP_NODELAY  Disable the Nagle algorithm   Socket channels are safe for use by multiple concurrent threads.  They
 support concurrent reading and writing though at most one thread may be
 reading and at most one thread may be writing at any given time.  The  connect  and  finishConnect  methods are
 mutually synchronized against each other and an attempt to initiate a read
 or write operation while an invocation of one of these methods is in
 progress will block until that invocation is complete."
android,java.nio.charset,CharsetEncoder,22,"An engine that can transform a sequence of sixteen-bit Unicode characters into a sequence of
 bytes in a specific charset.

   The input character sequence is provided in a character buffer or a series
 of such buffers.  The output byte sequence is written to a byte buffer
 or a series of such buffers.  An encoder should always be used by making
 the following sequence of method invocations hereinafter referred to as an
  encoding operation :

   Reset the encoder via the  reset  method unless it
   has not been used before;   Invoke the  encode  method zero or more times as
   long as additional input may be available passing  false  for the
    endOfInput  argument and filling the input buffer and flushing the
   output buffer between invocations;   Invoke the  encode  method one final time passing
    true  for the  endOfInput  argument; and then   Invoke the  flush  method so that the encoder can
   flush any internal state to the output buffer.  encode encode CoderResult  There are two general types of encoding errors.  If the input character
 sequence is not a legal sixteen-bit Unicode sequence then the input is considered  malformed .  If
 the input character sequence is legal but cannot be mapped to a valid
 byte sequence in the given charset then an  unmappable character  has been encountered.

   How an encoding error is handled depends upon the action requested for
 that type of error which is described by an instance of the  CodingErrorAction  class.  The possible error actions are to  CodingErrorAction#IGNORE  the erroneous input  CodingErrorAction#REPORT  the error to the invoker via
 the returned  CoderResult  object or  CodingErrorAction#REPLACE  the erroneous input with the current value of the
 replacement byte array.  The replacement

 
 is initially set to the encoder's default replacement which often
 (but not always) has the initial valueÂ  { (byte)'?' } ;
 
 
 
 

 its value may be changed via the  replaceWith  method.

   The default action for malformed-input and unmappable-character errors
 is to  CodingErrorAction#REPORT  them.  The
 malformed-input error action may be changed via the  onMalformedInput  method; the
 unmappable-character action may be changed via the  onUnmappableCharacter  method.

   This class is designed to handle many of the details of the encoding
 process including the implementation of error actions.  An encoder for a
 specific charset which is a concrete subclass of this class need only
 implement the abstract  encodeLoop  method which
 encapsulates the basic encoding loop.  A subclass that maintains internal
 state should additionally override the  implFlush  and
  implReset  methods.

   Instances of this class are not safe for use by multiple concurrent
 threads."
android,java.nio.charset,Charset,20,"A named mapping between sequences of sixteen-bit Unicode  code units  and sequences of
 bytes.  This class defines methods for creating decoders and encoders and
 for retrieving the various names associated with a charset.  Instances of
 this class are immutable.

   This class also defines static methods for testing whether a particular
 charset is supported for locating charset instances by name and for
 constructing a map that contains every charset for which support is
 available in the current Java virtual machine.  Support for new charsets can
 be added via the service-provider interface defined in the  CharsetProvider  class.

   All of the methods defined in this class are safe for use by multiple
 concurrent threads."
android,java.nio.charset,CharsetDecoder,22,"An engine that can transform a sequence of bytes in a specific charset into a sequence of
 sixteen-bit Unicode characters.

   The input byte sequence is provided in a byte buffer or a series
 of such buffers.  The output character sequence is written to a character buffer
 or a series of such buffers.  A decoder should always be used by making
 the following sequence of method invocations hereinafter referred to as a
  decoding operation :

   Reset the decoder via the  reset  method unless it
   has not been used before;   Invoke the  decode  method zero or more times as
   long as additional input may be available passing  false  for the
    endOfInput  argument and filling the input buffer and flushing the
   output buffer between invocations;   Invoke the  decode  method one final time passing
    true  for the  endOfInput  argument; and then   Invoke the  flush  method so that the decoder can
   flush any internal state to the output buffer.  decode decode CoderResult  There are two general types of decoding errors.  If the input byte
 sequence is not legal for this charset then the input is considered  malformed .  If
 the input byte sequence is legal but cannot be mapped to a valid
 Unicode character then an  unmappable character  has been encountered.

   How a decoding error is handled depends upon the action requested for
 that type of error which is described by an instance of the  CodingErrorAction  class.  The possible error actions are to  CodingErrorAction#IGNORE  the erroneous input  CodingErrorAction#REPORT  the error to the invoker via
 the returned  CoderResult  object or  CodingErrorAction#REPLACE  the erroneous input with the current value of the
 replacement string.  The replacement

 
 
 
 
 
 has the initial value  ""\uFFFD"" ;
 

 its value may be changed via the  replaceWith  method.

   The default action for malformed-input and unmappable-character errors
 is to  CodingErrorAction#REPORT  them.  The
 malformed-input error action may be changed via the  onMalformedInput  method; the
 unmappable-character action may be changed via the  onUnmappableCharacter  method.

   This class is designed to handle many of the details of the decoding
 process including the implementation of error actions.  A decoder for a
 specific charset which is a concrete subclass of this class need only
 implement the abstract  decodeLoop  method which
 encapsulates the basic decoding loop.  A subclass that maintains internal
 state should additionally override the  implFlush  and
  implReset  methods.

   Instances of this class are not safe for use by multiple concurrent
 threads."
android,java.nio.charset,CoderResult,10,"A description of the result state of a coder.

   A charset coder that is either a decoder or an encoder consumes bytes
 (or characters) from an input buffer translates them and writes the
 resulting characters (or bytes) to an output buffer.  A coding process
 terminates for one of four categories of reasons which are described by
 instances of this class:

  Underflow  is reported when there is no more input to be
   processed or there is insufficient input and additional input is
   required.  This condition is represented by the unique result object
    UNDERFLOW  whose  isUnderflow  method
   returns  true .   Overflow  is reported when there is insufficient room
   remaining in the output buffer.  This condition is represented by the
   unique result object  OVERFLOW  whose  isOverflow  method returns  true .    A  malformed-input error  is reported when a sequence of
   input units is not well-formed.  Such errors are described by instances of
   this class whose  isMalformed  method returns
    true  and whose  length  method returns the length
   of the malformed sequence.  There is one unique instance of this class for
   all malformed-input errors of a given length.    An  unmappable-character error  is reported when a sequence
   of input units denotes a character that cannot be represented in the
   output charset.  Such errors are described by instances of this class
   whose  isUnmappable  method returns  true  and
   whose  length  method returns the length of the input
   sequence denoting the unmappable character.  There is one unique instance
   of this class for all unmappable-character errors of a given length.
     For convenience the  isError  method returns  true 
 for result objects that describe malformed-input and unmappable-character
 errors but  false  for those that describe underflow or overflow
 conditions."
android,java.nio.charset,CodingErrorAction,1,"A typesafe enumeration for coding-error actions.

   Instances of this class are used to specify how malformed-input and
 unmappable-character errors are to be handled by charset  decoders  and  encoders ."
android,java.nio.charset,StandardCharsets,0,"Constant definitions for the standard  Charset . These
 charsets are guaranteed to be available on every implementation of the Java
 platform."
android,java.nio.charset.spi,CharsetProvider,2,"Charset service-provider class.

   A charset provider is a concrete subclass of this class that has a
 zero-argument constructor and some number of associated charset
 implementation classes.  Charset providers may be installed in an instance
 of the Java platform as extensions that is jar files placed into any of
 the usual extension directories.  Providers may also be made available by
 adding them to the applet or application class path or by some other
 platform-specific means.  Charset providers are looked up via the current
 thread's  context class
 loader .

   A charset provider identifies itself with a provider-configuration file
 named  java.nio.charset.spi.CharsetProvider  in the resource
 directory  META-INF/services .  The file should contain a list of
 fully-qualified concrete charset-provider class names one per line.  A line
 is terminated by any one of a line feed ( '\n' ) a carriage return
 ( '\r' ) or a carriage return followed immediately by a line feed.
 Space and tab characters surrounding each name as well as blank lines are
 ignored.  The comment character is  '#'  ( '\u0023' ); on
 each line all characters following the first comment character are ignored.
 The file must be encoded in UTF-8.

   If a particular concrete charset provider class is named in more than
 one configuration file or is named in the same configuration file more than
 once then the duplicates will be ignored.  The configuration file naming a
 particular provider need not be in the same jar file or other distribution
 unit as the provider itself.  The provider must be accessible from the same
 class loader that was initially queried to locate the configuration file;
 this is not necessarily the class loader that loaded the file."
android,java.nio.file,Files,65,"This class consists exclusively of static methods that operate on files
 directories or other types of files.

   In most cases the methods defined here will delegate to the associated
 file system provider to perform the file operations."
android,java.nio.file,FileStore,10,"Storage for files. A  FileStore  represents a storage pool device
 partition volume concrete file system or other implementation specific means
 of file storage. The  FileStore  for where a file is stored is obtained
 by invoking the  Files#getFileStore  method or all file
 stores can be enumerated by invoking the  FileSystem#getFileStores  method.

   In addition to the methods defined by this class a file store may support
 one or more  FileStoreAttributeView  classes
 that provide a read-only or updatable view of a set of file store attributes."
android,java.nio.file,FileSystem,12,"Provides an interface to a file system and is the factory for objects to
 access files and other objects in the file system.

   The default file system obtained by invoking the  FileSystems#getDefault  method provides access to the file system that is
 accessible to the Java virtual machine. The  FileSystems  class defines
 methods to create file systems that provide access to other types of (custom)
 file systems.

   A file system is the factory for several types of objects:

   The  getPath  method converts a system dependent
      path string  returning a  Path  object that may be used
     to locate and access a file.   The  getPathMatcher  method is used
     to create a  PathMatcher  that performs match operations on
     paths.   The  getFileStores  method returns an iterator
     over the underlying  FileStore .   The  getUserPrincipalLookupService 
     method returns the  UserPrincipalLookupService  to lookup users or
     groups by name.   The  newWatchService  method creates a
      WatchService  that may be used to watch objects for changes and
     events.   File systems vary greatly. In some cases the file system is a single
 hierarchy of files with one top-level root directory. In other cases it may
 have several distinct file hierarchies each with its own top-level root
 directory. The  getRootDirectories  method may be
 used to iterate over the root directories in the file system. A file system
 is typically composed of one or more underlying  FileStore 
 that provide the storage for the files. Theses file stores can also vary in
 the features they support and the file attributes or  meta-data  that
 they associate with files.

   A file system is open upon creation and can be closed by invoking its
  close  method. Once closed any further attempt to access
 objects in the file system cause  ClosedFileSystemException  to be
 thrown. File systems created by the default  FileSystemProvider 
 cannot be closed.

   A  FileSystem  can provide read-only or read-write access to the
 file system. Whether or not a file system provides read-only access is
 established when the  FileSystem  is created and can be tested by invoking
 its  isReadOnly  method. Attempts to write to file stores
 by means of an object associated with a read-only file system throws  ReadOnlyFileSystemException .

   File systems are safe for use by multiple concurrent threads. The  close  method may be invoked at any time to close a file system but
 whether a file system is  asynchronously closeable  is provider specific
 and therefore unspecified. In other words if a thread is accessing an
 object in a file system and another thread invokes the  close  method
 then it may require to block until the first operation is complete. Closing
 a file system causes all open channels watch services and other  Closeable  objects associated with the file system to be closed."
android,java.nio.file,FileSystems,5,"Factory methods for file systems. This class defines the  getDefault  method to get the default file system and factory methods to
 construct other types of file systems.

   The first invocation of any of the methods defined by this class causes
 the default  FileSystemProvider  to be loaded. The default
 provider identified by the URI scheme ""file"" creates the  FileSystem 
 that provides access to the file systems accessible to the Java virtual
 machine. If the process of loading or initializing the default provider fails
 then an unspecified error is thrown.

   The first invocation of the  FileSystemProvider#installedProviders  method by way of invoking any of the  newFileSystem  methods defined by this class locates and loads all
 installed file system providers. Installed providers are loaded using the
 service-provider loading facility defined by the  ServiceLoader  class.
 Installed providers are loaded using the system class loader. If the
 system class loader cannot be found then the extension class loader is used;
 if there is no extension class loader then the bootstrap class loader is used.
 Providers are typically installed by placing them in a JAR file on the
 application class path or in the extension directory the JAR file contains a
 provider-configuration file named  java.nio.file.spi.FileSystemProvider 
 in the resource directory  META-INF/services  and the file lists one or
 more fully-qualified names of concrete subclass of  FileSystemProvider 
 that have a zero argument constructor.
 The ordering that installed providers are located is implementation specific.
 If a provider is instantiated and its  FileSystemProvider#getScheme()  returns the same URI scheme of a provider that was previously
 instantiated then the most recently instantiated duplicate is discarded. URI
 schemes are compared without regard to case. During construction a provider
 may safely access files associated with the default provider but care needs
 to be taken to avoid circular loading of other installed providers. If
 circular loading of installed providers is detected then an unspecified error
 is thrown.

   This class also defines factory methods that allow a  ClassLoader 
 to be specified when locating a provider. As with installed providers the
 provider classes are identified by placing the provider configuration file
 in the resource directory  META-INF/services .

   If a thread initiates the loading of the installed file system providers
 and another thread invokes a method that also attempts to load the providers
 then the method will block until the loading completes."
android,java.nio.file,LinkPermission,0,"The  Permission  class for link creation operations.

   The following table provides a summary description of what the permission
 allows and discusses the risks of granting code the permission.

  Permission Target Name What the Permission Allows Risks of Allowing this Permission hard  Ability to add an existing file to a directory. This is sometimes
   known as creating a link or hard link.   Extreme care should be taken when granting this permission. It allows
   linking to any file or directory in the file system thus allowing the
   attacker access to all files.  symbolic  Ability to create symbolic links.   Extreme care should be taken when granting this permission. It allows
   linking to any file or directory in the file system thus allowing the
   attacker to access to all files."
android,java.nio.file,Paths,2,"This class consists exclusively of static methods that return a  Path 
 by converting a path string or  URI ."
android,java.nio.file,SimpleFileVisitor,4,"A simple visitor of files with default behavior to visit all files and to
 re-throw I/O errors.

   Methods in this class may be overridden subject to their general contract."
android,java.nio.file,StandardWatchEventKinds,0,Defines the  standard  event kinds.
android,java.nio.file.attribute,AclEntry,9,"An entry in an access control list (ACL).

   The ACL entry represented by this class is based on the ACL model
 specified in  RFCÂ 3530:
 Network File System (NFS) version 4 Protocol . Each entry has four
 components as follows:

   The  type  component determines if the entry
    grants or denies access.   The  principal  component sometimes called the
    ""who"" component is a  UserPrincipal  corresponding to the identity
    that the entry grants or denies access
      The  permissions  component is a set of
     AclEntryPermission  The  flags  component is a set of  AclEntryFlag  to indicate how entries are inherited and propagated   ACL entries are created using an associated  Builder  object by
 invoking its  Builder#build  method.

   ACL entries are immutable and are safe for use by multiple concurrent
 threads."
android,java.nio.file.attribute,UserPrincipalLookupService,2,"An object to lookup user and group principals by name. A  UserPrincipal 
 represents an identity that may be used to determine access rights to objects
 in a file system. A  GroupPrincipal  represents a  group identity .
 A  UserPrincipalLookupService  defines methods to lookup identities by
 name or group name (which are typically user or account names). Whether names
 and group names are case sensitive or not depends on the implementation.
 The exact definition of a group is implementation specific but typically a
 group represents an identity created for administrative purposes so as to
 determine the access rights for the members of the group. In particular it is
 implementation specific if the  namespace  for names and groups is the
 same or is distinct. To ensure consistent and correct behavior across
 platforms it is recommended that this API be used as if the namespaces are
 distinct. In other words the  lookupPrincipalByName  should be used to lookup users and  lookupPrincipalByGroupName  should be used to
 lookup groups."
android,java.nio.file.attribute,AclEntry.Builder,7,"A builder of  AclEntry  objects.

   A  Builder  object is obtained by invoking one of the  AclEntry#newBuilder  methods defined by the  AclEntry 
 class.

   Builder objects are mutable and are not safe for use by multiple
 concurrent threads without appropriate synchronization."
android,java.nio.file.attribute,FileTime,10,"Represents the value of a file's time stamp attribute. For example it may
 represent the time that the file was last
  BasicFileAttributes#lastModifiedTime() 
  BasicFileAttributes#lastAccessTime() 
 or  BasicFileAttributes#creationTime() .

   Instances of this class are immutable."
android,java.nio.file.attribute,PosixFilePermissions,3,"This class consists exclusively of static methods that operate on sets of
  PosixFilePermission  objects."
android,java.nio.file.spi,FileSystemProvider,28,"Service-provider class for file systems. The methods defined by the  Files  class will typically delegate to an instance of this
 class.

   A file system provider is a concrete implementation of this class that
 implements the abstract methods defined by this class. A provider is
 identified by a  URI scheme . The default provider
 is identified by the URI scheme ""file"". It creates the  FileSystem  that
 provides access to the file systems accessible to the Java virtual machine.
 The  FileSystems  class defines how file system providers are located
 and loaded. The default provider is typically a system-default provider but
 may be overridden if the system property  java.nio.file.spi.DefaultFileSystemProvider  is set. In that case the
 provider has a one argument constructor whose formal parameter type is  FileSystemProvider . All other providers have a zero argument constructor
 that initializes the provider.

   A provider is a factory for one or more  FileSystem  instances. Each
 file system is identified by a  URI  where the URI's scheme matches
 the provider's  scheme . The default file system for example
 is identified by the URI  ""file:///"" . A memory-based file system
 for example may be identified by a URI such as  ""memory:///?name=logfs"" .
 The  newFileSystem  method may be used to create a file
 system and the  getFileSystem  method may be used to
 obtain a reference to an existing file system created by the provider. Where
 a provider is the factory for a single file system then it is provider dependent
 if the file system is created when the provider is initialized or later when
 the  newFileSystem  method is invoked. In the case of the default
 provider the  FileSystem  is created when the provider is initialized.

   All of the methods in this class are safe for use by multiple concurrent
 threads."
android,java.nio.file.spi,FileTypeDetector,1,"A file type detector for probing a file to guess its file type.

   A file type detector is a concrete implementation of this class has a
 zero-argument constructor and implements the abstract methods specified
 below.

   The means by which a file type detector determines the file type is
 highly implementation specific. A simple implementation might examine the
  file extension  (a convention used in some platforms) and map it to
 a file type. In other cases the file type may be stored as a file   attribute  or the bytes in a
 file may be examined to guess its file type."
android,provider,BlockedNumberContract,3,"The contract between the blockednumber provider and applications. Contains definitions for
 the supported URIs and columns.
   Overview  
 The content provider exposes a table containing blocked numbers. The columns and URIs for
 accessing this table are defined by the  BlockedNumbers  class. Messages and calls from
 blocked numbers are discarded by the platform. Notifications upon provider changes can be
 received using a  ContentObserver .
  
 The platform will not block messages and calls from emergency numbers as defined by
  PhoneNumberUtils.isEmergencyNumber(String) . If the user contacts
 emergency services number blocking is disabled by the platform for a duration defined by
  CarrierConfigManager.KEY_DURATION_BLOCKING_DISABLED_AFTER_EMERGENCY_INT .
   Permissions  
 Only the system the default SMS application and the default phone app
 (See  TelecomManager.getDefaultDialerPackage() ) and carrier apps
 (See  CarrierService ) can read and write to the blockednumber
 provider. However  canCurrentUserBlockNumbers(android.content.Context)  can be accessed by any
 application.
   Data  
 Other than regular phone numbers the blocked number provider can also store addresses (such
 as email) from which a user can receive messages and calls. The blocked numbers are stored
 in the  BlockedNumbers#COLUMN_ORIGINAL_NUMBER  column. A normalized version of phone
 numbers (if normalization is possible) is stored in  BlockedNumbers#COLUMN_E164_NUMBER 
 column. The platform blocks calls and messages from an address if it is present in in the
  BlockedNumbers#COLUMN_ORIGINAL_NUMBER  column or if the E164 version of the address
 matches the  BlockedNumbers#COLUMN_E164_NUMBER  column.
   Operations  Insert BlockedNumbers#COLUMN_ORIGINAL_NUMBER  is a required column that needs to be populated.
 Apps can optionally provide the  BlockedNumbers#COLUMN_E164_NUMBER  which is the phone
 number's E164 representation. The provider automatically populates this column if the app does
 not provide it. Note that this column is not populated if normalization fails or if the address
 is not a phone number (eg: email).
  
 Attempting to insert an existing blocked number (same
  BlockedNumbers#COLUMN_ORIGINAL_NUMBER  column) will result in replacing the existing
 blocked number.
  
 Examples:
  
 ContentValues values = new ContentValues();
 values.put(BlockedNumbers.COLUMN_ORIGINAL_NUMBER ""1234567890"");
 Uri uri = getContentResolver().insert(BlockedNumbers.CONTENT_URI values);
  
 ContentValues values = new ContentValues();
 values.put(BlockedNumbers.COLUMN_ORIGINAL_NUMBER ""1234567890"");
 values.put(BlockedNumbers.COLUMN_E164_NUMBER ""+11234567890"");
 Uri uri = getContentResolver().insert(BlockedNumbers.CONTENT_URI values);
  
 ContentValues values = new ContentValues();
 values.put(BlockedNumbers.COLUMN_ORIGINAL_NUMBER ""12345@abdcde.com"");
 Uri uri = getContentResolver().insert(BlockedNumbers.CONTENT_URI values);
  Update 
 Updates are not supported. Use Delete and Insert instead.
  Delete 
 Deletions can be performed as follows:
  
 ContentValues values = new ContentValues();
 values.put(BlockedNumbers.COLUMN_ORIGINAL_NUMBER ""1234567890"");
 Uri uri = getContentResolver().insert(BlockedNumbers.CONTENT_URI values);
 getContentResolver().delete(uri null null);
  
 To check if a particular number is blocked use the method
  isBlocked(android.content.Context java.lang.String) .
 
  Query 
 All blocked numbers can be enumerated as follows:
  
 Cursor c = getContentResolver().query(BlockedNumbers.CONTENT_URI
          new String[]{BlockedNumbers.COLUMN_ID BlockedNumbers.COLUMN_ORIGINAL_NUMBER
          BlockedNumbers.COLUMN_E164_NUMBER} null null null);
  Unblock 
 Use the method  unblock(android.content.Context java.lang.String)  to unblock numbers.
   Multi-user  
 Apps must use the method  canCurrentUserBlockNumbers(android.content.Context)  before performing any
 operation on the blocked number provider. If  canCurrentUserBlockNumbers(android.content.Context)  returns
  false  all operations on the provider will fail with a  SecurityException . The
 platform will block calls and messages from numbers in the provider independent of the current
 user."
android,provider,BlockedNumberContract.BlockedNumbers,0,Constants to interact with the blocked numbers list.
android,provider,Browser,1,
android,provider,CalendarContract,1,"The contract between the calendar provider and applications. Contains
 definitions for the supported URIs and data columns.
  Overview 
 CalendarContract defines the data model of calendar and event related
 information. This data is stored in a number of tables:
  The  Calendars  table holds the calendar specific information. Each
 row in this table contains the details for a single calendar such as the
 name color sync info etc. The  Events  table holds the event specific information. Each row
 in this table has the info for a single event. It contains information such
 as event title location start time end time etc. The event can occur
 one-time or can recur multiple times. Attendees reminders and extended
 properties are stored on separate tables and reference the  Events#_ID 
 to link them with the event. The  Instances  table holds the start and end time for occurrences
 of an event. Each row in this table represents a single occurrence. For
 one-time events there will be a 1:1 mapping of instances to events. For
 recurring events multiple rows will automatically be generated which
 correspond to multiple occurrences of that event. The  Attendees  table holds the event attendee or guest
 information. Each row represents a single guest of an event. It specifies the
 type of guest they are and their attendance response for the event. The  Reminders  table holds the alert/notification data. Each row
 represents a single alert for an event. An event can have multiple reminders.
 The number of reminders per event is specified in
  Calendars#MAX_REMINDERS  which is set by the Sync Adapter that owns
 the given calendar. Reminders are specified in minutes before the event and
 have a type. The  ExtendedProperties  table holds opaque data fields used by the
 sync adapter. The provider takes no action with items in this table except to
 delete them when their related events are deleted. 
 Other tables include:
  SyncState  which contains free-form data maintained by the sync
 adapters"
android,provider,CalendarContract.Attendees,1,"Fields and helpers for interacting with Attendees. Each row of this table
 represents a single attendee or guest of an event. Calling
  query(android.content.ContentResolver long java.lang.String[])  will return a list of attendees for
 the event with the given eventId. Both apps and sync adapters may write
 to this table. There are six writable fields and all of them except
  CalendarContract.AttendeesColumns.ATTENDEE_NAME  must be included when inserting a new attendee.
 They are:
  CalendarContract.AttendeesColumns.EVENT_ID CalendarContract.AttendeesColumns.ATTENDEE_NAME CalendarContract.AttendeesColumns.ATTENDEE_EMAIL CalendarContract.AttendeesColumns.ATTENDEE_RELATIONSHIP CalendarContract.AttendeesColumns.ATTENDEE_TYPE CalendarContract.AttendeesColumns.ATTENDEE_STATUS CalendarContract.AttendeesColumns.ATTENDEE_IDENTITY CalendarContract.AttendeesColumns.ATTENDEE_ID_NAMESPACE"
android,provider,CalendarContract.CalendarAlerts,0,"Fields and helpers for accessing calendar alerts information. These
 fields are for tracking which alerts have been fired. Scheduled alarms
 will generate an intent using  CalendarContract.ACTION_EVENT_REMINDER . Apps that
 receive this action may update the  CalendarContract.CalendarAlertsColumns.STATE  for the reminder when
 they have finished handling it. Apps that have their notifications
 disabled should not modify the table to ensure that they do not conflict
 with another app that is generating a notification. In general apps
 should not need to write to this table directly except to update the
 state of a reminder."
android,provider,CalendarContract.Colors,0,"Fields for accessing colors available for a given account. Colors are
 referenced by  CalendarContract.ColorsColumns.COLOR_KEY  which must be unique for a given
 account name/type. These values can only be updated by the sync
 adapter. Only  CalendarContract.ColorsColumns.COLOR  may be updated after the initial insert. In
 addition a row can only be deleted once all references to that color
 have been removed from the  Calendars  or  Events  tables."
android,provider,CalendarContract.Events,0,"Constants and helpers for the Events table which contains details for
 individual events.  Operations CalendarContract.CALLER_IS_SYNCADAPTER CalendarContract.SyncColumns.ACCOUNT_NAME CalendarContract.SyncColumns.ACCOUNT_TYPE Uri.Builder#appendQueryParameter(java.lang.String java.lang.String) Insert When inserting a new event the following fields must be included:
  dtstart dtend if the event is non-recurring duration if the event is recurring rrule or rdate if the event is recurring eventTimezone a calendar_id 
 There are also further requirements when inserting or updating an event.
 See the section on Writing to Events. Update To perform an update of an Event the  Events#_ID  of the event
 should be provided either as an appended id to the Uri (
  ContentUris#withAppendedId ) or as the first selection item--the
 selection should start with ""_id=?"" and the first selectionArg should be
 the _id of the event. Updates may also be done using a selection and no
 id. Updating an event must respect the same rules as inserting and is
 further restricted in the fields that can be written. See the section on
 Writing to Events. Delete Events can be deleted either by the  Events#_ID  as an appended
 id on the Uri or using any standard selection. If an appended id is used
 a selection is not allowed. There are two versions of delete: as an app
 and as a sync adapter. An app delete will set the deleted column on an
 event and remove all instances of that event. A sync adapter delete will
 remove the event from the database and all associated data. Query Querying the Events table will get you all information about a set of
 events except their reminders attendees and extended properties. There
 will be one row returned for each event that matches the query selection
 or at most a single row if the  Events#_ID  is appended to the Uri.
 Recurring events will only return a single row regardless of the number
 of times that event repeats. Writing to Events If allDay is set to 1 eventTimezone must be  Time#TIMEZONE_UTC 
 and the time must correspond to a midnight boundary. Exceptions are not allowed to recur. If rrule or rdate is not empty
 original_id and original_sync_id must be empty. In general a calendar_id should not be modified after insertion. This
 is not explicitly forbidden but many sync adapters will not behave in an
 expected way if the calendar_id is modified. CalendarContract.EventsColumns.CALENDAR_ID CalendarContract.EventsColumns.ORGANIZER CalendarContract.EventsColumns.TITLE CalendarContract.EventsColumns.EVENT_LOCATION CalendarContract.EventsColumns.DESCRIPTION CalendarContract.EventsColumns.EVENT_COLOR CalendarContract.EventsColumns.DTSTART CalendarContract.EventsColumns.DTEND CalendarContract.EventsColumns.EVENT_TIMEZONE CalendarContract.EventsColumns.EVENT_END_TIMEZONE CalendarContract.EventsColumns.DURATION CalendarContract.EventsColumns.ALL_DAY CalendarContract.EventsColumns.RRULE CalendarContract.EventsColumns.RDATE CalendarContract.EventsColumns.EXRULE CalendarContract.EventsColumns.EXDATE CalendarContract.EventsColumns.ORIGINAL_ID CalendarContract.EventsColumns.ORIGINAL_SYNC_ID CalendarContract.EventsColumns.ORIGINAL_INSTANCE_TIME CalendarContract.EventsColumns.ORIGINAL_ALL_DAY CalendarContract.EventsColumns.ACCESS_LEVEL CalendarContract.EventsColumns.AVAILABILITY CalendarContract.EventsColumns.GUESTS_CAN_MODIFY CalendarContract.EventsColumns.GUESTS_CAN_INVITE_OTHERS CalendarContract.EventsColumns.GUESTS_CAN_SEE_GUESTS CalendarContract.EventsColumns.CUSTOM_APP_PACKAGE CalendarContract.EventsColumns.CUSTOM_APP_URI CalendarContract.EventsColumns.UID_2445 CalendarContract.SyncColumns.DIRTY CalendarContract.SyncColumns.MUTATORS CalendarContract.SyncColumns._SYNC_ID CalendarContract.EventsColumns.SYNC_DATA1 CalendarContract.EventsColumns.SYNC_DATA2 CalendarContract.EventsColumns.SYNC_DATA3 CalendarContract.EventsColumns.SYNC_DATA4 CalendarContract.EventsColumns.SYNC_DATA5 CalendarContract.EventsColumns.SYNC_DATA6 CalendarContract.EventsColumns.SYNC_DATA7 CalendarContract.EventsColumns.SYNC_DATA8 CalendarContract.EventsColumns.SYNC_DATA9 CalendarContract.EventsColumns.SYNC_DATA10"
android,provider,CalendarContract.EventsEntity,2,"Class that represents an Event Entity. There is one entry per event.
 Recurring events show up as a single entry. This is a helper class to
 make batch operations easier. A  ContentResolver  or
  ContentProviderClient  is required as the helper does additional
 queries to add reminders and attendees to each entry."
android,provider,CalendarContract.Instances,2,"Fields and helpers for interacting with Instances. An instance is a
 single occurrence of an event including time zone specific start and end
 days and minutes. The instances table is not writable and only provides a
 way to query event occurrences."
android,provider,CalendarContract.Reminders,1,"Fields and helpers for accessing reminders for an event. Each row of this
 table represents a single reminder for an event. Calling
  query(android.content.ContentResolver long java.lang.String[])  will return a list of reminders for
 the event with the given eventId. Both apps and sync adapters may write
 to this table. There are three writable fields and all of them must be
 included when inserting a new reminder. They are:
  CalendarContract.RemindersColumns.EVENT_ID CalendarContract.RemindersColumns.MINUTES CalendarContract.RemindersColumns.METHOD"
android,provider,Contacts,0,The Contacts provider stores all information about contacts.
android,provider,Contacts.ContactMethods,5,"This table stores all non-phone contact methods and a reference to the
 person that the contact method belongs to."
android,provider,Contacts.Extensions,0,The extensions for a person
android,provider,ContactsContract.CommonDataKinds.Callable,0,"Convenient functionalities for ""callable"" data. Note that this is NOT a separate data
 kind.
  
 This URI allows the ContactsProvider to return a unified result for ""callable"" data
 that users can use for calling purposes.  Phone  and  SipAddress  are the
 current examples for ""callable"" but may be expanded to the other types.
  
 Each returned row may have a different MIMETYPE and thus different interpretation for
 each column. For example the meaning for  Phone 's type is different than
  SipAddress 's."
android,provider,ContactsContract.CommonDataKinds.GroupMembership,0,"Group Membership.
  
 You can use all columns defined for  ContactsContract.Data  as
 well as the following aliases."
android,provider,ContactsContract.CommonDataKinds.Identity,0,"A data kind representing an Identity related to the contact.
  
 This can be used as a signal by the aggregator to combine raw contacts into
 contacts e.g. if two contacts have Identity rows with
 the same NAMESPACE and IDENTITY values the aggregator can know that they refer
 to the same person."
android,provider,ContactsContract.CommonDataKinds.Photo,0,"A data kind representing a photo for the contact.
  
 Some sync adapters will choose to download photos in a separate
 pass. A common pattern is to use columns  ContactsContract.Data#SYNC1 
 through  ContactsContract.Data#SYNC4  to store temporary
 data e.g. the image URL or ID state of download server-side version
 of the image.  It is allowed for the  PHOTO  to be null.
  
 You can use all columns defined for  ContactsContract.Data  as
 well as the following aliases."
android,provider,ContactsContract.CommonDataKinds.Website,0,"A data kind representing a website related to the contact.
  
 You can use all columns defined for  ContactsContract.Data  as
 well as the following aliases."
android,provider,ContactsContract.Contacts,7,"Constants for the contacts table which contains a record per aggregate
 of raw contacts representing the same person.
  Operations Insert A Contact cannot be created explicitly. When a raw contact is
 inserted the provider will first try to find a Contact representing the
 same person. If one is found the raw contact's
  RawContacts#CONTACT_ID  column gets the _ID of the aggregate
 Contact. If no match is found the provider automatically inserts a new
 Contact and puts its _ID into the  RawContacts#CONTACT_ID  column
 of the newly inserted raw contact. Update Only certain columns of Contact are modifiable:
  ContactsContract.ContactOptionsColumns.STARRED   ContactsContract.ContactOptionsColumns.CUSTOM_RINGTONE   ContactsContract.ContactOptionsColumns.SEND_TO_VOICEMAIL . Changing any of
 these columns on the Contact also changes them on all constituent raw
 contacts. Delete Be careful with deleting Contacts! Deleting an aggregate contact
 deletes all constituent raw contacts. The corresponding sync adapters
 will notice the deletions of their respective raw contacts and remove
 them from their back end storage. Query If you need to read an individual contact consider using
  CONTENT_LOOKUP_URI  instead of  CONTENT_URI . If you need to look up a contact by the phone number use
  PhoneLookup#CONTENT_FILTER_URI 
 which is optimized for this purpose. If you need to look up a contact by partial name e.g. to produce
 filter-as-you-type suggestions use the  CONTENT_FILTER_URI  URI.
  If you need to look up a contact by some data element like email
 address nickname etc use a query against the  ContactsContract.Data  table.
 The result will contain contact ID name etc."
android,provider,ContactsContract.Contacts.AggregationSuggestions,0,"A  read-only  sub-directory of a single contact aggregate that
 contains all aggregation suggestions (other contacts). The
 aggregation suggestions are computed based on approximate data
 matches with this contact.
  Note: this query may be expensive! If you need to use it in bulk
 make sure the user experience is acceptable when the query runs for a
 long time. 
 Usage example:

  
 Uri uri = Contacts.CONTENT_URI.buildUpon()
          .appendEncodedPath(String.valueOf(contactId))
          .appendPath(Contacts.AggregationSuggestions.CONTENT_DIRECTORY)
          .appendQueryParameter(""limit"" ""3"")
          .build()
 Cursor cursor = getContentResolver().query(suggestionsUri
          new String[] {Contacts.DISPLAY_NAME Contacts._ID Contacts.LOOKUP_KEY}
          null null null);
  
 This directory can be used either with a  ContactsContract.Contacts.CONTENT_URI  or
  ContactsContract.Contacts.CONTENT_LOOKUP_URI ."
android,provider,ContactsContract.DeletedContacts,0,"Constants for the deleted contact table.  This table holds a log of deleted contacts.
  
 Log older than  DAYS_KEPT_MILLISECONDS  may be deleted."
android,provider,ContactsContract.DisplayPhoto,0,"Helper class for accessing full-size photos by photo file ID.
  
 Usage example:
  Retrieving a full-size photo by photo file ID (see
  ContactsContract.ContactsColumns#PHOTO_FILE_ID )
  
 public InputStream openDisplayPhoto(long photoFileId) {
     Uri displayPhotoUri = ContentUris.withAppendedId(DisplayPhoto.CONTENT_URI photoKey);
     try {
         AssetFileDescriptor fd = getContentResolver().openAssetFileDescriptor(
             displayPhotoUri ""r"");
         return fd.createInputStream();
     } catch (IOException e) {
         return null;
     }
 }"
android,provider,ContactsContract.Intents.Insert,0,"Convenience class that contains string constants used
 to create contact  Intents ."
android,provider,ContactsContract.Presence,0,
android,provider,ContactsContract.RawContacts.Data,0,"A sub-directory of a single raw contact that contains all of its
  ContactsContract.Data  rows. To access this directory
 append  Data#CONTENT_DIRECTORY  to the raw contact URI."
android,provider,ContactsContract.RawContacts.Entity,0,"A sub-directory of a single raw contact that contains all of its
  ContactsContract.Data  rows. To access this directory append
  CONTENT_DIRECTORY  to the raw contact URI. See
  RawContactsEntity  for a stand-alone table containing the same
 data.
  
 Entity has two ID fields:  BaseColumns._ID  for the raw contact
 and  DATA_ID  for the data rows.
 Entity always contains at least one row even if there are no
 actual data rows. In this case the  DATA_ID  field will be
 null.
  
 Using Entity should be preferred to using two separate queries:
 RawContacts followed by Data. The reason is that Entity reads all
 data for a raw contact in one transaction so there is no possibility
 of the data changing between the two queries."
android,provider,DocumentsContract,29,"Defines the contract between a documents provider and the platform.
  
 To create a document provider extend  DocumentsProvider  which
 provides a foundational implementation of this contract.
  
 All client apps must hold a valid URI permission grant to access documents
 typically issued when a user makes a selection through
  Intent#ACTION_OPEN_DOCUMENT   Intent#ACTION_CREATE_DOCUMENT 
 or  Intent#ACTION_OPEN_DOCUMENT_TREE ."
android,provider,DocumentsContract.Document,0,"Constants related to a document including  Cursor  column names
 and flags.
  
 A document can be either an openable stream (with a specific MIME type)
 or a directory containing additional documents (with the
  MIME_TYPE_DIR  MIME type). A directory represents the top of a
 subtree containing zero or more documents which can recursively contain
 even more documents and directories.
  
 All columns are  read-only  to client applications."
android,provider,DocumentsContract.Root,0,"Constants related to a root of documents including  Cursor  column
 names and flags. A root is the start of a tree of documents such as a
 physical storage device or an account. Each root starts at the directory
 referenced by  Root#COLUMN_DOCUMENT_ID  which can recursively
 contain both documents and directories.
  
 All columns are  read-only  to client applications."
android,provider,FontsContract.FontInfo,6,Object represent a font entry in the family returned from  FontsContract.fetchFonts(Context CancellationSignal FontRequest) .
android,provider,MediaStore.Audio,1,Collection of all media with MIME type of  audio/* .
android,provider,MediaStore.Audio.Albums,1,Contains artists for audio files
android,provider,MediaStore.Audio.Artists,1,Contains artists for audio files
android,provider,MediaStore.Audio.Genres,2,Contains all genres for audio files
android,provider,MediaStore.Images.Media,7,
android,provider,MediaStore.Images.Thumbnails,8,"This class provides utility methods to obtain thumbnails for various
  Images  items."
android,provider,MediaStore.Video,1,Collection of all media with MIME type of  video/* .
android,provider,Settings,1,The Settings provider contains global system-level device preferences.
android,provider,Settings.NameValueTable,2,Common base for tables of name/value settings.
android,provider,Settings.Panel,0,"A Settings panel is floating UI that contains a fixed subset of settings to address a
     particular user problem. For example the
      Internet Panel  surfaces settings related to
     connecting to the internet.
  
     Settings panels appear above the calling app to address the problem without
     the user needing to open Settings and thus leave their current screen."
android,provider,Settings.Secure,14,"Secure system settings containing system preferences that applications
 can read but are not allowed to write.  These are for preferences that
 the user must explicitly modify through the system UI or specialized
 APIs for those values not modified directly by applications."
android,provider,SettingsSlicesContract,0,"Provides a contract for platform-supported Settings  Slices .
  
 Contains definitions for the supported  SliceProvider 
 authority authority  Uri  and key constants.
  Slice  presenters interested in learning meta-data about the
  Slice  should read the  Slice 
 object at runtime.
  Uri  builder example:
  
 Uri wifiActionUri = BASE_URI
         .buildUpon()
         .appendPath(PATH_SETTING_ACTION)
         .appendPath(KEY_WIFI)
         .build();
 Uri bluetoothIntentUri = BASE_URI
         .buildUpon()
         .appendPath(PATH_SETTING_INTENT)
         .appendPath(KEY_BLUETOOTH)
         .build();"
android,provider,SyncStateContract.Constants,0,
android,provider,SyncStateContract.Helpers,7,
android,provider,Telephony,0,"The Telephony provider contains data related to phone operation specifically SMS and MMS
 messages access to the APN list including the MMSC to use and the service state.

  Note:  These APIs are not available on all Android-powered
 devices. If your app depends on telephony features such as for managing SMS messages include
 a  <uses-feature>  element in your manifest that declares the  ""android.hardware.telephony""  hardware
 feature. Alternatively you can check for telephony availability at runtime using either
  hasSystemFeature(PackageManager.FEATURE_TELEPHONY)  or  TelephonyManager.getPhoneType() . Creating an SMS app Only the default SMS app (selected by the user in system settings) is able to write to the
 SMS Provider (the tables defined within the  Telephony  class) and only the default SMS
 app receives the  Telephony.Sms.Intents.SMS_DELIVER_ACTION  broadcast
 when the user receives an SMS or the  Telephony.Sms.Intents.WAP_PUSH_DELIVER_ACTION  broadcast when the user
 receives an MMS. Any app that wants to behave as the user's default SMS app must handle the following intents:
  In a broadcast receiver include an intent filter for  Telephony.Sms.Intents.SMS_DELIVER_ACTION 
 ( ""android.provider.Telephony.SMS_DELIVER"" ). The broadcast receiver must also
 require the  Manifest.permission.BROADCAST_SMS  permission.
  This allows your app to directly receive incoming SMS messages. In a broadcast receiver include an intent filter for  Telephony.Sms.Intents.WAP_PUSH_DELIVER_ACTION } ( ""android.provider.Telephony.WAP_PUSH_DELIVER"" )
 with the MIME type  ""application/vnd.wap.mms-message"" .
 The broadcast receiver must also require the  Manifest.permission.BROADCAST_WAP_PUSH  permission.
  This allows your app to directly receive incoming MMS messages. In your activity that delivers new messages include an intent filter for
  Intent.ACTION_SENDTO  ( ""android.intent.action.SENDTO""
  ) with schemas  sms:   smsto:   mms:  and
  mmsto: .
  This allows your app to receive intents from other apps that want to deliver a
 message. In a service include an intent filter for  TelephonyManager.ACTION_RESPOND_VIA_MESSAGE 
 ( ""android.intent.action.RESPOND_VIA_MESSAGE"" ) with schemas
  sms:   smsto:   mms:  and  mmsto: .
 This service must also require the  Manifest.permission.SEND_RESPOND_VIA_MESSAGE  permission.
  This allows users to respond to incoming phone calls with an immediate text message
 using your app. Other apps that are not selected as the default SMS app can only  read  the SMS
 Provider but may also be notified when a new SMS arrives by listening for the  Telephony.Sms.Intents.SMS_RECEIVED_ACTION 
 broadcast which is a non-abortable broadcast that may be delivered to multiple apps. This
 broadcast is intended for apps thatâ€”while not selected as the default SMS appâ€”need to
 read special incoming messages such as to perform phone number verification. For more information about building SMS apps read the blog post  Getting Your SMS Apps Ready for KitKat ."
android,provider,Telephony.CarrierId,2,Contains carrier identification information for the current subscriptions.
android,provider,Telephony.Mms.Addr,0,Contains address information for an MMS message.
android,provider,Telephony.Mms.Draft,0,Contains all MMS messages in the MMS app drafts folder.
android,provider,Telephony.Mms.Inbox,0,Contains all MMS messages in the MMS app inbox.
android,provider,Telephony.Mms.Part,0,"Contains message parts.

 To avoid issues where applications might cache a part ID the ID of a deleted part must
 not be reused to point at a new part."
android,provider,Telephony.MmsSms.PendingMessages,0,Contains pending messages info.
android,provider,Telephony.Sms.Inbox,0,Contains all text-based SMS messages in the SMS app inbox.
android,provider,Telephony.Sms.Intents,1,Contains constants for SMS related Intents that are broadcast.
android,provider,Telephony.Sms.Outbox,0,Contains all pending outgoing text-based SMS messages.
android,provider,UserDictionary,0,"A provider of user defined words for input methods to use for predictive text input.
 Applications and input methods may add words into the dictionary. Words can have associated
 frequency information and locale information.

  NOTE:  Starting on API 23 the user dictionary is only accessible through
 IME and spellchecker."
android,provider,VoicemailContract,0,"The contract between the voicemail provider and applications. Contains
 definitions for the supported URIs and columns.

  The content providers exposes two tables through this interface:
   Voicemails table: This stores the actual voicemail records. The
   columns and URIs for accessing this table are defined by the
    Voicemails  class.
     Status table: This provides a way for the voicemail source application
   to convey its current state to the system. The columns and URIS for
   accessing this table are defined by the  Status  class.
     The minimum permission needed to access this content provider is
  Manifest.permission.ADD_VOICEMAIL  or carrier privileges (see
  TelephonyManager.hasCarrierPrivileges() ).

  Voicemails are inserted by what is called as a ""voicemail source""
 application which is responsible for syncing voicemail data between a remote
 server and the local voicemail content provider. ""voicemail source""
 application should always set the  PARAM_KEY_SOURCE_PACKAGE  in the
 URI to identify its package.

  In addition to the  ContentObserver  notifications the voicemail
 provider also generates broadcast intents to notify change for applications
 that are not active and therefore cannot listen to ContentObserver
 notifications. Broadcast intents with following actions are generated:
  ACTION_NEW_VOICEMAIL  is generated for each new voicemail
   inserted.
    Intent#ACTION_PROVIDER_CHANGED  is generated for any change
    made into the database including new voicemail."
android,provider,VoicemailContract.Status,1,Defines fields exposed through the /status path of this content provider.
android,provider,CalendarContract.CalendarCache,0,"CalendarCache stores some settings for calendar including the current
 time zone for the instances. These settings are stored using a key/value
 scheme. A  CalendarContract.CalendarCacheColumns.KEY  must be specified when updating these values."
android,provider,CalendarContract.CalendarEntity,1,"Class that represents a Calendar Entity. There is one entry per calendar.
 This is a helper class to make batch operations easier."
android,provider,CalendarContract.EventDays,1,Fields and helpers for querying for a list of days that contain events.
android,provider,CalendarContract.ExtendedProperties,0,"Fields for accessing the Extended Properties. This is a generic set of
 name/value pairs for use by sync adapters to add extra
 information to events. There are three writable columns and all three
 must be present when inserting a new value. They are:
  CalendarContract.ExtendedPropertiesColumns.EVENT_ID CalendarContract.ExtendedPropertiesColumns.NAME CalendarContract.ExtendedPropertiesColumns.VALUE"
android,provider,CalendarContract.SyncState,0,A table provided for sync adapters to use for storing private sync state data.
android,provider,Contacts.GroupMembership,0,
android,provider,Contacts.Intents,0,"Contains helper classes used to create or manage  Intents 
 that involve contacts."
android,provider,Contacts.Intents.Insert,0,"Convenience class that contains string constants used
 to create contact  Intents ."
android,provider,Contacts.Intents.UI,0,Intents related to the Contacts app UI.
android,provider,Contacts.Organizations,1,A sub directory of a single person that contains all of their Phones.
android,provider,Contacts.People,9,This table contains people.
android,provider,Contacts.People.Phones,0,A sub directory of a single person that contains all of their Phones.
android,provider,Contacts.Settings,2,The settings over all of the people
android,provider,ContactsContract.AggregationExceptions,0,"Constants for the contact aggregation exceptions table which contains
 aggregation rules overriding those used by automatic aggregation. This
 type only supports query and update. Neither insert nor delete are
 supported."
android,provider,ContactsContract.CommonDataKinds.Im,4,"A data kind representing an IM address
  
 You can use all columns defined for  ContactsContract.Data  as
 well as the following aliases."
android,provider,ContactsContract.CommonDataKinds.Nickname,0,"A data kind representing the contact's nickname. For example for
 Bob Parr (""Mr. Incredible""):
  
 ArrayList<ContentProviderOperation> ops =
          new ArrayList<ContentProviderOperation>();

 ops.add(ContentProviderOperation.newInsert(Data.CONTENT_URI)
          .withValue(Data.RAW_CONTACT_ID rawContactId)
          .withValue(Data.MIMETYPE StructuredName.CONTENT_ITEM_TYPE)
          .withValue(StructuredName.DISPLAY_NAME ""Bob Parr"")
          .build());

 ops.add(ContentProviderOperation.newInsert(Data.CONTENT_URI)
          .withValue(Data.RAW_CONTACT_ID rawContactId)
          .withValue(Data.MIMETYPE Nickname.CONTENT_ITEM_TYPE)
          .withValue(Nickname.NAME ""Mr. Incredible"")
          .withValue(Nickname.TYPE Nickname.TYPE_CUSTOM)
          .withValue(Nickname.LABEL ""Superhero"")
          .build());

 getContentResolver().applyBatch(ContactsContract.AUTHORITY ops);
  
 You can use all columns defined for  ContactsContract.Data  as well as the
 following aliases."
android,provider,ContactsContract.CommonDataKinds.Phone,2,"A data kind representing a telephone number.
  
 You can use all columns defined for  ContactsContract.Data  as
 well as the following aliases."
android,provider,ContactsContract.CommonDataKinds.Relation,2,"A data kind representing a relation.
  
 You can use all columns defined for  ContactsContract.Data  as
 well as the following aliases."
android,provider,ContactsContract.CommonDataKinds.SipAddress,2,"A data kind representing a SIP address for the contact.
  
 You can use all columns defined for  ContactsContract.Data  as
 well as the following aliases."
android,provider,ContactsContract.CommonDataKinds.StructuredName,0,"A data kind representing the contact's proper name. You can use all
 columns defined for  ContactsContract.Data  as well as the following aliases."
android,provider,ContactsContract.Contacts.AggregationSuggestions.Builder,4,A convenience builder for aggregation suggestion content URIs.
android,provider,ContactsContract.Contacts.Entity,0,"A sub-directory of a contact that contains all of its
  ContactsContract.RawContacts  as well as
  ContactsContract.Data  rows. To access this directory append
  CONTENT_DIRECTORY  to the contact URI.
  
 Entity has three ID fields:  ContactsContract.RawContactsColumns.CONTACT_ID  for the contact
  RAW_CONTACT_ID  for the raw contact and  DATA_ID  for
 the data rows. Entity always contains at least one row per
 constituent raw contact even if there are no actual data rows. In
 this case the  DATA_ID  field will be null.
  
 Entity reads all data for the entire contact in one transaction to
 guarantee consistency.  There is significant data duplication
 in the Entity (each row repeats all Contact columns and all RawContact
 columns) so the benefits of transactional consistency should be weighed
 against the cost of transferring large amounts of denormalized data
 from the Provider.
  
 To reduce the amount of data duplication the contacts provider and directory
 providers implementing this protocol are allowed to provide common Contacts
 and RawContacts fields in the first row returned for each raw contact only and
 leave them as null in subsequent rows."
android,provider,ContactsContract.Contacts.Photo,0,"A  read-only  sub-directory of a single contact that contains
 the contact's primary photo.  The photo may be stored in up to two ways -
 the default ""photo"" is a thumbnail-sized image stored directly in the data
 row while the ""display photo"" if present is a larger version stored as
 a file.
  
 Usage example:
  Retrieving the thumbnail-sized photo 
 public InputStream openPhoto(long contactId) {
     Uri contactUri = ContentUris.withAppendedId(Contacts.CONTENT_URI contactId);
     Uri photoUri = Uri.withAppendedPath(contactUri Contacts.Photo.CONTENT_DIRECTORY);
     Cursor cursor = getContentResolver().query(photoUri
          new String[] {Contacts.Photo.PHOTO} null null null);
     if (cursor == null) {
         return null;
     }
     try {
         if (cursor.moveToFirst()) {
             byte[] data = cursor.getBlob(0);
             if (data != null) {
                 return new ByteArrayInputStream(data);
             }
         }
     } finally {
         cursor.close();
     }
     return null;
 }
  Retrieving the larger photo version 
 public InputStream openDisplayPhoto(long contactId) {
     Uri contactUri = ContentUris.withAppendedId(Contacts.CONTENT_URI contactId);
     Uri displayPhotoUri = Uri.withAppendedPath(contactUri Contacts.Photo.DISPLAY_PHOTO);
     try {
         AssetFileDescriptor fd =
             getContentResolver().openAssetFileDescriptor(displayPhotoUri ""r"");
         return fd.createInputStream();
     } catch (IOException e) {
         return null;
     }
 }
  You may also consider using the convenience method
  ContactsContract.Contacts#openContactPhotoInputStream(ContentResolver Uri boolean) 
 to retrieve the raw photo contents of either the thumbnail-sized or the full-sized photo.
  
 This directory can be used either with a  ContactsContract.Contacts.CONTENT_URI  or
  ContactsContract.Contacts.CONTENT_LOOKUP_URI ."
android,provider,ContactsContract.Directory,3,"A Directory represents a contacts corpus e.g. Local contacts
 Google Apps Global Address List or Corporate Global Address List.
  
 A Directory is implemented as a content provider with its unique authority and
 the same API as the main Contacts Provider.  However there is no expectation that
 every directory provider will implement this Contract in its entirety.  If a
 directory provider does not have an implementation for a specific request it
 should throw an UnsupportedOperationException.
  
 The most important use case for Directories is search.  A Directory provider is
 expected to support at least  ContactsContract.Contacts#CONTENT_FILTER_URI .  If a Directory provider wants to participate
 in email and phone lookup functionalities it should also implement
  CommonDataKinds.Email.CONTENT_FILTER_URI 
 and
  CommonDataKinds.Phone.CONTENT_FILTER_URI .
  
 A directory provider should return NULL for every projection field it does not
 recognize rather than throwing an exception.  This way it will not be broken
 if ContactsContract is extended with new fields in the future.
  
 The client interacts with a directory via Contacts Provider by supplying an
 optional  directory=  query parameter.
  
 When the Contacts Provider receives the request it transforms the URI and forwards
 the request to the corresponding directory content provider.
 The URI is transformed in the following fashion:
  The URI authority is replaced with the corresponding  DIRECTORY_AUTHORITY . The  accountName=  and  accountType=  parameters are added or
 replaced using the corresponding  ACCOUNT_TYPE  and  ACCOUNT_NAME  values. 
 Clients should send directory requests to Contacts Provider and let it
 forward them to the respective providers rather than constructing
 directory provider URIs by themselves. This level of indirection allows
 Contacts Provider to implement additional system-level features and
 optimizations. Access to Contacts Provider is protected by the
 READ_CONTACTS permission but access to the directory provider is protected by
 BIND_DIRECTORY_SEARCH. This permission was introduced at the API level 17 for previous
 platform versions the provider should perform the following check to make sure the call
 is coming from the ContactsProvider:
  
 private boolean isCallerAllowed() {
   PackageManager pm = getContext().getPackageManager();
   for (String packageName: pm.getPackagesForUid(Binder.getCallingUid())) {
     if (packageName.equals(""com.android.providers.contacts"")) {
       return true;
     }
   }
   return false;
 }
  
 The Directory table is read-only and is maintained by the Contacts Provider
 automatically.
  It always has at least these two rows:
  
 The local directory. It has  Directory#_ID  =
  Directory#DEFAULT . This directory can be used to access locally
 stored contacts. The same can be achieved by omitting the  directory= 
 parameter altogether.
  
 The local invisible contacts. The corresponding directory ID is
  Directory#LOCAL_INVISIBLE .
  Custom Directories are discovered by the Contacts Provider following this procedure:
  It finds all installed content providers with meta data identifying them
 as directory providers in AndroidManifest.xml:
  
 <meta-data android:name=""android.content.ContactDirectory""
               android:value=""true"" />
  
 This tag should be placed inside the corresponding content provider declaration.
  
 Then Contacts Provider sends a  Directory#CONTENT_URI 
 query to each of the directory authorities.  A directory provider must implement
 this query and return a list of directories.  Each directory returned by
 the provider must have a unique combination for the  ACCOUNT_NAME  and
  ACCOUNT_TYPE  columns (nulls are allowed).  Since directory IDs are assigned
 automatically the _ID field will not be part of the query projection.
  Contacts Provider compiles directory lists received from all directory
 providers into one assigns each individual directory a globally unique ID and
 stores all directory records in the Directory table.
  Contacts Provider automatically interrogates newly installed or replaced packages.
 Thus simply installing a package containing a directory provider is sufficient
 to have that provider registered.  A package supplying a directory provider does
 not have to contain launchable activities.
  
 Every row in the Directory table is automatically associated with the corresponding package
 (apk).  If the package is later uninstalled all corresponding directory rows
 are automatically removed from the Contacts Provider.
  
 When the list of directories handled by a directory provider changes
 (for instance when the user adds a new Directory account) the directory provider
 should call  notifyDirectoryChange(ContentResolver)  to notify the Contacts Provider of the change.
 In response the Contacts Provider will requery the directory provider to obtain the
 new list of directories.
  
 A directory row can be optionally associated with an existing account
 (see  AccountManager ). If the account is later removed
 the corresponding directory rows are automatically removed from the Contacts Provider."
android,provider,ContactsContract.Intents,0,"Contains helper classes used to create or manage  Intents 
 that involve contacts."
android,provider,ContactsContract.PinnedPositions,2,"Contact-specific information about whether or not a contact has been pinned by the user
 at a particular position within the system contact application's user interface.
  
 This pinning information can be used by individual applications to customize how
 they order particular pinned contacts. For example a Dialer application could
 use pinned information to order user-pinned contacts in a top row of favorites.
  
 It is possible for two or more contacts to occupy the same pinned position (due
 to aggregation and sync) so this pinning information should be used on a best-effort
 basis to order contacts in-application rather than an absolute guide on where a contact
 should be positioned. Contacts returned by the ContactsProvider will not be ordered based
 on this information so it is up to the client application to reorder these contacts within
 their own UI adhering to (or ignoring as appropriate) information stored in the pinned
 column.
  
 By default unpinned contacts will have a pinned position of
  PinnedPositions#UNPINNED . Client-provided pinned positions can be positive
 integers that are greater than 1."
android,provider,ContactsContract.ProfileSyncState,4,"A table provided for sync adapters to use for storing private sync state data for the
 user's personal profile."
android,provider,ContactsContract.RawContactsEntity,0,"Constants for the raw contacts entities table which can be thought of as
 an outer join of the raw_contacts table with the data table.  It is a strictly
 read-only table.
  
 If a raw contact has data rows the RawContactsEntity cursor will contain
 a one row for each data row. If the raw contact has no data rows the
 cursor will still contain one row with the raw contact-level information
 and nulls for data columns.

  
 Uri entityUri = ContentUris.withAppendedId(RawContactsEntity.CONTENT_URI rawContactId);
 Cursor c = getContentResolver().query(entityUri
          new String[]{
              RawContactsEntity.SOURCE_ID
              RawContactsEntity.DATA_ID
              RawContactsEntity.MIMETYPE
              RawContactsEntity.DATA1
          } null null null);
 try {
     while (c.moveToNext()) {
         String sourceId = c.getString(0);
         if (!c.isNull(1)) {
             String mimeType = c.getString(2);
             String data = c.getString(3);
             ...
         }
     }
 } finally {
     c.close();
 }
  Columns RawContacts long BaseColumns._ID read-only Raw contact row ID. See  RawContacts . long ContactsContract.RawContactsColumns.CONTACT_ID read-only See  RawContacts . int ContactsContract.RawContactsColumns.AGGREGATION_MODE read-only See  RawContacts . int ContactsContract.RawContactsColumns.DELETED read-only See  RawContacts . Data long DATA_ID read-only Data row ID. It will be null if the raw contact has no data rows. String ContactsContract.DataColumns.MIMETYPE read-only See  ContactsContract.Data . int ContactsContract.DataColumns.IS_PRIMARY read-only See  ContactsContract.Data . int ContactsContract.DataColumns.IS_SUPER_PRIMARY read-only See  ContactsContract.Data . int ContactsContract.DataColumns.DATA_VERSION read-only See  ContactsContract.Data . Any type ContactsContract.DataColumns.DATA1 ContactsContract.DataColumns.DATA2 ContactsContract.DataColumns.DATA3 ContactsContract.DataColumns.DATA4 ContactsContract.DataColumns.DATA5 ContactsContract.DataColumns.DATA6 ContactsContract.DataColumns.DATA7 ContactsContract.DataColumns.DATA8 ContactsContract.DataColumns.DATA9 ContactsContract.DataColumns.DATA10 ContactsContract.DataColumns.DATA11 ContactsContract.DataColumns.DATA12 ContactsContract.DataColumns.DATA13 ContactsContract.DataColumns.DATA14 ContactsContract.DataColumns.DATA15 read-only See  ContactsContract.Data . Any type ContactsContract.DataColumns.SYNC1 ContactsContract.DataColumns.SYNC2 ContactsContract.DataColumns.SYNC3 ContactsContract.DataColumns.SYNC4 read-only See  ContactsContract.Data ."
android,provider,ContactsContract.StatusUpdates,2,"A status update is linked to a  ContactsContract.Data  row and captures
 the user's latest status update via the corresponding source e.g.
 ""Having lunch"" via ""Google Talk"".
  
 There are two ways a status update can be inserted: by explicitly linking
 it to a Data row using  ContactsContract.PresenceColumns.DATA_ID  or indirectly linking it to a data row
 using a combination of  ContactsContract.PresenceColumns.PROTOCOL  (or  ContactsContract.PresenceColumns.CUSTOM_PROTOCOL ) and
  ContactsContract.PresenceColumns.IM_HANDLE .  There is no difference between insert and update you can use
 either.
  
 Inserting or updating a status update for the user's profile requires either using
 the  ContactsContract.PresenceColumns.DATA_ID  to identify the data row to attach the update to or
  StatusUpdates#PROFILE_CONTENT_URI  to ensure that the change is scoped to the
 profile.
  
 You cannot use  ContentResolver#update  to change a status but
  ContentResolver#insert  will replace the latests status if it already
 exists.
  
 Use  ContentResolver#bulkInsert(Uri ContentValues[])  to insert/update statuses
 for multiple contacts at once.
  Columns StatusUpdates long ContactsContract.PresenceColumns.DATA_ID read/write Reference to the  Data#_ID  entry that owns this presence. If this
 field is  not  specified the provider will attempt to find a data row
 that matches the  ContactsContract.PresenceColumns.PROTOCOL  (or  ContactsContract.PresenceColumns.CUSTOM_PROTOCOL ) and
  ContactsContract.PresenceColumns.IM_HANDLE  columns.
  long ContactsContract.PresenceColumns.PROTOCOL read/write See  CommonDataKinds.Im  for a list of defined protocol constants. String ContactsContract.PresenceColumns.CUSTOM_PROTOCOL read/write Name of the custom protocol.  Should be supplied along with the  ContactsContract.PresenceColumns.PROTOCOL  value
  ContactsContract.CommonDataKinds.Im#PROTOCOL_CUSTOM .  Should be null or
 omitted if  ContactsContract.PresenceColumns.PROTOCOL  value is not
  ContactsContract.CommonDataKinds.Im#PROTOCOL_CUSTOM . String ContactsContract.PresenceColumns.IM_HANDLE read/write  The IM handle the presence item is for. The handle is scoped to
  ContactsContract.PresenceColumns.PROTOCOL . String ContactsContract.PresenceColumns.IM_ACCOUNT read/write The IM account for the local user that the presence data came from. int ContactsContract.StatusColumns.PRESENCE read/write Contact IM presence status. The allowed values are:
  ContactsContract.StatusColumns.OFFLINE ContactsContract.StatusColumns.INVISIBLE ContactsContract.StatusColumns.AWAY ContactsContract.StatusColumns.IDLE ContactsContract.StatusColumns.DO_NOT_DISTURB ContactsContract.StatusColumns.AVAILABLE 
 Since presence status is inherently volatile the content provider
 may choose not to store this field in long-term storage.
  int ContactsContract.StatusColumns.CHAT_CAPABILITY read/write Contact IM chat compatibility value. The allowed values combinations of the following
 flags. If None of these flags is set the device can only do text messaging.
  ContactsContract.StatusColumns.CAPABILITY_HAS_VIDEO ContactsContract.StatusColumns.CAPABILITY_HAS_VOICE ContactsContract.StatusColumns.CAPABILITY_HAS_CAMERA 
 Since chat compatibility is inherently volatile as the contact's availability moves from
 one device to another the content provider may choose not to store this field in long-term
 storage.
  String ContactsContract.StatusColumns.STATUS read/write Contact's latest status update e.g. ""having toast for breakfast"" long ContactsContract.StatusColumns.STATUS_TIMESTAMP read/write The absolute time in milliseconds when the status was
 entered by the user. If this value is not provided the provider will follow
 this logic: if there was no prior status update the value will be left as null.
 If there was a prior status update the provider will default this field
 to the current time. String ContactsContract.StatusColumns.STATUS_RES_PACKAGE read/write  The package containing resources for this status: label and icon. long ContactsContract.StatusColumns.STATUS_LABEL read/write The resource ID of the label describing the source of contact status
 e.g. ""Google Talk"". This resource is scoped by the
  ContactsContract.StatusColumns.STATUS_RES_PACKAGE . long ContactsContract.StatusColumns.STATUS_ICON read/write The resource ID of the icon for the source of contact status. This
 resource is scoped by the  ContactsContract.StatusColumns.STATUS_RES_PACKAGE ."
android,provider,DocumentsContract.Path,7,"Holds a path from a document to a particular document under it. It
 may also contains the root ID where the path resides."
android,provider,DocumentsProvider,42,"Base class for a document provider. A document provider offers read and write
 access to durable files such as files stored on a local disk or files in a
 cloud storage service. To create a document provider extend this class
 implement the abstract methods and add it to your manifest like this:

  <manifest>
    ...
    <application>
        ...
        <provider
            android:name=""com.example.MyCloudProvider""
            android:authorities=""com.example.mycloudprovider""
            android:exported=""true""
            android:grantUriPermissions=""true""
            android:permission=""android.permission.MANAGE_DOCUMENTS""
            android:enabled=""@bool/isAtLeastKitKat"">
            <intent-filter>
                <action android:name=""android.content.action.DOCUMENTS_PROVIDER"" />
            </intent-filter>
        </provider>
        ...
    </application>
</manifest> 
 When defining your provider you must protect it with
  Manifest.permission.MANAGE_DOCUMENTS  which is a permission
 only the system can obtain. Applications cannot use a documents provider
 directly; they must go through  Intent#ACTION_OPEN_DOCUMENT  or
  Intent#ACTION_CREATE_DOCUMENT  which requires a user to actively
 navigate and select documents. When a user selects documents through that UI
 the system issues narrow URI permission grants to the requesting application.
  Documents 
 A document can be either an openable stream (with a specific MIME type) or a
 directory containing additional documents (with the
  Document#MIME_TYPE_DIR  MIME type). Each directory represents the top
 of a subtree containing zero or more documents which can recursively contain
 even more documents and directories.
  
 Each document can have different capabilities as described by
  Document#COLUMN_FLAGS . For example if a document can be represented
 as a thumbnail your provider can set
  Document#FLAG_SUPPORTS_THUMBNAIL  and implement
  openDocumentThumbnail(java.lang.String android.graphics.Point android.os.CancellationSignal)  to return
 that thumbnail.
  
 Each document under a provider is uniquely referenced by its
  Document#COLUMN_DOCUMENT_ID  which must not change once returned. A
 single document can be included in multiple directories when responding to
  queryChildDocuments(java.lang.String java.lang.String[] java.lang.String) . For example a
 provider might surface a single photo in multiple locations: once in a
 directory of geographic locations and again in a directory of dates.
  Roots 
 All documents are surfaced through one or more ""roots."" Each root represents
 the top of a document tree that a user can navigate. For example a root
 could represent an account or a physical storage device. Similar to
 documents each root can have capabilities expressed through
  Root#COLUMN_FLAGS ."
android,provider,FontRequest,5,Information about a font request that may be sent to a Font Provider.
android,provider,FontsContract,3,Utility class to deal with Font ContentProviders.
android,provider,FontsContract.FontRequestCallback,2,Interface used to receive asynchronously fetched typefaces.
android,provider,MediaStore,9,"The contract between the media provider and applications. Contains
 definitions for the supported URIs and columns.
  
 The media provider provides an indexed collection of common media types such
 as  Audio   Video  and  Images  from any attached
 storage devices. Each collection is organized based on the primary MIME type
 of the underlying content; for example  image/*  content is indexed
 under  Images . The  Files  collection provides a broad view
 across all collections and does not filter by MIME type."
android,provider,MediaStore.Audio.Playlists,1,Contains playlists for audio files
android,provider,MediaStore.Audio.Playlists.Members,2,Sub-directory of each playlist containing all members.
android,provider,MediaStore.Files,2,"Media provider table containing an index of all files in the media storage
 including non-media files.  This should be used by applications that work with
 non-media file types (text HTML PDF etc) as well as applications that need to
 work with multiple media file types in a single query."
android,provider,MediaStore.Images,0,Collection of all media with MIME type of  image/* .
android,provider,SearchRecentSuggestions,3,"This is a utility class providing access to
  SearchRecentSuggestionsProvider .

  Unlike some utility classes this one must be instantiated and properly initialized so that
 it can be configured to operate with the search suggestions provider that you have created.

  Typically you will do this in your searchable activity each time you receive an incoming
  ACTION_SEARCH  Intent.  The code to record each
 incoming query is as follows:
  
      SearchSuggestions suggestions = new SearchSuggestions(this
              MySuggestionsProvider.AUTHORITY MySuggestionsProvider.MODE);
      suggestions.saveRecentQuery(queryString null);
  For a working example see SearchSuggestionSampleProvider and SearchQueryResults in
 samples/ApiDemos/app."
android,provider,Settings.Global,12,"Global system settings containing preferences that always apply identically
 to all defined users.  Applications can read these but are not allowed to write;
 like the ""Secure"" settings these are for preferences that the user must
 explicitly modify through the system UI or specialized APIs for those values."
android,provider,SyncStateContract,0,"The ContentProvider contract for associating data with ana data array account.
 This may be used by providers that want to store this data in a standard way."
android,provider,Telephony.Mms.Intents,0,Intents class.
android,provider,Telephony.Mms.Outbox,0,Contains all MMS messages in the MMS app outbox.
android,provider,Telephony.MmsSms,0,Contains all MMS and SMS messages.
android,provider,Telephony.Sms,1,Contains all text-based SMS messages.
android,provider,UserDictionary.Words,2,Contains the user defined words.
android,provider,VoicemailContract.Voicemails,1,Defines fields exposed through the /voicemail path of this content provider.
android,provider,AlarmClock,0,"The AlarmClock provider contains an Intent action and extras that can be used
 to start an Activity to set a new alarm or timer in an alarm clock application.

 Applications that wish to receive the ACTION_SET_ALARM  and ACTION_SET_TIMER Intents
 should create an activity to handle the Intent that requires the permission
 com.android.alarm.permission.SET_ALARM.  Applications that wish to create a
 new alarm or timer should use
  Context.startActivity()  so that
 the user has the option of choosing which alarm clock application to use.

 Android TV devices may not support the alarm intents."
android,provider,CalendarContract.Calendars,0,"Constants and helpers for the Calendars table which contains details for
 individual calendars.  Operations CalendarContract.CALLER_IS_SYNCADAPTER CalendarContract.SyncColumns.ACCOUNT_NAME CalendarContract.SyncColumns.ACCOUNT_TYPE Uri.Builder#appendQueryParameter(java.lang.String java.lang.String) CalendarContract.SyncColumns.ACCOUNT_TYPE CalendarContract.ACCOUNT_TYPE_LOCAL Insert When inserting a new calendar the following fields must be included:
  CalendarContract.SyncColumns.ACCOUNT_NAME CalendarContract.SyncColumns.ACCOUNT_TYPE NAME CalendarContract.CalendarColumns.CALENDAR_DISPLAY_NAME CalendarContract.CalendarColumns.CALENDAR_COLOR CalendarContract.CalendarColumns.CALENDAR_ACCESS_LEVEL CalendarContract.CalendarColumns.OWNER_ACCOUNT 
 The following fields are not required when inserting a Calendar but are
 generally a good idea to include:
  CalendarContract.CalendarColumns.SYNC_EVENTS  set to 1 CalendarContract.CalendarColumns.CALENDAR_TIME_ZONE CalendarContract.CalendarColumns.ALLOWED_REMINDERS CalendarContract.CalendarColumns.ALLOWED_AVAILABILITY CalendarContract.CalendarColumns.ALLOWED_ATTENDEE_TYPES Update To perform an update on a calendar the  BaseColumns._ID  of the calendar
 should be provided either as an appended id to the Uri (
  ContentUris#withAppendedId ) or as the first selection item--the
 selection should start with ""_id=?"" and the first selectionArg should be
 the _id of the calendar. Calendars may also be updated using a selection
 without the id. In general the  CalendarContract.SyncColumns.ACCOUNT_NAME  and
  CalendarContract.SyncColumns.ACCOUNT_TYPE  should not be changed after a calendar is created
 as this can cause issues for sync adapters.
  Delete Calendars can be deleted either by the  BaseColumns._ID  as an appended id
 on the Uri or using any standard selection. Deleting a calendar should
 generally be handled by a sync adapter as it will remove the calendar
 from the database and all associated data (aka events). Query Querying the Calendars table will get you all information about a set
 of calendars. There will be one row returned for each calendar that
 matches the query selection or at most a single row if the  BaseColumns._ID 
 is appended to the Uri. Calendar Columns NAME CalendarContract.CalendarColumns.CALENDAR_DISPLAY_NAME CalendarContract.CalendarColumns.VISIBLE CalendarContract.CalendarColumns.SYNC_EVENTS CalendarContract.SyncColumns.ACCOUNT_NAME CalendarContract.SyncColumns.ACCOUNT_TYPE CalendarContract.CalendarColumns.CALENDAR_COLOR CalendarContract.SyncColumns._SYNC_ID CalendarContract.SyncColumns.DIRTY CalendarContract.SyncColumns.MUTATORS CalendarContract.CalendarColumns.OWNER_ACCOUNT CalendarContract.CalendarColumns.MAX_REMINDERS CalendarContract.CalendarColumns.ALLOWED_REMINDERS CalendarContract.CalendarColumns.ALLOWED_AVAILABILITY CalendarContract.CalendarColumns.ALLOWED_ATTENDEE_TYPES CalendarContract.CalendarColumns.CAN_MODIFY_TIME_ZONE CalendarContract.CalendarColumns.CAN_ORGANIZER_RESPOND CalendarContract.SyncColumns.CAN_PARTIALLY_UPDATE CALENDAR_LOCATION CalendarContract.CalendarColumns.CALENDAR_TIME_ZONE CalendarContract.CalendarColumns.CALENDAR_ACCESS_LEVEL CalendarContract.SyncColumns.DELETED CalendarContract.CalendarSyncColumns.CAL_SYNC1 CalendarContract.CalendarSyncColumns.CAL_SYNC2 CalendarContract.CalendarSyncColumns.CAL_SYNC3 CalendarContract.CalendarSyncColumns.CAL_SYNC4 CalendarContract.CalendarSyncColumns.CAL_SYNC5 CalendarContract.CalendarSyncColumns.CAL_SYNC6 CalendarContract.CalendarSyncColumns.CAL_SYNC7 CalendarContract.CalendarSyncColumns.CAL_SYNC8 CalendarContract.CalendarSyncColumns.CAL_SYNC9 CalendarContract.CalendarSyncColumns.CAL_SYNC10"
android,provider,CallLog,0,The CallLog provider contains information about placed and received calls.
android,provider,CallLog.Calls,1,Contains the recent calls.
android,provider,Contacts.Groups,0,This table contains the groups for an account.
android,provider,Contacts.People.Extensions,0,The extensions for a person
android,provider,Contacts.Phones,2,"This table stores phone numbers and a reference to the person that the
 contact method belongs to. Phone numbers are stored separately from
 other contact methods to make caller ID lookup more efficient."
android,provider,ContactsContract,1,"The contract between the contacts provider and applications. Contains
 definitions for the supported URIs and columns. These APIs supersede
  Contacts .
  Overview 
 ContactsContract defines an extensible database of contact-related
 information. Contact information is stored in a three-tier data model:
  
 A row in the  Data  table can store any kind of personal data such
 as a phone number or email addresses.  The set of data kinds that can be
 stored in this table is open-ended. There is a predefined set of common
 kinds but any application can add its own data kinds.
  
 A row in the  RawContacts  table represents a set of data describing a
 person and associated with a single account (for example one of the user's
 Gmail accounts).
  
 A row in the  Contacts  table represents an aggregate of one or more
 RawContacts presumably describing the same person.  When data in or associated with
 the RawContacts table is changed the affected aggregate contacts are updated as
 necessary.
  
 Other tables include:
  Groups  which contains information about raw contact groups
 such as Gmail contact groups.  The
 current API does not support the notion of groups spanning multiple accounts.
  StatusUpdates  which contains social status updates including IM
 availability.
  AggregationExceptions  which is used for manual aggregation and
 disaggregation of raw contacts
  Settings  which contains visibility and sync settings for accounts
 and groups.
  SyncState  which contains free-form data maintained on behalf of sync
 adapters
  PhoneLookup  which is used for quick caller-ID lookup"
android,provider,ContactsContract.CommonDataKinds,0,"Container for definitions of common data types stored in the  ContactsContract.Data 
 table."
android,provider,ContactsContract.CommonDataKinds.Contactables,0,"A special class of data items used to refer to types of data that can be used to attempt
 to start communicating with a person ( Phone  and  Email ). Note that this
 is NOT a separate data kind.

 This URI allows the ContactsProvider to return a unified result for data items that users
 can use to initiate communications with another contact.  Phone  and  Email 
 are the current data types in this category."
android,provider,ContactsContract.CommonDataKinds.Email,2,"A data kind representing an email address.
  
 You can use all columns defined for  ContactsContract.Data  as
 well as the following aliases."
android,provider,ContactsContract.CommonDataKinds.Organization,2,"A data kind representing an organization.
  
 You can use all columns defined for  ContactsContract.Data  as
 well as the following aliases."
android,provider,ContactsContract.CommonDataKinds.StructuredPostal,2,"A data kind representing a postal addresses.
  
 You can use all columns defined for  ContactsContract.Data  as
 well as the following aliases."
android,provider,ContactsContract.DataUsageFeedback,0,"API allowing applications to send usage information for each  Data  row to the
 Contacts Provider.  Applications can also clear all usage information.
  
 With the feedback Contacts Provider may return more contextually appropriate results for
 Data listing typically supplied with
  ContactsContract.Contacts#CONTENT_FILTER_URI 
  ContactsContract.CommonDataKinds.Email#CONTENT_FILTER_URI 
  ContactsContract.CommonDataKinds.Phone#CONTENT_FILTER_URI  and users can benefit
 from better ranked (sorted) lists in applications that show auto-complete list.
  
 There is no guarantee for how this feedback is used or even whether it is used at all.
 The ranking algorithm will make best efforts to use the feedback data but the exact
 implementation the storage data structures as well as the resulting sort order is device
 and version specific and can change over time.
  
 When updating usage information users of this API need to use
  ContentResolver#update(Uri ContentValues String String[])  with a Uri constructed
 from  DataUsageFeedback#FEEDBACK_URI . The Uri must contain one or more data id(s) as
 its last path. They also need to append a query parameter to the Uri to specify the type of
 the communication which enables the Contacts Provider to differentiate between kinds of
 interactions using the same contact data field (for example a phone number can be used to
 make phone calls or send SMS).
  
 Selection and selectionArgs are ignored and must be set to null. To get data ids
 you may need to call  ContentResolver#query(Uri String[] String String[] String) 
 toward  Data#CONTENT_URI .
  ContentResolver#update(Uri ContentValues String String[])  returns a positive
 integer when successful and returns 0 if no contact with that id was found.
  
 Example:
  
 Uri uri = DataUsageFeedback.FEEDBACK_URI.buildUpon()
         .appendPath(TextUtils.join("""" dataIds))
         .appendQueryParameter(DataUsageFeedback.USAGE_TYPE
                 DataUsageFeedback.USAGE_TYPE_CALL)
         .build();
 boolean successful = resolver.update(uri new ContentValues() null null) > 0;
  
 Applications can also clear all usage information with:
  
 boolean successful = resolver.delete(DataUsageFeedback.DELETE_USAGE_URI null null) > 0;"
android,provider,ContactsContract.PhoneLookup,0,"A table that represents the result of looking up a phone number for
 example for caller ID. To perform a lookup you must append the number you
 want to find to  CONTENT_FILTER_URI .  This query is highly
 optimized.
  
 Uri uri = Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI Uri.encode(phoneNumber));
 resolver.query(uri new String[]{PhoneLookup.DISPLAY_NAME...
  Columns PhoneLookup String ContactsContract.PhoneLookupColumns.NUMBER read-only Phone number. String ContactsContract.PhoneLookupColumns.TYPE read-only Phone number type. See  CommonDataKinds.Phone . String ContactsContract.PhoneLookupColumns.LABEL read-only Custom label for the phone number. See  CommonDataKinds.Phone . 
 Columns from the Contacts table are also available through a join.
  Join with  Contacts long BaseColumns._ID read-only Contact ID. long ContactsContract.PhoneLookupColumns.CONTACT_ID read-only Contact ID. long ContactsContract.PhoneLookupColumns.DATA_ID read-only Data ID. String ContactsContract.ContactsColumns.LOOKUP_KEY read-only See  ContactsContract.Contacts String ContactsContract.ContactsColumns.DISPLAY_NAME read-only See  ContactsContract.Contacts long ContactsContract.ContactsColumns.PHOTO_ID read-only See  ContactsContract.Contacts . int ContactsContract.ContactsColumns.IN_VISIBLE_GROUP read-only See  ContactsContract.Contacts . int ContactsContract.ContactsColumns.HAS_PHONE_NUMBER read-only See  ContactsContract.Contacts . int ContactsContract.ContactOptionsColumns.STARRED read-only See  ContactsContract.Contacts . String ContactsContract.ContactOptionsColumns.CUSTOM_RINGTONE read-only See  ContactsContract.Contacts . int ContactsContract.ContactOptionsColumns.SEND_TO_VOICEMAIL read-only See  ContactsContract.Contacts ."
android,provider,ContactsContract.Profile,0,"Constants for the user's profile data which is represented as a single contact on
 the device that represents the user.  The profile contact is not aggregated
 together automatically in the same way that normal contacts are; instead each
 account (including data set if applicable) on the device may contribute a single
 raw contact representing the user's personal profile data from that source.
  
 Access to the profile entry through these URIs (or incidental access to parts of
 the profile if retrieved directly via ID) requires additional permissions beyond
 the read/write contact permissions required by the provider.  Querying for profile
 data requires android.permission.READ_PROFILE permission and inserting or
 updating profile data requires android.permission.WRITE_PROFILE permission.
  Operations Insert The user's profile entry cannot be created explicitly (attempting to do so
 will throw an exception). When a raw contact is inserted into the profile the
 provider will check for the existence of a profile on the device.  If one is
 found the raw contact's  RawContacts#CONTACT_ID  column gets the _ID of
 the profile Contact. If no match is found the profile Contact is created and
 its _ID is put into the  RawContacts#CONTACT_ID  column of the newly
 inserted raw contact. Update The profile Contact has the same update restrictions as Contacts in general
 but requires the android.permission.WRITE_PROFILE permission. Delete The profile Contact cannot be explicitly deleted.  It will be removed
 automatically if all of its constituent raw contact entries are deleted. Query The  CONTENT_URI  for profiles behaves in much the same way as
 retrieving a contact by ID except that it will only ever return the user's
 profile contact.
  
 The profile contact supports all of the same sub-paths as an individual contact
 does - the content of the profile contact can be retrieved as entities or
 data rows.  Similarly specific raw contact entries can be retrieved by appending
 the desired raw contact ID within the profile."
android,provider,ContactsContract.ProviderStatus,0,API for inquiring about the general status of the provider.
android,provider,ContactsContract.QuickContact,4,"Helper methods to display QuickContact dialogs that display all the information belonging to
 a specific  Contacts  entry."
android,provider,ContactsContract.RawContacts,2,"Constants for the raw contacts table which contains one row of contact
 information for each person in each synced account. Sync adapters and
 contact management apps
 are the primary consumers of this API.

  Aggregation 
 As soon as a raw contact is inserted or whenever its constituent data
 changes the provider will check if the raw contact matches other
 existing raw contacts and if so will aggregate it with those. The
 aggregation is reflected in the  RawContacts  table by the change of the
  ContactsContract.RawContactsColumns.CONTACT_ID  field which is the reference to the aggregate contact.
  
 Changes to the structured name organization phone number email address
 or nickname trigger a re-aggregation.
  
 See also  AggregationExceptions  for a mechanism to control
 aggregation programmatically.
  Operations Insert 
 Raw contacts can be inserted incrementally or in a batch.
 The incremental method is more traditional but less efficient.
 It should be used
 only if no  Data  values are available at the time the raw contact is created:
  
 ContentValues values = new ContentValues();
 values.put(RawContacts.ACCOUNT_TYPE accountType);
 values.put(RawContacts.ACCOUNT_NAME accountName);
 Uri rawContactUri = getContentResolver().insert(RawContacts.CONTENT_URI values);
 long rawContactId = ContentUris.parseId(rawContactUri);
  
 Once  Data  values become available insert those.
 For example here's how you would insert a name:

  
 values.clear();
 values.put(Data.RAW_CONTACT_ID rawContactId);
 values.put(Data.MIMETYPE StructuredName.CONTENT_ITEM_TYPE);
 values.put(StructuredName.DISPLAY_NAME ""Mike Sullivan"");
 getContentResolver().insert(Data.CONTENT_URI values);
  
 The batch method is by far preferred.  It inserts the raw contact and its
 constituent data rows in a single database transaction
 and causes at most one aggregation pass.
  
 ArrayList<ContentProviderOperation> ops =
          new ArrayList<ContentProviderOperation>();
 ...
 int rawContactInsertIndex = ops.size();
 ops.add(ContentProviderOperation.newInsert(RawContacts.CONTENT_URI)
          .withValue(RawContacts.ACCOUNT_TYPE accountType)
          .withValue(RawContacts.ACCOUNT_NAME accountName)
          .build());

 ops.add(ContentProviderOperation.newInsert(Data.CONTENT_URI)
          .withValueBackReference(Data.RAW_CONTACT_ID rawContactInsertIndex)
          .withValue(Data.MIMETYPE StructuredName.CONTENT_ITEM_TYPE)
          .withValue(StructuredName.DISPLAY_NAME ""Mike Sullivan"")
          .build());

 getContentResolver().applyBatch(ContactsContract.AUTHORITY ops);
  
 Note the use of  ContentProviderOperation.Builder#withValueBackReference(String int) 
 to refer to the as-yet-unknown index value of the raw contact inserted in the
 first operation.
  Update 
 Raw contacts can be updated incrementally or in a batch.
 Batch mode should be used whenever possible.
 The procedures and considerations are analogous to those documented above for inserts.
  Delete When a raw contact is deleted all of its Data rows as well as StatusUpdates
 AggregationExceptions PhoneLookup rows are deleted automatically. When all raw
 contacts associated with a  Contacts  row are deleted the  Contacts  row
 itself is also deleted automatically.
  
 The invocation of  resolver.delete(...)  does not immediately delete
 a raw contacts row.
 Instead it sets the  ContactsContract.RawContactsColumns.DELETED  flag on the raw contact and
 removes the raw contact from its aggregate contact.
 The sync adapter then deletes the raw contact from the server and
 finalizes phone-side deletion by calling  resolver.delete(...) 
 again and passing the  ContactsContract#CALLER_IS_SYNCADAPTER  query parameter. Some sync adapters are read-only meaning that they only sync server-side
 changes to the phone but not the reverse.  If one of those raw contacts
 is marked for deletion it will remain on the phone.  However it will be
 effectively invisible because it will not be part of any aggregate contact.
  Query 
 It is easy to find all raw contacts in a Contact:
  
 Cursor c = getContentResolver().query(RawContacts.CONTENT_URI
          new String[]{RawContacts._ID}
          RawContacts.CONTACT_ID + ""=?""
          new String[]{String.valueOf(contactId)} null);
  
 To find raw contacts within a specific account
 you can either put the account name and type in the selection or pass them as query
 parameters.  The latter approach is preferable especially when you can reuse the
 URI:
  
 Uri rawContactUri = RawContacts.CONTENT_URI.buildUpon()
          .appendQueryParameter(RawContacts.ACCOUNT_NAME accountName)
          .appendQueryParameter(RawContacts.ACCOUNT_TYPE accountType)
          .build();
 Cursor c1 = getContentResolver().query(rawContactUri
          RawContacts.STARRED + ""<>0"" null null null);
 ...
 Cursor c2 = getContentResolver().query(rawContactUri
          RawContacts.DELETED + ""<>0"" null null null);
  The best way to read a raw contact along with all the data associated with it is
 by using the  Entity  directory. If the raw contact has data rows
 the Entity cursor will contain a row for each data row.  If the raw contact has no
 data rows the cursor will still contain one row with the raw contact-level information.
  
 Uri rawContactUri = ContentUris.withAppendedId(RawContacts.CONTENT_URI rawContactId);
 Uri entityUri = Uri.withAppendedPath(rawContactUri Entity.CONTENT_DIRECTORY);
 Cursor c = getContentResolver().query(entityUri
          new String[]{RawContacts.SOURCE_ID Entity.DATA_ID Entity.MIMETYPE Entity.DATA1}
          null null null);
 try {
     while (c.moveToNext()) {
         String sourceId = c.getString(0);
         if (!c.isNull(1)) {
             String mimeType = c.getString(2);
             String data = c.getString(3);
             ...
         }
     }
 } finally {
     c.close();
 }"
android,provider,ContactsContract.RawContacts.DisplayPhoto,0,"A sub-directory of a single raw contact that represents its primary
 display photo.  To access this directory append
  CONTENT_DIRECTORY  to the raw contact URI.
 The resulting URI represents an image file and should be interacted with
 using ContentResolver.openAssetFileDescriptor.
  
 Note that this sub-directory also supports opening the photo as an asset file
 in write mode.  Callers can create or replace the primary photo associated
 with this raw contact by opening the asset file and writing the full-size
 photo contents into it.  When the file is closed the image will be parsed
 sized down if necessary for the full-size display photo and thumbnail
 dimensions and stored.
  
 Usage example:
  
 public void writeDisplayPhoto(long rawContactId byte[] photo) {
     Uri rawContactPhotoUri = Uri.withAppendedPath(
             ContentUris.withAppendedId(RawContacts.CONTENT_URI rawContactId)
             RawContacts.DisplayPhoto.CONTENT_DIRECTORY);
     try {
         AssetFileDescriptor fd =
             getContentResolver().openAssetFileDescriptor(rawContactPhotoUri ""rw"");
         OutputStream os = fd.createOutputStream();
         os.write(photo);
         os.close();
         fd.close();
     } catch (IOException e) {
         // Handle error cases.
     }
 }"
android,provider,ContactsContract.SearchSnippets,0,"Additional column returned by
  ContactsContract.Contacts#CONTENT_FILTER_URI  explaining
 why the filter matched the contact. This column will contain extracts from the contact's
 constituent  Data  items formatted in a way that indicates the section of the
 snippet that matched the filter.

  
 The following example searches for all contacts that match the query ""presi"" and requests
 the snippet column as well.
  
 Builder builder = Contacts.CONTENT_FILTER_URI.buildUpon();
 builder.appendPath(""presi"");
 // Defer snippeting to the client side if possible for performance reasons.
 builder.appendQueryParameter(SearchSnippets.DEFERRED_SNIPPETING_KEY""1"");

 Cursor cursor = getContentResolver().query(builder.build());

 Bundle extras = cursor.getExtras();
 if (extras.getBoolean(ContactsContract.DEFERRED_SNIPPETING)) {
     // Do our own snippet formatting.
     // For a contact with the email address (president@organization.com) the snippet
     // column will contain the string ""president@organization.com"".
 } else {
     // The snippet has already been pre-formatted we can display it as is.
     // For a contact with the email address (president@organization.com) the snippet
     // column will contain the string ""[presi]dent@organization.com"".
 }"
android,provider,FontsContract.Columns,0,"Defines the constants used in a response from a Font Provider. The cursor returned from the
 query should have the ID column populated with the content uri ID for the resulting font.
 This should point to a real file or shared memory as the client will mmap the given file
 descriptor. Pipes sockets and other non-mmap-able file descriptors will fail to load in the
 client application."
android,provider,FontsContract.FontFamilyResult,2,Object returned from  FontsContract.fetchFonts(Context CancellationSignal FontRequest) .
android,provider,LiveFolders,0,"A LiveFolder is a special folder whose content is provided by a
  ContentProvider . To create a live folder two components
 are required: An activity that can respond to the intent action  ACTION_CREATE_LIVE_FOLDER . The
  activity is responsible for creating the live folder. A  ContentProvider  to provide the live folder items. Lifecycle When a user wants to create a live folder the system looks for all activities with the
 intent filter action  ACTION_CREATE_LIVE_FOLDER  and presents the list to the user.
 When the user chooses one of the activities the activity is invoked with the
  ACTION_CREATE_LIVE_FOLDER  action. The activity then creates the live folder and
 passes it back to the system by setting it as an
  activity result . The
 live folder is described by a content provider URI a name an icon and a display mode.
 Finally when the user opens the live folder the system queries the content provider
 to retrieve the folder's content. Setting up the live folder activity The following code sample shows how to write an activity that creates a live folder: 
 public static class MyLiveFolder extends Activity {
     public static final Uri CONTENT_URI = Uri.parse(""content://my.app/live"");

     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);

         final Intent intent = getIntent();
         final String action = intent.getAction();

         if (LiveFolders.ACTION_CREATE_LIVE_FOLDER.equals(action)) {
             setResult(RESULT_OK createLiveFolder(this CONTENT_URI ""My LiveFolder""
                     R.drawable.ic_launcher_contacts_phones));
         } else {
             setResult(RESULT_CANCELED);
         }

         finish();
     }

     private static Intent createLiveFolder(Context context Uri uri String name
             int icon) {

         final Intent intent = new Intent();

         intent.setData(uri);
         intent.putExtra(LiveFolders.EXTRA_LIVE_FOLDER_NAME name);
         intent.putExtra(LiveFolders.EXTRA_LIVE_FOLDER_ICON
                 Intent.ShortcutIconResource.fromContext(context icon));
         intent.putExtra(LiveFolders.EXTRA_LIVE_FOLDER_DISPLAY_MODE LiveFolders.DISPLAY_MODE_LIST);

         return intent;
     }
 }
  The live folder is described by an  Intent  as follows: Component Type Description Required URI URI The ContentProvider URI Yes EXTRA_LIVE_FOLDER_NAME Extra String The name of the live folder Yes EXTRA_LIVE_FOLDER_ICON Extra  Intent.ShortcutIconResource The icon of the live folder Yes EXTRA_LIVE_FOLDER_DISPLAY_MODE Extra int The display mode of the live folder. The value must be either
          DISPLAY_MODE_GRID  or  DISPLAY_MODE_LIST . Yes EXTRA_LIVE_FOLDER_BASE_INTENT Extra Intent When the user clicks an item inside a live folder the system will either fire
         the intent associated with that item or if present the live folder's base intent
         with the id of the item appended to the base intent's URI. No Setting up the content provider The live folder's content provider must upon query return a  Cursor 
 whose columns match the following names: Column Type Description Required NAME String The name of the item Yes DESCRIPTION String The description of the item. The description is ignored when the live folder's
         display mode is  DISPLAY_MODE_GRID . No INTENT Intent The intent to fire when the item is clicked. Ignored when the live folder defines
         a base intent. No ICON_BITMAP Bitmap The icon for the item. When this column value is not null the values for the
         columns  ICON_PACKAGE  and  ICON_RESOURCE  must be null. No ICON_PACKAGE String The package of the item's icon. When this value is not null the value for the
         column  ICON_RESOURCE  must be specified and the value for the column
          ICON_BITMAP  must be null. No ICON_RESOURCE String The resource name of the item's icon. When this value is not null the value for the
         column  ICON_PACKAGE  must be specified and the value for the column
          ICON_BITMAP  must be null. No"
android,provider,MediaStore.Audio.Artists.Albums,1,"Sub-directory of each artist containing all albums on which
 a song by the artist appears."
android,provider,MediaStore.Audio.Genres.Members,1,Sub-directory of each genre containing all members.
android,provider,MediaStore.Audio.Media,2,
android,provider,MediaStore.Video.Media,1,
android,provider,Settings.System,17,"System settings containing miscellaneous system preferences.  This
 table holds simple name/value pairs.  There are convenience
 functions for accessing individual settings entries."
android,provider,Telephony.Carriers,0,Carriers class contains information about APNs including MMSC information.
android,provider,Telephony.Mms,0,Contains all MMS messages.
android,provider,Telephony.Mms.Rate,0,Message send rate table.
android,provider,Telephony.Mms.Sent,0,Contains all MMS messages in the MMS app sent folder.
android,provider,Telephony.ServiceStateTable,2,"Constants for interfacing with the ServiceStateProvider and the different fields of the
  ServiceState  class accessible through the provider."
android,provider,Telephony.Sms.Draft,0,Contains all sent text-based SMS messages in the SMS app.
android,provider,Telephony.Sms.Sent,0,Contains all sent text-based SMS messages in the SMS app.
android,provider,Contacts.People.ContactMethods,0,"A subdirectory of a single person that contains all of their
 ContactMethods."
android,provider,Contacts.Photos,0,The photos over all of the people
android,provider,ContactsContract.CommonDataKinds.Event,2,"A data kind representing an event.
  
 You can use all columns defined for  ContactsContract.Data  as
 well as the following aliases."
android,provider,ContactsContract.CommonDataKinds.Note,0,"Notes about the contact.
  
 You can use all columns defined for  ContactsContract.Data  as
 well as the following aliases."
android,provider,ContactsContract.Contacts.Data,0,"A sub-directory of a single contact that contains all of the constituent raw contact
  ContactsContract.Data  rows.  This directory can be used either
 with a  ContactsContract.Contacts.CONTENT_URI  or  ContactsContract.Contacts.CONTENT_LOOKUP_URI ."
android,provider,ContactsContract.Data,1,"Constants for the data table which contains data points tied to a raw
 contact.  Each row of the data table is typically used to store a single
 piece of contact
 information (such as a phone number) and its
 associated metadata (such as whether it is a work or home number).
  Data kinds 
 Data is a generic table that can hold any kind of contact data.
 The kind of data stored in a given row is specified by the row's
  ContactsContract.DataColumns.MIMETYPE  value which determines the meaning of the
 generic columns  ContactsContract.DataColumns.DATA1  through
  ContactsContract.DataColumns.DATA15 .
 For example if the data kind is
  CommonDataKinds.Phone  then the column
  ContactsContract.DataColumns.DATA1  stores the
 phone number but if the data kind is
  CommonDataKinds.Email  then  ContactsContract.DataColumns.DATA1 
 stores the email address.
 Sync adapters and applications can introduce their own data kinds.
  
 ContactsContract defines a small number of pre-defined data kinds e.g.
  CommonDataKinds.Phone   CommonDataKinds.Email  etc. As a
 convenience these classes define data kind specific aliases for DATA1 etc.
 For example  CommonDataKinds.Phone  is the same as
  ContactsContract.Data .
  ContactsContract.DataColumns.DATA1  is an indexed column and should be used for the data element that is
 expected to be most frequently used in query selections. For example in the
 case of a row representing email addresses  ContactsContract.DataColumns.DATA1  should probably
 be used for the email address itself while  ContactsContract.DataColumns.DATA2  etc can be
 used for auxiliary information like type of email address.
  
 By convention  ContactsContract.DataColumns.DATA15  is used for storing BLOBs (binary data).
  
 The sync adapter for a given account type must correctly handle every data type
 used in the corresponding raw contacts.  Otherwise it could result in lost or
 corrupted data.
  
 Similarly you should refrain from introducing new kinds of data for an other
 party's account types. For example if you add a data row for
 ""favorite song"" to a raw contact owned by a Google account it will not
 get synced to the server because the Google sync adapter does not know
 how to handle this data kind. Thus new data kinds are typically
 introduced along with new account types i.e. new sync adapters.
  Batch operations 
 Data rows can be inserted/updated/deleted using the traditional
  ContentResolver#insert   ContentResolver#update  and
  ContentResolver#delete  methods however the newer mechanism based
 on a batch of  ContentProviderOperation  will prove to be a better
 choice in almost all cases. All operations in a batch are executed in a
 single transaction which ensures that the phone-side and server-side
 state of a raw contact are always consistent. Also the batch-based
 approach is far more efficient: not only are the database operations
 faster when executed in a single transaction but also sending a batch of
 commands to the content provider saves a lot of time on context switching
 between your process and the process in which the content provider runs.
  
 The flip side of using batched operations is that a large batch may lock
 up the database for a long time preventing other applications from
 accessing data and potentially causing ANRs (""Application Not Responding""
 dialogs.)
  
 To avoid such lockups of the database make sure to insert ""yield points""
 in the batch. A yield point indicates to the content provider that before
 executing the next operation it can commit the changes that have already
 been made yield to other requests open another transaction and continue
 processing operations. A yield point will not automatically commit the
 transaction but only if there is another request waiting on the
 database. Normally a sync adapter should insert a yield point at the
 beginning of each raw contact operation sequence in the batch. See
  ContentProviderOperation.Builder#withYieldAllowed(boolean) .
  Operations Insert 
 An individual data row can be inserted using the traditional
  ContentResolver#insert(Uri ContentValues)  method. Multiple rows
 should always be inserted as a batch.
  
 An example of a traditional insert:
  
 ContentValues values = new ContentValues();
 values.put(Data.RAW_CONTACT_ID rawContactId);
 values.put(Data.MIMETYPE Phone.CONTENT_ITEM_TYPE);
 values.put(Phone.NUMBER ""1-800-GOOG-411"");
 values.put(Phone.TYPE Phone.TYPE_CUSTOM);
 values.put(Phone.LABEL ""free directory assistance"");
 Uri dataUri = getContentResolver().insert(Data.CONTENT_URI values);
  
 The same done using ContentProviderOperations:
  
 ArrayList<ContentProviderOperation> ops =
          new ArrayList<ContentProviderOperation>();

 ops.add(ContentProviderOperation.newInsert(Data.CONTENT_URI)
          .withValue(Data.RAW_CONTACT_ID rawContactId)
          .withValue(Data.MIMETYPE Phone.CONTENT_ITEM_TYPE)
          .withValue(Phone.NUMBER ""1-800-GOOG-411"")
          .withValue(Phone.TYPE Phone.TYPE_CUSTOM)
          .withValue(Phone.LABEL ""free directory assistance"")
          .build());
 getContentResolver().applyBatch(ContactsContract.AUTHORITY ops);
  Update 
 Just as with insert update can be done incrementally or as a batch
 the batch mode being the preferred method:
  
 ArrayList<ContentProviderOperation> ops =
          new ArrayList<ContentProviderOperation>();

 ops.add(ContentProviderOperation.newUpdate(Data.CONTENT_URI)
          .withSelection(Data._ID + ""=?"" new String[]{String.valueOf(dataId)})
          .withValue(Email.DATA ""somebody@android.com"")
          .build());
 getContentResolver().applyBatch(ContactsContract.AUTHORITY ops);
  Delete 
 Just as with insert and update deletion can be done either using the
  ContentResolver#delete  method or using a ContentProviderOperation:
  
 ArrayList<ContentProviderOperation> ops =
          new ArrayList<ContentProviderOperation>();

 ops.add(ContentProviderOperation.newDelete(Data.CONTENT_URI)
          .withSelection(Data._ID + ""=?"" new String[]{String.valueOf(dataId)})
          .build());
 getContentResolver().applyBatch(ContactsContract.AUTHORITY ops);
  Query Finding all Data of a given type for a given contact 
 Cursor c = getContentResolver().query(Data.CONTENT_URI
          new String[] {Data._ID Phone.NUMBER Phone.TYPE Phone.LABEL}
          Data.CONTACT_ID + ""=?"" + "" AND ""
                  + Data.MIMETYPE + ""='"" + Phone.CONTENT_ITEM_TYPE + ""'""
          new String[] {String.valueOf(contactId)} null);
  Finding all Data of a given type for a given raw contact 
 Cursor c = getContentResolver().query(Data.CONTENT_URI
          new String[] {Data._ID Phone.NUMBER Phone.TYPE Phone.LABEL}
          Data.RAW_CONTACT_ID + ""=?"" + "" AND ""
                  + Data.MIMETYPE + ""='"" + Phone.CONTENT_ITEM_TYPE + ""'""
          new String[] {String.valueOf(rawContactId)} null);
  Finding all Data for a given raw contact 
 Most sync adapters will want to read all data rows for a raw contact
 along with the raw contact itself.  For that you should use the
  RawContactsEntity . See also  RawContacts ."
android,provider,ContactsContract.Groups,1,Constants for the groups table. Only per-account groups are supported.
android,provider,ContactsContract.Settings,0,Contacts-specific settings for various  Account 's.
android,provider,MediaStore.Downloads,1,Collection of downloaded items.
android,provider,ContactsContract.SyncState,4,A table provided for sync adapters to use for storing private sync state data for contacts.
android,provider,MediaStore.Audio.Radio,0,
android,provider,MediaStore.Video.Thumbnails,5,"This class provides utility methods to obtain thumbnails for various
  Video  items."
android,provider,Telephony.Sms.Conversations,0,Contains all sent text-based SMS messages in the SMS app.
android,provider,Telephony.Threads,2,"Helper functions for the ""threads"" table used by MMS and SMS.

 Thread IDs are determined by the participants in a conversation and can be used to match
 both SMS and MMS messages.

 To avoid issues where applications might cache a thread ID the thread ID of a deleted thread
 must not be reused to point at a new thread."
android,java.lang,Byte,21,"The  Byte  class wraps a value of primitive type  byte 
 in an object.  An object of type  Byte  contains a single
 field whose type is  byte .

  In addition this class provides several methods for converting
 a  byte  to a  String  and a  String  to a  byte  as well as other constants and methods useful when dealing
 with a  byte ."
android,java.lang,Character.UnicodeBlock,3,"A family of character subsets representing the character blocks in the
 Unicode specification. Character blocks generally define characters
 used for a specific script or purpose. A character is contained by
 at most one Unicode block."
android,java.lang,Class,61,"Instances of the class  Class  represent classes and
 interfaces in a running Java application.  An enum is a kind of
 class and an annotation is a kind of interface.  Every array also
 belongs to a class that is reflected as a  Class  object
 that is shared by all arrays with the same element type and number
 of dimensions.  The primitive Java types ( boolean 
  byte   char   short 
  int   long   float  and
  double ) and the keyword  void  are also
 represented as  Class  objects.

  Class  has no public constructor. Instead  Class 
 objects are constructed automatically by the Java Virtual Machine as classes
 are loaded and by calls to the  defineClass  method in the class
 loader.

   The following example uses a  Class  object to print the
 class name of an object:

  
     void printClassName(Object obj) {
         System.out.println(""The class of "" + obj +
                            "" is "" + obj.getClass().getName());
     }
   It is also possible to get the  Class  object for a named
 type (or for void) using a class literal.  See Section 15.8.2 of
  The Javaâ„¢ Language Specification .
 For example:

  System.out.println(""The name of class Foo is: ""+Foo.class.getName());"
android,java.lang,ClassLoader,30,"A class loader is an object that is responsible for loading classes. The
 class  ClassLoader  is an abstract class.  Given the  binary name  of a class a class loader should attempt to
 locate or generate data that constitutes a definition for the class.  A
 typical strategy is to transform the name into a file name and then read a
 ""class file"" of that name from a file system.

   Every  Class  object contains a  Class#getClassLoader()  to the  ClassLoader  that defined
 it.

  Class  objects for array classes are not created by class
 loaders but are created automatically as required by the Java runtime.
 The class loader for an array class as returned by  Class#getClassLoader()  is the same as the class loader for its element
 type; if the element type is a primitive type then the array class has no
 class loader.

   Applications implement subclasses of  ClassLoader  in order to
 extend the manner in which the Java virtual machine dynamically loads
 classes.

   Class loaders may typically be used by security managers to indicate
 security domains.

   The  ClassLoader  class uses a delegation model to search for
 classes and resources.  Each instance of  ClassLoader  has an
 associated parent class loader.  When requested to find a class or
 resource a  ClassLoader  instance will delegate the search for the
 class or resource to its parent class loader before attempting to find the
 class or resource itself.  The virtual machine's built-in class loader
 called the ""bootstrap class loader"" does not itself have a parent but may
 serve as the parent of a  ClassLoader  instance.

   Class loaders that support concurrent loading of classes are known as
  parallel capable  class loaders and are required to register
 themselves at their class initialization time by invoking the
  ClassLoader.registerAsParallelCapable 
 method. Note that the  ClassLoader  class is registered as parallel
 capable by default. However its subclasses still need to register themselves
 if they are parallel capable.  
 In environments in which the delegation model is not strictly
 hierarchical class loaders need to be parallel capable otherwise class
 loading can lead to deadlocks because the loader lock is held for the
 duration of the class loading process (see  loadClass  methods).

   Normally the Java virtual machine loads classes from the local file
 system in a platform-dependent manner.  For example on UNIX systems the
 virtual machine loads classes from the directory defined by the
  CLASSPATH  environment variable.

   However some classes may not originate from a file; they may originate
 from other sources such as the network or they could be constructed by an
 application.  The method  defineClass  converts an array of bytes into an instance of class
  Class . Instances of this newly defined class can be created using
  Class#newInstance .

   The methods and constructors of objects created by a class loader may
 reference other classes.  To determine the class(es) referred to the Java
 virtual machine invokes the  loadClass  method of
 the class loader that originally created the class.

   For example an application could create a network class loader to
 download class files from a server.  Sample code might look like:

  
   ClassLoader loaderÂ = new NetworkClassLoader(hostÂ port);
   Object mainÂ = loader.loadClass(""Main"" true).newInstance();
       Â .Â .Â .
   The network class loader subclass must define the methods  findClass  and  loadClassData  to load a class
 from the network.  Once it has downloaded the bytes that make up the class
 it should use the method  defineClass  to
 create a class instance.  A sample implementation is:

  
     class NetworkClassLoader extends ClassLoader {
         String host;
         int port;

         public Class findClass(String name) {
             byte[] b = loadClassData(name);
             return defineClass(name b 0 b.length);
         }

         private byte[] loadClassData(String name) {
             // load the class data from the connection
             Â .Â .Â .
         }
     }
  Binary names  Any class name provided as a  String  parameter to methods in
  ClassLoader  must be a binary name as defined by
  The Javaâ„¢ Language Specification .

   Examples of valid class names include:
  
   ""java.lang.String""
   ""javax.swing.JSpinner$DefaultEditor""
   ""java.security.KeyStore$Builder$FileBuilder$1""
   ""java.net.URLClassLoader$3$1"""
android,java.lang,Compiler,5,Does nothing on Android.
android,java.lang,Double,28,"The  Double  class wraps a value of the primitive type
  double  in an object. An object of type
  Double  contains a single field whose type is
  double .

  In addition this class provides several methods for converting a
  double  to a  String  and a
  String  to a  double  as well as other
 constants and methods useful when dealing with a
  double ."
android,java.lang,Enum,10,"This is the common base class of all Java language enumeration types.

 More information about enums including descriptions of the
 implicitly declared methods synthesized by the compiler can be
 found in section 8.9 of
  The Javaâ„¢ Language Specification .

   Note that when using an enumeration type as the type of a set
 or as the type of the keys in a map specialized and efficient
  set  and  map  implementations are available."
android,java.lang,Float,28,"The  Float  class wraps a value of primitive type
  float  in an object. An object of type
  Float  contains a single field whose type is
  float .

  In addition this class provides several methods for converting a
  float  to a  String  and a
  String  to a  float  as well as other
 constants and methods useful when dealing with a
  float ."
android,java.lang,InheritableThreadLocal,0,"This class extends  ThreadLocal  to provide inheritance of values
 from parent thread to child thread: when a child thread is created the
 child receives initial values for all inheritable thread-local variables
 for which the parent has values.  Normally the child's values will be
 identical to the parent's; however the child's value can be made an
 arbitrary function of the parent's by overriding the  childValue 
 method in this class.

  Inheritable thread-local variables are used in preference to
 ordinary thread-local variables when the per-thread-attribute being
 maintained in the variable (e.g. User ID Transaction ID) must be
 automatically transmitted to any child threads that are created."
android,java.lang,Integer,47,"The  Integer  class wraps a value of the primitive type
  int  in an object. An object of type  Integer 
 contains a single field whose type is  int .

  In addition this class provides several methods for converting
 an  int  to a  String  and a  String  to an
  int  as well as other constants and methods useful when
 dealing with an  int .

  Implementation note: The implementations of the ""bit twiddling""
 methods (such as  highestOneBit  and
  numberOfTrailingZeros ) are
 based on material from Henry S. Warren Jr.'s  Hacker's
 Delight  (Addison Wesley 2002)."
android,java.lang,Math,73,"The class  Math  contains methods for performing basic
 numeric operations such as the elementary exponential logarithm
 square root and trigonometric functions.

  Unlike some of the numeric methods of class
  StrictMath  all implementations of the equivalent
 functions of class  Math  are not defined to return the
 bit-for-bit same results.  This relaxation permits
 better-performing implementations where strict reproducibility is
 not required.

  By default many of the  Math  methods simply call
 the equivalent method in  StrictMath  for their
 implementation.  Code generators are encouraged to use
 platform-specific native libraries or microprocessor instructions
 where available to provide higher-performance implementations of
  Math  methods.  Such higher-performance
 implementations still must conform to the specification for
  Math .

  The quality of implementation specifications concern two
 properties accuracy of the returned result and monotonicity of the
 method.  Accuracy of the floating-point  Math  methods is
 measured in terms of  ulps  units in the last place.  For a
 given floating-point format an  ulp  of a
 specific real number value is the distance between the two
 floating-point values bracketing that numerical value.  When
 discussing the accuracy of a method as a whole rather than at a
 specific argument the number of ulps cited is for the worst-case
 error at any argument.  If a method always has an error less than
 0.5 ulps the method always returns the floating-point number
 nearest the exact result; such a method is  correctly
 rounded .  A correctly rounded method is generally the best a
 floating-point approximation can be; however it is impractical for
 many floating-point methods to be correctly rounded.  Instead for
 the  Math  class a larger error bound of 1 or 2 ulps is
 allowed for certain methods.  Informally with a 1 ulp error bound
 when the exact result is a representable number the exact result
 should be returned as the computed result; otherwise either of the
 two floating-point values which bracket the exact result may be
 returned.  For exact results large in magnitude one of the
 endpoints of the bracket may be infinite.  Besides accuracy at
 individual arguments maintaining proper relations between the
 method at different arguments is also important.  Therefore most
 methods with more than 0.5 ulp errors are required to be
  semi-monotonic : whenever the mathematical function is
 non-decreasing so is the floating-point approximation likewise
 whenever the mathematical function is non-increasing so is the
 floating-point approximation.  Not all approximations that have 1
 ulp accuracy will automatically meet the monotonicity requirements.

  
 The platform uses signed two's complement integer arithmetic with
 int and long primitive types.  The developer should choose
 the primitive type to ensure that arithmetic operations consistently
 produce correct results which in some cases means the operations
 will not overflow the range of values of the computation.
 The best practice is to choose the primitive type and algorithm to avoid
 overflow. In cases where the size is  int  or  long  and
 overflow errors need to be detected the methods  addExact 
  subtractExact   multiplyExact  and  toIntExact 
 throw an  ArithmeticException  when the results overflow.
 For other arithmetic operations such as divide absolute value
 increment decrement and negation overflow occurs only with
 a specific minimum or maximum value and should be checked against
 the minimum or maximum as appropriate."
android,java.lang,Number,6,"The abstract class  Number  is the superclass of platform
 classes representing numeric values that are convertible to the
 primitive types  byte   double   float   int   long  and  short .

 The specific semantics of the conversion from the numeric value of
 a particular  Number  implementation to a given primitive
 type is defined by the  Number  implementation in question.

 For platform classes the conversion is often analogous to a
 narrowing primitive conversion or a widening primitive conversion
 as defining in  The Javaâ„¢ Language Specification 
 for converting between primitive types.  Therefore conversions may
 lose information about the overall magnitude of a numeric value may
 lose precision and may even return a result of a different sign
 than the input.

 See the documentation of a given  Number  implementation for
 conversion details."
android,java.lang,Package,21,"Package  objects contain version information
 about the implementation and specification of a Java package.
 This versioning information is retrieved and made available
 by the  ClassLoader  instance that
 loaded the class(es).  Typically it is stored in the manifest that is
 distributed with the classes.

  The set of classes that make up the package may implement a
 particular specification and if so the specification title version number
 and vendor strings identify that specification.
 An application can ask if the package is
 compatible with a particular version see the  isCompatibleWith 
 method for details.

  Specification version numbers use a syntax that consists of nonnegative
 decimal integers separated by periods ""."" for example ""2.0"" or
 ""1.2.3.4.5.6.7"".  This allows an extensible number to be used to represent
 major minor micro etc. versions.  The version specification is described
 by the following formal grammar:
  SpecificationVersion: Digits RefinedVersion opt RefinedVersion: . Digits . Digits RefinedVersion Digits: Digit Digits Digit: any character for which  Character#isDigit  returns  true 
 e.g. 0 1 2 ...
  The implementation title version and vendor strings identify an
 implementation and are made available conveniently to enable accurate
 reporting of the packages involved when a problem occurs. The contents
 all three implementation strings are vendor specific. The
 implementation version strings have no specified syntax and should
 only be compared for equality with desired version identifiers.

  Within each  ClassLoader  instance all classes from the same
 java package have the same Package object.  The static methods allow a package
 to be found by name or the set of all packages known to the current class
 loader to be found."
android,java.lang,Process,9,"The  ProcessBuilder#start()  and
  Runtime#exec(String[]String[]File) 
 methods create a native process and return an instance of a
 subclass of  Process  that can be used to control the process
 and obtain information about it.  The class  Process 
 provides methods for performing input from the process performing
 output to the process waiting for the process to complete
 checking the exit status of the process and destroying (killing)
 the process.

  The methods that create processes may not work well for special
 processes on certain native platforms such as native windowing
 processes daemon processes Win16/DOS processes on Microsoft
 Windows or shell scripts.

  By default the created subprocess does not have its own terminal
 or console.  All its standard I/O (i.e. stdin stdout stderr)
 operations will be redirected to the parent process where they can
 be accessed via the streams obtained using the methods
  getOutputStream() 
  getInputStream()  and
  getErrorStream() .
 The parent process uses these streams to feed input to and get output
 from the subprocess.  Because some native platforms only provide
 limited buffer size for standard input and output streams failure
 to promptly write the input stream or read the output stream of
 the subprocess may cause the subprocess to block or even deadlock.

  Where desired  
 subprocess I/O can also be redirected 
 using methods of the  ProcessBuilder  class.

  The subprocess is not killed when there are no more references to
 the  Process  object but rather the subprocess
 continues executing asynchronously.

  There is no requirement that a process represented by a  Process  object execute asynchronously or concurrently with respect
 to the Java process that owns the  Process  object.

  As of 1.5  ProcessBuilder#start()  is the preferred way
 to create a  Process ."
android,java.lang,ProcessBuilder.Redirect,7,"Represents a source of subprocess input or a destination of
 subprocess output.

 Each  Redirect  instance is one of the following:

  the special value  Redirect.PIPE the special value  Redirect.INHERIT a redirection to read from a file created by an invocation of
      Redirect#from a redirection to write to a file  created by an invocation of
      Redirect#to a redirection to append to a file created by an invocation of
      Redirect#appendTo Each of the above categories has an associated unique
  Type ."
android,java.lang,RuntimePermission,0,Legacy security code; do not use.
android,java.lang,SecurityManager,41,"Legacy security code; do not use.

  Security managers do  not  provide a secure environment for
 executing untrusted code and are unsupported on Android. Untrusted code
 cannot be safely isolated within a single VM on Android. Application
 developers can assume that there's no SecurityManager installed
 i.e.  System.getSecurityManager()  will return null."
android,java.lang,StrictMath,67,"The class  StrictMath  contains methods for performing basic
 numeric operations such as the elementary exponential logarithm
 square root and trigonometric functions.

  To help ensure portability of Java programs the definitions of
 some of the numeric functions in this package require that they
 produce the same results as certain published algorithms. These
 algorithms are available from the well-known network library
  netlib  as the package ""Freely Distributable Math
 Library""  fdlibm . These
 algorithms which are written in the C programming language are
 then to be understood as executed with all floating-point
 operations following the rules of Java floating-point arithmetic.

  The Java math library is defined with respect to
  fdlibm  version 5.3. Where  fdlibm  provides
 more than one definition for a function (such as
  acos ) use the ""IEEE 754 core function"" version
 (residing in a file whose name begins with the letter
  e ).  The methods which require  fdlibm 
 semantics are  sin   cos   tan 
  asin   acos   atan 
  exp   log   log10 
  cbrt   atan2   pow 
  sinh   cosh   tanh 
  hypot   expm1  and  log1p .

  
 The platform uses signed two's complement integer arithmetic with
 int and long primitive types.  The developer should choose
 the primitive type to ensure that arithmetic operations consistently
 produce correct results which in some cases means the operations
 will not overflow the range of values of the computation.
 The best practice is to choose the primitive type and algorithm to avoid
 overflow. In cases where the size is  int  or  long  and
 overflow errors need to be detected the methods  addExact 
  subtractExact   multiplyExact  and  toIntExact 
 throw an  ArithmeticException  when the results overflow.
 For other arithmetic operations such as divide absolute value
 increment decrement and negation overflow occurs only with
 a specific minimum or maximum value and should be checked against
 the minimum or maximum as appropriate."
android,java.lang,StringBuffer,50,"A thread-safe mutable sequence of characters.
 A string buffer is like a  String  but can be modified. At any
 point in time it contains some particular sequence of characters but
 the length and content of the sequence can be changed through certain
 method calls.
  
 String buffers are safe for use by multiple threads. The methods
 are synchronized where necessary so that all the operations on any
 particular instance behave as if they occur in some serial order
 that is consistent with the order of the method calls made by each of
 the individual threads involved.
  
 The principal operations on a  StringBuffer  are the
  append  and  insert  methods which are
 overloaded so as to accept data of any type. Each effectively
 converts a given datum to a string and then appends or inserts the
 characters of that string to the string buffer. The
  append  method always adds these characters at the end
 of the buffer; the  insert  method adds the characters at
 a specified point.
  
 For example if  z  refers to a string buffer object
 whose current contents are  ""start""  then
 the method call  z.append(""le"")  would cause the string
 buffer to contain  ""startle""  whereas
  z.insert(4 ""le"")  would alter the string buffer to
 contain  ""starlet"" .
  
 In general if sb refers to an instance of a  StringBuffer 
 then  sb.append(x)  has the same effect as
  sb.insert(sb.length() x) .
  
 Whenever an operation occurs involving a source sequence (such as
 appending or inserting from a source sequence) this class synchronizes
 only on the string buffer performing the operation not on the source.
 Note that while  StringBuffer  is designed to be safe to use
 concurrently from multiple threads if the constructor or the
  append  or  insert  operation is passed a source sequence
 that is shared across threads the calling code must ensure
 that the operation has a consistent and unchanging view of the source
 sequence for the duration of the operation.
 This could be satisfied by the caller holding a lock during the
 operation's call by using an immutable source sequence or by not
 sharing the source sequence across threads.
  
 Every string buffer has a capacity. As long as the length of the
 character sequence contained in the string buffer does not exceed
 the capacity it is not necessary to allocate a new internal
 buffer array. If the internal buffer overflows it is
 automatically made larger.
  
 Unless otherwise noted passing a  null  argument to a constructor
 or method in this class will cause a  NullPointerException  to be
 thrown.
  
 As of  release JDK 5 this class has been supplemented with an equivalent
 class designed for use by a single thread  StringBuilder .  The
  StringBuilder  class should generally be used in preference to
 this one as it supports all of the same operations but it is faster as
 it performs no synchronization."
android,java.lang,StringBuilder,50,"A mutable sequence of characters.  This class provides an API compatible
 with  StringBuffer  but with no guarantee of synchronization.
 This class is designed for use as a drop-in replacement for
  StringBuffer  in places where the string buffer was being
 used by a single thread (as is generally the case).   Where possible
 it is recommended that this class be used in preference to
  StringBuffer  as it will be faster under most implementations.

  The principal operations on a  StringBuilder  are the
  append  and  insert  methods which are
 overloaded so as to accept data of any type. Each effectively
 converts a given datum to a string and then appends or inserts the
 characters of that string to the string builder. The
  append  method always adds these characters at the end
 of the builder; the  insert  method adds the characters at
 a specified point.
  
 For example if  z  refers to a string builder object
 whose current contents are "" start "" then
 the method call  z.append(""le"")  would cause the string
 builder to contain "" startle "" whereas
  z.insert(4 ""le"")  would alter the string builder to
 contain "" starlet "".
  
 In general if sb refers to an instance of a  StringBuilder 
 then  sb.append(x)  has the same effect as
  sb.insert(sb.length() x) .
  
 Every string builder has a capacity. As long as the length of the
 character sequence contained in the string builder does not exceed
 the capacity it is not necessary to allocate a new internal
 buffer. If the internal buffer overflows it is automatically made larger.

  Instances of  StringBuilder  are not safe for
 use by multiple threads. If such synchronization is required then it is
 recommended that  StringBuffer  be used.

  Unless otherwise noted passing a  null  argument to a constructor
 or method in this class will cause a  NullPointerException  to be
 thrown."
android,java.lang,System,27,"The  System  class contains several useful class fields
 and methods. It cannot be instantiated.

  Among the facilities provided by the  System  class
 are standard input standard output and error output streams;
 access to externally defined properties and environment
 variables; a means of loading files and libraries; and a utility
 method for quickly copying a portion of an array."
android,java.lang,Thread,43,"A  thread  is a thread of execution in a program. The Java
 Virtual Machine allows an application to have multiple threads of
 execution running concurrently.
  
 Every thread has a priority. Threads with higher priority are
 executed in preference to threads with lower priority. Each thread
 may or may not also be marked as a daemon. When code running in
 some thread creates a new  Thread  object the new
 thread has its priority initially set equal to the priority of the
 creating thread and is a daemon thread if and only if the
 creating thread is a daemon.
  
 When a Java Virtual Machine starts up there is usually a single
 non-daemon thread (which typically calls the method named
  main  of some designated class). The Java Virtual
 Machine continues to execute threads until either of the following
 occurs:
  The  exit  method of class  Runtime  has been
     called and the security manager has permitted the exit operation
     to take place.
  All threads that are not daemon threads have died either by
     returning from the call to the  run  method or by
     throwing an exception that propagates beyond the  run 
     method.
  
 There are two ways to create a new thread of execution. One is to
 declare a class to be a subclass of  Thread . This
 subclass should override the  run  method of class
  Thread . An instance of the subclass can then be
 allocated and started. For example a thread that computes primes
 larger than a stated value could be written as follows:
  
     class PrimeThread extends Thread {
         long minPrime;
         PrimeThread(long minPrime) {
             this.minPrime = minPrime;
         }

         public void run() {
             // compute primes larger than minPrime
             Â .Â .Â .
         }
     }
  
 The following code would then create a thread and start it running:
  
     PrimeThread p = new PrimeThread(143);
     p.start();
  
 The other way to create a thread is to declare a class that
 implements the  Runnable  interface. That class then
 implements the  run  method. An instance of the class can
 then be allocated passed as an argument when creating
  Thread  and started. The same example in this other
 style looks like the following:
  
     class PrimeRun implements Runnable {
         long minPrime;
         PrimeRun(long minPrime) {
             this.minPrime = minPrime;
         }

         public void run() {
             // compute primes larger than minPrime
             Â .Â .Â .
         }
     }
  
 The following code would then create a thread and start it running:
  
     PrimeRun p = new PrimeRun(143);
     new Thread(p).start();
  
 Every thread has a name for identification purposes. More than
 one thread may have the same name. If a name is not specified when
 a thread is created a new name is generated for it.
  
 Unless otherwise noted passing a  null  argument to a constructor
 or method in this class will cause a  NullPointerException  to be
 thrown."
android,java.lang,ThreadGroup,24,"A thread group represents a set of threads. In addition a thread
 group can also include other thread groups. The thread groups form
 a tree in which every thread group except the initial thread group
 has a parent.
  
 A thread is allowed to access information about its own thread
 group but not to access information about its thread group's
 parent thread group or any other thread groups."
android,java.lang,Void,0,"The  Void  class is an uninstantiable placeholder class to hold a
 reference to the  Class  object representing the Java keyword
 void."
android,java.lang,Boolean,15,"The Boolean class wraps a value of the primitive type
  boolean  in an object. An object of type
  Boolean  contains a single field whose type is
  boolean .
  
 In addition this class provides many methods for
 converting a  boolean  to a  String  and a
  String  to a  boolean  as well as other
 constants and methods useful when dealing with a
  boolean ."
android,java.lang,Character,86,"The  Character  class wraps a value of the primitive
 type  char  in an object. An object of type
  Character  contains a single field whose type is
  char .
  
 In addition this class provides several methods for determining
 a character's category (lowercase letter digit etc.) and for converting
 characters from uppercase to lowercase and vice versa.
  
 Character information is based on the Unicode Standard
  
 The methods and data of class  Character  are defined by
 the information in the  UnicodeData  file that is part of the
 Unicode Character Database maintained by the Unicode
 Consortium. This file specifies various properties including name
 and general category for every defined Unicode code point or
 character range.
  
 The file and its description are available from the Unicode Consortium at:
  http://www.unicode.org Unicode Character Representations The  char  data type (and therefore the value that a
  Character  object encapsulates) are based on the
 original Unicode specification which defined characters as
 fixed-width 16-bit entities. The Unicode Standard has since been
 changed to allow for characters whose representation requires more
 than 16 bits.  The range of legal  code point s is now
 U+0000 to U+10FFFF known as  Unicode scalar value .
 (Refer to the  
 definition  of the U+ n  notation in the Unicode
 Standard.)

  The set of characters from U+0000 to U+FFFF  is
 sometimes referred to as the  Basic Multilingual Plane (BMP) .
  Characters  whose code points are greater
 than U+FFFF are called  supplementary character s.  The Java
 platform uses the UTF-16 representation in  char  arrays and
 in the  String  and  StringBuffer  classes. In
 this representation supplementary characters are represented as a pair
 of  char  values the first from the  high-surrogates 
 range (\uD800-\uDBFF) the second from the
  low-surrogates  range (\uDC00-\uDFFF).

  A  char  value therefore represents Basic
 Multilingual Plane (BMP) code points including the surrogate
 code points or code units of the UTF-16 encoding. An
  int  value represents all Unicode code points
 including supplementary code points. The lower (least significant)
 21 bits of  int  are used to represent Unicode code
 points and the upper (most significant) 11 bits must be zero.
 Unless otherwise specified the behavior with respect to
 supplementary characters and surrogate  char  values is
 as follows:

  The methods that only accept a  char  value cannot support
 supplementary characters. They treat  char  values from the
 surrogate ranges as undefined characters. For example
  Character.isLetter('\uD840')  returns  false  even though
 this specific value if followed by any low-surrogate value in a string
 would represent a letter.

  The methods that accept an  int  value support all
 Unicode characters including supplementary characters. For
 example  Character.isLetter(0x2F81A)  returns
  true  because the code point value represents a letter
 (a CJK ideograph).
  In the Java SE API documentation  Unicode code point  is
 used for character values in the range between U+0000 and U+10FFFF
 and  Unicode code unit  is used for 16-bit
  char  values that are code units of the  UTF-16 
 encoding. For more information on Unicode terminology refer to the
  Unicode Glossary ."
android,java.lang,Character.Subset,3,"Instances of this class represent particular subsets of the Unicode
 character set.  The only family of subsets defined in the
  Character  class is  Character.UnicodeBlock .
 Other portions of the Java API may define other subsets for their
 own purposes."
android,java.lang,Long,46,"The  Long  class wraps a value of the primitive type  long  in an object. An object of type  Long  contains a
 single field whose type is  long .

   In addition this class provides several methods for converting
 a  long  to a  String  and a  String  to a  long  as well as other constants and methods useful when dealing
 with a  long .

  Implementation note: The implementations of the ""bit twiddling""
 methods (such as  highestOneBit  and
  numberOfTrailingZeros ) are
 based on material from Henry S. Warren Jr.'s  Hacker's
 Delight  (Addison Wesley 2002)."
android,java.lang,Object,11,"Class  Object  is the root of the class hierarchy.
 Every class has  Object  as a superclass. All objects
 including arrays implement the methods of this class."
android,java.lang,String,67,"The  String  class represents character strings. All
 string literals in Java programs such as  ""abc""  are
 implemented as instances of this class.
  
 Strings are constant; their values cannot be changed after they
 are created. String buffers support mutable strings.
 Because String objects are immutable they can be shared. For example:
  
     String str = ""abc"";
  
 is equivalent to:
  
     char data[] = {'a' 'b' 'c'};
     String str = new String(data);
  
 Here are some more examples of how strings can be used:
  
     System.out.println(""abc"");
     String cde = ""cde"";
     System.out.println(""abc"" + cde);
     String c = ""abc"".substring(23);
     String d = cde.substring(1 2);
  
 The class  String  includes methods for examining
 individual characters of the sequence for comparing strings for
 searching strings for extracting substrings and for creating a
 copy of a string with all characters translated to uppercase or to
 lowercase. Case mapping is based on the Unicode Standard version
 specified by the  Character  class.
  
 The Java language provides special support for the string
 concatenation operator (Â +Â ) and for conversion of
 other objects to strings. String concatenation is implemented
 through the  StringBuilder (or  StringBuffer )
 class and its  append  method.
 String conversions are implemented through the method
  toString  defined by  Object  and
 inherited by all classes in Java. For additional information on
 string concatenation and conversion see Gosling Joy and Steele
  The Java Language Specification .

   Unless otherwise noted passing a  null  argument to a constructor
 or method in this class will cause a  NullPointerException  to be
 thrown.

  A  String  represents a string in the UTF-16 format
 in which  supplementary characters  are represented by  surrogate
 pairs  (see the section  Unicode
 Character Representations  in the  Character  class for
 more information).
 Index values refer to  char  code units so a supplementary
 character uses two positions in a  String .
  The  String  class provides methods for dealing with
 Unicode code points (i.e. characters) in addition to those for
 dealing with Unicode code units (i.e.  char  values)."
android,java.lang,ProcessBuilder,19,"This class is used to create operating system processes.

  Each  ProcessBuilder  instance manages a collection
 of process attributes.  The  start()  method creates a new
  Process  instance with those attributes.  The  start()  method can be invoked repeatedly from the same instance
 to create new subprocesses with identical or related attributes.

  Each process builder manages these process attributes:

  a  command  a list of strings which signifies the
 external program file to be invoked and its arguments if any.
 Which string lists represent a valid operating system command is
 system-dependent.  For example it is common for each conceptual
 argument to be an element in this list but there are operating
 systems where programs are expected to tokenize command line
 strings themselves - on such a system a Java implementation might
 require commands to contain exactly two elements.

  an  environment  which is a system-dependent mapping from
  variables  to  values .  The initial value is a copy of
 the environment of the current process (see  System#getenv() ).

  a  working directory .  The default value is the current
 working directory of the current process usually the directory
 named by the system property  user.dir .

  a source of  standard input .
 By default the subprocess reads input from a pipe.  Java code
 can access this pipe via the output stream returned by
  Process#getOutputStream() .  However standard input may
 be redirected to another source using
  redirectInput .
 In this case  Process#getOutputStream()  will return a
  null output stream  for which:

  the  OutputStream#write(int)  methods always
 throw  IOException the  OutputStream#close()  method does nothing
  a destination for  standard output 
 and  standard error .  By default the subprocess writes standard
 output and standard error to pipes.  Java code can access these pipes
 via the input streams returned by  Process#getInputStream()  and
  Process#getErrorStream() .  However standard output and
 standard error may be redirected to other destinations using
  redirectOutput  and
  redirectError .
 In this case  Process#getInputStream()  and/or
  Process#getErrorStream()  will return a  null input
 stream  for which:

  the  InputStream#read()  methods always return
  -1 the  InputStream#available()  method always returns
  0 the  InputStream#close()  method does nothing
  a  redirectErrorStream  property.  Initially this property
 is  false  meaning that the standard output and error
 output of a subprocess are sent to two separate streams which can
 be accessed using the  Process#getInputStream()  and  Process#getErrorStream()  methods.

  If the value is set to  true  then:

  standard error is merged with the standard output and always sent
 to the same destination (this makes it easier to correlate error
 messages with the corresponding output)
  the common destination of standard error and standard output can be
 redirected using
  redirectOutput any redirection set by the
  redirectError 
 method is ignored when creating a subprocess
  the stream returned from  Process#getErrorStream()  will
 always be a  null input stream Modifying a process builder's attributes will affect processes
 subsequently started by that object's  start()  method but
 will never affect previously started processes or the Java process
 itself.

  Most error checking is performed by the  start()  method.
 It is possible to modify the state of an object so that  start()  will fail.  For example setting the command attribute to
 an empty list will not throw an exception unless  start() 
 is invoked.

  Note that this class is not synchronized. 
 If multiple threads access a  ProcessBuilder  instance
 concurrently and at least one of the threads modifies one of the
 attributes structurally it  must  be synchronized externally.

  Starting a new process which uses the default working directory
 and environment is easy:

  Process p = new ProcessBuilder(""myCommand"" ""myArg"").start();
  Here is an example that starts a process with a modified working
 directory and environment and redirects standard output and error
 to be appended to a log file:

  ProcessBuilder pb =
   new ProcessBuilder(""myCommand"" ""myArg1"" ""myArg2"");
 Map<String String> env = pb.environment();
 env.put(""VAR1"" ""myValue"");
 env.remove(""OTHERVAR"");
 env.put(""VAR2"" env.get(""VAR1"") + ""suffix"");
 pb.directory(new File(""myDir""));
 File log = new File(""log"");
 pb.redirectErrorStream(true);
 pb.redirectOutput(Redirect.appendTo(log));
 Process p = pb.start();
 assert pb.redirectInput() == Redirect.PIPE;
 assert pb.redirectOutput().file() == log;
 assert p.getInputStream().read() == -1;
  To start a process with an explicit set of environment
 variables first call  Map.clear() 
 before adding environment variables."
android,java.lang,Runtime,24,"Every Java application has a single instance of class
  Runtime  that allows the application to interface with
 the environment in which the application is running. The current
 runtime can be obtained from the  getRuntime  method.
  
 An application cannot create its own instance of this class."
android,java.lang,Short,22,"The  Short  class wraps a value of primitive type  short  in an object.  An object of type  Short  contains a
 single field whose type is  short .

  In addition this class provides several methods for converting
 a  short  to a  String  and a  String  to a
  short  as well as other constants and methods useful when
 dealing with a  short ."
android,java.lang,StackTraceElement,8,"An element in a stack trace as returned by  Throwable#getStackTrace() .  Each element represents a single stack frame.
 All stack frames except for the one at the top of the stack represent
 a method invocation.  The frame at the top of the stack represents the
 execution point at which the stack trace was generated.  Typically
 this is the point at which the throwable corresponding to the stack trace
 was created."
android,java.lang,ThreadLocal,5,"This class provides thread-local variables.  These variables differ from
 their normal counterparts in that each thread that accesses one (via its
  get  or  set  method) has its own independently initialized
 copy of the variable.   ThreadLocal  instances are typically private
 static fields in classes that wish to associate state with a thread (e.g.
 a user ID or Transaction ID).

  For example the class below generates unique identifiers local to each
 thread.
 A thread's id is assigned the first time it invokes  ThreadId.get() 
 and remains unchanged on subsequent calls.
  
 import java.util.concurrent.atomic.AtomicInteger;

 public class ThreadId {
     // Atomic integer containing the next thread ID to be assigned
     private static final AtomicInteger nextId = new AtomicInteger(0);

     // Thread local variable containing each thread's ID
     private static final ThreadLocal<Integer> threadId =
         new ThreadLocal<Integer>() {
             @Override protected Integer initialValue() {
                 return nextId.getAndIncrement();
         }
     };

     // Returns the current thread's unique ID assigning it if necessary
     public static int get() {
         return threadId.get();
     }
 }
  Each thread holds an implicit reference to its copy of a thread-local
 variable as long as the thread is alive and the  ThreadLocal 
 instance is accessible; after a thread goes away all of its copies of
 thread-local instances are subject to garbage collection (unless other
 references to these copies exist)."
android,java.lang,Throwable,13,"The  Throwable  class is the superclass of all errors and
 exceptions in the Java language. Only objects that are instances of this
 class (or one of its subclasses) are thrown by the Java Virtual Machine or
 can be thrown by the Java  throw  statement. Similarly only
 this class or one of its subclasses can be the argument type in a
  catch  clause.

 For the purposes of compile-time checking of exceptions  Throwable  and any subclass of  Throwable  that is not also a
 subclass of either  RuntimeException  or  Error  are
 regarded as checked exceptions.

  Instances of two subclasses  Error  and
  Exception  are conventionally used to indicate
 that exceptional situations have occurred. Typically these instances
 are freshly created in the context of the exceptional situation so
 as to include relevant information (such as stack trace data).

  A throwable contains a snapshot of the execution stack of its
 thread at the time it was created. It can also contain a message
 string that gives more information about the error. Over time a
 throwable can  Throwable#addSuppressed  other
 throwables from being propagated.  Finally the throwable can also
 contain a  cause : another throwable that caused this
 throwable to be constructed.  The recording of this causal information
 is referred to as the  chained exception  facility as the
 cause can itself have a cause and so on leading to a ""chain"" of
 exceptions each caused by another.

  One reason that a throwable may have a cause is that the class that
 throws it is built atop a lower layered abstraction and an operation on
 the upper layer fails due to a failure in the lower layer.  It would be bad
 design to let the throwable thrown by the lower layer propagate outward as
 it is generally unrelated to the abstraction provided by the upper layer.
 Further doing so would tie the API of the upper layer to the details of
 its implementation assuming the lower layer's exception was a checked
 exception.  Throwing a ""wrapped exception"" (i.e. an exception containing a
 cause) allows the upper layer to communicate the details of the failure to
 its caller without incurring either of these shortcomings.  It preserves
 the flexibility to change the implementation of the upper layer without
 changing its API (in particular the set of exceptions thrown by its
 methods).

  A second reason that a throwable may have a cause is that the method
 that throws it must conform to a general-purpose interface that does not
 permit the method to throw the cause directly.  For example suppose
 a persistent collection conforms to the  Collection  interface and that its persistence is implemented atop
  java.io .  Suppose the internals of the  add  method
 can throw an  IOException .  The implementation
 can communicate the details of the  IOException  to its caller
 while conforming to the  Collection  interface by wrapping the
  IOException  in an appropriate unchecked exception.  (The
 specification for the persistent collection should indicate that it is
 capable of throwing such exceptions.)

  A cause can be associated with a throwable in two ways: via a
 constructor that takes the cause as an argument or via the
  initCause(java.lang.Throwable)  method.  New throwable classes that
 wish to allow causes to be associated with them should provide constructors
 that take a cause and delegate (perhaps indirectly) to one of the
  Throwable  constructors that takes a cause.

 Because the  initCause  method is public it allows a cause to be
 associated with any throwable even a ""legacy throwable"" whose
 implementation predates the addition of the exception chaining mechanism to
  Throwable .

  By convention class  Throwable  and its subclasses have two
 constructors one that takes no arguments and one that takes a
  String  argument that can be used to produce a detail message.
 Further those subclasses that might likely have a cause associated with
 them should have two more constructors one that takes a
  Throwable  (the cause) and one that takes a
  String  (the detail message) and a  Throwable  (the
 cause)."
android,java.security.cert,Certificate.CertificateRep,0,Alternate Certificate class for serialization.
android,java.security.cert,CertificateFactory,13,"This class defines the functionality of a certificate factory which is
 used to generate certificate certification path ( CertPath )
 and certificate revocation list (CRL) objects from their encodings.

  For encodings consisting of multiple certificates use
  generateCertificates  when you want to
 parse a collection of possibly unrelated certificates. Otherwise
 use  generateCertPath  when you want to generate
 a  CertPath  (a certificate chain) and subsequently
 validate it with a  CertPathValidator .

  A certificate factory for X.509 must return certificates that are an
 instance of  java.security.cert.X509Certificate  and CRLs
 that are an instance of  java.security.cert.X509CRL .

  The following example reads a file with Base64 encoded certificates
 which are each bounded at the beginning by -----BEGIN CERTIFICATE----- and
 bounded at the end by -----END CERTIFICATE-----. We convert the
  FileInputStream  (which does not support  mark 
 and  reset ) to a  BufferedInputStream  (which
 supports those methods) so that each call to
  generateCertificate  consumes only one certificate and the
 read position of the input stream is positioned to the next certificate in
 the file:

  FileInputStream fis = new FileInputStream(filename);
 BufferedInputStream bis = new BufferedInputStream(fis);

 CertificateFactory cf = CertificateFactory.getInstance(""X.509"");

 while (bis.available() > 0) {
    Certificate cert = cf.generateCertificate(bis);
    System.out.println(cert.toString());
 }
  The following example parses a PKCS#7-formatted certificate reply stored
 in a file and extracts all the certificates from it:

  
 FileInputStream fis = new FileInputStream(filename);
 CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
 Collection c = cf.generateCertificates(fis);
 Iterator i = c.iterator();
 while (i.hasNext()) {
    Certificate cert = (Certificate)i.next();
    System.out.println(cert);
 }
   Android provides the following  CertificateFactory  types:
  Algorithm Supported API Levels X.509 1+ CertPath Name Supported (API Levels) PKCS7 1+ PkiPath 1+ 
 CertificateFactory section 
 CertPath Encodings section"
android,java.security.cert,CertPath,9,"An immutable sequence of certificates (a certification path).
  
 This is an abstract class that defines the methods common to all
  CertPath s. Subclasses can handle different kinds of
 certificates (X.509 PGP etc.).
  
 All  CertPath  objects have a type a list of
  Certificate s and one or more supported encodings. Because the
  CertPath  class is immutable a  CertPath  cannot
 change in any externally visible way after being constructed. This
 stipulation applies to all public fields and methods of this class and any
 added or overridden by subclasses.
  
 The type is a  String  that identifies the type of
  Certificate s in the certification path. For each
 certificate  cert  in a certification path  certPath 
  cert.getType().equals(certPath.getType())  must be
  true .
  
 The list of  Certificate s is an ordered  List  of
 zero or more  Certificate s. This  List  and all
 of the  Certificate s contained in it must be immutable.
  
 Each  CertPath  object must support one or more encodings
 so that the object can be translated into a byte array for storage or
 transmission to other parties. Preferably these encodings should be
 well-documented standards (such as PKCS#7). One of the encodings supported
 by a  CertPath  is considered the default encoding. This
 encoding is used if no encoding is explicitly requested (for the
  getEncoded()  method for instance).
  
 All  CertPath  objects are also  Serializable .
  CertPath  objects are resolved into an alternate
  CertPathRep  object during serialization. This allows
 a  CertPath  object to be serialized into an equivalent
 representation regardless of its underlying implementation.
  CertPath  objects can be created with a
  CertificateFactory  or they can be returned by other classes
 such as a  CertPathBuilder .
  
 By convention X.509  CertPath s (consisting of
  X509Certificate s) are ordered starting with the target
 certificate and ending with a certificate issued by the trust anchor. That
 is the issuer of one certificate is the subject of the following one. The
 certificate representing the  TrustAnchor  should not be
 included in the certification path. Unvalidated X.509  CertPath s
 may not follow these conventions. PKIX  CertPathValidator s will
 detect any departure from these conventions that cause the certification
 path to be invalid and throw a  CertPathValidatorException .

   Every implementation of the Java platform is required to support the
 following standard  CertPath  encodings:
  PKCS7 PkiPath 
 CertPath Encodings section Concurrent Access 
 All  CertPath  objects must be thread-safe. That is multiple
 threads may concurrently invoke the methods defined in this class on a
 single  CertPath  object (or more than one) with no
 ill effects. This is also true for the  List  returned by
  CertPath.getCertificates .
  
 Requiring  CertPath  objects to be immutable and thread-safe
 allows them to be passed around to various pieces of code without worrying
 about coordinating access.  Providing this thread-safety is
 generally not difficult since the  CertPath  and
  List  objects in question are immutable."
android,java.security.cert,CertStore,9,"A class for retrieving  Certificate s and  CRL s
 from a repository.
  
 This class uses a provider-based architecture.
 To create a  CertStore  call one of the static
  getInstance  methods passing in the type of
  CertStore  desired any applicable initialization parameters
 and optionally the name of the provider desired.
  
 Once the  CertStore  has been created it can be used to
 retrieve  Certificate s and  CRL s by calling its
  getCertificates  and
  getCRLs  methods.
  
 Unlike a  KeyStore  which provides access
 to a cache of private keys and trusted certificates a
  CertStore  is designed to provide access to a potentially
 vast repository of untrusted certificates and CRLs. For example an LDAP
 implementation of  CertStore  provides access to certificates
 and CRLs stored in one or more directories using the LDAP protocol and the
 schema as defined in the RFC service attribute.

   Android provides the following  CertStore  types:
  Algorithm Supported API Levels Collection 1+ 
 CertStore section Concurrent Access 
 All public methods of  CertStore  objects must be thread-safe.
 That is multiple threads may concurrently invoke these methods on a
 single  CertStore  object (or more than one) with no
 ill effects. This allows a  CertPathBuilder  to search for a
 CRL while simultaneously searching for further certificates for instance.
  
 The static methods of this class are also guaranteed to be thread-safe.
 Multiple threads may concurrently invoke the static methods defined in
 this class with no ill effects."
android,java.security.cert,LDAPCertStoreParameters,4,"Parameters used as input for the LDAP  CertStore  algorithm.
  
 This class is used to provide necessary configuration parameters (server
 name and port number) to implementations of the LDAP  CertStore 
 algorithm.
  Concurrent Access 
 Unless otherwise specified the methods defined in this class are not
 thread-safe. Multiple threads that need to access a single
 object concurrently should synchronize amongst themselves and
 provide the necessary locking. Multiple threads each manipulating
 separate objects need not synchronize."
android,java.security.cert,PKIXBuilderParameters,3,"Parameters used as input for the PKIX  CertPathBuilder 
 algorithm.
  
 A PKIX  CertPathBuilder  uses these parameters to  CertPathBuilder#build  a  CertPath  which has been
 validated according to the PKIX certification path validation algorithm.

  To instantiate a  PKIXBuilderParameters  object an
 application must specify one or more  most-trusted CAs  as defined by
 the PKIX certification path validation algorithm. The most-trusted CA
 can be specified using one of two constructors. An application
 can call  PKIXBuilderParameters(Set CertSelector)  specifying a
  Set  of  TrustAnchor  objects each of which
 identifies a most-trusted CA. Alternatively an application can call
  PKIXBuilderParameters(KeyStore CertSelector)  specifying a
  KeyStore  instance containing trusted certificate entries each
 of which will be considered as a most-trusted CA.

  In addition an application must specify constraints on the target
 certificate that the  CertPathBuilder  will attempt
 to build a path to. The constraints are specified as a
  CertSelector  object. These constraints should provide the
  CertPathBuilder  with enough search criteria to find the target
 certificate. Minimal criteria for an  X509Certificate  usually
 include the subject name and/or one or more subject alternative names.
 If enough criteria is not specified the  CertPathBuilder 
 may throw a  CertPathBuilderException .
  Concurrent Access 
 Unless otherwise specified the methods defined in this class are not
 thread-safe. Multiple threads that need to access a single
 object concurrently should synchronize amongst themselves and
 provide the necessary locking. Multiple threads each manipulating
 separate objects need not synchronize."
android,java.security.cert,PKIXCertPathValidatorResult,5,"This class represents the successful result of the PKIX certification
 path validation algorithm.

  Instances of  PKIXCertPathValidatorResult  are returned by the
  CertPathValidator#validate  method of
  CertPathValidator  objects implementing the PKIX algorithm.

   All  PKIXCertPathValidatorResult  objects contain the
 valid policy tree and subject public key resulting from the
 validation algorithm as well as a  TrustAnchor  describing
 the certification authority (CA) that served as a trust anchor for the
 certification path.
  Concurrent Access 
 Unless otherwise specified the methods defined in this class are not
 thread-safe. Multiple threads that need to access a single
 object concurrently should synchronize amongst themselves and
 provide the necessary locking. Multiple threads each manipulating
 separate objects need not synchronize."
android,java.security.cert,TrustAnchor,6,"A trust anchor or most-trusted Certification Authority (CA).
  
 This class represents a ""most-trusted CA"" which is used as a trust anchor
 for validating X.509 certification paths. A most-trusted CA includes the
 public key of the CA the CA's name and any constraints upon the set of
 paths which may be validated using this key. These parameters can be
 specified in the form of a trusted  X509Certificate  or as
 individual parameters.
  Concurrent Access All  TrustAnchor  objects must be immutable and
 thread-safe. That is multiple threads may concurrently invoke the
 methods defined in this class on a single  TrustAnchor 
 object (or more than one) with no ill effects. Requiring
  TrustAnchor  objects to be immutable and thread-safe
 allows them to be passed around to various pieces of code without
 worrying about coordinating access. This stipulation applies to all
 public fields and methods of this class and any added or overridden
 by subclasses."
android,java.security.cert,X509CertSelector,52,"A  CertSelector  that selects  X509Certificates  that
 match all specified criteria. This class is particularly useful when
 selecting certificates from a  CertStore  to build a
 PKIX-compliant certification path.
  
 When first constructed an  X509CertSelector  has no criteria
 enabled and each of the  get  methods return a default value
 ( null  or  -1  for the  getBasicConstraints  method). Therefore the  match 
 method would return  true  for any  X509Certificate .
 Typically several criteria are enabled (by calling
  setIssuer  or
  setKeyUsage  for instance) and then the
  X509CertSelector  is passed to
  CertStore#getCertificates  or some similar
 method.
  
 Several criteria can be enabled (by calling  setIssuer 
 and  setSerialNumber 
 for example) such that the  match  method
 usually uniquely matches a single  X509Certificate . We say
 usually since it is possible for two issuing CAs to have the same
 distinguished name and each issue a certificate with the same serial
 number. Other unique combinations include the issuer subject
 subjectKeyIdentifier and/or the subjectPublicKey criteria.
  
 Please refer to  RFC 3280:
 Internet X.509 Public Key Infrastructure Certificate and CRL Profile  for
 definitions of the X.509 certificate extensions mentioned below.
  Concurrent Access 
 Unless otherwise specified the methods defined in this class are not
 thread-safe. Multiple threads that need to access a single
 object concurrently should synchronize amongst themselves and
 provide the necessary locking. Multiple threads each manipulating
 separate objects need not synchronize."
android,java.security.cert,Certificate,10,"Abstract class for managing a variety of identity certificates.
 An identity certificate is a binding of a principal to a public key which
 is vouched for by another principal.  (A principal represents
 an entity such as an individual user a group or a corporation.)
 
 This class is an abstraction for certificates that have different
 formats but important common uses.  For example different types of
 certificates such as X.509 and PGP share general certificate
 functionality (like encoding and verifying) and
 some types of information (like a public key).
  
 X.509 PGP and SDSI certificates can all be implemented by
 subclassing the Certificate class even though they contain different
 sets of information and they store and retrieve the information in
 different ways."
android,java.security.cert,CertificateFactorySpi,8,"This class defines the  Service Provider Interface  ( SPI )
 for the  CertificateFactory  class.
 All the abstract methods in this class must be implemented by each
 cryptographic service provider who wishes to supply the implementation
 of a certificate factory for a particular certificate type e.g. X.509.

  Certificate factories are used to generate certificate certification path
 ( CertPath ) and certificate revocation list (CRL) objects from
 their encodings.

  A certificate factory for X.509 must return certificates that are an
 instance of  java.security.cert.X509Certificate  and CRLs
 that are an instance of  java.security.cert.X509CRL ."
android,java.security.cert,CertPath.CertPathRep,0,Alternate  CertPath  class for serialization.
android,java.security.cert,CertPathBuilder,8,"A class for building certification paths (also known as certificate chains).
  
 This class uses a provider-based architecture.
 To create a  CertPathBuilder  call
 one of the static  getInstance  methods passing in the
 algorithm name of the  CertPathBuilder  desired and optionally
 the name of the provider desired.

  Once a  CertPathBuilder  object has been created certification
 paths can be constructed by calling the  build  method and
 passing it an algorithm-specific set of parameters. If successful the
 result (including the  CertPath  that was built) is returned
 in an object that implements the  CertPathBuilderResult 
 interface.

  The  getRevocationChecker()  method allows an application to specify
 additional algorithm-specific parameters and options used by the
  CertPathBuilder  when checking the revocation status of certificates.
 Here is an example demonstrating how it is used with the PKIX algorithm:

  
 CertPathBuilder cpb = CertPathBuilder.getInstance(""PKIX"");
 PKIXRevocationChecker rc = (PKIXRevocationChecker)cpb.getRevocationChecker();
 rc.setOptions(EnumSet.of(Option.PREFER_CRLS));
 params.addCertPathChecker(rc);
 CertPathBuilderResult cpbr = cpb.build(params);
   Android provides the following  CertPathBuilder  algorithms:
  Algorithm Supported API Levels PKIX 1+ 
 CertPathBuilder section Concurrent Access 
 The static methods of this class are guaranteed to be thread-safe.
 Multiple threads may concurrently invoke the static methods defined in
 this class with no ill effects.
  
 However this is not true for the non-static methods defined by this class.
 Unless otherwise documented by a specific provider threads that need to
 access a single  CertPathBuilder  instance concurrently should
 synchronize amongst themselves and provide the necessary locking. Multiple
 threads each manipulating a different  CertPathBuilder  instance
 need not synchronize."
android,java.security.cert,CertPathBuilderSpi,2,"The  Service Provider Interface  ( SPI )
 for the  CertPathBuilder  class. All
  CertPathBuilder  implementations must include a class (the
 SPI class) that extends this class ( CertPathBuilderSpi ) and
 implements all of its methods. In general instances of this class should
 only be accessed through the  CertPathBuilder  class. For
 details see the Java Cryptography Architecture.
  Concurrent Access 
 Instances of this class need not be protected against concurrent
 access from multiple threads. Threads that need to access a single
  CertPathBuilderSpi  instance concurrently should synchronize
 amongst themselves and provide the necessary locking before calling the
 wrapping  CertPathBuilder  object.
  
 However implementations of  CertPathBuilderSpi  may still
 encounter concurrency issues since multiple threads each
 manipulating a different  CertPathBuilderSpi  instance need not
 synchronize."
android,java.security.cert,CertPathValidatorSpi,2,"The  Service Provider Interface  ( SPI )
 for the  CertPathValidator  class. All
  CertPathValidator  implementations must include a class (the
 SPI class) that extends this class ( CertPathValidatorSpi )
 and implements all of its methods. In general instances of this class
 should only be accessed through the  CertPathValidator  class.
 For details see the Java Cryptography Architecture.
  Concurrent Access 
 Instances of this class need not be protected against concurrent
 access from multiple threads. Threads that need to access a single
  CertPathValidatorSpi  instance concurrently should synchronize
 amongst themselves and provide the necessary locking before calling the
 wrapping  CertPathValidator  object.
  
 However implementations of  CertPathValidatorSpi  may still
 encounter concurrency issues since multiple threads each
 manipulating a different  CertPathValidatorSpi  instance need not
 synchronize."
android,java.security.cert,CertStoreSpi,2,"The  Service Provider Interface  ( SPI )
 for the  CertStore  class. All  CertStore 
 implementations must include a class (the SPI class) that extends
 this class ( CertStoreSpi ) provides a constructor with
 a single argument of type  CertStoreParameters  and implements
 all of its methods. In general instances of this class should only be
 accessed through the  CertStore  class.
 For details see the Java Cryptography Architecture.
  Concurrent Access 
 The public methods of all  CertStoreSpi  objects must be
 thread-safe. That is multiple threads may concurrently invoke these
 methods on a single  CertStoreSpi  object (or more than one)
 with no ill effects. This allows a  CertPathBuilder  to search
 for a CRL while simultaneously searching for further certificates for
 instance.
  
 Simple  CertStoreSpi  implementations will probably ensure
 thread safety by adding a  synchronized  keyword to their
  engineGetCertificates  and  engineGetCRLs  methods.
 More sophisticated ones may allow truly concurrent access."
android,java.security.cert,CollectionCertStoreParameters,3,"Parameters used as input for the Collection  CertStore 
 algorithm.
  
 This class is used to provide necessary configuration parameters
 to implementations of the Collection  CertStore 
 algorithm. The only parameter included in this class is the
  Collection  from which the  CertStore  will
 retrieve certificates and CRLs.
  Concurrent Access 
 Unless otherwise specified the methods defined in this class are not
 thread-safe. Multiple threads that need to access a single
 object concurrently should synchronize amongst themselves and
 provide the necessary locking. Multiple threads each manipulating
 separate objects need not synchronize."
android,java.security.cert,PKIXCertPathChecker,6,"An abstract class that performs one or more checks on an
  X509Certificate .

  A concrete implementation of the  PKIXCertPathChecker  class
 can be created to extend the PKIX certification path validation algorithm.
 For example an implementation may check for and process a critical private
 extension of each certificate in a certification path.

  Instances of  PKIXCertPathChecker  are passed as parameters
 using the  PKIXParameters#setCertPathCheckers 
 or  PKIXParameters#addCertPathChecker  methods
 of the  PKIXParameters  and  PKIXBuilderParameters 
 class. Each of the  PKIXCertPathChecker s  check 
 methods will be called in turn for each certificate processed by a PKIX
  CertPathValidator  or  CertPathBuilder 
 implementation.

  A  PKIXCertPathChecker  may be called multiple times on
 successive certificates in a certification path. Concrete subclasses
 are expected to maintain any internal state that may be necessary to
 check successive certificates. The  init  method is used
 to initialize the internal state of the checker so that the certificates
 of a new certification path may be checked. A stateful implementation
  must  override the  clone  method if necessary in
 order to allow a PKIX  CertPathBuilder  to efficiently
 backtrack and try other paths. In these situations the
  CertPathBuilder  is able to restore prior path validation
 states by restoring the cloned  PKIXCertPathChecker s.

  The order in which the certificates are presented to the
  PKIXCertPathChecker  may be either in the forward direction
 (from target to most-trusted CA) or in the reverse direction (from
 most-trusted CA to target). A  PKIXCertPathChecker  implementation
  must  support reverse checking (the ability to perform its checks when
 it is presented with certificates in the reverse direction) and  may 
 support forward checking (the ability to perform its checks when it is
 presented with certificates in the forward direction). The
  isForwardCheckingSupported  method
 indicates whether forward checking is supported.
  
 Additional input parameters required for executing the check may be
 specified through constructors of concrete implementations of this class.
  Concurrent Access 
 Unless otherwise specified the methods defined in this class are not
 thread-safe. Multiple threads that need to access a single
 object concurrently should synchronize amongst themselves and
 provide the necessary locking. Multiple threads each manipulating
 separate objects need not synchronize."
android,java.security.cert,PKIXRevocationChecker,12,"A  PKIXCertPathChecker  for checking the revocation status of
 certificates with the PKIX algorithm.

  A  PKIXRevocationChecker  checks the revocation status of
 certificates with the Online Certificate Status Protocol (OCSP) or
 Certificate Revocation Lists (CRLs). OCSP is described in RFC 2560 and
 is a network protocol for determining the status of a certificate. A CRL
 is a time-stamped list identifying revoked certificates and RFC 5280
 describes an algorithm for determining the revocation status of certificates
 using CRLs.

  Each  PKIXRevocationChecker  must be able to check the revocation
 status of certificates with OCSP and CRLs. By default OCSP is the
 preferred mechanism for checking revocation status with CRLs as the
 fallback mechanism. However this preference can be switched to CRLs with
 the  Option#PREFER_CRLS  option. In addition the fallback
 mechanism can be disabled with the  Option#NO_FALLBACK 
 option.

  A  PKIXRevocationChecker  is obtained by calling the
  CertPathValidator#getRevocationChecker  method
 of a PKIX  CertPathValidator . Additional parameters and options
 specific to revocation can be set (by calling the
  setOcspResponder  method for instance). The
  PKIXRevocationChecker  is added to a  PKIXParameters  object
 using the  PKIXParameters#addCertPathChecker 
 or  PKIXParameters#setCertPathCheckers  method
 and then the  PKIXParameters  is passed along with the  CertPath 
 to be validated to the  CertPathValidator#validate  method
 of a PKIX  CertPathValidator . When supplying a revocation checker in
 this manner it will be used to check revocation irrespective of the setting
 of the  PKIXParameters#isRevocationEnabled  flag.
 Similarly a  PKIXRevocationChecker  may be added to a
  PKIXBuilderParameters  object for use with a PKIX
  CertPathBuilder .

  Note that when a  PKIXRevocationChecker  is added to
  PKIXParameters  it clones the  PKIXRevocationChecker ;
 thus any subsequent modifications to the  PKIXRevocationChecker 
 have no effect.

  Any parameter that is not set (or is set to  null ) will be set to
 the default value for that parameter.

  Concurrent Access Unless otherwise specified the methods defined in this class are not
 thread-safe. Multiple threads that need to access a single object
 concurrently should synchronize amongst themselves and provide the
 necessary locking. Multiple threads each manipulating separate objects
 need not synchronize.

  See RFC 2560: X.509 Internet Public Key Infrastructure Online Certificate Status Protocol -
 OCSP RFC 5280: Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation
 List (CRL) Profile (Android note: this paragraph was originally in a malformed ""see"" tag below
 moved here for correct construction of the docs)."
android,java.security.cert,PolicyQualifierInfo,4,"An immutable policy qualifier represented by the ASN.1 PolicyQualifierInfo
 structure.

  The ASN.1 definition is as follows:
  
   PolicyQualifierInfo ::= SEQUENCE {
        policyQualifierId       PolicyQualifierId
        qualifier               ANY DEFINED BY policyQualifierId }
  
 A certificate policies extension if present in an X.509 version 3
 certificate contains a sequence of one or more policy information terms
 each of which consists of an object identifier (OID) and optional
 qualifiers. In an end-entity certificate these policy information terms
 indicate the policy under which the certificate has been issued and the
 purposes for which the certificate may be used. In a CA certificate these
 policy information terms limit the set of policies for certification paths
 which include this certificate.
  
 A  Set  of  PolicyQualifierInfo  objects are returned
 by the  PolicyNode#getPolicyQualifiers 
 method. This allows applications with specific policy requirements to
 process and validate each policy qualifier. Applications that need to
 process policy qualifiers should explicitly set the
  policyQualifiersRejected  flag to false (by calling the
  PKIXParameters#setPolicyQualifiersRejected  method) before validating
 a certification path.

  Note that the PKIX certification path validation algorithm specifies
 that any policy qualifier in a certificate policies extension that is
 marked critical must be processed and validated. Otherwise the
 certification path must be rejected. If the
  policyQualifiersRejected  flag is set to false it is up to
 the application to validate all policy qualifiers in this manner in order
 to be PKIX compliant.

  Concurrent Access All  PolicyQualifierInfo  objects must be immutable and
 thread-safe. That is multiple threads may concurrently invoke the
 methods defined in this class on a single  PolicyQualifierInfo 
 object (or more than one) with no ill effects. Requiring
  PolicyQualifierInfo  objects to be immutable and thread-safe
 allows them to be passed around to various pieces of code without
 worrying about coordinating access."
android,java.security.cert,X509Certificate,23,"Abstract class for X.509 certificates. This provides a standard
 way to access all the attributes of an X.509 certificate.
  
 In June of 1996 the basic X.509 v3 format was completed by
 ISO/IEC and ANSI X9 which is described below in ASN.1:
  
 Certificate  ::=  SEQUENCE  {
     tbsCertificate       TBSCertificate
     signatureAlgorithm   AlgorithmIdentifier
     signature            BIT STRING  }
  
 These certificates are widely used to support authentication and
 other functionality in Internet security systems. Common applications
 include Privacy Enhanced Mail (PEM) Transport Layer Security (SSL)
 code signing for trusted software distribution and Secure Electronic
 Transactions (SET).
  
 These certificates are managed and vouched for by  Certificate
 Authorities  (CAs). CAs are services which create certificates by
 placing data in the X.509 standard format and then digitally signing
 that data. CAs act as trusted third parties making introductions
 between principals who have no direct knowledge of each other.
 CA certificates are either signed by themselves or by some other
 CA such as a ""root"" CA.
  
 More information can be found in
  RFC 3280: Internet X.509
 Public Key Infrastructure Certificate and CRL Profile .
  
 The ASN.1 definition of  tbsCertificate  is:
  
 TBSCertificate  ::=  SEQUENCE  {
     version         [0]  EXPLICIT Version DEFAULT v1
     serialNumber         CertificateSerialNumber
     signature            AlgorithmIdentifier
     issuer               Name
     validity             Validity
     subject              Name
     subjectPublicKeyInfo SubjectPublicKeyInfo
     issuerUniqueID  [1]  IMPLICIT UniqueIdentifier OPTIONAL
                          -- If present version must be v2 or v3
     subjectUniqueID [2]  IMPLICIT UniqueIdentifier OPTIONAL
                          -- If present version must be v2 or v3
     extensions      [3]  EXPLICIT Extensions OPTIONAL
                          -- If present version must be v3
     }
  
 Certificates are instantiated using a certificate factory. The following is
 an example of how to instantiate an X.509 certificate:
  
 try (InputStream inStream = new FileInputStream(""fileName-of-cert"")) {
     CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
     X509Certificate cert = (X509Certificate)cf.generateCertificate(inStream);
 }"
android,java.security.cert,X509CRL,19,"Abstract class for an X.509 Certificate Revocation List (CRL).
 A CRL is a time-stamped list identifying revoked certificates.
 It is signed by a Certificate Authority (CA) and made freely
 available in a public repository.

  Each revoked certificate is
 identified in a CRL by its certificate serial number. When a
 certificate-using system uses a certificate (e.g. for verifying a
 remote user's digital signature) that system not only checks the
 certificate signature and validity but also acquires a suitably-
 recent CRL and checks that the certificate serial number is not on
 that CRL.  The meaning of ""suitably-recent"" may vary with local
 policy but it usually means the most recently-issued CRL.  A CA
 issues a new CRL on a regular periodic basis (e.g. hourly daily or
 weekly).  Entries are added to CRLs as revocations occur and an
 entry may be removed when the certificate expiration date is reached.
  
 The X.509 v2 CRL format is described below in ASN.1:
  
 CertificateList  ::=  SEQUENCE  {
     tbsCertList          TBSCertList
     signatureAlgorithm   AlgorithmIdentifier
     signature            BIT STRING  }
  
 More information can be found in
  RFC 3280: Internet X.509
 Public Key Infrastructure Certificate and CRL Profile .
  
 The ASN.1 definition of  tbsCertList  is:
  
 TBSCertList  ::=  SEQUENCE  {
     version                 Version OPTIONAL
                             -- if present must be v2
     signature               AlgorithmIdentifier
     issuer                  Name
     thisUpdate              ChoiceOfTime
     nextUpdate              ChoiceOfTime OPTIONAL
     revokedCertificates     SEQUENCE OF SEQUENCE  {
         userCertificate         CertificateSerialNumber
         revocationDate          ChoiceOfTime
         crlEntryExtensions      Extensions OPTIONAL
                                 -- if present must be v2
         }  OPTIONAL
     crlExtensions           [0]  EXPLICIT Extensions OPTIONAL
                                  -- if present must be v2
     }
  
 CRLs are instantiated using a certificate factory. The following is an
 example of how to instantiate an X.509 CRL:
  try (InputStream inStream = new FileInputStream(""fileName-of-crl"")) {
     CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
     X509CRL crl = (X509CRL)cf.generateCRL(inStream);
 }"
android,java.security.cert,X509CRLEntry,9,"Abstract class for a revoked certificate in a CRL (Certificate
 Revocation List).

 The ASN.1 definition for  revokedCertificates  is:
  
 revokedCertificates    SEQUENCE OF SEQUENCE  {
     userCertificate    CertificateSerialNumber
     revocationDate     ChoiceOfTime
     crlEntryExtensions Extensions OPTIONAL
                        -- if present must be v2
 }  OPTIONAL

 CertificateSerialNumber  ::=  INTEGER

 Extensions  ::=  SEQUENCE SIZE (1..MAX) OF Extension

 Extension  ::=  SEQUENCE  {
     extnId        OBJECT IDENTIFIER
     critical      BOOLEAN DEFAULT FALSE
     extnValue     OCTET STRING
                   -- contains a DER encoding of a value
                   -- of the type registered for use with
                   -- the extnId object identifier value
 }"
android,java.security.cert,CertPathValidator,8,"A class for validating certification paths (also known as certificate
 chains).
  
 This class uses a provider-based architecture.
 To create a  CertPathValidator 
 call one of the static  getInstance  methods passing in the
 algorithm name of the  CertPathValidator  desired and
 optionally the name of the provider desired.

  Once a  CertPathValidator  object has been created it can
 be used to validate certification paths by calling the  validate  method and passing it the  CertPath  to be validated
 and an algorithm-specific set of parameters. If successful the result is
 returned in an object that implements the
  CertPathValidatorResult  interface.

  The  getRevocationChecker()  method allows an application to specify
 additional algorithm-specific parameters and options used by the
  CertPathValidator  when checking the revocation status of
 certificates. Here is an example demonstrating how it is used with the PKIX
 algorithm:

  
 CertPathValidator cpv = CertPathValidator.getInstance(""PKIX"");
 PKIXRevocationChecker rc = (PKIXRevocationChecker)cpv.getRevocationChecker();
 rc.setOptions(EnumSet.of(Option.SOFT_FAIL));
 params.addCertPathChecker(rc);
 CertPathValidatorResult cpvr = cpv.validate(path params);
   Android provides the following  CertPathValidator  algorithms:
  Algorithm Supported API Levels PKIX 1+ 
 CertPathValidator section Concurrent Access 
 The static methods of this class are guaranteed to be thread-safe.
 Multiple threads may concurrently invoke the static methods defined in
 this class with no ill effects.
  
 However this is not true for the non-static methods defined by this class.
 Unless otherwise documented by a specific provider threads that need to
 access a single  CertPathValidator  instance concurrently should
 synchronize amongst themselves and provide the necessary locking. Multiple
 threads each manipulating a different  CertPathValidator 
 instance need not synchronize."
android,java.security.cert,CRL,3,"This class is an abstraction of certificate revocation lists (CRLs) that
 have different formats but important common uses. For example all CRLs
 share the functionality of listing revoked certificates and can be queried
 on whether or not they list a given certificate.
  
 Specialized CRL types can be defined by subclassing off of this abstract
 class."
android,java.security.cert,PKIXCertPathBuilderResult,2,"This class represents the successful result of the PKIX certification
 path builder algorithm. All certification paths that are built and
 returned using this algorithm are also validated according to the PKIX
 certification path validation algorithm.

  Instances of  PKIXCertPathBuilderResult  are returned by
 the  build  method of  CertPathBuilder 
 objects implementing the PKIX algorithm.

  All  PKIXCertPathBuilderResult  objects contain the
 certification path constructed by the build algorithm the
 valid policy tree and subject public key resulting from the build
 algorithm and a  TrustAnchor  describing the certification
 authority (CA) that served as a trust anchor for the certification path.
  Concurrent Access 
 Unless otherwise specified the methods defined in this class are not
 thread-safe. Multiple threads that need to access a single
 object concurrently should synchronize amongst themselves and
 provide the necessary locking. Multiple threads each manipulating
 separate objects need not synchronize."
android,java.security.cert,PKIXParameters,28,"Parameters used as input for the PKIX  CertPathValidator 
 algorithm.
  
 A PKIX  CertPathValidator  uses these parameters to
 validate a  CertPath  according to the PKIX certification path
 validation algorithm.

  To instantiate a  PKIXParameters  object an
 application must specify one or more  most-trusted CAs  as defined by
 the PKIX certification path validation algorithm. The most-trusted CAs
 can be specified using one of two constructors. An application
 can call  PKIXParameters(Set) 
 specifying a  Set  of  TrustAnchor  objects each
 of which identify a most-trusted CA. Alternatively an application can call
  PKIXParameters(KeyStore)  specifying a
  KeyStore  instance containing trusted certificate entries each
 of which will be considered as a most-trusted CA.
  
 Once a  PKIXParameters  object has been created other parameters
 can be specified (by calling  setInitialPolicies 
 or  setDate  for instance) and then the
  PKIXParameters  is passed along with the  CertPath 
 to be validated to  CertPathValidator#validate .
  
 Any parameter that is not set (or is set to  null ) will
 be set to the default value for that parameter. The default value for the
  date  parameter is  null  which indicates
 the current time when the path is validated. The default for the
 remaining parameters is the least constrained.
  Concurrent Access 
 Unless otherwise specified the methods defined in this class are not
 thread-safe. Multiple threads that need to access a single
 object concurrently should synchronize amongst themselves and
 provide the necessary locking. Multiple threads each manipulating
 separate objects need not synchronize."
android,java.security.cert,X509CRLSelector,18,"A  CRLSelector  that selects  X509CRLs  that
 match all specified criteria. This class is particularly useful when
 selecting CRLs from a  CertStore  to check revocation status
 of a particular certificate.
  
 When first constructed an  X509CRLSelector  has no criteria
 enabled and each of the  get  methods return a default
 value ( null ). Therefore the  match  method
 would return  true  for any  X509CRL . Typically
 several criteria are enabled (by calling  setIssuers 
 or  setDateAndTime  for instance) and then the
  X509CRLSelector  is passed to
  CertStore#getCRLs  or some similar
 method.
  
 Please refer to  RFC 3280:
 Internet X.509 Public Key Infrastructure Certificate and CRL Profile 
 for definitions of the X.509 CRL fields and extensions mentioned below.
  Concurrent Access 
 Unless otherwise specified the methods defined in this class are not
 thread-safe. Multiple threads that need to access a single
 object concurrently should synchronize amongst themselves and
 provide the necessary locking. Multiple threads each manipulating
 separate objects need not synchronize."
android,java.sql,Date,9,"A thin wrapper around a millisecond value that allows
 JDBC to identify this as an SQL  DATE  value.  A
 milliseconds value represents the number of milliseconds that
 have passed since January 1 1970 00:00:00.000 GMT.
  
 To conform with the definition of SQL  DATE  the
 millisecond values wrapped by a  java.sql.Date  instance
 must be 'normalized' by setting the
 hours minutes seconds and milliseconds to zero in the particular
 time zone with which the instance is associated."
android,java.sql,DriverManager,14,"The basic service for managing a set of JDBC drivers. NOTE:  The  DataSource  interface new in the
 JDBC 2.0 API provides another way to connect to a data source.
 The use of a  DataSource  object is the preferred means of
 connecting to a data source.

  As part of its initialization the  DriverManager  class will
 attempt to load the driver classes referenced in the ""jdbc.drivers""
 system property. This allows a user to customize the JDBC Drivers
 used by their applications. For example in your
 ~/.hotjava/properties file you might specify:
  jdbc.drivers=foo.bah.Driver:wombat.sql.Driver:bad.taste.ourDriver  The  DriverManager  methods  getConnection  and
  getDrivers  have been enhanced to support the Java Standard Edition
  Service Provider  mechanism. JDBC 4.0 Drivers must
 include the file  META-INF/services/java.sql.Driver . This file contains the name of the JDBC drivers
 implementation of  java.sql.Driver .  For example to load the  my.sql.Driver  class
 the  META-INF/services/java.sql.Driver  file would contain the entry:
  my.sql.Driver Applications no longer need to explictly load JDBC drivers using  Class.forName() . Existing programs
 which currently load JDBC drivers using  Class.forName()  will continue to work without
 modification.

  When the method  getConnection  is called
 the  DriverManager  will attempt to
 locate a suitable driver from amongst those loaded at
 initialization and those loaded explicitly using the same classloader
 as the current applet or application.

  
 Starting with the Java 2 SDK Standard Edition version 1.3 a
 logging stream can be set only if the proper
 permission has been granted.  Normally this will be done with
 the tool PolicyTool which can be used to grant  permission
 java.sql.SQLPermission ""setLog"" ."
android,java.sql,DriverPropertyInfo,0,"Driver properties for making a connection. The
  DriverPropertyInfo  class is of interest only to advanced programmers
 who need to interact with a Driver via the method
  getDriverProperties  to discover
 and supply properties for connections."
android,java.sql,SQLPermission,0,Legacy security code; do not use.
android,java.sql,Time,10,"A thin wrapper around the  java.util.Date  class that allows the JDBC
 API to identify this as an SQL  TIME  value. The  Time 
 class adds formatting and
 parsing operations to support the JDBC escape syntax for time
 values.
  The date components should be set to the ""zero epoch""
 value of January 1 1970 and should not be accessed."
android,java.sql,Timestamp,13,"A thin wrapper around  java.util.Date  that allows
 the JDBC API to identify this as an SQL  TIMESTAMP  value.
 It adds the ability
 to hold the SQL  TIMESTAMP  fractional seconds value by allowing
 the specification of fractional seconds to a precision of nanoseconds.
 A Timestamp also provides formatting and
 parsing operations to support the JDBC escape syntax for timestamp values.

  The precision of a Timestamp object is calculated to be either:
  19   which is the number of characters in yyyy-mm-dd hh:mm:ss
   20 + s   which is the number
 of characters in the yyyy-mm-dd hh:mm:ss.[fff...] and  s  represents  the scale of the given Timestamp
 its fractional seconds precision.
 Note:  This type is a composite of a  java.util.Date  and a
 separate nanoseconds value. Only integral seconds are stored in the
  java.util.Date  component. The fractional seconds - the nanos - are
 separate.  The  Timestamp.equals(Object)  method never returns
  true  when passed an object
 that isn't an instance of  java.sql.Timestamp 
 because the nanos component of a date is unknown.
 As a result the  Timestamp.equals(Object) 
 method is not symmetric with respect to the
  java.util.Date.equals(Object) 
 method.  Also the  hashCode  method uses the underlying
  java.util.Date 
 implementation and therefore does not include nanos in its computation.
  
 Due to the differences between the  Timestamp  class
 and the  java.util.Date 
 class mentioned above it is recommended that code not view
  Timestamp  values generically as an instance of
  java.util.Date .  The
 inheritance relationship between  Timestamp 
 and  java.util.Date  really
 denotes implementation inheritance and not type inheritance."
android,java.sql,Types,0,"The class that defines the constants that are used to identify generic
 SQL types called JDBC types.
  
 This class is never instantiated."
android,java.time.chrono,AbstractChronology,5,"An abstract implementation of a calendar system used to organize and identify dates.
  
 The main date and time API is built on the ISO calendar system.
 The chronology operates behind the scenes to represent the general concept of a calendar system.
  
 See  Chronology  for more details."
android,java.time.chrono,HijrahChronology,20,"The Hijrah calendar is a lunar calendar supporting Islamic calendars.
  
 The HijrahChronology follows the rules of the Hijrah calendar system. The Hijrah
 calendar has several variants based on differences in when the new moon is
 determined to have occurred and where the observation is made.
 In some variants the length of each month is
 computed algorithmically from the astronomical data for the moon and earth and
 in others the length of the month is determined by an authorized sighting
 of the new moon. For the algorithmically based calendars the calendar
 can project into the future.
 For sighting based calendars only historical data from past
 sightings is available.
  
 The length of each month is 29 or 30 days.
 Ordinary years have 354 days; leap years have 355 days.

  
 CLDR and LDML identify variants:
  Chronology ID Calendar Type Locale extension see  Locale Description Hijrah-umalqura islamic-umalqura ca-islamic-umalqura Islamic - Umm Al-Qura calendar of Saudi Arabia Additional variants may be available through  Chronology#getAvailableChronologies() .

  Example 
 Selecting the chronology from the locale uses  Chronology#ofLocale 
 to find the Chronology based on Locale supported BCP 47 extension mechanism
 to request a specific calendar (""ca""). For example
  
      Locale locale = Locale.forLanguageTag(""en-US-u-ca-islamic-umalqura"");
      Chronology chrono = Chronology.ofLocale(locale);"
android,java.time.chrono,HijrahDate,26,"A date in the Hijrah calendar system.
  
 This date operates using one of several variants of the
  HijrahChronology .
  
 The Hijrah calendar has a different total of days in a year than
 Gregorian calendar and the length of each month is based on the period
 of a complete revolution of the moon around the earth
 (as between successive new moons).
 Refer to the  HijrahChronology  for details of supported variants.
  
 Each HijrahDate is created bound to a particular HijrahChronology
 The same chronology is propagated to each HijrahDate computed from the date.
 To use a different Hijrah variant its HijrahChronology can be used
 to create new HijrahDate instances.
 Alternatively the  withVariant(HijrahChronology)  method can be used to convert
 to a new HijrahChronology."
android,java.time.chrono,IsoChronology,21,"The ISO calendar system.
  
 This chronology defines the rules of the ISO calendar system.
 This calendar system is based on the ISO-8601 standard which is the
  de facto  world calendar.
  
 The fields are defined as follows:
  era - There are two eras 'Current Era' (CE) and 'Before Current Era' (BCE).
  year-of-era - The year-of-era is the same as the proleptic-year for the current CE era.
  For the BCE era before the ISO epoch the year increases from 1 upwards as time goes backwards.
  proleptic-year - The proleptic year is the same as the year-of-era for the
  current era. For the previous era years have zero then negative values.
  month-of-year - There are 12 months in an ISO year numbered from 1 to 12.
  day-of-month - There are between 28 and 31 days in each of the ISO month numbered from 1 to 31.
  Months 4 6 9 and 11 have 30 days Months 1 3 5 7 8 10 and 12 have 31 days.
  Month 2 has 28 days or 29 in a leap year.
  day-of-year - There are 365 days in a standard ISO year and 366 in a leap year.
  The days are numbered from 1 to 365 or 1 to 366.
  leap-year - Leap years occur every 4 years except where the year is divisble by 100 and not divisble by 400."
android,java.time.chrono,JapaneseChronology,20,"The Japanese Imperial calendar system.
  
 This chronology defines the rules of the Japanese Imperial calendar system.
 This calendar system is primarily used in Japan.
 The Japanese Imperial calendar system is the same as the ISO calendar system
 apart from the era-based year numbering.
  
 Japan introduced the Gregorian calendar starting with Meiji 6.
 Only Meiji and later eras are supported;
 dates before Meiji 6 January 1 are not supported.
  
 The supported  ChronoField  instances are:
  DAY_OF_WEEK DAY_OF_MONTH DAY_OF_YEAR EPOCH_DAY MONTH_OF_YEAR PROLEPTIC_MONTH YEAR_OF_ERA YEAR ERA"
android,java.time.chrono,JapaneseDate,26,"A date in the Japanese Imperial calendar system.
  
 This date operates using the  JapaneseChronology .
 This calendar system is primarily used in Japan.
  
 The Japanese Imperial calendar system is the same as the ISO calendar system
 apart from the era-based year numbering. The proleptic-year is defined to be
 equal to the ISO proleptic-year.
  
 Japan introduced the Gregorian calendar starting with Meiji 6.
 Only Meiji and later eras are supported;
 dates before Meiji 6 January 1 are not supported.
  
 For example the Japanese year ""Heisei 24"" corresponds to ISO year ""2012"". 
 Calling  japaneseDate.get(YEAR_OF_ERA)  will return 24. 
 Calling  japaneseDate.get(YEAR)  will return 2012. 
 Calling  japaneseDate.get(ERA)  will return 2 corresponding to
  JapaneseChronology.ERA_HEISEI ."
android,java.time.chrono,MinguoDate,23,"A date in the Minguo calendar system.
  
 This date operates using the  MinguoChronology .
 This calendar system is primarily used in the Republic of China often known as Taiwan.
 Dates are aligned such that  0001-01-01 (Minguo)  is  1912-01-01 (ISO) ."
android,java.time.chrono,ThaiBuddhistDate,23,"A date in the Thai Buddhist calendar system.
  
 This date operates using the  ThaiBuddhistChronology .
 This calendar system is primarily used in Thailand.
 Dates are aligned such that  2484-01-01 (Buddhist)  is  1941-01-01 (ISO) ."
android,java.time.chrono,JapaneseEra,7,"An era in the Japanese Imperial calendar system.
  
 The Japanese government defines the official name and start date of
 each era. Eras are consecutive and their date ranges do not overlap
 so the end date of one era is always the day before the start date
 of the next era.
  
 The Java SE Platform supports all eras defined by the Japanese government
 beginning with the Meiji era. Each era is identified in the Platform by an
 integer value and a name. The  of(int)  and  valueOf(java.lang.String) 
 methods may be used to obtain a singleton instance of JapaneseEra for each
 era. The  values()  method returns the singleton instances of all
 supported eras.
  
 For convenience this class declares a number of public static final fields
 that refer to singleton instances returned by the values() method."
android,java.time.chrono,MinguoChronology,20,"The Minguo calendar system.
  
 This chronology defines the rules of the Minguo calendar system.
 This calendar system is primarily used in the Republic of China often known as Taiwan.
 Dates are aligned such that  0001-01-01 (Minguo)  is  1912-01-01 (ISO) .
  
 The fields are defined as follows:
  era - There are two eras the current 'Republic' (ERA_ROC) and the previous era (ERA_BEFORE_ROC).
  year-of-era - The year-of-era for the current era increases uniformly from the epoch at year one.
  For the previous era the year increases from one as time goes backwards.
  The value for the current era is equal to the ISO proleptic-year minus 1911.
  proleptic-year - The proleptic year is the same as the year-of-era for the
  current era. For the previous era years have zero then negative values.
  The value is equal to the ISO proleptic-year minus 1911.
  month-of-year - The Minguo month-of-year exactly matches ISO.
  day-of-month - The Minguo day-of-month exactly matches ISO.
  day-of-year - The Minguo day-of-year exactly matches ISO.
  leap-year - The Minguo leap-year pattern exactly matches ISO such that the two calendars
  are never out of step."
android,java.time.chrono,ThaiBuddhistChronology,20,"The Thai Buddhist calendar system.
  
 This chronology defines the rules of the Thai Buddhist calendar system.
 This calendar system is primarily used in Thailand.
 Dates are aligned such that  2484-01-01 (Buddhist)  is  1941-01-01 (ISO) .
  
 The fields are defined as follows:
  era - There are two eras the current 'Buddhist' (ERA_BE) and the previous era (ERA_BEFORE_BE).
  year-of-era - The year-of-era for the current era increases uniformly from the epoch at year one.
  For the previous era the year increases from one as time goes backwards.
  The value for the current era is equal to the ISO proleptic-year plus 543.
  proleptic-year - The proleptic year is the same as the year-of-era for the
  current era. For the previous era years have zero then negative values.
  The value is equal to the ISO proleptic-year plus 543.
  month-of-year - The ThaiBuddhist month-of-year exactly matches ISO.
  day-of-month - The ThaiBuddhist day-of-month exactly matches ISO.
  day-of-year - The ThaiBuddhist day-of-year exactly matches ISO.
  leap-year - The ThaiBuddhist leap-year pattern exactly matches ISO such that the two calendars
  are never out of step."
android,java.time.format,DateTimeFormatter,31,"Formatter for printing and parsing date-time objects.
  
 This class provides the main application entry point for printing and parsing
 and provides common implementations of  DateTimeFormatter :
  Using predefined constants such as  ISO_LOCAL_DATE Using pattern letters such as  uuuu-MMM-dd Using localized styles such as  long  or  medium 
 More complex formatters are provided by
  DateTimeFormatterBuilder .

  
 The main date-time classes provide two methods - one for formatting
  format(DateTimeFormatter formatter)  and one for parsing
  parse(CharSequence text DateTimeFormatter formatter) .
  For example:
  
  LocalDate date = LocalDate.now();
  String text = date.format(formatter);
  LocalDate parsedDate = LocalDate.parse(text formatter);
  
 In addition to the format formatters can be created with desired Locale
 Chronology ZoneId and DecimalStyle.
  
 The  withLocale  method returns a new formatter that
 overrides the locale. The locale affects some aspects of formatting and
 parsing. For example the  ofLocalizedDate  provides a
 formatter that uses the locale specific date format.
  
 The  withChronology  method returns a new formatter
 that overrides the chronology. If overridden the date-time value is
 converted to the chronology before formatting. During parsing the date-time
 value is converted to the chronology before it is returned.
  
 The  withZone  method returns a new formatter that overrides
 the zone. If overridden the date-time value is converted to a ZonedDateTime
 with the requested ZoneId before formatting. During parsing the ZoneId is
 applied before the value is returned.
  
 The  withDecimalStyle  method returns a new formatter that
 overrides the  DecimalStyle . The DecimalStyle symbols are used for
 formatting and parsing.
  
 Some applications may need to use the older  Format 
 class for formatting. The  toFormat()  method returns an
 implementation of  java.text.Format .

  Predefined Formatters Formatter Description Example ofLocalizedDate(dateStyle)  Formatter with date style from the locale   '2011-12-03' ofLocalizedTime(timeStyle)  Formatter with time style from the locale   '10:15:30' ofLocalizedDateTime(dateTimeStyle)  Formatter with a style for date and time from the locale  '3 Jun 2008 11:05:30' ofLocalizedDateTime(dateStyletimeStyle)  Formatter with date and time styles from the locale   '3 Jun 2008 11:05' BASIC_ISO_DATE Basic ISO date  '20111203' ISO_LOCAL_DATE  ISO Local Date  '2011-12-03' ISO_OFFSET_DATE  ISO Date with offset  '2011-12-03+01:00' ISO_DATE  ISO Date with or without offset   '2011-12-03+01:00'; '2011-12-03' ISO_LOCAL_TIME  Time without offset  '10:15:30' ISO_OFFSET_TIME  Time with offset  '10:15:30+01:00' ISO_TIME  Time with or without offset  '10:15:30+01:00'; '10:15:30' ISO_LOCAL_DATE_TIME  ISO Local Date and Time  '2011-12-03T10:15:30' ISO_OFFSET_DATE_TIME  Date Time with Offset
  2011-12-03T10:15:30+01:00' ISO_ZONED_DATE_TIME  Zoned Date Time  '2011-12-03T10:15:30+01:00[Europe/Paris]' ISO_DATE_TIME  Date and time with ZoneId  '2011-12-03T10:15:30+01:00[Europe/Paris]' ISO_ORDINAL_DATE  Year and day of year  '2012-337' ISO_WEEK_DATE  Year and Week  2012-W48-6' ISO_INSTANT  Date and Time of an Instant  '2011-12-03T10:15:30Z'  RFC_1123_DATE_TIME  RFC 1123 / RFC 822  'Tue 3 Jun 2008 11:05:30 GMT' Patterns for Formatting and Parsing ofPattern(java.lang.String) ofPattern(java.lang.String java.util.Locale) ""d MMM uuuu"" 
 For example:
  
  LocalDate date = LocalDate.now();
  DateTimeFormatter formatter = DateTimeFormatter.ofPattern(""yyyy MM dd"");
  String text = date.format(formatter);
  LocalDate parsedDate = LocalDate.parse(text formatter);
  
 All letters 'A' to 'Z' and 'a' to 'z' are reserved as pattern letters. The
 following pattern letters are defined:
  
  Symbol  Meaning                     Presentation      Examples
  ------  -------                     ------------      -------
   G       era                         text              AD; Anno Domini; A
   u       year                        year              2004; 04
   y       year-of-era                 year              2004; 04
   D       day-of-year                 number            189
   M/L     month-of-year               number/text       7; 07; Jul; July; J
   d       day-of-month                number            10

   Q/q     quarter-of-year             number/text       3; 03; Q3; 3rd quarter
   Y       week-based-year             year              1996; 96
   w       week-of-week-based-year     number            27
   W       week-of-month               number            4
   E       day-of-week                 text              Tue; Tuesday; T
   e/c     localized day-of-week       number/text       2; 02; Tue; Tuesday; T
   F       week-of-month               number            3

   a       am-pm-of-day                text              PM
   h       clock-hour-of-am-pm (1-12)  number            12
   K       hour-of-am-pm (0-11)        number            0
   k       clock-hour-of-am-pm (1-24)  number            0

   H       hour-of-day (0-23)          number            0
   m       minute-of-hour              number            30
   s       second-of-minute            number            55
   S       fraction-of-second          fraction          978
   A       milli-of-day                number            1234
   n       nano-of-second              number            987654321
   N       nano-of-day                 number            1234000000

   V       time-zone ID                zone-id           America/Los_Angeles; Z; -08:30
   z       time-zone name              zone-name         Pacific Standard Time; PST
   O       localized zone-offset       offset-O          GMT+8; GMT+08:00; UTC-08:00;
   X       zone-offset 'Z' for zero    offset-X          Z; -08; -0830; -08:30; -083015; -08:30:15;
   x       zone-offset                 offset-x          +0000; -08; -0830; -08:30; -083015; -08:30:15;
   Z       zone-offset                 offset-Z          +0000; -0800; -08:00;

   p       pad next                    pad modifier      1

   '       escape for text             delimiter
   ''      single quote                literal           '
   [       optional section start
   ]       optional section end
   #       reserved for future use
   {       reserved for future use
   }       reserved for future use
  
 The count of pattern letters determines the format.
  Text : The text style is determined based on the number of pattern
 letters used. Less than 4 pattern letters will use the
  TextStyle#SHORT . Exactly 4 pattern letters will use the
  TextStyle#FULL . Exactly 5 pattern letters will use the
  TextStyle#NARROW .
 Pattern letters 'L' 'c' and 'q' specify the stand-alone form of the text styles.
  Number : If the count of letters is one then the value is output using
 the minimum number of digits and without padding. Otherwise the count of digits
 is used as the width of the output field with the value zero-padded as necessary.
 The following pattern letters have constraints on the count of letters.
 Only one letter of 'c' and 'F' can be specified.
 Up to two letters of 'd' 'H' 'h' 'K' 'k' 'm' and 's' can be specified.
 Up to three letters of 'D' can be specified.
  Number/Text : If the count of pattern letters is 3 or greater use the
 Text rules above. Otherwise use the Number rules above.
  Fraction : Outputs the nano-of-second field as a fraction-of-second.
 The nano-of-second value has nine digits thus the count of pattern letters
 is from 1 to 9. If it is less than 9 then the nano-of-second value is
 truncated with only the most significant digits being output.
  Year : The count of letters determines the minimum field width below
 which padding is used. If the count of letters is two then a
  DateTimeFormatterBuilder#appendValueReduced  two digit form is
 used. For printing this outputs the rightmost two digits. For parsing this
 will parse using the base value of 2000 resulting in a year within the range
 2000 to 2099 inclusive. If the count of letters is less than four (but not
 two) then the sign is only output for negative years as per
  SignStyle#NORMAL . Otherwise the sign is output if the pad width is
 exceeded as per  SignStyle#EXCEEDS_PAD .
  ZoneId : This outputs the time-zone ID such as 'Europe/Paris'. If the
 count of letters is two then the time-zone ID is output. Any other count of
 letters throws  IllegalArgumentException .
  Zone names : This outputs the display name of the time-zone ID. If the
 count of letters is one two or three then the short name is output. If the
 count of letters is four then the full name is output. Five or more letters
 throws  IllegalArgumentException .
  Offset X and x : This formats the offset based on the number of pattern
 letters. One letter outputs just the hour such as '+01' unless the minute
 is non-zero in which case the minute is also output such as '+0130'. Two
 letters outputs the hour and minute without a colon such as '+0130'. Three
 letters outputs the hour and minute with a colon such as '+01:30'. Four
 letters outputs the hour and minute and optional second without a colon
 such as '+013015'. Five letters outputs the hour and minute and optional
 second with a colon such as '+01:30:15'. Six or more letters throws
  IllegalArgumentException . Pattern letter 'X' (upper case) will output
 'Z' when the offset to be output would be zero whereas pattern letter 'x'
 (lower case) will output '+00' '+0000' or '+00:00'.
  Offset O : This formats the localized offset based on the number of
 pattern letters. One letter outputs the  TextStyle#SHORT 
 form of the localized offset which is localized offset text such as 'GMT'
 with hour without leading zero optional 2-digit minute and second if
 non-zero and colon for example 'GMT+8'. Four letters outputs the
  TextStyle#FULL  form which is localized offset text
 such as 'GMT with 2-digit hour and minute field optional second field
 if non-zero and colon for example 'GMT+08:00'. Any other count of letters
 throws  IllegalArgumentException .
  Offset Z : This formats the offset based on the number of pattern
 letters. One two or three letters outputs the hour and minute without a
 colon such as '+0130'. The output will be '+0000' when the offset is zero.
 Four letters outputs the  TextStyle#FULL  form of localized
 offset equivalent to four letters of Offset-O. The output will be the
 corresponding localized offset text if the offset is zero. Five
 letters outputs the hour minute with optional second if non-zero with
 colon. It outputs 'Z' if the offset is zero.
 Six or more letters throws  IllegalArgumentException .
  Optional section : The optional section markers work exactly like
 calling  DateTimeFormatterBuilder#optionalStart()  and
  DateTimeFormatterBuilder#optionalEnd() .
  Pad modifier : Modifies the pattern that immediately follows to be
 padded with spaces. The pad width is determined by the number of pattern
 letters. This is the same as calling
  DateTimeFormatterBuilder#padNext(int) .
  
 For example 'ppH' outputs the hour-of-day padded on the left with spaces to
 a width of 2.
  
 Any unrecognized letter is an error. Any non-letter character other than
 '[' ']' '{' '}' '#' and the single quote will be output directly.
 Despite this it is recommended to use single quotes around all characters
 that you want to output directly to ensure that future changes do not break
 your application.

  Resolving Map ZoneId Chronology resolved 
 Five parsing methods are supplied by this class.
 Four of these perform both the parse and resolve phases.
 The fifth method  parseUnresolved(java.lang.CharSequence java.text.ParsePosition) 
 only performs the first phase leaving the result unresolved.
 As such it is essentially a low-level operation.
  
 The resolve phase is controlled by two parameters set on this class.
  
 The  ResolverStyle  is an enum that offers three different approaches
 strict smart and lenient. The smart option is the default.
 It can be set using  withResolverStyle(java.time.format.ResolverStyle) .
  
 The  withResolverFields(java.time.temporal.TemporalField)  parameter allows the
 set of fields that will be resolved to be filtered before resolving starts.
 For example if the formatter has parsed a year month day-of-month
 and day-of-year then there are two approaches to resolve a date:
 (year + month + day-of-month) and (year + day-of-year).
 The resolver fields allows one of the two approaches to be selected.
 If no resolver fields are set then both approaches must result in the same date.
  
 Resolving separate fields to form a complete date and time is a complex
 process with behaviour distributed across a number of classes.
 It follows these steps:
  The chronology is determined.
 The chronology of the result is either the chronology that was parsed
 or if no chronology was parsed it is the chronology set on this class
 or if that is null it is  IsoChronology .
  The  ChronoField  date fields are resolved.
 This is achieved using  Chronology#resolveDate(Map ResolverStyle) .
 Documentation about field resolution is located in the implementation
 of  Chronology .
  The  ChronoField  time fields are resolved.
 This is documented on  ChronoField  and is the same for all chronologies.
  Any fields that are not  ChronoField  are processed.
 This is achieved using  TemporalField#resolve(Map TemporalAccessor ResolverStyle) .
 Documentation about field resolution is located in the implementation
 of  TemporalField .
  The  ChronoField  date and time fields are re-resolved.
 This allows fields in step four to produce  ChronoField  values
 and have them be processed into dates and times.
  A  LocalTime  is formed if there is at least an hour-of-day available.
 This involves providing default values for minute second and fraction of second.
  Any remaining unresolved fields are cross-checked against any
 date and/or time that was resolved. Thus an earlier stage would resolve
 (year + month + day-of-month) to a date and this stage would check that
 day-of-week was valid for the date.
  If an  excess number of days 
 was parsed then it is added to the date if a date is available."
android,java.time.format,DateTimeFormatterBuilder,39,"Builder to create date-time formatters.
  
 This allows a  DateTimeFormatter  to be created.
 All date-time formatters are created ultimately using this builder.
  
 The basic elements of date-time can all be added:
  Value - a numeric value Fraction - a fractional value including the decimal place. Always use this when
 outputting fractions to ensure that the fraction is parsed correctly Text - the textual equivalent for the value OffsetId/Offset - the  ZoneOffset ZoneId - the  ZoneId  id ZoneText - the name of the time-zone ChronologyId - the  Chronology  id ChronologyText - the name of the chronology Literal - a text literal Nested and Optional - formats can be nested or made optional 
 Finally a shorthand pattern mostly compatible with  java.text.SimpleDateFormat SimpleDateFormat 
 can be used see  appendPattern(java.lang.String) .
 In practice this simply parses the pattern and calls other methods on the builder."
android,java.time.format,DecimalStyle,14,"Localized decimal style used in date and time formatting.
  
 A significant part of dealing with dates and times is the localization.
 This class acts as a central point for accessing the information."
android,java.security,AccessController,8,Legacy security code; do not use.
android,java.security,AllPermission,2,Legacy security code; do not use.
android,java.security,CodeSigner,5,"This class encapsulates information about a code signer.
 It is immutable."
android,java.security,DigestOutputStream,6,"A transparent stream that updates the associated message digest using
 the bits going through the stream.

  To complete the message digest computation call one of the
  digest  methods on the associated message
 digest after your calls to one of this digest output stream's
  write  methods.

  It is possible to turn this stream on or off (see
  on ). When it is on a call to one of the
  write  methods results in
 an update on the message digest.  But when it is off the message
 digest is not updated. The default is for the stream to be on."
android,java.security,GuardedObject,1,"A GuardedObject is an object that is used to protect access to
 another object.

  A GuardedObject encapsulates a target object and a Guard object
 such that access to the target object is possible
 only if the Guard object allows it.
 Once an object is encapsulated by a GuardedObject
 access to that object is controlled by the  getObject 
 method which invokes the
  checkGuard  method on the Guard object that is
 guarding access. If access is not allowed
 an exception is thrown."
android,java.security,KeyFactory,9,"Key factories are used to convert  keys  (opaque
 cryptographic keys of type  Key ) into  key specifications 
 (transparent representations of the underlying key material) and vice
 versa.

   Key factories are bi-directional. That is they allow you to build an
 opaque key object from a given key specification (key material) or to
 retrieve the underlying key material of a key object in a suitable format.

   Multiple compatible key specifications may exist for the same key.
 For example a DSA public key may be specified using
  DSAPublicKeySpec  or
  X509EncodedKeySpec . A key factory can be used to translate
 between compatible key specifications.

   The following is an example of how to use a key factory in order to
 instantiate a DSA public key from its encoding.
 Assume Alice has received a digital signature from Bob.
 Bob also sent her his public key (in encoded format) to verify
 his signature. Alice then performs the following actions:

  
 X509EncodedKeySpec bobPubKeySpec = new X509EncodedKeySpec(bobEncodedPubKey);
 KeyFactory keyFactory = KeyFactory.getInstance(""DSA"");
 PublicKey bobPubKey = keyFactory.generatePublic(bobPubKeySpec);
 Signature sig = Signature.getInstance(""DSA"");
 sig.initVerify(bobPubKey);
 sig.update(data);
 sig.verify(signature);
   Android provides the following  KeyFactory  algorithms:
  Algorithm Supported API Levels DH 1+ DSA 1+ EC 11+ RSA 1+ X.509 1-8 
 KeyFactory section"
android,java.security,KeyFactorySpi,0,"This class defines the  Service Provider Interface  ( SPI )
 for the  KeyFactory  class.
 All the abstract methods in this class must be implemented by each
 cryptographic service provider who wishes to supply the implementation
 of a key factory for a particular algorithm.

   Key factories are used to convert  keys  (opaque
 cryptographic keys of type  Key ) into  key specifications 
 (transparent representations of the underlying key material) and vice
 versa.

   Key factories are bi-directional. That is they allow you to build an
 opaque key object from a given key specification (key material) or to
 retrieve the underlying key material of a key object in a suitable format.

   Multiple compatible key specifications may exist for the same key.
 For example a DSA public key may be specified using
  DSAPublicKeySpec  or
  X509EncodedKeySpec . A key factory can be used to translate
 between compatible key specifications.

   A provider should document all the key specifications supported by its
 key factory."
android,java.security,KeyPairGeneratorSpi,3,"This class defines the  Service Provider Interface  ( SPI )
 for the  KeyPairGenerator  class which is used to generate
 pairs of public and private keys.

   All the abstract methods in this class must be implemented by each
 cryptographic service provider who wishes to supply the implementation
 of a key pair generator for a particular algorithm.

   In case the client does not explicitly initialize the KeyPairGenerator
 (via a call to an  initialize  method) each provider must
 supply (and document) a default initialization.
 For example the  Sun  provider uses a default modulus size (keysize)
 of 1024 bits."
android,java.security,KeyStore.Builder,5,"A description of a to-be-instantiated KeyStore object.

  An instance of this class encapsulates the information needed to
 instantiate and initialize a KeyStore object. That process is
 triggered when the  getKeyStore()  method is called.

  This makes it possible to decouple configuration from KeyStore
 object creation and e.g. delay a password prompt until it is
 needed."
android,java.security,KeyStore.PasswordProtection,5,A password-based implementation of  ProtectionParameter .
android,java.security,KeyStore.SecretKeyEntry,3,A  KeyStore  entry that holds a  SecretKey .
android,java.security,KeyStore.TrustedCertificateEntry,3,"A  KeyStore  entry that holds a trusted
  Certificate ."
android,java.security,Permission,5,Legacy security code; do not use.
android,java.security,Permissions,3,Legacy security code; do not use.
android,java.security,PolicySpi,0,"This class defines the  Service Provider Interface  ( SPI )
 for the  Policy  class.
 All the abstract methods in this class must be implemented by each
 service provider who wishes to supply a Policy implementation.

   Subclass implementations of this abstract class must provide
 a public constructor that takes a  Policy.Parameters 
 object as an input parameter.  This constructor also must throw
 an IllegalArgumentException if it does not understand the
  Policy.Parameters  input."
android,java.security,ProtectionDomain,5,Legacy security code; do not use.
android,java.security,Provider,31,"This class represents a ""provider"" for the
 Java Security API where a provider implements some or all parts of
 Java Security. Services that a provider may implement include:

  Algorithms (such as DSA RSA MD5 or SHA-1).

  Key generation conversion and management facilities (such as for
 algorithm-specific keys).

 Each provider has a name and a version number and is configured
 in each runtime it is installed in.

  See  The Provider Class 
 in the ""Java Cryptography Architecture API Specification & Reference""
 for information about how a particular type of provider the
 cryptographic service provider works and is installed. However
 please note that a provider can be used to implement any security
 service in Java that uses a pluggable architecture with a choice
 of implementations that fit underneath.

  Some provider implementations may encounter unrecoverable internal
 errors during their operation for example a failure to communicate with a
 security token. A  ProviderException  should be used to indicate
 such errors.

  The service type  Provider  is reserved for use by the
 security framework. Services of this type cannot be added removed
 or modified by applications.
 The following attributes are automatically placed in each Provider object:
  Attributes Automatically Placed in a Provider Object Name Value Provider.id name String.valueOf(provider.getName()) Provider.id version String.valueOf(provider.getVersion()) Provider.id info String.valueOf(provider.getInfo()) Provider.id className provider.getClass().getName()"
android,java.security,Provider.Service,8,"The description of a security service. It encapsulates the properties
 of a service and contains a factory method to obtain new implementation
 instances of this service.

  Each service has a provider that offers the service a type
 an algorithm name and the name of the class that implements the
 service. Optionally it also includes a list of alternate algorithm
 names for this service (aliases) and attributes which are a map of
 (name value) String pairs.

  This class defines the methods  supportsParameter()  and  newInstance() 
 which are used by the Java security framework when it searches for
 suitable services and instantiates them. The valid arguments to those
 methods depend on the type of service. For the service types defined
 within Java SE see the
  
 Java Cryptography Architecture API Specification & Reference  
 for the valid values.
 Note that components outside of Java SE can define additional types of
 services and their behavior.

  Instances of this class are immutable."
android,java.security,SecureClassLoader,0,"This class extends ClassLoader with additional support for defining
 classes with an associated code source and permissions which are
 retrieved by the system policy by default."
android,java.security,SecureRandom,12,"This class provides a cryptographically strong random number
 generator (RNG).

  A cryptographically strong random number
 minimally complies with the statistical random number generator tests
 specified in  FIPS 140-2 Security Requirements for Cryptographic Modules 
 section 4.9.1.
 Additionally SecureRandom must produce non-deterministic output.
 Therefore any seed material passed to a SecureRandom object must be
 unpredictable and all SecureRandom output sequences must be
 cryptographically strong as described in
  RFC 1750: Randomness Recommendations for Security .

  A caller obtains a SecureRandom instance via the
 no-argument constructor or one of the  getInstance  methods:

  
      SecureRandom random = new SecureRandom();
   Many SecureRandom implementations are in the form of a pseudo-random
 number generator (PRNG) which means they use a deterministic algorithm
 to produce a pseudo-random sequence from a true random seed.
 Other implementations may produce true random numbers
 and yet others may use a combination of both techniques.

   Typical callers of SecureRandom invoke the following methods
 to retrieve random bytes:

  
      SecureRandom random = new SecureRandom();
      byte bytes[] = new byte[20];
      random.nextBytes(bytes);
   Callers may also invoke the  generateSeed  method
 to generate a given number of seed bytes (to seed other random number
 generators for example):
  
      byte seed[] = random.generateSeed(20);
  generateSeed nextBytes 
 Security ""Crypto"" provider deprecated in Android N"
android,java.security,Signature,23,"The Signature class is used to provide applications the functionality
 of a digital signature algorithm. Digital signatures are used for
 authentication and integrity assurance of digital data.

   The signature algorithm can be among others the NIST standard
 DSA using DSA and SHA-1. The DSA algorithm using the
 SHA-1 message digest algorithm can be specified as  SHA1withDSA .
 In the case of RSA there are multiple choices for the message digest
 algorithm so the signing algorithm could be specified as for example
  MD2withRSA   MD5withRSA  or  SHA1withRSA .
 The algorithm name must be specified as there is no default.

   A Signature object can be used to generate and verify digital
 signatures.

   There are three phases to the use of a Signature object for
 either signing data or verifying a signature: Initialization with either

      a public key which initializes the signature for
     verification (see  initVerify ) or

      a private key (and optionally a Secure Random Number Generator)
     which initializes the signature for signing
     (see  initSign(java.security.PrivateKey) 
     and  initSign(java.security.PrivateKey java.security.SecureRandom) ).

      Updating

  Depending on the type of initialization this will update the
 bytes to be signed or verified. See the
  update  methods.

  Signing or Verifying a signature on all updated bytes. See the
  sign  methods and the  verify 
 method.

  Note that this class is abstract and extends from
  SignatureSpi  for historical reasons.
 Application developers should only take notice of the methods defined in
 this  Signature  class; all the methods in
 the superclass are intended for cryptographic service providers who wish to
 supply their own implementations of digital signature algorithms.

   Android provides the following  Signature  algorithms:
  Algorithm Supported API Levels DSA 1+ DSAwithSHA1 1+ DSS 1-19 ECDSA 11+ ECDSAwithSHA1 11+ MD2withRSA 1-3 MD4withRSA 1-8 MD5withRSA 1+ MD5withRSA/ISO9796-2 1-8 NONEwithDSA 1+ NONEwithECDSA 11+ NONEwithRSA 17+ RSASSA-PSS 1-8 SHA1withDSA 1+ SHA1withECDSA 11+ SHA1withRSA 1+ SHA1withRSA/ISO9796-2 1-8 SHA1withRSA/PSS 23+ SHA224withDSA 20+ SHA224withECDSA 20+ SHA224withRSA 20+ SHA224withRSA/PSS 23+ SHA256withDSA 1+ SHA256withECDSA 11+ SHA256withRSA 1+ SHA256withRSA/PSS 23+ SHA384withECDSA 11+ SHA384withRSA 1+ SHA384withRSA/PSS 23+ SHA512withECDSA 11+ SHA512withRSA 1+ SHA512withRSA/PSS 23+ 
 Signature section"
android,java.security,SignatureSpi,15,"This class defines the  Service Provider Interface  ( SPI )
 for the  Signature  class which is used to provide the
 functionality of a digital signature algorithm. Digital signatures are used
 for authentication and integrity assurance of digital data.
.
   All the abstract methods in this class must be implemented by each
 cryptographic service provider who wishes to supply the implementation
 of a particular signature algorithm."
android,java.security,SignedObject,4,"SignedObject is a class for the purpose of creating authentic
 runtime objects whose integrity cannot be compromised without being
 detected.

   More specifically a SignedObject contains another Serializable
 object the (to-be-)signed object and its signature.

   The signed object is a ""deep copy"" (in serialized form) of an
 original object.  Once the copy is made further manipulation of
 the original object has no side effect on the copy.

   The underlying signing algorithm is designated by the Signature
 object passed to the constructor and the  verify  method.
 A typical usage for signing is the following:

  Signature signingEngine = Signature.getInstance(algorithm
                                                 provider);
 SignedObject so = new SignedObject(myobject signingKey
                                    signingEngine);
   A typical usage for verification is the following (having
 received SignedObject  so ):

  Signature verificationEngine =
     Signature.getInstance(algorithm provider);
 if (so.verify(publickey verificationEngine))
     try {
         Object myobj = so.getObject();
     } catch (java.lang.ClassNotFoundException e) {};
   Several points are worth noting.  First there is no need to
 initialize the signing or verification engine as it will be
 re-initialized inside the constructor and the  verify 
 method. Secondly for verification to succeed the specified
 public key must be the public key corresponding to the private key
 used to generate the SignedObject.

   More importantly for flexibility reasons the
 constructor and  verify  method allow for
 customized signature engines which can implement signature
 algorithms that are not installed formally as part of a crypto
 provider.  However it is crucial that the programmer writing the
 verifier code be aware what  Signature  engine is being
 used as its own implementation of the  verify  method
 is invoked to verify a signature.  In other words a malicious
  Signature  may choose to always return true on
 verification in an attempt to bypass a security check.

   The signature algorithm can be among others the NIST standard
 DSA using DSA and SHA-1.  The algorithm is specified using the
 same convention as that for signatures. The DSA algorithm using the
 SHA-1 message digest algorithm can be specified for example as
 ""SHA/DSA"" or ""SHA-1/DSA"" (they are equivalent).  In the case of
 RSA there are multiple choices for the message digest algorithm
 so the signing algorithm could be specified as for example
 ""MD2/RSA"" ""MD5/RSA"" or ""SHA-1/RSA"".  The algorithm name must be
 specified as there is no default.

   The name of the Cryptography Package Provider is designated
 also by the Signature parameter to the constructor and the
  verify  method.  If the provider is not
 specified the default provider is used.  Each installation can
 be configured to use a particular provider as default.

   Potential applications of SignedObject include:
   It can be used
 internally to any Java runtime as an unforgeable authorization
 token -- one that can be passed around without the fear that the
 token can be maliciously modified without being detected.
   It
 can be used to sign and serialize data/object for storage outside
 the Java runtime (e.g. storing critical access control data on
 disk).
   Nested SignedObjects can be used to construct a logical
 sequence of signatures resembling a chain of authorization and
 delegation."
android,java.security,Signer,3,"This class is used to represent an Identity that can also digitally
 sign data.

  The management of a signer's private keys is an important and
 sensitive issue that should be handled by subclasses as appropriate
 to their intended use."
android,java.security,UnresolvedPermission,6,Legacy security code; do not use.
android,java.security,AlgorithmParameterGenerator,10,"The  AlgorithmParameterGenerator  class is used to generate a
 set of
 parameters to be used with a certain algorithm. Parameter generators
 are constructed using the  getInstance  factory methods
 (static methods that return instances of a given class).

  The object that will generate the parameters can be initialized
 in two different ways: in an algorithm-independent manner or in an
 algorithm-specific manner:

  The algorithm-independent approach uses the fact that all parameter
 generators share the concept of a ""size"" and a
 source of randomness. The measure of size is universally shared
 by all algorithm parameters though it is interpreted differently
 for different algorithms. For example in the case of parameters for
 the  DSA  algorithm ""size"" corresponds to the size
 of the prime modulus (in bits).
 When using this approach algorithm-specific parameter generation
 values - if any - default to some standard values unless they can be
 derived from the specified size.

  The other approach initializes a parameter generator object
 using algorithm-specific semantics which are represented by a set of
 algorithm-specific parameter generation values. To generate
 Diffie-Hellman system parameters for example the parameter generation
 values usually
 consist of the size of the prime modulus and the size of the
 random exponent both specified in number of bits.
  In case the client does not explicitly initialize the
 AlgorithmParameterGenerator
 (via a call to an  init  method) each provider must supply (and
 document) a default initialization. For example the Sun provider uses a
 default modulus prime size of 1024 bits for the generation of DSA
 parameters.

   Android provides the following  AlgorithmParameterGenerator  algorithms:
  Algorithm Supported API Levels AES 1-8 DES 1-8 DESede 1-8 DH 1+ DSA 1+ 
 AlgorithmParameterGenerator section"
android,java.security,AlgorithmParameterGeneratorSpi,0,"This class defines the  Service Provider Interface  ( SPI )
 for the  AlgorithmParameterGenerator  class which
 is used to generate a set of parameters to be used with a certain algorithm.

   All the abstract methods in this class must be implemented by each
 cryptographic service provider who wishes to supply the implementation
 of a parameter generator for a particular algorithm.

   In case the client does not explicitly initialize the
 AlgorithmParameterGenerator (via a call to an  engineInit 
 method) each provider must supply (and document) a default initialization.
 For example the Sun provider uses a default modulus prime size of 1024
 bits for the generation of DSA parameters."
android,java.security,AlgorithmParameters,12,"This class is used as an opaque representation of cryptographic parameters.

  An  AlgorithmParameters  object for managing the parameters
 for a particular algorithm can be obtained by
 calling one of the  getInstance  factory methods
 (static methods that return instances of a given class).

  Once an  AlgorithmParameters  object is obtained it must be
 initialized via a call to  init  using an appropriate parameter
 specification or parameter encoding.

  A transparent parameter specification is obtained from an
  AlgorithmParameters  object via a call to
  getParameterSpec  and a byte encoding of the parameters is
 obtained via a call to  getEncoded .

   Android provides the following  AlgorithmParameters  algorithms:
  Algorithm Supported API Levels AES 1+ BLOWFISH 10+ ChaCha20 28+ DES 1+ DESede 1+ DH 1+ DSA 1+ EC 26+ GCM 22+ IES 1-8 OAEP 1+ PBEwithHmacSHA1AndAES_128 26+ PBEwithHmacSHA1AndAES_256 26+ PBEwithHmacSHA224AndAES_128 26+ PBEwithHmacSHA224AndAES_256 26+ PBEwithHmacSHA256AndAES_128 26+ PBEwithHmacSHA256AndAES_256 26+ PBEwithHmacSHA384AndAES_128 26+ PBEwithHmacSHA384AndAES_256 26+ PBEwithHmacSHA512AndAES_128 26+ PBEwithHmacSHA512AndAES_256 26+ PKCS12PBE 1+ PSS 1-824+ 
 AlgorithmParameters section"
android,java.security,AlgorithmParametersSpi,0,"This class defines the  Service Provider Interface  ( SPI )
 for the  AlgorithmParameters  class which is used to manage
 algorithm parameters.

   All the abstract methods in this class must be implemented by each
 cryptographic service provider who wishes to supply parameter management
 for a particular algorithm."
android,java.security,BasicPermission,2,Legacy security code; do not use.
android,java.security,DomainLoadStoreParameter,3,"Configuration data that specifies the keystores in a keystore domain.
 A keystore domain is a collection of keystores that are presented as a
 single logical keystore. The configuration data is used during
  KeyStore KeyStore#load(KeyStore.LoadStoreParameter)  and
  KeyStore#store(KeyStore.LoadStoreParameter)  operations.
  
 The following syntax is supported for configuration data:
  domain <domainName> [<property> ...] {
         keystore <keystoreName> [<property> ...] ;
         ...
     };
     ...
  domainName keystoreName property Arrays#toString(java.lang.Object[]) 
 To ensure that keystore entries are uniquely identified each
 entry's alias is prefixed by its  keystoreName  followed
 by the entry name separator and each  keystoreName  must be
 unique within its domain. Entry name prefixes are omitted when
 storing a keystore.
  
 Properties are context-sensitive: properties that apply to
 all the keystores in a domain are located in the domain clause
 and properties that apply only to a specific keystore are located
 in that keystore's clause.
 Unless otherwise specified a property in a keystore clause overrides
 a property of the same name in the domain clause. All property names
 are case-insensitive. The following properties are supported:
  keystoreType=""<type>""  The keystore type.  keystoreURI=""<url>""  The keystore location.  keystoreProviderName=""<name>""  The name of the keystore's JCE provider.  keystorePasswordEnv=""<environment-variable>""  The environment variable that stores a keystore password.
          Alternatively passwords may be supplied to the constructor
          method in a  Map<String ProtectionParameter> .  entryNameSeparator=""<separator>""  The separator between a keystore name prefix and an entry name.
          When specified it applies to all the entries in a domain.
          Its default value is a space.  
 For example configuration data for a simple keystore domain
 comprising three keystores is shown below:
  

 domain app1 {
     keystore app1-truststore
         keystoreURI=""file:///app1/etc/truststore.jks"";

     keystore system-truststore
         keystoreURI=""${java.home}/lib/security/cacerts"";

     keystore app1-keystore
         keystoreType=""PKCS12""
         keystoreURI=""file:///app1/etc/keystore.p12"";
 };"
android,java.security,Identity,14,"This class represents identities: real-world objects such as people
 companies or organizations whose identities can be authenticated using
 their public keys. Identities may also be more abstract (or concrete)
 constructs such as daemon threads or smart cards.

  All Identity objects have a name and a public key. Names are
 immutable. Identities may also be scoped. That is if an Identity is
 specified to have a particular scope then the name and public
 key of the Identity are unique within that scope.

  An Identity also has a set of certificates (all certifying its own
 public key). The Principal names specified in these certificates need
 not be the same only the key.

  An Identity can be subclassed to include postal and email addresses
 telephone numbers images of faces and logos and so on."
android,java.security,PermissionCollection,5,Legacy security code; do not use.
android,java.security,AccessControlContext,2,Legacy security code; do not use.
android,java.security,AuthProvider,3,Legacy security code; do not use.
android,java.security,CodeSource,4,Legacy security code; do not use.
android,java.security,DigestInputStream,6,"A transparent stream that updates the associated message digest using
 the bits going through the stream.

  To complete the message digest computation call one of the
  digest  methods on the associated message
 digest after your calls to one of this digest input stream's
  read  methods.

  It is possible to turn this stream on or off (see
  on ). When it is on a call to one of the
  read  methods
 results in an update on the message digest.  But when it is off
 the message digest is not updated. The default is for the stream
 to be on.

  Note that digest objects can compute only one digest (see
  MessageDigest )
 so that in order to compute intermediate digests a caller should
 retain a handle onto the digest object and clone it for each
 digest to be computed leaving the orginal digest untouched."
android,java.security,IdentityScope,10,"This class represents a scope for identities. It is an Identity
 itself and therefore has a name and can have a scope. It can also
 optionally have a public key and associated certificates.

  An IdentityScope can contain Identity objects of all kinds including
 Signers. All types of Identity objects can be retrieved added and
 removed using the same methods. Note that it is possible and in fact
 expected that different types of identity scopes will
 apply different policies for their various operations on the
 various types of Identities.

  There is a one-to-one mapping between keys and identities and
 there can only be one copy of one key per scope. For example suppose
  Acme Software Inc  is a software publisher known to a user.
 Suppose it is an Identity that is it has a public key and a set of
 associated certificates. It is named in the scope using the name
 ""Acme Software"". No other named Identity in the scope has the same
 public  key. Of course none has the same name as well."
android,java.security,KeyPair,2,"This class is a simple holder for a key pair (a public key and a
 private key). It does not enforce any security and when initialized
 should be treated like a PrivateKey."
android,java.security,KeyPairGenerator,11,"The KeyPairGenerator class is used to generate pairs of
 public and private keys. Key pair generators are constructed using the
  getInstance  factory methods (static methods that
 return instances of a given class).

  A Key pair generator for a particular algorithm creates a public/private
 key pair that can be used with this algorithm. It also associates
 algorithm-specific parameters with each of the generated keys.

  There are two ways to generate a key pair: in an algorithm-independent
 manner and in an algorithm-specific manner.
 The only difference between the two is the initialization of the object:

  Algorithm-Independent Initialization All key pair generators share the concepts of a keysize and a
 source of randomness. The keysize is interpreted differently for different
 algorithms (e.g. in the case of the  DSA  algorithm the keysize
 corresponds to the length of the modulus).
 There is an
  initialize 
 method in this KeyPairGenerator class that takes these two universally
 shared types of arguments. There is also one that takes just a
  keysize  argument and uses the  SecureRandom 
 implementation of the highest-priority installed provider as the source
 of randomness. (If none of the installed providers supply an implementation
 of  SecureRandom  a system-provided source of randomness is
 used.)

  Since no other parameters are specified when you call the above
 algorithm-independent  initialize  methods it is up to the
 provider what to do about the algorithm-specific parameters (if any) to be
 associated with each of the keys.

  If the algorithm is the  DSA  algorithm and the keysize (modulus
 size) is 512 768 or 1024 then the  Sun  provider uses a set of
 precomputed values for the  p   q  and
  g  parameters. If the modulus size is not one of the above
 values the  Sun  provider creates a new set of parameters. Other
 providers might have precomputed parameter sets for more than just the
 three modulus sizes mentioned above. Still others might not have a list of
 precomputed parameters at all and instead always create new parameter sets.

  Algorithm-Specific Initialization For situations where a set of algorithm-specific parameters already
 exists (e.g. so-called  community parameters  in DSA) there are two
  initialize  methods that have an  AlgorithmParameterSpec 
 argument. One also has a  SecureRandom  argument while the
 the other uses the  SecureRandom 
 implementation of the highest-priority installed provider as the source
 of randomness. (If none of the installed providers supply an implementation
 of  SecureRandom  a system-provided source of randomness is
 used.)
  In case the client does not explicitly initialize the KeyPairGenerator
 (via a call to an  initialize  method) each provider must
 supply (and document) a default initialization.
 For example the  Sun  provider uses a default modulus size (keysize)
 of 1024 bits.

  Note that this class is abstract and extends from
  KeyPairGeneratorSpi  for historical reasons.
 Application developers should only take notice of the methods defined in
 this  KeyPairGenerator  class; all the methods in
 the superclass are intended for cryptographic service providers who wish to
 supply their own implementations of key pair generators.

   Android provides the following  KeyPairGenerator  algorithms:
  Algorithm Supported API Levels DH 1+ DSA 1+ EC 11+ RSA 1+ 
 KeyPairGenerator section"
android,java.security,KeyStore,27,"This class represents a storage facility for cryptographic
 keys and certificates.

   A  KeyStore  manages different types of entries.
 Each type of entry implements the  KeyStore.Entry  interface.
 Three basic  KeyStore.Entry  implementations are provided:

  KeyStore.PrivateKeyEntry  This type of entry holds a cryptographic  PrivateKey 
 which is optionally stored in a protected format to prevent
 unauthorized access.  It is also accompanied by a certificate chain
 for the corresponding public key.

   Private keys and certificate chains are used by a given entity for
 self-authentication. Applications for this authentication include software
 distribution organizations which sign JAR files as part of releasing
 and/or licensing software.

  KeyStore.SecretKeyEntry  This type of entry holds a cryptographic  SecretKey 
 which is optionally stored in a protected format to prevent
 unauthorized access.

  KeyStore.TrustedCertificateEntry  This type of entry contains a single public key  Certificate 
 belonging to another party. It is called a  trusted certificate 
 because the keystore owner trusts that the public key in the certificate
 indeed belongs to the identity identified by the  subject  (owner)
 of the certificate.

  This type of entry can be used to authenticate other parties.
   Each entry in a keystore is identified by an ""alias"" string. In the
 case of private keys and their associated certificate chains these strings
 distinguish among the different ways in which the entity may authenticate
 itself. For example the entity may authenticate itself using different
 certificate authorities or using different public key algorithms.

   Whether aliases are case sensitive is implementation dependent. In order
 to avoid problems it is recommended not to use aliases in a KeyStore that
 only differ in case.

   Whether keystores are persistent and the mechanisms used by the
 keystore if it is persistent are not specified here. This allows
 use of a variety of techniques for protecting sensitive (e.g. private or
 secret) keys. Smart cards or other integrated cryptographic engines
 (SafeKeyper) are one option and simpler mechanisms such as files may also
 be used (in a variety of formats).

   Typical ways to request a KeyStore object include
 relying on the default type and providing a specific keystore type.

  To rely on the default type:
  
    KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());
  
 The system will return a keystore implementation for the default type.

  To provide a specific keystore type:
  
      KeyStore ks = KeyStore.getInstance(""JKS"");
  
 The system will return the most preferred implementation of the
 specified keystore type available in the environment.   Before a keystore can be accessed it must be
  loaded .
  
    KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());

    // get user password and file input stream
    char[] password = getPassword();

    try (FileInputStream fis = new FileInputStream(""keyStoreName"")) {
        ks.load(fis password);
    }
  load null InputStream  Once the keystore has been loaded it is possible
 to read existing entries from the keystore or to write new entries
 into the keystore:
  
    KeyStore.ProtectionParameter protParam =
        new KeyStore.PasswordProtection(password);

    // get my private key
    KeyStore.PrivateKeyEntry pkEntry = (KeyStore.PrivateKeyEntry)
        ks.getEntry(""privateKeyAlias"" protParam);
    PrivateKey myPrivateKey = pkEntry.getPrivateKey();

    // save my secret key
    javax.crypto.SecretKey mySecretKey;
    KeyStore.SecretKeyEntry skEntry =
        new KeyStore.SecretKeyEntry(mySecretKey);
    ks.setEntry(""secretKeyAlias"" skEntry protParam);

    // store away the keystore
    try (FileOutputStream fos = new FileOutputStream(""newKeyStoreName"")) {
        ks.store(fos password);
    }
   Android provides the following  KeyStore  types:
  Algorithm Supported API Levels AndroidCAStore 14+ AndroidKeyStore 18+ BCPKCS12 1-8 BKS 1+ BouncyCastle 1+ PKCS12 1+ PKCS12-DEF 1-8 
 KeyStore section"
android,java.security,KeyStore.CallbackHandlerProtection,1,A ProtectionParameter encapsulating a CallbackHandler.
android,java.security,KeyStore.PrivateKeyEntry,5,"A  KeyStore  entry that holds a  PrivateKey 
 and corresponding certificate chain."
android,java.security,Security,11,"This class centralizes all security properties and common security
 methods. One of its primary uses is to manage providers.

  The default values of security properties are read from an
 implementation-specific location which is typically the properties file
  lib/security/java.security  in the Java installation directory."
android,java.security,KeyRep,0,"Standardized representation for serialized Key objects.

  

 Note that a serialized Key may contain sensitive information
 which should not be exposed in untrusted environments.  See the
  
 Security Appendix 
 of the Serialization Specification for more information."
android,java.security,KeyStoreSpi,21,"This class defines the  Service Provider Interface  ( SPI )
 for the  KeyStore  class.
 All the abstract methods in this class must be implemented by each
 cryptographic service provider who wishes to supply the implementation
 of a keystore for a particular keystore type."
android,java.security,MessageDigest,17,"This MessageDigest class provides applications the functionality of a
 message digest algorithm such as SHA-1 or SHA-256.
 Message digests are secure one-way hash functions that take arbitrary-sized
 data and output a fixed-length hash value.

  A MessageDigest object starts out initialized. The data is
 processed through it using the  update 
 methods. At any point  reset  can be called
 to reset the digest. Once all the data to be updated has been
 updated one of the  digest  methods should
 be called to complete the hash computation.

  The  digest  method can be called once for a given number
 of updates. After  digest  has been called the MessageDigest
 object is reset to its initialized state.

  Implementations are free to implement the Cloneable interface.
 Client applications can test cloneability by attempting cloning
 and catching the CloneNotSupportedException:

  MessageDigest md = MessageDigest.getInstance(""SHA"");

 try {
     md.update(toChapter1);
     MessageDigest tc1 = md.clone();
     byte[] toChapter1Digest = tc1.digest();
     md.update(toChapter2);
     ...etc.
 } catch (CloneNotSupportedException cnse) {
     throw new DigestException(""couldn't make digest of partial content"");
 }
  Note that if a given implementation is not cloneable it is
 still possible to compute intermediate digests by instantiating
 several instances if the number of digests is known in advance.

  Note that this class is abstract and extends from
  MessageDigestSpi  for historical reasons.
 Application developers should only take notice of the methods defined in
 this  MessageDigest  class; all the methods in
 the superclass are intended for cryptographic service providers who wish to
 supply their own implementations of message digest algorithms.

   Android provides the following  MessageDigest  algorithms:
  Algorithm Supported API Levels MD5 1+ SHA-1 1+ SHA-224 1-822+ SHA-256 1+ SHA-384 1+ SHA-512 1+ 
 MessageDigest section"
android,java.security,MessageDigestSpi,8,"This class defines the  Service Provider Interface  ( SPI )
 for the  MessageDigest  class which provides the functionality
 of a message digest algorithm such as MD5 or SHA. Message digests are
 secure one-way hash functions that take arbitrary-sized data and output a
 fixed-length hash value.

   All the abstract methods in this class must be implemented by a
 cryptographic service provider who wishes to supply the implementation
 of a particular message digest algorithm.

   Implementations are free to implement the Cloneable interface."
android,java.security,PKCS12Attribute,6,"An attribute associated with a PKCS12 keystore entry.
 The attribute name is an ASN.1 Object Identifier and the attribute
 value is a set of ASN.1 types."
android,java.security,Policy,12,Legacy security code; do not use.
android,java.security,SecureRandomSpi,0,"This class defines the  Service Provider Interface  ( SPI )
 for the  SecureRandom  class.
 All the abstract methods in this class must be implemented by each
 service provider who wishes to supply the implementation
 of a cryptographically strong pseudo-random number generator."
android,java.security,SecurityPermission,0,Legacy security code; do not use.
android,java.security,Timestamp,5,"This class encapsulates information about a signed timestamp.
 It is immutable.
 It includes the timestamp's date and time as well as information about the
 Timestamping Authority (TSA) which generated and signed the timestamp."
android,java.text,AttributedCharacterIterator.Attribute,5,"Defines attribute keys that are used to identify text attributes. These
 keys are used in  AttributedCharacterIterator  and  AttributedString ."
android,java.text,AttributedString,6,"An AttributedString holds text and related attribute information. It
 may be used as the actual data storage in some cases where a text
 reader wants to access attributed text through the AttributedCharacterIterator
 interface.

  
 An attribute is a key/value pair identified by the key.  No two
 attributes on a given character can have the same key.

  The values for an attribute are immutable or must not be mutated
 by clients or storage.  They are always passed by reference and not
 cloned."
android,java.text,Bidi,15,"This class implements the Unicode Bidirectional Algorithm.
  
 A Bidi object provides information on the bidirectional reordering of the text
 used to create it.  This is required for example to properly display Arabic
 or Hebrew text.  These languages are inherently mixed directional as they order
 numbers from left-to-right while ordering most other text from right-to-left.
  
 Once created a Bidi object can be queried to see if the text it represents is
 all left-to-right or all right-to-left.  Such objects are very lightweight and
 this text is relatively easy to process.
  
 If there are multiple runs of text information about the runs can be accessed
 by indexing to get the start limit and level of a run.  The level represents
 both the direction and the 'nesting level' of a directional run.  Odd levels
 are right-to-left while even levels are left-to-right.  So for example level
 0 represents left-to-right text while level 1 represents right-to-left text and
 level 2 represents left-to-right text embedded in a right-to-left run."
android,java.text,BreakIterator,22,"The  BreakIterator  class implements methods for finding
 the location of boundaries in text. Instances of  BreakIterator 
 maintain a current position and scan over text
 returning the index of characters where boundaries occur.
 Internally  BreakIterator  scans text using a
  CharacterIterator  and is thus able to scan text held
 by any object implementing that protocol. A  StringCharacterIterator 
 is used to scan  String  objects passed to  setText .
 The  CharacterIterator  object must not be modified after having been
 passed to  setText . If the text in the  CharacterIterator  object
 is changed the caller must reset  BreakIterator  by calling
  setText .

  
 You use the factory methods provided by this class to create
 instances of various types of break iterators. In particular
 use  getWordInstance   getLineInstance 
  getSentenceInstance  and  getCharacterInstance 
 to create  BreakIterator s that perform
 word line sentence and character boundary analysis respectively.
 A single  BreakIterator  can work only on one unit
 (word line sentence and so on). You must use a different iterator
 for each unit boundary analysis you wish to perform.

  
 Line boundary analysis determines where a text string can be
 broken when line-wrapping. The mechanism correctly handles
 punctuation and hyphenated words. Actual line breaking needs
 to also consider the available line width and is handled by
 higher-level software.

  
 Sentence boundary analysis allows selection with correct interpretation
 of periods within numbers and abbreviations and trailing punctuation
 marks such as quotation marks and parentheses.

  
 Word boundary analysis is used by search and replace functions as
 well as within text editing applications that allow the user to
 select words with a double click. Word selection provides correct
 interpretation of punctuation marks within and following
 words. Characters that are not part of a word such as symbols
 or punctuation marks have word-breaks on both sides.

  
 Character boundary analysis allows users to interact with characters
 as they expect to for example when moving the cursor through a text
 string. Character boundary analysis provides correct navigation
 through character strings regardless of how the character is stored.
 The boundaries returned may be those of supplementary characters
 combining character sequences or ligature clusters.
 For example an accented character might be stored as a base character
 and a diacritical mark. What users consider to be a character can
 differ between languages.

  
 The  BreakIterator  instances returned by the factory methods
 of this class are intended for use with natural languages only not for
 programming language text. It is however possible to define subclasses
 that tokenize a programming language.

  Examples : 
 Creating and using text boundaries:
  
 public static void main(String args[]) {
      if (args.length == 1) {
          String stringToExamine = args[0];
          //print each word in order
          BreakIterator boundary = BreakIterator.getWordInstance();
          boundary.setText(stringToExamine);
          printEachForward(boundary stringToExamine);
          //print each sentence in reverse order
          boundary = BreakIterator.getSentenceInstance(Locale.US);
          boundary.setText(stringToExamine);
          printEachBackward(boundary stringToExamine);
          printFirst(boundary stringToExamine);
          printLast(boundary stringToExamine);
      }
 }
  
 public static void printEachForward(BreakIterator boundary String source) {
     int start = boundary.first();
     for (int end = boundary.next();
          end != BreakIterator.DONE;
          start = end end = boundary.next()) {
          System.out.println(source.substring(startend));
     }
 }
  
 public static void printEachBackward(BreakIterator boundary String source) {
     int end = boundary.last();
     for (int start = boundary.previous();
          start != BreakIterator.DONE;
          end = start start = boundary.previous()) {
         System.out.println(source.substring(startend));
     }
 }
  
 public static void printFirst(BreakIterator boundary String source) {
     int start = boundary.first();
     int end = boundary.next();
     System.out.println(source.substring(startend));
 }
  
 public static void printLast(BreakIterator boundary String source) {
     int end = boundary.last();
     int start = boundary.previous();
     System.out.println(source.substring(startend));
 }
  
 public static void printAt(BreakIterator boundary int pos String source) {
     int end = boundary.following(pos);
     int start = boundary.previous();
     System.out.println(source.substring(startend));
 }
  public static int nextWordStartAfter(int pos String text) {
     BreakIterator wb = BreakIterator.getWordInstance();
     wb.setText(text);
     int last = wb.following(pos);
     int current = wb.next();
     while (current != BreakIterator.DONE) {
         for (int p = last; p < current; p++) {
             if (Character.isLetter(text.codePointAt(p)))
                 return last;
         }
         last = current;
         current = wb.next();
     }
     return BreakIterator.DONE;
 }
  
 (The iterator returned by BreakIterator.getWordInstance() is unique in that
 the break positions it returns don't represent both the start and end of the
 thing being iterated over.  That is a sentence-break iterator returns breaks
 that each represent the end of one sentence and the beginning of the next.
 With the word-break iterator the characters between two boundaries might be a
 word or they might be the punctuation or whitespace between two words.  The
 above code uses a simple heuristic to determine which boundary is the beginning
 of a word: If the characters between this boundary and the next boundary
 include at least one letter (this can be an alphabetical letter a CJK ideograph
 a Hangul syllable a Kana character etc.) then the text between this boundary
 and the next is a word; otherwise it's the material between words.)"
android,java.text,ChoiceFormat,14,"A  ChoiceFormat  allows you to attach a format to a range of numbers.
 It is generally used in a  MessageFormat  for handling plurals.
 The choice is specified with an ascending list of doubles where each item
 specifies a half-open interval up to the next item:
  
 X matches j if and only if limit[j] â‰¤ X < limit[j+1]
  \u221E Note: ChoiceFormat  differs from the other  Format 
 classes in that you create a  ChoiceFormat  object with a
 constructor (not with a  getInstance  style factory
 method). The factory methods aren't necessary because  ChoiceFormat 
 doesn't require any complex setup for a given locale. In fact
  ChoiceFormat  doesn't implement any locale specific behavior.

  
 When creating a  ChoiceFormat  you must specify an array of formats
 and an array of limits. The length of these arrays must be the same.
 For example
  limits  = {1234567} formats  = {""Sun""""Mon""""Tue""""Wed""""Thur""""Fri""""Sat""}
  limits  = {0 1 ChoiceFormat.nextDouble(1)} formats  = {""no files"" ""one file"" ""many files""} 
     ( nextDouble  can be used to get the next higher double to
     make the half-open interval.)
  
 Here is a simple example that shows formatting and parsing:
  double[] limits = {1234567};
 String[] dayOfWeekNames = {""Sun""""Mon""""Tue""""Wed""""Thur""""Fri""""Sat""};
 ChoiceFormat form = new ChoiceFormat(limits dayOfWeekNames);
 ParsePosition status = new ParsePosition(0);
 for (double i = 0.0; i <= 8.0; ++i) {
     status.setIndex(0);
     System.out.println(i + "" -> "" + form.format(i) + "" -> ""
                              + form.parse(form.format(i)status));
 }
  double[] filelimits = {012};
 String[] filepart = {""are no files""""is one file""""are {2} files""};
 ChoiceFormat fileform = new ChoiceFormat(filelimits filepart);
 Format[] testFormats = {fileform null NumberFormat.getInstance()};
 MessageFormat pattform = new MessageFormat(""There {0} on {1}"");
 pattform.setFormats(testFormats);
 Object[] testArgs = {null ""ADisk"" null};
 for (int i = 0; i < 4; ++i) {
     testArgs[0] = new Integer(i);
     testArgs[2] = testArgs[0];
     System.out.println(pattform.format(testArgs));
 }
  
 Specifying a pattern for ChoiceFormat objects is fairly straightforward.
 For example:
  ChoiceFormat fmt = new ChoiceFormat(
      ""-1#is negative| 0#is zero or fraction | 1#is one |1.0<is 1+ |2#is two |2<is more than 2."");
 System.out.println(""Formatter Pattern : "" + fmt.toPattern());

 System.out.println(""Format with -INF : "" + fmt.format(Double.NEGATIVE_INFINITY));
 System.out.println(""Format with -1.0 : "" + fmt.format(-1.0));
 System.out.println(""Format with 0 : "" + fmt.format(0));
 System.out.println(""Format with 0.9 : "" + fmt.format(0.9));
 System.out.println(""Format with 1.0 : "" + fmt.format(1));
 System.out.println(""Format with 1.5 : "" + fmt.format(1.5));
 System.out.println(""Format with 2 : "" + fmt.format(2));
 System.out.println(""Format with 2.1 : "" + fmt.format(2.1));
 System.out.println(""Format with NaN : "" + fmt.format(Double.NaN));
 System.out.println(""Format with +INF : "" + fmt.format(Double.POSITIVE_INFINITY));
  Format with -INF : is negative
 Format with -1.0 : is negative
 Format with 0 : is zero or fraction
 Format with 0.9 : is zero or fraction
 Format with 1.0 : is one
 Format with 1.5 : is 1+
 Format with 2 : is two
 Format with 2.1 : is more than 2.
 Format with NaN : is negative
 Format with +INF : is more than 2.
  Synchronization 
 Choice formats are not synchronized.
 It is recommended to create separate format instances for each thread.
 If multiple threads access a format concurrently it must be synchronized
 externally."
android,java.text,DateFormat.Field,3,"Defines constants that are used as attribute keys in the
  AttributedCharacterIterator  returned
 from  DateFormat.formatToCharacterIterator  and as
 field identifiers in  FieldPosition .
  
 The class also provides two methods to map
 between its constants and the corresponding Calendar constants."
android,java.text,FieldPosition,9,"FieldPosition  is a simple class used by  Format 
 and its subclasses to identify fields in formatted output. Fields can
 be identified in two ways:
  By an integer constant whose names typically end with
       _FIELD . The constants are defined in the various
      subclasses of  Format .
   By a  Format.Field  constant see  ERA_FIELD 
      and its friends in  DateFormat  for an example.
  FieldPosition  keeps track of the position of the
 field within the formatted output with two indices: the index
 of the first character of the field and the index of the last
 character of the field.

  
 One version of the  format  method in the various
  Format  classes requires a  FieldPosition 
 object as an argument. You use this  format  method
 to perform partial formatting or to get information about the
 formatted output (such as the position of a field).

  
 If you are interested in the positions of all attributes in the
 formatted string use the  Format  method
  formatToCharacterIterator ."
android,java.text,Format.Field,0,"Defines constants that are used as attribute keys in the
  AttributedCharacterIterator  returned
 from  Format.formatToCharacterIterator  and as
 field identifiers in  FieldPosition ."
android,java.text,NumberFormat,38,"NumberFormat  is the abstract base class for all number
 formats. This class provides the interface for formatting and parsing
 numbers.  NumberFormat  also provides methods for determining
 which locales have number formats and what their names are.

  NumberFormat  helps you to format and parse numbers for any locale.
 Your code can be completely independent of the locale conventions for
 decimal points thousands-separators or even the particular decimal
 digits used or whether the number format is even decimal.

  
 To format a number for the current Locale use one of the factory
 class methods:
  myString = NumberFormat.getInstance().format(myNumber);
  NumberFormat nf = NumberFormat.getInstance();
 for (int i = 0; i < myNumber.length; ++i) {
     output.println(nf.format(myNumber[i]) + ""; "");
 }
  getInstance NumberFormat nf = NumberFormat.getInstance(Locale.FRENCH);
  NumberFormat myNumber = nf.parse(myString);
  getInstance getNumberInstance getIntegerInstance getCurrencyInstance getPercentInstance 
 You can also control the display of numbers with such methods as
  setMinimumFractionDigits .
 If you want even more control over the format or parsing
 or want to give your users more control
 you can try casting the  NumberFormat  you get from the factory methods
 to a  DecimalFormat . This will work for the vast majority
 of locales; just remember to put it in a  try  block in case you
 encounter an unusual one.

  
 NumberFormat and DecimalFormat are designed such that some controls
 work for formatting and others work for parsing.  The following is
 the detailed description for each these control methods
  
 setParseIntegerOnly : only affects parsing e.g.
 if true  ""3456.78"" â†’ 3456 (and leaves the parse position just after index 6)
 if false ""3456.78"" â†’ 3456.78 (and leaves the parse position just after index 8)
 This is independent of formatting.  If you want to not show a decimal point
 where there might be no digits after the decimal point use
 setDecimalSeparatorAlwaysShown.
  
 setDecimalSeparatorAlwaysShown : only affects formatting and only where
 there might be no digits after the decimal point such as with a pattern
 like ""###0.##"" e.g.
 if true  3456.00 â†’ ""3456.""
 if false 3456.00 â†’ ""3456""
 This is independent of parsing.  If you want parsing to stop at the decimal
 point use setParseIntegerOnly.

  
 You can also use forms of the  parse  and  format 
 methods with  ParsePosition  and  FieldPosition  to
 allow you to:
   progressively parse through pieces of a string
   align the decimal point and other areas
   If you are using a monospaced font with spacing for alignment
      you can pass the  FieldPosition  in your format call with
       field  =  INTEGER_FIELD . On output
       getEndIndex  will be set to the offset between the
      last character of the integer and the decimal. Add
      (desiredSpaceCount - getEndIndex) spaces at the front of the string.

   If you are using proportional fonts
      instead of padding with spaces measure the width
      of the string in pixels from the start to  getEndIndex .
      Then move the pen by
      (desiredPixelWidth - widthToAlignmentPoint) before drawing the text.
      It also works where there is no decimal but possibly additional
      characters at the end e.g. with parentheses in negative
      numbers: ""(12)"" for -12.
  Synchronization 
 Number formats are generally not synchronized.
 It is recommended to create separate format instances for each thread.
 If multiple threads access a format concurrently it must be synchronized
 externally."
android,java.text,SimpleDateFormat,14,"SimpleDateFormat  is a concrete class for formatting and
 parsing dates in a locale-sensitive manner. It allows for formatting
 (date â†’ text) parsing (text â†’ date) and normalization.

  SimpleDateFormat  allows you to start by choosing
 any user-defined patterns for date-time formatting. However you
 are encouraged to create a date-time formatter with either
  getTimeInstance   getDateInstance  or
  getDateTimeInstance  in  DateFormat . Each
 of these class methods can return a date/time formatter initialized
 with a default format pattern. You may modify the format pattern
 using the  applyPattern  methods as desired.
 For more information on using these methods see
  DateFormat .

  Date and Time Patterns 
 Date and time formats are specified by  date and time pattern 
 strings.
 Within date and time pattern strings unquoted letters from
  'A'  to  'Z'  and from  'a'  to
  'z'  are interpreted as pattern letters representing the
 components of a date or time string.
 Text can be quoted using single quotes ( ' ) to avoid
 interpretation.
  ""''""  represents a single quote.
 All other characters are not interpreted; they're simply copied into the
 output string during formatting or matched against the input string
 during parsing.
  
 The following pattern letters are defined (all other characters from
  'A'  to  'Z'  and from  'a'  to
  'z'  are reserved):
  Letter
          Date or Time Component
          Presentation
          Examples
          Supported (API Levels)
      G Era designator
          Text AD 1+ y Year
          Year 1996 ;  96 1+ Y Week year
          Year 2009 ;  09 24+ M Month in year (context sensitive)
          Month July ;  Jul ;  07 1+ L Month in year (standalone form)
          Month July ;  Jul ;  07 TBD w Week in year
          Number 27 1+ W Week in month
          Number 2 1+ D Day in year
          Number 189 1+ d Day in month
          Number 10 1+ F Day of week in month
          Number 2 1+ E Day name in week
          Text Tuesday ;  Tue 1+ u Day number of week (1 = Monday ... 7 = Sunday)
          Number 1 24+ a Am/pm marker
          Text PM 1+ H Hour in day (0-23)
          Number 0 1+ k Hour in day (1-24)
          Number 24 1+ K Hour in am/pm (0-11)
          Number 0 1+ h Hour in am/pm (1-12)
          Number 12 1+ m Minute in hour
          Number 30 1+ s Second in minute
          Number 55 1+ S Millisecond
          Number 978 1+ z Time zone
          General time zone Pacific Standard Time ;  PST ;  GMT-08:00 1+ Z Time zone
          RFC 822 time zone -0800 1+ X Time zone
          ISO 8601 time zone -08 ;  -0800 ;   -08:00 24+ Text: 
     For formatting if the number of pattern letters is 4 or more
     the full form is used; otherwise a short or abbreviated form
     is used if available.
     For parsing both forms are accepted independent of the number
     of pattern letters. Number: 
     For formatting the number of pattern letters is the minimum
     number of digits and shorter numbers are zero-padded to this amount.
     For parsing the number of pattern letters is ignored unless
     it's needed to separate two adjacent fields. Year: 
     If the formatter's  Calendar  is the Gregorian
     calendar the following rules are applied.
      For formatting if the number of pattern letters is 2 the year
         is truncated to 2 digits; otherwise it is interpreted as a
          number .
      For parsing if the number of pattern letters is more than 2
         the year is interpreted literally regardless of the number of
         digits. So using the pattern ""MM/dd/yyyy"" ""01/11/12"" parses to
         Jan 11 12 A.D.
      For parsing with the abbreviated year pattern (""y"" or ""yy"")
          SimpleDateFormat  must interpret the abbreviated year
         relative to some century.  It does this by adjusting dates to be
         within 80 years before and 20 years after the time the  SimpleDateFormat 
         instance is created. For example using a pattern of ""MM/dd/yy"" and a
          SimpleDateFormat  instance created on Jan 1 1997  the string
         ""01/11/12"" would be interpreted as Jan 11 2012 while the string ""05/04/64""
         would be interpreted as May 4 1964.
         During parsing only strings consisting of exactly two digits as defined by
          Character#isDigit(char)  will be parsed into the default century.
         Any other numeric string such as a one digit string a three or more digit
         string or a two digit string that isn't all digits (for example ""-1"") is
         interpreted literally.  So ""01/02/3"" or ""01/02/003"" are parsed using the
         same pattern as Jan 2 3 AD.  Likewise ""01/02/-3"" is parsed as Jan 2 4 BC.
      
     Otherwise calendar system specific forms are applied.
     For both formatting and parsing if the number of pattern
     letters is 4 or more a calendar specific  Calendar#LONG  is used. Otherwise a calendar
     specific  Calendar#SHORT 
     is used.
      
     If week year  'Y'  is specified and the  calendar  doesn't support any   week
     years  the calendar year ( 'y' ) is used instead. The
     support of week years can be tested with a call to  DateFormat#getCalendar() . isWeekDateSupported() . Month: 
     If the number of pattern letters is 3 or more the month is
     interpreted as  text ; otherwise
     it is interpreted as a  number .
      Letter  M  produces context-sensitive month names such as the
         embedded form of names. If a  DateFormatSymbols  has been set
         explicitly with constructor  SimpleDateFormat(java.lang.String java.text.DateFormatSymbols)  or method  setDateFormatSymbols(java.text.DateFormatSymbols)  the month names given by
         the  DateFormatSymbols  are used. Letter  L  produces the standalone form of month names. General time zone: 
     Time zones are interpreted as  text  if they have
     names. For time zones representing a GMT offset value the
     following syntax is used:
      GMTOffsetTimeZone: GMT Sign Hours : Minutes Sign:  one of
              + - Hours: Digit Digit Digit Minutes: Digit Digit Digit:  one of
              0 1 2 3 4 5 6 7 8 9 Hours  must be between 0 and 23 and  Minutes  must be between
     00 and 59. The format is locale independent and digits must be taken
     from the Basic Latin block of the Unicode standard.
      For parsing  RFC 822 time zones  are also
     accepted. RFC 822 time zone: 
     For formatting the RFC 822 4-digit time zone format is used:

      RFC822TimeZone: Sign TwoDigitHours Minutes TwoDigitHours: Digit Digit TwoDigitHours  must be between 00 and 23. Other definitions
     are as for  general time zones .

      For parsing  general time zones  are also
     accepted.
  ISO 8601 Time zone: 
     The number of pattern letters designates the format for both formatting
     and parsing as follows:
      ISO8601TimeZone: OneLetterISO8601TimeZone TwoLetterISO8601TimeZone ThreeLetterISO8601TimeZone OneLetterISO8601TimeZone: Sign TwoDigitHours Z TwoLetterISO8601TimeZone: Sign TwoDigitHours Minutes Z ThreeLetterISO8601TimeZone: Sign TwoDigitHours : Minutes Z 
     Other definitions are as for  general time zones  or
      RFC 822 time zones .

      For formatting if the offset value from GMT is 0  ""Z""  is
     produced. If the number of pattern letters is 1 any fraction of an hour
     is ignored. For example if the pattern is  ""X""  and the time zone is
      ""GMT+05:30""   ""+05""  is produced.

      For parsing the letter  ""Z""  is parsed as the UTC time zone designator (therefore
      ""09:30Z""  is parsed as  ""09:30 UTC"" .
      General time zones  are  not  accepted.
      If the number of  ""X""  pattern letters is 4 or more (e.g.  XXXX )  IllegalArgumentException  is thrown when constructing a  SimpleDateFormat  or  applying a
     pattern .
  SimpleDateFormat localized date and time
 pattern SimpleDateFormat Examples Date and Time Pattern
          Result
      ""yyyy.MM.dd G 'at' HH:mm:ss z"" 2001.07.04 AD at 12:08:56 PDT ""EEE MMM d ''yy"" Wed Jul 4 '01 ""h:mm a"" 12:08 PM ""hh 'o''clock' a zzzz"" 12 o'clock PM Pacific Daylight Time ""K:mm a z"" 0:08 PM PDT ""yyyyy.MMMMM.dd GGG hh:mm aaa"" 02001.July.04 AD 12:08 PM ""EEE d MMM yyyy HH:mm:ss Z"" Wed 4 Jul 2001 12:08:56 -0700 ""yyMMddHHmmssZ"" 010704120856-0700 ""yyyy-MM-dd'T'HH:mm:ss.SSSZ"" 2001-07-04T12:08:56.235-0700 ""yyyy-MM-dd'T'HH:mm:ss.SSSXXX"" 2001-07-04T12:08:56.235-07:00 ""YYYY-'W'ww-u"" 2001-W27-3 Synchronization 
 Date formats are not synchronized.
 It is recommended to create separate format instances for each thread.
 If multiple threads access a format concurrently it must be synchronized
 externally."
android,java.text,Annotation,2,"An Annotation object is used as a wrapper for a text attribute value if
 the attribute has annotation characteristics. These characteristics are:
  The text range that the attribute is applied to is critical to the
 semantics of the range. That means the attribute cannot be applied to subranges
 of the text range that it applies to and if two adjacent text ranges have
 the same value for this attribute the attribute still cannot be applied to
 the combined range as a whole with this value.
  The attribute or its value usually do no longer apply if the underlying text is
 changed.
  
 Wrapping the attribute value into an Annotation object guarantees that
 adjacent text runs don't get merged even if the attribute values are equal
 and indicates to text containers that the attribute should be discarded if
 the underlying text is modified."
android,java.text,CollationElementIterator,11,"The  CollationElementIterator  class is used as an iterator
 to walk through each character of an international string. Use the iterator
 to return the ordering priority of the positioned character. The ordering
 priority of a character which we refer to as a key defines how a character
 is collated in the given collation object.

  
 For example consider the following in Spanish:
  
 ""ca"" â†’ the first key is key('c') and second key is key('a').
 ""cha"" â†’ the first key is key('ch') and second key is key('a').
  
 ""Ã¤b"" â†’ the first key is key('a') the second key is key('e') and
 the third key is key('b').
  primaryOrder secondaryOrder tertiaryOrder int short short 
 Example of the iterator usage
  

  String testString = ""This is a test"";
  Collator col = Collator.getInstance();
  if (col instanceof RuleBasedCollator) {
      RuleBasedCollator ruleBasedCollator = (RuleBasedCollator)col;
      CollationElementIterator collationElementIterator = ruleBasedCollator.getCollationElementIterator(testString);
      int primaryOrder = CollationElementIterator.primaryOrder(collationElementIterator.next());
          :
  }
  CollationElementIterator.next  returns the collation order
 of the next character. A collation order consists of primary order
 secondary order and tertiary order. The data type of the collation
 order is  int . The first 16 bits of a collation order
 is its primary order; the next 8 bits is the secondary order and the
 last 8 bits is the tertiary order.

  Note: CollationElementIterator  is a part of
  RuleBasedCollator  implementation. It is only usable
 with  RuleBasedCollator  instances."
android,java.text,CollationKey,3,"A  CollationKey  represents a  String  under the
 rules of a specific  Collator  object. Comparing two
  CollationKey s returns the relative order of the
  String s they represent. Using  CollationKey s
 to compare  String s is generally faster than using
  Collator.compare . Thus when the  String s
 must be compared multiple times for example when sorting a list
 of  String s. It's more efficient to use  CollationKey s.

  
 You can not create  CollationKey s directly. Rather
 generate them by calling  Collator.getCollationKey .
 You can only compare  CollationKey s generated from
 the same  Collator  object.

  
 Generating a  CollationKey  for a  String 
 involves examining the entire  String 
 and converting it to series of bits that can be compared bitwise. This
 allows fast comparisons once the keys are generated. The cost of generating
 keys is recouped in faster comparisons when  String s need
 to be compared many times. On the other hand the result of a comparison
 is often determined by the first couple of characters of each  String .
  Collator.compare  examines only as many characters as it needs which
 allows it to be faster when doing single comparisons.
  
 The following example shows how  CollationKey s might be used
 to sort a list of  String s.
  // Create an array of CollationKeys for the Strings to be sorted.
 Collator myCollator = Collator.getInstance();
 CollationKey[] keys = new CollationKey[3];
 keys[0] = myCollator.getCollationKey(""Tom"");
 keys[1] = myCollator.getCollationKey(""Dick"");
 keys[2] = myCollator.getCollationKey(""Harry"");
 sort(keys);

 //...

 // Inside body of sort routine compare keys this way
 if (keys[i].compareTo(keys[j]) > 0)
    // swap keys[i] and keys[j]

 //...

 // Finally when we've returned from sort.
 System.out.println(keys[0].getSourceString());
 System.out.println(keys[1].getSourceString());
 System.out.println(keys[2].getSourceString());"
android,java.text,Collator,14,"The  Collator  class performs locale-sensitive
  String  comparison. You use this class to build
 searching and sorting routines for natural language text.

  Collator  is an abstract base class. Subclasses
 implement specific collation strategies. One subclass
  RuleBasedCollator  is currently provided with
 the Java Platform and is applicable to a wide set of languages. Other
 subclasses may be created to handle more specialized needs.

  
 Like other locale-sensitive classes you can use the static
 factory method  getInstance  to obtain the appropriate
  Collator  object for a given locale. You will only need
 to look at the subclasses of  Collator  if you need
 to understand the details of a particular collation strategy or
 if you need to modify that strategy.

  
 The following example shows how to compare two strings using
 the  Collator  for the default locale.
  // Compare two strings in the default locale
 Collator myCollator = Collator.getInstance();
 if( myCollator.compare(""abc"" ""ABC"") < 0 )
     System.out.println(""abc is less than ABC"");
 else
     System.out.println(""abc is greater than or equal to ABC"");
  
 You can set a  Collator 's  strength  property
 to determine the level of difference considered significant in
 comparisons. Four strengths are provided:  PRIMARY 
  SECONDARY   TERTIARY  and  IDENTICAL .
 The exact assignment of strengths to language features is
 locale dependant.  For example in Czech ""e"" and ""f"" are considered
 primary differences while ""e"" and ""Ä›"" are secondary differences
 ""e"" and ""E"" are tertiary differences and ""e"" and ""e"" are identical.
 The following shows how both case and accents could be ignored for
 US English.
  
 //Get the Collator for US English and set its strength to PRIMARY
 Collator usCollator = Collator.getInstance(Locale.US);
 usCollator.setStrength(Collator.PRIMARY);
 if( usCollator.compare(""abc"" ""ABC"") == 0 ) {
     System.out.println(""Strings are equivalent"");
 }
  
 For comparing  String s exactly once the  compare 
 method provides the best performance. When sorting a list of
  String s however it is generally necessary to compare each
  String  multiple times. In this case  CollationKey s
 provide better performance. The  CollationKey  class converts
 a  String  to a series of bits that can be compared bitwise
 against other  CollationKey s. A  CollationKey  is
 created by a  Collator  object for a given  String .
  Note: CollationKey s from different
  Collator s can not be compared. See the class description
 for  CollationKey 
 for an example using  CollationKey s."
android,java.text,DateFormat,28,"DateFormat  is an abstract class for date/time formatting subclasses which
 formats and parses dates or time in a language-independent manner.
 The date/time formatting subclass such as  SimpleDateFormat  allows for
 formatting (i.e. date â†’ text) parsing (text â†’ date) and
 normalization.  The date is represented as a  Date  object or
 as the milliseconds since January 1 1970 00:00:00 GMT.

  DateFormat  provides many class methods for obtaining default date/time
 formatters based on the default or a given locale and a number of formatting
 styles. The formatting styles include  FULL   LONG   MEDIUM  and  SHORT . More
 detail and examples of using these styles are provided in the method
 descriptions.

  DateFormat  helps you to format and parse dates for any locale.
 Your code can be completely independent of the locale conventions for
 months days of the week or even the calendar format: lunar vs. solar.

  To format a date for the current Locale use one of the
 static factory methods:
  myString = DateFormat.getDateInstance().format(myDate);
  If you are formatting multiple dates it is
 more efficient to get the format and use it multiple times so that
 the system doesn't have to fetch the information about the local
 language and country conventions multiple times.
  DateFormat df = DateFormat.getDateInstance();
 for (int i = 0; i < myDate.length; ++i) {
     output.println(df.format(myDate[i]) + ""; "");
 }
  To format a date for a different Locale specify it in the
 call to  getDateInstance() .
  DateFormat df = DateFormat.getDateInstance(DateFormat.LONG Locale.FRANCE);
  You can use a DateFormat to parse also.
  myDate = df.parse(myString);
  Use  getDateInstance  to get the normal date format for that country.
 There are other static factory methods available.
 Use  getTimeInstance  to get the time format for that country.
 Use  getDateTimeInstance  to get a date and time format. You can pass in
 different options to these factory methods to control the length of the
 result; from  SHORT  to  MEDIUM  to  LONG  to  FULL . The exact result depends
 on the locale but generally:
  SHORT  is completely numeric such as  12.13.52  or  3:30pm MEDIUM  is longer such as  Jan 12 1952 LONG  is longer such as  January 12 1952  or  3:30:32pm FULL  is pretty completely specified such as
  Tuesday April 12 1952 AD or 3:30:42pm PST .
  You can also set the time zone on the format if you wish.
 If you want even more control over the format or parsing
 (or want to give your users more control)
 you can try casting the  DateFormat  you get from the factory methods
 to a  SimpleDateFormat . This will work for the majority
 of countries; just remember to put it in a  try  block in case you
 encounter an unusual one.

  You can also use forms of the parse and format methods with
  ParsePosition  and  FieldPosition  to
 allow you to
  progressively parse through pieces of a string.
  align any particular field or find out where it is for selection
 on the screen.
  Synchronization 
 Date formats are not synchronized.
 It is recommended to create separate format instances for each thread.
 If multiple threads access a format concurrently it must be synchronized
 externally."
android,java.text,DateFormatSymbols,22,"DateFormatSymbols  is a public class for encapsulating
 localizable date-time formatting data such as the names of the
 months the names of the days of the week and the time zone data.
  SimpleDateFormat  uses
  DateFormatSymbols  to encapsulate this information.

  
 Typically you shouldn't use  DateFormatSymbols  directly.
 Rather you are encouraged to create a date-time formatter with the
  DateFormat  class's factory methods:  getTimeInstance 
  getDateInstance  or  getDateTimeInstance .
 These methods automatically create a  DateFormatSymbols  for
 the formatter so that you don't have to. After the
 formatter is created you may modify its format pattern using the
  setPattern  method. For more information about
 creating formatters using  DateFormat 's factory methods
 see  DateFormat .

  
 If you decide to create a date-time formatter with a specific
 format pattern for a specific locale you can do so with:
  
 new SimpleDateFormat(aPattern DateFormatSymbols.getInstance(aLocale)).
  DateFormatSymbols  objects are cloneable. When you obtain
 a  DateFormatSymbols  object feel free to modify the
 date-time formatting data. For instance you can replace the localized
 date-time format pattern characters with the ones that you feel easy
 to remember. Or you can change the representative cities
 to your favorite ones.

  
 New  DateFormatSymbols  subclasses may be added to support
  SimpleDateFormat  for date-time formatting for additional locales."
android,java.text,DecimalFormat,46,"DecimalFormat  is a concrete subclass of
  NumberFormat  that formats decimal numbers. It has a variety of
 features designed to make it possible to parse and format numbers in any
 locale including support for Western Arabic and Indic digits.  It also
 supports different kinds of numbers including integers (123) fixed-point
 numbers (123.4) scientific notation (1.23E4) percentages (12%) and
 currency amounts ($123).  All of these can be localized.

  To obtain a  NumberFormat  for a specific locale including the
 default locale call one of  NumberFormat 's factory methods such
 as  getInstance() .  In general do not call the
  DecimalFormat  constructors directly since the
  NumberFormat  factory methods may return subclasses other than
  DecimalFormat . If you need to customize the format object do
 something like this:

  
 NumberFormat f = NumberFormat.getInstance(loc);
 if (f instanceof DecimalFormat) {
     ((DecimalFormat) f).setDecimalSeparatorAlwaysShown(true);
 }
  A  DecimalFormat  comprises a  pattern  and a set of
  symbols .  The pattern may be set directly using
  applyPattern()  or indirectly using the API methods.  The
 symbols are stored in a  DecimalFormatSymbols  object.  When using
 the  NumberFormat  factory methods the pattern and symbols are
 read from localized  ResourceBundle s.

  Patterns DecimalFormat Pattern: PositivePattern PositivePattern  ;  NegativePattern PositivePattern: Prefix opt Number Suffix opt NegativePattern: Prefix opt Number Suffix opt Prefix: 
         any Unicode characters except \uFFFE \uFFFF and special characters
  Suffix: 
         any Unicode characters except \uFFFE \uFFFF and special characters
  Number: Integer Exponent opt Integer  .  Fraction Exponent opt Integer: MinimumInteger 
         #
         #  Integer 
         #   Integer MinimumInteger: 
         0
         0  MinimumInteger 
         0   MinimumInteger Fraction: MinimumFraction opt OptionalFraction opt MinimumFraction: 
         0  MinimumFraction opt OptionalFraction: 
         #  OptionalFraction opt Exponent: 
         E  MinimumExponent MinimumExponent: 
         0  MinimumExponent opt A  DecimalFormat  pattern contains a positive and negative
 subpattern for example  ""###0.00;(###0.00)"" .  Each
 subpattern has a prefix numeric part and suffix. The negative subpattern
 is optional; if absent then the positive subpattern prefixed with the
 localized minus sign ( '-'  in most locales) is used as the
 negative subpattern. That is  ""0.00""  alone is equivalent to
  ""0.00;-0.00"" .  If there is an explicit negative subpattern it
 serves only to specify the negative prefix and suffix; the number of digits
 minimal digits and other characteristics are all the same as the positive
 pattern. That means that  ""###0.0#;(#)""  produces precisely
 the same behavior as  ""###0.0#;(###0.0#)"" .

  The prefixes suffixes and various symbols used for infinity digits
 thousands separators decimal separators etc. may be set to arbitrary
 values and they will appear properly during formatting.  However care must
 be taken that the symbols and strings do not conflict or parsing will be
 unreliable.  For example either the positive and negative prefixes or the
 suffixes must be distinct for  DecimalFormat.parse()  to be able
 to distinguish positive from negative values.  (If they are identical then
  DecimalFormat  will behave as if no negative subpattern was
 specified.)  Another example is that the decimal separator and thousands
 separator should be distinct characters or parsing will be impossible.

  The grouping separator is commonly used for thousands but in some
 countries it separates ten-thousands. The grouping size is a constant number
 of digits between the grouping characters such as 3 for 100000000 or 4 for
 100000000.  If you supply a pattern with multiple grouping characters the
 interval between the last one and the end of the integer is the one that is
 used. So  ""##########""  ==  ""##########""  ==
  ""##########"" .

  Special Pattern Characters Many characters in a pattern are taken literally; they are matched during
 parsing and output unchanged during formatting.  Special characters on the
 other hand stand for other characters strings or classes of characters.
 They must be quoted unless noted otherwise if they are to appear in the
 prefix or suffix as literals.

  The characters listed here are used in non-localized patterns.  Localized
 patterns use the corresponding characters taken from this formatter's
  DecimalFormatSymbols  object instead and these characters lose
 their special status.  Two exceptions are the currency sign and quote which
 are not localized.

  Symbol
           Location
           Localized?
           Meaning
      0 Number
           Yes
           Digit
      # Number
           Yes
           Digit zero shows as absent
      . Number
           Yes
           Decimal separator or monetary decimal separator
      - Number
           Yes
           Minus sign
       Number
           Yes
           Grouping separator
      E Number
           Yes
           Separates mantissa and exponent in scientific notation.
               Need not be quoted in prefix or suffix. ; Subpattern boundary
           Yes
           Separates positive and negative subpatterns
      % Prefix or suffix
           Yes
           Multiply by 100 and show as percentage
      \u2030 Prefix or suffix
           Yes
           Multiply by 1000 and show as per mille value
      Â¤  ( \u00A4 )
           Prefix or suffix
           No
           Currency sign replaced by currency symbol.  If
              doubled replaced by international currency symbol.
              If present in a pattern the monetary decimal separator
              is used instead of the decimal separator.
      ' Prefix or suffix
           No
           Used to quote special characters in a prefix or suffix
              for example  ""'#'#""  formats 123 to
               ""#123"" .  To create a single quote
              itself use two in a row:  ""# o''clock"" .
  Scientific Notation Numbers in scientific notation are expressed as the product of a mantissa
 and a power of ten for example 1234 can be expressed as 1.234 x 10^3.  The
 mantissa is often in the range 1.0 â‰¤ x < 10.0 but it need not
 be.
  DecimalFormat  can be instructed to format and parse scientific
 notation  only via a pattern ; there is currently no factory method
 that creates a scientific notation format.  In a pattern the exponent
 character immediately followed by one or more digit characters indicates
 scientific notation.  Example:  ""0.###E0""  formats the number
 1234 as  ""1.234E3"" .

  The number of digit characters after the exponent character gives the
 minimum exponent digit count.  There is no maximum.  Negative exponents are
 formatted using the localized minus sign  not  the prefix and suffix
 from the pattern.  This allows patterns such as  ""0.###E0 m/s"" .

  The minimum and maximum number of integer digits are interpreted
 together:

  If the maximum number of integer digits is greater than their minimum number
 and greater than 1 it forces the exponent to be a multiple of the maximum
 number of integer digits and the minimum number of integer digits to be
 interpreted as 1.  The most common use of this is to generate
  engineering notation  in which the exponent is a multiple of three
 e.g.  ""##0.#####E0"" . Using this pattern the number 12345
 formats to  ""12.345E3""  and 123456 formats to
  ""123.456E3"" .

  Otherwise the minimum number of integer digits is achieved by adjusting the
 exponent.  Example: 0.00123 formatted with  ""00.###E0""  yields
  ""12.3E-4"" .
  The number of significant digits in the mantissa is the sum of the
  minimum integer  and  maximum fraction  digits and is
 unaffected by the maximum integer digits.  For example 12345 formatted with
  ""##0.##E0""  is  ""12.3E3"" . To show all digits set
 the significant digits count to zero.  The number of significant digits
 does not affect parsing.

  Exponential patterns may not contain grouping separators.
  Rounding DecimalFormat RoundingMode RoundingMode.HALF_EVEN Digits DecimalFormat DecimalFormatSymbols Character#digit Special Values NaN  is formatted as a string which typically has a single character
  \uFFFD .  This string is determined by the
  DecimalFormatSymbols  object.  This is the only value for which
 the prefixes and suffixes are not used.

  Infinity is formatted as a string which typically has a single character
  \u221E  with the positive or negative prefixes and suffixes
 applied.  The infinity string is determined by the
  DecimalFormatSymbols  object.

  Negative zero ( ""-0"" ) parses to
  BigDecimal(0)  if  isParseBigDecimal()  is
 true
  Long(0)  if  isParseBigDecimal()  is false
     and  isParseIntegerOnly()  is true
  Double(-0.0)  if both  isParseBigDecimal() 
 and  isParseIntegerOnly()  are false.
  Synchronization 
 Decimal formats are generally not synchronized.
 It is recommended to create separate format instances for each thread.
 If multiple threads access a format concurrently it must be synchronized
 externally.

  Example <strong>// Print out a number using the localized number integer currency
 // and percent format for each locale</strong>
 Locale[] locales = NumberFormat.getAvailableLocales();
 double myNumber = -1234.56;
 NumberFormat form;
 for (int j = 0; j < 4; ++j) {
     System.out.println(""FORMAT"");
     for (int i = 0; i < locales.length; ++i) {
         if (locales[i].getCountry().length() == 0) {
            continue; // Skip language-only locales
         }
         System.out.print(locales[i].getDisplayName());
         switch (j) {
         case 0:
             form = NumberFormat.getInstance(locales[i]); break;
         case 1:
             form = NumberFormat.getIntegerInstance(locales[i]); break;
         case 2:
             form = NumberFormat.getCurrencyInstance(locales[i]); break;
         default:
             form = NumberFormat.getPercentInstance(locales[i]); break;
         }
         if (form instanceof DecimalFormat) {
             System.out.print("": "" + ((DecimalFormat) form).toPattern());
         }
         System.out.print("" -> "" + form.format(myNumber));
         try {
             System.out.println("" -> "" + form.parse(form.format(myNumber)));
         } catch (ParseException e) {}
     }
 }"
android,java.text,DecimalFormatSymbols,36,"This class represents the set of symbols (such as the decimal separator
 the grouping separator and so on) needed by  DecimalFormat 
 to format numbers.  DecimalFormat  creates for itself an instance of
  DecimalFormatSymbols  from its locale data.  If you need to change any
 of these symbols you can get the  DecimalFormatSymbols  object from
 your  DecimalFormat  and modify it."
android,java.text,Format,6,"Format  is an abstract base class for formatting locale-sensitive
 information such as dates messages and numbers.

  Format  defines the programming interface for formatting
 locale-sensitive objects into  String s (the
  format  method) and for parsing  String s back
 into objects (the  parseObject  method).

  
 Generally a format's  parseObject  method must be able to parse
 any string formatted by its  format  method. However there may
 be exceptional cases where this is not possible. For example a
  format  method might create two adjacent integer numbers with
 no separator in between and in this case the  parseObject  could
 not tell which digits belong to which number.

  Subclassing 
 The Java Platform provides three specialized subclasses of  Format --
  DateFormat   MessageFormat  and
  NumberFormat --for formatting dates messages and numbers
 respectively.
  
 Concrete subclasses must implement three methods:
  format(Object obj StringBuffer toAppendTo FieldPosition pos) formatToCharacterIterator(Object obj) parseObject(String source ParsePosition pos) MessageFormat format parse parse ParsePosition ParseException 
 Most subclasses will also implement the following factory methods:
  getInstance  for getting a useful format object appropriate
 for the current locale
  getInstance(Locale)  for getting a useful format
 object appropriate for the specified locale
  getXxxxInstance NumberFormat getPercentInstance getCurrencyInstance 
 Subclasses of  Format  that allow programmers to create objects
 for locales (with  getInstance(Locale)  for example)
 must also implement the following class method:
  
 public static Locale[] getAvailableLocales()
  
 And finally subclasses may define a set of constants to identify the various
 fields in the formatted output. These constants are used to create a FieldPosition
 object which identifies what information is contained in the field and its
 position in the formatted result. These constants should be named
  item _FIELD  where  item  identifies
 the field. For examples of these constants see  ERA_FIELD  and its
 friends in  DateFormat .

  Synchronization 
 Formats are generally not synchronized.
 It is recommended to create separate format instances for each thread.
 If multiple threads access a format concurrently it must be synchronized
 externally."
android,java.text,MessageFormat,20,"MessageFormat  provides a means to produce concatenated
 messages in a language-neutral way. Use this to construct messages
 displayed for end users.

  MessageFormat  takes a set of objects formats them then
 inserts the formatted strings into the pattern at the appropriate places.

  Note: MessageFormat  differs from the other  Format 
 classes in that you create a  MessageFormat  object with one
 of its constructors (not with a  getInstance  style factory
 method). The factory methods aren't necessary because  MessageFormat 
 itself doesn't implement locale specific behavior. Any locale specific
 behavior is defined by the pattern that you provide as well as the
 subformats used for inserted arguments.

  Patterns and Their Interpretation MessageFormat MessageFormatPattern: String MessageFormatPattern FormatElement String FormatElement: 
         {  ArgumentIndex  }
         {  ArgumentIndex    FormatType  }
         {  ArgumentIndex    FormatType    FormatStyle  }

  FormatType: one of  
         number date time choice

  FormatStyle: 
         short
         medium
         long
         full
         integer
         currency
         percent
          SubformatPattern Within a  String  a pair of single quotes can be used to
 quote any arbitrary characters except single quotes. For example
 pattern string  ""'{0}'""  represents string
  ""{0}""  not a  FormatElement . A single quote itself
 must be represented by doubled single quotes  ''  throughout a
  String .  For example pattern string  ""'{''}'""  is
 interpreted as a sequence of  '{  (start of quoting and a
 left curly brace)  ''  (a single quote) and
  }'  (a right curly brace and end of quoting)
  not '{'  and  '}'  (quoted left and
 right curly braces): representing string  ""{'}"" 
  not ""{}"" .

  A  SubformatPattern  is interpreted by its corresponding
 subformat and subformat-dependent pattern rules apply. For example
 pattern string  ""{1number $'#'## }"" 
 ( SubformatPattern  with underline) will produce a number format
 with the pound-sign quoted with a result such as:  ""$#3145"" . Refer to each  Format  subclass documentation for
 details.

  Any unmatched quote is treated as closed at the end of the given
 pattern. For example pattern string  ""'{0}""  is treated as
 pattern  ""'{0}'"" .

  Any curly braces within an unquoted pattern must be balanced. For
 example  ""ab {0} de""  and  ""ab '}' de""  are
 valid patterns but  ""ab {0'}' de""   ""ab } de"" 
 and  ""''{''""  are not.

  Warning: The rules for using quotes within message
 format patterns unfortunately have shown to be somewhat confusing.
 In particular it isn't always obvious to localizers whether single
 quotes need to be doubled or not. Make sure to inform localizers about
 the rules and tell them (for example by using comments in resource
 bundle source files) which strings will be processed by  MessageFormat .
 Note that localizers may need to use single quotes in translated
 strings where the original version doesn't have them.
  
 The  ArgumentIndex  value is a non-negative integer written
 using the digits  '0'  through  '9'  and represents an index into the
  arguments  array passed to the  format  methods
 or the result array returned by the  parse  methods.
  
 The  FormatType  and  FormatStyle  values are used to create
 a  Format  instance for the format element. The following
 table shows how the values map to  Format  instances. Combinations not
 shown in the table are illegal. A  SubformatPattern  must
 be a valid pattern string for the  Format  subclass used.

  FormatType
        FormatStyle
        Subformat Created
     (none) (none) null number (none) NumberFormat#getInstance(Locale) (getLocale()) integer NumberFormat#getIntegerInstance(Locale) (getLocale()) currency NumberFormat#getCurrencyInstance(Locale) (getLocale()) percent NumberFormat#getPercentInstance(Locale) (getLocale()) SubformatPattern new DecimalFormat#DecimalFormat(StringDecimalFormatSymbols) (subformatPattern DecimalFormatSymbols#getInstance(Locale) (getLocale())) date (none) DateFormat#getDateInstance(intLocale) ( DateFormat#DEFAULT  getLocale()) short DateFormat#getDateInstance(intLocale) ( DateFormat#SHORT  getLocale()) medium DateFormat#getDateInstance(intLocale) ( DateFormat#DEFAULT  getLocale()) long DateFormat#getDateInstance(intLocale) ( DateFormat#LONG  getLocale()) full DateFormat#getDateInstance(intLocale) ( DateFormat#FULL  getLocale()) SubformatPattern new SimpleDateFormat#SimpleDateFormat(StringLocale) (subformatPattern getLocale()) time (none) DateFormat#getTimeInstance(intLocale) ( DateFormat#DEFAULT  getLocale()) short DateFormat#getTimeInstance(intLocale) ( DateFormat#SHORT  getLocale()) medium DateFormat#getTimeInstance(intLocale) ( DateFormat#DEFAULT  getLocale()) long DateFormat#getTimeInstance(intLocale) ( DateFormat#LONG  getLocale()) full DateFormat#getTimeInstance(intLocale) ( DateFormat#FULL  getLocale()) SubformatPattern new SimpleDateFormat#SimpleDateFormat(StringLocale) (subformatPattern getLocale()) choice SubformatPattern new ChoiceFormat#ChoiceFormat(String) (subformatPattern) Usage Information 
 Here are some examples of usage.
 In real internationalized programs the message format pattern and other
 static strings will of course be obtained from resource bundles.
 Other parameters will be dynamically determined at runtime.
  
 The first example uses the static method  MessageFormat.format 
 which internally creates a  MessageFormat  for one-time use:
  
 int planet = 7;
 String event = ""a disturbance in the Force"";

 String result = MessageFormat.format(
     ""At {1time} on {1date} there was {2} on planet {0numberinteger}.""
     planet new Date() event);
  
 At 12:30 PM on Jul 3 2053 there was a disturbance in the Force on planet 7.
  
 The following example creates a  MessageFormat  instance that
 can be used repeatedly:
  
 int fileCount = 1273;
 String diskName = ""MyDisk"";
 Object[] testArgs = {new Long(fileCount) diskName};

 MessageFormat form = new MessageFormat(
     ""The disk \""{1}\"" contains {0} file(s)."");

 System.out.println(form.format(testArgs));
  fileCount 
 The disk ""MyDisk"" contains 0 file(s).
 The disk ""MyDisk"" contains 1 file(s).
 The disk ""MyDisk"" contains 1273 file(s).
  
 For more sophisticated patterns you can use a  ChoiceFormat 
 to produce correct forms for singular and plural:
  
 MessageFormat form = new MessageFormat(""The disk \""{1}\"" contains {0}."");
 double[] filelimits = {012};
 String[] filepart = {""no files""""one file""""{0number} files""};
 ChoiceFormat fileform = new ChoiceFormat(filelimits filepart);
 form.setFormatByArgumentIndex(0 fileform);

 int fileCount = 1273;
 String diskName = ""MyDisk"";
 Object[] testArgs = {new Long(fileCount) diskName};

 System.out.println(form.format(testArgs));
  fileCount 
 The disk ""MyDisk"" contains no files.
 The disk ""MyDisk"" contains one file.
 The disk ""MyDisk"" contains 1273 files.
  
 You can create the  ChoiceFormat  programmatically as in the
 above example or by using a pattern. See  ChoiceFormat 
 for more information.
  form.applyPattern(
    ""There {0choice0#are no files|1#is one file|1<are {0numberinteger} files}."");
  Note:  As we see above the string produced
 by a  ChoiceFormat  in  MessageFormat  is treated as special;
 occurrences of '{' are used to indicate subformats and cause recursion.
 If you create both a  MessageFormat  and  ChoiceFormat 
 programmatically (instead of using the string patterns) then be careful not to
 produce a format that recurses on itself which will cause an infinite loop.
  
 When a single argument is parsed more than once in the string the last match
 will be the final result of the parsing.  For example
  
 MessageFormat mf = new MessageFormat(""{0number#.##} {0number#.#}"");
 Object[] objs = {new Double(3.1415)};
 String result = mf.format( objs );
 // result now equals ""3.14 3.1""
 objs = null;
 objs = mf.parse(result new ParsePosition(0));
 // objs now equals {new Double(3.1)}
  
 Likewise parsing with a  MessageFormat  object using patterns containing
 multiple occurrences of the same argument would return the last match.  For
 example
  
 MessageFormat mf = new MessageFormat(""{0} {0} {0}"");
 String forParsing = ""x y z"";
 Object[] objs = mf.parse(forParsing new ParsePosition(0));
 // result now equals {new String(""z"")}
  Synchronization 
 Message formats are not synchronized.
 It is recommended to create separate format instances for each thread.
 If multiple threads access a format concurrently it must be synchronized
 externally."
android,java.text,MessageFormat.Field,0,"Defines constants that are used as attribute keys in the
  AttributedCharacterIterator  returned
 from  MessageFormat.formatToCharacterIterator ."
android,java.text,Normalizer,2,"This class provides the method  normalize  which transforms Unicode
 text into an equivalent composed or decomposed form allowing for easier
 sorting and searching of text.
 The  normalize  method supports the standard normalization forms
 described in
  
 Unicode Standard Annex #15 â€” Unicode Normalization Forms .
  
 Characters with accents or other adornments can be encoded in
 several different ways in Unicode.  For example take the character A-acute.
 In Unicode this can be encoded as a single character (the ""composed"" form):

  
      U+00C1    LATIN CAPITAL LETTER A WITH ACUTE 
      U+0041    LATIN CAPITAL LETTER A
      U+0301    COMBINING ACUTE ACCENT 
 Similarly the string ""ffi"" can be encoded as three separate letters:

  
      U+0066    LATIN SMALL LETTER F
      U+0066    LATIN SMALL LETTER F
      U+0069    LATIN SMALL LETTER I 
      U+FB03    LATIN SMALL LIGATURE FFI 
 The  normalize  method helps solve these problems by transforming
 text into the canonical composed and decomposed forms as shown in the first
 example above. In addition you can have it perform compatibility
 decompositions so that you can treat compatibility characters the same as
 their equivalents.
 Finally the  normalize  method rearranges accents into the
 proper canonical order so that you do not have to worry about accent
 rearrangement on your own.
  
 The W3C generally recommends to exchange texts in NFC.
 Note also that most legacy character encodings use only precomposed forms and
 often do not encode any combining marks by themselves. For conversion to such
 character encodings the Unicode text needs to be normalized to NFC.
 For more usage examples see the Unicode Standard Annex."
android,java.text,NumberFormat.Field,0,"Defines constants that are used as attribute keys in the
  AttributedCharacterIterator  returned
 from  NumberFormat.formatToCharacterIterator  and as
 field identifiers in  FieldPosition ."
android,java.text,ParsePosition,7,"ParsePosition  is a simple class used by  Format 
 and its subclasses to keep track of the current position during parsing.
 The  parseObject  method in the various  Format 
 classes requires a  ParsePosition  object as an argument.

  
 By design as you parse through a string with different formats
 you can use the same  ParsePosition  since the index parameter
 records the current position."
android,java.text,RuleBasedCollator,8,"The  RuleBasedCollator  class is a concrete subclass of
  Collator  that provides a simple data-driven table
 collator.  With this class you can create a customized table-based
  Collator .   RuleBasedCollator  maps
 characters to sort keys.

  RuleBasedCollator  has the following restrictions
 for efficiency (other subclasses may be used for more complex languages) :
  If a special collation rule controlled by a <modifier> is
     specified it applies to the whole collator object.
  All non-mentioned characters are at the end of the
     collation order.
  
 The collation table is composed of a list of collation rules where each
 rule is of one of three forms:
  
    <modifier>
    <relation> <text-argument>
    <reset> <text-argument>
  Text-Argument : A text-argument is any sequence of
        characters excluding special characters (that is common
        whitespace characters [0009-000D 0020] and rule syntax characters
        [0021-002F 003A-0040 005B-0060 007B-007E]). If those
        characters are desired you can put them in single quotes
        (e.g. ampersand => '&'). Note that unquoted white space characters
        are ignored; e.g.  b c  is treated as  bc .
     Modifier : There are currently two modifiers that
        turn on special collation rules.
         '@' : Turns on backwards sorting of accents (secondary
                      differences) as in French.
             '!' : Turns on Thai/Lao vowel-consonant swapping.  If this
                      rule is in force when a Thai vowel of the range
                      \U0E40-\U0E44 precedes a Thai consonant of the range
                      \U0E01-\U0E2E OR a Lao vowel of the range \U0EC0-\U0EC4
                      precedes a Lao consonant of the range \U0E81-\U0EAE then
                      the vowel is placed after the consonant for collation
                      purposes.
         '@' : Indicates that accents are sorted backwards as in French.
     Relation : The relations are the following:
         '<' : Greater as a letter difference (primary)
             ';' : Greater as an accent difference (secondary)
             '' : Greater as a case difference (tertiary)
             '=' : Equal
         Reset : There is a single reset
        which is used primarily for contractions and expansions but which
        can also be used to add a modification at the end of a set of rules.
         '&' : Indicates that the next rule follows the position to where
            the reset text-argument would be sorted.
  
 This sounds more complicated than it is in practice. For example the
 following are equivalent ways of expressing the same thing:
  
 a < b < c
 a < b & b < c
 a < c & a < b
  
 a < b & a < c
 a < c & a < b
  Ignorable Characters 
 For ignorable characters the first rule must start with a relation (the
 examples we have used above are really fragments; ""a < b"" really should be
 ""< a < b""). If however the first relation is not ""<"" then all the all
 text-arguments up to the first ""<"" are ignorable. For example "" - < a < b""
 makes ""-"" an ignorable character as we saw earlier in the word
 ""black-birds"". In the samples for different languages you see that most
 accents are ignorable.

  Normalization and Accents RuleBasedCollator  automatically processes its rule table to
 include both pre-composed and combining-character versions of
 accented characters.  Even if the provided rule string contains only
 base characters and separate combining accent characters the pre-composed
 accented characters matching all canonical combinations of characters from
 the rule string will be entered in the table.
  
 This allows you to use a RuleBasedCollator to compare accented strings
 even when the collator is set to NO_DECOMPOSITION.  There are two caveats
 however.  First if the strings to be collated contain combining
 sequences that may not be in canonical order you should set the collator to
 CANONICAL_DECOMPOSITION or FULL_DECOMPOSITION to enable sorting of
 combining sequences.  Second if the strings contain characters with
 compatibility decompositions (such as full-width and half-width forms)
 you must use FULL_DECOMPOSITION since the rule tables only include
 canonical mappings.

  Errors 
 The following are errors:
  A text-argument contains unquoted punctuation symbols
        (e.g. ""a < b-c < d"").
      A relation or reset character not followed by a text-argument
        (e.g. ""a < b"").
      A reset where the text-argument (or an initial substring of the
         text-argument) is not already in the sequence.
         (e.g. ""a < b & e < f"")
  RuleBasedCollator ParseException Examples Simple:     ""< a < b < c < d""
  Norwegian:  ""< a A < b B < c C < d D < e E < f F
                 < g G < h H < i I < j J < k K < l L
                 < m M < n N < o O < p P < q Q < r R
                 < s S < t T < u U < v V < w W < x X
                 < y Y < z Z
                 < \u00E6 \u00C6
                 < \u00F8 \u00D8
                 < \u00E5 = a\u030A \u00C5 = A\u030A;
                      aa AA""

  
 To create a  RuleBasedCollator  object with specialized
 rules tailored to your needs you construct the  RuleBasedCollator 
 with the rules contained in a  String  object. For example:
  
 String simple = ""< a< b< c< d"";
 RuleBasedCollator mySimple = new RuleBasedCollator(simple);
  
 String Norwegian = ""< a A < b B < c C < d D < e E < f F < g G < h H < i I"" +
                    ""< j J < k K < l L < m M < n N < o O < p P < q Q < r R"" +
                    ""< s S < t T < u U < v V < w W < x X < y Y < z Z"" +
                    ""< \u00E6 \u00C6"" +     // Latin letter ae & AE
                    ""< \u00F8 \u00D8"" +     // Latin letter o & O with stroke
                    ""< \u00E5 = a\u030A"" +  // Latin letter a with ring above
                    ""  \u00C5 = A\u030A;"" +  // Latin letter A with ring above
                    ""  aa AA"";
 RuleBasedCollator myNorwegian = new RuleBasedCollator(Norwegian);
  
 A new collation rules string can be created by concatenating rules
 strings. For example the rules returned by  getRules()  could
 be concatenated to combine multiple  RuleBasedCollator s.

  
 The following example demonstrates how to change the order of
 non-spacing accents
  
 // old rule
 String oldRules = ""=\u0301;\u0300;\u0302;\u0308""    // main accents
                 + "";\u0327;\u0303;\u0304;\u0305""    // main accents
                 + "";\u0306;\u0307;\u0309;\u030A""    // main accents
                 + "";\u030B;\u030C;\u030D;\u030E""    // main accents
                 + "";\u030F;\u0310;\u0311;\u0312""    // main accents
                 + ""< a  A ; ae AE ; \u00e6  \u00c6""
                 + ""< b  B < c C < e E & C < d D"";
 // change the order of accent characters
 String addOn = ""& \u0300 ; \u0308 ; \u0302"";
 RuleBasedCollator myCollator = new RuleBasedCollator(oldRules + addOn);"
android,java.text,StringCharacterIterator,13,"StringCharacterIterator  implements the
  CharacterIterator  protocol for a  String .
 The  StringCharacterIterator  class iterates over the
 entire  String ."
android,java.time.temporal,IsoFields,0,"Fields and units specific to the ISO-8601 calendar system
 including quarter-of-year and week-based-year.
  
 This class defines fields and units that are specific to the ISO calendar system.

  Quarter of year 
 January February and March are in Q1.
 April May and June are in Q2.
 July August and September are in Q3.
 October November and December are in Q4.
  
 The complete date is expressed using three fields:
  DAY_OF_QUARTER  - the day within the quarter from 1 to 90 91 or 92
  QUARTER_OF_YEAR  - the week within the week-based-year
  ChronoField#YEAR  - the standard ISO year
  Week based years 
 The date is expressed using three fields:
  ChronoField#DAY_OF_WEEK  - the standard field defining the
  day-of-week from Monday (1) to Sunday (7)
  WEEK_OF_WEEK_BASED_YEAR  - the week within the week-based-year
  WEEK_BASED_YEAR  - the week-based-year
  
 The first week of a week-based-year is the first Monday-based week of the standard
 ISO year that has at least 4 days in the new year.
  If January 1st is Monday then week 1 starts on January 1st
  If January 1st is Tuesday then week 1 starts on December 31st of the previous standard year
  If January 1st is Wednesday then week 1 starts on December 30th of the previous standard year
  If January 1st is Thursday then week 1 starts on December 29th of the previous standard year
  If January 1st is Friday then week 1 starts on January 4th
  If January 1st is Saturday then week 1 starts on January 3rd
  If January 1st is Sunday then week 1 starts on January 2nd
  
 For example:

  Examples of Week based Years Date Day-of-week Field values 2008-12-28 Sunday Week 52 of week-based-year 2008 2008-12-29 Monday Week 1 of week-based-year 2009 2008-12-31 Wednesday Week 1 of week-based-year 2009 2009-01-01 Thursday Week 1 of week-based-year 2009 2009-01-04 Sunday Week 1 of week-based-year 2009 2009-01-05 Monday Week 2 of week-based-year 2009"
android,java.time.temporal,JulianFields,0,"A set of date fields that provide access to Julian Days.
  
 The Julian Day is a standard way of expressing date and time commonly used in the scientific community.
 It is expressed as a decimal number of whole days where days start at midday.
 This class represents variations on Julian Days that count whole days from midnight.
  
 The fields are implemented relative to  ChronoField#EPOCH_DAY .
 The fields are supported and can be queried and set if  EPOCH_DAY  is available.
 The fields work with all chronologies."
android,java.time.temporal,TemporalAdjusters,14,"Common and useful TemporalAdjusters.
  
 Adjusters are a key tool for modifying temporal objects.
 They exist to externalize the process of adjustment permitting different
 approaches as per the strategy design pattern.
 Examples might be an adjuster that sets the date avoiding weekends or one that
 sets the date to the last day of the month.
  
 There are two equivalent ways of using a  TemporalAdjuster .
 The first is to invoke the method on the interface directly.
 The second is to use  Temporal#with(TemporalAdjuster) :
  
   // these two lines are equivalent but the second approach is recommended
   temporal = thisAdjuster.adjustInto(temporal);
   temporal = temporal.with(thisAdjuster);
  with(TemporalAdjuster) 
 This class contains a standard set of adjusters available as static methods.
 These include:
  finding the first or last day of the month
  finding the first day of next month
  finding the first or last day of the year
  finding the first day of next year
  finding the first or last day-of-week within a month such as ""first Wednesday in June""
  finding the next or previous day-of-week such as ""next Thursday"""
android,java.time.temporal,TemporalQueries,7,"Common implementations of  TemporalQuery .
  
 This class provides common implementations of  TemporalQuery .
 These are defined here as they must be constants and the definition
 of lambdas does not guarantee that. By assigning them once here
 they become 'normal' Java constants.
  
 Queries are a key tool for extracting information from temporal objects.
 They exist to externalize the process of querying permitting different
 approaches as per the strategy design pattern.
 Examples might be a query that checks if the date is the day before February 29th
 in a leap year or calculates the number of days to your next birthday.
  
 The  TemporalField  interface provides another mechanism for querying
 temporal objects. That interface is limited to returning a  long .
 By contrast queries can return any type.
  
 There are two equivalent ways of using a  TemporalQuery .
 The first is to invoke the method on this interface directly.
 The second is to use  TemporalAccessor#query(TemporalQuery) :
  
   // these two lines are equivalent but the second approach is recommended
   temporal = thisQuery.queryFrom(temporal);
   temporal = temporal.query(thisQuery);
  query(TemporalQuery) 
 The most common implementations are method references such as
  LocalDate::from  and  ZoneId::from .
 Additional common queries are provided to return:
   a Chronology
   a LocalDate
   a LocalTime
   a ZoneOffset
   a precision
   a zone or
   a zoneId."
android,java.time.temporal,ValueRange,16,"The range of valid values for a date-time field.
  
 All  TemporalField  instances have a valid range of values.
 For example the ISO day-of-month runs from 1 to somewhere between 28 and 31.
 This class captures that valid range.
  
 It is important to be aware of the limitations of this class.
 Only the minimum and maximum values are provided.
 It is possible for there to be invalid values within the outer range.
 For example a weird field may have valid values of 1 2 4 6 7 thus
 have a range of '1 - 7' despite that fact that values 3 and 5 are invalid.
  
 Instances of this class are not tied to a specific field."
android,java.time.temporal,WeekFields,12,"Localized definitions of the day-of-week week-of-month and week-of-year fields.
  
 A standard week is seven days long but cultures have different definitions for some
 other aspects of a week. This class represents the definition of the week for the
 purpose of providing  TemporalField  instances.
  
 WeekFields provides five fields
  dayOfWeek()   weekOfMonth()   weekOfYear() 
  weekOfWeekBasedYear()  and  weekBasedYear() 
 that provide access to the values from any  Temporal .
  
 The computations for day-of-week week-of-month and week-of-year are based
 on the   ChronoField#YEAR 
  ChronoField#MONTH_OF_YEAR 
  ChronoField#DAY_OF_MONTH  and
  ChronoField#DAY_OF_WEEK  which are based on the
  ChronoField#EPOCH_DAY  and the chronology.
 The values may not be aligned with the  ChronoField#YEAR_OF_ERA 
 depending on the Chronology.
  A week is defined by:
  The first day-of-week.
 For example the ISO-8601 standard considers Monday to be the first day-of-week.
  The minimal number of days in the first week.
 For example the ISO-8601 standard counts the first week as needing at least 4 days.
  Week of Month Examples of WeekFields Date Day-of-week First day: Monday Minimal days: 4 First day: Monday Minimal days: 5 2008-12-31 Wednesday Week 5 of December 2008 Week 5 of December 2008 2009-01-01 Thursday Week 1 of January 2009 Week 0 of January 2009 2009-01-04 Sunday Week 1 of January 2009 Week 0 of January 2009 2009-01-05 Monday Week 2 of January 2009 Week 1 of January 2009 Week of Year Week Based Year week-of-week-based-year week-based-year Examples of WeekFields for week-based-year Date Day-of-week First day: Monday Minimal days: 4 First day: Monday Minimal days: 5 2008-12-31 Wednesday Week 1 of 2009 Week 53 of 2008 2009-01-01 Thursday Week 1 of 2009 Week 53 of 2008 2009-01-04 Sunday Week 1 of 2009 Week 53 of 2008 2009-01-05 Monday Week 2 of 2009 Week 1 of 2009"
android,java.time.zone,ZoneOffsetTransition,15,"A transition between two offsets caused by a discontinuity in the local time-line.
  
 A transition between two offsets is normally the result of a daylight savings cutover.
 The discontinuity is normally a gap in spring and an overlap in autumn.
  ZoneOffsetTransition  models the transition between the two offsets.
  
 Gaps occur where there are local date-times that simply do not exist.
 An example would be when the offset changes from  +03:00  to  +04:00 .
 This might be described as 'the clocks will move forward one hour tonight at 1am'.
  
 Overlaps occur where there are local date-times that exist twice.
 An example would be when the offset changes from  +04:00  to  +03:00 .
 This might be described as 'the clocks will move back one hour tonight at 2am'."
android,java.time.zone,ZoneOffsetTransitionRule,14,"A rule expressing how to create a transition.
  
 This class allows rules for identifying future transitions to be expressed.
 A rule might be written in many forms:
  the 16th March
  the Sunday on or after the 16th March
  the Sunday on or before the 16th March
  the last Sunday in February"
android,java.time.zone,ZoneRules,18,"The rules defining how the zone offset varies for a single time-zone.
  
 The rules model all the historic and future transitions for a time-zone.
  ZoneOffsetTransition  is used for known transitions typically historic.
  ZoneOffsetTransitionRule  is used for future transitions that are based
 on the result of an algorithm.
  
 The same rules may be shared internally between multiple zone IDs.
  
 Serializing an instance of  ZoneRules  will store the entire set of rules.
 It does not store the zone ID as it is not part of the state of this object.
  
 A rule implementation may or may not store full information about historic
 and future transitions and the information stored is only as accurate as
 that supplied to the implementation by the rules provider.
 Applications should treat the data provided as representing the best information
 available to the implementation of this rule."
android,java.util.concurrent.locks,AbstractOwnableSynchronizer,0,"A synchronizer that may be exclusively owned by a thread.  This
 class provides a basis for creating locks and related synchronizers
 that may entail a notion of ownership.  The
  AbstractOwnableSynchronizer  class itself does not manage or
 use this information. However subclasses and tools may use
 appropriately maintained values to help control and monitor access
 and provide diagnostics."
android,java.util.concurrent.locks,AbstractQueuedLongSynchronizer,30,"A version of  AbstractQueuedSynchronizer  in
 which synchronization state is maintained as a  long .
 This class has exactly the same structure properties and methods
 as  AbstractQueuedSynchronizer  with the exception
 that all state-related parameters and results are defined
 as  long  rather than  int . This class
 may be useful when creating synchronizers such as
 multilevel locks and barriers that require
 64 bits of state.

  See  AbstractQueuedSynchronizer  for usage
 notes and examples."
android,java.util.concurrent.locks,AbstractQueuedLongSynchronizer.ConditionObject,10,"Condition implementation for a  AbstractQueuedLongSynchronizer  serving as the basis of a  Lock  implementation.

  Method documentation for this class describes mechanics
 not behavioral specifications from the point of view of Lock
 and Condition users. Exported versions of this class will in
 general need to be accompanied by documentation describing
 condition semantics that rely on those of the associated
  AbstractQueuedLongSynchronizer .

  This class is Serializable but all fields are transient
 so deserialized conditions have no waiters."
android,java.util.concurrent.locks,AbstractQueuedSynchronizer,30,"Provides a framework for implementing blocking locks and related
 synchronizers (semaphores events etc) that rely on
 first-in-first-out (FIFO) wait queues.  This class is designed to
 be a useful basis for most kinds of synchronizers that rely on a
 single atomic  int  value to represent state. Subclasses
 must define the protected methods that change this state and which
 define what that state means in terms of this object being acquired
 or released.  Given these the other methods in this class carry
 out all queuing and blocking mechanics. Subclasses can maintain
 other state fields but only the atomically updated  int 
 value manipulated using methods  getState()   setState(int)  and  compareAndSetState(int int)  is tracked with respect
 to synchronization.

  Subclasses should be defined as non-public internal helper
 classes that are used to implement the synchronization properties
 of their enclosing class.  Class
  AbstractQueuedSynchronizer  does not implement any
 synchronization interface.  Instead it defines methods such as
  acquireInterruptibly(int)  that can be invoked as
 appropriate by concrete locks and related synchronizers to
 implement their public methods.

  This class supports either or both a default  exclusive 
 mode and a  shared  mode. When acquired in exclusive mode
 attempted acquires by other threads cannot succeed. Shared mode
 acquires by multiple threads may (but need not) succeed. This class
 does not ""understand"" these differences except in the
 mechanical sense that when a shared mode acquire succeeds the next
 waiting thread (if one exists) must also determine whether it can
 acquire as well. Threads waiting in the different modes share the
 same FIFO queue. Usually implementation subclasses support only
 one of these modes but both can come into play for example in a
  ReadWriteLock . Subclasses that support only exclusive or
 only shared modes need not define the methods supporting the unused mode.

  This class defines a nested  ConditionObject  class that
 can be used as a  Condition  implementation by subclasses
 supporting exclusive mode for which method  isHeldExclusively()  reports whether synchronization is exclusively
 held with respect to the current thread method  release(int) 
 invoked with the current  getState()  value fully releases
 this object and  acquire(int)  given this saved state value
 eventually restores this object to its previous acquired state.  No
  AbstractQueuedSynchronizer  method otherwise creates such a
 condition so if this constraint cannot be met do not use it.  The
 behavior of  ConditionObject  depends of course on the
 semantics of its synchronizer implementation.

  This class provides inspection instrumentation and monitoring
 methods for the internal queue as well as similar methods for
 condition objects. These can be exported as desired into classes
 using an  AbstractQueuedSynchronizer  for their
 synchronization mechanics.

  Serialization of this class stores only the underlying atomic
 integer maintaining state so deserialized objects have empty
 thread queues. Typical subclasses requiring serializability will
 define a  readObject  method that restores this to a known
 initial state upon deserialization.

  Usage To use this class as the basis of a synchronizer redefine the
 following methods as applicable by inspecting and/or modifying
 the synchronization state using  getState()   setState(int)  and/or  compareAndSetState(int int) :

  tryAcquire(int) tryRelease(int) tryAcquireShared(int) tryReleaseShared(int) isHeldExclusively() UnsupportedOperationException only final You may also find the inherited methods from  AbstractOwnableSynchronizer  useful to keep track of the thread
 owning an exclusive synchronizer.  You are encouraged to use them
 -- this enables monitoring and diagnostic tools to assist users in
 determining which threads hold locks.

  Even though this class is based on an internal FIFO queue it
 does not automatically enforce FIFO acquisition policies.  The core
 of exclusive synchronization takes the form:

  
 Acquire:
     while (!tryAcquire(arg)) {
         enqueue thread if it is not already queued ;
         possibly block current thread ;
     }

 Release:
     if (tryRelease(arg))
         unblock the first queued thread ;
  Because checks in acquire are invoked before
 enqueuing a newly acquiring thread may  barge  ahead of
 others that are blocked and queued.  However you can if desired
 define  tryAcquire  and/or  tryAcquireShared  to
 disable barging by internally invoking one or more of the inspection
 methods thereby providing a  fair  FIFO acquisition order.
 In particular most fair synchronizers can define  tryAcquire 
 to return  false  if  hasQueuedPredecessors()  (a method
 specifically designed to be used by fair synchronizers) returns
  true .  Other variations are possible.

  Throughput and scalability are generally highest for the
 default barging (also known as  greedy 
  renouncement  and  convoy-avoidance ) strategy.
 While this is not guaranteed to be fair or starvation-free earlier
 queued threads are allowed to recontend before later queued
 threads and each recontention has an unbiased chance to succeed
 against incoming threads.  Also while acquires do not
 ""spin"" in the usual sense they may perform multiple
 invocations of  tryAcquire  interspersed with other
 computations before blocking.  This gives most of the benefits of
 spins when exclusive synchronization is only briefly held without
 most of the liabilities when it isn't. If so desired you can
 augment this by preceding calls to acquire methods with
 ""fast-path"" checks possibly prechecking  hasContended() 
 and/or  hasQueuedThreads()  to only do so if the synchronizer
 is likely not to be contended.

  This class provides an efficient and scalable basis for
 synchronization in part by specializing its range of use to
 synchronizers that can rely on  int  state acquire and
 release parameters and an internal FIFO wait queue. When this does
 not suffice you can build synchronizers from a lower level using
  atomic  classes your own custom
  Queue  classes and  LockSupport  blocking
 support.

  Usage Examples Here is a non-reentrant mutual exclusion lock class that uses
 the value zero to represent the unlocked state and one to
 represent the locked state. While a non-reentrant lock
 does not strictly require recording of the current owner
 thread this class does so anyway to make usage easier to monitor.
 It also supports conditions and exposes
 one of the instrumentation methods:

  class Mutex implements Lock java.io.Serializable {

   // Our internal helper class
   private static class Sync extends AbstractQueuedSynchronizer {
     // Reports whether in locked state
     protected boolean isHeldExclusively() {
       return getState() == 1;
     }

     // Acquires the lock if state is zero
     public boolean tryAcquire(int acquires) {
       assert acquires == 1; // Otherwise unused
       if (compareAndSetState(0 1)) {
         setExclusiveOwnerThread(Thread.currentThread());
         return true;
       }
       return false;
     }

     // Releases the lock by setting state to zero
     protected boolean tryRelease(int releases) {
       assert releases == 1; // Otherwise unused
       if (getState() == 0) throw new IllegalMonitorStateException();
       setExclusiveOwnerThread(null);
       setState(0);
       return true;
     }

     // Provides a Condition
     Condition newCondition() { return new ConditionObject(); }

     // Deserializes properly
     private void readObject(ObjectInputStream s)
         throws IOException ClassNotFoundException {
       s.defaultReadObject();
       setState(0); // reset to unlocked state
     }
   }

   // The sync object does all the hard work. We just forward to it.
   private final Sync sync = new Sync();

   public void lock()                { sync.acquire(1); }
   public boolean tryLock()          { return sync.tryAcquire(1); }
   public void unlock()              { sync.release(1); }
   public Condition newCondition()   { return sync.newCondition(); }
   public boolean isLocked()         { return sync.isHeldExclusively(); }
   public boolean hasQueuedThreads() { return sync.hasQueuedThreads(); }
   public void lockInterruptibly() throws InterruptedException {
     sync.acquireInterruptibly(1);
   }
   public boolean tryLock(long timeout TimeUnit unit)
       throws InterruptedException {
     return sync.tryAcquireNanos(1 unit.toNanos(timeout));
   }
 } Here is a latch class that is like a
  CountDownLatch 
 except that it only requires a single  signal  to
 fire. Because a latch is non-exclusive it uses the  shared 
 acquire and release methods.

  class BooleanLatch {

   private static class Sync extends AbstractQueuedSynchronizer {
     boolean isSignalled() { return getState() != 0; }

     protected int tryAcquireShared(int ignore) {
       return isSignalled() ? 1 : -1;
     }

     protected boolean tryReleaseShared(int ignore) {
       setState(1);
       return true;
     }
   }

   private final Sync sync = new Sync();
   public boolean isSignalled() { return sync.isSignalled(); }
   public void signal()         { sync.releaseShared(1); }
   public void await() throws InterruptedException {
     sync.acquireSharedInterruptibly(1);
   }
 }"
android,java.util.concurrent.locks,AbstractQueuedSynchronizer.ConditionObject,10,"Condition implementation for a  AbstractQueuedSynchronizer  serving as the basis of a  Lock  implementation.

  Method documentation for this class describes mechanics
 not behavioral specifications from the point of view of Lock
 and Condition users. Exported versions of this class will in
 general need to be accompanied by documentation describing
 condition semantics that rely on those of the associated
  AbstractQueuedSynchronizer .

  This class is Serializable but all fields are transient
 so deserialized conditions have no waiters."
android,java.util.concurrent.locks,LockSupport,8,"Basic thread blocking primitives for creating locks and other
 synchronization classes.

  This class associates with each thread that uses it a permit
 (in the sense of the  Semaphore  class). A call to  park  will return immediately
 if the permit is available consuming it in the process; otherwise
 it  may  block.  A call to  unpark  makes the permit
 available if it was not already available. (Unlike with Semaphores
 though permits do not accumulate. There is at most one.)
 Reliable usage requires the use of volatile (or atomic) variables
 to control when to park or unpark.  Orderings of calls to these
 methods are maintained with respect to volatile variable accesses
 but not necessarily non-volatile variable accesses.

  Methods  park  and  unpark  provide efficient
 means of blocking and unblocking threads that do not encounter the
 problems that cause the deprecated methods  Thread.suspend 
 and  Thread.resume  to be unusable for such purposes: Races
 between one thread invoking  park  and another thread trying
 to  unpark  it will preserve liveness due to the
 permit. Additionally  park  will return if the caller's
 thread was interrupted and timeout versions are supported. The
  park  method may also return at any other time for ""no
 reason"" so in general must be invoked within a loop that rechecks
 conditions upon return. In this sense  park  serves as an
 optimization of a ""busy wait"" that does not waste as much time
 spinning but must be paired with an  unpark  to be
 effective.

  The three forms of  park  each also support a
  blocker  object parameter. This object is recorded while
 the thread is blocked to permit monitoring and diagnostic tools to
 identify the reasons that threads are blocked. (Such tools may
 access blockers using method  getBlocker(java.lang.Thread) .)
 The use of these forms rather than the original forms without this
 parameter is strongly encouraged. The normal argument to supply as
 a  blocker  within a lock implementation is  this .

  These methods are designed to be used as tools for creating
 higher-level synchronization utilities and are not in themselves
 useful for most concurrency control applications.  The  park 
 method is designed for use only in constructions of the form:

  while (!canProceed()) {
   // ensure request to unpark is visible to other threads
   ...
   LockSupport.park(this);
 } park park Sample Usage.  Here is a sketch of a first-in-first-out
 non-reentrant lock class:
  class FIFOMutex {
   private final AtomicBoolean locked = new AtomicBoolean(false);
   private final Queue<Thread> waiters
     = new ConcurrentLinkedQueue<>();

   public void lock() {
     boolean wasInterrupted = false;
     // publish current thread for unparkers
     waiters.add(Thread.currentThread());

     // Block while not first in queue or cannot acquire lock
     while (waiters.peek() != Thread.currentThread() ||
            !locked.compareAndSet(false true)) {
       LockSupport.park(this);
       // ignore interrupts while waiting
       if (Thread.interrupted())
         wasInterrupted = true;
     }

     waiters.remove();
     // ensure correct interrupt status on return
     if (wasInterrupted)
       Thread.currentThread().interrupt();
   }

   public void unlock() {
     locked.set(false);
     LockSupport.unpark(waiters.peek());
   }

   static {
     // Reduce the risk of ""lost unpark"" due to classloading
     Class<?> ensureLoaded = LockSupport.class;
   }
 }"
android,java.util.concurrent.locks,ReentrantLock,19,"A reentrant mutual exclusion  Lock  with the same basic
 behavior and semantics as the implicit monitor lock accessed using
  synchronized  methods and statements but with extended
 capabilities.

  A  ReentrantLock  is  owned  by the thread last
 successfully locking but not yet unlocking it. A thread invoking
  lock  will return successfully acquiring the lock when
 the lock is not owned by another thread. The method will return
 immediately if the current thread already owns the lock. This can
 be checked using methods  isHeldByCurrentThread()  and  getHoldCount() .

  The constructor for this class accepts an optional
  fairness  parameter.  When set  true  under
 contention locks favor granting access to the longest-waiting
 thread.  Otherwise this lock does not guarantee any particular
 access order.  Programs using fair locks accessed by many threads
 may display lower overall throughput (i.e. are slower; often much
 slower) than those using the default setting but have smaller
 variances in times to obtain locks and guarantee lack of
 starvation. Note however that fairness of locks does not guarantee
 fairness of thread scheduling. Thus one of many threads using a
 fair lock may obtain it multiple times in succession while other
 active threads are not progressing and not currently holding the
 lock.
 Also note that the untimed  tryLock()  method does not
 honor the fairness setting. It will succeed if the lock
 is available even if other threads are waiting.

  It is recommended practice to  always  immediately
 follow a call to  lock  with a  try  block most
 typically in a before/after construction such as:

  class X {
   private final ReentrantLock lock = new ReentrantLock();
   // ...

   public void m() {
     lock.lock();  // block until condition holds
     try {
       // ... method body
     } finally {
       lock.unlock()
     }
   }
 } In addition to implementing the  Lock  interface this
 class defines a number of  public  and  protected 
 methods for inspecting the state of the lock.  Some of these
 methods are only useful for instrumentation and monitoring.

  Serialization of this class behaves in the same way as built-in
 locks: a deserialized lock is in the unlocked state regardless of
 its state when serialized.

  This lock supports a maximum of 2147483647 recursive locks by
 the same thread. Attempts to exceed this limit result in
  Error  throws from locking methods."
android,java.util.concurrent.locks,ReentrantReadWriteLock.ReadLock,7,The lock returned by method  ReentrantReadWriteLock#readLock .
android,java.util.concurrent.locks,ReentrantReadWriteLock,19,"An implementation of  ReadWriteLock  supporting similar
 semantics to  ReentrantLock .
  This class has the following properties:

  Acquisition order This class does not impose a reader or writer preference
 ordering for lock access.  However it does support an optional
  fairness  policy.

  Non-fair mode (default) 
 When constructed as non-fair (the default) the order of entry
 to the read and write lock is unspecified subject to reentrancy
 constraints.  A nonfair lock that is continuously contended may
 indefinitely postpone one or more reader or writer threads but
 will normally have higher throughput than a fair lock.

  Fair mode 
 When constructed as fair threads contend for entry using an
 approximately arrival-order policy. When the currently held lock
 is released either the longest-waiting single writer thread will
 be assigned the write lock or if there is a group of reader threads
 waiting longer than all waiting writer threads that group will be
 assigned the read lock.

  A thread that tries to acquire a fair read lock (non-reentrantly)
 will block if either the write lock is held or there is a waiting
 writer thread. The thread will not acquire the read lock until
 after the oldest currently waiting writer thread has acquired and
 released the write lock. Of course if a waiting writer abandons
 its wait leaving one or more reader threads as the longest waiters
 in the queue with the write lock free then those readers will be
 assigned the read lock.

  A thread that tries to acquire a fair write lock (non-reentrantly)
 will block unless both the read lock and write lock are free (which
 implies there are no waiting threads).  (Note that the non-blocking
  ReadLock#tryLock()  and  WriteLock#tryLock()  methods
 do not honor this fair setting and will immediately acquire the lock
 if it is possible regardless of waiting threads.)
  Reentrancy This lock allows both readers and writers to reacquire read or
 write locks in the style of a  ReentrantLock . Non-reentrant
 readers are not allowed until all write locks held by the writing
 thread have been released.

  Additionally a writer can acquire the read lock but not
 vice-versa.  Among other applications reentrancy can be useful
 when write locks are held during calls or callbacks to methods that
 perform reads under read locks.  If a reader tries to acquire the
 write lock it will never succeed.

  Lock downgrading Reentrancy also allows downgrading from the write lock to a read lock
 by acquiring the write lock then the read lock and then releasing the
 write lock. However upgrading from a read lock to the write lock is
  not  possible.

  Interruption of lock acquisition The read lock and write lock both support interruption during lock
 acquisition.

  Condition  support The write lock provides a  Condition  implementation that
 behaves in the same way with respect to the write lock as the
  Condition  implementation provided by
  ReentrantLock#newCondition  does for  ReentrantLock .
 This  Condition  can of course only be used with the write lock.

  The read lock does not support a  Condition  and
  readLock().newCondition()  throws
  UnsupportedOperationException .

  Instrumentation This class supports methods to determine whether locks
 are held or contended. These methods are designed for monitoring
 system state not for synchronization control.
  Serialization of this class behaves in the same way as built-in
 locks: a deserialized lock is in the unlocked state regardless of
 its state when serialized.

  Sample usages . Here is a code sketch showing how to perform
 lock downgrading after updating a cache (exception handling is
 particularly tricky when handling multiple locks in a non-nested
 fashion):

  class CachedData {
   Object data;
   volatile boolean cacheValid;
   final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();

   void processCachedData() {
     rwl.readLock().lock();
     if (!cacheValid) {
       // Must release read lock before acquiring write lock
       rwl.readLock().unlock();
       rwl.writeLock().lock();
       try {
         // Recheck state because another thread might have
         // acquired write lock and changed state before we did.
         if (!cacheValid) {
           data = ...
           cacheValid = true;
         }
         // Downgrade by acquiring read lock before releasing write lock
         rwl.readLock().lock();
       } finally {
         rwl.writeLock().unlock(); // Unlock write still hold read
       }
     }

     try {
       use(data);
     } finally {
       rwl.readLock().unlock();
     }
   }
 } class RWDictionary {
   private final Map<String Data> m = new TreeMap<>();
   private final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
   private final Lock r = rwl.readLock();
   private final Lock w = rwl.writeLock();

   public Data get(String key) {
     r.lock();
     try { return m.get(key); }
     finally { r.unlock(); }
   }
   public List<String> allKeys() {
     r.lock();
     try { return new ArrayList<>(m.keySet()); }
     finally { r.unlock(); }
   }
   public Data put(String key Data value) {
     w.lock();
     try { return m.put(key value); }
     finally { w.unlock(); }
   }
   public void clear() {
     w.lock();
     try { m.clear(); }
     finally { w.unlock(); }
   }
 } Implementation Notes This lock supports a maximum of 65535 recursive write locks
 and 65535 read locks. Attempts to exceed these limits result in
  Error  throws from locking methods."
android,java.util.concurrent.locks,ReentrantReadWriteLock.WriteLock,9,The lock returned by method  ReentrantReadWriteLock#writeLock .
android,java.util.concurrent.locks,StampedLock,25,"A capability-based lock with three modes for controlling read/write
 access.  The state of a StampedLock consists of a version and mode.
 Lock acquisition methods return a stamp that represents and
 controls access with respect to a lock state; ""try"" versions of
 these methods may instead return the special value zero to
 represent failure to acquire access. Lock release and conversion
 methods require stamps as arguments and fail if they do not match
 the state of the lock. The three modes are:

  Writing.  Method  writeLock()  possibly blocks
   waiting for exclusive access returning a stamp that can be used
   in method  unlockWrite(long)  to release the lock. Untimed and
   timed versions of  tryWriteLock  are also provided. When
   the lock is held in write mode no read locks may be obtained
   and all optimistic read validations will fail.

   Reading.  Method  readLock()  possibly blocks
   waiting for non-exclusive access returning a stamp that can be
   used in method  unlockRead(long)  to release the lock. Untimed
   and timed versions of  tryReadLock  are also provided.

   Optimistic Reading.  Method  tryOptimisticRead() 
   returns a non-zero stamp only if the lock is not currently held
   in write mode. Method  validate(long)  returns true if the lock
   has not been acquired in write mode since obtaining a given
   stamp.  This mode can be thought of as an extremely weak version
   of a read-lock that can be broken by a writer at any time.  The
   use of optimistic mode for short read-only code segments often
   reduces contention and improves throughput.  However its use is
   inherently fragile.  Optimistic read sections should only read
   fields and hold them in local variables for later use after
   validation. Fields read while in optimistic mode may be wildly
   inconsistent so usage applies only when you are familiar enough
   with data representations to check consistency and/or repeatedly
   invoke method  validate() .  For example such steps are
   typically required when first reading an object or array
   reference and then accessing one of its fields elements or
   methods.

  This class also supports methods that conditionally provide
 conversions across the three modes. For example method  tryConvertToWriteLock(long)  attempts to ""upgrade"" a mode returning
 a valid write stamp if (1) already in writing mode (2) in reading
 mode and there are no other readers or (3) in optimistic mode and
 the lock is available. The forms of these methods are designed to
 help reduce some of the code bloat that otherwise occurs in
 retry-based designs.

  StampedLocks are designed for use as internal utilities in the
 development of thread-safe components. Their use relies on
 knowledge of the internal properties of the data objects and
 methods they are protecting.  They are not reentrant so locked
 bodies should not call other unknown methods that may try to
 re-acquire locks (although you may pass a stamp to other methods
 that can use or convert it).  The use of read lock modes relies on
 the associated code sections being side-effect-free.  Unvalidated
 optimistic read sections cannot call methods that are not known to
 tolerate potential inconsistencies.  Stamps use finite
 representations and are not cryptographically secure (i.e. a
 valid stamp may be guessable). Stamp values may recycle after (no
 sooner than) one year of continuous operation. A stamp held without
 use or validation for longer than this period may fail to validate
 correctly.  StampedLocks are serializable but always deserialize
 into initial unlocked state so they are not useful for remote
 locking.

  The scheduling policy of StampedLock does not consistently
 prefer readers over writers or vice versa.  All ""try"" methods are
 best-effort and do not necessarily conform to any scheduling or
 fairness policy. A zero return from any ""try"" method for acquiring
 or converting locks does not carry any information about the state
 of the lock; a subsequent invocation may succeed.

  Because it supports coordinated usage across multiple lock
 modes this class does not directly implement the  Lock  or
  ReadWriteLock  interfaces. However a StampedLock may be
 viewed  asReadLock()   asWriteLock()  or  asReadWriteLock()  in applications requiring only the associated
 set of functionality.

  Sample Usage.  The following illustrates some usage idioms
 in a class that maintains simple two-dimensional points. The sample
 code illustrates some try/catch conventions even though they are
 not strictly needed here because no exceptions can occur in their
 bodies. class Point {
   private double x y;
   private final StampedLock sl = new StampedLock();

   void move(double deltaX double deltaY) { // an exclusively locked method
     long stamp = sl.writeLock();
     try {
       x += deltaX;
       y += deltaY;
     } finally {
       sl.unlockWrite(stamp);
     }
   }

   double distanceFromOrigin() { // A read-only method
     long stamp = sl.tryOptimisticRead();
     double currentX = x currentY = y;
     if (!sl.validate(stamp)) {
        stamp = sl.readLock();
        try {
          currentX = x;
          currentY = y;
        } finally {
           sl.unlockRead(stamp);
        }
     }
     return Math.sqrt(currentX * currentX + currentY * currentY);
   }

   void moveIfAtOrigin(double newX double newY) { // upgrade
     // Could instead start with optimistic not read mode
     long stamp = sl.readLock();
     try {
       while (x == 0.0 && y == 0.0) {
         long ws = sl.tryConvertToWriteLock(stamp);
         if (ws != 0L) {
           stamp = ws;
           x = newX;
           y = newY;
           break;
         }
         else {
           sl.unlockRead(stamp);
           stamp = sl.writeLock();
         }
       }
     } finally {
       sl.unlock(stamp);
     }
   }
 }"
android,java.util.jar,Attributes,18,"The Attributes class maps Manifest attribute names to associated string
 values. Valid attribute names are case-insensitive are restricted to
 the ASCII characters in the set [0-9a-zA-Z_-] and cannot exceed 70
 characters in length. Attribute values can contain any characters and
 will be UTF8-encoded when written to the output stream.  See the
  JAR File Specification 
 for more information about valid attribute names and values."
android,java.util.jar,Attributes.Name,3,"The Attributes.Name class represents an attribute name stored in
 this Map. Valid attribute names are case-insensitive are restricted
 to the ASCII characters in the set [0-9a-zA-Z_-] and cannot exceed
 70 characters in length. Attribute values can contain any characters
 and will be UTF8-encoded when written to the output stream.  See the
  JAR File Specification 
 for more information about valid attribute names and values."
android,java.util.jar,JarEntry,3,This class is used to represent a JAR file entry.
android,java.util.jar,JarFile,6,"The  JarFile  class is used to read the contents of a jar file
 from any file that can be opened with  java.io.RandomAccessFile .
 It extends the class  java.util.zip.ZipFile  with support
 for reading an optional  Manifest  entry. The
  Manifest  can be used to specify meta-information about the
 jar file and its entries.

   Unless otherwise noted passing a  null  argument to a constructor
 or method in this class will cause a  NullPointerException  to be
 thrown.

 If the verify flag is on when opening a signed jar file the content of the
 file is verified against its signature embedded inside the file. Please note
 that the verification process does not include validating the signer's
 certificate. A caller should inspect the return value of
  JarEntry#getCodeSigners()  to further determine if the signature
 can be trusted."
android,java.util.jar,JarInputStream,5,"The  JarInputStream  class is used to read the contents of
 a JAR file from any input stream. It extends the class
  java.util.zip.ZipInputStream  with support for reading
 an optional  Manifest  entry. The  Manifest 
 can be used to store meta-information about the JAR file and its entries."
android,java.util.jar,JarOutputStream,1,"The  JarOutputStream  class is used to write the contents
 of a JAR file to any output stream. It extends the class
  java.util.zip.ZipOutputStream  with support
 for writing an optional  Manifest  entry. The
  Manifest  can be used to specify meta-information about
 the JAR file and its entries."
android,java.util.jar,Manifest,9,"The Manifest class is used to maintain Manifest entry names and their
 associated Attributes. There are main Manifest Attributes as well as
 per-entry Attributes. For information on the Manifest format please
 see the
  
 Manifest format specification ."
android,java.util.jar,Pack200,2,"Transforms a JAR file to or from a packed stream in Pack200 format.
 Please refer to Network Transfer Format JSR 200 Specification at
  http://jcp.org/aboutJava/communityprocess/review/jsr200/index.html 
 Typically the packer engine is used by application developers
 to deploy or host JAR files on a website.
 The unpacker  engine is used by deployment applications to
 transform the byte-stream back to JAR format.
  
 Here is an example using  packer and unpacker:
  import java.util.jar.Pack200;
    import java.util.jar.Pack200.*;
    ...
    // Create the Packer object
    Packer packer = Pack200.newPacker();

    // Initialize the state by setting the desired properties
    Map p = packer.properties();
    // take more time choosing codings for better compression
    p.put(Packer.EFFORT ""7"");  // default is ""5""
    // use largest-possible archive segments (>10% better compression).
    p.put(Packer.SEGMENT_LIMIT ""-1"");
    // reorder files for better compression.
    p.put(Packer.KEEP_FILE_ORDER Packer.FALSE);
    // smear modification times to a single value.
    p.put(Packer.MODIFICATION_TIME Packer.LATEST);
    // ignore all JAR deflation requests
    // transmitting a single request to use ""store"" mode.
    p.put(Packer.DEFLATE_HINT Packer.FALSE);
    // discard debug attributes
    p.put(Packer.CODE_ATTRIBUTE_PFX+""LineNumberTable"" Packer.STRIP);
    // throw an error if an attribute is unrecognized
    p.put(Packer.UNKNOWN_ATTRIBUTE Packer.ERROR);
    // pass one class file uncompressed:
    p.put(Packer.PASS_FILE_PFX+0 ""mutants/Rogue.class"");
    try {
        JarFile jarFile = new JarFile(""/tmp/testref.jar"");
        FileOutputStream fos = new FileOutputStream(""/tmp/test.pack"");
        // Call the packer
        packer.pack(jarFile fos);
        jarFile.close();
        fos.close();

        File f = new File(""/tmp/test.pack"");
        FileOutputStream fostream = new FileOutputStream(""/tmp/test.jar"");
        JarOutputStream jostream = new JarOutputStream(fostream);
        Unpacker unpacker = Pack200.newUnpacker();
        // Call the unpacker
        unpacker.unpack(f jostream);
        // Must explicitly close the output.
        jostream.close();
    } catch (IOException ioe) {
        ioe.printStackTrace();
    }
  
 A Pack200 file compressed with gzip can be hosted on HTTP/1.1 web servers.
 The deployment applications can use ""Accept-Encoding=pack200-gzip"". This
 indicates to the server that the client application desires a version of
 the file encoded with Pack200 and further compressed with gzip. Please
 refer to   Java Deployment Guide  for more details and
 techniques.
  
 Unless otherwise noted passing a  null  argument to a constructor or
 method in this class will cause a  NullPointerException  to be thrown."
android,java.util,AbstractList,16,"This class provides a skeletal implementation of the  List 
 interface to minimize the effort required to implement this interface
 backed by a ""random access"" data store (such as an array).  For sequential
 access data (such as a linked list)  AbstractSequentialList  should
 be used in preference to this class.

  To implement an unmodifiable list the programmer needs only to extend
 this class and provide implementations for the  get(int)  and
  List#size()  methods.

  To implement a modifiable list the programmer must additionally
 override the  set(int E)  method (which otherwise
 throws an  UnsupportedOperationException ).  If the list is
 variable-size the programmer must additionally override the
  add(int E)  and  remove(int)  methods.

  The programmer should generally provide a void (no argument) and collection
 constructor as per the recommendation in the  Collection  interface
 specification.

  Unlike the other abstract collection implementations the programmer does
  not  have to provide an iterator implementation; the iterator and
 list iterator are implemented by this class on top of the ""random access""
 methods:
  get(int) 
  set(int E) 
  add(int E)  and
  remove(int) .

  The documentation for each non-abstract method in this class describes its
 implementation in detail.  Each of these methods may be overridden if the
 collection being implemented admits a more efficient implementation.

  This class is a member of the
  
 Java Collections Framework ."
android,java.util,AbstractMap.SimpleEntry,6,"An Entry maintaining a key and a value.  The value may be
 changed using the  setValue  method.  This class
 facilitates the process of building custom map
 implementations. For example it may be convenient to return
 arrays of  SimpleEntry  instances in method
  Map.entrySet().toArray ."
android,java.util,AbstractMap.SimpleImmutableEntry,6,"An Entry maintaining an immutable key and value.  This class
 does not support method  setValue .  This class may be
 convenient in methods that return thread-safe snapshots of
 key-value mappings."
android,java.util,AbstractQueue,5,"This class provides skeletal implementations of some  Queue 
 operations. The implementations in this class are appropriate when
 the base implementation does  not  allow  null 
 elements.  Methods  add   remove  and
  element  are based on  offer   poll  and  peek  respectively but throw
 exceptions instead of indicating failure via  false  or
  null  returns.

  A  Queue  implementation that extends this class must
 minimally define a method  Queue#offer  which does not permit
 insertion of  null  elements along with methods  Queue#peek   Queue#poll   Collection#size  and
  Collection#iterator .  Typically additional methods will be
 overridden as well.  If these requirements cannot be met consider
 instead subclassing  AbstractCollection ."
android,java.util,AbstractSequentialList,7,"This class provides a skeletal implementation of the  List 
 interface to minimize the effort required to implement this interface
 backed by a ""sequential access"" data store (such as a linked list).  For
 random access data (such as an array)  AbstractList  should be used
 in preference to this class. 

 This class is the opposite of the  AbstractList  class in the sense
 that it implements the ""random access"" methods ( get(int index) 
  set(int index E element)   add(int index E element)  and
  remove(int index) ) on top of the list's list iterator instead of
 the other way around. 

 To implement a list the programmer needs only to extend this class and
 provide implementations for the  listIterator  and  size 
 methods.  For an unmodifiable list the programmer need only implement the
 list iterator's  hasNext   next   hasPrevious 
  previous  and  index  methods. 

 For a modifiable list the programmer should additionally implement the list
 iterator's  set  method.  For a variable-size list the programmer
 should additionally implement the list iterator's  remove  and
  add  methods. 

 The programmer should generally provide a void (no argument) and collection
 constructor as per the recommendation in the  Collection  interface
 specification. 

 This class is a member of the
  
 Java Collections Framework ."
android,java.util,AbstractSet,3,"This class provides a skeletal implementation of the  Set 
 interface to minimize the effort required to implement this
 interface.  

 The process of implementing a set by extending this class is identical
 to that of implementing a Collection by extending AbstractCollection
 except that all of the methods and constructors in subclasses of this
 class must obey the additional constraints imposed by the  Set 
 interface (for instance the add method must not permit addition of
 multiple instances of an object to a set). 

 Note that this class does not override any of the implementations from
 the  AbstractCollection  class.  It merely adds implementations
 for  equals  and  hashCode . 

 This class is a member of the
  
 Java Collections Framework ."
android,java.util,Arrays,155,"This class contains various methods for manipulating arrays (such as
 sorting and searching). This class also contains a static factory
 that allows arrays to be viewed as lists.

  The methods in this class all throw a  NullPointerException 
 if the specified array reference is null except where noted.

  The documentation for the methods contained in this class includes
 briefs description of the  implementations . Such descriptions should
 be regarded as  implementation notes  rather than parts of the
  specification . Implementors should feel free to substitute other
 algorithms so long as the specification itself is adhered to. (For
 example the algorithm used by  sort(Object[])  does not have to be
 a MergeSort but it does have to be  stable .)

  This class is a member of the
  
 Java Collections Framework ."
android,java.util,Base64,7,"This class consists exclusively of static methods for obtaining
 encoders and decoders for the Base64 encoding scheme. The
 implementation of this class supports the following types of Base64
 as specified in
  RFC 4648  and
  RFC 2045 .

  Basic  Uses ""The Base64 Alphabet"" as specified in Table 1 of
     RFC 4648 and RFC 2045 for encoding and decoding operation.
     The encoder does not add any line feed (line separator)
     character. The decoder rejects data that contains characters
     outside the base64 alphabet. URL and Filename safe  Uses the ""URL and Filename safe Base64 Alphabet"" as specified
     in Table 2 of RFC 4648 for encoding and decoding. The
     encoder does not add any line feed (line separator) character.
     The decoder rejects data that contains characters outside the
     base64 alphabet. MIME  Uses the ""The Base64 Alphabet"" as specified in Table 1 of
     RFC 2045 for encoding and decoding operation. The encoded output
     must be represented in lines of no more than 76 characters each
     and uses a carriage return  '\r'  followed immediately by
     a linefeed  '\n'  as the line separator. No line separator
     is added to the end of the encoded output. All line separators
     or other characters not found in the base64 alphabet table are
     ignored in decoding operation.  Unless otherwise noted passing a  null  argument to a
 method of this class will cause a  NullPointerException  to be thrown."
android,java.util,Base64.Decoder,5,"This class implements a decoder for decoding byte data using the
 Base64 encoding scheme as specified in RFC 4648 and RFC 2045.

   The Base64 padding character  '='  is accepted and
 interpreted as the end of the encoded byte data but is not
 required. So if the final unit of the encoded byte data only has
 two or three Base64 characters (without the corresponding padding
 character(s) padded) they are decoded as if followed by padding
 character(s). If there is a padding character present in the
 final unit the correct number of padding character(s) must be
 present otherwise  IllegalArgumentException  (
  IOException  when reading from a Base64 stream) is thrown
 during decoding.

   Instances of  Decoder  class are safe for use by
 multiple concurrent threads.

   Unless otherwise noted passing a  null  argument to
 a method of this class will cause a
  NullPointerException  to
 be thrown."
android,java.util,Base64.Encoder,6,"This class implements an encoder for encoding byte data using
 the Base64 encoding scheme as specified in RFC 4648 and RFC 2045.

   Instances of  Encoder  class are safe for use by
 multiple concurrent threads.

   Unless otherwise noted passing a  null  argument to
 a method of this class will cause a
  NullPointerException  to
 be thrown."
android,java.util,BitSet,35,"This class implements a vector of bits that grows as needed. Each
 component of the bit set has a  boolean  value. The
 bits of a  BitSet  are indexed by nonnegative integers.
 Individual indexed bits can be examined set or cleared. One
  BitSet  may be used to modify the contents of another
  BitSet  through logical AND logical inclusive OR and
 logical exclusive OR operations.

  By default all bits in the set initially have the value
  false .

  Every bit set has a current size which is the number of bits
 of space currently in use by the bit set. Note that the size is
 related to the implementation of a bit set so it may change with
 implementation. The length of a bit set relates to logical length
 of a bit set and is defined independently of implementation.

  Unless otherwise noted passing a null parameter to any of the
 methods in a  BitSet  will result in a
  NullPointerException .

  A  BitSet  is not safe for multithreaded use without
 external synchronization."
android,java.util,Calendar,54,"The  Calendar  class is an abstract class that provides methods
 for converting between a specific instant in time and a set of  calendar fields  such as  YEAR   MONTH 
  DAY_OF_MONTH   HOUR  and so on and for
 manipulating the calendar fields such as getting the date of the next
 week. An instant in time can be represented by a millisecond value that is
 an offset from the  Epoch  January 1 1970
 00:00:00.000 GMT (Gregorian).

  The class also provides additional fields and methods for
 implementing a concrete calendar system outside the package. Those
 fields and methods are defined as  protected .

  
 Like other locale-sensitive classes  Calendar  provides a
 class method  getInstance  for getting a generally useful
 object of this type.  Calendar 's  getInstance  method
 returns a  Calendar  object whose
 calendar fields have been initialized with the current date and time:
  
     Calendar rightNow = Calendar.getInstance();
  A  Calendar  object can produce all the calendar field values
 needed to implement the date-time formatting for a particular language and
 calendar style (for example Japanese-Gregorian Japanese-Traditional).
  Calendar  defines the range of values returned by
 certain calendar fields as well as their meaning.  For example
 the first month of the calendar system has value  MONTH ==
 JANUARY  for all calendars.  Other values are defined by the
 concrete subclass such as  ERA .  See individual field
 documentation and subclass documentation for details.

  Getting and Setting Calendar Field Values The calendar field values can be set by calling the  set 
 methods. Any field values set in a  Calendar  will not be
 interpreted until it needs to calculate its time value (milliseconds from
 the Epoch) or values of the calendar fields. Calling the
  get   getTimeInMillis   getTime 
  add  and  roll  involves such calculation.

  Leniency Calendar  has two modes for interpreting the calendar
 fields  lenient  and  non-lenient .  When a
  Calendar  is in lenient mode it accepts a wider range of
 calendar field values than it produces.  When a  Calendar 
 recomputes calendar field values for return by  get()  all of
 the calendar fields are normalized. For example a lenient
  GregorianCalendar  interprets  MONTH == JANUARY 
  DAY_OF_MONTH == 32  as February 1.
 
  When a  Calendar  is in non-lenient mode it throws an
 exception if there is any inconsistency in its calendar fields. For
 example a  GregorianCalendar  always produces
  DAY_OF_MONTH  values between 1 and the length of the month. A
 non-lenient  GregorianCalendar  throws an exception upon
 calculating its time or calendar field values if any out-of-range field
 value has been set.

  First Week Calendar Calendar When setting or getting the  WEEK_OF_MONTH  or
  WEEK_OF_YEAR  fields  Calendar  must determine the
 first week of the month or year as a reference point.  The first week of a
 month or year is defined as the earliest seven day period beginning on
  getFirstDayOfWeek()  and containing at least
  getMinimalDaysInFirstWeek()  days of that month or year.  Weeks
 numbered ... -1 0 precede the first week; weeks numbered 2 3... follow
 it.  Note that the normalized numbering returned by  get()  may be
 different.  For example a specific  Calendar  subclass may
 designate the week before week 1 of a year as week  n  of
 the previous year.

  Calendar Fields Resolution Calendar If there is any conflict in calendar field values
  Calendar  gives priorities to calendar fields that have been set
 more recently.  The following are the default combinations of the
 calendar fields. The most recent combination as determined by the
 most recently set single field will be used.

  For the date fields :
  
 YEAR + MONTH + DAY_OF_MONTH
 YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK
 YEAR + MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK
 YEAR + DAY_OF_YEAR
 YEAR + DAY_OF_WEEK + WEEK_OF_YEAR
  For the time of day fields 
 HOUR_OF_DAY
 AM_PM + HOUR
  If there are any calendar fields whose values haven't been set in the selected
 field combination  Calendar  uses their default values. The default
 value of each field may vary by concrete calendar systems. For example in
  GregorianCalendar  the default of a field is the same as that
 of the start of the Epoch: i.e.  YEAR = 1970   MONTH =
 JANUARY   DAY_OF_MONTH = 1  etc.

  Note:  There are certain possible ambiguities in
 interpretation of certain singular times which are resolved in the
 following ways:
   23:59 is the last minute of the day and 00:00 is the first
          minute of the next day. Thus 23:59 on Dec 31 1999 < 00:00 on
          Jan 1 2000 < 00:01 on Jan 1 2000.

       Although historically not precise midnight also belongs to ""am""
          and noon belongs to ""pm"" so on the same day
          12:00 am (midnight) < 12:01 am and 12:00 pm (noon) < 12:01 pm
  
 The date or time format strings are not part of the definition of a
 calendar as those must be modifiable or overridable by the user at
 runtime. Use  DateFormat 
 to format dates.

  Field Manipulation set() add() roll() set(f value)  changes calendar field
  f  to  value .  In addition it sets an
 internal member variable to indicate that calendar field  f  has
 been changed. Although calendar field  f  is changed immediately
 the calendar's time value in milliseconds is not recomputed until the next call to
  get()   getTime()   getTimeInMillis() 
  add()  or  roll()  is made. Thus multiple calls to
  set()  do not trigger multiple unnecessary
 computations. As a result of changing a calendar field using
  set()  other calendar fields may also change depending on the
 calendar field the calendar field value and the calendar system. In addition
  get(f)  will not necessarily return  value  set by
 the call to the  set  method
 after the calendar fields have been recomputed. The specifics are determined by
 the concrete calendar class. Example : Consider a  GregorianCalendar 
 originally set to August 31 1999. Calling  set(Calendar.MONTH
 Calendar.SEPTEMBER)  sets the date to September 31
 1999. This is a temporary internal representation that resolves to
 October 1 1999 if  getTime() is then called. However a
 call to  set(Calendar.DAY_OF_MONTH 30)  before the call to
  getTime()  sets the date to September 30 1999 since
 no recomputation occurs after  set()  itself. add(f delta)  adds  delta 
 to field  f .  This is equivalent to calling  set(f
 get(f) + delta)  with two adjustments: Add rule 1 . The value of field  f 
   after the call minus the value of field  f  before the
   call is  delta  modulo any overflow that has occurred in
   field  f . Overflow occurs when a field value exceeds its
   range and as a result the next larger field is incremented or
   decremented and the field value is adjusted back into its range. Add rule 2 . If a smaller field is expected to be
   invariant but it is impossible for it to be equal to its
   prior value because of changes in its minimum or maximum after field
    f  is changed or other constraints such as time zone
   offset changes then its value is adjusted to be as close
   as possible to its expected value. A smaller field represents a
   smaller unit of time.  HOUR  is a smaller field than
    DAY_OF_MONTH . No adjustment is made to smaller fields
   that are not expected to be invariant. The calendar system
   determines what fields are expected to be invariant. In addition unlike  set()   add()  forces
 an immediate recomputation of the calendar's milliseconds and all
 fields. Example : Consider a  GregorianCalendar 
 originally set to August 31 1999. Calling  add(Calendar.MONTH
 13)  sets the calendar to September 30 2000.  Add rule
 1  sets the  MONTH  field to September since
 adding 13 months to August gives September of the next year. Since
  DAY_OF_MONTH  cannot be 31 in September in a
  GregorianCalendar   add rule 2  sets the
  DAY_OF_MONTH  to 30 the closest possible value. Although
 it is a smaller field  DAY_OF_WEEK  is not adjusted by
 rule 2 since it is expected to change when the month changes in a
  GregorianCalendar . roll(f delta)  adds
  delta  to field  f  without changing larger
 fields. This is equivalent to calling  add(f delta)  with
 the following adjustment: Roll rule . Larger fields are unchanged after the
   call. A larger field represents a larger unit of
   time.  DAY_OF_MONTH  is a larger field than
    HOUR . Example : See  GregorianCalendar.roll(int int) .

  Usage model . To motivate the behavior of
  add()  and  roll()  consider a user interface
 component with increment and decrement buttons for the month day and
 year and an underlying  GregorianCalendar . If the
 interface reads January 31 1999 and the user presses the month
 increment button what should it read? If the underlying
 implementation uses  set()  it might read March 3 1999. A
 better result would be February 28 1999. Furthermore if the user
 presses the month increment button again it should read March 31
 1999 not March 28 1999. By saving the original date and using either
  add()  or  roll()  depending on whether larger
 fields should be affected the user interface can behave as most users
 will intuitively expect."
android,java.util,Calendar.Builder,14,"Calendar.Builder  is used for creating a  Calendar  from
 various date-time parameters.

  There are two ways to set a  Calendar  to a date-time value. One
 is to set the instant parameter to a millisecond offset from the  Epoch . The other is to set individual
 field parameters such as  Calendar#YEAR  to their desired
 values. These two ways can't be mixed. Trying to set both the instant and
 individual fields will cause an  IllegalStateException  to be
 thrown. However it is permitted to override previous values of the
 instant or field parameters.

  If no enough field parameters are given for determining date and/or
 time calendar specific default values are used when building a
  Calendar . For example if the  Calendar#YEAR  value
 isn't given for the Gregorian calendar 1970 will be used. If there are
 any conflicts among field parameters the   resolution rules  are applied.
 Therefore the order of field setting matters.

  In addition to the date-time parameters
 the  locale 
  time zone 
  week definition  and
  leniency mode  parameters can be set.

  Examples The following are sample usages. Sample code assumes that the
  Calendar  constants are statically imported.

  The following code produces a  Calendar  with date 2012-12-31
 (Gregorian) because Monday is the first day of a week with the   ISO 8601
 compatible week parameters .
  
   Calendar cal = new Calendar.Builder().setCalendarType(""iso8601"")
                        .setWeekDate(2013 1 MONDAY).build(); The following code produces a Japanese  Calendar  with date
 1989-01-08 (Gregorian) assuming that the default  Calendar#ERA 
 is  Heisei  that started on that day.
  
   Calendar cal = new Calendar.Builder().setCalendarType(""japanese"")
                        .setFields(YEAR 1 DAY_OF_YEAR 1).build();"
android,java.util,Collections,66,"This class consists exclusively of static methods that operate on or return
 collections.  It contains polymorphic algorithms that operate on
 collections ""wrappers"" which return a new collection backed by a
 specified collection and a few other odds and ends.

  The methods of this class all throw a  NullPointerException 
 if the collections or class objects provided to them are null.

  The documentation for the polymorphic algorithms contained in this class
 generally includes a brief description of the  implementation .  Such
 descriptions should be regarded as  implementation notes  rather than
 parts of the  specification .  Implementors should feel free to
 substitute other algorithms so long as the specification itself is adhered
 to.  (For example the algorithm used by  sort  does not have to be
 a mergesort but it does have to be  stable .)

  The ""destructive"" algorithms contained in this class that is the
 algorithms that modify the collection on which they operate are specified
 to throw  UnsupportedOperationException  if the collection does not
 support the appropriate mutation primitive(s) such as the  set 
 method.  These algorithms may but are not required to throw this
 exception if an invocation would have no effect on the collection.  For
 example invoking the  sort  method on an unmodifiable list that is
 already sorted may or may not throw  UnsupportedOperationException .

  This class is a member of the
  
 Java Collections Framework ."
android,java.util,Currency,11,"Represents a currency. Currencies are identified by their ISO 4217 currency
 codes. Visit the  
 ISO web site  for more information.
  
 The class is designed so that there's never more than one
  Currency  instance for any given currency. Therefore there's
 no public constructor. You obtain a  Currency  instance using
 the  getInstance  methods."
android,java.util,DoubleSummaryStatistics,8,"A state object for collecting statistics such as count min max sum and
 average.

  This class is designed to work with (though does not require)
  streams . For example you can compute
 summary statistics on a stream of doubles with:
  DoubleSummaryStatistics stats = doubleStream.collect(DoubleSummaryStatistics::new
                                                      DoubleSummaryStatistics::accept
                                                      DoubleSummaryStatistics::combine);
  DoubleSummaryStatistics  can be used as a
  reduction 
 target for a  stream . For example:

  DoubleSummaryStatistics stats = people.stream()
     .collect(Collectors.summarizingDouble(Person::getWeight));"
android,java.util,EnumMap,14,"A specialized  Map  implementation for use with enum type keys.  All
 of the keys in an enum map must come from a single enum type that is
 specified explicitly or implicitly when the map is created.  Enum maps
 are represented internally as arrays.  This representation is extremely
 compact and efficient.

  Enum maps are maintained in the  natural order  of their keys
 (the order in which the enum constants are declared).  This is reflected
 in the iterators returned by the collections views ( keySet() 
  entrySet()  and  values() ).

  Iterators returned by the collection views are  weakly consistent :
 they will never throw  ConcurrentModificationException  and they may
 or may not show the effects of any modifications to the map that occur while
 the iteration is in progress.

  Null keys are not permitted.  Attempts to insert a null key will
 throw  NullPointerException .  Attempts to test for the
 presence of a null key or to remove one will however function properly.
 Null values are permitted.
 
  Like most collection implementations  EnumMap  is not
 synchronized. If multiple threads access an enum map concurrently and at
 least one of the threads modifies the map it should be synchronized
 externally.  This is typically accomplished by synchronizing on some
 object that naturally encapsulates the enum map.  If no such object exists
 the map should be ""wrapped"" using the  Collections#synchronizedMap 
 method.  This is best done at creation time to prevent accidental
 unsynchronized access:

  
     Map<EnumKey V> m
         = Collections.synchronizedMap(new EnumMap<EnumKey V>(...));
  Implementation note: All basic operations execute in constant time.
 They are likely (though not guaranteed) to be faster than their
  HashMap  counterparts.

  This class is a member of the
  
 Java Collections Framework ."
android,java.util,EventListenerProxy,1,"An abstract wrapper class for an  EventListener  class
 which associates a set of additional parameters with the listener.
 Subclasses must provide the storage and accessor methods
 for the additional arguments or parameters.
  
 For example a bean which supports named properties
 would have a two argument method signature for adding
 a  PropertyChangeListener  for a property:
  
 public void addPropertyChangeListener(String propertyName
                                       PropertyChangeListener listener)
  
 public PropertyChangeListener[] getPropertyChangeListeners()
  PropertyChangeListeners PropertyChangeListenerProxy 
 If the calling method is interested in retrieving the named property
 then it would have to test the element to see if it is a proxy class."
android,java.util,FormattableFlags,0,"FomattableFlags are passed to the  Formattable#formatTo  method and modify the output format for  Formattable .  Implementations of  Formattable  are
 responsible for interpreting and validating any flags."
android,java.util,AbstractCollection,14,"This class provides a skeletal implementation of the  Collection 
 interface to minimize the effort required to implement this interface.  

 To implement an unmodifiable collection the programmer needs only to
 extend this class and provide implementations for the  iterator  and
  size  methods.  (The iterator returned by the  iterator 
 method must implement  hasNext  and  next .) 

 To implement a modifiable collection the programmer must additionally
 override this class's  add  method (which otherwise throws an
  UnsupportedOperationException ) and the iterator returned by the
  iterator  method must additionally implement its  remove 
 method. 

 The programmer should generally provide a void (no argument) and
  Collection  constructor as per the recommendation in the
  Collection  interface specification. 

 The documentation for each non-abstract method in this class describes its
 implementation in detail.  Each of these methods may be overridden if
 the collection being implemented admits a more efficient implementation. 

 This class is a member of the
  
 Java Collections Framework ."
android,java.util,AbstractMap,16,"This class provides a skeletal implementation of the  Map 
 interface to minimize the effort required to implement this interface.

  To implement an unmodifiable map the programmer needs only to extend this
 class and provide an implementation for the  entrySet  method which
 returns a set-view of the map's mappings.  Typically the returned set
 will in turn be implemented atop  AbstractSet .  This set should
 not support the  add  or  remove  methods and its iterator
 should not support the  remove  method.

  To implement a modifiable map the programmer must additionally override
 this class's  put  method (which otherwise throws an
  UnsupportedOperationException ) and the iterator returned by
  entrySet().iterator()  must additionally implement its
  remove  method.

  The programmer should generally provide a void (no argument) and map
 constructor as per the recommendation in the  Map  interface
 specification.

  The documentation for each non-abstract method in this class describes its
 implementation in detail.  Each of these methods may be overridden if the
 map being implemented admits a more efficient implementation.

  This class is a member of the
  
 Java Collections Framework ."
android,java.util,ArrayDeque,33,"Resizable-array implementation of the  Deque  interface.  Array
 deques have no capacity restrictions; they grow as necessary to support
 usage.  They are not thread-safe; in the absence of external
 synchronization they do not support concurrent access by multiple threads.
 Null elements are prohibited.  This class is likely to be faster than
  Stack  when used as a stack and faster than  LinkedList 
 when used as a queue.

  Most  ArrayDeque  operations run in amortized constant time.
 Exceptions include
  remove 
  removeFirstOccurrence 
  removeLastOccurrence 
  contains 
  iterator.remove() 
 and the bulk operations all of which run in linear time.

  The iterators returned by this class's  iterator 
 method are  fail-fast : If the deque is modified at any time after
 the iterator is created in any way except through the iterator's own
  remove  method the iterator will generally throw a  ConcurrentModificationException .  Thus in the face of concurrent
 modification the iterator fails quickly and cleanly rather than risking
 arbitrary non-deterministic behavior at an undetermined time in the
 future.

  Note that the fail-fast behavior of an iterator cannot be guaranteed
 as it is generally speaking impossible to make any hard guarantees in the
 presence of unsynchronized concurrent modification.  Fail-fast iterators
 throw  ConcurrentModificationException  on a best-effort basis.
 Therefore it would be wrong to write a program that depended on this
 exception for its correctness:  the fail-fast behavior of iterators
 should be used only to detect bugs. This class and its iterator implement all of the
  optional  methods of the  Collection  and  Iterator  interfaces."
android,java.util,ArrayList,31,"Resizable-array implementation of the  List  interface.  Implements
 all optional list operations and permits all elements including
  null .  In addition to implementing the  List  interface
 this class provides methods to manipulate the size of the array that is
 used internally to store the list.  (This class is roughly equivalent to
  Vector  except that it is unsynchronized.)

  The  size   isEmpty   get   set 
  iterator  and  listIterator  operations run in constant
 time.  The  add  operation runs in  amortized constant time 
 that is adding n elements requires O(n) time.  All of the other operations
 run in linear time (roughly speaking).  The constant factor is low compared
 to that for the  LinkedList  implementation.

  Each  ArrayList  instance has a  capacity .  The capacity is
 the size of the array used to store the elements in the list.  It is always
 at least as large as the list size.  As elements are added to an ArrayList
 its capacity grows automatically.  The details of the growth policy are not
 specified beyond the fact that adding an element has constant amortized
 time cost.

  An application can increase the capacity of an  ArrayList  instance
 before adding a large number of elements using the  ensureCapacity 
 operation.  This may reduce the amount of incremental reallocation.

  Note that this implementation is not synchronized. 
 If multiple threads access an  ArrayList  instance concurrently
 and at least one of the threads modifies the list structurally it
  must  be synchronized externally.  (A structural modification is
 any operation that adds or deletes one or more elements or explicitly
 resizes the backing array; merely setting the value of an element is not
 a structural modification.)  This is typically accomplished by
 synchronizing on some object that naturally encapsulates the list.

 If no such object exists the list should be ""wrapped"" using the
  Collections#synchronizedList 
 method.  This is best done at creation time to prevent accidental
 unsynchronized access to the list: 
   List list = Collections.synchronizedList(new ArrayList(...)); 
 The iterators returned by this class's  iterator  and
  listIterator  methods are  fail-fast : 
 if the list is structurally modified at any time after the iterator is
 created in any way except through the iterator's own
  ListIterator#remove()  or
  ListIterator#add(Object)  methods the iterator will throw a
  ConcurrentModificationException .  Thus in the face of
 concurrent modification the iterator fails quickly and cleanly rather
 than risking arbitrary non-deterministic behavior at an undetermined
 time in the future.

  Note that the fail-fast behavior of an iterator cannot be guaranteed
 as it is generally speaking impossible to make any hard guarantees in the
 presence of unsynchronized concurrent modification.  Fail-fast iterators
 throw  ConcurrentModificationException  on a best-effort basis.
 Therefore it would be wrong to write a program that depended on this
 exception for its correctness:   the fail-fast behavior of iterators
 should be used only to detect bugs. This class is a member of the
  
 Java Collections Framework ."
android,java.util,Date,29,"The class  Date  represents a specific instant
 in time with millisecond precision.
  
 Prior to JDKÂ 1.1 the class  Date  had two additional
 functions.  It allowed the interpretation of dates as year month day hour
 minute and second values.  It also allowed the formatting and parsing
 of date strings.  Unfortunately the API for these functions was not
 amenable to internationalization.  As of JDKÂ 1.1 the
  Calendar  class should be used to convert between dates and time
 fields and the  DateFormat  class should be used to format and
 parse date strings.
 The corresponding methods in  Date  are deprecated.
  
 Although the  Date  class is intended to reflect
 coordinated universal time (UTC) it may not do so exactly
 depending on the host environment of the Java Virtual Machine.
 Nearly all modern operating systems assume that 1Â dayÂ =
 24Â Ã—Â 60Â Ã—Â 60Â = 86400 seconds
 in all cases. In UTC however about once every year or two there
 is an extra second called a ""leap second."" The leap
 second is always added as the last second of the day and always
 on December 31 or June 30. For example the last minute of the
 year 1995 was 61 seconds long thanks to an added leap second.
 Most computer clocks are not accurate enough to be able to reflect
 the leap-second distinction.
  
 Some computer standards are defined in terms of Greenwich mean
 time (GMT) which is equivalent to universal time (UT).  GMT is
 the ""civil"" name for the standard; UT is the
 ""scientific"" name for the same standard. The
 distinction between UTC and UT is that UTC is based on an atomic
 clock and UT is based on astronomical observations which for all
 practical purposes is an invisibly fine hair to split. Because the
 earth's rotation is not uniform (it slows down and speeds up
 in complicated ways) UT does not always flow uniformly. Leap
 seconds are introduced as needed into UTC so as to keep UTC within
 0.9 seconds of UT1 which is a version of UT with certain
 corrections applied. There are other time and date systems as
 well; for example the time scale used by the satellite-based
 global positioning system (GPS) is synchronized to UTC but is
  not  adjusted for leap seconds. An interesting source of
 further information is the U.S. Naval Observatory particularly
 the Directorate of Time at:
  http://tycho.usno.navy.mil 
 and their definitions of ""Systems of Time"" at:
  http://tycho.usno.navy.mil/systime.html 
 In all methods of class  Date  that accept or return
 year month date hours minutes and seconds values the
 following representations are used:
  A year  y  is represented by the integer
      y -Â 1900 .
  A month is represented by an integer from 0 to 11; 0 is January
     1 is February and so forth; thus 11 is December.
  A date (day of month) is represented by an integer from 1 to 31
     in the usual manner.
  An hour is represented by an integer from 0 to 23. Thus the hour
     from midnight to 1 a.m. is hour 0 and the hour from noon to 1
     p.m. is hour 12.
  A minute is represented by an integer from 0 to 59 in the usual manner.
  A second is represented by an integer from 0 to 61; the values 60 and
     61 occur only for leap seconds and even then only in Java
     implementations that actually track leap seconds correctly. Because
     of the manner in which leap seconds are currently introduced it is
     extremely unlikely that two leap seconds will occur in the same
     minute but this specification follows the date and time conventions
     for ISO C.
  
 In all cases arguments given to methods for these purposes need
 not fall within the indicated ranges; for example a date may be
 specified as January 32 and is interpreted as meaning February 1."
android,java.util,Dictionary,7,"The  Dictionary  class is the abstract parent of any
 class such as  Hashtable  which maps keys to values.
 Every key and every value is an object. In any one  Dictionary 
 object every key is associated with at most one value. Given a
  Dictionary  and a key the associated element can be looked up.
 Any non- null  object can be used as a key and as a value.
  
 As a rule the  equals  method should be used by
 implementations of this class to decide if two keys are the same.
  NOTE: This class is obsolete.  New implementations should
 implement the Map interface rather than extending this class."
android,java.util,EnumSet,13,"A specialized  Set  implementation for use with enum types.  All of
 the elements in an enum set must come from a single enum type that is
 specified explicitly or implicitly when the set is created.  Enum sets
 are represented internally as bit vectors.  This representation is
 extremely compact and efficient. The space and time performance of this
 class should be good enough to allow its use as a high-quality typesafe
 alternative to traditional  int -based ""bit flags.""  Even bulk
 operations (such as  containsAll  and  retainAll ) should
 run very quickly if their argument is also an enum set.

  The iterator returned by the  iterator  method traverses the
 elements in their  natural order  (the order in which the enum
 constants are declared).  The returned iterator is  weakly
 consistent : it will never throw  ConcurrentModificationException 
 and it may or may not show the effects of any modifications to the set that
 occur while the iteration is in progress.

  Null elements are not permitted.  Attempts to insert a null element
 will throw  NullPointerException .  Attempts to test for the
 presence of a null element or to remove one will however function
 properly.

  Like most collection implementations  EnumSet  is not
 synchronized.  If multiple threads access an enum set concurrently and at
 least one of the threads modifies the set it should be synchronized
 externally.  This is typically accomplished by synchronizing on some
 object that naturally encapsulates the enum set.  If no such object exists
 the set should be ""wrapped"" using the  Collections#synchronizedSet 
 method.  This is best done at creation time to prevent accidental
 unsynchronized access:

  
 Set<MyEnum> s = Collections.synchronizedSet(EnumSet.noneOf(MyEnum.class));
  Implementation note: All basic operations execute in constant time.
 They are likely (though not guaranteed) to be much faster than their
  HashSet  counterparts.  Even bulk operations execute in
 constant time if their argument is also an enum set.

  This class is a member of the
  
 Java Collections Framework ."
android,java.util,EventObject,2,"The root class from which all event state objects shall be derived.
  
 All Events are constructed with a reference to the object the ""source""
 that is logically deemed to be the object upon which the Event in question
 initially occurred upon."
android,java.util.prefs,AbstractPreferences,46,"This class provides a skeletal implementation of the  Preferences 
 class greatly easing the task of implementing it.

  This class is for  Preferences  implementers only.
 Normal users of the  Preferences  facility should have no need to
 consult this documentation.  The  Preferences  documentation
 should suffice. Implementors must override the nine abstract service-provider interface
 (SPI) methods:  getSpi(java.lang.String)   putSpi(java.lang.String java.lang.String) 
  removeSpi(java.lang.String)   childSpi(java.lang.String)   removeNodeSpi()   keysSpi()   childrenNamesSpi()   syncSpi()  and  flushSpi() .  All of the concrete methods specify
 precisely how they are implemented atop these SPI methods.  The implementor
 may at his discretion override one or more of the concrete methods if the
 default implementation is unsatisfactory for any reason such as
 performance.

  The SPI methods fall into three groups concerning exception
 behavior. The  getSpi  method should never throw exceptions but it
 doesn't really matter as any exception thrown by this method will be
 intercepted by  get(java.lang.String java.lang.String)  which will return the specified
 default value to the caller.  The  removeNodeSpi keysSpi
 childrenNamesSpi syncSpi  and  flushSpi  methods are specified
 to throw  BackingStoreException  and the implementation is required
 to throw this checked exception if it is unable to perform the operation.
 The exception propagates outward causing the corresponding API method
 to fail.

  The remaining SPI methods  putSpi(java.lang.String java.lang.String)   removeSpi(java.lang.String)  and  childSpi(java.lang.String)  have more complicated
 exception behavior.  They are not specified to throw
  BackingStoreException  as they can generally obey their contracts
 even if the backing store is unavailable.  This is true because they return
 no information and their effects are not required to become permanent until
 a subsequent call to  Preferences#flush()  or
  Preferences#sync() . Generally speaking these SPI methods should not
 throw exceptions.  In some implementations there may be circumstances
 under which these calls cannot even enqueue the requested operation for
 later processing.  Even under these circumstances it is generally better to
 simply ignore the invocation and return rather than throwing an
 exception.  Under these circumstances however all subsequent invocations
 of  flush()  and  sync  should return  false  as
 returning  true  would imply that all previous operations had
 successfully been made permanent.

  There is one circumstance under which  putSpi removeSpi and
 childSpi should  throw an exception: if the caller lacks
 sufficient privileges on the underlying operating system to perform the
 requested operation.  This will for instance occur on most systems
 if a non-privileged user attempts to modify system preferences.
 (The required privileges will vary from implementation to
 implementation.  On some implementations they are the right to modify the
 contents of some directory in the file system; on others they are the right
 to modify contents of some key in a registry.)  Under any of these
 circumstances it would generally be undesirable to let the program
 continue executing as if these operations would become permanent at a later
 time.  While implementations are not required to throw an exception under
 these circumstances they are encouraged to do so.  A  SecurityException  would be appropriate.

  Most of the SPI methods require the implementation to read or write
 information at a preferences node.  The implementor should beware of the
 fact that another VM may have concurrently deleted this node from the
 backing store.  It is the implementation's responsibility to recreate the
 node if it has been deleted.

  Implementation note: In Sun's default  Preferences 
 implementations the user's identity is inherited from the underlying
 operating system and does not change for the lifetime of the virtual
 machine.  It is recognized that server-side  Preferences 
 implementations may have the user identity change from request to request
 implicitly passed to  Preferences  methods via the use of a
 static  ThreadLocal  instance.  Authors of such implementations are
  strongly  encouraged to determine the user at the time preferences
 are accessed (for example by the  get(java.lang.String java.lang.String)  or  put(java.lang.String java.lang.String)  method) rather than permanently associating a user
 with each  Preferences  instance.  The latter behavior conflicts
 with normal  Preferences  usage and would lead to great confusion."
android,java.util.prefs,NodeChangeEvent,2,"An event emitted by a  Preferences  node to indicate that
 a child of that node has been added or removed. 

 Note that although NodeChangeEvent inherits Serializable interface from
 java.util.EventObject it is not intended to be Serializable. Appropriate
 serialization methods are implemented to throw NotSerializableException."
android,java.util.prefs,PreferenceChangeEvent,3,"An event emitted by a  Preferences  node to indicate that
 a preference has been added removed or has had its value changed. 

 Note that although PreferenceChangeEvent inherits Serializable interface
 from EventObject it is not intended to be Serializable. Appropriate
 serialization methods are implemented to throw NotSerializableException."
android,java.util.prefs,Preferences,39,"A node in a hierarchical collection of preference data.  This class
 allows applications to store and retrieve user and system
 preference and configuration data.  This data is stored
 persistently in an implementation-dependent backing store.  Typical
 implementations include flat files OS-specific registries
 directory servers and SQL databases.  The user of this class needn't
 be concerned with details of the backing store.

  There are two separate trees of preference nodes one for user
 preferences and one for system preferences.  Each user has a separate user
 preference tree and all users in a given system share the same system
 preference tree.  The precise description of ""user"" and ""system"" will vary
 from implementation to implementation.  Typical information stored in the
 user preference tree might include font choice color choice or preferred
 window location and size for a particular application.  Typical information
 stored in the system preference tree might include installation
 configuration data for an application.

  Nodes in a preference tree are named in a similar fashion to
 directories in a hierarchical file system.   Every node in a preference
 tree has a  node name  (which is not necessarily unique)
 a unique  absolute path name  and a path name  relative  to each
 ancestor including itself.

  The root node has a node name of the empty string ("""").  Every other
 node has an arbitrary node name specified at the time it is created.  The
 only restrictions on this name are that it cannot be the empty string and
 it cannot contain the slash character ('/').

  The root node has an absolute path name of  ""/"" .  Children of
 the root node have absolute path names of  ""/"" +  <node
 name> .  All other nodes have absolute path names of  <parent's
 absolute path name>  + ""/"" +  <node name> .
 Note that all absolute path names begin with the slash character.

  A node  n 's path name relative to its ancestor  a 
 is simply the string that must be appended to  a 's absolute path name
 in order to form  n 's absolute path name with the initial slash
 character (if present) removed.  Note that:
  No relative path names begin with the slash character.
  Every node's path name relative to itself is the empty string.
  Every node's path name relative to its parent is its node name (except
 for the root node which does not have a parent).
  Every node's path name relative to the root is its absolute path name
 with the initial slash character removed.
  Note finally that:
  No path name contains multiple consecutive slash characters.
  No path name with the exception of the root's absolute path name
 ends in the slash character.
  Any string that conforms to these two rules is a valid path name.
  All of the methods that modify preferences data are permitted to operate
 asynchronously; they may return immediately and changes will eventually
 propagate to the persistent backing store with an implementation-dependent
 delay.  The  flush  method may be used to synchronously force
 updates to the backing store.  Normal termination of the Java Virtual
 Machine will  not  result in the loss of pending updates -- an explicit
  flush  invocation is  not  required upon termination to ensure
 that pending updates are made persistent.

  All of the methods that read preferences from a  Preferences 
 object require the invoker to provide a default value.  The default value is
 returned if no value has been previously set  or if the backing store is
 unavailable .  The intent is to allow applications to operate albeit
 with slightly degraded functionality even if the backing store becomes
 unavailable.  Several methods like  flush  have semantics that
 prevent them from operating if the backing store is unavailable.  Ordinary
 applications should have no need to invoke any of these methods which can
 be identified by the fact that they are declared to throw  BackingStoreException .

  The methods in this class may be invoked concurrently by multiple threads
 in a single JVM without the need for external synchronization and the
 results will be equivalent to some serial execution.  If this class is used
 concurrently  by multiple JVMs  that store their preference data in
 the same backing store the data store will not be corrupted but no
 other guarantees are made concerning the consistency of the preference
 data.

  This class contains an export/import facility allowing preferences
 to be ""exported"" to an XML document and XML documents representing
 preferences to be ""imported"" back into the system.  This facility
 may be used to back up all or part of a preference tree and
 subsequently restore from the backup.

  The XML document has the following DOCTYPE declaration:
  <!DOCTYPE preferences SYSTEM ""http://java.sun.com/dtd/preferences.dtd"">
  not <?xml version=""1.0"" encoding=""UTF-8""?>

    <!-- DTD for a Preferences tree. -->

    <!-- The preferences element is at the root of an XML document
         representing a Preferences tree. -->
    <!ELEMENT preferences (root)>

    <!-- The preferences element contains an optional version attribute
          which specifies version of DTD. -->
    <!ATTLIST preferences EXTERNAL_XML_VERSION CDATA ""0.0"" >

    <!-- The root element has a map representing the root's preferences
         (if any) and one node for each child of the root (if any). -->
    <!ELEMENT root (map node*) >

    <!-- Additionally the root contains a type attribute which
         specifies whether it's the system or user root. -->
    <!ATTLIST root
              type (system|user) #REQUIRED >

    <!-- Each node has a map representing its preferences (if any)
         and one node for each child (if any). -->
    <!ELEMENT node (map node*) >

    <!-- Additionally each node has a name attribute -->
    <!ATTLIST node
              name CDATA #REQUIRED >

    <!-- A map represents the preferences stored at a node (if any). -->
    <!ELEMENT map (entry*) >

    <!-- An entry represents a single preference which is simply
          a key-value pair. -->
    <!ELEMENT entry EMPTY >
    <!ATTLIST entry
              key   CDATA #REQUIRED
              value CDATA #REQUIRED >
  Preferences PreferencesFactory PreferencesFactory Implementation note: In Sun's JRE the  PreferencesFactory 
 implementation is located as follows:

  If the system property
  java.util.prefs.PreferencesFactory  is defined then it is
 taken to be the fully-qualified name of a class implementing the
  PreferencesFactory  interface.  The class is loaded and
 instantiated; if this process fails then an unspecified error is
 thrown.  If a  PreferencesFactory  implementation class file
 has been installed in a jar file that is visible to the
  system class loader 
 and that jar file contains a provider-configuration file named
  java.util.prefs.PreferencesFactory  in the resource
 directory  META-INF/services  then the first class name
 specified in that file is taken.  If more than one such jar file is
 provided the first one found will be used.  The class is loaded
 and instantiated; if this process fails then an unspecified error
 is thrown.   Finally if neither the above-mentioned system property nor
 an extension jar file is provided then the system-wide default
  PreferencesFactory  implementation for the underlying
 platform is loaded and instantiated."
android,java.util.logging,ConsoleHandler,2,"This  Handler  publishes log records to  System.err .
 By default the  SimpleFormatter  is used to generate brief summaries.
  Configuration: 
 By default each  ConsoleHandler  is initialized using the following
  LogManager  configuration properties where  <handler-name> 
 refers to the fully-qualified class name of the handler.
 If properties are not defined
 (or have invalid values) then the specified default values are used.
     <handler-name>.level
        specifies the default level for the  Handler 
        (defaults to  Level.INFO ).     <handler-name>.filter
        specifies the name of a  Filter  class to use
        (defaults to no  Filter ).     <handler-name>.formatter
        specifies the name of a  Formatter  class to use
        (defaults to  java.util.logging.SimpleFormatter ).     <handler-name>.encoding
        the name of the character set encoding to use (defaults to
        the default platform encoding).  
 For example the properties for  ConsoleHandler  would be:
     java.util.logging.ConsoleHandler.level=INFO     java.util.logging.ConsoleHandler.formatter=java.util.logging.SimpleFormatter  
 For a custom handler e.g. com.foo.MyHandler the properties would be:
     com.foo.MyHandler.level=INFO     com.foo.MyHandler.formatter=java.util.logging.SimpleFormatter"
android,java.util.logging,ErrorManager,1,"ErrorManager objects can be attached to Handlers to process
 any error that occurs on a Handler during Logging.
  
 When processing logging output if a Handler encounters problems
 then rather than throwing an Exception back to the issuer of
 the logging call (who is unlikely to be interested) the Handler
 should call its associated ErrorManager."
android,java.util.logging,FileHandler,2,"Simple file logging  Handler .
  
 The  FileHandler  can either write to a specified file
 or it can write to a rotating set of files.
  
 For a rotating set of files as each file reaches a given size
 limit it is closed rotated out and a new file opened.
 Successively older files are named by adding ""0"" ""1"" ""2""
 etc. into the base filename.
  
 By default buffering is enabled in the IO libraries but each log
 record is flushed out when it is complete.
  
 By default the  XMLFormatter  class is used for formatting.
  Configuration: 
 By default each  FileHandler  is initialized using the following
  LogManager  configuration properties where  <handler-name> 
 refers to the fully-qualified class name of the handler.
 If properties are not defined
 (or have invalid values) then the specified default values are used.
     <handler-name>.level
        specifies the default level for the  Handler 
        (defaults to  Level.ALL ).     <handler-name>.filter
        specifies the name of a  Filter  class to use
        (defaults to no  Filter ).     <handler-name>.formatter
        specifies the name of a  Formatter  class to use
        (defaults to  java.util.logging.XMLFormatter )     <handler-name>.encoding
        the name of the character set encoding to use (defaults to
        the default platform encoding).     <handler-name>.limit
        specifies an approximate maximum amount to write (in bytes)
        to any one file.  If this is zero then there is no limit.
        (Defaults to no limit).     <handler-name>.count
        specifies how many output files to cycle through (defaults to 1).     <handler-name>.pattern
        specifies a pattern for generating the output file name.  See
        below for details. (Defaults to ""%h/java%u.log"").     <handler-name>.append
        specifies whether the FileHandler should append onto
        any existing files (defaults to false).  
 For example the properties for  FileHandler  would be:
     java.util.logging.FileHandler.level=INFO     java.util.logging.FileHandler.formatter=java.util.logging.SimpleFormatter  
 For a custom handler e.g. com.foo.MyHandler the properties would be:
     com.foo.MyHandler.level=INFO     com.foo.MyHandler.formatter=java.util.logging.SimpleFormatter  
 A pattern consists of a string that includes the following special
 components that will be replaced at runtime:
      ""/""    the local pathname separator       ""%t""   the system temporary directory       ""%h""   the value of the ""user.home"" system property       ""%g""   the generation number to distinguish rotated logs       ""%u""   a unique number to resolve conflicts       ""%%""   translates to a single percent sign ""%""  
 Thus for example a pattern of ""%t/java%g.log"" with a count of 2
 would typically cause log files to be written on Solaris to
 /var/tmp/java0.log and /var/tmp/java1.log whereas on Windows 95 they
 would be typically written to C:\TEMP\java0.log and C:\TEMP\java1.log
  
 Generation numbers follow the sequence 0 1 2 etc.
  
 Normally the ""%u"" unique field is set to 0.  However if the  FileHandler 
 tries to open the filename and finds the file is currently in use by
 another process it will increment the unique number field and try
 again.  This will be repeated until  FileHandler  finds a file name that
 is  not currently in use. If there is a conflict and no ""%u"" field has
 been specified it will be added at the end of the filename after a dot.
 (This will be after any automatically added generation number.)
  
 Thus if three processes were all trying to log to fred%u.%g.txt then
 they  might end up using fred0.0.txt fred1.0.txt fred2.0.txt as
 the first file in their rotating sequences.
  
 Note that the use of unique ids to avoid conflicts is only guaranteed
 to work reliably when using a local disk file system."
android,java.util.logging,Formatter,4,"A Formatter provides support for formatting LogRecords.
  
 Typically each logging Handler will have a Formatter associated
 with it.  The Formatter takes a LogRecord and converts it to
 a string.
  
 Some formatters (such as the XMLFormatter) need to wrap head
 and tail strings around a set of formatted records. The getHeader
 and getTail methods can be used to obtain these strings."
android,java.util.logging,Handler,15,"A  Handler  object takes log messages from a  Logger  and
 exports them.  It might for example write them to a console
 or write them to a file or send them to a network logging service
 or forward them to an OS log or whatever.
  
 A  Handler  can be disabled by doing a  setLevel(Level.OFF) 
 and can  be re-enabled by doing a  setLevel  with an appropriate level.
  Handler  classes typically use  LogManager  properties to set
 default values for the  Handler 's  Filter   Formatter 
 and  Level .  See the specific documentation for each concrete
  Handler  class."
android,java.util.logging,Level,8,"The Level class defines a set of standard logging levels that
 can be used to control logging output.  The logging Level objects
 are ordered and are specified by ordered integers.  Enabling logging
 at a given level also enables logging at all higher levels.
  
 Clients should normally use the predefined Level constants such
 as Level.SEVERE.
  
 The levels in descending order are:
  SEVERE (highest value)
  WARNING
  INFO
  CONFIG
  FINE
  FINER
  FINEST  (lowest value)
  
 It is possible for third parties to define additional logging
 levels by subclassing Level.  In such cases subclasses should
 take care to chose unique integer level values and to ensure that
 they maintain the Object uniqueness property across serialization
 by defining a suitable readResolve method."
android,java.util.logging,Logger,60,"A Logger object is used to log messages for a specific
 system or application component.  Loggers are normally named
 using a hierarchical dot-separated namespace.  Logger names
 can be arbitrary strings but they should normally be based on
 the package name or class name of the logged component such
 as java.net or javax.swing.  In addition it is possible to create
 ""anonymous"" Loggers that are not stored in the Logger namespace.
  
 Logger objects may be obtained by calls on one of the getLogger
 factory methods.  These will either create a new Logger or
 return a suitable existing Logger. It is important to note that
 the Logger returned by one of the  getLogger  factory methods
 may be garbage collected at any time if a strong reference to the
 Logger is not kept.
  
 Logging messages will be forwarded to registered Handler
 objects which can forward the messages to a variety of
 destinations including consoles files OS logs etc.
  
 Each Logger keeps track of a ""parent"" Logger which is its
 nearest existing ancestor in the Logger namespace.
  
 Each Logger has a ""Level"" associated with it.  This reflects
 a minimum Level that this logger cares about.  If a Logger's
 level is set to  null  then its effective level is inherited
 from its parent which may in turn obtain it recursively from its
 parent and so on up the tree.
  
 The log level can be configured based on the properties from the
 logging configuration file as described in the description
 of the LogManager class.  However it may also be dynamically changed
 by calls on the Logger.setLevel method.  If a logger's level is
 changed the change may also affect child loggers since any child
 logger that has  null  as its level will inherit its
 effective level from its parent.
  
 On each logging call the Logger initially performs a cheap
 check of the request level (e.g. SEVERE or FINE) against the
 effective log level of the logger.  If the request level is
 lower than the log level the logging call returns immediately.
  
 After passing this initial (cheap) test the Logger will allocate
 a LogRecord to describe the logging message.  It will then call a
 Filter (if present) to do a more detailed check on whether the
 record should be published.  If that passes it will then publish
 the LogRecord to its output Handlers.  By default loggers also
 publish to their parent's Handlers recursively up the tree.
  
 Each Logger may have a  ResourceBundle  associated with it.
 The  ResourceBundle  may be specified by name using the
  getLogger(java.lang.String java.lang.String)  factory
 method or by value - using the  setResourceBundle  method.
 This bundle will be used for localizing logging messages.
 If a Logger does not have its own  ResourceBundle  or resource bundle
 name then it will inherit the  ResourceBundle  or resource bundle name
 from its parent recursively up the tree.
  
 Most of the logger output methods take a ""msg"" argument.  This
 msg argument may be either a raw value or a localization key.
 During formatting if the logger has (or inherits) a localization
  ResourceBundle  and if the  ResourceBundle  has a mapping for
 the msg string then the msg string is replaced by the localized value.
 Otherwise the original msg string is used.  Typically formatters use
 java.text.MessageFormat style formatting to format parameters so
 for example a format string ""{0} {1}"" would format two parameters
 as strings.
  
 A set of methods alternatively take a ""msgSupplier"" instead of a ""msg""
 argument.  These methods take a  Supplier <String>  function
 which is invoked to construct the desired log message only when the message
 actually is to be logged based on the effective log level thus eliminating
 unnecessary message construction. For example if the developer wants to
 log system health status for diagnosis with the String-accepting version
 the code would look like:
  
 
   class DiagnosisMessages {
     static String systemHealthStatus() {
       // collect system health information
       ...
     }
   }
   ...
   logger.log(Level.FINER DiagnosisMessages.systemHealthStatus());
  
 
   logger.log(Level.FINER DiagnosisMessages::systemHealthStatus);
  
 When looking for a  ResourceBundle  the logger will first look at
 whether a bundle was specified using  setResourceBundle  and then
 only whether a resource bundle name was specified through the  getLogger  factory method.
 If no  ResourceBundle  or no resource bundle name is found
 then it will use the nearest  ResourceBundle  or resource bundle
 name inherited from its parent tree. 
 When a  ResourceBundle  was inherited or specified through the
  setResourceBundle  method then
 that  ResourceBundle  will be used. Otherwise if the logger only
 has or inherited a resource bundle name then that resource bundle name
 will be mapped to a  ResourceBundle  object using the default Locale
 at the time of logging.
  When mapping resource bundle names to
  ResourceBundle  objects the logger will first try to use the
 Thread's  context class
 loader  to map the given resource bundle name to a  ResourceBundle .
 If the thread context class loader is  null  it will try the
  system class loader 
 instead.  If the  ResourceBundle  is still not found it will use the
 class loader of the first caller of the  getLogger  factory method.
  
 Formatting (including localization) is the responsibility of
 the output Handler which will typically call a Formatter.
  
 Note that formatting need not occur synchronously.  It may be delayed
 until a LogRecord is actually written to an external sink.
  
 The logging methods are grouped in five main categories:
  
     There are a set of ""log"" methods that take a log level a message
     string and optionally some parameters to the message string.
  
     There are a set of ""logp"" methods (for ""log precise"") that are
     like the ""log"" methods but also take an explicit source class name
     and method name.
  
     There are a set of ""logrb"" method (for ""log with resource bundle"")
     that are like the ""logp"" method but also take an explicit resource
     bundle object for use in localizing the log message.
  
     There are convenience methods for tracing method entries (the
     ""entering"" methods) method returns (the ""exiting"" methods) and
     throwing exceptions (the ""throwing"" methods).
  
     Finally there are a set of convenience methods for use in the
     very simplest cases when a developer simply wants to log a
     simple string at a given log level.  These methods are named
     after the standard Level names (""severe"" ""warning"" ""info"" etc.)
     and take a single argument a message string.
  
 For the methods that do not take an explicit source name and
 method name the Logging framework will make a ""best effort""
 to determine which class and method called into the logging method.
 However it is important to realize that this automatically inferred
 information may only be approximate (or may even be quite wrong!).
 Virtual machines are allowed to do extensive optimizations when
 JITing and may entirely remove stack frames making it impossible
 to reliably locate the calling class and method.
  
 All methods on Logger are multi-thread safe.
  Subclassing Information:  Note that a LogManager class may
 provide its own implementation of named Loggers for any point in
 the namespace.  Therefore any subclasses of Logger (unless they
 are implemented in conjunction with a new LogManager class) should
 take care to obtain a Logger instance from the LogManager class and
 should delegate operations such as ""isLoggable"" and ""log(LogRecord)""
 to that instance.  Note that in order to intercept all logging
 output subclasses need only override the log(LogRecord) method.
 All the other logging methods are implemented as calls on this
 log(LogRecord) method."
android,java.util.logging,LoggingPermission,0,Legacy security code; do not use.
android,java.util.logging,LogManager,12,"There is a single global LogManager object that is used to
 maintain a set of shared state about Loggers and log services.
  
 This LogManager object:
   Manages a hierarchical namespace of Logger objects.  All
      named Loggers are stored in this namespace.
   Manages a set of logging control properties.  These are
      simple key-value pairs that can be used by Handlers and
      other logging objects to configure themselves.
  
 The global LogManager object can be retrieved using LogManager.getLogManager().
 The LogManager object is created during class initialization and
 cannot subsequently be changed.
  
 At startup the LogManager class is located using the
 java.util.logging.manager system property.
  
 The LogManager defines two optional system properties that allow control over
 the initial configuration:
  ""java.util.logging.config.class""
  ""java.util.logging.config.file""
  
 If the ""java.util.logging.config.class"" property is set then the
 property value is treated as a class name.  The given class will be
 loaded an object will be instantiated and that object's constructor
 is responsible for reading in the initial configuration.  (That object
 may use other system properties to control its configuration.)  The
 alternate configuration class can use  readConfiguration(InputStream) 
 to define properties in the LogManager.
  
 If ""java.util.logging.config.class"" property is  not  set
 then the ""java.util.logging.config.file"" system property can be used
 to specify a properties file (in java.util.Properties format). The
 initial logging configuration will be read from this file.
  
 If neither of these properties is defined then the LogManager uses its
 default configuration. The default configuration is typically loaded from the
 properties file "" lib/logging.properties "" in the Java installation
 directory.
  
 The properties for loggers and Handlers will have names starting
 with the dot-separated name for the handler or logger.
  
 The global logging properties may include:
  A property ""handlers"".  This defines a whitespace or comma separated
 list of class names for handler classes to load and register as
 handlers on the root Logger (the Logger named """").  Each class
 name must be for a Handler class which has a default constructor.
 Note that these Handlers may be created lazily when they are
 first used.

  A property ""<logger>.handlers"". This defines a whitespace or
 comma separated list of class names for handlers classes to
 load and register as handlers to the specified logger. Each class
 name must be for a Handler class which has a default constructor.
 Note that these Handlers may be created lazily when they are
 first used.

  A property ""<logger>.useParentHandlers"". This defines a boolean
 value. By default every logger calls its parent in addition to
 handling the logging message itself this often result in messages
 being handled by the root logger as well. When setting this property
 to false a Handler needs to be configured for this logger otherwise
 no logging messages are delivered.

  A property ""config"".  This property is intended to allow
 arbitrary configuration code to be run.  The property defines a
 whitespace or comma separated list of class names.  A new instance will be
 created for each named class.  The default constructor of each class
 may execute arbitrary code to update the logging configuration such as
 setting logger levels adding handlers adding filters etc.
  
 Note that all classes loaded during LogManager configuration are
 first searched on the system class path before any user class path.
 That includes the LogManager class any config classes and any
 handler classes.
  
 Loggers are organized into a naming hierarchy based on their
 dot separated names.  Thus ""a.b.c"" is a child of ""a.b"" but
 ""a.b1"" and a.b2"" are peers.
  
 All properties whose names end with "".level"" are assumed to define
 log levels for Loggers.  Thus ""foo.level"" defines a log level for
 the logger called ""foo"" and (recursively) for any of its children
 in the naming hierarchy.  Log Levels are applied in the order they
 are defined in the properties file.  Thus level settings for child
 nodes in the tree should come after settings for their parents.
 The property name "".level"" can be used to set the level for the
 root of the tree.
  
 All methods on the LogManager object are multi-thread safe."
android,java.util.logging,LogRecord,24,"LogRecord objects are used to pass logging requests between
 the logging framework and individual log Handlers.
  
 When a LogRecord is passed into the logging framework it
 logically belongs to the framework and should no longer be
 used or updated by the client application.
  
 Note that if the client application has not specified an
 explicit source method name and source class name then the
 LogRecord class will infer them automatically when they are
 first accessed (due to a call on getSourceMethodName or
 getSourceClassName) by analyzing the call stack.  Therefore
 if a logging Handler wants to pass off a LogRecord to another
 thread or to transmit it over RMI and if it wishes to subsequently
 obtain method name or class name information it should call
 one of getSourceClassName or getSourceMethodName to force
 the values to be filled in.
   Serialization notes: The LogRecord class is serializable.

   Because objects in the parameters array may not be serializable
 during serialization all objects in the parameters array are
 written as the corresponding Strings (using Object.toString).

   The ResourceBundle is not transmitted as part of the serialized
 form but the resource bundle name is and the recipient object's
 readObject method will attempt to locate a suitable resource bundle."
android,java.util.logging,MemoryHandler,7,"Handler  that buffers requests in a circular buffer in memory.
  
 Normally this  Handler  simply stores incoming  LogRecords 
 into its memory buffer and discards earlier records.  This buffering
 is very cheap and avoids formatting costs.  On certain trigger
 conditions the  MemoryHandler  will push out its current buffer
 contents to a target  Handler  which will typically publish
 them to the outside world.
  
 There are three main models for triggering a push of the buffer:
  
 An incoming  LogRecord  has a type that is greater than
 a pre-defined level the  pushLevel .  
 An external class calls the  push  method explicitly.  
 A subclass overrides the  log  method and scans each incoming
  LogRecord  and calls  push  if a record matches some
 desired criteria.  Configuration: 
 By default each  MemoryHandler  is initialized using the following
  LogManager  configuration properties where  <handler-name> 
 refers to the fully-qualified class name of the handler.
 If properties are not defined
 (or have invalid values) then the specified default values are used.
 If no default value is defined then a RuntimeException is thrown.
     <handler-name>.level
        specifies the level for the  Handler 
        (defaults to  Level.ALL ).     <handler-name>.filter
        specifies the name of a  Filter  class to use
        (defaults to no  Filter ).     <handler-name>.size
        defines the buffer size (defaults to 1000).     <handler-name>.push
        defines the  pushLevel  (defaults to  level.SEVERE ).     <handler-name>.target
        specifies the name of the target  Handler   class.
        (no default).  
 For example the properties for  MemoryHandler  would be:
     java.util.logging.MemoryHandler.level=INFO     java.util.logging.MemoryHandler.formatter=java.util.logging.SimpleFormatter  
 For a custom handler e.g. com.foo.MyHandler the properties would be:
     com.foo.MyHandler.level=INFO     com.foo.MyHandler.formatter=java.util.logging.SimpleFormatter"
android,java.util.logging,SimpleFormatter,1,"Print a brief summary of the  LogRecord  in a human readable
 format.  The summary will typically be 1 or 2 lines.

  Configuration: 
 The  SimpleFormatter  is initialized with the
  format string 
 specified in the  java.util.logging.SimpleFormatter.format 
 property to  format  the log messages.
 This property can be defined
 in the  LogManager#getProperty 
 configuration file
 or as a system property.  If this property is set in both
 the logging properties and system properties
 the format string specified in the system property will be used.
 If this property is not defined or the given format string
 is  illegal 
 the default format is implementation-specific."
android,java.util.logging,SocketHandler,2,"Simple network logging  Handler .
  LogRecords  are published to a network stream connection.  By default
 the  XMLFormatter  class is used for formatting.
  Configuration: 
 By default each  SocketHandler  is initialized using the following
  LogManager  configuration properties where  <handler-name> 
 refers to the fully-qualified class name of the handler.
 If properties are not defined
 (or have invalid values) then the specified default values are used.
     <handler-name>.level
        specifies the default level for the  Handler 
        (defaults to  Level.ALL ).     <handler-name>.filter
        specifies the name of a  Filter  class to use
        (defaults to no  Filter ).     <handler-name>.formatter
        specifies the name of a  Formatter  class to use
        (defaults to  java.util.logging.XMLFormatter ).     <handler-name>.encoding
        the name of the character set encoding to use (defaults to
        the default platform encoding).     <handler-name>.host
        specifies the target host name to connect to (no default).     <handler-name>.port
        specifies the target TCP port to use (no default).  
 For example the properties for  SocketHandler  would be:
     java.util.logging.SocketHandler.level=INFO     java.util.logging.SocketHandler.formatter=java.util.logging.SimpleFormatter  
 For a custom handler e.g. com.foo.MyHandler the properties would be:
     com.foo.MyHandler.level=INFO     com.foo.MyHandler.formatter=java.util.logging.SimpleFormatter  
 The output IO stream is buffered but is flushed after each
  LogRecord  is written."
android,java.util.logging,StreamHandler,6,"Stream based logging  Handler .
  
 This is primarily intended as a base class or support class to
 be used in implementing other logging  Handlers .
  LogRecords  are published to a given  java.io.OutputStream .
  Configuration: 
 By default each  StreamHandler  is initialized using the following
  LogManager  configuration properties where  <handler-name> 
 refers to the fully-qualified class name of the handler.
 If properties are not defined
 (or have invalid values) then the specified default values are used.
     <handler-name>.level
        specifies the default level for the  Handler 
        (defaults to  Level.INFO ).     <handler-name>.filter
        specifies the name of a  Filter  class to use
         (defaults to no  Filter ).     <handler-name>.formatter
        specifies the name of a  Formatter  class to use
        (defaults to  java.util.logging.SimpleFormatter ).     <handler-name>.encoding
        the name of the character set encoding to use (defaults to
        the default platform encoding).  
 For example the properties for  StreamHandler  would be:
     java.util.logging.StreamHandler.level=INFO     java.util.logging.StreamHandler.formatter=java.util.logging.SimpleFormatter  
 For a custom handler e.g. com.foo.MyHandler the properties would be:
     com.foo.MyHandler.level=INFO     com.foo.MyHandler.formatter=java.util.logging.SimpleFormatter"
android,java.util.logging,XMLFormatter,3,"Format a LogRecord into a standard XML format.
  
 The DTD specification is provided as Appendix A to the
 Java Logging APIs specification.
  
 The XMLFormatter can be used with arbitrary character encodings
 but it is recommended that it normally be used with UTF-8.  The
 character encoding can be set on the output Handler."
android,java.util.regex,Matcher,34,"An engine that performs match operations on a  character sequence  by interpreting a  Pattern .

   A matcher is created from a pattern by invoking the pattern's  Pattern#matcher  method.  Once created a matcher can be used to
 perform three different kinds of match operations:

   The  matches  method attempts to match the entire
   input sequence against the pattern.    The  lookingAt  method attempts to match the
   input sequence starting at the beginning against the pattern.    The  find  method scans the input sequence looking for
   the next subsequence that matches the pattern.    Each of these methods returns a boolean indicating success or failure.
 More information about a successful match can be obtained by querying the
 state of the matcher.

   A matcher finds matches in a subset of its input called the
  region . By default the region contains all of the matcher's input.
 The region can be modified via the region  method and queried
 via the  regionStart  and  regionEnd 
 methods. The way that the region boundaries interact with some pattern
 constructs can be changed. See  useAnchoringBounds  and  useTransparentBounds 
 for more details.

   This class also defines methods for replacing matched subsequences with
 new strings whose contents can if desired be computed from the match
 result.  The  appendReplacement  and  appendTail  methods can be used in tandem in order to collect
 the result into an existing string buffer or the more convenient  replaceAll  method can be used to create a string in which every
 matching subsequence in the input sequence is replaced.

   The explicit state of a matcher includes the start and end indices of
 the most recent successful match.  It also includes the start and end
 indices of the input subsequence captured by each  capturing group  in the pattern as well as a total
 count of such subsequences.  As a convenience methods are also provided for
 returning these captured subsequences in string form.

   The explicit state of a matcher is initially undefined; attempting to
 query any part of it before a successful match will cause an  IllegalStateException  to be thrown.  The explicit state of a matcher is
 recomputed by every match operation.

   The implicit state of a matcher includes the input character sequence as
 well as the  append position  which is initially zero and is updated
 by the  appendReplacement  method.

   A matcher may be reset explicitly by invoking its  reset() 
 method or if a new input sequence is desired its  reset(CharSequence)  method.  Resetting a
 matcher discards its explicit state information and sets the append position
 to zero.

   Instances of this class are not safe for use by multiple concurrent
 threads."
android,java.util.stream,Collectors,37,"Implementations of  Collector  that implement various useful reduction
 operations such as accumulating elements into collections summarizing
 elements according to various criteria etc.

  The following are examples of using the predefined collectors to perform
 common mutable reduction tasks:

  // Accumulate names into a List
     List<String> list = people.stream().map(Person::getName).collect(Collectors.toList());

     // Accumulate names into a TreeSet
     Set<String> set = people.stream().map(Person::getName).collect(Collectors.toCollection(TreeSet::new));

     // Convert elements to strings and concatenate them separated by commas
     String joined = things.stream()
                           .map(Object::toString)
                           .collect(Collectors.joining("" ""));

     // Compute sum of salaries of employee
     int total = employees.stream()
                          .collect(Collectors.summingInt(Employee::getSalary)));

     // Group employees by department
     Map<Department List<Employee>> byDept
         = employees.stream()
                    .collect(Collectors.groupingBy(Employee::getDepartment));

     // Compute sum of salaries by department
     Map<Department Integer> totalByDept
         = employees.stream()
                    .collect(Collectors.groupingBy(Employee::getDepartment
                                                   Collectors.summingInt(Employee::getSalary)));

     // Partition students into passing and failing
     Map<Boolean List<Student>> passingFailing =
         students.stream()
                 .collect(Collectors.partitioningBy(s -> s.getGrade() >= PASS_THRESHOLD));"
android,java.util.stream,StreamSupport,8,"Low-level utility methods for creating and manipulating streams.

  This class is mostly for library writers presenting stream views
 of data structures; most static stream methods intended for end users are in
 the various  Stream  classes."
android,java.util.concurrent.atomic,AtomicBoolean,7,"A  boolean  value that may be updated atomically. See the
  java.util.concurrent.atomic  package specification for
 description of the properties of atomic variables. An
  AtomicBoolean  is used in applications such as atomically
 updated flags and cannot be used as a replacement for a
  Boolean ."
android,java.util.concurrent.atomic,AtomicInteger,21,"An  int  value that may be updated atomically.  See the
  java.util.concurrent.atomic  package specification for
 description of the properties of atomic variables. An
  AtomicInteger  is used in applications such as atomically
 incremented counters and cannot be used as a replacement for an
  Integer . However this class does extend
  Number  to allow uniform access by tools and utilities that
 deal with numerically-based classes."
android,java.util.concurrent.atomic,AtomicIntegerArray,18,"An  int  array in which elements may be updated atomically.
 See the  java.util.concurrent.atomic  package
 specification for description of the properties of atomic
 variables."
android,java.util.concurrent.atomic,AtomicIntegerFieldUpdater,17,"A reflection-based utility that enables atomic updates to
 designated  volatile int  fields of designated classes.
 This class is designed for use in atomic data structures in which
 several fields of the same node are independently subject to atomic
 updates.

  Note that the guarantees of the  compareAndSet 
 method in this class are weaker than in other atomic classes.
 Because this class cannot ensure that all uses of the field
 are appropriate for purposes of atomic access it can
 guarantee atomicity only with respect to other invocations of
  compareAndSet  and  set  on the same updater."
android,java.util.concurrent.atomic,AtomicLong,21,"A  long  value that may be updated atomically.  See the
  java.util.concurrent.atomic  package specification for
 description of the properties of atomic variables. An
  AtomicLong  is used in applications such as atomically
 incremented sequence numbers and cannot be used as a replacement
 for a  Long . However this class does extend
  Number  to allow uniform access by tools and utilities that
 deal with numerically-based classes."
android,java.util.concurrent.atomic,AtomicLongArray,18,"A  long  array in which elements may be updated atomically.
 See the  java.util.concurrent.atomic  package specification
 for description of the properties of atomic variables."
android,java.util.concurrent.atomic,AtomicLongFieldUpdater,17,"A reflection-based utility that enables atomic updates to
 designated  volatile long  fields of designated classes.
 This class is designed for use in atomic data structures in which
 several fields of the same node are independently subject to atomic
 updates.

  Note that the guarantees of the  compareAndSet 
 method in this class are weaker than in other atomic classes.
 Because this class cannot ensure that all uses of the field
 are appropriate for purposes of atomic access it can
 guarantee atomicity only with respect to other invocations of
  compareAndSet  and  set  on the same updater."
android,java.util.concurrent.atomic,AtomicMarkableReference,7,"An  AtomicMarkableReference  maintains an object reference
 along with a mark bit that can be updated atomically.

  Implementation note: This implementation maintains markable
 references by creating internal objects representing ""boxed""
 [reference boolean] pairs."
android,java.util.concurrent.atomic,AtomicReferenceArray,12,"An array of object references in which elements may be updated
 atomically.  See the  java.util.concurrent.atomic  package
 specification for description of the properties of atomic
 variables."
android,java.util.concurrent.atomic,AtomicReference,11,"An object reference that may be updated atomically. See the  java.util.concurrent.atomic  package specification for description
 of the properties of atomic variables."
android,java.util.concurrent.atomic,AtomicReferenceFieldUpdater,11,"A reflection-based utility that enables atomic updates to
 designated  volatile  reference fields of designated
 classes.  This class is designed for use in atomic data structures
 in which several reference fields of the same node are
 independently subject to atomic updates. For example a tree node
 might be declared as

  class Node {
   private volatile Node left right;

   private static final AtomicReferenceFieldUpdater<Node Node> leftUpdater =
     AtomicReferenceFieldUpdater.newUpdater(Node.class Node.class ""left"");
   private static AtomicReferenceFieldUpdater<Node Node> rightUpdater =
     AtomicReferenceFieldUpdater.newUpdater(Node.class Node.class ""right"");

   Node getLeft() { return left; }
   boolean compareAndSetLeft(Node expect Node update) {
     return leftUpdater.compareAndSet(this expect update);
   }
   // ... and so on
 } Note that the guarantees of the  compareAndSet 
 method in this class are weaker than in other atomic classes.
 Because this class cannot ensure that all uses of the field
 are appropriate for purposes of atomic access it can
 guarantee atomicity only with respect to other invocations of
  compareAndSet  and  set  on the same updater."
android,java.util.concurrent.atomic,AtomicStampedReference,7,"An  AtomicStampedReference  maintains an object reference
 along with an integer ""stamp"" that can be updated atomically.

  Implementation note: This implementation maintains stamped
 references by creating internal objects representing ""boxed""
 [reference integer] pairs."
android,java.util.concurrent.atomic,DoubleAccumulator,9,"One or more variables that together maintain a running  double 
 value updated using a supplied function.  When updates (method
  accumulate(double) ) are contended across threads the set of variables
 may grow dynamically to reduce contention.  Method  get() 
 (or equivalently  doubleValue() ) returns the current value
 across the variables maintaining updates.

  This class is usually preferable to alternatives when multiple
 threads update a common value that is used for purposes such as
 summary statistics that are frequently updated but less frequently
 read.

  The supplied accumulator function should be side-effect-free
 since it may be re-applied when attempted updates fail due to
 contention among threads. The function is applied with the current
 value as its first argument and the given update as the second
 argument.  For example to maintain a running maximum value you
 could supply  Double::max  along with  Double.NEGATIVE_INFINITY  as the identity. The order of
 accumulation within or across threads is not guaranteed. Thus this
 class may not be applicable if numerical stability is required
 especially when combining values of substantially different orders
 of magnitude.

  Class  DoubleAdder  provides analogs of the functionality
 of this class for the common special case of maintaining sums.  The
 call  new DoubleAdder()  is equivalent to  new
 DoubleAccumulator((x y) -> x + y 0.0) .

  This class extends  Number  but does  not  define
 methods such as  equals   hashCode  and  compareTo  because instances are expected to be mutated and so are
 not useful as collection keys."
android,java.util.concurrent.atomic,DoubleAdder,9,"One or more variables that together maintain an initially zero
  double  sum.  When updates (method  add(double) ) are
 contended across threads the set of variables may grow dynamically
 to reduce contention.  Method  sum()  (or equivalently  doubleValue() ) returns the current total combined across the
 variables maintaining the sum. The order of accumulation within or
 across threads is not guaranteed. Thus this class may not be
 applicable if numerical stability is required especially when
 combining values of substantially different orders of magnitude.

  This class is usually preferable to alternatives when multiple
 threads update a common value that is used for purposes such as
 summary statistics that are frequently updated but less frequently
 read.

  This class extends  Number  but does  not  define
 methods such as  equals   hashCode  and  compareTo  because instances are expected to be mutated and so are
 not useful as collection keys."
android,java.util.concurrent.atomic,LongAccumulator,9,"One or more variables that together maintain a running  long 
 value updated using a supplied function.  When updates (method
  accumulate(long) ) are contended across threads the set of variables
 may grow dynamically to reduce contention.  Method  get() 
 (or equivalently  longValue() ) returns the current value
 across the variables maintaining updates.

  This class is usually preferable to  AtomicLong  when
 multiple threads update a common value that is used for purposes such
 as collecting statistics not for fine-grained synchronization
 control.  Under low update contention the two classes have similar
 characteristics. But under high contention expected throughput of
 this class is significantly higher at the expense of higher space
 consumption.

  The order of accumulation within or across threads is not
 guaranteed and cannot be depended upon so this class is only
 applicable to functions for which the order of accumulation does
 not matter. The supplied accumulator function should be
 side-effect-free since it may be re-applied when attempted updates
 fail due to contention among threads. The function is applied with
 the current value as its first argument and the given update as
 the second argument.  For example to maintain a running maximum
 value you could supply  Long::max  along with  Long.MIN_VALUE  as the identity.

  Class  LongAdder  provides analogs of the functionality of
 this class for the common special case of maintaining counts and
 sums.  The call  new LongAdder()  is equivalent to  new
 LongAccumulator((x y) -> x + y 0L .

  This class extends  Number  but does  not  define
 methods such as  equals   hashCode  and  compareTo  because instances are expected to be mutated and so are
 not useful as collection keys."
android,java.util.concurrent.atomic,LongAdder,11,"One or more variables that together maintain an initially zero
  long  sum.  When updates (method  add(long) ) are contended
 across threads the set of variables may grow dynamically to reduce
 contention. Method  sum()  (or equivalently  longValue() ) returns the current total combined across the
 variables maintaining the sum.

  This class is usually preferable to  AtomicLong  when
 multiple threads update a common sum that is used for purposes such
 as collecting statistics not for fine-grained synchronization
 control.  Under low update contention the two classes have similar
 characteristics. But under high contention expected throughput of
 this class is significantly higher at the expense of higher space
 consumption.

  LongAdders can be used with a  ConcurrentHashMap  to maintain a scalable
 frequency map (a form of histogram or multiset). For example to
 add a count to a  ConcurrentHashMap<StringLongAdder> freqs 
 initializing if not already present you can use  freqs.computeIfAbsent(key k -> new LongAdder()).increment(); This class extends  Number  but does  not  define
 methods such as  equals   hashCode  and  compareTo  because instances are expected to be mutated and so are
 not useful as collection keys."
android,java.util.zip,Adler32,6,"A class that can be used to compute the Adler-32 checksum of a data
 stream. An Adler-32 checksum is almost as reliable as a CRC-32 but
 can be computed much faster.

   Passing a  null  argument to a method in this class will cause
 a  NullPointerException  to be thrown."
android,java.util.zip,CheckedInputStream,4,"An input stream that also maintains a checksum of the data being read.
 The checksum can then be used to verify the integrity of the input data."
android,java.util.zip,CheckedOutputStream,3,"An output stream that also maintains a checksum of the data being
 written. The checksum can then be used to verify the integrity of
 the output data."
android,java.util.zip,CRC32,6,"A class that can be used to compute the CRC-32 of a data stream.

   Passing a  null  argument to a method in this class will cause
 a  NullPointerException  to be thrown."
android,java.util.zip,Deflater,20,"This class provides support for general purpose compression using the
 popular ZLIB compression library. The ZLIB compression library was
 initially developed as part of the PNG graphics standard and is not
 protected by patents. It is fully described in the specifications at
 the  java.util.zip
 package description .

  The following code fragment demonstrates a trivial compression
 and decompression of a string using  Deflater  and
  Inflater .

  
 try {
     // Encode a String into bytes
     String inputString = ""blahblahblah"";
     byte[] input = inputString.getBytes(""UTF-8"");

     // Compress the bytes
     byte[] output = new byte[100];
     Deflater compresser = new Deflater();
     compresser.setInput(input);
     compresser.finish();
     int compressedDataLength = compresser.deflate(output);
     compresser.end();

     // Decompress the bytes
     Inflater decompresser = new Inflater();
     decompresser.setInput(output 0 compressedDataLength);
     byte[] result = new byte[100];
     int resultLength = decompresser.inflate(result);
     decompresser.end();

     // Decode the bytes into a String
     String outputString = new String(result 0 resultLength ""UTF-8"");
 } catch(java.io.UnsupportedEncodingException ex) {
     // handle
 } catch (java.util.zip.DataFormatException ex) {
     // handle
 }"
android,java.util.zip,DeflaterInputStream,8,"Implements an input stream filter for compressing data in the ""deflate""
 compression format."
android,java.util.zip,DeflaterOutputStream,6,"This class implements an output stream filter for compressing data in
 the ""deflate"" compression format. It is also used as the basis for other
 types of compression filters such as GZIPOutputStream."
android,java.util.zip,InflaterInputStream,9,"This class implements a stream filter for uncompressing data in the
 ""deflate"" compression format. It is also used as the basis for other
 decompression filters such as GZIPInputStream."
android,java.util.zip,ZipOutputStream,8,"This class implements an output stream filter for writing files in the
 ZIP file format. Includes support for both compressed and uncompressed
 entries."
android,java.util.zip,GZIPInputStream,2,"This class implements a stream filter for reading compressed data in
 the GZIP file format."
android,java.util.zip,GZIPOutputStream,2,"This class implements a stream filter for writing compressed data in
 the GZIP file format."
android,java.util.zip,Inflater,18,"This class provides support for general purpose decompression using the
 popular ZLIB compression library. The ZLIB compression library was
 initially developed as part of the PNG graphics standard and is not
 protected by patents. It is fully described in the specifications at
 the  java.util.zip
 package description .

  The following code fragment demonstrates a trivial compression
 and decompression of a string using  Deflater  and
  Inflater .

  
 try {
     // Encode a String into bytes
     String inputString = ""blahblahblahâ‚¬â‚¬"";
     byte[] input = inputString.getBytes(""UTF-8"");

     // Compress the bytes
     byte[] output = new byte[100];
     Deflater compresser = new Deflater();
     compresser.setInput(input);
     compresser.finish();
     int compressedDataLength = compresser.deflate(output);

     // Decompress the bytes
     Inflater decompresser = new Inflater();
     decompresser.setInput(output 0 compressedDataLength);
     byte[] result = new byte[100];
     int resultLength = decompresser.inflate(result);
     decompresser.end();

     // Decode the bytes into a String
     String outputString = new String(result 0 resultLength ""UTF-8"");
 } catch(java.io.UnsupportedEncodingException ex) {
     // handle
 } catch (java.util.zip.DataFormatException ex) {
     // handle
 }"
android,java.util.zip,InflaterOutputStream,5,"Implements an output stream filter for uncompressing data stored in the
 ""deflate"" compression format."
android,java.util.zip,ZipEntry,25,This class is used to represent a ZIP file entry.
android,java.util.zip,ZipFile,9,"This class is used to read entries from a zip file.

   Unless otherwise noted passing a  null  argument to a constructor
 or method in this class will cause a  NullPointerException  to be
 thrown."
android,java.util.zip,ZipInputStream,7,"This class implements an input stream filter for reading files in the
 ZIP file format. Includes support for both compressed and uncompressed
 entries."
android,javax.crypto,Cipher,37,"This class provides the functionality of a cryptographic cipher for
 encryption and decryption. It forms the core of the Java Cryptographic
 Extension (JCE) framework.

  In order to create a Cipher object the application calls the
 Cipher's  getInstance  method and passes the name of the
 requested  transformation  to it. Optionally the name of a provider
 may be specified.

  A  transformation  is a string that describes the operation (or
 set of operations) to be performed on the given input to produce some
 output. A transformation always includes the name of a cryptographic
 algorithm (e.g.  DES ) and may be followed by a feedback mode and
 padding scheme.

   A transformation is of the form:

  "" algorithm/mode/padding "" or

  "" algorithm ""
   (in the latter case
 provider-specific default values for the mode and padding scheme are used).
 For example the following is a valid transformation:

  
     Cipher c = Cipher.getInstance("" DES/CBC/PKCS5Padding "");
  CFB OFB DES/CFB8/NoPadding DES/OFB32/PKCS5Padding 
 Modes such as Authenticated Encryption with Associated Data (AEAD)
 provide authenticity assurances for both confidential data and
 Additional Associated Data (AAD) that is not encrypted.  (Please see
   RFC 5116   for more
 information on AEAD and AEAD algorithms such as GCM/CCM.) Both
 confidential and AAD data can be used when calculating the
 authentication tag (similar to a  Mac ).  This tag is appended
 to the ciphertext during encryption and is verified on decryption.
  
 AEAD modes such as GCM/CCM perform all AAD authenticity calculations
 before starting the ciphertext authenticity calculations.  To avoid
 implementations having to internally buffer ciphertext all AAD data
 must be supplied to GCM/CCM implementations (via the  updateAAD  methods)  before  the ciphertext is processed (via
 the  update  and  doFinal  methods).
  
 Note that GCM mode has a uniqueness requirement on IVs used in
 encryption with a given key. When IVs are repeated for GCM
 encryption such usages are subject to forgery attacks. Thus after
 each encryption operation using GCM mode callers should re-initialize
 the cipher objects with GCM parameters which has a different IV value.
  
     GCMParameterSpec s = ...;
     cipher.init(... s);

     // If the GCM parameters were generated by the provider it can
     // be retrieved by:
     // cipher.getParameters().getParameterSpec(GCMParameterSpec.class);

     cipher.updateAAD(...);  // AAD
     cipher.update(...);     // Multi-part update
     cipher.doFinal(...);    // conclusion of operation

     // Use a different IV value for every encryption
     byte[] newIv = ...;
     s = new GCMParameterSpec(s.getTLen() newIv);
     cipher.init(... s);
     ...

   Android provides the following  Cipher  transformations:
  Algorithm Modes Paddings Supported API Levels Notes AES CBC CFB CTR CTS ECB OFB ISO10126Padding NoPadding PKCS5Padding 1+ GCM NoPadding 10+ AES_128 CBC ECB NoPadding PKCS5Padding 26+ GCM NoPadding 26+ AES_256 CBC ECB NoPadding PKCS5Padding 26+ GCM NoPadding 26+ ARC4 ECB NoPadding 10+ NONE NoPadding 28+ BLOWFISH CBC CFB CTR CTS ECB OFB ISO10126Padding NoPadding PKCS5Padding 10+ ChaCha20 NONE Poly1305 NoPadding 28+ ChaCha with 20 rounds 96-bit nonce and 32-bit counter as described in RFC 7539. DES CBC CFB CTR CTS ECB OFB ISO10126Padding NoPadding PKCS5Padding 1+ DESede CBC CFB CTR CTS ECB OFB ISO10126Padding NoPadding PKCS5Padding 1+ RSA ECB NONE NoPadding OAEPPadding PKCS1Padding 1+ OAEPwithSHA-1andMGF1Padding OAEPwithSHA-256andMGF1Padding 10+ OAEPwithSHA-224andMGF1Padding OAEPwithSHA-384andMGF1Padding OAEPwithSHA-512andMGF1Padding 23+ 
 Cipher section"
android,javax.crypto,CipherInputStream,7,"A CipherInputStream is composed of an InputStream and a Cipher so
 that read() methods return data that are read in from the
 underlying InputStream but have been additionally processed by the
 Cipher.  The Cipher must be fully initialized before being used by
 a CipherInputStream.

   For example if the Cipher is initialized for decryption the
 CipherInputStream will attempt to read in data and decrypt them
 before returning the decrypted data.

   This class adheres strictly to the semantics especially the
 failure semantics of its ancestor classes
 java.io.FilterInputStream and java.io.InputStream.  This class has
 exactly those methods specified in its ancestor classes and
 overrides them all.  Moreover this class catches all exceptions
 that are not thrown by its ancestor classes.  In particular the
  skip  method skips and the  available 
 method counts only data that have been processed by the encapsulated Cipher.

   It is crucial for a programmer using this class not to use
 methods that are not defined or overriden in this class (such as a
 new method or constructor that is later added to one of the super
 classes) because the design and implementation of those methods
 are unlikely to have considered security impact with regard to
 CipherInputStream."
android,javax.crypto,CipherOutputStream,5,"A CipherOutputStream is composed of an OutputStream and a Cipher so
 that write() methods first process the data before writing them out
 to the underlying OutputStream.  The cipher must be fully
 initialized before being used by a CipherOutputStream.

   For example if the cipher is initialized for encryption the
 CipherOutputStream will attempt to encrypt data before writing out the
 encrypted data.

   This class adheres strictly to the semantics especially the
 failure semantics of its ancestor classes
 java.io.OutputStream and java.io.FilterOutputStream.  This class
 has exactly those methods specified in its ancestor classes and
 overrides them all.  Moreover this class catches all exceptions
 that are not thrown by its ancestor classes.

   It is crucial for a programmer using this class not to use
 methods that are not defined or overriden in this class (such as a
 new method or constructor that is later added to one of the super
 classes) because the design and implementation of those methods
 are unlikely to have considered security impact with regard to
 CipherOutputStream."
android,javax.crypto,CipherSpi,0,"This class defines the  Service Provider Interface  ( SPI )
 for the  Cipher  class.
 All the abstract methods in this class must be implemented by each
 cryptographic service provider who wishes to supply the implementation
 of a particular cipher algorithm.

  In order to create an instance of  Cipher  which
 encapsulates an instance of this  CipherSpi  class an
 application calls one of the
  Cipher#getInstance(java.lang.String) 
 factory methods of the
  Cipher  engine class and specifies the requested
  transformation .
 Optionally the application may also specify the name of a provider.

  A  transformation  is a string that describes the operation (or
 set of operations) to be performed on the given input to produce some
 output. A transformation always includes the name of a cryptographic
 algorithm (e.g.  DES ) and may be followed by a feedback mode and
 padding scheme.

   A transformation is of the form:

  "" algorithm/mode/padding "" or

  "" algorithm ""
   (in the latter case
 provider-specific default values for the mode and padding scheme are used).
 For example the following is a valid transformation:

  
     Cipher c = Cipher.getInstance("" DES/CBC/PKCS5Padding "");
  A provider may supply a separate class for each combination
 of  algorithm/mode/padding  or may decide to provide more generic
 classes representing sub-transformations corresponding to
  algorithm  or  algorithm/mode  or  algorithm//padding 
 (note the double slashes)
 in which case the requested mode and/or padding are set automatically by
 the  getInstance  methods of  Cipher  which invoke
 the  engineSetMode  and
  engineSetPadding 
 methods of the provider's subclass of  CipherSpi .

  A  Cipher  property in a provider master class may have one of
 the following formats:

  
     // provider's subclass of ""CipherSpi"" implements ""algName"" with
     // pluggable mode and padding
      Cipher. algName 
     // provider's subclass of ""CipherSpi"" implements ""algName"" in the
     // specified ""mode"" with pluggable padding
      Cipher. algName/mode 
     // provider's subclass of ""CipherSpi"" implements ""algName"" with the
     // specified ""padding"" with pluggable mode
      Cipher. algName//padding 
     // provider's subclass of ""CipherSpi"" implements ""algName"" with the
     // specified ""mode"" and ""padding""
      Cipher. algName/mode/padding For example a provider may supply a subclass of  CipherSpi 
 that implements  DES/ECB/PKCS5Padding  one that implements
  DES/CBC/PKCS5Padding  one that implements
  DES/CFB/PKCS5Padding  and yet another one that implements
  DES/OFB/PKCS5Padding . That provider would have the following
  Cipher  properties in its master class:

  Cipher. DES/ECB/PKCS5Padding Cipher. DES/CBC/PKCS5Padding Cipher. DES/CFB/PKCS5Padding Cipher. DES/OFB/PKCS5Padding Another provider may implement a class for each of the above modes
 (i.e. one class for  ECB  one for  CBC  one for  CFB 
 and one for  OFB ) one class for  PKCS5Padding 
 and a generic  DES  class that subclasses from  CipherSpi .
 That provider would have the following
  Cipher  properties in its master class:

  Cipher. DES The  getInstance  factory method of the  Cipher 
 engine class follows these rules in order to instantiate a provider's
 implementation of  CipherSpi  for a
 transformation of the form "" algorithm "":

  
 Check if the provider has registered a subclass of  CipherSpi 
 for the specified "" algorithm "".
  If the answer is YES instantiate this
 class for whose mode and padding scheme default values (as supplied by
 the provider) are used.
  If the answer is NO throw a  NoSuchAlgorithmException 
 exception.
  The  getInstance  factory method of the  Cipher 
 engine class follows these rules in order to instantiate a provider's
 implementation of  CipherSpi  for a
 transformation of the form "" algorithm/mode/padding "":

  
 Check if the provider has registered a subclass of  CipherSpi 
 for the specified "" algorithm/mode/padding "" transformation.
  If the answer is YES instantiate it.
  If the answer is NO go to the next step.
  
 Check if the provider has registered a subclass of  CipherSpi 
 for the sub-transformation "" algorithm/mode "".
  If the answer is YES instantiate it and call
  engineSetPadding( padding )  on the new instance.
  If the answer is NO go to the next step.
  
 Check if the provider has registered a subclass of  CipherSpi 
 for the sub-transformation "" algorithm//padding "" (note the double
 slashes).
  If the answer is YES instantiate it and call
  engineSetMode( mode )  on the new instance.
  If the answer is NO go to the next step.
  
 Check if the provider has registered a subclass of  CipherSpi 
 for the sub-transformation "" algorithm "".
  If the answer is YES instantiate it and call
  engineSetMode( mode )  and
  engineSetPadding( padding )  on the new instance.
  If the answer is NO throw a  NoSuchAlgorithmException 
 exception."
android,javax.crypto,EncryptedPrivateKeyInfo,8,"This class implements the  EncryptedPrivateKeyInfo  type
 as defined in PKCS #8.
  Its ASN.1 definition is as follows:

  
 EncryptedPrivateKeyInfo ::=  SEQUENCE {
     encryptionAlgorithm   AlgorithmIdentifier
     encryptedData   OCTET STRING }

 AlgorithmIdentifier  ::=  SEQUENCE  {
     algorithm              OBJECT IDENTIFIER
     parameters             ANY DEFINED BY algorithm OPTIONAL  }"
android,javax.crypto,KeyAgreement,13,"This class provides the functionality of a key agreement (or key
 exchange) protocol.
  
 The keys involved in establishing a shared secret are created by one of the
 key generators ( KeyPairGenerator  or
  KeyGenerator ) a  KeyFactory  or as a result from
 an intermediate phase of the key agreement protocol.

   For each of the correspondents in the key exchange  doPhase 
 needs to be called. For example if this key exchange is with one other
 party  doPhase  needs to be called once with the
  lastPhase  flag set to  true .
 If this key exchange is
 with two other parties  doPhase  needs to be called twice
 the first time setting the  lastPhase  flag to
  false  and the second time setting it to  true .
 There may be any number of parties involved in a key exchange.

   Android provides the following  KeyAgreement  algorithms:
  Algorithm Supported API Levels DH 1+ ECDH 11+ 
 KeyAgreement section"
android,javax.crypto,KeyAgreementSpi,0,"This class defines the  Service Provider Interface  ( SPI )
 for the  KeyAgreement  class.
 All the abstract methods in this class must be implemented by each
 cryptographic service provider who wishes to supply the implementation
 of a particular key agreement algorithm.

   The keys involved in establishing a shared secret are created by one
 of the
 key generators ( KeyPairGenerator  or
  KeyGenerator ) a  KeyFactory  or as a result from
 an intermediate phase of the key agreement protocol
 ( engineDoPhase ).

   For each of the correspondents in the key exchange
  engineDoPhase 
 needs to be called. For example if the key exchange is with one other
 party  engineDoPhase  needs to be called once with the
  lastPhase  flag set to  true .
 If the key exchange is
 with two other parties  engineDoPhase  needs to be called twice
 the first time setting the  lastPhase  flag to
  false  and the second time setting it to  true .
 There may be any number of parties involved in a key exchange."
android,javax.crypto,ExemptionMechanism,13,"This class provides the functionality of an exemption mechanism examples
 of which are  key recovery   key weakening  and
  key escrow .

  Applications or applets that use an exemption mechanism may be granted
 stronger encryption capabilities than those which don't."
android,javax.crypto,ExemptionMechanismSpi,0,"This class defines the  Service Provider Interface  ( SPI )
 for the  ExemptionMechanism  class.
 All the abstract methods in this class must be implemented by each
 cryptographic service provider who wishes to supply the implementation
 of a particular exemption mechanism."
android,javax.crypto,KeyGenerator,11,"This class provides the functionality of a secret (symmetric) key generator.

  Key generators are constructed using one of the  getInstance 
 class methods of this class.

  KeyGenerator objects are reusable i.e. after a key has been
 generated the same KeyGenerator object can be re-used to generate further
 keys.

  There are two ways to generate a key: in an algorithm-independent
 manner and in an algorithm-specific manner.
 The only difference between the two is the initialization of the object:

  Algorithm-Independent Initialization All key generators share the concepts of a  keysize  and a
  source of randomness .
 There is an
  init 
 method in this KeyGenerator class that takes these two universally
 shared types of arguments. There is also one that takes just a
  keysize  argument and uses the SecureRandom implementation
 of the highest-priority installed provider as the source of randomness
 (or a system-provided source of randomness if none of the installed
 providers supply a SecureRandom implementation) and one that takes just a
 source of randomness.

  Since no other parameters are specified when you call the above
 algorithm-independent  init  methods it is up to the
 provider what to do about the algorithm-specific parameters (if any) to be
 associated with each of the keys.

  Algorithm-Specific Initialization For situations where a set of algorithm-specific parameters already
 exists there are two
  init 
 methods that have an  AlgorithmParameterSpec 
 argument. One also has a  SecureRandom  argument while the
 other uses the SecureRandom implementation
 of the highest-priority installed provider as the source of randomness
 (or a system-provided source of randomness if none of the installed
 providers supply a SecureRandom implementation).
  In case the client does not explicitly initialize the KeyGenerator
 (via a call to an  init  method) each provider must
 supply (and document) a default initialization.

   Android provides the following  KeyGenerator  algorithms:
  Algorithm Supported API Levels AES 1+ AESWRAP 1-8 ARC4 14+ BLOWFISH 10+ ChaCha20 28+ DES 1+ DESede 1+ DESedeWRAP 1-8 HmacMD5 1+ HmacSHA1 11+ HmacSHA224 1-822+ HmacSHA256 1+ HmacSHA384 1+ HmacSHA512 1+ RC4 10-13 
 KeyGenerator section"
android,javax.crypto,KeyGeneratorSpi,0,"This class defines the  Service Provider Interface  ( SPI )
 for the  KeyGenerator  class.
 All the abstract methods in this class must be implemented by each
 cryptographic service provider who wishes to supply the implementation
 of a key generator for a particular algorithm."
android,javax.crypto,Mac,17,"This class provides the functionality of a ""Message Authentication Code""
 (MAC) algorithm.

   A MAC provides a way to check
 the integrity of information transmitted over or stored in an unreliable
 medium based on a secret key. Typically message
 authentication codes are used between two parties that share a secret
 key in order to validate information transmitted between these
 parties.

   A MAC mechanism that is based on cryptographic hash functions is
 referred to as HMAC. HMAC can be used with any cryptographic hash function
 e.g. MD5 or SHA-1 in combination with a secret shared key. HMAC is
 specified in RFC 2104.

   Android provides the following  Mac  algorithms:
  Algorithm Supported API Levels DESMAC 1-8 DESMAC/CFB8 1-8 DESedeMAC 1-8 DESedeMAC/CFB8 1-8 DESedeMAC64 1-8 DESwithISO9797 1-8 HmacMD5 1+ HmacSHA1 1+ HmacSHA224 1-822+ HmacSHA256 1+ HmacSHA384 1+ HmacSHA512 1+ ISO9797ALG3MAC 1-8 PBEwithHmacSHA 1+ PBEwithHmacSHA1 1+ PBEwithHmacSHA224 26+ PBEwithHmacSHA256 26+ PBEwithHmacSHA384 26+ PBEwithHmacSHA512 26+ 
 Mac section"
android,javax.crypto,MacSpi,8,"This class defines the  Service Provider Interface  ( SPI )
 for the  Mac  class.
 All the abstract methods in this class must be implemented by each
 cryptographic service provider who wishes to supply the implementation
 of a particular MAC algorithm.

   Implementations are free to implement the Cloneable interface."
android,javax.crypto,NullCipher,0,"The NullCipher class is a class that provides an
 ""identity cipher"" -- one that does not transform the plain text.  As
 a consequence the ciphertext is identical to the plaintext.  All
 initialization methods do nothing while the blocksize is set to 1
 byte."
android,javax.crypto,SealedObject,4,"This class enables a programmer to create an object and protect its
 confidentiality with a cryptographic algorithm.

   Given any Serializable object one can create a SealedObject
 that encapsulates the original object in serialized
 format (i.e. a ""deep copy"") and seals (encrypts) its serialized contents
 using a cryptographic algorithm such as DES to protect its
 confidentiality.  The encrypted content can later be decrypted (with
 the corresponding algorithm using the correct decryption key) and
 de-serialized yielding the original object.

   Note that the Cipher object must be fully initialized with the
 correct algorithm key padding scheme etc. before being applied
 to a SealedObject.

   The original object that was sealed can be recovered in two different
 ways:

  by using the  getObject 
 method that takes a  Cipher  object.

   This method requires a fully initialized  Cipher  object
 initialized with the
 exact same algorithm key padding scheme etc. that were used to seal the
 object.

   This approach has the advantage that the party who unseals the
 sealed object does not require knowledge of the decryption key. For example
 after one party has initialized the cipher object with the required
 decryption key it could hand over the cipher object to
 another party who then unseals the sealed object.

  by using one of the
  getObject  methods
 that take a  Key  object.

   In this approach the  getObject  method creates a cipher
 object for the appropriate decryption algorithm and initializes it with the
 given decryption key and the algorithm parameters (if any) that were stored
 in the sealed object.

   This approach has the advantage that the party who
 unseals the object does not need to keep track of the parameters (e.g. an
 IV) that were used to seal the object."
android,javax.crypto,SecretKeyFactorySpi,0,"This class defines the  Service Provider Interface  ( SPI )
 for the  SecretKeyFactory  class.
 All the abstract methods in this class must be implemented by each
 cryptographic service provider who wishes to supply the implementation
 of a secret-key factory for a particular algorithm.

   A provider should document all the key specifications supported by its
 secret key factory.
 For example the DES secret-key factory supplied by the ""SunJCE"" provider
 supports  DESKeySpec  as a transparent representation of DES
 keys and that provider's secret-key factory for Triple DES keys supports
  DESedeKeySpec  as a transparent representation of Triple DES
 keys."
android,javax.crypto,SecretKeyFactory,8,"This class represents a factory for secret keys.

   Key factories are used to convert  keys  (opaque
 cryptographic keys of type  Key ) into  key specifications 
 (transparent representations of the underlying key material) and vice
 versa.
 Secret key factories operate only on secret (symmetric) keys.

   Key factories are bi-directional i.e. they allow to build an opaque
 key object from a given key specification (key material) or to retrieve
 the underlying key material of a key object in a suitable format.

   Application developers should refer to their provider's documentation
 to find out which key specifications are supported by the
  generateSecret  and
  getKeySpec 
 methods.
 For example the DES secret-key factory supplied by the ""SunJCE"" provider
 supports  DESKeySpec  as a transparent representation of DES
 keys and that provider's secret-key factory for Triple DES keys supports
  DESedeKeySpec  as a transparent representation of Triple DES
 keys.

   Android provides the following  SecretKeyFactory  algorithms:
  Algorithm Supported API Levels AES 23+ DES 1+ DESede 1+ HmacSHA1 23+ HmacSHA224 23+ HmacSHA256 23+ HmacSHA384 23+ HmacSHA512 23+ PBEwithHmacSHA1 1+ PBEwithHmacSHA1AndAES_128 26+ PBEwithHmacSHA1AndAES_256 26+ PBEwithHmacSHA224AndAES_128 26+ PBEwithHmacSHA224AndAES_256 26+ PBEwithHmacSHA256AndAES_128 26+ PBEwithHmacSHA256AndAES_256 26+ PBEwithHmacSHA384AndAES_128 26+ PBEwithHmacSHA384AndAES_256 26+ PBEwithHmacSHA512AndAES_128 26+ PBEwithHmacSHA512AndAES_256 26+ PBEwithMD5AND128BITAES-CBC-OPENSSL 1+ PBEwithMD5AND192BITAES-CBC-OPENSSL 1+ PBEwithMD5AND256BITAES-CBC-OPENSSL 1+ PBEwithMD5ANDDES 1+ PBEwithMD5ANDRC2 1+ PBEwithSHA1ANDDES 1+ PBEwithSHA1ANDRC2 1+ PBEwithSHA256AND128BITAES-CBC-BC 1+ PBEwithSHA256AND192BITAES-CBC-BC 1+ PBEwithSHA256AND256BITAES-CBC-BC 1+ PBEwithSHAAND128BITAES-CBC-BC 1+ PBEwithSHAAND128BITRC2-CBC 10+ PBEwithSHAAND128BITRC4 10+ PBEwithSHAAND192BITAES-CBC-BC 1+ PBEwithSHAAND2-KEYTRIPLEDES-CBC 1+ PBEwithSHAAND256BITAES-CBC-BC 1+ PBEwithSHAAND3-KEYTRIPLEDES-CBC 1+ PBEwithSHAAND40BITRC2-CBC 1+ PBEwithSHAAND40BITRC4 10+ PBEwithSHAANDTWOFISH-CBC 10+ PBKDF2withHmacSHA1 10+ PBKDF2withHmacSHA1And8BIT 19+ PBKDF2withHmacSHA224 26+ PBKDF2withHmacSHA256 26+ PBKDF2withHmacSHA384 26+ PBKDF2withHmacSHA512 26+ 
 SecretKeyFactory section"
android,javax.microedition.khronos.egl,EGLConfig,0,
android,javax.microedition.khronos.egl,EGLContext,2,
android,javax.microedition.khronos.egl,EGLDisplay,0,
android,javax.microedition.khronos.egl,EGLSurface,0,
android,javax.crypto.spec,DESedeKeySpec,2,"This class specifies a DES-EDE (""triple-DES"") key."
android,javax.crypto.spec,DESKeySpec,3,This class specifies a DES key.
android,javax.crypto.spec,DHGenParameterSpec,2,"This class specifies the set of parameters used for generating
 Diffie-Hellman (system) parameters for use in Diffie-Hellman key
 agreement. This is typically done by a central
 authority.

   The central authority after computing the parameters must send this
 information to the parties looking to agree on a secret key."
android,javax.crypto.spec,DHParameterSpec,3,"This class specifies the set of parameters used with the Diffie-Hellman
 algorithm as specified in PKCS #3:  Diffie-Hellman Key-Agreement
 Standard .

  A central authority generates parameters and gives them to the two
 entities seeking to generate a secret key. The parameters are a prime
  p  a base  g  and optionally the length
 in bits of the private value  l .

  It is possible that more than one instance of parameters may be
 generated by a given central authority and that there may be more than
 one central authority. Indeed each individual may be its own central
 authority with different entities having different parameters.

  Note that this class does not perform any validation on specified
 parameters. Thus the specified values are returned directly even
 if they are null."
android,javax.crypto.spec,IvParameterSpec,1,"This class specifies an  initialization vector  (IV).
 Examples which use IVs are ciphers in feedback mode
 e.g. DES in CBC mode and RSA ciphers with OAEP encoding
 operation."
android,javax.crypto.spec,OAEPParameterSpec,4,"This class specifies the set of parameters used with OAEP Padding
 as defined in the
  PKCS #1 
 standard.

 Its ASN.1 definition in PKCS#1 standard is described below:
  
 RSAES-OAEP-params ::= SEQUENCE {
   hashAlgorithm      [0] OAEP-PSSDigestAlgorithms     DEFAULT sha1
   maskGenAlgorithm   [1] PKCS1MGFAlgorithms  DEFAULT mgf1SHA1
   pSourceAlgorithm   [2] PKCS1PSourceAlgorithms  DEFAULT pSpecifiedEmpty
 }
  
 OAEP-PSSDigestAlgorithms    ALGORITHM-IDENTIFIER ::= {
   { OID id-sha1 PARAMETERS NULL   }|
   { OID id-sha256 PARAMETERS NULL }|
   { OID id-sha384 PARAMETERS NULL }|
   { OID id-sha512 PARAMETERS NULL }
   ...  -- Allows for future expansion --
 }
 PKCS1MGFAlgorithms    ALGORITHM-IDENTIFIER ::= {
   { OID id-mgf1 PARAMETERS OAEP-PSSDigestAlgorithms }
   ...  -- Allows for future expansion --
 }
 PKCS1PSourceAlgorithms    ALGORITHM-IDENTIFIER ::= {
   { OID id-pSpecified PARAMETERS OCTET STRING }
   ...  -- Allows for future expansion --
 }
  Note: the OAEPParameterSpec.DEFAULT uses the following:
     message digest  -- ""SHA-1""
     mask generation function (mgf) -- ""MGF1""
     parameters for mgf -- MGF1ParameterSpec.SHA1
     source of encoding input -- PSource.PSpecified.DEFAULT"
android,javax.crypto.spec,PBEKeySpec,5,"A user-chosen password that can be used with password-based encryption
 ( PBE ).

  The password can be viewed as some kind of raw key material from which
 the encryption mechanism that uses it derives a cryptographic key.

  Different PBE mechanisms may consume different bits of each password
 character. For example the PBE mechanism defined in
  
 PKCS #5  looks at only the low order 8 bits of each character whereas
 PKCS #12 looks at all 16 bits of each character.

  You convert the password characters to a PBE key by creating an
 instance of the appropriate secret-key factory. For example a secret-key
 factory for PKCS #5 will construct a PBE key from only the low order 8 bits
 of each password character whereas a secret-key factory for PKCS #12 will
 take all 16 bits of each character.

  Also note that this class stores passwords as char arrays instead of
  String  objects (which would seem more logical) because the
 String class is immutable and there is no way to overwrite its
 internal value when the password stored in it is no longer needed. Hence
 this class requests the password as a char array so it can be overwritten
 when done."
android,javax.crypto.spec,PBEParameterSpec,3,"This class specifies the set of parameters used with password-based
 encryption (PBE) as defined in the
  PKCS #5 
 standard."
android,javax.crypto.spec,DHPrivateKeySpec,3,"This class specifies a Diffie-Hellman private key with its associated
 parameters.

  Note that this class does not perform any validation on specified
 parameters. Thus the specified values are returned directly even
 if they are null."
android,javax.crypto.spec,DHPublicKeySpec,3,"This class specifies a Diffie-Hellman public key with its associated
 parameters.

  Note that this class does not perform any validation on specified
 parameters. Thus the specified values are returned directly even
 if they are null."
android,javax.crypto.spec,GCMParameterSpec,2,"Specifies the set of parameters required by a  Cipher  using the Galois/Counter Mode (GCM) mode.
  
 Simple block cipher modes (such as CBC) generally require only an
 initialization vector (such as  IvParameterSpec )
 but GCM needs these parameters:
  IV : Initialization Vector (IV)  tLen : length (in bits) of authentication tag T 
 In addition to the parameters described here other GCM inputs/output
 (Additional Authenticated Data (AAD) Keys block ciphers
 plain/ciphertext and authentication tags) are handled in the  Cipher  class.
  
 Please see   RFC 5116
   for more information on the Authenticated Encryption with
 Associated Data (AEAD) algorithm and  
 NIST Special Publication 800-38D  ""NIST Recommendation for Block
 Cipher Modes of Operation:  Galois/Counter Mode (GCM) and GMAC.""
  
 The GCM specification states that  tLen  may only have the
 values {128 120 112 104 96} or {64 32} for certain
 applications.  Other values can be specified for this class but not
 all CSP implementations will support them."
android,javax.crypto.spec,PSource,1,"This class specifies the source for encoding input P in OAEP Padding
 as defined in the
  PKCS #1 
 standard.
  
 PKCS1PSourceAlgorithms    ALGORITHM-IDENTIFIER ::= {
   { OID id-pSpecified PARAMETERS OCTET STRING }
   ...  -- Allows for future expansion --
 }"
android,javax.crypto.spec,PSource.PSpecified,1,"This class is used to explicitly specify the value for
 encoding input P in OAEP Padding."
android,javax.crypto.spec,RC2ParameterSpec,4,"This class specifies the parameters used with the
  RC2 
 algorithm.

   The parameters consist of an effective key size and optionally
 an 8-byte initialization vector (IV) (only in feedback mode).

   This class can be used to initialize a  Cipher  object that
 implements the  RC2  algorithm."
android,javax.crypto.spec,RC5ParameterSpec,6,"This class specifies the parameters used with the
  RC5 
 algorithm.

   The parameters consist of a version number a rounds count a word
 size and optionally an initialization vector (IV) (only in feedback mode).

   This class can be used to initialize a  Cipher  object that
 implements the  RC5  algorithm as supplied by
  RSA Security Inc. 
 or any parties authorized by RSA Security."
android,javax.crypto.spec,SecretKeySpec,5,"This class specifies a secret key in a provider-independent fashion.

  It can be used to construct a  SecretKey  from a byte array
 without having to go through a (provider-based)
  SecretKeyFactory .

  This class is only useful for raw secret keys that can be represented as
 a byte array and have no key parameters associated with them e.g. DES or
 Triple DES keys."
android,javax.net,ServerSocketFactory,5,"This class creates server sockets.  It may be subclassed by other
 factories which create particular types of server sockets.  This
 provides a general framework for the addition of public socket-level
 functionality.  It is the server side analogue of a socket factory
 and similarly provides a way to capture a variety of policies related
 to the sockets being constructed.

   Like socket factories server Socket factory instances have
 methods used to create sockets. There is also an environment
 specific default server socket factory; frameworks will often use
 their own customized factory."
android,javax.net,SocketFactory,6,"This class creates sockets.  It may be subclassed by other factories
 which create particular subclasses of sockets and thus provide a general
 framework for the addition of public socket-level functionality.

   Socket factories are a simple way to capture a variety of policies
 related to the sockets being constructed producing such sockets in
 a way which does not require special configuration of the code which
 asks for the sockets:    Due to polymorphism of both factories and sockets different
      kinds of sockets can be used by the same application code just
      by passing it different kinds of factories.

        Factories can themselves be customized with parameters used
      in socket construction.  So for example factories could be
      customized to return sockets with different networking timeouts
      or security parameters already configured.

        The sockets returned to the application can be subclasses
      of java.net.Socket so that they can directly expose new APIs
      for features such as compression security record marking
      statistics collection or firewall tunneling.

        Factory classes are specified by environment-specific configuration
 mechanisms.  For example the  getDefault  method could return
 a factory that was appropriate for a particular user or applet and a
 framework could use a factory customized to its own purposes."
android,javax.security.auth.callback,PasswordCallback,5,"Underlying security services instantiate and pass a
  PasswordCallback  to the  handle 
 method of a  CallbackHandler  to retrieve password information."
android,javax.security.auth,AuthPermission,0,Legacy security code; do not use.
android,javax.security.auth,PrivateCredentialPermission,4,Legacy security code; do not use.
android,javax.security.auth,Subject,16,"A  Subject  represents a grouping of related information
 for a single entity such as a person.
 Such information includes the Subject's identities as well as
 its security-related attributes
 (passwords and cryptographic keys for example).

   Subjects may potentially have multiple identities.
 Each identity is represented as a  Principal 
 within the  Subject .  Principals simply bind names to a
  Subject .  For example a  Subject  that happens
 to be a person Alice might have two Principals:
 one which binds ""Alice Bar"" the name on her driver license
 to the  Subject  and another which binds
 ""999-99-9999"" the number on her student identification card
 to the  Subject .  Both Principals refer to the same
  Subject  even though each has a different name.

   A  Subject  may also own security-related attributes
 which are referred to as credentials.
 Sensitive credentials that require special protection such as
 private cryptographic keys are stored within a private credential
  Set .  Credentials intended to be shared such as
 public key certificates or Kerberos server tickets are stored
 within a public credential  Set .  Different permissions
 are required to access and modify the different credential Sets.

   To retrieve all the Principals associated with a  Subject 
 invoke the  getPrincipals  method.  To retrieve
 all the public or private credentials belonging to a  Subject 
 invoke the  getPublicCredentials  method or
  getPrivateCredentials  method respectively.
 To modify the returned  Set  of Principals and credentials
 use the methods defined in the  Set  class.
 For example:
  
      Subject subject;
      Principal principal;
      Object credential;

      // add a Principal and credential to the Subject
      subject.getPrincipals().add(principal);
      subject.getPublicCredentials().add(credential);
   This  Subject  class implements  Serializable .
 While the Principals associated with the  Subject  are serialized
 the credentials associated with the  Subject  are not.
 Note that the  java.security.Principal  class
 does not implement  Serializable .  Therefore all concrete
  Principal  implementations associated with Subjects
 must implement  Serializable ."
android,javax.security.auth,SubjectDomainCombiner,2,Legacy security code; do not use.
android,javax.security.auth.x500,X500Principal,7,"This class represents an X.500  Principal .
  X500Principal s are represented by distinguished names such as
 ""CN=Duke OU=JavaSoft O=Sun Microsystems C=US"".

   This class can be instantiated by using a string representation
 of the distinguished name or by using the ASN.1 DER encoded byte
 representation of the distinguished name.  The current specification
 for the string representation of a distinguished name is defined in
  RFC 2253: Lightweight
 Directory Access Protocol (v3): UTF-8 String Representation of
 Distinguished Names . This class however accepts string formats from
 both RFC 2253 and  RFC 1779:
 A String Representation of Distinguished Names  and also recognizes
 attribute type keywords whose OIDs (Object Identifiers) are defined in
  RFC 3280: Internet X.509
 Public Key Infrastructure Certificate and CRL Profile .

   The string representation for this  X500Principal 
 can be obtained by calling the  getName  methods.

   Note that the  getSubjectX500Principal  and
  getIssuerX500Principal  methods of
  X509Certificate  return X500Principals representing the
 issuer and subject fields of the certificate."
android,javax.security.cert,Certificate,7,"Abstract class for managing a variety of identity certificates.
 An identity certificate is a guarantee by a principal that
 a public key is that of another principal.  (A principal represents
 an entity such as an individual user a group or a corporation.)
 
 This class is an abstraction for certificates that have different
 formats but important common uses.  For example different types of
 certificates such as X.509 and PGP share general certificate
 functionality (like encoding and verifying) and
 some types of information (like a public key).
  
 X.509 PGP and SDSI certificates can all be implemented by
 subclassing the Certificate class even though they contain different
 sets of information and they store and retrieve the information in
 different ways.

  Note: The classes in the package  javax.security.cert 
 exist for compatibility with earlier versions of the
 Java Secure Sockets Extension (JSSE). New applications should instead
 use the standard Java SE certificate classes located in
  java.security.cert ."
android,javax.security.cert,X509Certificate,13,"Abstract class for X.509 v1 certificates. This provides a standard
 way to access all the version 1 attributes of an X.509 certificate.
 Attributes that are specific to X.509 v2 or v3 are not available
 through this interface. Future API evolution will provide full access to
 complete X.509 v3 attributes.
  
 The basic X.509 format was defined by
 ISO/IEC and ANSI X9 and is described below in ASN.1:
  
 Certificate  ::=  SEQUENCE  {
     tbsCertificate       TBSCertificate
     signatureAlgorithm   AlgorithmIdentifier
     signature            BIT STRING  }
  
 These certificates are widely used to support authentication and
 other functionality in Internet security systems. Common applications
 include Privacy Enhanced Mail (PEM) Transport Layer Security (SSL)
 code signing for trusted software distribution and Secure Electronic
 Transactions (SET).
  
 These certificates are managed and vouched for by  Certificate
 Authorities  (CAs). CAs are services which create certificates by
 placing data in the X.509 standard format and then digitally signing
 that data. CAs act as trusted third parties making introductions
 between principals who have no direct knowledge of each other.
 CA certificates are either signed by themselves or by some other
 CA such as a ""root"" CA.
  
 The ASN.1 definition of  tbsCertificate  is:
  
 TBSCertificate  ::=  SEQUENCE  {
     version         [0]  EXPLICIT Version DEFAULT v1
     serialNumber         CertificateSerialNumber
     signature            AlgorithmIdentifier
     issuer               Name
     validity             Validity
     subject              Name
     subjectPublicKeyInfo SubjectPublicKeyInfo
     }
  
 Here is sample code to instantiate an X.509 certificate:
  
 InputStream inStream = new FileInputStream(""fileName-of-cert"");
 X509Certificate cert = X509Certificate.getInstance(inStream);
 inStream.close();
  
 byte[] certData = <certificate read from a file say>
 X509Certificate cert = X509Certificate.getInstance(certData);
  
 In either case the code that instantiates an X.509 certificate
 consults the value of the  cert.provider.x509v1  security property
 to locate the actual implementation or instantiates a default implementation.
  
 The  cert.provider.x509v1  property is set to a default
 implementation for X.509 such as:
  
 cert.provider.x509v1=com.sun.security.cert.internal.x509.X509V1CertImpl
  
 The value of this  cert.provider.x509v1  property has to be
 changed to instantiate another implementation. If this security
 property is not set a default implementation will be used.
 Currently due to possible security restrictions on access to
 Security properties this value is looked up and cached at class
 initialization time and will fallback on a default implementation if
 the Security property is not accessible.

  Note: The classes in the package  javax.security.cert 
 exist for compatibility with earlier versions of the
 Java Secure Sockets Extension (JSSE). New applications should instead
 use the standard Java SE certificate classes located in
  java.security.cert ."
android,javax.xml,XMLConstants,0,Utility class to contain basic XML values as constants.
android,javax.sql,ConnectionEvent,1,"An  Event  object that provides information about the
 source of a connection-related event.   ConnectionEvent 
 objects are generated when an application closes a pooled connection
 and when an error occurs.  The  ConnectionEvent  object
 contains two kinds of information:
  The pooled connection closed by the application
    In the case of an error event the  SQLException 
       about to be thrown to the application"
android,javax.sql,RowSetEvent,0,"An  Event  object generated when an event occurs to a
  RowSet  object.  A  RowSetEvent  object is
 generated when a single row in a rowset is changed the whole rowset
 is changed or the rowset cursor moves.
  
 When an event occurs on a  RowSet  object one of the
  RowSetListener  methods will be sent to all registered
 listeners to notify them of the event.  An  Event  object
 is supplied to the  RowSetListener  method so that the
 listener can use it to find out which  RowSet  object is
 the source of the event."
android,javax.sql,StatementEvent,2,"A  StatementEvent  is sent to all  StatementEventListener s which were
 registered with a  PooledConnection . This occurs when the driver determines that a
  PreparedStatement  that is associated with the  PooledConnection  has been closed or the driver determines
 is invalid."
android,javax.xml.namespace,QName,7,"QName  represents a  qualified name 
 as defined in the XML specifications:  XML Schema Part2:
 Datatypes specification   Namespaces
 in XML   Namespaces
 in XML Errata . The value of a  QName  contains a  Namespace
 URI   local part  and
  prefix . The prefix is included in  QName  to retain lexical
 information  when present  in an  XML input source . The prefix is
  NOT  used in  QName.equals(Object)  or to compute the  QName.hashCode() .  Equality and the hash code are defined using
  only  the Namespace URI and local part. If not specified the Namespace URI is set to  XMLConstants.NULL_NS_URI .
 If not specified the prefix is set to  XMLConstants.DEFAULT_NS_PREFIX . QName  is immutable."
android,javax.xml.datatype,DatatypeConstants,0,Utility class to contain basic Datatype values as constants.
android,javax.xml.datatype,DatatypeConstants.Field,2,"Type-safe enum class that represents six fields
 of the  Duration  class."
android,javax.xml.datatype,DatatypeFactory,23,"Factory that creates new  javax.xml.datatype Object s that map XML to/from Java  Object s. newInstance()  is used to create a new  DatatypeFactory .
 The following implementation resolution mechanisms are used in the following order: 
      If the system property specified by  DATATYPEFACTORY_PROPERTY  "" javax.xml.datatype.DatatypeFactory ""
      exists a class with the name of the property's value is instantiated.
      Any Exception thrown during the instantiation process is wrapped as a  DatatypeConfigurationException .
     
      If the file ${JAVA_HOME}/lib/jaxp.properties exists it is loaded in a  Properties Object .
      The  Properties Object   is then queried for the property as documented in the prior step
      and processed as documented in the prior step.
     
      The services resolution mechanism is used e.g.  META-INF/services/java.xml.datatype.DatatypeFactory .
      Any Exception thrown during the instantiation process is wrapped as a  DatatypeConfigurationException .
     
      The final mechanism is to attempt to instantiate the  Class  specified by
       DATATYPEFACTORY_IMPLEMENTATION_CLASS  "" javax.xml.datatype.DatatypeFactoryImpl "".
      Any Exception thrown during the instantiation process is wrapped as a  DatatypeConfigurationException .
     Note that you must supply your own implementation (such as Xerces); Android does not ship with a default implementation."
android,javax.xml.datatype,Duration,26,"Immutable representation of a time span as defined in
 the W3C XML Schema 1.0 specification. A Duration object represents a period of Gregorian time
 which consists of six fields (years months days hours
 minutes and seconds) plus a sign (+/-) field. The first five fields have non-negative (>=0) integers or null
 (which represents that the field is not set)
 and the seconds field has a non-negative decimal or null.
 A negative sign indicates a negative duration. This class provides a number of methods that make it easy
 to use for the duration datatype of XML Schema 1.0 with
 the errata."
android,javax.xml.datatype,XMLGregorianCalendar,39,"Representation for W3C XML Schema 1.0 date/time datatypes.
 Specifically these date/time datatypes are
  dateTime 
  time 
  date 
  gYearMonth 
  gMonthDay 
  gYear gMonth  and
  gDay  defined in the XML Namespace
  ""http://www.w3.org/2001/XMLSchema"" .
 These datatypes are normatively defined in
  W3C XML Schema 1.0 Part 2 Section 3.2.7-14 . The table below defines the mapping between XML Schema 1.0
 date/time datatype fields and this class' fields. It also summarizes
 the value constraints for the date and time fields defined in
  W3C XML Schema 1.0 Part 2 Appendix D
  ISO 8601 Date and Time Formats . 
         Date/Time Datatype Field Mapping Between XML Schema 1.0 and Java Representation
        XML Schema 1.0 
           datatype 
            field Related XMLGregorianCalendar Accessor(s) Value Range  year  getYear()  +  getEon()  or getEonAndYear() getYear()  is a value between -(10^9-1) to (10^9)-1
            or  DatatypeConstants#FIELD_UNDEFINED . getEon()  is high order year value in billion of years. getEon()  has values greater than or equal to (10^9) or less than or equal to -(10^9).
            A value of null indicates field is undefined.
            Given that  XML Schema 1.0 errata  states that the year zero
            will be a valid lexical value in a future version of XML Schema
            this class allows the year field to be set to zero. Otherwise
            the year field value is handled exactly as described
            in the errata and [ISO-8601-1988]. Note that W3C XML Schema 1.0
            validation does not allow for the year field to have a value of zero.
              month  getMonth()  1 to 12 or  DatatypeConstants#FIELD_UNDEFINED  day  getDay()  Independent of month max range is 1 to 31 or  DatatypeConstants#FIELD_UNDEFINED . 
            The normative value constraint stated relative to month
            field's value is in  W3C XML Schema 1.0 Part 2 Appendix D .
        hour getHour() 
         0 to 24 or  DatatypeConstants#FIELD_UNDEFINED .
         For a value of 24 the minute and second field must be zero per
          XML Schema Errata .
         minute  getMinute()  0 to 59 or  DatatypeConstants#FIELD_UNDEFINED second getSecond()  +  getMillisecond() /1000 or getSecond()  +  getFractionalSecond() getSecond()  from 0 to 60 or  DatatypeConstants#FIELD_UNDEFINED . (Note: 60 only allowable for leap second.) getFractionalSecond()  allows for infinite precision over the range from 0.0 to 1.0 when
         the  getSecond()  is defined. FractionalSecond  is optional and has a value of  null  when it is undefined. getMillisecond()  is the convenience
            millisecond precision of value of  getFractionalSecond() .
         timezone  getTimezone()  Number of minutes or  DatatypeConstants#FIELD_UNDEFINED .
         Value range from -14 hours (-14 * 60 minutes) to 14 hours (14 * 60 minutes).
        All maximum value space constraints listed for the fields in the table
 above are checked by factory methods @{link DatatypeFactory}
 setter methods and parse methods of
 this class.  IllegalArgumentException  is thrown when a
 parameter's value is outside the value constraint for the field or
 if the composite
 values constitute an invalid XMLGregorianCalendar instance (for example if
 the 31st of June is specified).
  The following operations are defined for this class:
  accessors/mutators for independent date/time fields conversion between this class and W3C XML Schema 1.0 lexical representation
      toString()   DatatypeFactory#newXMLGregorianCalendar(String lexicalRepresentation) conversion between this class and  GregorianCalendar 
      toGregorianCalendar(java.util.TimeZone java.util.Locale javax.xml.datatype.XMLGregorianCalendar) 
      DatatypeFactory partial order relation comparator method  compare(javax.xml.datatype.XMLGregorianCalendar) equals(java.lang.Object)  defined relative to  compare(javax.xml.datatype.XMLGregorianCalendar) . addition operation with  Duration 
      instance as defined in  
      W3C XML Schema 1.0 Part 2 Appendix E  Adding durations to dateTimes ."
android,javax.xml.parsers,DocumentBuilder,14,"Defines the API to obtain DOM Document instances from an XML
 document. Using this class an application programmer can obtain a
  Document  from XML. 

 An instance of this class can be obtained from the
  DocumentBuilderFactory#newDocumentBuilder()  method. Once
 an instance of this class is obtained XML can be parsed from a
 variety of input sources. These input sources are InputStreams
 Files URLs and SAX InputSources. 

 Note that this class reuses several classes from the SAX API. This
 does not require that the implementor of the underlying DOM
 implementation use a SAX parser to parse XML document into a
  Document . It merely requires that the implementation
 communicate with the application using these existing APIs."
android,javax.xml.parsers,DocumentBuilderFactory,23,"Defines a factory API that enables applications to obtain a
 parser that produces DOM object trees from XML documents."
android,javax.xml.parsers,SAXParser,19,"Defines the API that wraps an  XMLReader 
 implementation class. In JAXP 1.0 this class wrapped the
  Parser  interface however this interface was
 replaced by the  XMLReader . For ease
 of transition this class continues to support the same name
 and interface as well as supporting new methods.

 An instance of this class can be obtained from the
  SAXParserFactory.newSAXParser()  method.
 Once an instance of this class is obtained XML can be parsed from
 a variety of input sources. These input sources are InputStreams
 Files URLs and SAX InputSources. 

 This static method creates a new factory instance based
 on a system property setting or uses the platform default
 if no property has been defined. 

 The system property that controls which Factory implementation
 to create is named  ""javax.xml.parsers.SAXParserFactory"" .
 This property names a class that is a concrete subclass of this
 abstract class. If no property is defined a platform default
 will be used. HandlerBase DefaultHandler 

 Implementations of this class which wrap an underlying implementation
 can consider using the  ParserAdapter 
 class to initially adapt their SAX1 implementation to work under
 this revised class."
android,javax.xml.parsers,SAXParserFactory,13,"Defines a factory API that enables applications to configure and
 obtain a SAX based parser to parse XML documents."
android,javax.net.ssl,HandshakeCompletedEvent,8,"This event indicates that an SSL handshake completed on a given
 SSL connection.  All of the core information about that handshake's
 result is captured through an ""SSLSession"" object.  As a convenience
 this event class provides direct access to some important session
 attributes.

   The source of this event is the SSLSocket on which handshaking
 just completed."
android,javax.net.ssl,KeyStoreBuilderParameters,1,"A parameters object for X509KeyManagers that encapsulates a List
 of KeyStore.Builders."
android,javax.net.ssl,SNIHostName,5,"Instances of this class represent a server name of type
  StandardConstants#SNI_HOST_NAME  in a Server Name
 Indication (SNI) extension.
  
 As described in section 3 ""Server Name Indication"" of
  TLS Extensions (RFC 6066) 
 ""HostName"" contains the fully qualified DNS hostname of the server as
 understood by the client.  The encoded server name value of a hostname is
 represented as a byte string using ASCII encoding without a trailing dot.
 This allows the support of Internationalized Domain Names (IDN) through
 the use of A-labels (the ASCII-Compatible Encoding (ACE) form of a valid
 string of Internationalized Domain Names for Applications (IDNA)) defined
 in  RFC 5890 .
  
 Note that  SNIHostName  objects are immutable."
android,javax.net.ssl,SSLContextSpi,0,"This class defines the  Service Provider Interface  ( SPI )
 for the  SSLContext  class.

   All the abstract methods in this class must be implemented by each
 cryptographic service provider who wishes to supply the implementation
 of a particular SSL context."
android,javax.net.ssl,SSLEngineResult,5,"An encapsulation of the result state produced by
  SSLEngine  I/O calls.

   A  SSLEngine  provides a means for establishing
 secure communication sessions between two peers.   SSLEngine 
 operations typically consume bytes from an input buffer and produce
 bytes in an output buffer.  This class provides operational result
 values describing the state of the  SSLEngine  including
 indications of what operations are needed to finish an
 ongoing handshake.  Lastly it reports the number of bytes consumed
 and produced as a result of this operation."
android,javax.net.ssl,SSLParameters,20,"Encapsulates parameters for an SSL/TLS connection. The parameters
 are the list of ciphersuites to be accepted in an SSL/TLS handshake
 the list of protocols to be allowed the endpoint identification
 algorithm during SSL/TLS handshaking the Server Name Indication (SNI)
 the algorithm constraints and whether SSL/TLS servers should request
 or require client authentication etc.
  
 SSLParameters can be created via the constructors in this class.
 Objects can also be obtained using the  getSSLParameters() 
 methods in
  SSLSocket#getSSLParameters  and
  SSLServerSocket#getSSLParameters  and
  SSLEngine#getSSLParameters  or the
  SSLContext#getDefaultSSLParameters  and
  SSLContext#getSupportedSSLParameters 
 methods in  SSLContext .
  
 SSLParameters can be applied to a connection via the methods
  SSLSocket#setSSLParameters  and
  SSLServerSocket#setSSLParameters 
 and  SSLEngine#setSSLParameters ."
android,javax.net.ssl,SSLServerSocket,17,"This class extends  ServerSocket s and
 provides secure server sockets using protocols such as the Secure
 Sockets Layer (SSL) or Transport Layer Security (TLS) protocols.
  
 Instances of this class are generally created using a
  SSLServerSocketFactory .  The primary function
 of  SSLServerSocket s
 is to create  SSLSocket s by  accept ing
 connections.
  SSLServerSocket s contain several pieces of state data
 which are inherited by the  SSLSocket  at
 socket creation.  These include the enabled cipher
 suites and protocols whether client
 authentication is necessary and whether created sockets should
 begin handshaking in client or server mode.  The state
 inherited by the created  SSLSocket  can be
 overriden by calling the appropriate methods."
android,javax.net.ssl,SSLSessionBindingEvent,2,"This event is propagated to a SSLSessionBindingListener.
 When a listener object is bound or unbound to an SSLSession by
  SSLSession#putValue(String Object) 
 or  SSLSession#removeValue(String)  objects which
 implement the SSLSessionBindingListener will be receive an
 event of this type.  The event's  name  field is the
 key in which the listener is being bound or unbound."
android,javax.net.ssl,SSLSocketFactory,4,SSLSocketFactory s create  SSLSocket s.
android,javax.net.ssl,TrustManagerFactorySpi,0,"This class defines the  Service Provider Interface  ( SPI )
 for the  TrustManagerFactory  class.

   All the abstract methods in this class must be implemented by each
 cryptographic service provider who wishes to supply the implementation
 of a particular trust manager factory."
android,javax.net.ssl,X509ExtendedTrustManager,4,"Extensions to the  X509TrustManager  interface to support
 SSL/TLS connection sensitive trust management.
  
 To prevent man-in-the-middle attacks hostname checks can be done
 to verify that the hostname in an end-entity certificate matches the
 targeted hostname.  TLS does not require such checks but some protocols
 over TLS (such as HTTPS) do.  In earlier versions of the JDK the
 certificate chain checks were done at the SSL/TLS layer and the hostname
 verification checks were done at the layer over TLS.  This class allows
 for the checking to be done during a single call to this class.
  
 RFC 2830 defines the server identification specification for the ""LDAPS""
 algorithm. RFC 2818 defines both the server identification and the
 client identification specification for the ""HTTPS"" algorithm."
android,javax.net.ssl,CertPathTrustManagerParameters,1,"A wrapper for CertPathParameters. This class is used to pass validation
 settings to CertPath based  TrustManager s using the
  TrustManagerFactory#init(ManagerFactoryParameters)  method.

  Instances of this class are immutable."
android,javax.net.ssl,ExtendedSSLSession,3,"Extends the  SSLSession  interface to support additional
 session attributes."
android,javax.net.ssl,HttpsURLConnection,13,"HttpsURLConnection  extends  HttpURLConnection 
 with support for https-specific features.
  
 See  
 http://www.w3.org/pub/WWW/Protocols/  and
   RFC 2818  
 for more details on the
 https specification.
  
 This class uses  HostnameVerifier  and
  SSLSocketFactory .
 There are default implementations defined for both classes.
 However the implementations can be replaced on a per-class (static) or
 per-instance basis.  All new  HttpsURLConnection s instances
 will be assigned
 the ""default"" static values at instance creation but they can be overriden
 by calling the appropriate per-instance set method(s) before
  connect ing."
android,javax.net.ssl,KeyManagerFactory,9,"This class acts as a factory for key managers based on a
 source of key material. Each key manager manages a specific
 type of key material for use by secure sockets. The key
 material is based on a KeyStore and/or provider specific sources.

   Android provides the following  KeyManagerFactory  algorithms:
  Algorithm Supported API Levels PKIX 1+"
android,javax.net.ssl,KeyManagerFactorySpi,0,"This class defines the  Service Provider Interface  ( SPI )
 for the  KeyManagerFactory  class.

   All the abstract methods in this class must be implemented by each
 cryptographic service provider who wishes to supply the implementation
 of a particular key manager factory."
android,javax.net.ssl,SNIMatcher,2,"Instances of this class represent a matcher that performs match
 operations on an  SNIServerName  instance.
  
 Servers can use Server Name Indication (SNI) information to decide if
 specific  SSLSocket  or  SSLEngine  instances should accept
 a connection.  For example when multiple ""virtual"" or ""name-based""
 servers are hosted on a single underlying network address the server
 application can use SNI information to determine whether this server is
 the exact server that the client wants to access.  Instances of this
 class can be used by a server to verify the acceptable server names of
 a particular type such as host names.
  SNIMatcher  objects are immutable.  Subclasses should not provide
 methods that can change the state of an instance once it has been created."
android,javax.net.ssl,SNIServerName,5,"Instances of this class represent a server name in a Server Name
 Indication (SNI) extension.
  
 The SNI extension is a feature that extends the SSL/TLS protocols to
 indicate what server name the client is attempting to connect to during
 handshaking.  See section 3 ""Server Name Indication"" of  TLS Extensions (RFC 6066) .
  SNIServerName  objects are immutable.  Subclasses should not provide
 methods that can change the state of an instance once it has been created."
android,javax.net.ssl,SSLContext,16,"Instances of this class represent a secure socket protocol
 implementation which acts as a factory for secure socket
 factories or  SSLEngine s. This class is initialized
 with an optional set of key and trust managers and source of
 secure random bytes.

   Android provides the following  SSLContext  protocols:
  Algorithm Supported API Levels Default 10+ SSL 10+ SSLv3 10-25 TLS 1+ TLSv1 10+ TLSv1.1 16+ TLSv1.2 16+ TLSv1.3 29+ 
 SSLContext section"
android,javax.net.ssl,SSLEngine,37,"A class which enables secure communications using protocols such as
 the Secure Sockets Layer (SSL) or
   IETF RFC 2246 ""Transport
 Layer Security"" (TLS)   protocols but is transport independent.
  
 The secure communications modes include:  Integrity Protection .  SSL/TLS protects against
      modification of messages by an active wiretapper.

       Authentication .  In most modes SSL/TLS provides
      peer authentication.  Servers are usually authenticated and
      clients may be authenticated as requested by servers.

       Confidentiality (Privacy Protection) .  In most
      modes SSL/TLS encrypts data being sent between client and
      server.  This protects the confidentiality of data so that
      passive wiretappers won't see sensitive data such as financial
      information or personal information of many kinds.

       
 The cipher suite used is established by a negotiation process called
 ""handshaking"".  The goal of this process is to create or rejoin a
 ""session"" which may protect many connections over time.  After
 handshaking has completed you can access session attributes by
 using the  getSession()  method.
  
 The  SSLSocket  class provides much of the same security
 functionality but all of the inbound and outbound data is
 automatically transported using the underlying  Socket  which by design uses a blocking model.
 While this is appropriate for many applications this model does not
 provide the scalability required by large servers.
  
 The primary distinction of an  SSLEngine  is that it
 operates on inbound and outbound byte streams independent of the
 transport mechanism.  It is the responsibility of the
  SSLEngine  user to arrange for reliable I/O transport to
 the peer.  By separating the SSL/TLS abstraction from the I/O
 transport mechanism the  SSLEngine  can be used for a
 wide variety of I/O types such as  non-blocking I/O (polling)   selectable non-blocking I/O   Socket  and the
 traditional Input/OutputStreams local  ByteBuffers  or byte arrays   future asynchronous
 I/O models   and so on.
  
 At a high level the  SSLEngine  appears thus:

  
                   app data

                |           ^
                |     |     |
                v     |     |
           +----+-----|-----+----+
           |          |          |
           |       SSL|Engine    |
   wrap()  |          |          |  unwrap()
           | OUTBOUND | INBOUND  |
           |          |          |
           +----+-----|-----+----+
                |     |     ^
                |     |     |
                v           |

                   net data
  
 (In the context of an  SSLEngine  the term ""handshake
 data"" is taken to mean any data exchanged to establish and control a
 secure connection.  Handshake data includes the SSL/TLS messages
 ""alert"" ""change_cipher_spec"" and ""handshake."")
  
 There are five distinct phases to an  SSLEngine .

   Creation - The  SSLEngine  has been created and
     initialized but has not yet been used.  During this phase an
     application may set any  SSLEngine -specific settings
     (enabled cipher suites whether the  SSLEngine  should
     handshake in client or server mode and so on).  Once
     handshaking has begun though any new settings (except
     client/server mode see below) will be used for
     the next handshake.

       Initial Handshake - The initial handshake is a procedure by
     which the two peers exchange communication parameters until an
     SSLSession is established.  Application data can not be sent during
     this phase.

       Application Data - Once the communication parameters have
     been established and the handshake is complete application data
     may flow through the  SSLEngine .  Outbound
     application messages are encrypted and integrity protected
     and inbound messages reverse the process.

        Rehandshaking - Either side may request a renegotiation of
     the session at any time during the Application Data phase.  New
     handshaking data can be intermixed among the application data.
     Before starting the rehandshake phase the application may
     reset the SSL/TLS communication parameters such as the list of
     enabled ciphersuites and whether to use client authentication
     but can not change between client/server modes.  As before once
     handshaking has begun any new  SSLEngine 
     configuration settings will not be used until the next
     handshake.

        Closure - When the connection is no longer needed the
     application should close the  SSLEngine  and should
     send/receive any remaining messages to the peer before
     closing the underlying transport mechanism.  Once an engine is
     closed it is not reusable:  a new  SSLEngine  must
     be created.
  SSLEngine SSLContext#createSSLEngine() SSLContext wrap() unwrap() beginHandshake() 
 Data moves through the engine by calling  wrap()  or  unwrap()  on outbound or inbound data respectively.  Depending on
 the state of the  SSLEngine  a  wrap()  call
 may consume application data from the source buffer and may produce
 network data in the destination buffer.  The outbound data
 may contain application and/or handshake data.  A call to
  unwrap()  will examine the source buffer and may
 advance the handshake if the data is handshaking information or
 may place application data in the destination buffer if the data
 is application.  The state of the underlying SSL/TLS algorithm
 will determine when data is consumed and produced.
  
 Calls to  wrap()  and  unwrap()  return an
  SSLEngineResult  which indicates the status of the
 operation and (optionally) how to interact with the engine to make
 progress.
  
 The  SSLEngine  produces/consumes complete SSL/TLS
 packets only and does not store application data internally between
 calls to  wrap()/unwrap() .  Thus input and output
  ByteBuffer s must be sized appropriately to hold the
 maximum record that can be produced.  Calls to  SSLSession#getPacketBufferSize()  and  SSLSession#getApplicationBufferSize()  should be used to determine
 the appropriate buffer sizes.  The size of the outbound application
 data buffer generally does not matter.  If buffer conditions do not
 allow for the proper consumption/production of data the application
 must determine (via  SSLEngineResult ) and correct the
 problem and then try the call again.
  
 For example  unwrap()  will return a  SSLEngineResult.Status#BUFFER_OVERFLOW  result if the engine
 determines that there is not enough destination buffer space available.
 Applications should call  SSLSession#getApplicationBufferSize() 
 and compare that value with the space available in the destination buffer
 enlarging the buffer if necessary.  Similarly if  unwrap() 
 were to return a  SSLEngineResult.Status#BUFFER_UNDERFLOW  the
 application should call  SSLSession#getPacketBufferSize()  to ensure
 that the source buffer has enough room to hold a record (enlarging if
 necessary) and then obtain more inbound data.

  SSLEngineResult r = engine.unwrap(src dst);
   switch (r.getStatus()) {
   BUFFER_OVERFLOW:
       // Could attempt to drain the dst buffer of any already obtained
       // data but we'll just increase it to the size needed.
       int appSize = engine.getSession().getApplicationBufferSize();
       ByteBuffer b = ByteBuffer.allocate(appSize + dst.position());
       dst.flip();
       b.put(dst);
       dst = b;
       // retry the operation.
       break;
   BUFFER_UNDERFLOW:
       int netSize = engine.getSession().getPacketBufferSize();
       // Resize buffer if needed.
       if (netSize > dst.capacity()) {
           ByteBuffer b = ByteBuffer.allocate(netSize);
           src.flip();
           b.put(src);
           src = b;
       }
       // Obtain more inbound network data for src
       // then retry the operation.
       break;
   // other cases: CLOSED OK.
   }
  
 Unlike  SSLSocket  all methods of SSLEngine are
 non-blocking.   SSLEngine  implementations may
 require the results of tasks that may take an extended period of
 time to complete or may even block.  For example a TrustManager
 may need to connect to a remote certificate validation service
 or a KeyManager might need to prompt a user to determine which
 certificate to use as part of client authentication.  Additionally
 creating cryptographic signatures and verifying them can be slow
 seemingly blocking.
  
 For any operation which may potentially block the
  SSLEngine  will create a  Runnable 
 delegated task.  When  SSLEngineResult  indicates that a
 delegated task result is needed the application must call  getDelegatedTask()  to obtain an outstanding delegated task and
 call its  run()  method (possibly using
 a different thread depending on the compute strategy).  The
 application should continue obtaining delegated tasks until no more
 exist and try the original operation again.
  
 At the end of a communication session applications should properly
 close the SSL/TLS link.  The SSL/TLS protocols have closure handshake
 messages and these messages should be communicated to the peer
 before releasing the  SSLEngine  and closing the
 underlying transport mechanism.  A close can be initiated by one of:
 an SSLException an inbound closure handshake message or one of the
 close methods.  In all cases closure handshake messages are
 generated by the engine and  wrap()  should be repeatedly
 called until the resulting  SSLEngineResult 's status
 returns ""CLOSED"" or  isOutboundDone()  returns true.  All
 data obtained from the  wrap()  method should be sent to the
 peer.
  closeOutbound()  is used to signal the engine that the
 application will not be sending any more data.
  
 A peer will signal its intent to close by sending its own closure
 handshake message.  After this message has been received and
 processed by the local  SSLEngine 's  unwrap() 
 call the application can detect the close by calling
  unwrap()  and looking for a  SSLEngineResult 
 with status ""CLOSED"" or if  isInboundDone()  returns true.
 If for some reason the peer closes the communication link without
 sending the proper SSL/TLS closure message the application can
 detect the end-of-stream and can signal the engine via  closeInbound()  that there will no more inbound messages to
 process.  Some applications might choose to require orderly shutdown
 messages from a peer in which case they can check that the closure
 was generated by a handshake message and not by an end-of-stream
 condition.
  
 There are two groups of cipher suites which you will need to know
 about when managing cipher suites:

  Supported  cipher suites:  all the suites which are
      supported by the SSL implementation.  This list is reported
      using  getSupportedCipherSuites() .

       Enabled  cipher suites which may be fewer than
      the full set of supported suites.  This group is set using the
       setEnabledCipherSuites(java.lang.String[])  method and
      queried using the  getEnabledCipherSuites()  method.
      Initially a default set of cipher suites will be enabled on a
      new engine that represents the minimum suggested
      configuration.
  
 Each SSL/TLS connection must have one client and one server thus
 each endpoint must decide which role to assume.  This choice determines
 who begins the handshaking process as well as which type of messages
 should be sent by each party.  The method  setUseClientMode(boolean)  configures the mode.  Once the initial
 handshaking has started an  SSLEngine  can not switch
 between client and server modes even when performing renegotiations.
  
 Applications might choose to process delegated tasks in different
 threads.  When an  SSLEngine 
 is created the current  AccessControlContext 
 is saved.  All future delegated tasks will be processed using this
 context:  that is all access control decisions will be made using the
 context captured at engine creation.

  Concurrency Notes The  wrap()  and  unwrap()  methods
      may execute concurrently of each other.

        The SSL/TLS protocols employ ordered packets.
      Applications must take care to ensure that generated packets
      are delivered in sequence.  If packets arrive
      out-of-order unexpected or fatal results may occur.
  
      For example:

       
              synchronized (outboundLock) {
                  sslEngine.wrap(src dst);
                  outboundQueue.put(dst);
              }
       

      As a corollary two threads must not attempt to call the same method
      (either  wrap()  or  unwrap() ) concurrently
      because there is no way to guarantee the eventual packet ordering.
  Default configuration for different Android versions SSLEngine  instances obtained from the default  SSLContext  are configured as
 follows:

  
   tr.deprecated {
     background-color: #ccc;
     color: #999;
     font-style: italic;
   }
  Protocols Protocol Supported (API Levels) Enabled by default (API Levels) SSLv3 1â€“25 1â€“22 TLSv1 1+ 1+ TLSv1.1 20+ 20+ TLSv1.2 20+ 20+ TLSv1.3 29+ 29+ Cipher suites Cipher suite Supported (API Levels) Enabled by default (API Levels) SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA 9-22 9-19 SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA 9-22 9-19 SSL_DHE_DSS_WITH_DES_CBC_SHA 9-22 9-19 SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA 9-22 9-19 SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA 9-22 9-19 SSL_DHE_RSA_WITH_DES_CBC_SHA 9-22 9-19 SSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA 9-22 SSL_DH_anon_EXPORT_WITH_RC4_40_MD5 9-22 SSL_DH_anon_WITH_3DES_EDE_CBC_SHA 9-22 SSL_DH_anon_WITH_DES_CBC_SHA 9-22 SSL_DH_anon_WITH_RC4_128_MD5 9-22 SSL_RSA_EXPORT_WITH_DES40_CBC_SHA 9-22 9-19 SSL_RSA_EXPORT_WITH_RC4_40_MD5 9-22 9-19 SSL_RSA_WITH_3DES_EDE_CBC_SHA 9+ 9-19 SSL_RSA_WITH_DES_CBC_SHA 9-22 9-19 SSL_RSA_WITH_NULL_MD5 9-22 SSL_RSA_WITH_NULL_SHA 9-22 SSL_RSA_WITH_RC4_128_MD5 9-25 9-19 SSL_RSA_WITH_RC4_128_SHA 9-25 9-23 TLS_AES_128_GCM_SHA256 29+ 29+ TLS_AES_256_GCM_SHA384 29+ 29+ TLS_CHACHA20_POLY1305_SHA256 29+ 29+ TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA 1-8 1-8 TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA 1-8 1-8 TLS_DHE_DSS_WITH_AES_128_CBC_SHA 9-22 9-22 TLS_DHE_DSS_WITH_AES_128_CBC_SHA256 20-22 TLS_DHE_DSS_WITH_AES_128_GCM_SHA256 20-22 TLS_DHE_DSS_WITH_AES_256_CBC_SHA 9-22 20-22 TLS_DHE_DSS_WITH_AES_256_CBC_SHA256 20-22 TLS_DHE_DSS_WITH_AES_256_GCM_SHA384 20-22 TLS_DHE_DSS_WITH_DES_CBC_SHA 1-8 1-8 TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA 1-8 1-8 TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA 1-8 1-8 TLS_DHE_RSA_WITH_AES_128_CBC_SHA 9-25 9-25 TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 20-25 TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 20-25 20-25 TLS_DHE_RSA_WITH_AES_256_CBC_SHA 9-25 20-25 TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 20-25 TLS_DHE_RSA_WITH_AES_256_GCM_SHA384 20-25 20-25 TLS_DHE_RSA_WITH_DES_CBC_SHA 1-8 1-8 TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA 1-8 TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA 1-8 TLS_DH_DSS_WITH_DES_CBC_SHA 1-8 TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA 1-8 TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA 1-8 TLS_DH_RSA_WITH_DES_CBC_SHA 1-8 TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA 1-8 TLS_DH_anon_WITH_3DES_EDE_CBC_SHA 1-8 TLS_DH_anon_WITH_AES_128_CBC_SHA 9-22 TLS_DH_anon_WITH_AES_128_CBC_SHA256 20-22 TLS_DH_anon_WITH_AES_128_GCM_SHA256 20-22 TLS_DH_anon_WITH_AES_256_CBC_SHA 9-22 TLS_DH_anon_WITH_AES_256_CBC_SHA256 20-22 TLS_DH_anon_WITH_AES_256_GCM_SHA384 20-22 TLS_DH_anon_WITH_DES_CBC_SHA 1-8 TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA 20-22 TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA 20+ 20+ TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 20-28 TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 20+ 20+ TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA 20+ 20+ TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 20-28 TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 20+ 20+ TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 24+ 24+ TLS_ECDHE_ECDSA_WITH_NULL_SHA 20-22 TLS_ECDHE_ECDSA_WITH_RC4_128_SHA 20-25 20-23 TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA 21+ 21+ TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA 21+ 21+ TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256 24+ 24+ TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA 20-22 TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA 20+ 20+ TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 20-28 TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 20+ 20+ TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA 20+ 20+ TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 20-28 TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 20+ 20+ TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 24+ 24+ TLS_ECDHE_RSA_WITH_NULL_SHA 20-22 TLS_ECDHE_RSA_WITH_RC4_128_SHA 20-25 20-23 TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA 20-22 TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA 20-22 TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256 20-22 TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256 20-22 TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA 20-22 TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384 20-22 TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384 20-22 TLS_ECDH_ECDSA_WITH_NULL_SHA 20-22 TLS_ECDH_ECDSA_WITH_RC4_128_SHA 20-22 TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA 20-22 TLS_ECDH_RSA_WITH_AES_128_CBC_SHA 20-22 TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256 20-22 TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256 20-22 TLS_ECDH_RSA_WITH_AES_256_CBC_SHA 20-22 TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384 20-22 TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384 20-22 TLS_ECDH_RSA_WITH_NULL_SHA 20-22 TLS_ECDH_RSA_WITH_RC4_128_SHA 20-22 TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA 20-22 TLS_ECDH_anon_WITH_AES_128_CBC_SHA 20-22 TLS_ECDH_anon_WITH_AES_256_CBC_SHA 20-22 TLS_ECDH_anon_WITH_NULL_SHA 20-22 TLS_ECDH_anon_WITH_RC4_128_SHA 20-22 TLS_EMPTY_RENEGOTIATION_INFO_SCSV 20+ 20+ TLS_FALLBACK_SCSV 21+ TLS_NULL_WITH_NULL_NULL 1-8 TLS_PSK_WITH_3DES_EDE_CBC_SHA 21-22 TLS_PSK_WITH_AES_128_CBC_SHA 21+ 21+ TLS_PSK_WITH_AES_256_CBC_SHA 21+ 21+ TLS_PSK_WITH_RC4_128_SHA 21-25 TLS_RSA_EXPORT_WITH_DES40_CBC_SHA 1-8 1-8 TLS_RSA_WITH_3DES_EDE_CBC_SHA 1-8 1-8 TLS_RSA_WITH_AES_128_CBC_SHA 9+ 9+ TLS_RSA_WITH_AES_128_CBC_SHA256 20-28 TLS_RSA_WITH_AES_128_GCM_SHA256 20+ 20+ TLS_RSA_WITH_AES_256_CBC_SHA 9+ 20+ TLS_RSA_WITH_AES_256_CBC_SHA256 20-28 TLS_RSA_WITH_AES_256_GCM_SHA384 20+ 20+ TLS_RSA_WITH_DES_CBC_SHA 1-8 1-8 TLS_RSA_WITH_NULL_MD5 1-8 TLS_RSA_WITH_NULL_SHA 1-8 TLS_RSA_WITH_NULL_SHA256 20-22 NOTE : PSK cipher suites are enabled by default only if the  SSLContext  through
 which the engine was created has been initialized with a  PSKKeyManager ."
android,javax.net.ssl,SSLPermission,0,Legacy security code; do not use.
android,javax.net.ssl,SSLServerSocketFactory,3,"SSLServerSocketFactory s create
  SSLServerSocket s."
android,javax.net.ssl,StandardConstants,0,Standard constants definitions
android,javax.net.ssl,TrustManagerFactory,9,"This class acts as a factory for trust managers based on a
 source of trust material. Each trust manager manages a specific
 type of trust material for use by secure sockets. The trust
 material is based on a KeyStore and/or provider specific sources.

   Android provides the following  TrustManagerFactory  algorithms:
  Algorithm Supported API Levels PKIX 1+"
android,javax.net.ssl,X509ExtendedKeyManager,2,"Abstract class that provides for extension of the X509KeyManager
 interface.
  
 Methods in this class should be overriden to provide actual
 implementations."
android,javax.net.ssl,SSLSocket,26,"This class extends  Socket s and provides secure
 socket using protocols such as the ""Secure
 Sockets Layer"" (SSL) or IETF ""Transport Layer Security"" (TLS) protocols.
  
 Such sockets are normal stream sockets but they
 add a layer of security protections over the underlying network transport
 protocol such as TCP.  Those protections include:  Integrity Protection .  SSL protects against
      modification of messages by an active wiretapper.

       Authentication .  In most modes SSL provides
      peer authentication.  Servers are usually authenticated
      and clients may be authenticated as requested by servers.

       Confidentiality (Privacy Protection) .  In most
      modes SSL encrypts data being sent between client and server.
      This protects the confidentiality of data so that passive
      wiretappers won't see sensitive data such as financial
      information or personal information of many kinds.

       These kinds of protection are specified by a ""cipher suite"" which
 is a combination of cryptographic algorithms used by a given SSL connection.
 During the negotiation process the two endpoints must agree on
 a ciphersuite that is available in both environments.
 If there is no such suite in common no SSL connection can
 be established and no data can be exchanged.

   The cipher suite used is established by a negotiation process
 called ""handshaking"".  The goal of this
 process is to create or rejoin a ""session"" which may protect many
 connections over time.  After handshaking has completed you can access
 session attributes by using the  getSession  method.
 The initial handshake on this connection can be initiated in
 one of three ways:   calling  startHandshake  which explicitly
              begins handshakes or
        any attempt to read or write application data on
              this socket causes an implicit handshake or
        a call to  getSession  tries to set up a session
              if there is no currently valid session and
              an implicit handshake is done.
  If handshaking fails for any reason the  SSLSocket 
 is closed and no further communications can be done.

  There are two groups of cipher suites which you will need to know
 about when managing cipher suites:  Supported  cipher suites:  all the suites which are
      supported by the SSL implementation.  This list is reported
      using  getSupportedCipherSuites .

       Enabled  cipher suites which may be fewer
      than the full set of supported suites.  This group is
      set using the  setEnabledCipherSuites  method and
      queried using the  getEnabledCipherSuites  method.
      Initially a default set of cipher suites will be enabled on
      a new socket that represents the minimum suggested configuration.

        Implementation defaults require that only cipher
 suites which authenticate servers and provide confidentiality
 be enabled by default.
 Only if both sides explicitly agree to unauthenticated and/or
 non-private (unencrypted) communications will such a ciphersuite be
 selected.

  When  SSLSocket s are first created no handshaking
 is done so that applications may first set their communication
 preferences:  what cipher suites to use whether the socket should be
 in client or server mode etc.
 However security is always provided by the time that application data
 is sent over the connection.

   You may register to receive event notification of handshake
 completion.  This involves
 the use of two additional classes.   HandshakeCompletedEvent 
 objects are passed to  HandshakeCompletedListener  instances
 which are registered by users of this API.

  SSLSocket s are created by  SSLSocketFactory s
 or by  accept ing a connection from a
  SSLServerSocket .

  A SSL socket must choose to operate in the client or server mode.
 This will determine who begins the handshaking process as well
 as which messages should be sent by each party.  Each
 connection must have one client and one server or handshaking
 will not progress properly.  Once the initial handshaking has started a
 socket can not switch between client and server modes even when
 performing renegotiations.

  Default configuration for different Android versions SSLSocket  instances obtained from default  SSLSocketFactory 
  SSLServerSocketFactory  and  SSLContext  are configured as follows:

  
   tr.deprecated {
     background-color: #ccc;
     color: #999;
     font-style: italic;
   }
  Protocols Client socket:
  Protocol Supported (API Levels) Enabled by default (API Levels) SSLv3 1â€“25 1â€“22 TLSv1 1+ 1+ TLSv1.1 16+ 20+ TLSv1.2 16+ 20+ TLSv1.3 29+ 29+ Server socket:
  Protocol Supported (API Levels) Enabled by default (API Levels) SSLv3 1â€“25 1â€“22 TLSv1 1+ 1+ TLSv1.1 16+ 16+ TLSv1.2 16+ 16+ TLSv1.3 29+ 29+ Cipher suites Methods that operate with cipher suite names (for example
  getSupportedCipherSuites 
  setEnabledCipherSuites ) have used
 standard names for cipher suites since API Level 9 as listed in the table
 below. Prior to API Level 9 non-standard (OpenSSL) names had been used (see
 the table following this table).
  Cipher suite Supported (API Levels) Enabled by default (API Levels) SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA 9-22 9-19 SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA 9-22 9-19 SSL_DHE_DSS_WITH_DES_CBC_SHA 9-22 9-19 SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA 9-22 9-19 SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA 9-22 9-19 SSL_DHE_RSA_WITH_DES_CBC_SHA 9-22 9-19 SSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA 9-22 SSL_DH_anon_EXPORT_WITH_RC4_40_MD5 9-22 SSL_DH_anon_WITH_3DES_EDE_CBC_SHA 9-22 SSL_DH_anon_WITH_DES_CBC_SHA 9-22 SSL_DH_anon_WITH_RC4_128_MD5 9-22 SSL_RSA_EXPORT_WITH_DES40_CBC_SHA 9-22 9-19 SSL_RSA_EXPORT_WITH_RC4_40_MD5 9-22 9-19 SSL_RSA_WITH_3DES_EDE_CBC_SHA 9+ 9-19 SSL_RSA_WITH_DES_CBC_SHA 9-22 9-19 SSL_RSA_WITH_NULL_MD5 9-22 SSL_RSA_WITH_NULL_SHA 9-22 SSL_RSA_WITH_RC4_128_MD5 9-25 9-19 SSL_RSA_WITH_RC4_128_SHA 9-25 9-23 TLS_AES_128_GCM_SHA256 29+ 29+ TLS_AES_256_GCM_SHA384 29+ 29+ TLS_CHACHA20_POLY1305_SHA256 29+ 29+ TLS_DHE_DSS_WITH_AES_128_CBC_SHA 9-22 9-22 TLS_DHE_DSS_WITH_AES_128_CBC_SHA256 20-22 TLS_DHE_DSS_WITH_AES_128_GCM_SHA256 20-22 TLS_DHE_DSS_WITH_AES_256_CBC_SHA 9-22 11-22 TLS_DHE_DSS_WITH_AES_256_CBC_SHA256 20-22 TLS_DHE_DSS_WITH_AES_256_GCM_SHA384 20-22 TLS_DHE_RSA_WITH_AES_128_CBC_SHA 9-25 9-25 TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 20-25 TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 20-25 20-25 TLS_DHE_RSA_WITH_AES_256_CBC_SHA 9-25 11-25 TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 20-25 TLS_DHE_RSA_WITH_AES_256_GCM_SHA384 20-25 20-25 TLS_DH_anon_WITH_AES_128_CBC_SHA 9-22 TLS_DH_anon_WITH_AES_128_CBC_SHA256 20-22 TLS_DH_anon_WITH_AES_128_GCM_SHA256 20-22 TLS_DH_anon_WITH_AES_256_CBC_SHA 9-22 TLS_DH_anon_WITH_AES_256_CBC_SHA256 20-22 TLS_DH_anon_WITH_AES_256_GCM_SHA384 20-22 TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA 11-22 11-19 TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA 11+ 11+ TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 20-28 TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 20+ 20+ TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA 11+ 11+ TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 20-28 TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 20+ 20+ TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 24+ 24+ TLS_ECDHE_ECDSA_WITH_NULL_SHA 11-22 TLS_ECDHE_ECDSA_WITH_RC4_128_SHA 11-25 11-23 TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA 21+ 21+ TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA 21+ 21+ TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256 24+ 24+ TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA 11-22 11-19 TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA 11+ 11+ TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 20-28 TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 20+ 20+ TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA 11+ 11+ TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 20-28 TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 20+ 20+ TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 24+ 24+ TLS_ECDHE_RSA_WITH_NULL_SHA 11-22 TLS_ECDHE_RSA_WITH_RC4_128_SHA 11-25 11-23 TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA 11-22 11-19 TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA 11-22 11-19 TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256 20-22 TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256 20-22 TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA 11-22 11-19 TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384 20-22 TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384 20-22 TLS_ECDH_ECDSA_WITH_NULL_SHA 11-22 TLS_ECDH_ECDSA_WITH_RC4_128_SHA 11-22 11-19 TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA 11-22 11-19 TLS_ECDH_RSA_WITH_AES_128_CBC_SHA 11-22 11-19 TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256 20-22 TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256 20-22 TLS_ECDH_RSA_WITH_AES_256_CBC_SHA 11-22 11-19 TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384 20-22 TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384 20-22 TLS_ECDH_RSA_WITH_NULL_SHA 11-22 TLS_ECDH_RSA_WITH_RC4_128_SHA 11-22 11-19 TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA 11-22 TLS_ECDH_anon_WITH_AES_128_CBC_SHA 11-22 TLS_ECDH_anon_WITH_AES_256_CBC_SHA 11-22 TLS_ECDH_anon_WITH_NULL_SHA 11-22 TLS_ECDH_anon_WITH_RC4_128_SHA 11-22 TLS_EMPTY_RENEGOTIATION_INFO_SCSV 11+ 11+ TLS_FALLBACK_SCSV 21+ TLS_PSK_WITH_3DES_EDE_CBC_SHA 21-22 TLS_PSK_WITH_AES_128_CBC_SHA 21+ 21+ TLS_PSK_WITH_AES_256_CBC_SHA 21+ 21+ TLS_PSK_WITH_RC4_128_SHA 21-25 TLS_RSA_WITH_AES_128_CBC_SHA 9+ 9+ TLS_RSA_WITH_AES_128_CBC_SHA256 20-28 TLS_RSA_WITH_AES_128_GCM_SHA256 20+ 20+ TLS_RSA_WITH_AES_256_CBC_SHA 9+ 11+ TLS_RSA_WITH_AES_256_CBC_SHA256 20-28 TLS_RSA_WITH_AES_256_GCM_SHA384 20+ 20+ TLS_RSA_WITH_NULL_SHA256 20-22 NOTE : PSK cipher suites are enabled by default only if the  SSLContext  through
 which the socket was created has been initialized with a  PSKKeyManager .

  API Levels 1 to 8 use OpenSSL names for cipher suites. The table below
 lists these OpenSSL names and their corresponding standard names used in API
 Levels 9 and newer.
  OpenSSL cipher suite Standard cipher suite Supported (API Levels) Enabled by default (API Levels) AES128-SHA TLS_RSA_WITH_AES_128_CBC_SHA 1+ 1+ AES256-SHA TLS_RSA_WITH_AES_256_CBC_SHA 1+ 1â€“8 11+ DES-CBC-MD5 SSL_CK_DES_64_CBC_WITH_MD5 1â€“8 1â€“8 DES-CBC-SHA SSL_RSA_WITH_DES_CBC_SHA 1â€“22 1â€“19 DES-CBC3-MD5 SSL_CK_DES_192_EDE3_CBC_WITH_MD5 1â€“8 1â€“8 DES-CBC3-SHA SSL_RSA_WITH_3DES_EDE_CBC_SHA 1+ 1â€“19 DHE-DSS-AES128-SHA TLS_DHE_DSS_WITH_AES_128_CBC_SHA 1â€“22 1â€“22 DHE-DSS-AES256-SHA TLS_DHE_DSS_WITH_AES_256_CBC_SHA 1â€“22 1â€“8 11â€“22 DHE-RSA-AES128-SHA TLS_DHE_RSA_WITH_AES_128_CBC_SHA 1+ 1+ DHE-RSA-AES256-SHA TLS_DHE_RSA_WITH_AES_256_CBC_SHA 1+ 1â€“8 11+ EDH-DSS-DES-CBC-SHA SSL_DHE_DSS_WITH_DES_CBC_SHA 1â€“22 1â€“19 EDH-DSS-DES-CBC3-SHA SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA 1â€“22 1â€“19 EDH-RSA-DES-CBC-SHA SSL_DHE_RSA_WITH_DES_CBC_SHA 1â€“22 1â€“19 EDH-RSA-DES-CBC3-SHA SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA 1â€“22 1â€“19 EXP-DES-CBC-SHA SSL_RSA_EXPORT_WITH_DES40_CBC_SHA 1â€“22 1â€“19 EXP-EDH-DSS-DES-CBC-SHA SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA 1â€“22 1â€“19 EXP-EDH-RSA-DES-CBC-SHA SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA 1â€“22 1â€“19 EXP-RC2-CBC-MD5 SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5 1â€“8 1â€“8 EXP-RC4-MD5 SSL_RSA_EXPORT_WITH_RC4_40_MD5 1â€“22 1â€“19 RC2-CBC-MD5 SSL_CK_RC2_128_CBC_WITH_MD5 1â€“8 1â€“8 RC4-MD5 SSL_RSA_WITH_RC4_128_MD5 1â€“25 1â€“19 RC4-SHA SSL_RSA_WITH_RC4_128_SHA 1â€“25 1â€“23"
android,javax.xml.transform,OutputKeys,0,"Provides string constants that can be used to set
 output properties for a Transformer or to retrieve
 output properties from a Transformer or Templates object.
  All the fields in this class are read-only."
android,javax.xml.transform,Transformer,13,"An instance of this abstract class can transform a
 source tree into a result tree.

  An instance of this class can be obtained with the
  TransformerFactory#newTransformer 
 method. This instance may then be used to process XML from a
 variety of sources and write the transformation output to a
 variety of sinks. An object of this class may not be used in multiple threads
 running concurrently.  Different Transformers may be used
 concurrently by different threads. A  Transformer  may be used multiple times.  Parameters and
 output properties are preserved across transformations."
android,javax.xml.transform,TransformerFactory,14,"A TransformerFactory instance can be used to create
  Transformer  and
  Templates  objects. The system property that determines which Factory implementation
 to create is named  ""javax.xml.transform.TransformerFactory"" .
 This property names a concrete subclass of the
  TransformerFactory  abstract class. If the property is not
 defined a platform default is be used."
android,javax.xml.transform.dom,DOMResult,6,"Acts as a holder for a transformation result tree in the form of a Document Object Model (DOM) tree. If no output DOM source is set the transformation will create a Document node as the holder for the result of the transformation
 which may be retrieved with  getNode() ."
android,javax.xml.transform.dom,DOMSource,4,"Acts as a holder for a transformation Source tree in the
 form of a Document Object Model (DOM) tree. Note that XSLT requires namespace support. Attempting to transform a DOM
 that was not contructed with a namespace-aware parser may result in errors.
 Parsers can be made namespace aware by calling
  DocumentBuilderFactory.setNamespaceAware(boolean) ."
android,javax.xml.transform.sax,SAXResult,6,Acts as an holder for a transformation Result.
android,javax.xml.transform.sax,SAXSource,7,"Acts as an holder for SAX-style Source. Note that XSLT requires namespace support. Attempting to transform an
 input source that is not
 generated with a namespace-aware parser may result in errors.
 Parsers can be made namespace aware by calling the
  SAXParserFactory.setNamespaceAware(boolean)  method."
android,javax.xml.transform.sax,SAXTransformerFactory,6,"This class extends TransformerFactory to provide SAX-specific
 factory methods.  It provides two types of ContentHandlers
 one for creating Transformers the other for creating Templates
 objects.

  If an application wants to set the ErrorHandler or EntityResolver
 for an XMLReader used during a transformation it should use a URIResolver
 to return the SAXSource which provides (with getXMLReader) a reference to
 the XMLReader."
android,javax.xml.transform.stream,StreamResult,7,"Acts as an holder for a transformation result
 which may be XML plain Text HTML or some other form of markup."
android,javax.xml.transform.stream,StreamSource,9,"Acts as an holder for a transformation Source in the form
 of a stream of XML markup. Note:  Due to their internal use of either a  Reader  or  InputStream  instance
  StreamSource  instances may only be used once."
android,javax.xml.validation,Schema,2,"Immutable in-memory representation of grammar.

  
 This object represents a set of constraints that can be checked/
 enforced against an XML document.

  
 A  Schema  object is thread safe and applications are
 encouraged to share it across many parsers in many threads.

  
 A  Schema  object is immutable in the sense that it shouldn't
 change the set of constraints once it is created. In other words
 if an application validates the same document twice against the same
  Schema  it must always produce the same result.

  
 A  Schema  object is usually created from  SchemaFactory .

  
 Two kinds of validators can be created from a  Schema  object.
 One is  Validator  which provides highly-level validation
 operations that cover typical use cases. The other is
  ValidatorHandler  which works on top of SAX for better
 modularity.

  
 This specification does not refine
 the  Object.equals(java.lang.Object)  method.
 In other words if you parse the same schema twice you may
 still get  !schemaA.equals(schemaB) ."
android,javax.xml.validation,SchemaFactory,16,"Factory that creates  Schema  objects. Entry-point to
 the validation API.

  SchemaFactory  is a schema compiler. It reads external
 representations of schemas and prepares them for validation.

  
 The  SchemaFactory  class is not thread-safe. In other words
 it is the application's responsibility to ensure that at most
 one thread is using a  SchemaFactory  object at any
 given moment. Implementations are encouraged to mark methods
 as  synchronized  to protect themselves from broken clients.

  SchemaFactory  is not re-entrant. While one of the
  newSchema  methods is being invoked applications
 may not attempt to recursively invoke the  newSchema  method
 even from the same thread."
android,javax.xml.validation,SchemaFactoryLoader,1,"This class was removed from JAXP 1.3 before it was finalized but
 was mistakenly included in Java 5. It only exists now for compatibility
 reasons. Applications should avoid using it."
android,javax.xml.validation,TypeInfoProvider,4,"This class provides access to the type information determined
 by  ValidatorHandler .

  
 Some schema languages such as W3C XML Schema encourages a validator
 to report the ""type"" it assigns to each attribute/element.
 Those applications who wish to access this type information can invoke
 methods defined on this ""interface"" to access such type information.

  
 Implementation of this ""interface"" can be obtained through the
  ValidatorHandler#getTypeInfoProvider()  method."
android,javax.xml.validation,Validator,11,"A processor that checks an XML document against  Schema . 
 A validator is a thread-unsafe and non-reentrant object.
 In other words it is the application's responsibility to make
 sure that one  Validator  object is not used from
 more than one thread at any given time and while the  validate 
 method is invoked applications may not recursively call
 the  validate  method.
  

 Note that while the  validate(javax.xml.transform.Source)  and  validate(javax.xml.transform.Source javax.xml.transform.Result) 
 methods take a  Source  instance the  Source 
 instance must be a  SAXSource   DOMSource   StAXSource  or  StreamSource ."
android,javax.xml.validation,ValidatorHandler,11,"Streaming validator that works on SAX stream.

  
 A  ValidatorHandler  object is a thread-unsafe non-reentrant object.
 In other words it is the application's responsibility to make
 sure that one  ValidatorHandler  object is not used from
 more than one thread at any given time.

  ValidatorHandler  checks if the SAX events follow
 the set of constraints described in the associated  Schema 
 and additionally it may modify the SAX events (for example
 by adding default values etc.)

  ValidatorHandler  extends from  ContentHandler 
 but it refines the underlying  ContentHandler  in
 the following way:
  startElement/endElement events must receive non-null String
      for  uri   localName  and  qname 
      even though SAX allows some of them to be null.
      Similarly the user-specified  ContentHandler  will receive non-null
      Strings for all three parameters.

   Applications must ensure that  ValidatorHandler 's
       ContentHandler#startPrefixMapping(StringString)  and
       ContentHandler#endPrefixMapping(String)  are invoked
      properly. Similarly the user-specified  ContentHandler 
      will receive startPrefixMapping/endPrefixMapping events.
      If the  ValidatorHandler  introduces additional namespace
      bindings the user-specified  ContentHandler  will receive
      additional startPrefixMapping/endPrefixMapping events.

   Attributes  for the
       ContentHandler#startElement(StringStringStringAttributes)  method
      may or may not include xmlns* attributes.
  
 A  ValidatorHandler  is automatically reset every time
 the startDocument method is invoked."
android,javax.xml.xpath,XPathConstants,0,XPath constants.
android,javax.xml.xpath,XPathFactory,9,"An  XPathFactory  instance can be used to create
  XPath  objects. See  newInstance(java.lang.String)  for lookup mechanism."
android,junit.framework,Assert,38,A set of assert methods.  Messages are only displayed when an assert fails.
android,junit.framework,TestCase,11,"A test case defines the fixture to run multiple tests. To define a test case implement a subclass of  TestCase define instance variables that store the state of the fixture initialize the fixture state by overriding  setUp() clean-up after a test by overriding  tearDown() . 
 public class MathTest extends TestCase {
    protected double fValue1;
    protected double fValue2;

    protected void setUp() {
       fValue1= 2.0;
       fValue2= 3.0;
    }
 }
  Assert.assertTrue(String boolean) 
    public void testAdd() {
       double result= fValue1 + fValue2;
       assertTrue(result == 5.0);
    }
  
 TestCase test= new MathTest(""add"") {
    public void runTest() {
       testAdd();
    }
 };
 test.run();
  runTest() 
 TestCase test= new MathTest(""testAdd"");
 test.run();
  test runners suite 
 public static Test suite() {
    suite.addTest(new MathTest(""testAdd""));
    suite.addTest(new MathTest(""testDivideByZero""));
    return suite;
 }"
android,junit.framework,TestFailure,6,"A  TestFailure  collects a failed test together with
 the caught exception."
android,junit.framework,TestResult,16,"A  TestResult  collects the results of executing
 a test case. It is an instance of the Collecting Parameter pattern.
 The test framework distinguishes between  failures  and  errors .
 A failure is anticipated and checked for with assertions. Errors are
 unanticipated problems like an  ArrayIndexOutOfBoundsException ."
android,junit.framework,TestSuite,14,"A  TestSuite  is a  Composite  of Tests.
 It runs a collection of test cases. Here is an example using
 the dynamic test definition.
  
 TestSuite suite= new TestSuite();
 suite.addTest(new MathTest(""testAdd""));
 suite.addTest(new MathTest(""testDivideByZero""));
  Alternatively a TestSuite can extract the tests to be run automatically.
 To do so you pass the class of your TestCase class to the
 TestSuite constructor.
  
 TestSuite suite= new TestSuite(MathTest.class);
  This constructor creates a suite with all the methods
 starting with ""test"" that take no arguments. A final option is to do the same for a large array of test classes.
  
 Class[] testClasses = { MathTest.class AnotherTest.class }
 TestSuite suite= new TestSuite(testClasses);"
android,junit.runner,BaseTestRunner,28,"Base class for all test runners.
 This class was born live on stage in Sardinia during XP2000."
android,junit.runner,Version,1,This class defines the current version of JUnit
android,org.apache.http.params,HttpConnectionParams,12,"An adaptor for accessing connection parameters in  HttpParams .
  
 Note that the  implements  relation to  CoreConnectionPNames 
 is for compatibility with existing application code only. References to
 the parameter names should use the interface not this class."
android,org.apache.http.conn.ssl,AbstractVerifier,8,"Abstract base class for all standard  X509HostnameVerifier 
 implementations."
android,org.apache.http.conn.ssl,AllowAllHostnameVerifier,2,"The ALLOW_ALL HostnameVerifier essentially turns hostname verification
 off. This implementation is a no-op and never throws the SSLException."
android,org.apache.http.conn.ssl,BrowserCompatHostnameVerifier,2,The HostnameVerifier that works the same way as Curl and Firefox.
android,org.apache.http.conn.ssl,SSLSocketFactory,7,"Layered socket factory for TLS/SSL connections based on JSSE.
.
  
 SSLSocketFactory can be used to validate the identity of the HTTPS
 server against a list of trusted certificates and to authenticate to
 the HTTPS server using a private key.
  
 SSLSocketFactory will enable server authentication when supplied with
 a  KeyStore  file containg one or several trusted
 certificates. The client secure socket will reject the connection during
 the SSL session handshake if the target HTTPS server attempts to
 authenticate itself with a non-trusted certificate.
  
 Use JDK keytool utility to import a trusted certificate and generate a truststore file:
     
     keytool -import -alias ""my server cert"" -file server.crt -keystore my.truststore
     
 SSLSocketFactory will enable client authentication when supplied with
 a  KeyStore  file containg a private key/public certificate
 pair. The client secure socket will use the private key to authenticate
 itself to the target HTTPS server during the SSL session handshake if
 requested to do so by the server.
 The target HTTPS server will in its turn verify the certificate presented
 by the client in order to establish client's authenticity
  
 Use the following sequence of actions to generate a keystore file
  
      Use JDK keytool utility to generate a new key
       keytool -genkey -v -alias ""my client key"" -validity 365 -keystore my.keystore 
      For simplicity use the same password for the key as that of the keystore
      
      
      Issue a certificate signing request (CSR)
       keytool -certreq -alias ""my client key"" -file mycertreq.csr -keystore my.keystore 
      Send the certificate request to the trusted Certificate Authority for signature.
      One may choose to act as her own CA and sign the certificate request using a PKI
      tool such as OpenSSL.
       
       Import the trusted CA root certificate
        keytool -import -alias ""my trusted ca"" -file caroot.crt -keystore my.keystore 
       Import the PKCS#7 file containg the complete certificate chain
        keytool -import -alias ""my client key"" -file mycert.p7 -keystore my.keystore 
       Verify the content the resultant keystore file
        keytool -list -v -keystore my.keystore"
android,org.apache.http.conn.ssl,StrictHostnameVerifier,2,"The Strict HostnameVerifier works the same way as Sun Java 1.4 Sun
 Java 5 Sun Java 6-rc.  It's also pretty close to IE6.  This
 implementation appears to be compliant with RFC 2818 for dealing with
 wildcards."
android,org.json,JSONArray,40,"A dense indexed sequence of values. Values may be any mix of
  JSONObject  other  JSONArray  Strings
 Booleans Integers Longs Doubles  null  or  JSONObject#NULL .
 Values may not be  Double#isNaN()   Double#isInfinite()  or of any type not listed here.

  JSONArray  has the same type coercion behavior and
 optional/mandatory accessors as  JSONObject . See that class'
 documentation for details.

  Warning:  this class represents null in two incompatible
 ways: the standard Java  null  reference and the sentinel value  JSONObject#NULL . In particular  get  fails if the requested index
 holds the null reference but succeeds if it holds  JSONObject.NULL .

  Instances of this class are not thread safe. Although this class is
 nonfinal it was not designed for inheritance and should not be subclassed.
 In particular self-use by overridable methods is not specified. See
  Effective Java  Item 17 ""Design and Document or inheritance or else
 prohibit it"" for further information."
android,org.json,JSONObject,40,"A modifiable set of name/value mappings. Names are unique non-null strings.
 Values may be any mix of  JSONObject   JSONArray  Strings Booleans Integers Longs Doubles or  NULL .
 Values may not be  null   Double#isNaN()   Double#isInfinite()  or of any type not listed here.

  This class can coerce values to another type when requested.
  When the requested type is a boolean strings will be coerced using a
       case-insensitive comparison to ""true"" and ""false"".
    When the requested type is a double other  Number  types will
       be coerced using  Number#doubleValue() . Strings
       that can be coerced using  Double#valueOf(String)  will be.
    When the requested type is an int other  Number  types will
       be coerced using  Number#intValue() . Strings
       that can be coerced using  Double#valueOf(String)  will be
       and then cast to int.
    When the requested type is a long other  Number  types will
       be coerced using  Number#longValue() . Strings
       that can be coerced using  Double#valueOf(String)  will be
       and then cast to long. This two-step conversion is lossy for very
       large values. For example the string ""9223372036854775806"" yields the
       long 9223372036854775807. When the requested type is a String other non-null values will be
       coerced using  String#valueOf(Object) . Although null cannot be
       coerced the sentinel value  JSONObject#NULL  is coerced to the
       string ""null"".
  This class can look up both mandatory and optional values:
  Use  get Type ()  to retrieve a mandatory value. This
       fails with a  JSONException  if the requested name has no value
       or if the value cannot be coerced to the requested type.
    Use  opt Type ()  to retrieve an optional value. This
       returns a system- or user-supplied default if the requested name has no
       value or if the value cannot be coerced to the requested type.
  Warning:  this class represents null in two incompatible
 ways: the standard Java  null  reference and the sentinel value  JSONObject#NULL . In particular calling  put(name null)  removes the
 named entry from the object but  put(name JSONObject.NULL)  stores an
 entry whose value is  JSONObject.NULL .

  Instances of this class are not thread safe. Although this class is
 nonfinal it was not designed for inheritance and should not be subclassed.
 In particular self-use by overrideable methods is not specified. See
  Effective Java  Item 17 ""Design and Document or inheritance or else
 prohibit it"" for further information."
android,org.json,JSONStringer,10,"Implements  JSONObject#toString  and  JSONArray#toString . Most
 application developers should use those methods directly and disregard this
 API. For example: 
 JSONObject object = ...
 String json = object.toString(); Stringers only encode well-formed JSON strings. In particular:
  The stringer must have exactly one top-level array or object.
    Lexical scopes must be balanced: every call to  array()  must
       have a matching call to  endArray()  and every call to  object()  must have a matching call to  endObject() .
    Arrays may not contain keys (property names).
    Objects must alternate keys (property names) and values.
    Values are inserted with either literal  value 
       calls or by nesting arrays or objects.
  JSONException This class provides no facility for pretty-printing (ie. indenting)
 output. To encode indented output use  JSONObject#toString(int)  or
  JSONArray#toString(int) .

  Some implementations of the API support at most 20 levels of nesting.
 Attempts to create more than 20 levels of nesting may fail with a  JSONException .

  Each stringer may be used to encode a single top level value. Instances of
 this class are not thread safe. Although this class is nonfinal it was not
 designed for inheritance and should not be subclassed. In particular
 self-use by overrideable methods is not specified. See  Effective Java 
 Item 17 ""Design and Document or inheritance or else prohibit it"" for further
 information."
android,org.json,JSONTokener,15,"Parses a JSON ( RFC 4627 )
 encoded string into the corresponding object. Most clients of
 this class will use only need the  constructor 
 and  nextValue()  method. Example usage:  
 String json = ""{""
         + ""  \""query\"": \""Pizza\"" ""
         + ""  \""locations\"": [ 94043 90210 ] ""
         + ""}"";

 JSONObject object = (JSONObject) new JSONTokener(json).nextValue();
 String query = object.getString(""query"");
 JSONArray locations = object.getJSONArray(""locations""); For best interoperability and performance use JSON that complies with
 RFC 4627 such as that generated by  JSONStringer . For legacy reasons
 this parser is lenient so a successful parse does not indicate that the
 input string was valid JSON. All of the following syntax errors will be
 ignored:
  End of line comments starting with  //  or  #  and ending
       with a newline character.
    C-style comments starting with  /*  and ending with
        * / . Such comments may not be nested.
    Strings that are unquoted or  'single quoted' .
    Hexadecimal integers prefixed with  0x  or  0X .
    Octal integers prefixed with  0 .
    Array elements separated by  ; .
    Unnecessary array separators. These are interpreted as if null was the
       omitted value.
    Key-value pairs separated by  =  or  => .
    Key-value pairs separated by  ; .
  Each tokener may be used to parse a single JSON string. Instances of this
 class are not thread safe. Although this class is nonfinal it was not
 designed for inheritance and should not be subclassed. In particular
 self-use by overrideable methods is not specified. See  Effective Java 
 Item 17 ""Design and Document or inheritance or else prohibit it"" for further
 information."
android,org.xml.sax,HandlerBase,14,"Default base class for handlers.

  This module both source code and documentation is in the
 Public Domain and comes with  NO WARRANTY . 
 See  http://www.saxproject.org 
 for further information.
  This class implements the default behaviour for four SAX1
 interfaces: EntityResolver DTDHandler DocumentHandler
 and ErrorHandler.  It is now obsolete but is included in SAX2 to
 support legacy SAX1 applications.  SAX2 applications should use
 the  DefaultHandler 
 class instead. Application writers can extend this class when they need to
 implement only part of an interface; parser writers can
 instantiate this class to provide default handlers when the
 application has not supplied its own. Note that the use of this class is optional."
android,org.xml.sax,InputSource,10,"A single input source for an XML entity.

  This module both source code and documentation is in the
 Public Domain and comes with  NO WARRANTY . 
 See  http://www.saxproject.org 
 for further information.
  This class allows a SAX application to encapsulate information
 about an input source in a single object which may include
 a public identifier a system identifier a byte stream (possibly
 with a specified encoding) and/or a character stream. There are two places that the application can deliver an
 input source to the parser: as the argument to the Parser.parse
 method or as the return value of the EntityResolver.resolveEntity
 method. The SAX parser will use the InputSource object to determine how
 to read XML input.  If there is a character stream available the
 parser will read that stream directly disregarding any text
 encoding declaration found in that stream.
 If there is no character stream but there is
 a byte stream the parser will use that byte stream using the
 encoding specified in the InputSource or else (if no encoding is
 specified) autodetecting the character encoding using an algorithm
 such as the one in the XML specification.  If neither a character
 stream nor a
 byte stream is available the parser will attempt to open a URI
 connection to the resource identified by the system
 identifier. An InputSource object belongs to the application: the SAX parser
 shall never modify it in any way (it may modify a copy if
 necessary).  However standard processing of both byte and
 character streams is to close them on as part of end-of-parse cleanup
 so applications should not attempt to re-use such streams after they
 have been handed to a parser."
android,org.xml.sax.ext,Attributes2Impl,11,"SAX2 extension helper for additional Attributes information
 implementing the  Attributes2  interface.

  This module both source code and documentation is in the
 Public Domain and comes with  NO WARRANTY . This is not part of core-only SAX2 distributions. The  specified  flag for each attribute will always
 be true unless it has been set to false in the copy constructor
 or using  setSpecified(int boolean) .
 Similarly the  declared  flag for each attribute will
 always be false except for defaulted attributes ( specified 
 is false) non-CDATA attributes or when it is set to true using
  setDeclared(int boolean) .
 If you change an attribute's type by hand you may need to modify
 its  declared  flag to match."
android,org.xml.sax.ext,DefaultHandler2,14,"This class extends the SAX2 base handler class to support the
 SAX2  LexicalHandler   DeclHandler  and
  EntityResolver2  extensions.  Except for overriding the
 original SAX1  DefaultHandler#resolveEntity 
 method the added handler methods just return.  Subclassers may
 override everything on a method-by-method basis.

  This module both source code and documentation is in the
 Public Domain and comes with  NO WARRANTY . Note:  this class might yet learn that the
  ContentHandler.setDocumentLocator()  call might be passed a
  Locator2  object and that the
  ContentHandler.startElement()  call might be passed a
  Attributes2  object."
android,org.xml.sax.ext,Locator2Impl,4,"SAX2 extension helper for holding additional Entity information
 implementing the  Locator2  interface.

  This module both source code and documentation is in the
 Public Domain and comes with  NO WARRANTY .  This is not part of core-only SAX2 distributions."
android,org.xmlpull.v1,XmlPullParserFactory,10,This class is used to create implementations of XML Pull Parser defined in XMPULL V1 API.
android,org.xmlpull.v1.sax2,Driver,32,"SAX2 Driver that pulls events from XmlPullParser
 and converts them into SAX2 callbacks."
android,org.xml.sax.helpers,AttributeListImpl,10,"Default implementation for AttributeList.

  This module both source code and documentation is in the
 Public Domain and comes with  NO WARRANTY . 
 See  http://www.saxproject.org 
 for further information.
  AttributeList implements the deprecated SAX1  AttributeList  interface and has been
 replaced by the new SAX2  AttributesImpl  interface. This class provides a convenience implementation of the SAX
  AttributeList  interface.  This
 implementation is useful both for SAX parser writers who can use
 it to provide attributes to the application and for SAX application
 writers who can use it to create a persistent copy of an element's
 attribute specifications: 
 private AttributeList myatts;

 public void startElement (String name AttributeList atts)
 {
              // create a persistent copy of the attribute list
              // for use outside this method
   myatts = new AttributeListImpl(atts);
   [...]
 }
  Please note that SAX parsers are not required to use this
 class to provide an implementation of AttributeList; it is
 supplied only as an optional convenience.  In particular
 parser writers are encouraged to invent more efficient
 implementations."
android,org.xml.sax.helpers,AttributesImpl,22,"Default implementation of the Attributes interface.

  This module both source code and documentation is in the
 Public Domain and comes with  NO WARRANTY . 
 See  http://www.saxproject.org 
 for further information.
  This class provides a default implementation of the SAX2
  Attributes  interface with the
 addition of manipulators so that the list can be modified or
 reused. There are two typical uses of this class: to take a persistent snapshot of an Attributes object
  in a  startElement  event; or to construct or modify an Attributes object in a SAX2 driver or filter. This class replaces the now-deprecated SAX1  AttributeListImpl 
 class; in addition to supporting the updated Attributes
 interface rather than the deprecated  AttributeList  interface it also includes a much more efficient
 implementation using a single array rather than a set of Vectors."
android,org.xml.sax.helpers,DefaultHandler,17,"Default base class for SAX2 event handlers.

  This module both source code and documentation is in the
 Public Domain and comes with  NO WARRANTY . 
 See  http://www.saxproject.org 
 for further information.
  This class is available as a convenience base class for SAX2
 applications: it provides default implementations for all of the
 callbacks in the four core SAX2 handler classes: EntityResolver DTDHandler ContentHandler ErrorHandler Application writers can extend this class when they need to
 implement only part of an interface; parser writers can
 instantiate this class to provide default handlers when the
 application has not supplied its own. This class replaces the deprecated SAX1
  HandlerBase  class."
android,org.xml.sax.helpers,LocatorImpl,8,"Provide an optional convenience implementation of Locator.

  This module both source code and documentation is in the
 Public Domain and comes with  NO WARRANTY . 
 See  http://www.saxproject.org 
 for further information.
  This class is available mainly for application writers who
 can use it to make a persistent snapshot of a locator at any
 point during a document parse: 
 Locator locator;
 Locator startloc;

 public void setLocator (Locator locator)
 {
         // note the locator
   this.locator = locator;
 }

 public void startDocument ()
 {
         // save the location of the start of the document
         // for future use.
   Locator startloc = new LocatorImpl(locator);
 }
 Normally parser writers will not use this class since it
 is more efficient to provide location information only when
 requested rather than constantly updating a Locator object."
android,org.xml.sax.helpers,NamespaceSupport,12,"Encapsulate Namespace logic for use by applications using SAX
 or internally by SAX drivers.

  This module both source code and documentation is in the
 Public Domain and comes with  NO WARRANTY . 
 See  http://www.saxproject.org 
 for further information.
  This class encapsulates the logic of Namespace processing: it
 tracks the declarations currently in force for each context and
 automatically processes qualified XML names into their Namespace
 parts; it can also be used in reverse for generating XML qnames
 from Namespaces. Namespace support objects are reusable but the reset method
 must be invoked between each session. Here is a simple session: 
 String parts[] = new String[3];
 NamespaceSupport support = new NamespaceSupport();

 support.pushContext();
 support.declarePrefix("""" ""http://www.w3.org/1999/xhtml"");
 support.declarePrefix(""dc"" ""http://www.purl.org/dc#"");

 parts = support.processName(""p"" parts false);
 System.out.println(""Namespace URI: "" + parts[0]);
 System.out.println(""Local name: "" + parts[1]);
 System.out.println(""Raw name: "" + parts[2]);

 parts = support.processName(""dc:title"" parts false);
 System.out.println(""Namespace URI: "" + parts[0]);
 System.out.println(""Local name: "" + parts[1]);
 System.out.println(""Raw name: "" + parts[2]);

 support.popContext();
  Note that this class is optimized for the use case where most
 elements do not contain Namespace declarations: if the same
 prefix/URI mapping is repeated for each context (for example) this
 class will be somewhat less efficient. Although SAX drivers (parsers) may choose to use this class to
 implement namespace handling they are not required to do so.
 Applications must track namespace information themselves if they
 want to use namespace information."
android,org.xml.sax.helpers,ParserFactory,2,"Java-specific class for dynamically loading SAX parsers.

  This module both source code and documentation is in the
 Public Domain and comes with  NO WARRANTY . 
 See  http://www.saxproject.org 
 for further information.
  Note:  This class is designed to work with the now-deprecated
 SAX1  Parser  class.  SAX2 applications should use
  XMLReaderFactory  instead. ParserFactory is not part of the platform-independent definition
 of SAX; it is an additional convenience class designed
 specifically for Java XML application writers.  SAX applications
 can use the static methods in this class to allocate a SAX parser
 dynamically at run-time based either on the value of the
 `org.xml.sax.parser' system property or on a string containing the class
 name. Note that the application still requires an XML parser that
 implements SAX1."
android,org.xml.sax.helpers,XMLFilterImpl,33,"Base class for deriving an XML filter.

  This module both source code and documentation is in the
 Public Domain and comes with  NO WARRANTY . 
 See  http://www.saxproject.org 
 for further information.
  This class is designed to sit between an  XMLReader  and the client application's event handlers.  By default it
 does nothing but pass requests up to the reader and events
 on to the handlers unmodified but subclasses can override
 specific methods to modify the event stream or the configuration
 requests as they pass through."
android,org.xml.sax.helpers,ParserAdapter,22,"Adapt a SAX1 Parser as a SAX2 XMLReader.

  This module both source code and documentation is in the
 Public Domain and comes with  NO WARRANTY . 
 See  http://www.saxproject.org 
 for further information.
  This class wraps a SAX1  Parser 
 and makes it act as a SAX2  XMLReader 
 with feature property and Namespace support.  Note
 that it is not possible to report  skippedEntity  events since SAX1 does not make that information available. This adapter does not test for duplicate Namespace-qualified
 attribute names."
android,org.xml.sax.helpers,XMLReaderAdapter,18,"Adapt a SAX2 XMLReader as a SAX1 Parser.

  This module both source code and documentation is in the
 Public Domain and comes with  NO WARRANTY . 
 See  http://www.saxproject.org 
 for further information.
  This class wraps a SAX2  XMLReader 
 and makes it act as a SAX1  Parser .  The XMLReader
 must support a true value for the
 http://xml.org/sax/features/namespace-prefixes property or parsing will fail
 with a  SAXException ; if the XMLReader
 supports a false value for the http://xml.org/sax/features/namespaces
 property that will also be used to improve efficiency."
android,org.xml.sax.helpers,XMLReaderFactory,2,"Factory for creating an XML reader.

  This module both source code and documentation is in the
 Public Domain and comes with  NO WARRANTY . 
 See  http://www.saxproject.org 
 for further information.
  This class contains static methods for creating an XML reader
 from an explicit class name or based on runtime defaults: 
 try {
   XMLReader myReader = XMLReaderFactory.createXMLReader();
 } catch (SAXException e) {
   System.err.println(e.getMessage());
 }
  Note to Distributions bundled with parsers: 
 You should modify the implementation of the no-arguments
  createXMLReader  to handle cases where the external
 configuration mechanisms aren't set up.  That method should do its
 best to return a parser when one is in the class path even when
 nothing bound its class name to  org.xml.sax.driver  so
 those configuration mechanisms would see it."
android,widget,AbsoluteLayout,7,"A layout that lets you specify exact locations (x/y coordinates) of its
 children. Absolute layouts are less flexible and harder to maintain than
 other types of layouts without absolute positioning.

  XML attributes  See  ViewGroup Attributes   View Attributes"
android,widget,AbsoluteLayout.LayoutParams,1,"Per-child layout information associated with AbsoluteLayout.
 See
  Absolute Layout Attributes 
 for a list of all child view attributes that this class supports."
android,widget,AbsSeekBar,36,AbsSeekBar extends the capabilities of ProgressBar by adding a draggable thumb.
android,widget,ActionMenuView.LayoutParams,0,
android,widget,AdapterView.AdapterContextMenuInfo,0,"Extra menu information provided to the
  View.OnCreateContextMenuListener.onCreateContextMenu(ContextMenu View ContextMenuInfo) 
 callback when a context menu is brought up for this AdapterView."
android,widget,AdapterViewAnimator,29,"Base class for a  AdapterView  that will perform animations
 when switching between its views."
android,widget,AutoCompleteTextView,58,"An editable text view that shows completion suggestions automatically
 while the user is typing. The list of suggestions is displayed in a drop
 down menu from which the user can choose an item to replace the content
 of the edit box with. The drop down can be dismissed at any time by pressing the back key or
 if no item is selected in the drop down by pressing the enter/dpad center
 key. The list of suggestions is obtained from a data adapter and appears
 only after a given number of characters defined by
  the threshold . The following code snippet shows how to create a text view which suggests
 various countries names while the user is typing: 
 public class CountriesActivity extends Activity {
     protected void onCreate(Bundle icicle) {
         super.onCreate(icicle);
         setContentView(R.layout.countries);

         ArrayAdapter<String> adapter = new ArrayAdapter<String>(this
                 android.R.layout.simple_dropdown_item_1line COUNTRIES);
         AutoCompleteTextView textView = (AutoCompleteTextView)
                 findViewById(R.id.countries_list);
         textView.setAdapter(adapter);
     }

     private static final String[] COUNTRIES = new String[] {
         ""Belgium"" ""France"" ""Italy"" ""Germany"" ""Spain""
     };
 }
  See the  Text Fields 
 guide."
android,widget,BaseAdapter,13,"Common base class of common implementation for an  Adapter  that can be
 used in both  ListView  (by implementing the specialized
  ListAdapter  interface) and  Spinner  (by implementing the
 specialized  SpinnerAdapter  interface)."
android,widget,Button,2,"A user interface element the user can tap or click to perform an action.

  To display a button in an activity add a button to the activity's layout XML file: 
 <Button
     android:id=""@+id/button_id""
     android:layout_height=""wrap_content""
     android:layout_width=""wrap_content""
     android:text=""@string/self_destruct"" /> To specify an action when the button is pressed set a click
 listener on the button object in the corresponding activity code: 
 public class MyActivity extends Activity {
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);

         setContentView(R.layout.content_layout_id);

         final Button button = findViewById(R.id.button_id);
         button.setOnClickListener(new View.OnClickListener() {
             public void onClick(View v) {
                 // Code here executes on main thread after user presses button
             }
         });
     }
 } The above snippet creates an instance of  View.OnClickListener  and wires
 the listener to the button using
  setOnClickListener(View.OnClickListener) .
 As a result the system executes the code you write in  onClick(View)  after the
 user presses the button. The system executes the code in  onClick  on the
  main thread .
 This means your onClick code must execute quickly to avoid delaying your app's response
 to further user actions.  See
  Keeping Your App Responsive 
 for more details. Every button is styled using the system's default button background which is often
 different from one version of the platform to another. If you are not satisfied with the
 default button style you can customize it. For more details and code samples see the
  Styling Your Button 
 guide. For all XML style attributes available on Button see
  Button Attributes 
  TextView Attributes 
  View Attributes .  See the
  Styles and Themes 
 guide to learn how to implement and organize overrides to style-related attributes."
android,widget,CheckedTextView,23,"An extension to  TextView  that supports the  Checkable 
 interface and displays.
  
 This is useful when used in a  ListView  where
 the  setChoiceMode  has
 been set to something other than
  CHOICE_MODE_NONE ."
android,widget,Chronometer,16,"Class that implements a simple timer.
  
 You can give it a start time in the  SystemClock#elapsedRealtime  timebase
 and it counts up from that or if you don't give it a base time it will use the
 time at which you call  start() .

  The timer can also count downward towards the base time by
 setting  setCountDown(boolean)  to true.

   By default it will display the current
 timer value in the form ""MM:SS"" or ""H:MM:SS"" or you can use  setFormat(String) 
 to format the timer value into an arbitrary string."
android,widget,CursorAdapter,21,"Adapter that exposes data from a  Cursor  to a
  ListView  widget.
  
 The Cursor must include a column named ""_id"" or this class will not work.
 Additionally using  MergeCursor  with this class will
 not work if the merged Cursors have overlapping values in their ""_id""
 columns."
android,widget,CursorTreeAdapter,28,"An adapter that exposes data from a series of  Cursor s to an
  ExpandableListView  widget. The top-level  Cursor  (that is
 given in the constructor) exposes the groups while subsequent  Cursor s
 returned from  getChildrenCursor(android.database.Cursor)  expose children within a
 particular group. The Cursors must include a column named ""_id"" or this class
 will not work."
android,widget,DatePicker,28,"Provides a widget for selecting a date.
  
 When the  R.styleable.DatePicker_datePickerMode  attribute is
 set to  spinner  the date can be selected using year month and day
 spinners or a  CalendarView . The set of spinners and the calendar
 view are automatically synchronized. The client can customize whether only
 the spinners or only the calendar view or both to be displayed.
  
 When the  R.styleable.DatePicker_datePickerMode  attribute is
 set to  calendar  the month and day can be selected using a
 calendar-style view while the year can be selected separately using a list.
  
 See the  Pickers 
 guide.
  
 For a dialog using this view see  DatePickerDialog ."
android,widget,DialerFilter,17,"This widget is a layout that contains several specifically-named child views that
 handle keyboard entry interpreted as standard phone dialpad digits."
android,widget,EditText,11,"A user interface element for entering and modifying text.
 When you define an edit text widget you must specify the
  R.styleable.TextView_inputType 
 attribute. For example for plain text input set inputType to ""text"":
  
 <EditText
     android:id=""@+id/plain_text_input""
     android:layout_height=""wrap_content""
     android:layout_width=""match_parent""
     android:inputType=""text""/> 
 See the  Text Fields 
 guide for examples of other
  R.styleable.TextView_inputType  settings.
  You also can receive callbacks as a user changes text by
 adding a  TextWatcher  to the edit text.
 This is useful when you want to add auto-save functionality as changes are made
 or validate the format of user input for example.
 You add a text watcher using the  TextView#addTextChangedListener  method.
  
 This widget does not support auto-sizing text.
  XML attributes 
 See  EditText Attributes 
  TextView Attributes 
  View Attributes"
android,widget,ExpandableListView,37,"A view that shows items in a vertically scrolling two-level list. This
 differs from the  ListView  by allowing two levels: groups which can
 individually be expanded to show its children. The items come from the
  ExpandableListAdapter  associated with this view.
  
 Expandable lists are able to show an indicator beside each item to display
 the item's current state (the states are usually one of expanded group
 collapsed group child or last child). Use
  setChildIndicator(android.graphics.drawable.Drawable)  or  setGroupIndicator(android.graphics.drawable.Drawable) 
 (or the corresponding XML attributes) to set these indicators (see the docs
 for each method to see additional state that each Drawable can have). The
 default style for an  ExpandableListView  provides indicators which
 will be shown next to Views given to the  ExpandableListView . The
 layouts android.R.layout.simple_expandable_list_item_1 and
 android.R.layout.simple_expandable_list_item_2 (which should be used with
  SimpleCursorTreeAdapter ) contain the preferred position information
 for indicators.
  
 The context menu information set by an  ExpandableListView  will be a
  ExpandableListContextMenuInfo  object with
  ExpandableListContextMenuInfo#packedPosition  being a packed position
 that can be used with  getPackedPositionType(long)  and the other
 similar methods.
  Note:  You cannot use the value  wrap_content 
 for the  android:layout_height  attribute of a
 ExpandableListView in XML if the parent's size is also not strictly specified
 (for example if the parent were ScrollView you could not specify
 wrap_content since it also can be any length. However you can use
 wrap_content if the ExpandableListView parent has a specific size such as
 100 pixels."
android,widget,ExpandableListView.ExpandableListContextMenuInfo,0,"Extra menu information specific to an  ExpandableListView  provided
 to the
  View.OnCreateContextMenuListener.onCreateContextMenu(ContextMenu View ContextMenuInfo) 
 callback when a context menu is brought up for this AdapterView."
android,widget,Filter,5,"A filter constrains data with a filtering pattern. Filters are usually created by  Filterable 
 classes. Filtering operations performed by calling  filter(java.lang.CharSequence)  or
  filter(java.lang.CharSequence android.widget.Filter.FilterListener)  are
 performed asynchronously. When these methods are called a filtering request
 is posted in a request queue and processed later. Any call to one of these
 methods will cancel any previous non-executed filtering request."
android,widget,Filter.FilterResults,0,"Holds the results of a filtering operation. The results are the values
 computed by the filtering operation and the number of these values."
android,widget,FrameLayout.LayoutParams,0,"Per-child layout information for layouts that support margins.
 See  FrameLayout Layout Attributes 
 for a list of all child view attributes that this class supports."
android,widget,Gallery.LayoutParams,0,"Gallery extends LayoutParams to provide a place to hold current
 Transformation information along with previous position/transformation
 info."
android,widget,GridLayout.Alignment,0,"Alignments specify where a view should be placed within a cell group and
 what size it should be.
  
 The  LayoutParams  class contains a  LayoutParams#rowSpec 
 and a  LayoutParams#columnSpec  each of which contains an
  alignment . Overall placement of the view in the cell
 group is specified by the two alignments which act along each axis independently.
  
  The GridLayout class defines the most common alignments used in general layout:
  GridLayout.TOP   GridLayout.LEFT   GridLayout.BOTTOM   GridLayout.RIGHT   GridLayout.START 
  GridLayout.END   GridLayout.CENTER   GridLayout.BASELINE  and  GridLayout.FILL ."
android,widget,HeaderViewListAdapter,18,"ListAdapter used when a ListView has header views. This ListAdapter
 wraps another one and also keeps track of the header views and their
 associated data objects.
 This is intended as a base class; you will probably not need to
 use this class directly in your own code."
android,widget,HorizontalScrollView,48,"Layout container for a view hierarchy that can be scrolled by the user
 allowing it to be larger than the physical display.  A HorizontalScrollView
 is a  FrameLayout  meaning you should place one child in it
 containing the entire contents to scroll; this child may itself be a layout
 manager with a complex hierarchy of objects.  A child that is often used
 is a  LinearLayout  in a horizontal orientation presenting a horizontal
 array of top-level items that the user can scroll through.

  The  TextView  class also
 takes care of its own scrolling so does not require a HorizontalScrollView but
 using the two together is possible to achieve the effect of a text view
 within a larger container.

  HorizontalScrollView only supports horizontal scrolling. For vertical scrolling
 use either  ScrollView  or  ListView ."
android,widget,ImageSwitcher,4,"ViewSwitcher  that switches between two ImageViews when a new
 image is set on it. The views added to an ImageSwitcher must all be
  ImageView ."
android,widget,ImageView,57,"Displays image resources for example  Bitmap 
 or  Drawable  resources.
 ImageView is also commonly used to
  apply tints to an image  and
 handle  image scaling .

  
 The following XML snippet is a common example of using an ImageView to display an image resource:
  
 <LinearLayout
     xmlns:android=""http://schemas.android.com/apk/res/android""
     android:layout_width=""match_parent""
     android:layout_height=""match_parent"">
     <ImageView
         android:layout_width=""wrap_content""
         android:layout_height=""wrap_content""
         android:src=""@drawable/my_image""
         android:contentDescription=""@string/my_image_description""
         />
 </LinearLayout>
  
 To learn more about Drawables see:  Drawable Resources .
 To learn more about working with Bitmaps see:  Handling Bitmaps ."
android,widget,LinearLayout.LayoutParams,1,Per-child layout information associated with ViewLinearLayout.
android,widget,ListView,49,"Displays a vertically-scrollable collection of views where each view is positioned
 immediatelybelow the previous view in the list.  For a more modern flexible and performant
 approach to displaying lists use  RecyclerView . To display a list you can include a list view in your layout XML file: <ListView
      android:id=""@+id/list_view""
      android:layout_width=""match_parent""
      android:layout_height=""match_parent"" /> A list view is an  
 adapter view  that does not know the details such as type and contents of the views it
 contains. Instead list view requests views on demand from a  ListAdapter  as needed
 such as to display new views as the user scrolls up or down. In order to display items in the list call  setAdapter(android.widget.ListAdapter) 
 to associate an adapter with the list.  For a simple example see the discussion of filling an
 adapter view with text in the
  
 Layouts  guide. To display a more custom view for each item in your dataset implement a ListAdapter.
 For example extend  BaseAdapter  and create and configure the view for each data item in
  getView(...) : private class MyAdapter extends BaseAdapter {

      // override other abstract methods here

      @Override
      public View getView(int position View convertView ViewGroup container) {
          if (convertView == null) {
              convertView = getLayoutInflater().inflate(R.layout.list_item container false);
          }

          ((TextView) convertView.findViewById(android.R.id.text1))
                  .setText(getItem(position));
          return convertView;
      }
  } ListView attempts to reuse view objects in order to improve performance and
 avoid a lag in response to user scrolls.  To take advantage of this feature check if the
  convertView  provided to  getView(...)  is null before creating or inflating a new
 view object.  See
  
 Making ListView Scrolling Smooth  for more ways to ensure a smooth user experience. To specify an action when a user clicks or taps on a single list item see
  
     Handling click events . To learn how to populate a list view with a CursorAdapter see the discussion of filling an
 adapter view with text in the
  
 Layouts  guide.
 See  
     Using a Loader 
 to learn how to avoid blocking the main thread when using a cursor. Note many examples use  ListActivity 
 or  ListFragment 
 to display a list view. Instead favor the more flexible approach when writing your own app:
 use a more generic Activity subclass or Fragment subclass and add a list view to the layout
 or view hierarchy directly.  This approach gives you more direct control of the
 list view and adapter."
android,widget,ListView.FixedViewInfo,0,"A class that represents a fixed view in a list for example a header at the top
 or a footer at the bottom."
android,widget,Magnifier.Builder,9,Builder class for  Magnifier  objects.
android,widget,MediaController,13,"A view containing controls for a MediaPlayer. Typically contains the
 buttons like ""Play/Pause"" ""Rewind"" ""Fast Forward"" and a progress
 slider. It takes care of synchronizing the controls with the state
 of the MediaPlayer.
  
 The way to use this class is to instantiate it programmatically.
 The MediaController will create a default set of controls
 and put them in a window floating above your application. Specifically
 the controls will float above the view specified with setAnchorView().
 The window will disappear if left idle for three seconds and reappear
 when the user touches the anchor view.
  
 Functions like show() and hide() have no effect when MediaController
 is created in an xml layout.

 MediaController will hide and
 show the buttons according to these rules:
   The ""previous"" and ""next"" buttons are hidden until setPrevNextListeners()
   has been called
   The ""previous"" and ""next"" buttons are visible but disabled if
   setPrevNextListeners() was called with null listeners
   The ""rewind"" and ""fastforward"" buttons are shown unless requested
   otherwise by using the MediaController(Context boolean) constructor
   with the boolean set to false"
android,widget,MultiAutoCompleteTextView,7,"An editable text view extending  AutoCompleteTextView  that
 can show completion suggestions for the substring of the text where
 the user is typing instead of necessarily for the entire thing.
  
 You must provide a  Tokenizer  to distinguish the
 various substrings.

  The following code snippet shows how to create a text view which suggests
 various countries names while the user is typing: 
 public class CountriesActivity extends Activity {
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.autocomplete_7);

         ArrayAdapter<String> adapter = new ArrayAdapter<String>(this
                 android.R.layout.simple_dropdown_item_1line COUNTRIES);
         MultiAutoCompleteTextView textView = findViewById(R.id.edit);
         textView.setAdapter(adapter);
         textView.setTokenizer(new MultiAutoCompleteTextView.CommaTokenizer());
     }

     private static final String[] COUNTRIES = new String[] {
         ""Belgium"" ""France"" ""Italy"" ""Germany"" ""Spain""
     };
 }"
android,widget,MultiAutoCompleteTextView.CommaTokenizer,3,"This simple Tokenizer can be used for lists where the items are
 separated by a comma and one or more spaces."
android,widget,OverScroller,20,"This class encapsulates scrolling with the ability to overshoot the bounds
 of a scrolling operation. This class is a drop-in replacement for
  Scroller  in most cases."
android,widget,PopupWindow,64,"This class represents a popup window that can be used to display an
 arbitrary view. The popup window is a floating container that appears on top
 of the current activity.
  Animation 
 On all versions of Android popup window enter and exit animations may be
 specified by calling  setAnimationStyle(int)  and passing the
 resource ID for an animation style that defines  windowEnterAnimation 
 and  windowExitAnimation . For example passing
  R.style.Animation_Dialog  will give a scale and alpha
 animation.
 
 A window animation style may also be specified in the popup window's style
 XML via the  popupAnimationStyle 
 attribute.
  
 Starting with API 23 more complex popup window enter and exit transitions
 may be specified by calling either  setEnterTransition(android.transition.Transition) 
 or  setExitTransition(android.transition.Transition)  and passing a   Transition .
 
 Popup enter and exit transitions may also be specified in the popup window's
 style XML via the  popupEnterTransition 
 and  popupExitTransition 
 attributes respectively."
android,widget,ProgressBar,71,"A user interface element that indicates the progress of an operation.
 Progress bar supports two modes to represent progress: determinate and indeterminate. For
 a visual overview of the difference between determinate and indeterminate progress modes see
  
 Progress & activity .
 Display progress bars to a user in a non-interruptive way.
 Show the progress bar in your app's user interface or in a notification
 instead of within a dialog.
  Indeterminate Progress 
 Use indeterminate mode for the progress bar when you do not know how long an
 operation will take.
 Indeterminate mode is the default for progress bar and shows a cyclic animation without a
 specific amount of progress indicated.
 The following example shows an indeterminate progress bar:
  
 <ProgressBar
      android:id=""@+id/indeterminateBar""
      android:layout_width=""wrap_content""
      android:layout_height=""wrap_content""
      />
  Determinate Progress 
 Use determinate mode for the progress bar when you want to show that a specific quantity of
 progress has occurred.
 For example the percent remaining of a file being retrieved the amount records in
 a batch written to database or the percent remaining of an audio file that is playing.
  
 To indicate determinate progress you set the style of the progress bar to
  R.style.Widget_ProgressBar_Horizontal  and set the amount of progress.
 The following example shows a determinate progress bar that is 25% complete:
  
 <ProgressBar
      android:id=""@+id/determinateBar""
      style=""@android:style/Widget.ProgressBar.Horizontal""
      android:layout_width=""wrap_content""
      android:layout_height=""wrap_content""
      android:progress=""25""/>
  setProgress(int) incrementProgressBy(int) android:max Other progress bar styles provided by the system include: Widget.ProgressBar.Horizontal Widget.ProgressBar.Small Widget.ProgressBar.Large Widget.ProgressBar.Inverse Widget.ProgressBar.Small.Inverse Widget.ProgressBar.Large.Inverse The ""inverse"" styles provide an inverse color scheme for the spinner which may be necessary
 if your application uses a light colored theme (a white background). XML attributes 
 See  ProgressBar Attributes 
  View Attributes"
android,widget,QuickContactBadge,16,"Widget used to show an image with the standard QuickContact badge
 and on-click behavior."
android,widget,RadioGroup,14,"This class is used to create a multiple-exclusion scope for a set of radio
 buttons. Checking one radio button that belongs to a radio group unchecks
 any previously checked radio button within the same group. Intially all of the radio buttons are unchecked. While it is not possible
 to uncheck a particular radio button the radio group can be cleared to
 remove the checked state. The selection is identified by the unique id of the radio button as defined
 in the XML layout file. XML Attributes See  RadioGroup Attributes 
  LinearLayout Attributes 
  ViewGroup Attributes 
  View Attributes Also see
  LinearLayout.LayoutParams 
 for layout attributes."
android,widget,RadioGroup.LayoutParams,0,"This set of layout parameters defaults the width and the height of
 the children to  ViewGroup.LayoutParams.WRAP_CONTENT  when they are not specified in the
 XML file. Otherwise this class ussed the value read from the XML file. See
  LinearLayout Attributes 
 for a list of all child view attributes that this class supports."
android,widget,RatingBar,13,"A RatingBar is an extension of SeekBar and ProgressBar that shows a rating in
 stars. The user can touch/drag or use arrow keys to set the rating when using
 the default size RatingBar. The smaller RatingBar style (
  R.attr.ratingBarStyleSmall ) and the larger indicator-only
 style ( R.attr.ratingBarStyleIndicator ) do not support user
 interaction and should only be used as indicators.
  
 When using a RatingBar that supports user interaction placing widgets to the
 left or right of the RatingBar is discouraged.
  
 The number of stars set (via  setNumStars(int)  or in an XML layout)
 will be shown when the layout width is set to wrap content (if another layout
 width is set the results may be unpredictable).
  
 The secondary progress should not be modified by the client as it is used
 internally as the background for a fractionally filled star."
android,widget,RelativeLayout,16,"A Layout where the positions of the children can be described in relation to each other or to the
 parent.

  
 Note that you cannot have a circular dependency between the size of the RelativeLayout and the
 position of its children. For example you cannot have a RelativeLayout whose height is set to
  WRAP_CONTENT  and a child set to
  ALIGN_PARENT_BOTTOM .
  Note:  In platform version 17 and lower RelativeLayout was affected by
 a measurement bug that could cause child views to be measured with incorrect
  MeasureSpec  values. (See
  MeasureSpec.makeMeasureSpec 
 for more details.) This was triggered when a RelativeLayout container was placed in
 a scrolling container such as a ScrollView or HorizontalScrollView. If a custom view
 not equipped to properly measure with the MeasureSpec mode
  UNSPECIFIED  was placed in a RelativeLayout
 this would silently work anyway as RelativeLayout would pass a very large
  AT_MOST  MeasureSpec instead. This behavior has been preserved for apps that set  android:targetSdkVersion=""17"" 
 or older in their manifest's  uses-sdk  tag for compatibility. Apps targeting SDK
 version 18 or newer will receive the correct behavior. See the  Relative
 Layout  guide. 
 Also see  RelativeLayout.LayoutParams  for
 layout attributes"
android,widget,RelativeLayout.LayoutParams,7,"Specifies how a view is positioned within a  RelativeLayout .
 The relative layout containing the view uses the value of these layout parameters to
 determine where to position the view on the screen.  If the view is not contained
 within a relative layout these attributes are ignored.

 See the  Relative
 Layout  guide for example code demonstrating how to use relative layout's
 layout parameters in a layout XML.

 To learn more about layout parameters and how they differ from typical view attributes
 see the  Layouts
 guide ."
android,widget,RemoteViews.RemoteResponse,3,Class representing a response to an action performed on any element of a RemoteViews.
android,widget,RemoteViewsService,2,"The service to be connected to for a remote adapter to request RemoteViews.  Users should
 extend the RemoteViewsService to provide the appropriate RemoteViewsFactory's used to
 populate the remote collection view (ListView GridView etc)."
android,widget,ResourceCursorTreeAdapter,2,"A fairly simple ExpandableListAdapter that creates views defined in an XML
 file. You can specify the XML file that defines the appearance of the views."
android,widget,Scroller,20,"This class encapsulates scrolling. You can use scrollers ( Scroller 
 or  OverScroller ) to collect the data you need to produce a scrolling
 animationâ€”for example in response to a fling gesture. Scrollers track
 scroll offsets for you over time but they don't automatically apply those
 positions to your view. It's your responsibility to get and apply new
 coordinates at a rate that will make the scrolling animation look smooth. Here is a simple example:  private Scroller mScroller = new Scroller(context);
 ...
 public void zoomIn() {
     // Revert any animation currently in progress
     mScroller.forceFinished(true);
     // Start scrolling by providing a starting point and
     // the distance to travel
     mScroller.startScroll(0 0 100 0);
     // Invalidate to request a redraw
     invalidate();
 } To track the changing positions of the x/y coordinates use
  computeScrollOffset() . The method returns a boolean to indicate
 whether the scroller is finished. If it isn't it means that a fling or
 programmatic pan operation is still in progress. You can use this method to
 find the current offsets of the x and y coordinates for example: if (mScroller.computeScrollOffset()) {
     // Get current x and y positions
     int currX = mScroller.getCurrX();
     int currY = mScroller.getCurrY();
    ...
 }"
android,widget,ScrollView,55,"A view group that allows the view hierarchy placed within it to be scrolled.
 Scroll view may have only one direct child placed within it.
 To add multiple views within the scroll view make
 the direct child you add a view group for example  LinearLayout  and
 place additional views within that LinearLayout.

  Scroll view supports vertical scrolling only. For horizontal scrolling
 use  HorizontalScrollView  instead. Never add a  RecyclerView  or  ListView  to
 a scroll view. Doing so results in poor user interface performance and a poor user
 experience. 
 For vertical scrolling consider  NestedScrollView 
 instead of scroll view which offers greater user interface flexibility and
 support for the material design scrolling patterns. Material Design offers guidelines on how the appearance of
  several UI components  including app bars and
 banners should respond to gestures."
android,widget,ShareActionProvider,6,"This is a provider for a share action. It is responsible for creating views
 that enable data sharing and also to show a sub menu with sharing activities
 if the hosting item is placed on the overflow menu.
  
 Here is how to use the action provider with custom backing file in a  MenuItem :
  
 // In Activity#onCreateOptionsMenu
 public boolean onCreateOptionsMenu(Menu menu) {
     // Get the menu item.
     MenuItem menuItem = menu.findItem(R.id.my_menu_item);
     // Get the provider and hold onto it to set/change the share intent.
     mShareActionProvider = (ShareActionProvider) menuItem.getActionProvider();
     // Set history different from the default before getting the action
     // view since a call to  MenuItem#getActionView()  calls
     //  ActionProvider#onCreateActionView()  which uses the backing file name. Omit this
     // line if using the default share history file is desired.
     mShareActionProvider.setShareHistoryFileName(""custom_share_history.xml"");
     . . .
 }

 // Somewhere in the application.
 public void doShare(Intent shareIntent) {
     // When you want to share set the share intent.
     mShareActionProvider.setShareIntent(shareIntent);
 } Note:  While the sample snippet demonstrates how to use this provider
 in the context of a menu item the use of the provider is not limited to menu items."
android,widget,SimpleAdapter,14,"An easy adapter to map static data to views defined in an XML file. You can specify the data
 backing the list as an ArrayList of Maps. Each entry in the ArrayList corresponds to one row
 in the list. The Maps contain the data for each row. You also specify an XML file that
 defines the views used to display the row and a mapping from keys in the Map to specific
 views.

 Binding data to views occurs in two phases. First if a
  SimpleAdapter.ViewBinder  is available
  ViewBinder#setViewValue(android.view.View Object String) 
 is invoked. If the returned value is true binding has occurred.
 If the returned value is false the following views are then tried in order:
   A view that implements Checkable (e.g. CheckBox).  The expected bind value is a boolean.
   TextView.  The expected bind value is a string and  setViewText(android.widget.TextView java.lang.String) 
 is invoked.
   ImageView. The expected bind value is a resource id or a string and
  setViewImage(android.widget.ImageView int)  or  setViewImage(android.widget.ImageView java.lang.String)  is invoked.
  IllegalStateException"
android,widget,SimpleCursorTreeAdapter,6,"An easy adapter to map columns from a cursor to TextViews or ImageViews
 defined in an XML file. You can specify which columns you want which views
 you want to display the columns and the XML file that defines the appearance
 of these views. Separate XML files for child and groups are possible.

 Binding occurs in two phases. First if a
  SimpleCursorTreeAdapter.ViewBinder  is available
  ViewBinder#setViewValue(android.view.View android.database.Cursor int) 
 is invoked. If the returned value is true binding has occurred. If the
 returned value is false and the view to bind is a TextView
  setViewText(android.widget.TextView java.lang.String)  is invoked. If the returned value
 is false and the view to bind is an ImageView
  setViewImage(android.widget.ImageView java.lang.String)  is invoked. If no appropriate
 binding can be found an  IllegalStateException  is thrown."
android,widget,SimpleExpandableListAdapter,12,"An easy adapter to map static data to group and child views defined in an XML
 file. You can separately specify the data backing the group as a List of
 Maps. Each entry in the ArrayList corresponds to one group in the expandable
 list. The Maps contain the data for each row. You also specify an XML file
 that defines the views used to display a group and a mapping from keys in
 the Map to specific views. This process is similar for a child except it is
 one-level deeper so the data backing is specified as a List >
 where the first List corresponds to the group of the child the second List
 corresponds to the position of the child within the group and finally the
 Map holds the data for that particular child."
android,widget,Space,2,"Space is a lightweight View subclass that may be used to create gaps between components
 in general purpose layouts."
android,widget,Switch,50,"A Switch is a two-state toggle switch widget that can select between two
 options. The user may drag the ""thumb"" back and forth to choose the selected option
 or simply tap to toggle as if it were a checkbox. The  text 
 property controls the text displayed in the label for the switch whereas the
  off  and  on  text
 controls the text on the thumb. Similarly the
  textAppearance  and the related
 setTypeface() methods control the typeface and style of label text whereas the
  switchTextAppearance  and
 the related setSwitchTypeface() methods control that of the thumb.

  SwitchCompat  is a version of
 the Switch widget which runs on devices back to API 7. See the  Toggle Buttons 
 guide."
android,widget,TabHost,18,"Container for a tabbed window view. This object holds two children: a set of tab labels that the
 user clicks to select a specific tab and a FrameLayout object that displays the contents of that
 page. The individual elements are typically controlled using this container object rather than
 setting values on the child elements themselves."
android,widget,TableLayout,23,"A layout that arranges its children into rows and columns.
 A TableLayout consists of a number of  TableRow  objects
 each defining a row (actually you can have other children which will be
 explained below). TableLayout containers do not display border lines for
 their rows columns or cells. Each row has zero or more cells; each cell can
 hold one  View  object. The table has as many columns
 as the row with the most cells. A table can leave cells empty. Cells can span
 columns as they can in HTML. The width of a column is defined by the row with the widest cell in that
 column. However a TableLayout can specify certain columns as shrinkable or
 stretchable by calling
  setColumnShrinkable() 
 or  setColumnStretchable() . If
 marked as shrinkable the column width can be shrunk to fit the table into
 its parent object. If marked as stretchable it can expand in width to fit
 any extra space. The total width of the table is defined by its parent
 container. It is important to remember that a column can be both shrinkable
 and stretchable. In such a situation the column will change its size to
 always use up the available space but never more. Finally you can hide a
 column by calling
  setColumnCollapsed() . The children of a TableLayout cannot specify the  layout_width 
 attribute. Width is always  MATCH_PARENT . However the
  layout_height  attribute can be defined by a child; default value
 is  ViewGroup.LayoutParams.WRAP_CONTENT . If the child
 is a  TableRow  then the height is always
  ViewGroup.LayoutParams.WRAP_CONTENT .  Cells must be added to a row in increasing column order both in code and
 XML. Column numbers are zero-based. If you don't specify a column number for
 a child cell it will autoincrement to the next available column. If you skip
 a column number it will be considered an empty cell in that row. See the
 TableLayout examples in ApiDemos for examples of creating tables in XML. Although the typical child of a TableLayout is a TableRow you can
 actually use any View subclass as a direct child of TableLayout. The View
 will be displayed as a single row that spans all the table columns."
android,widget,TableRow,10,"A layout that arranges its children horizontally. A TableRow should
 always be used as a child of a  TableLayout . If a
 TableRow's parent is not a TableLayout the TableRow will behave as
 an horizontal  LinearLayout . The children of a TableRow do not need to specify the
  layout_width  and  layout_height  attributes in the
 XML file. TableRow always enforces those values to be respectively
  ViewGroup.LayoutParams.MATCH_PARENT  and
  ViewGroup.LayoutParams.WRAP_CONTENT . 
 Also see  TableRow.LayoutParams 
 for layout attributes"
android,widget,TableRow.LayoutParams,0,Set of layout parameters used in table rows.
android,widget,TabWidget,24,"Displays a list of tab labels representing each page in the parent's tab
 collection.
  
 The container object for this widget is  TabHost .
 When the user selects a tab this object sends a message to the parent
 container TabHost to tell it to switch the displayed page. You typically
 won't use many methods directly on this object. The container TabHost is
 used to add labels add the callback handler and manage callbacks. You
 might call this object to iterate the list of tabs or to tweak the layout
 of the tab list but most methods should be called on the containing TabHost
 object."
android,widget,TextSwitcher,4,"Specialized  ViewSwitcher  that contains
 only children of type  TextView .

 A TextSwitcher is useful to animate a label on screen. Whenever
  setText(java.lang.CharSequence)  is called TextSwitcher animates the current text
 out and animates the new text in."
android,widget,TextView.SavedState,2,"User interface state that is stored by TextView for implementing
  View#onSaveInstanceState ."
android,widget,Toolbar,77,"A standard toolbar for use within application content.

  A Toolbar is a generalization of  action bars  for use
 within application layouts. While an action bar is traditionally part of an
  Activity's  opaque window decor controlled by the framework
 a Toolbar may be placed at any arbitrary level of nesting within a view hierarchy.
 An application may choose to designate a Toolbar as the action bar for an Activity
 using the  setActionBar()  method. Toolbar supports a more focused feature set than ActionBar. From start to end a toolbar
 may contain a combination of the following optional elements:

  A navigation button.  This may be an Up arrow navigation menu toggle close
     collapse done or another glyph of the app's choosing. This button should always be used
     to access other navigational destinations within the container of the Toolbar and
     its signified content or otherwise leave the current context signified by the Toolbar.
     The navigation button is vertically aligned within the Toolbar's
      minimum height  if set. A branded logo image.  This may extend to the height of the bar and can be
     arbitrarily wide. A title and subtitle.  The title should be a signpost for the Toolbar's current
     position in the navigation hierarchy and the content contained there. The subtitle
     if present should indicate any extended information about the current content.
     If an app uses a logo image it should strongly consider omitting a title and subtitle. One or more custom views.  The application may add arbitrary child views
     to the Toolbar. They will appear at this position within the layout. If a child view's
      LayoutParams  indicates a  Gravity  value of
      Gravity#CENTER_HORIZONTAL  the view will attempt to center
     within the available space remaining in the Toolbar after all other elements have been
     measured. An  ActionMenuView .  The menu of actions will pin to the
     end of the Toolbar offering a few
      
     frequent important or typical  actions along with an optional overflow menu for
     additional actions. Action buttons are vertically aligned within the Toolbar's
      minimum height  if set. In modern Android UIs developers should lean more on a visually distinct color scheme for
 toolbars than on their application icon. The use of application icon plus title as a standard
 layout is discouraged on API 21 devices and newer."
android,widget,Toolbar.LayoutParams,0,"Layout information for child views of Toolbars.

  Toolbar.LayoutParams extends ActionBar.LayoutParams for compatibility with existing
 ActionBar API. See  Activity.setActionBar 
 for more info on how to use a Toolbar as your Activity's ActionBar."
android,widget,ViewAnimator,22,"Base class for a  FrameLayout  container that will perform animations
 when switching between its views."
android,widget,ViewFlipper,11,"Simple  ViewAnimator  that will animate between two or more views
 that have been added to it.  Only one child is shown at a time.  If
 requested can automatically flip between each child at a regular interval."
android,widget,ZoomButton,7,"This widget provides a simple utility for turning a continued long-press event
 into a series of clicks at some set frequency. There is no actual 'zoom' functionality
 handled by this widget directly. Instead clients of this API should set up an
  View#setOnClickListener(OnClickListener)  to handle
 zoom functionality. That click listener is called on a frequency
 determined by  setZoomSpeed(long)  whenever the user long-presses
 on the ZoomButton."
android,widget,ZoomButtonsController,11,"The  ZoomButtonsController  handles showing and hiding the zoom
 controls and positioning it relative to an owner view. It also gives the
 client access to the zoom controls container allowing for additional
 accessory buttons to be shown in the zoom controls window.
  
 Typically clients should call  setVisible(true) 
 on a touch down or move (no need to call  setVisible(false)  since it will time out on its own). Also whenever the
 owner cannot be zoomed further the client should update
  setZoomInEnabled(boolean)  and  setZoomOutEnabled(boolean) .
  
 If you are using this with a custom View please call
  setVisible(false)  from
  View#onDetachedFromWindow  and from  View#onVisibilityChanged 
 when  visibility != View.VISIBLE ."
android,widget,AbsListView.LayoutParams,0,AbsListView extends LayoutParams to provide a place to hold the view type.
android,widget,AbsSpinner,17,"An abstract base class for spinner widgets. SDK users will probably not
 need to use this class."
android,widget,AdapterView,39,"An AdapterView is a view whose children are determined by an  Adapter .

  
 See  ListView   GridView   Spinner  and
       Gallery  for commonly used subclasses of AdapterView."
android,widget,AlphabetIndexer,7,"A helper class for adapters that implement the SectionIndexer interface.
 If the items in the adapter are sorted by simple alphabet-based sorting then
 this class provides a way to do fast indexing of large lists using binary search.
 It caches the indices that have been determined through the binary search and also
 invalidates the cache if changes occur in the cursor.
  setCursor(Cursor) getPositionForSection(int)"
android,widget,AnalogClock,0,"This widget display an analogic clock with two hands for hours and
 minutes."
android,widget,ArrayAdapter,22,"You can use this adapter to provide views for an  AdapterView 
 Returns a view for each object in a collection of data objects you
 provide and can be used with list-based user interface widgets such as
  ListView  or  Spinner .
  
 By default the array adapter creates a view by calling  Object#toString()  on each
 data object in the collection you provide and places the result in a TextView.
 You may also customize what type of view is used for the data object in the collection.
 To customize what type of view is used for the data object
 override  getView(int android.view.View android.view.ViewGroup) 
 and inflate a view resource.
 For a code example see
 the  
 CustomChoiceList  sample.
  
 For an example of using an array adapter with a ListView see the
  
 Adapter Views  guide.
  
 For an example of using an array adapter with a Spinner see the
  Spinners  guide.
  Note: 
 If you are considering using array adapter with a ListView consider using
  RecyclerView  instead.
 RecyclerView offers similar features with better performance and more flexibility than
 ListView provides.
 See the
  
 Recycler View  guide."
android,widget,CalendarView,33,"This class is a calendar widget for displaying and selecting dates. The
 range of dates supported by this calendar is configurable.
  
 The exact appearance and interaction model of this widget may vary between
 OS versions and themes (e.g. Holo versus Material) but in general a user
 can select a date by tapping on it and can scroll or fling the calendar to a
 desired date."
android,widget,CheckBox,1,"A checkbox is a specific type of two-states button that can be either
 checked or unchecked. A example usage of a checkbox inside your activity
 would be the following:
  
 public class MyActivity extends Activity {
     protected void onCreate(Bundle icicle) {
         super.onCreate(icicle);

         setContentView(R.layout.content_layout_id);

         final CheckBox checkBox = (CheckBox) findViewById(R.id.checkbox_id);
         if (checkBox.isChecked()) {
             checkBox.setChecked(false);
         }
     }
 }
  See the  Checkboxes 
 guide. XML attributes 
 See  CompoundButton Attributes 
  Button Attributes 
  TextView Attributes 
  View Attributes"
android,widget,DigitalClock,3,Like AnalogClock but digital.
android,widget,EdgeEffect,13,"This class performs the graphical effect used at the edges of scrollable widgets
 when the user scrolls beyond the content bounds in 2D space.

  EdgeEffect is stateful. Custom widgets using EdgeEffect should create an
 instance for each edge that should show the effect feed it input data using
 the methods  onAbsorb(int)   onPull(float)  and  onRelease() 
 and draw the effect using  draw(android.graphics.Canvas)  in the widget's overridden
  View.draw(Canvas)  method. If  isFinished()  returns
 false after drawing the edge effect's animation is not yet complete and the widget
 should schedule another drawing pass to continue the animation. When drawing widgets should draw their main content and child views first
 usually by invoking  super.draw(canvas)  from an overridden  draw 
 method. (This will invoke onDraw and dispatch drawing to child views as needed.)
 The edge effect may then be drawn on top of the view's content using the
  draw(android.graphics.Canvas)  method."
android,widget,FrameLayout,12,"FrameLayout is designed to block out an area on the screen to display
 a single item. Generally FrameLayout should be used to hold a single child view because it can
 be difficult to organize child views in a way that's scalable to different screen sizes without
 the children overlapping each other. You can however add multiple children to a FrameLayout
 and control their position within the FrameLayout by assigning gravity to each child using the
  android:layout_gravity  attribute.
  Child views are drawn in a stack with the most recently added child on top.
 The size of the FrameLayout is the size of its largest child (plus padding) visible
 or not (if the FrameLayout's parent permits). Views that are  View.GONE  are
 used for sizing
 only if  setConsiderGoneChildrenWhenMeasuring() 
 is set to true."
android,widget,GridLayout,32,"A layout that places its children in a rectangular  grid .
  
 The grid is composed of a set of infinitely thin lines that separate the
 viewing area into  cells . Throughout the API grid lines are referenced
 by grid  indices . A grid with  N  columns
 has  N + 1  grid indices that run from  0 
 through  N  inclusive. Regardless of how GridLayout is
 configured grid index  0  is fixed to the leading edge of the
 container and grid index  N  is fixed to its trailing edge
 (after padding is taken into account).

  Row and Column Specs GridLayout.LayoutParams#rowSpec GridLayout.LayoutParams#columnSpec Default Cell Assignment GridLayout#setOrientation(int) GridLayout#setRowCount(int) GridLayout#setColumnCount(int) Space Space ViewGroup.MarginLayoutParams#leftMargin ViewGroup.MarginLayoutParams#topMargin ViewGroup.MarginLayoutParams#rightMargin ViewGroup.MarginLayoutParams#bottomMargin GridLayout#setUseDefaultMargins(boolean) Excess Space Distribution 
 The flexibility of a view is therefore influenced by its alignment which is
 in turn typically defined by setting the
  LayoutParams#setGravity(int)  property of the child's layout parameters.
 If either a weight or alignment were defined along a given axis then the component
 is taken as  flexible  in that direction. If no weight or alignment was set
 the component is instead assumed to be  inflexible .
  
 Multiple components in the same row or column group are
 considered to act in  parallel . Such a
 group is flexible only if  all  of the components
 within it are flexible. Row and column groups that sit either side of a common boundary
 are instead considered to act in  series . The composite group made of these two
 elements is flexible if  one  of its elements is flexible.
  
 To make a column stretch make sure all of the components inside it define a
 weight or a gravity. To prevent a column from stretching ensure that one of the components
 in the column does not define a weight or a gravity.
  
 When the principle of flexibility does not provide complete disambiguation
 GridLayout's algorithms favour rows and columns that are closer to its  right 
 and  bottom  edges. To be more precise GridLayout treats each of its layout
 parameters as a constraint in the a set of variables that define the grid-lines along a
 given axis. During layout GridLayout solves the constraints so as to return the unique
 solution to those constraints for which all variables are less-than-or-equal-to
 the corresponding value in any other valid solution.

  Interpretation of GONE View#GONE 
 These statements apply equally to rows as well as columns and to groups of rows or columns.

  
 See  GridLayout.LayoutParams  for a full description of the
 layout parameters used by GridLayout."
android,widget,GridLayout.Spec,2,"A Spec defines the horizontal or vertical characteristics of a group of
 cells. Each spec. defines the  grid indices  and  alignment 
 along the appropriate axis.
  
 The  grid indices  are the leading and trailing edges of this cell group.
 See  GridLayout  for a description of the conventions used by GridLayout
 for grid indices.
  
 The  alignment  property specifies how cells should be aligned in this group.
 For row groups this specifies the vertical alignment.
 For column groups this specifies the horizontal alignment.
  
 Use the following static methods to create specs:
  GridLayout.spec(int) GridLayout.spec(int int) GridLayout.spec(int android.widget.GridLayout.Alignment) GridLayout.spec(int int android.widget.GridLayout.Alignment) GridLayout.spec(int float) GridLayout.spec(int int float) GridLayout.spec(int android.widget.GridLayout.Alignment float) GridLayout.spec(int int android.widget.GridLayout.Alignment float)"
android,widget,GridView,32,"A view that shows items in two-dimensional scrolling grid. The items in the
 grid come from the  ListAdapter  associated with this view.

  See the  Grid
 View  guide."
android,widget,ImageButton,3,"Displays a button with an image (instead of text) that can be pressed
 or clicked by the user. By default an ImageButton looks like a regular
  Button  with the standard button background
 that changes color during different button states. The image on the surface
 of the button is defined either by the  android:src  attribute in the
  <ImageButton>  XML element or by the
  ImageView.setImageResource(int)  method. To remove the standard button background image define your own
 background image or set the background color to be transparent. To indicate the different button states (focused selected etc.) you can
 define a different image for each state. E.g. a blue image by default an
 orange one for when focused and a yellow one for when pressed. An easy way to
 do this is with an XML drawable ""selector."" For example: 
 <?xml version=""1.0"" encoding=""utf-8""?>
 <selector xmlns:android=""http://schemas.android.com/apk/res/android"">
     <item android:state_pressed=""true""
           android:drawable=""@drawable/button_pressed"" /> <!-- pressed -->
     <item android:state_focused=""true""
           android:drawable=""@drawable/button_focused"" /> <!-- focused -->
     <item android:drawable=""@drawable/button_normal"" /> <!-- default -->
 </selector> Save the XML file in your project  res/drawable/  folder and then
 reference it as a drawable for the source of your ImageButton (in the
  android:src  attribute). Android will automatically change the image
 based on the state of the button and the corresponding images
 defined in the XML. The order of the  <item>  elements is important because they are
 evaluated in order. This is why the ""normal"" button image comes last because
 it will only be applied after  android:state_pressed  and  android:state_focused  have both evaluated false. See the  Buttons 
 guide. XML attributes 
 See  Button Attributes 
  View Attributes"
android,widget,Magnifier,18,Android magnifier widget. Can be used by any view which is attached to a window.
android,widget,NumberPicker,44,"A widget that enables the user to select a number from a predefined range.
 There are two flavors of this widget and which one is presented to the user
 depends on the current theme.
  
 If the current theme is derived from  R.style.Theme  the widget
 presents the current value as an editable input field with an increment button
 above and a decrement button below. Long pressing the buttons allows for a quick
 change of the current value. Tapping on the input field allows to type in
 a desired value.
  
 If the current theme is derived from  R.style.Theme_Holo  or
  R.style.Theme_Holo_Light  the widget presents the current
 value as an editable input field with a lesser value above and a greater
 value below. Tapping on the lesser or greater value selects it by animating
 the number axis up or down to make the chosen value current. Flinging up
 or down allows for multiple increments or decrements of the current value.
 Long pressing on the lesser and greater values also allows for a quick change
 of the current value. Tapping on the current value allows to type in a
 desired value.
  
 If the current theme is derived from  R.style.Theme_Material 
 the widget presents the current value as a scrolling vertical selector with
 the selected value in the center and the previous and following numbers above
 and below separated by a divider. The value is changed by flinging vertically.
 The thickness of the divider can be changed by using the
  R.attr.selectionDividerHeight  attribute and the color of the
 divider can be changed by using the
  R.attr.colorControlNormal  attribute.
  
 For an example of using this widget see  TimePicker ."
android,widget,RadioButton,2,"A radio button is a two-states button that can be either checked or
 unchecked. When the radio button is unchecked the user can press or click it
 to check it. However contrary to a  CheckBox  a radio
 button cannot be unchecked by the user once checked.
  
 Radio buttons are normally used together in a
  RadioGroup . When several radio buttons live inside
 a radio group checking one radio button unchecks all the others. See the  Radio Buttons 
 guide. XML attributes 
 See  CompoundButton Attributes 
  Button Attributes 
  TextView Attributes 
  View Attributes"
android,widget,RemoteViews,56,"A class that describes a view hierarchy that can be displayed in
 another process. The hierarchy is inflated from a layout resource
 file and this class provides some basic operations for modifying
 the content of the inflated hierarchy.

  RemoteViews  is limited to support for the following layouts: AdapterViewFlipper FrameLayout GridLayout GridView LinearLayout ListView RelativeLayout StackView ViewFlipper And the following widgets: AnalogClock Button Chronometer ImageButton ImageView ProgressBar TextClock TextView Descendants of these classes are not supported."
android,widget,ResourceCursorAdapter,5,"An easy adapter that creates views defined in an XML file. You can specify
 the XML file that defines the appearance of the views."
android,widget,SearchView,37,"A widget that provides a user interface for the user to enter a search query and submit a request
 to a search provider. Shows a list of query suggestions or results if available and allows the
 user to pick a suggestion or result to launch into.

  
 When the SearchView is used in an ActionBar as an action view for a collapsible menu item it
 needs to be set to iconified by default using  setIconifiedByDefault(true) . This is the default so nothing needs to be done.
  
 If you want the search field to always be visible then call setIconifiedByDefault(false)."
android,widget,SlidingDrawer,22,"SlidingDrawer hides content out of the screen and allows the user to drag a handle
 to bring the content on screen. SlidingDrawer can be used vertically or horizontally.

 A special widget composed of two children views: the handle that the users drags
 and the content attached to the handle and dragged with it.

 SlidingDrawer should be used as an overlay inside layouts. This means SlidingDrawer
 should only be used inside of a FrameLayout or a RelativeLayout for instance. The
 size of the SlidingDrawer defines how much space the content will occupy once slid
 out so SlidingDrawer should usually use match_parent for both its dimensions.

 Inside an XML layout SlidingDrawer must define the id of the handle and of the
 content:

  
 <SlidingDrawer
     android:id=""@+id/drawer""
     android:layout_width=""match_parent""
     android:layout_height=""match_parent""

     android:handle=""@+id/handle""
     android:content=""@+id/content"">

     <ImageView
         android:id=""@id/handle""
         android:layout_width=""88dip""
         android:layout_height=""44dip"" />

     <GridView
         android:id=""@id/content""
         android:layout_width=""match_parent""
         android:layout_height=""match_parent"" />

 </SlidingDrawer>"
android,widget,Spinner,29,"A view that displays one child at a time and lets the user pick among them.
 The items in the Spinner come from the  Adapter  associated with
 this view.

  See the  Spinners  guide."
android,widget,TextClock,10,"TextClock  can display the current date and/or time as
 a formatted string. This view honors the 24-hour format system setting. As such it is
 possible and recommended to provide two different formatting patterns:
 one to display the date/time in 24-hour mode and one to display the
 date/time in 12-hour mode. Most callers will want to use the defaults
 though which will be appropriate for the user's locale. It is possible to determine whether the system is currently in
 24-hour mode by calling  is24HourModeEnabled() . The rules used by this widget to decide how to format the date and
 time are the following: In 24-hour mode:
          Use the value returned by  getFormat24Hour()  when non-null Otherwise use the value returned by  getFormat12Hour()  when non-null Otherwise use a default value appropriate for the user's locale such as  h:mm a In 12-hour mode:
          Use the value returned by  getFormat12Hour()  when non-null Otherwise use the value returned by  getFormat24Hour()  when non-null Otherwise use a default value appropriate for the user's locale such as  HH:mm The  CharSequence  instances used as formatting patterns when calling either
  setFormat24Hour(java.lang.CharSequence)  or  setFormat12Hour(java.lang.CharSequence)  can
 contain styling information. To do so use a  Spanned  object.
 Note that if you customize these strings it is your responsibility to supply strings
 appropriate for formatting dates and/or times in the user's locale."
android,widget,ToggleButton,10,"Displays checked/unchecked states as a button
 with a ""light"" indicator and by default accompanied with the text ""ON"" or ""OFF"".

  See the  Toggle Buttons 
 guide."
android,widget,TwoLineListItem,4,"A view group with two children intended for use in ListViews. This item has two
  TextViews  elements (or subclasses) with the ID values
  text1 
 and  text2 . There is an optional third View element with the
 ID  selectedIcon  which can be any View subclass
 (though it is typically a graphic View such as  ImageView )
 that can be displayed when a TwoLineListItem has focus. Android supplies a
  standard layout resource for TwoLineListView 
 (which does not include a selected item icon) but you can design your own custom XML
 layout for this object."
android,widget,ViewSwitcher,5,"ViewAnimator  that switches between two views and has a factory
 from which these views are created.  You can either use the factory to
 create the views or add them yourself.  A ViewSwitcher can only have two
 child views of which only one is shown at a time."
android,widget,ZoomControls,10,"The  ZoomControls  class displays a simple set of controls used for zooming and
 provides callbacks to register for events."
android,widget,AbsListView,141,"Base class that can be used to implement virtualized lists of items. A list does
 not have a spatial definition here. For instance subclasses of this class can
 display the content of the list in a grid in a carousel as stack etc."
android,widget,ActionMenuView,18,"ActionMenuView is a presentation of a series of menu options as a View. It provides
 several top level options as action buttons while spilling remaining options over as
 items in an overflow menu. This allows applications to present packs of actions inline with
 specific or repeating content."
android,widget,AdapterViewFlipper,15,"Simple  ViewAnimator  that will animate between two or more views
 that have been added to it.  Only one child is shown at a time.  If
 requested can automatically flip between each child at a regular interval."
android,widget,GridLayout.LayoutParams,4,"Layout information associated with each of the children of a GridLayout.
  
 GridLayout supports both row and column spanning and arbitrary forms of alignment within
 each cell group. The fundamental parameters associated with each cell group are
 gathered into their vertical and horizontal components and stored
 in the  rowSpec  and  columnSpec  layout parameters.
  GridLayout.Spec  are immutable structures
 and may be shared between the layout parameters of different children.
  
 The row and column specs contain the leading and trailing indices along each axis
 and together specify the four grid indices that delimit the cells of this cell group.
  
 The  alignment properties of the row and column specs together specify
 both aspects of alignment within the cell group. It is also possible to specify a child's
 alignment within its cell group by using the  GridLayout.LayoutParams#setGravity(int) 
 method.
  
 The weight property is also included in Spec and specifies the proportion of any
 excess space that is due to the associated view.

  WRAP_CONTENT and MATCH_PARENT ViewGroup.LayoutParams.width ViewGroup.LayoutParams.height ViewGroup.LayoutParams.WRAP_CONTENT ViewGroup.LayoutParams.MATCH_PARENT ViewGroup.LayoutParams.WRAP_CONTENT flexibility GridLayout Summary WRAP_CONTENT MATCH_PARENT Default values ViewGroup.LayoutParams.width  =  ViewGroup.LayoutParams.WRAP_CONTENT ViewGroup.LayoutParams.height  =  ViewGroup.LayoutParams.WRAP_CONTENT ViewGroup.MarginLayoutParams.topMargin  = 0 when
           GridLayout#setUseDefaultMargins(boolean)  is
           false ; otherwise  GridLayout.UNDEFINED  to
          indicate that a default value should be computed on demand.  ViewGroup.MarginLayoutParams.leftMargin  = 0 when
           GridLayout#setUseDefaultMargins(boolean)  is
           false ; otherwise  GridLayout.UNDEFINED  to
          indicate that a default value should be computed on demand.  ViewGroup.MarginLayoutParams.bottomMargin  = 0 when
           GridLayout#setUseDefaultMargins(boolean)  is
           false ; otherwise  GridLayout.UNDEFINED  to
          indicate that a default value should be computed on demand.  ViewGroup.MarginLayoutParams.rightMargin  = 0 when
           GridLayout#setUseDefaultMargins(boolean)  is
           false ; otherwise  GridLayout.UNDEFINED  to
          indicate that a default value should be computed on demand.  rowSpec .row  =  GridLayout.UNDEFINED rowSpec .rowSpan  = 1  rowSpec .alignment  =  GridLayout.BASELINE rowSpec .weight  = 0  columnSpec .column  =  GridLayout.UNDEFINED columnSpec .columnSpan  = 1  columnSpec .alignment  =  GridLayout.START columnSpec .weight  = 0  GridLayout"
android,widget,ListPopupWindow,50,"A ListPopupWindow anchors itself to a host view and displays a
 list of choices.

  ListPopupWindow contains a number of tricky behaviors surrounding
 positioning scrolling parents to fit the dropdown interacting
 sanely with the IME if present and others."
android,widget,Toast,17,"A toast is a view containing a quick little message for the user.  The toast class
 helps you create and show those.
  
 When the view is shown to the user appears as a floating view over the
 application.  It will never receive focus.  The user will probably be in the
 middle of typing something else.  The idea is to be as unobtrusive as
 possible while still showing the user the information you want them to see.
 Two examples are the volume control and the brief message saying that your
 settings have been saved.
  
 The easiest way to use this class is to call one of the static methods that constructs
 everything you need and returns a new Toast object."
android,widget,BaseExpandableListAdapter,14,"Base class for a  ExpandableListAdapter  used to provide data and Views
 from some data to an expandable list view.
  
 Adapters inheriting this class should verify that the base implementations of
  getCombinedChildId(long long)  and  getCombinedGroupId(long) 
 are correct in generating unique IDs from the group/children IDs."
android,widget,CompoundButton,28,"A button with two states checked and unchecked. When the button is pressed
 or clicked the state changes automatically.
  XML attributes 
 See  CompoundButton Attributes   Button
 Attributes   TextView Attributes   View Attributes"
android,widget,Gallery,35,"A view that shows items in a center-locked horizontally scrolling list.
  
 The default values for the Gallery assume you will be using
  R.styleable.Theme_galleryItemBackground  as the background for
 each View given to the Gallery from the Adapter. If you are not doing this
 you may need to adjust some Gallery properties such as the spacing.
  
 Views given to the Gallery should use  Gallery.LayoutParams  as their
 layout parameters type."
android,widget,LinearLayout,31,"A layout that arranges other views either horizontally in a single column
 or vertically in a single row.

  The following snippet shows how to include a linear layout in your layout XML file: <LinearLayout xmlns:android=""http://schemas.android.com/apk/res/android""
   android:layout_width=""match_parent""
   android:layout_height=""match_parent""
   android:paddingLeft=""16dp""
   android:paddingRight=""16dp""
   android:orientation=""horizontal""
   android:gravity=""center"">

   <!-- Include other widget or layout tags here. These are considered
           ""child views"" or ""children"" of the linear layout -->

 </LinearLayout> Set  android:orientation  to specify
 whether child views are displayed in a row or column. To control how linear layout aligns all the views it contains set a value for
  android:gravity .  For example the
 snippet above sets android:gravity to ""center"".  The value you set affects
 both horizontal and vertical alignment of all child views within the single row or column. You can set
  android:layout_weight 
 on individual child views to specify how linear layout divides remaining space amongst
 the views it contains. See the
  Linear Layout 
 guide for an example. See
  LinearLayout.LayoutParams 
 to learn about other attributes you can set on a child view to affect its
 position and size in the containing linear layout."
android,widget,PopupMenu,11,"A PopupMenu displays a  Menu  in a modal popup window anchored to a
  View . The popup will appear below the anchor view if there is room
 or above it if there is not. If the IME is visible the popup will not
 overlap it until it is touched. Touching outside of the popup will dismiss
 it."
android,widget,StackView,10,
android,widget,TableLayout.LayoutParams,0,"This set of layout parameters enforces the width of each child to be
  ViewGroup.LayoutParams.MATCH_PARENT  and the height of each child to be
  ViewGroup.LayoutParams.WRAP_CONTENT  but only if the height is not specified."
android,widget,SeekBar,2,"A SeekBar is an extension of ProgressBar that adds a draggable thumb. The user can touch
 the thumb and drag left or right to set the current progress level or use the arrow keys.
 Placing focusable widgets to the left or right of a SeekBar is discouraged.
  
 Clients of the SeekBar can attach a  SeekBar.OnSeekBarChangeListener  to
 be notified of the user's actions."
android,widget,SimpleCursorAdapter,12,"An easy adapter to map columns from a cursor to TextViews or ImageViews
 defined in an XML file. You can specify which columns you want which
 views you want to display the columns and the XML file that defines
 the appearance of these views.

 Binding occurs in two phases. First if a
  SimpleCursorAdapter.ViewBinder  is available
  ViewBinder#setViewValue(android.view.View android.database.Cursor int) 
 is invoked. If the returned value is true binding has occured. If the
 returned value is false and the view to bind is a TextView
  setViewText(android.widget.TextView java.lang.String)  is invoked. If the returned value
 is false and the view to bind is an ImageView
  setViewImage(android.widget.ImageView java.lang.String)  is invoked. If no appropriate
 binding can be found an  IllegalStateException  is thrown.

 If this adapter is used with filtering for instance in an
  AutoCompleteTextView  you can use the
  SimpleCursorAdapter.CursorToStringConverter  and the
  FilterQueryProvider  interfaces
 to get control over the filtering process. You can refer to
  convertToString(android.database.Cursor)  and
  CursorAdapter.runQueryOnBackgroundThread(java.lang.CharSequence)  for more information."
android,widget,TabHost.TabSpec,7,"A tab has a tab indicator content and a tag that is used to keep
 track of it.  This builder helps choose among these options.

 For the tab indicator your choices are:
 1) set a label
 2) set a label and an icon

 For the tab content your choices are:
 1) the id of a  View 
 2) a  TabContentFactory  that creates the  View  content.
 3) an  Intent  that launches an  Activity ."
android,widget,TextView,306,"A user interface element that displays text to the user.
 To provide user-editable text see  EditText .
  
 The following code sample shows a typical use with an XML layout
 and code to modify the contents of the text view:
  
 <LinearLayout
      xmlns:android=""http://schemas.android.com/apk/res/android""
      android:layout_width=""match_parent""
      android:layout_height=""match_parent"">
    <TextView
        android:id=""@+id/text_view_id""
        android:layout_height=""wrap_content""
        android:layout_width=""wrap_content""
        android:text=""@string/hello"" />
 </LinearLayout>
  
 This code sample demonstrates how to modify the contents of the text view
 defined in the previous XML layout:
  
 public class MainActivity extends Activity {

    protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_main);
         final TextView helloTextView = (TextView) findViewById(R.id.text_view_id);
         helloTextView.setText(R.string.user_greeting);
     }
 }
  
 To customize the appearance of TextView see  Styles and Themes .
  XML attributes 
 See  TextView Attributes 
  View Attributes"
android,widget,TimePicker,22,"A widget for selecting the time of day in either 24-hour or AM/PM mode.
  
 For a dialog using this view see  TimePickerDialog . See
 the  Pickers 
 guide for more information."
android,widget,VideoView,35,"Displays a video file.  The VideoView class
 can load images from various sources (such as resources or content
 providers) takes care of computing its measurement from the video so that
 it can be used in any layout manager and provides various display options
 such as scaling and tinting. Note: VideoView does not retain its full state when going into the
 background.   In particular it does not restore the current play state
 play position selected tracks or any subtitle tracks added via
  addSubtitleSource() .  Applications should
 save and restore these on their own in
  Activity.onSaveInstanceState(Bundle)  and
  Activity.onRestoreInstanceState(Bundle) . 
 Also note that the audio session id (from  getAudioSessionId() ) may
 change from its previously returned value when the VideoView is restored.
  
 By default VideoView requests audio focus with  AudioManager#AUDIOFOCUS_GAIN . Use
  setAudioFocusRequest(int)  to change this behavior.
  
 The default  AudioAttributes  used during playback have a usage of
  AudioAttributes#USAGE_MEDIA  and a content type of
  AudioAttributes#CONTENT_TYPE_MOVIE  use  setAudioAttributes(android.media.AudioAttributes)  to
 modify them."
android,java.security.spec,DSAParameterSpec,3,This class specifies the set of parameters used with the DSA algorithm.
android,java.security.spec,DSAPrivateKeySpec,4,This class specifies a DSA private key with its associated parameters.
android,java.security.spec,ECFieldF2m,6,"This immutable class defines an elliptic curve (EC)
 characteristic 2 finite field."
android,java.security.spec,ECFieldFp,4,"This immutable class defines an elliptic curve (EC) prime
 finite field."
android,java.security.spec,ECGenParameterSpec,1,"This immutable class specifies the set of parameters used for
 generating elliptic curve (EC) domain parameters."
android,java.security.spec,ECParameterSpec,4,"This immutable class specifies the set of domain parameters
 used with elliptic curve cryptography (ECC)."
android,java.security.spec,ECPoint,4,"This immutable class represents a point on an elliptic curve (EC)
 in affine coordinates. Other coordinate systems can
 extend this class to represent this point in other
 coordinates."
android,java.security.spec,ECPrivateKeySpec,2,"This immutable class specifies an elliptic curve private key with
 its associated parameters."
android,java.security.spec,ECPublicKeySpec,2,"This immutable class specifies an elliptic curve public key with
 its associated parameters."
android,java.security.spec,EllipticCurve,6,"This immutable class holds the necessary values needed to represent
 an elliptic curve."
android,java.security.spec,EncodedKeySpec,2,This class represents a public or private key in encoded format.
android,java.security.spec,PKCS8EncodedKeySpec,2,"This class represents the ASN.1 encoding of a private key
 encoded according to the ASN.1 type  PrivateKeyInfo .
 The  PrivateKeyInfo  syntax is defined in the PKCS#8 standard
 as follows:

  
 PrivateKeyInfo ::= SEQUENCE {
   version Version
   privateKeyAlgorithm PrivateKeyAlgorithmIdentifier
   privateKey PrivateKey
   attributes [0] IMPLICIT Attributes OPTIONAL }

 Version ::= INTEGER

 PrivateKeyAlgorithmIdentifier ::= AlgorithmIdentifier

 PrivateKey ::= OCTET STRING

 Attributes ::= SET OF Attribute"
android,java.security.spec,RSAKeyGenParameterSpec,2,"This class specifies the set of parameters used to generate an RSA
 key pair."
android,java.security.spec,RSAOtherPrimeInfo,3,"This class represents the triplet (prime exponent and coefficient)
 inside RSA's OtherPrimeInfo structure as defined in the PKCS#1 v2.1.
 The ASN.1 syntax of RSA's OtherPrimeInfo is as follows:

  
 OtherPrimeInfo ::= SEQUENCE {
   prime INTEGER
   exponent INTEGER
   coefficient INTEGER
   }"
android,java.security.spec,RSAPrivateKeySpec,2,This class specifies an RSA private key.
android,java.security.spec,DSAPublicKeySpec,4,This class specifies a DSA public key with its associated parameters.
android,java.security.spec,MGF1ParameterSpec,1,"This class specifies the set of parameters used with mask generation
 function MGF1 in OAEP Padding and RSA-PSS signature scheme as
 defined in the
  PKCS #1 v2.1 
 standard.

  Its ASN.1 definition in PKCS#1 standard is described below:
  
 MGF1Parameters ::= OAEP-PSSDigestAlgorthms
  
 OAEP-PSSDigestAlgorithms    ALGORITHM-IDENTIFIER ::= {
   { OID id-sha1 PARAMETERS NULL   }|
   { OID id-sha224 PARAMETERS NULL   }|
   { OID id-sha256 PARAMETERS NULL }|
   { OID id-sha384 PARAMETERS NULL }|
   { OID id-sha512 PARAMETERS NULL }
   ...  -- Allows for future expansion --
 }"
android,java.security.spec,PSSParameterSpec,5,"This class specifies a parameter spec for RSA-PSS signature scheme
 as defined in the
  PKCS#1 v2.1 
 standard.

  Its ASN.1 definition in PKCS#1 standard is described below:
  
 RSASSA-PSS-params ::= SEQUENCE {
   hashAlgorithm      [0] OAEP-PSSDigestAlgorithms  DEFAULT sha1
   maskGenAlgorithm   [1] PKCS1MGFAlgorithms  DEFAULT mgf1SHA1
   saltLength         [2] INTEGER  DEFAULT 20
   trailerField       [3] INTEGER  DEFAULT 1
 }
  
 OAEP-PSSDigestAlgorithms    ALGORITHM-IDENTIFIER ::= {
   { OID id-sha1 PARAMETERS NULL   }|
   { OID id-sha224 PARAMETERS NULL   }|
   { OID id-sha256 PARAMETERS NULL }|
   { OID id-sha384 PARAMETERS NULL }|
   { OID id-sha512 PARAMETERS NULL }
   ...  -- Allows for future expansion --
 }

 PKCS1MGFAlgorithms    ALGORITHM-IDENTIFIER ::= {
   { OID id-mgf1 PARAMETERS OAEP-PSSDigestAlgorithms }
   ...  -- Allows for future expansion --
 }
  Note: the PSSParameterSpec.DEFAULT uses the following:
     message digest  -- ""SHA-1""
     mask generation function (mgf) -- ""MGF1""
     parameters for mgf -- MGF1ParameterSpec.SHA1
     SaltLength   -- 20
     TrailerField -- 1"
android,java.security.spec,RSAMultiPrimePrivateCrtKeySpec,7,"This class specifies an RSA multi-prime private key as defined in the
 PKCS#1 v2.1 using the Chinese Remainder Theorem (CRT) information
 values for efficiency."
android,java.security.spec,RSAPrivateCrtKeySpec,6,"This class specifies an RSA private key as defined in the PKCS#1
 standard using the Chinese Remainder Theorem (CRT) information values for
 efficiency."
android,java.security.spec,RSAPublicKeySpec,2,This class specifies an RSA public key.
android,java.security.spec,X509EncodedKeySpec,2,"This class represents the ASN.1 encoding of a public key
 encoded according to the ASN.1 type  SubjectPublicKeyInfo .
 The  SubjectPublicKeyInfo  syntax is defined in the X.509
 standard as follows:

  
 SubjectPublicKeyInfo ::= SEQUENCE {
   algorithm AlgorithmIdentifier
   subjectPublicKey BIT STRING }"
