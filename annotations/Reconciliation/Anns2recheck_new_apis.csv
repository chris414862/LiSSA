,Old Annotation,New Annotation,Description,Parameters,Return,ClassDescription,PackageDescription
<android.view.contentcapture.ContentCaptureSession: void setContentCaptureContext(ContentCaptureContext)>,NEITHER,SINK,Sets the ContentCaptureContext associated with the session. Typically used to change the context associated with the default session from an activity.,context ContentCaptureContext : This value may be null . |||,void,Session used when notifying the Android system about events associated with views.,
<android.view.contentcapture.ContentCaptureContext: Bundle getExtras()>,NEITHER,SOURCE,Gets the (optional) extras set by the app (through Builder#setExtras(Bundle) ). It can be used to provide vendor-specific data that can be modified and examined.,,Bundle This value may be null . |||,"Context associated with a  ContentCaptureSession  - see  ContentCaptureManager  for
 more info.",
<android.view.contentcapture.ContentCaptureCondition: int hashCode()>,NEITHER,NEITHER,"Returns a hash code value for the object. This method is
 supported for the benefit of hash tables such as those provided by HashMap . The general contract of hashCode is: Whenever it is invoked on the same object more than once during
     an execution of a Java application the hashCode method
     must consistently return the same integer provided no information
     used in equals comparisons on the object is modified.
     This integer need not remain consistent from one execution of an
     application to another execution of the same application. 
If two objects are equal according to the equals(Object) method then calling the hashCode method on each of
     the two objects must produce the same integer result. 
It is not required that if two objects are unequal
     according to the equals(java.lang.Object) method then calling the hashCode method on each of the
     two objects must produce distinct integer results.  However the
     programmer should be aware that producing distinct integer results
     for unequal objects may improve the performance of hash tables. 
As much as is reasonably practical the hashCode method defined by
 class Object does return distinct integers for distinct
 objects. (This is typically implemented by converting the internal
 address of the object into an integer but this implementation
 technique is not required by the
 Javaâ„¢ programming language.)",,int a hash code value for this object. |||,"Defines a condition for when content capture should be allowed.

  See  ContentCaptureManager#getContentCaptureConditions()  for more.",
<android.view.contentcapture.ContentCaptureContext.Builder: ContentCaptureContext build()>,NEITHER,SOURCE,Builds the ContentCaptureContext .,,ContentCaptureContext the built ContentCaptureContext This value will never be null . |||,Builder for  ContentCaptureContext  objects.,
<android.view.contentcapture.ContentCaptureSessionId: String toString()>,SOURCE,SOURCE,"Returns a string representation of the object. In general the toString method returns a string that
 ""textually represents"" this object. The result should
 be a concise but informative representation that is easy for a
 person to read.
 It is recommended that all subclasses override this method. The toString method for class Object returns a string consisting of the name of the class of which the
 object is an instance the at-sign character ` @ ' and
 the unsigned hexadecimal representation of the hash code of the
 object. In other words this method returns a string equal to the
 value of: NOTE: this method is only useful for debugging purposes and is not guaranteed to
 be stable hence it should not be used to identify the session.",,String a string representation of the object. |||,Identifier for a Content Capture session.,
<android.view.contentcapture.ContentCaptureContext: LocusId getLocusId()>,SOURCE,SOURCE,Gets the context id.,,LocusId This value may be null . |||,"Context associated with a  ContentCaptureSession  - see  ContentCaptureManager  for
 more info.",
<android.view.contentcapture.DataRemovalRequest: int describeContents()>,NEITHER,NEITHER,"Describe the kinds of special objects contained in this Parcelable
 instance's marshaled representation. For example if the object will
 include a file descriptor in the output of writeToParcel(android.os.Parcel int) the return value of this method must include the CONTENTS_FILE_DESCRIPTOR bit.",,"int a bitmask indicating the set of special object types marshaled
 by this Parcelable object instance.
 
 Value is either 0 or CONTENTS_FILE_DESCRIPTOR |||","Class used by apps to remove content capture data associated with  LocusId .

  An app which has tagged data with a LocusId can therefore delete them later. This is intended
 to let apps propagate deletions of user data into the operating system.",
"<android.view.contentcapture.ContentCaptureSession: ViewStructure newVirtualViewStructure(AutofillId,long)>",NEITHER,SOURCE,"Creates a ViewStructure for a ""virtual"" view so it can be passed to notifyViewAppeared(android.view.ViewStructure) by the view managing the virtual view hierarchy.","parentId AutofillId : id of the virtual view parent (it can be obtained by calling ViewStructure#getAutofillId() on the parent).
This value must never be null . |||
virtualId long : id of the virtual child relative to the parent. |||","ViewStructure a new ViewStructure that can be used for Content Capture purposes.
 
 This value will never be null . |||",Session used when notifying the Android system about events associated with views.,
"<android.view.contentcapture.ContentCaptureSession: void notifyViewTextChanged(AutofillId,CharSequence)>",SINK,NEITHER,Notifies the Intelligence Service that the value of a text node has been changed.,"id AutofillId : of the node.
This value must never be null . |||
text CharSequence : new text.
This value may be null . |||",void,Session used when notifying the Android system about events associated with views.,
<android.view.contentcapture.DataRemovalRequest.LocusIdRequest: int getFlags()>,NEITHER,SOURCE,Gets the flags associates with request.,,"int either DataRemovalRequest#FLAG_IS_PREFIX or 0 .
 
 This value will never be null .
 
 Value is either 0 or DataRemovalRequest.FLAG_IS_PREFIX |||",Representation of a request to remove data associated with a  LocusId .,
<android.view.contentcapture.DataRemovalRequest: String getPackageName()>,NEITHER,SOURCE,Gets the name of the app that's making the request.,,String This value will never be null . |||,"Class used by apps to remove content capture data associated with  LocusId .

  An app which has tagged data with a LocusId can therefore delete them later. This is intended
 to let apps propagate deletions of user data into the operating system.",
<android.view.contentcapture.ContentCaptureContext: ContentCaptureContext forLocusId(String)>,NEITHER,SOURCE,Helper that creates a ContentCaptureContext associated with the given id .,id String : This value must never be null . |||,ContentCaptureContext This value will never be null . |||,"Context associated with a  ContentCaptureSession  - see  ContentCaptureManager  for
 more info.",
<android.view.contentcapture.DataRemovalRequest.Builder: DataRemovalRequest build()>,NEITHER,NEITHER,Builds the DataRemovalRequest .,,DataRemovalRequest This value will never be null . |||,Builder for  DataRemovalRequest  objects.,
<android.view.contentcapture.ContentCaptureSession: void notifyViewDisappeared(AutofillId)>,NEITHER,NEITHER,"Notifies the Content Capture Service that a node has been removed from the view structure. Typically called ""manually"" by views that handle their own virtual view hierarchy or
 automatically by the Android System for standard views.","id AutofillId : id of the node that has been removed.
This value must never be null . |||",void,Session used when notifying the Android system about events associated with views.,
<android.view.contentcapture.ContentCaptureManager: void setContentCaptureEnabled(boolean)>,NEITHER,NEITHER,"Called by apps to explicitly enable or disable content capture. Note: this call is not persisted accross reboots so apps should typically call
 it on Activity.onCreate(android.os.Bundle android.os.PersistableBundle) .",enabled boolean |||,void,"Content capture is mechanism used to let apps notify the Android system of events associated with
 views.

  Before using this manager you should check if it's available. Example:
  
  ContentCaptureManager mgr = context.getSystemService(ContentCaptureManager.class);
  if (mgr != null && mgr.isContentCaptureEnabled()) {
    // ...
  }
   To support content capture you must notifiy the Android system of the following events:

  When a visible view is laid out call
    ContentCaptureSession#notifyViewAppeared(ViewStructure) .
    When a view becomes invisible or is removed from the view hierarchy call
    ContentCaptureSession#notifyViewDisappeared(android.view.autofill.AutofillId) .
    When the view represents text and the text value changed call  ContentCaptureSession#notifyViewTextChanged(android.view.autofill.AutofillId CharSequence) .
  You can get a blank content capture structure using
  ContentCaptureSession#newViewStructure(View)  then populate its relevant fields.
 Here's an example of the relevant methods for an  EditText -like view:

  
 public class MyEditText extends View {

 private void populateContentCaptureStructure(@NonNull ViewStructure structure) {
   structure.setText(getText() getSelectionStart() getSelectionEnd());
   structure.setHint(getHint());
   structure.setInputType(getInputType());
   // set other properties like setTextIdEntry() setTextLines() setTextStyle()
   // setMinTextEms() setMaxTextEms() setMaxTextLength()
 }

 private void onTextChanged() {
   if (isLaidOut() && isTextEditable()) {
     ContentCaptureManager mgr = mContext.getSystemService(ContentCaptureManager.class);
     if (cm != null && cm.isContentCaptureEnabled()) {
        ContentCaptureSession session = getContentCaptureSession();
        if (session != null) {
          session.notifyViewTextChanged(getAutofillId() getText());
        }
   }
 }
  The main integration point with content capture is the  ContentCaptureSession . A ""main""
 session is automatically created by the Android system when content capture is enabled for the
 activity. The session could have a  ContentCaptureContext  to provide more contextual info
 about it such as the locus associated with the view hierarchy
 (see  LocusId  for more info about locus). By default the main session
 doesn't have a  ContentCaptureContext  but you can change it after its created. Example:

  
 protected void onCreate(Bundle savedInstanceState) {
   // Initialize view structure
   ContentCaptureSession session = rootView.getContentCaptureSession();
   if (session != null) {
     session.setContentCaptureContext(ContentCaptureContext.forLocusId(""chat_UserA_UserB""));
   }
 }
  If your activity contains view hierarchies with a different contextual meaning you should
 created child sessions for each view hierarchy root. For example if your activity is a browser
 you could use the main session for the main URL being rendered then child sessions for each
  IFRAME :

  
 ContentCaptureSession mMainSession;

 protected void onCreate(Bundle savedInstanceState) {
    // Initialize view structure...
    mMainSession = rootView.getContentCaptureSession();
    if (mMainSession != null) {
      mMainSession.setContentCaptureContext(
          ContentCaptureContext.forLocusId(""https://example.com""));
    }
 }

 private void loadIFrame(View iframeRootView String url) {
   if (mMainSession != null) {
      ContentCaptureSession iFrameSession = mMainSession.newChild(
          ContentCaptureContext.forLocusId(url));
      }
      iframeRootView.setContentCaptureSession(iFrameSession);
   }
   // Load iframe...
 }",
<android.view.contentcapture.ContentCaptureSession: void notifyViewAppeared(ViewStructure)>,NEITHER,NEITHER,"Notifies the Content Capture Service that a node has been added to the view structure. Typically called ""manually"" by views that handle their own virtual view hierarchy or
 automatically by the Android System for views that return true on View#onProvideContentCaptureStructure(ViewStructure int) .","node ViewStructure : node that has been added.
This value must never be null . |||",void,Session used when notifying the Android system about events associated with views.,
<android.view.contentcapture.ContentCaptureContext: String toString()>,NEITHER,SOURCE,"Returns a string representation of the object. In general the toString method returns a string that
 ""textually represents"" this object. The result should
 be a concise but informative representation that is easy for a
 person to read.
 It is recommended that all subclasses override this method. The toString method for class Object returns a string consisting of the name of the class of which the
 object is an instance the at-sign character ` @ ' and
 the unsigned hexadecimal representation of the hash code of the
 object. In other words this method returns a string equal to the
 value of:",,String a string representation of the object. |||,"Context associated with a  ContentCaptureSession  - see  ContentCaptureManager  for
 more info.",
<android.hardware.camera2.params.SessionConfiguration: int describeContents()>,NEITHER,SOURCE,"Describe the kinds of special objects contained in this Parcelable
 instance's marshaled representation. For example if the object will
 include a file descriptor in the output of writeToParcel(android.os.Parcel int) the return value of this method must include the CONTENTS_FILE_DESCRIPTOR bit.",,"int a bitmask indicating the set of special object types marshaled
 by this Parcelable object instance.
 
 Value is either 0 or CONTENTS_FILE_DESCRIPTOR |||",A helper class that aggregates all supported arguments for capture session initialization.,"The android.hardware.camera2 package provides an interface to
 individual camera devices connected to an Android device. It replaces
 the deprecated  Camera  class. This package models a camera device as a pipeline which takes in
 input requests for capturing a single frame captures the single image
 per the request and then outputs one capture result metadata packet
 plus a set of output image buffers for the request. The requests are
 processed in-order and multiple requests can be in flight at
 once. Since the camera device is a pipeline with multiple stages
 having multiple requests in flight is required to maintain full
 framerate on most Android devices. To enumerate query and open available camera devices obtain a
  CameraManager  instance. Individual  CameraDevices  provide a set of static property information that
 describes the hardware device and the available settings and output
 parameters for the device. This information is provided through the
  CameraCharacteristics  object and is
 available through  getCameraCharacteristics(String) To capture or stream images from a camera device the application
 must first create a  camera capture session 
 with a set of output Surfaces for use with the camera device with
  createCaptureSession(SessionConfiguration) . Each
 Surface has to be pre-configured with an  appropriate
 size and format  (if applicable) to match the sizes and formats
 available from the camera device. A target Surface can be obtained
 from a variety of classes including  SurfaceView 
  SurfaceTexture  via
  Surface(SurfaceTexture) 
  MediaCodec   MediaRecorder 
  Allocation  and  ImageReader .
  Generally camera preview images are sent to  SurfaceView  or  TextureView  (via its
  SurfaceTexture ). Capture of JPEG images or
 RAW buffers for  DngCreator  can be
 done with  ImageReader  with the  JPEG  and  RAW_SENSOR  formats.  Application-driven
 processing of camera data in RenderScript OpenGL ES or directly in
 managed or native code is best done through  Allocation  with a YUV  Type   SurfaceTexture 
 and  ImageReader  with a  YUV_420_888  format respectively. The application then needs to construct a  CaptureRequest  which defines all the
 capture parameters needed by a camera device to capture a single
 image. The request also lists which of the configured output Surfaces
 should be used as targets for this capture. The CameraDevice has a
  factory method  for creating a  request builder  for a
 given use case which is optimized for the Android device the
 application is running on. Once the request has been set up it can be handed to the active
 capture session either for a one-shot  capture  or for
 an endlessly  repeating  use. Both methods also have a variant that accepts a list
 of requests to use as a burst capture / repeating burst. Repeating
 requests have a lower priority than captures so a request submitted
 through  capture()  while there's a repeating request
 configured will be captured before any new instances of the currently
 repeating (burst) capture will begin capture. After processing a request the camera device will produce a  TotalCaptureResult  object which contains
 information about the state of the camera device at time of capture
 and the final settings used. These may vary somewhat from the request
 if rounding or resolving contradictory parameters was necessary. The
 camera device will also send a frame of image data into each of the
 output  Surfaces  included in the request. These are produced
 asynchronously relative to the output CaptureResult sometimes
 substantially later."
<android.media.session.MediaController.PlaybackInfo: int describeContents()>,SOURCE,SOURCE,"Describe the kinds of special objects contained in this Parcelable
 instance's marshaled representation. For example if the object will
 include a file descriptor in the output of writeToParcel(android.os.Parcel int) the return value of this method must include the CONTENTS_FILE_DESCRIPTOR bit.",,"int a bitmask indicating the set of special object types marshaled
 by this Parcelable object instance.
 
 Value is either 0 or CONTENTS_FILE_DESCRIPTOR |||","Holds information about the current playback and how audio is handled for
 this session.","The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager )."
<android.net.wifi.rtt.ResponderLocation: int describeContents()>,SOURCE,SOURCE,"Describe the kinds of special objects contained in this Parcelable
 instance's marshaled representation. For example if the object will
 include a file descriptor in the output of writeToParcel(android.os.Parcel int) the return value of this method must include the CONTENTS_FILE_DESCRIPTOR bit.",,"int a bitmask indicating the set of special object types marshaled
 by this Parcelable object instance.
 
 Value is either 0 or CONTENTS_FILE_DESCRIPTOR |||","ResponderLocation is both a Location Configuration Information (LCI) decoder and a Location Civic
 Report (LCR) decoder for information received from a Wi-Fi Access Point (AP) during Wi-Fi RTT
 ranging process.

  This is based on the IEEE P802.11-REVmc/D8.0 spec section 9.4.2.22 under Measurement Report
 Element. Subelement location data-fields parsed from separate input LCI and LCR Information
 Elements are unified in this class. Note: The information provided by this class is broadcast by a responder (usually an Access
 Point) and passed on as-is. There is no guarantee this information is accurate or correct and
 as a result developers should carefully consider how this information should be used and provide
 corresponding advice to users.","Provides classes which allow applications to use Wi-Fi RTT (IEEE 802.11mc) to measure distance
     to supporting Access Points and peer devices. The primary entry point to Wi-Fi RTT capabilities is the
      WifiRttManager  class which is acquired by calling
      Context.getSystemService(Context.WIFI_RTT_RANGING_SERVICE) Some APIs may require the following user permissions: ACCESS_WIFI_STATE CHANGE_WIFI_STATE ACCESS_FINE_LOCATION Usage of the API is also gated by the device's Location Mode: whether it permits Wi-Fi based
 location to be queried. Note:  Not all Android-powered devices support Wi-Fi RTT
     functionality.
     If your application only works with Wi-Fi RTT (i.e. it should only be installed on devices which
     support Wi-Fi RTT) declare so with a  <uses-feature> 
     element in the manifest file: 
 <manifest ...>
     <uses-feature android:name=""android.hardware.wifi.rtt"" />
     ...
 </manifest>
  Alternatively if your application does not require Wi-Fi RTT but can take advantage of it if
     available you can perform
     the check at run-time in your code using  hasSystemFeature(String)  with  FEATURE_WIFI_RTT : 
     getPackageManager().hasSystemFeature(PackageManager.FEATURE_WIFI_RTT)"
<android.service.autofill.TextValueSanitizer: int describeContents()>,NEITHER,NEITHER,"Describe the kinds of special objects contained in this Parcelable
 instance's marshaled representation. For example if the object will
 include a file descriptor in the output of writeToParcel(android.os.Parcel int) the return value of this method must include the CONTENTS_FILE_DESCRIPTOR bit.",,"int a bitmask indicating the set of special object types marshaled
 by this Parcelable object instance.
 
 Value is either 0 or CONTENTS_FILE_DESCRIPTOR |||","Sanitizes a text  AutofillValue  using a regular expression (regex) substitution.

  For example to remove spaces from groups of 4-digits in a credit card:

  
 new TextValueSanitizer(Pattern.compile(""^(\\d{4})\\s?(\\d{4})\\s?(\\d{4})\\s?(\\d{4})$"")
     ""$1$2$3$4"")",
<android.telephony.mbms.FileServiceInfo: int describeContents()>,SOURCE,SOURCE,"Describe the kinds of special objects contained in this Parcelable
 instance's marshaled representation. For example if the object will
 include a file descriptor in the output of writeToParcel(android.os.Parcel int) the return value of this method must include the CONTENTS_FILE_DESCRIPTOR bit.",,"int a bitmask indicating the set of special object types marshaled
 by this Parcelable object instance.
 
 Value is either 0 or CONTENTS_FILE_DESCRIPTOR |||","Describes a file service available from the carrier from which files can be downloaded via
 cell-broadcast.",
<android.telephony.CellInfoTdscdma: int describeContents()>,SOURCE,SOURCE,Implement the Parcelable interface,,"int a bitmask indicating the set of special object types marshaled
 by this Parcelable object instance.
 
 Value is either 0 or CONTENTS_FILE_DESCRIPTOR |||",A  CellInfo  representing a TD-SCDMA cell that provides identity and measurement info.,
<android.telephony.mbms.FileInfo: int describeContents()>,NEITHER,SOURCE,"Describe the kinds of special objects contained in this Parcelable
 instance's marshaled representation. For example if the object will
 include a file descriptor in the output of writeToParcel(android.os.Parcel int) the return value of this method must include the CONTENTS_FILE_DESCRIPTOR bit.",,"int a bitmask indicating the set of special object types marshaled
 by this Parcelable object instance.
 
 Value is either 0 or CONTENTS_FILE_DESCRIPTOR |||",Describes a single file that is available over MBMS.,
<android.service.autofill.UserData: int describeContents()>,NEITHER,SOURCE,"Describe the kinds of special objects contained in this Parcelable
 instance's marshaled representation. For example if the object will
 include a file descriptor in the output of writeToParcel(android.os.Parcel int) the return value of this method must include the CONTENTS_FILE_DESCRIPTOR bit.",,"int a bitmask indicating the set of special object types marshaled
 by this Parcelable object instance.
 
 Value is either 0 or CONTENTS_FILE_DESCRIPTOR |||","Defines the user data used for
  field classification .",
<android.telephony.AvailableNetworkInfo: int describeContents()>,SOURCE,SOURCE,"Describe the kinds of special objects contained in this Parcelable
 instance's marshaled representation. For example if the object will
 include a file descriptor in the output of writeToParcel(android.os.Parcel int) the return value of this method must include the CONTENTS_FILE_DESCRIPTOR bit.",,"int a bitmask indicating the set of special object types marshaled
 by this Parcelable object instance.
 
 Value is either 0 or CONTENTS_FILE_DESCRIPTOR |||","Defines available network information which includes corresponding subscription id
 network plmns and corresponding priority to be used for network selection by Opportunistic
 Network Service when passed through  TelephonyManager#updateAvailableNetworks",
<android.view.textclassifier.ConversationActions.Message: int describeContents()>,NEITHER,SOURCE,"Describe the kinds of special objects contained in this Parcelable
 instance's marshaled representation. For example if the object will
 include a file descriptor in the output of writeToParcel(android.os.Parcel int) the return value of this method must include the CONTENTS_FILE_DESCRIPTOR bit.",,"int a bitmask indicating the set of special object types marshaled
 by this Parcelable object instance.
 
 Value is either 0 or CONTENTS_FILE_DESCRIPTOR |||",Represents a message in the conversation.,
<android.service.autofill.DateTransformation: int describeContents()>,NEITHER,NEITHER,"Describe the kinds of special objects contained in this Parcelable
 instance's marshaled representation. For example if the object will
 include a file descriptor in the output of writeToParcel(android.os.Parcel int) the return value of this method must include the CONTENTS_FILE_DESCRIPTOR bit.",,"int a bitmask indicating the set of special object types marshaled
 by this Parcelable object instance.
 
 Value is either 0 or CONTENTS_FILE_DESCRIPTOR |||","Replaces a  TextView  child of a  CustomDescription  with the contents of a field
 that is expected to have a  AutofillValue#forDate(long) .

  For example a transformation to display a credit card expiration date as month/year would be:

  
 new DateTransformation(ccExpDate new java.text.SimpleDateFormat(""MM/yyyy"")",
<android.net.IpSecAlgorithm: int describeContents()>,NEITHER,SOURCE,"Describe the kinds of special objects contained in this Parcelable
 instance's marshaled representation. For example if the object will
 include a file descriptor in the output of writeToParcel(android.os.Parcel int) the return value of this method must include the CONTENTS_FILE_DESCRIPTOR bit.",,"int a bitmask indicating the set of special object types marshaled
 by this Parcelable object instance.
 
 Value is either 0 or CONTENTS_FILE_DESCRIPTOR |||",This class represents a single algorithm that can be used by an  IpSecTransform .,
<android.view.textclassifier.TextClassifier.EntityConfig: int describeContents()>,NEITHER,NEITHER,"Describe the kinds of special objects contained in this Parcelable
 instance's marshaled representation. For example if the object will
 include a file descriptor in the output of writeToParcel(android.os.Parcel int) the return value of this method must include the CONTENTS_FILE_DESCRIPTOR bit.",,"int a bitmask indicating the set of special object types marshaled
 by this Parcelable object instance.
 
 Value is either 0 or CONTENTS_FILE_DESCRIPTOR |||","Configuration object for specifying what entity types to identify.

 Configs are initially based on a predefined preset and can be modified from there.",
<android.view.textclassifier.TextClassifierEvent: int describeContents()>,NEITHER,NEITHER,"Describe the kinds of special objects contained in this Parcelable
 instance's marshaled representation. For example if the object will
 include a file descriptor in the output of writeToParcel(android.os.Parcel int) the return value of this method must include the CONTENTS_FILE_DESCRIPTOR bit.",,"int a bitmask indicating the set of special object types marshaled
 by this Parcelable object instance.
 
 Value is either 0 or CONTENTS_FILE_DESCRIPTOR |||","This class represents events that are sent by components to the  TextClassifier  to report
 something of note that relates to a feature powered by the TextClassifier. The TextClassifier may
 log these events or use them to improve future responses to queries.
  
 Each category of events has its their own subclass. Events of each type have an associated
 set of related properties. You can find their specification in the subclasses.",
<android.net.wifi.rtt.RangingRequest: int describeContents()>,NEITHER,SOURCE,"Describe the kinds of special objects contained in this Parcelable
 instance's marshaled representation. For example if the object will
 include a file descriptor in the output of writeToParcel(android.os.Parcel int) the return value of this method must include the CONTENTS_FILE_DESCRIPTOR bit.",,"int a bitmask indicating the set of special object types marshaled
 by this Parcelable object instance.
 
 Value is either 0 or CONTENTS_FILE_DESCRIPTOR |||","Defines the ranging request to other devices. The ranging request is built using
  RangingRequest.Builder .
 A ranging request is executed using
  WifiRttManager#startRanging(RangingRequest java.util.concurrent.Executor RangingResultCallback) .
  
 The ranging request is a batch request - specifying a set of devices (specified using
  RangingRequest.Builder#addAccessPoint(ScanResult)  and
  RangingRequest.Builder#addAccessPoints(List) ).","Provides classes which allow applications to use Wi-Fi RTT (IEEE 802.11mc) to measure distance
     to supporting Access Points and peer devices. The primary entry point to Wi-Fi RTT capabilities is the
      WifiRttManager  class which is acquired by calling
      Context.getSystemService(Context.WIFI_RTT_RANGING_SERVICE) Some APIs may require the following user permissions: ACCESS_WIFI_STATE CHANGE_WIFI_STATE ACCESS_FINE_LOCATION Usage of the API is also gated by the device's Location Mode: whether it permits Wi-Fi based
 location to be queried. Note:  Not all Android-powered devices support Wi-Fi RTT
     functionality.
     If your application only works with Wi-Fi RTT (i.e. it should only be installed on devices which
     support Wi-Fi RTT) declare so with a  <uses-feature> 
     element in the manifest file: 
 <manifest ...>
     <uses-feature android:name=""android.hardware.wifi.rtt"" />
     ...
 </manifest>
  Alternatively if your application does not require Wi-Fi RTT but can take advantage of it if
     available you can perform
     the check at run-time in your code using  hasSystemFeature(String)  with  FEATURE_WIFI_RTT : 
     getPackageManager().hasSystemFeature(PackageManager.FEATURE_WIFI_RTT)"
<android.view.SurfaceControl: int describeContents()>,NEITHER,SOURCE,"Describe the kinds of special objects contained in this Parcelable
 instance's marshaled representation. For example if the object will
 include a file descriptor in the output of writeToParcel(android.os.Parcel int) the return value of this method must include the CONTENTS_FILE_DESCRIPTOR bit.",,"int a bitmask indicating the set of special object types marshaled
 by this Parcelable object instance.
 
 Value is either 0 or CONTENTS_FILE_DESCRIPTOR |||","Handle onto a raw buffer that is being managed by the screen compositor.

  A Surface is generally created by or from a consumer of image buffers (such as a
  SurfaceTexture   MediaRecorder  or
  Allocation ) and is handed to some kind of producer (such as
  OpenGL 
  MediaPlayer  or
  CameraDevice ) to draw
 into. Note:  A Surface acts like a
  weak reference  to the consumer it is associated with. By
 itself it will not keep its parent consumer from being reclaimed.",
<android.service.autofill.CustomDescription: int describeContents()>,NEITHER,NEITHER,"Describe the kinds of special objects contained in this Parcelable
 instance's marshaled representation. For example if the object will
 include a file descriptor in the output of writeToParcel(android.os.Parcel int) the return value of this method must include the CONTENTS_FILE_DESCRIPTOR bit.",,"int a bitmask indicating the set of special object types marshaled
 by this Parcelable object instance.
 
 Value is either 0 or CONTENTS_FILE_DESCRIPTOR |||","Defines a custom description for the autofill save UI.

  This is useful when the autofill service needs to show a detailed view of what would be saved;
 for example when the screen contains a credit card it could display a logo of the credit card
 bank the last four digits of the credit card number and its expiration number.

  A custom description is made of 2 parts:
  A  RemoteViews  containing children views.
    Transformation  to populate the children views.
  For the credit card example mentioned above the (simplified) template would be:

  
 <LinearLayout>
   <ImageView android:id=""@+id/templateccLogo""/>
   <TextView android:id=""@+id/templateCcNumber""/>
   <TextView android:id=""@+id/templateExpDate""/>
 </LinearLayout>
  Which in code translates to:

  
   CustomDescription.Builder buider = new Builder(new RemoteViews(pgkName R.layout.cc_template);
  Then the value of each of the 3 children would be changed at runtime based on the the value of
 the screen fields and the  Transformation :

  
 // Image child - different logo for each bank based on credit card prefix
 builder.addChild(R.id.templateccLogo
   new ImageTransformation.Builder(ccNumberId)
     .addOption(Pattern.compile(""^4815.*$"") R.drawable.ic_credit_card_logo1)
     .addOption(Pattern.compile(""^1623.*$"") R.drawable.ic_credit_card_logo2)
     .addOption(Pattern.compile(""^42.*$"") R.drawable.ic_credit_card_logo3)
     .build();
 // Masked credit card number (as .....LAST_4_DIGITS)
 builder.addChild(R.id.templateCcNumber new CharSequenceTransformation
     .Builder(ccNumberId Pattern.compile(""^.*(\\d\\d\\d\\d)$"") ""...$1"")
     .build();
 // Expiration date as MM / YYYY:
 builder.addChild(R.id.templateExpDate new CharSequenceTransformation
     .Builder(ccExpMonthId Pattern.compile(""^(\\d\\d)$"") ""Exp: $1"")
     .addField(ccExpYearId Pattern.compile(""^(\\d\\d)$"") ""/$1"")
     .build();
  See  ImageTransformation   CharSequenceTransformation  for more info about these
 transformations.",
<android.view.textclassifier.TextClassification: int describeContents()>,NEITHER,NEITHER,"Describe the kinds of special objects contained in this Parcelable
 instance's marshaled representation. For example if the object will
 include a file descriptor in the output of writeToParcel(android.os.Parcel int) the return value of this method must include the CONTENTS_FILE_DESCRIPTOR bit.",,"int a bitmask indicating the set of special object types marshaled
 by this Parcelable object instance.
 
 Value is either 0 or CONTENTS_FILE_DESCRIPTOR |||","Information for generating a widget to handle classified text.

  A TextClassification object contains icons labels onClickListeners and intents that may
 be used to build a widget that can be used to act on classified text. There is the concept of a
  primary action  and other  secondary actions .

  e.g. building a view that when clicked shares the classified text with the preferred app:

  // Called preferably outside the UiThread.
   TextClassification classification = textClassifier.classifyText(allText 10 25);

   // Called on the UiThread.
   Button button = new Button(context);
   button.setCompoundDrawablesWithIntrinsicBounds(classification.getIcon() null null null);
   button.setText(classification.getLabel());
   button.setOnClickListener(v -> classification.getActions().get(0).getActionIntent().send());
  e.g. starting an action mode with menu items that can handle the classified text:

  // Called preferably outside the UiThread.
   final TextClassification classification = textClassifier.classifyText(allText 10 25);

   // Called on the UiThread.
   view.startActionMode(new ActionMode.Callback() {

       public boolean onCreateActionMode(ActionMode mode Menu menu) {
           for (int i = 0; i < classification.getActions().size(); ++i) {
              RemoteAction action = classification.getActions().get(i);
              menu.add(Menu.NONE i 20 action.getTitle())
                 .setIcon(action.getIcon());
           }
           return true;
       }

       public boolean onActionItemClicked(ActionMode mode MenuItem item) {
           classification.getActions().get(item.getItemId()).getActionIntent().send();
           return true;
       }

       ...
   });",
<android.telephony.euicc.DownloadableSubscription: int describeContents()>,NEITHER,SOURCE,"Describe the kinds of special objects contained in this Parcelable
 instance's marshaled representation. For example if the object will
 include a file descriptor in the output of writeToParcel(android.os.Parcel int) the return value of this method must include the CONTENTS_FILE_DESCRIPTOR bit.",,"int a bitmask indicating the set of special object types marshaled
 by this Parcelable object instance.
 
 Value is either 0 or CONTENTS_FILE_DESCRIPTOR |||","Information about a subscription which is downloadable to an eUICC using
  EuiccManager#downloadSubscription(DownloadableSubscription boolean PendingIntent)",
<android.telecom.PhoneAccountSuggestion: int describeContents()>,NEITHER,SOURCE,"Describe the kinds of special objects contained in this Parcelable
 instance's marshaled representation. For example if the object will
 include a file descriptor in the output of writeToParcel(android.os.Parcel int) the return value of this method must include the CONTENTS_FILE_DESCRIPTOR bit.",,"int a bitmask indicating the set of special object types marshaled
 by this Parcelable object instance.
 
 Value is either 0 or CONTENTS_FILE_DESCRIPTOR |||","Represents a distinct method to place or receive a phone call. Apps which can place calls and
 want those calls to be integrated into the dialer and in-call UI should build an instance of
 this class and register it with the system using  TelecomManager .
  TelecomManager  uses registered  PhoneAccount s to present the user with
 alternative options when placing a phone call. When building a  PhoneAccount  the app
 should supply a valid  PhoneAccountHandle  that references the connection service
 implementation Telecom will use to interact with the app.","Android supports the following calling use cases (with increasing level of complexity):
  Implement the self-managed  ConnectionService  API - this is ideal
     for developers of standalone calling apps which do not wish to show their calls within the
     default phone app and do not wish to have other calls shown in their user interface.  Using
     a self-managed  ConnectionService  implementation within your
     standalone calling app helps you ensure that your app will interoperate not only with native
     telephony calling on the device but also other standalone calling apps implementing this
     API.  It also manages audio routing and focus for you. Implement the managed  ConnectionService  API - facilitates
     development of a calling solution that relies on the existing device phone application (see
      getDefaultDialerPackage() ) to provide the user
     interface for calls.  An example might be a third party implementation of SIP calling or a
     VOIP calling service.  A  ConnectionService  alone provides only the
     means of connecting calls but has no associated user interface. Implement the  InCallService  API - facilitates development of a
     replacement for the device's default Phone/Dialer app.  The
      InCallService  alone does not have any calling capability and consists
     of the user-interface side of calling only.  An  InCallService  must
     handle all Calls the Telecom framework is aware of.  It must not make assumptions about the
     nature of the calls (e.g. assuming calls are SIM-based telephony calls) and should not
     implement calling restrictions based on any one  ConnectionService 
     (e.g. it should not enforce Telephony restrictions for video calls). Implement both the  InCallService  and
      ConnectionService  API - ideal if you wish to create your own
      ConnectionService  based calling solution complete with its own
     full user interface while showing all other Android calls in the same user interface.  Using
     this approach you must still ensure that your  InCallService  makes
     no assumption about the source of the calls it displays.  You must also ensure that your
      ConnectionService  implementation can still function without the
     default phone app being set to your custom  InCallService ."
<android.os.SharedMemory: int describeContents()>,NEITHER,SOURCE,"Describe the kinds of special objects contained in this Parcelable
 instance's marshaled representation. For example if the object will
 include a file descriptor in the output of writeToParcel(android.os.Parcel int) the return value of this method must include the CONTENTS_FILE_DESCRIPTOR bit.",,"int a bitmask indicating the set of special object types marshaled
 by this Parcelable object instance.
 
 Value is either 0 or CONTENTS_FILE_DESCRIPTOR |||",SharedMemory enables the creation mapping and protection control over anonymous shared memory.,
<android.content.pm.SigningInfo: int describeContents()>,NEITHER,SOURCE,"Describe the kinds of special objects contained in this Parcelable
 instance's marshaled representation. For example if the object will
 include a file descriptor in the output of writeToParcel(android.os.Parcel int) the return value of this method must include the CONTENTS_FILE_DESCRIPTOR bit.",,"int a bitmask indicating the set of special object types marshaled
 by this Parcelable object instance.
 
 Value is either 0 or CONTENTS_FILE_DESCRIPTOR |||",Information pertaining to the signing certificates used to sign a package.,"Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application componentsâ€”allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources ."
<android.app.Person: int describeContents()>,SOURCE,SOURCE,"Describe the kinds of special objects contained in this Parcelable
 instance's marshaled representation. For example if the object will
 include a file descriptor in the output of writeToParcel(android.os.Parcel int) the return value of this method must include the CONTENTS_FILE_DESCRIPTOR bit.",,"int a bitmask indicating the set of special object types marshaled
 by this Parcelable object instance.
 
 Value is either 0 or CONTENTS_FILE_DESCRIPTOR |||","Provides an immutable reference to an entity that appears repeatedly on different surfaces of the
 platform. For example this could represent the sender of a message.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 designâ€”especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activityâ€”allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User ."
<android.telephony.mbms.StreamingServiceInfo: int describeContents()>,SOURCE,SOURCE,"Describe the kinds of special objects contained in this Parcelable
 instance's marshaled representation. For example if the object will
 include a file descriptor in the output of writeToParcel(android.os.Parcel int) the return value of this method must include the CONTENTS_FILE_DESCRIPTOR bit.",,"int a bitmask indicating the set of special object types marshaled
 by this Parcelable object instance.
 
 Value is either 0 or CONTENTS_FILE_DESCRIPTOR |||",Describes a single MBMS streaming service.,
<android.telephony.CellSignalStrengthNr: int describeContents()>,NEITHER,SOURCE,"Describe the kinds of special objects contained in this Parcelable
 instance's marshaled representation. For example if the object will
 include a file descriptor in the output of writeToParcel(android.os.Parcel int) the return value of this method must include the CONTENTS_FILE_DESCRIPTOR bit.",,"int a bitmask indicating the set of special object types marshaled
 by this Parcelable object instance.
 
 Value is either 0 or CONTENTS_FILE_DESCRIPTOR |||",Abstract base class for cell phone signal strength related information.,
<android.service.autofill.CharSequenceTransformation: int describeContents()>,NEITHER,NEITHER,"Describe the kinds of special objects contained in this Parcelable
 instance's marshaled representation. For example if the object will
 include a file descriptor in the output of writeToParcel(android.os.Parcel int) the return value of this method must include the CONTENTS_FILE_DESCRIPTOR bit.",,"int a bitmask indicating the set of special object types marshaled
 by this Parcelable object instance.
 
 Value is either 0 or CONTENTS_FILE_DESCRIPTOR |||","Replaces a  TextView  child of a  CustomDescription  with the contents of one or
 more regular expressions (regexs).

  When it contains more than one field the fields that match their regex are added to the
 overall transformation result.

  For example a transformation to mask a credit card number contained in just one field would
 be:

  
 new CharSequenceTransformation
     .Builder(ccNumberId Pattern.compile(""^.*(\\d\\d\\d\\d)$"") ""...$1"")
     .build();
  But a transformation that generates a  Exp: MM / YYYY  credit expiration date from two
 fields (month and year) would be:

  
 new CharSequenceTransformation
   .Builder(ccExpMonthId Pattern.compile(""^(\\d\\d)$"") ""Exp: $1"")
   .addField(ccExpYearId Pattern.compile(""^(\\d\\d\\d\\d)$"") "" / $1"");",
<android.service.autofill.RegexValidator: int describeContents()>,NEITHER,NEITHER,"Describe the kinds of special objects contained in this Parcelable
 instance's marshaled representation. For example if the object will
 include a file descriptor in the output of writeToParcel(android.os.Parcel int) the return value of this method must include the CONTENTS_FILE_DESCRIPTOR bit.",,"int a bitmask indicating the set of special object types marshaled
 by this Parcelable object instance.
 
 Value is either 0 or CONTENTS_FILE_DESCRIPTOR |||","Defines if a field is valid based on a regular expression (regex).

  See  SaveInfo.Builder#setValidator(Validator)  for examples.",
<android.app.slice.SliceItem: int describeContents()>,NEITHER,NEITHER,"Describe the kinds of special objects contained in this Parcelable
 instance's marshaled representation. For example if the object will
 include a file descriptor in the output of writeToParcel(android.os.Parcel int) the return value of this method must include the CONTENTS_FILE_DESCRIPTOR bit.",,"int a bitmask indicating the set of special object types marshaled
 by this Parcelable object instance.
 
 Value is either 0 or CONTENTS_FILE_DESCRIPTOR |||","A SliceItem is a single unit in the tree structure of a  Slice .

 A SliceItem a piece of content and some hints about what that content
 means or how it should be displayed. The types of content can be:
  FORMAT_SLICE FORMAT_TEXT FORMAT_IMAGE FORMAT_ACTION FORMAT_INT FORMAT_LONG FORMAT_REMOTE_INPUT FORMAT_BUNDLE SliceItem Slice","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 designâ€”especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activityâ€”allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User ."
<android.net.MacAddress: int describeContents()>,SOURCE,SOURCE,"Describe the kinds of special objects contained in this Parcelable
 instance's marshaled representation. For example if the object will
 include a file descriptor in the output of writeToParcel(android.os.Parcel int) the return value of this method must include the CONTENTS_FILE_DESCRIPTOR bit.",,"int a bitmask indicating the set of special object types marshaled
 by this Parcelable object instance.
 
 Value is either 0 or CONTENTS_FILE_DESCRIPTOR |||","Representation of a MAC address.

 This class only supports 48 bits long addresses and does not support 64 bits long addresses.
 Instances of this class are immutable.",
<android.view.textclassifier.TextLinks: int describeContents()>,NEITHER,NEITHER,"Describe the kinds of special objects contained in this Parcelable
 instance's marshaled representation. For example if the object will
 include a file descriptor in the output of writeToParcel(android.os.Parcel int) the return value of this method must include the CONTENTS_FILE_DESCRIPTOR bit.",,"int a bitmask indicating the set of special object types marshaled
 by this Parcelable object instance.
 
 Value is either 0 or CONTENTS_FILE_DESCRIPTOR |||","A collection of links representing subsequences of text and the entity types (phone number
 address url etc) they may be.",
<android.telephony.CellSignalStrengthTdscdma: int describeContents()>,SOURCE,SOURCE,Implement the Parcelable interface,,"int a bitmask indicating the set of special object types marshaled
 by this Parcelable object instance.
 
 Value is either 0 or CONTENTS_FILE_DESCRIPTOR |||",Abstract base class for cell phone signal strength related information.,
<android.telephony.RadioAccessSpecifier: int describeContents()>,SOURCE,SOURCE,"Describe the kinds of special objects contained in this Parcelable
 instance's marshaled representation. For example if the object will
 include a file descriptor in the output of writeToParcel(android.os.Parcel int) the return value of this method must include the CONTENTS_FILE_DESCRIPTOR bit.",,"int a bitmask indicating the set of special object types marshaled
 by this Parcelable object instance.
 
 Value is either 0 or CONTENTS_FILE_DESCRIPTOR |||","Describes a particular radio access network to be scanned.

 The scan can be performed on either bands or channels for a specific radio access network type.",
<android.app.Notification.BubbleMetadata: int describeContents()>,NEITHER,SOURCE,"Describe the kinds of special objects contained in this Parcelable
 instance's marshaled representation. For example if the object will
 include a file descriptor in the output of writeToParcel(android.os.Parcel int) the return value of this method must include the CONTENTS_FILE_DESCRIPTOR bit.",,"int a bitmask indicating the set of special object types marshaled
 by this Parcelable object instance.
 
 Value is either 0 or CONTENTS_FILE_DESCRIPTOR |||","A class that represents how a persistent notification is to be presented to
 the user using the  NotificationManager .

  The  Notification.Builder  has been added to make it
 easier to construct Notifications.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 designâ€”especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activityâ€”allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User ."
<android.media.audiofx.DynamicsProcessing.MbcBand: String toString()>,NEITHER,NEITHER,"Returns a string representation of the object. In general the toString method returns a string that
 ""textually represents"" this object. The result should
 be a concise but informative representation that is easy for a
 person to read.
 It is recommended that all subclasses override this method. The toString method for class Object returns a string consisting of the name of the class of which the
 object is an instance the at-sign character ` @ ' and
 the unsigned hexadecimal representation of the hash code of the
 object. In other words this method returns a string equal to the
 value of:",,String a string representation of the object. |||,"Class for Multi-Band compressor bands
 MBC bands have multiple controllable parameters: enabled/disabled cutoffFrequency
 attackTime releaseTime ratio threshold kneeWidth noiseGateThreshold expanderRatio
 preGain and postGain.","The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager )."
<android.text.PrecomputedText: String toString()>,NEITHER,NEITHER,"Returns a string representation of the object. In general the toString method returns a string that
 ""textually represents"" this object. The result should
 be a concise but informative representation that is easy for a
 person to read.
 It is recommended that all subclasses override this method. The toString method for class Object returns a string consisting of the name of the class of which the
 object is an instance the at-sign character ` @ ' and
 the unsigned hexadecimal representation of the hash code of the
 object. In other words this method returns a string equal to the
 value of:",,String a string representation of the object. |||,"A text which has the character metrics data.

 A text object that contains the character metrics data and can be used to improve the performance
 of text layout operations. When a PrecomputedText is created with a given  CharSequence 
 it will measure the text metrics during the creation. This PrecomputedText instance can be set on
  TextView  or  StaticLayout . Since the text layout information will
 be included in this instance  TextView  or  StaticLayout  will not
 have to recalculate this information.

 Note that the  PrecomputedText  created from different parameters of the target  TextView  will be rejected internally and compute the text layout again with the
 current  TextView  parameters.

  
 An example usage is:
  
  static void asyncSetText(TextView textView final String longString Executor bgExecutor) {
      // construct precompute related parameters using the TextView that we will set the text on.
      final PrecomputedText.Params params = textView.getTextMetricsParams();
      final Reference textViewRef = new WeakReference<>(textView);
      bgExecutor.submit(() -> {
          TextView textView = textViewRef.get();
          if (textView == null) return;
          final PrecomputedText precomputedText = PrecomputedText.create(longString params);
          textView.post(() -> {
              TextView textView = textViewRef.get();
              if (textView == null) return;
              textView.setText(precomputedText);
          });
      });
  }
  PrecomputedText TextView NoCopySpan","Provides classes used to render or track text and text spans on the screen. You can use these classes to design your own widgets that manage text
 to handle arbitrary text spans for changes or to handle drawing yourself
 for an existing widget. The Spanâ€¦ interfaces and classes are used to create or manage spans of
 text in a View item. You can use these to style the text or background or to
 listen for changes. If creating your own widget extend DynamicLayout to manages
 the actual wrapping and drawing of your text."
<android.view.textclassifier.TextLanguage: String toString()>,NEITHER,SOURCE,"Returns a string representation of the object. In general the toString method returns a string that
 ""textually represents"" this object. The result should
 be a concise but informative representation that is easy for a
 person to read.
 It is recommended that all subclasses override this method. The toString method for class Object returns a string consisting of the name of the class of which the
 object is an instance the at-sign character ` @ ' and
 the unsigned hexadecimal representation of the hash code of the
 object. In other words this method returns a string equal to the
 value of:",,String a string representation of the object. |||,"Represents the result of language detection of a piece of text.
  
 This contains a list of locales each paired with a confidence score sorted in decreasing
 order of those scores. E.g. for a given input text the model may return
  [<""en"" 0.85> <""fr"" 0.15>] . This sample result means the model reports that it is
 85% likely that the entire text is in English and 15% likely that the entire text is in French
 etc. It does not mean that 85% of the input is in English and 15% is in French.",
<android.graphics.fonts.Font: String toString()>,NEITHER,NEITHER,"Returns a string representation of the object. In general the toString method returns a string that
 ""textually represents"" this object. The result should
 be a concise but informative representation that is easy for a
 person to read.
 It is recommended that all subclasses override this method. The toString method for class Object returns a string consisting of the name of the class of which the
 object is an instance the at-sign character ` @ ' and
 the unsigned hexadecimal representation of the hash code of the
 object. In other words this method returns a string equal to the
 value of:",,String a string representation of the object. |||,A font class can be used for creating FontFamily.,
<android.telephony.AvailableNetworkInfo: String toString()>,SOURCE,SOURCE,"Returns a string representation of the object. In general the toString method returns a string that
 ""textually represents"" this object. The result should
 be a concise but informative representation that is easy for a
 person to read.
 It is recommended that all subclasses override this method. The toString method for class Object returns a string consisting of the name of the class of which the
 object is an instance the at-sign character ` @ ' and
 the unsigned hexadecimal representation of the hash code of the
 object. In other words this method returns a string equal to the
 value of:",,String a string representation of the object. |||,"Defines available network information which includes corresponding subscription id
 network plmns and corresponding priority to be used for network selection by Opportunistic
 Network Service when passed through  TelephonyManager#updateAvailableNetworks",
<android.system.StructTimeval: String toString()>,NEITHER,NEITHER,"Returns a string representation of the object. In general the toString method returns a string that
 ""textually represents"" this object. The result should
 be a concise but informative representation that is easy for a
 person to read.
 It is recommended that all subclasses override this method. The toString method for class Object returns a string consisting of the name of the class of which the
 object is an instance the at-sign character ` @ ' and
 the unsigned hexadecimal representation of the hash code of the
 object. In other words this method returns a string equal to the
 value of:",,String a string representation of the object. |||,Corresponds to C's  struct timeval  from  sys/time.h .,
<android.icu.text.Transliterator.Position: String toString()>,NEITHER,NEITHER,Returns a string representation of this Position.,,String a string representation of the object. |||,"Transliterator  is an abstract class that transliterates text from one format to another. The most common
 kind of transliterator is a script or alphabet transliterator. For example a Russian to Latin transliterator
 changes Russian text written in Cyrillic characters to phonetically equivalent Latin characters. It does not
  translate  Russian to English! Transliteration unlike translation operates on characters without reference
 to the meanings of words and sentences.

  
 Although script conversion is its most common use a transliterator can actually perform a more general class of
 tasks. In fact  Transliterator  defines a very general API which specifies only that a segment of the
 input text is replaced by new text. The particulars of this conversion are determined entirely by subclasses of
  Transliterator .

  Transliterators are stateless Transliterator  objects are  stateless ; they retain no information between calls to
  transliterate() . As a result threads may share transliterators without synchronizing them. This might
 seem to limit the complexity of the transliteration operation. In practice subclasses perform complex
 transliterations by delaying the replacement of text until it is known that no other replacements are possible. In
 other words although the  Transliterator  objects are stateless the source text itself embodies all the
 needed information and delayed operation allows arbitrary complexity.

  Batch transliteration 
 The simplest way to perform transliteration is all at once on a string of existing text. This is referred to as
  batch  transliteration. For example given a string  input  and a transliterator  t 
 the call

  String result = t.transliterate(input);
  Replaceable Keyboard transliteration 
 Somewhat more involved is  keyboard  or incremental transliteration. This is the transliteration of text that
 is arriving from some source (typically the user's keyboard) one character at a time or in some other piecemeal
 fashion.

  
 In keyboard transliteration a  Replaceable  buffer stores the text. As text is inserted as much as
 possible is transliterated on the fly. This means a GUI that displays the contents of the buffer may show text being
 modified as each new character arrives.

  
 Consider the simple rule-based Transliterator:

  
 th>{theta} 
 t>{tau}
  
 t>|{tau} 
 {tau}h>{theta}
  transliterate() 
 Keyboard transliteration methods maintain a set of three indices that are updated with each call to
  transliterate()  including the cursor start and limit. These indices are changed by the method and
 they are passed in and out via a Position object. The  start  index marks the beginning of the substring
 that the transliterator will look at. It is advanced as text becomes committed (but it is not the committed index;
 that's the  cursor ). The  cursor  index described above marks the point at which the
 transliterator last stopped either because it reached the end or because it required more characters to
 disambiguate between possible inputs. The  cursor  can also be explicitly set by rules.
 Any characters before the  cursor  index are frozen; future keyboard
 transliteration calls within this input sequence will not change them. New text is inserted at the  limit 
 index which marks the end of the substring that the transliterator looks at.

  
 Because keyboard transliteration assumes that more characters are to arrive it is conservative in its operation. It
 only transliterates when it can do so unambiguously. Otherwise it waits for more characters to arrive. When the
 client code knows that no more characters are forthcoming perhaps because the user has performed some input
 termination operation then it should call  finishTransliteration()  to complete any pending
 transliterations.

  Inverses 
 Pairs of transliterators may be inverses of one another. For example if transliterator  A  transliterates
 characters by incrementing their Unicode value (so ""abc"" -> ""def"") and transliterator  B  decrements character
 values then  A  is an inverse of  B  and vice versa. If we compose  A  with  B  in a compound
 transliterator the result is the indentity transliterator that is a transliterator that does not change its input
 text.

 The  Transliterator  method  getInverse()  returns a transliterator's inverse if one exists
 or  null  otherwise. However the result of  getInverse()  usually will  not  be a true
 mathematical inverse. This is because true inverse transliterators are difficult to formulate. For example consider
 two transliterators:  AB  which transliterates the character 'A' to 'B' and  BA  which transliterates
 'B' to 'A'. It might seem that these are exact inverses since

  ""A"" x  AB  -> ""B"" 
 ""B"" x  BA  -> ""A"" ""ABCD"" x  AB  -> ""BBCD"" 
 ""BBCD"" x  BA  -> ""AACD"" AB BA BA AB AB .getInverse() BA Filtering Each transliterator has a filter which restricts changes to those characters selected by the filter. The
 filter affects just the characters that are changed -- the characters outside of the filter are still part of the
 context for the filter. For example in the following even though 'x' is filtered out and doesn't convert to y it does affect the conversion of 'a'.

  
 String rules = ""x > y; x{a} > b; "";
 Transliterator tempTrans = Transliterator.createFromRules(""temp"" rules Transliterator.FORWARD);
 tempTrans.setFilter(new UnicodeSet(""[a]""));
 String tempResult = tempTrans.transform(""xa"");
 // results in ""xb""
 IDs and display names 
 A transliterator is designated by a short identifier string or  ID . IDs follow the format
  source-destination  where  source  describes the entity being replaced and  destination 
 describes the entity replacing  source . The entities may be the names of scripts particular sequences of
 characters or whatever else it is that the transliterator converts to or from. For example a transliterator from
 Russian to Latin might be named ""Russian-Latin"". A transliterator from keyboard escape sequences to Latin-1
 characters might be named ""KeyboardEscape-Latin1"". By convention system entity names are in English with the
 initial letters of words capitalized; user entity names may follow any format so long as they do not contain dashes.

  
 In addition to programmatic IDs transliterator objects have display names for presentation in user interfaces
 returned by  getDisplayName(String) .

  Composed transliterators 
 In addition to built-in system transliterators like ""Latin-Greek"" there are also built-in  composed 
 transliterators. These are implemented by composing two or more component transliterators. For example if we have
 scripts ""A"" ""B"" ""C"" and ""D"" and we want to transliterate between all pairs of them then we need to write 12
 transliterators: ""A-B"" ""A-C"" ""A-D"" ""B-A""... ""D-A"" ""D-B"" ""D-C"". If it is possible to convert all scripts to an
 intermediate script ""M"" then instead of writing 12 rule sets we only need to write 8: ""A~M"" ""B~M"" ""C~M"" ""D~M""
 ""M~A"" ""M~B"" ""M~C"" ""M~D"". (This might not seem like a big win but it's really 2 n  vs.  n 2  -  n  so as  n  gets larger the gain becomes significant. With 9 scripts it's 18 vs. 72
 rule sets a big difference.) Note the use of ""~"" rather than ""-"" for the script separator here; this indicates that
 the given transliterator is intended to be composed with others rather than be used as is.

  
 Composed transliterators can be instantiated as usual. For example the system transliterator ""Devanagari-Gujarati""
 is a composed transliterator built internally as ""Devanagari~InterIndic;InterIndic~Gujarati"". When this
 transliterator is instantiated it appears externally to be a standard transliterator (e.g. getID() returns
 ""Devanagari-Gujarati"").

  Rule syntax A set of rules determines how to perform translations.
 Rules within a rule set are separated by semicolons (';').
 To include a literal semicolon prefix it with a backslash ('\').
 Unicode Pattern_White_Space is ignored.
 If the first non-blank character on a line is '#'
 the entire line is ignored as a comment.

  Each set of rules consists of two groups one forward and one
 reverse. This is a convention that is not enforced; rules for one
 direction may be omitted with the result that translations in
 that direction will not modify the source text. In addition
 bidirectional forward-reverse rules may be specified for
 symmetrical transformations.

  Note: Another description of the Transliterator rule syntax is available in
  section
 Transform Rules Syntax of UTS #35: Unicode LDML .
 The rules are shown there using arrow symbols â† and â†’ and â†”.
 ICU supports both those and the equivalent ASCII symbols < and > and <>.

  Rule statements take one of the following forms:

  $alefmadda=\\u0622; Variable definition.  The name on the
         left is assigned the text on the right. In this example
         after this statement instances of the left hand name
         "" $alefmadda "" will be replaced by
         the Unicode character U+0622. Variable names must begin
         with a letter and consist only of letters digits and
         underscores. Case is significant. Duplicate names cause
         an exception to be thrown that is variables cannot be
         redefined. The right hand side may contain well-formed
         text of any length including no text at all ("" $empty=; "").
         The right hand side may contain embedded  UnicodeSet 
         patterns for example "" $softvowel=[eiyEIY] "". ai>$alefmadda; Forward translation rule.  This rule
         states that the string on the left will be changed to the
         string on the right when performing forward
         transliteration. ai<$alefmadda; Reverse translation rule.  This rule
         states that the string on the right will be changed to
         the string on the left when performing reverse
         transliteration. ai<>$alefmadda; Bidirectional translation rule.  This
         rule states that the string on the right will be changed
         to the string on the left when performing forward
         transliteration and vice versa when performing reverse
         transliteration. Translation rules consist of a  match pattern  and an  output
 string . The match pattern consists of literal characters
 optionally preceded by context and optionally followed by
 context. Context characters like literal pattern characters
 must be matched in the text being transliterated. However unlike
 literal pattern characters they are not replaced by the output
 text. For example the pattern "" abc{def} ""
 indicates the characters "" def "" must be
 preceded by "" abc "" for a successful match.
 If there is a successful match "" def "" will
 be replaced but not "" abc "". The final ' } '
 is optional so "" abc{def "" is equivalent to
 "" abc{def} "". Another example is "" {123}456 ""
 (or "" 123}456 "") in which the literal
 pattern "" 123 "" must be followed by "" 456 "".

  The output string of a forward or reverse rule consists of
 characters to replace the literal pattern characters. If the
 output string contains the character ' | ' this is
 taken to indicate the location of the  cursor  after
 replacement. The cursor is the point in the text at which the
 next replacement if any will be applied. The cursor is usually
 placed within the replacement text; however it can actually be
 placed into the precending or following context by using the
 special character '@'. Examples:

  
     a {foo} z > | @ bar; # foo -> bar move cursor before a
     {foo} xyz > bar @@|; #Â foo -> bar cursor between y and z
  UnicodeSet UnicodeSet  patterns may appear anywhere that
 makes sense. They may appear in variable definitions.
 Contrariwise  UnicodeSet  patterns may themselves
 contain variable references such as "" $a=[a-z];$not_a=[^$a] ""
 or "" $range=a-z;$ll=[$range] "".

  UnicodeSet  patterns may also be embedded directly
 into rule strings. Thus the following two rules are equivalent:

  
     $vowel=[aeiou]; $vowel>'*'; # One way to do this
     [aeiou]>'*'; # Another way
  See  UnicodeSet  for more documentation and examples.

  Segments Segments of the input string can be matched and copied to the
 output string. This makes certain sets of rules simpler and more
 general and makes reordering possible. For example:

  
     ([a-z]) > $1 $1; # double lowercase letters
     ([:Lu:]) ([:Ll:]) > $2 $1; # reverse order of Lu-Ll pairs
  The segment of the input string to be copied is delimited by
 "" ( "" and "" ) "". Up to
 nine segments may be defined. Segments may not overlap. In the
 output string "" $1 "" through "" $9 ""
 represent the input string segments in left-to-right order of
 definition.

  Anchors Patterns can be anchored to the beginning or the end of the text. This is done with the
 special characters ' ^ ' and ' $ '. For example:

  
   ^ aÂ Â  > 'BEG_A'; Â Â # match 'a' at start of text
   Â  aÂ Â  > 'A'; # match other instances of 'a'
   Â  z $ > 'END_Z'; Â Â # match 'z' at end of text
   Â  zÂ Â  > 'Z';Â Â Â Â Â Â  # match other instances of 'z'
  It is also possible to match the beginning or the end of the text using a  UnicodeSet .
 This is done by including a virtual anchor character ' $ ' at the end of the
 set pattern. Although this is usually the match chafacter for the end anchor the set will
 match either the beginning or the end of the text depending on its placement. For
 example:

  
   $x = [a-z$]; Â Â # match 'a' through 'z' OR anchor
   $x 1Â Â Â  > 2;Â Â  # match '1' after a-z or at the start
   Â Â  3 $x > 4; Â Â # match '3' before a-z or at the end
  Example The following example rules illustrate many of the features of
 the rule language.

  Rule 1. abc{def}>x|y Rule 2. xyz>r Rule 3. yz>q Applying these rules to the string "" adefabcdefz ""
 yields the following results:

  |adefabcdefz Initial state no rules match. Advance
         cursor. a|defabcdefz Still no match. Rule 1 does not match
         because the preceding context is not present. ad|efabcdefz Still no match. Keep advancing until
         there is a match... ade|fabcdefz ... adef|abcdefz ... adefa|bcdefz ... adefab|cdefz ... adefabc|defz Rule 1 matches; replace "" def ""
         with "" xy "" and back up the cursor
         to before the ' y '. adefabcx|yz Although "" xyz "" is
         present rule 2 does not match because the cursor is
         before the ' y ' not before the ' x '.
         Rule 3 does match. Replace "" yz ""
         with "" q "". adefabcxq| The cursor is at the end;
         transliteration is complete. The order of rules is significant. If multiple rules may match
 at some point the first matching rule is applied.

  Forward and reverse rules may have an empty output string.
 Otherwise an empty left or right hand side of any statement is a
 syntax error.

  Single quotes are used to quote any character other than a
 digit or letter. To specify a single quote itself inside or
 outside of quotes use two single quotes in a row. For example
 the rule "" '>'>o''clock "" changes the
 string "" > "" to the string "" o'clock "".

  Notes While a Transliterator is being built from rules it checks that
 the rules are added in proper order. For example if the rule
 ""a>x"" is followed by the rule ""ab>y""
 then the second rule will throw an exception. The reason is that
 the second rule can never be triggered since the first rule
 always matches anything it matches. In other words the first
 rule  masks  the second rule.",
<android.service.autofill.BatchUpdates: String toString()>,NEITHER,NEITHER,"Returns a string representation of the object. In general the toString method returns a string that
 ""textually represents"" this object. The result should
 be a concise but informative representation that is easy for a
 person to read.
 It is recommended that all subclasses override this method. The toString method for class Object returns a string consisting of the name of the class of which the
 object is an instance the at-sign character ` @ ' and
 the unsigned hexadecimal representation of the hash code of the
 object. In other words this method returns a string equal to the
 value of:",,String a string representation of the object. |||,"Defines actions to be applied to a  RemoteViews .


  It supports 2 types of actions:

  RemoteViews  to be applied to the template.
    Transformation  to be applied on child views.
  Typically used on  CustomDescription  to conditionally display
 differents views based on user input - see
  CustomDescription.Builder#batchUpdate(Validator BatchUpdates)  for more information.",
<android.media.audiofx.DynamicsProcessing.Limiter: String toString()>,NEITHER,NEITHER,"Returns a string representation of the object. In general the toString method returns a string that
 ""textually represents"" this object. The result should
 be a concise but informative representation that is easy for a
 person to read.
 It is recommended that all subclasses override this method. The toString method for class Object returns a string consisting of the name of the class of which the
 object is an instance the at-sign character ` @ ' and
 the unsigned hexadecimal representation of the hash code of the
 object. In other words this method returns a string equal to the
 value of:",,String a string representation of the object. |||,"Class for Limiter Stage
 Limiter is a single band compressor at the end of the processing chain commonly used to
 protect the signal from overloading and distortion. Limiters have multiple controllable
 parameters: enabled/disabled linkGroup attackTime releaseTime ratio threshold and
 postGain.
  Limiters can be linked in groups across multiple channels. Linked limiters will trigger
 the same limiting if any of the linked limiters starts compressing.","The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager )."
<android.app.slice.SliceSpec: String toString()>,NEITHER,NEITHER,"Returns a string representation of the object. In general the toString method returns a string that
 ""textually represents"" this object. The result should
 be a concise but informative representation that is easy for a
 person to read.
 It is recommended that all subclasses override this method. The toString method for class Object returns a string consisting of the name of the class of which the
 object is an instance the at-sign character ` @ ' and
 the unsigned hexadecimal representation of the hash code of the
 object. In other words this method returns a string equal to the
 value of:",,String a string representation of the object. |||,"Class describing the structure of the data contained within a slice.
  
 A data version contains a string which describes the type of structure
 and a revision which denotes this specific implementation. Revisions are expected
 to be backwards compatible and monotonically increasing. Meaning if a
 SliceSpec has the same type and an equal or lesser revision
 it is expected to be compatible.
  
 Apps rendering slices will provide a list of supported versions to the OS which
 will also be given to the app. Apps should only return a  Slice  with a
  SliceSpec  that one of the supported  SliceSpec s provided
  canRender(SliceSpec) .","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 designâ€”especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activityâ€”allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User ."
<android.media.MediaSession2.ControllerInfo: String toString()>,NEITHER,NEITHER,"Returns a string representation of the object. In general the toString method returns a string that
 ""textually represents"" this object. The result should
 be a concise but informative representation that is easy for a
 person to read.
 It is recommended that all subclasses override this method. The toString method for class Object returns a string consisting of the name of the class of which the
 object is an instance the at-sign character ` @ ' and
 the unsigned hexadecimal representation of the hash code of the
 object. In other words this method returns a string equal to the
 value of:",,String This value will never be null . |||,"This API is not generally intended for third party application developers.
 Use the  AndroidX Media2 session
 Library  for consistent behavior across all devices.
  
 Information of a controller.","The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager )."
<android.content.LocusId: String toString()>,NEITHER,SOURCE,"Returns a string representation of the object. In general the toString method returns a string that
 ""textually represents"" this object. The result should
 be a concise but informative representation that is easy for a
 person to read.
 It is recommended that all subclasses override this method. The toString method for class Object returns a string consisting of the name of the class of which the
 object is an instance the at-sign character ` @ ' and
 the unsigned hexadecimal representation of the hash code of the
 object. In other words this method returns a string equal to the
 value of:",,String a string representation of the object. |||,"An identifier for an unique state (locus) in the application. Should be stable across reboots and
 backup / restore.

  Locus is a new concept introduced on
  Android Q  and it lets the Android system correlate
 state between different subsystems such as content capture shortcuts and notifications.

  For example if your app provides an activiy representing a chat between 2 users
 (say  A  and  B  this chat state could be represented by:

  
 LocusId chatId = new LocusId(""Chat_A_B"");
  And then you should use that  chatId  by:

  Setting it in the chat notification (through
    Notification.Builder.setLocusId(chatId) ).
    Setting it into the  ShortcutInfo  (through
    ShortcutInfo.Builder.setLocusId(chatId) ) if you provide a launcher shortcut for that chat
   conversation.
    Associating it with the  ContentCaptureContext  of the
   root view of the chat conversation activity (through
    View.getContentCaptureSession()  then
    new ContentCaptureContext.Builder(chatId).build()  and
    ContentCaptureSession.setContentCaptureContext(android.view.contentcapture.ContentCaptureContext)  - see  ContentCaptureManager 
   for more info about content capture).
    Configuring your app to launch the chat conversation through the
    Intent#ACTION_VIEW_LOCUS  intent.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application componentsâ€”allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources ."
<android.graphics.Insets: String toString()>,NEITHER,NEITHER,"Returns a string representation of the object. In general the toString method returns a string that
 ""textually represents"" this object. The result should
 be a concise but informative representation that is easy for a
 person to read.
 It is recommended that all subclasses override this method. The toString method for class Object returns a string consisting of the name of the class of which the
 object is an instance the at-sign character ` @ ' and
 the unsigned hexadecimal representation of the hash code of the
 object. In other words this method returns a string equal to the
 value of:",,String a string representation of the object. |||,"An Insets instance holds four integer offsets which describe changes to the four
 edges of a Rectangle. By convention positive values move edges towards the
 centre of the rectangle.
  
 Insets are immutable so may be treated as values.",
<android.net.wifi.aware.WifiAwareNetworkInfo: String toString()>,SOURCE,SOURCE,"Returns a string representation of the object. In general the toString method returns a string that
 ""textually represents"" this object. The result should
 be a concise but informative representation that is easy for a
 person to read.
 It is recommended that all subclasses override this method. The toString method for class Object returns a string consisting of the name of the class of which the
 object is an instance the at-sign character ` @ ' and
 the unsigned hexadecimal representation of the hash code of the
 object. In other words this method returns a string equal to the
 value of:",,String a string representation of the object. |||,"Wi-Fi Aware-specific network information. The information can be extracted from the
  NetworkCapabilities  of the network using
  NetworkCapabilities#getTransportInfo() .
 The  NetworkCapabilities  is provided by the connectivity service to apps e.g. received
 through the
  ConnectivityManager.NetworkCallback.onCapabilitiesChanged(android.net.Network android.net.NetworkCapabilities)  callback.
  
 The Wi-Fi Aware-specific network information include the peer's scoped link-local IPv6 address
 for the Wi-Fi Aware link as well as (optionally) the port and transport protocol specified by
 the peer.
 The scoped link-local IPv6 port and transport protocol can then be used to create a
  Socket  connection to the peer.
  
 Note: these are the peer's IPv6 and port information - not the local device's!","Provides classes to manage Wi-Fi functionality on the device. The Wi-Fi APIs provide a means by which applications can communicate
 with the lower-level wireless stack that provides Wi-Fi network access. Almost all
 information from the device supplicant is available including the connected network's
 link speed IP address negotiation state and more plus information about other
 networks that are available. Some other API features include the ability to
 scan add save terminate and initiate Wi-Fi connections. Some APIs may require the following user permissions: ACCESS_WIFI_STATE CHANGE_WIFI_STATE CHANGE_WIFI_MULTICAST_STATE Note:  Not all Android-powered devices provide Wi-Fi functionality.
 If your application uses Wi-Fi declare so with a  <uses-feature> 
 element in the manifest file: 
 <manifest ...>
     <uses-feature android:name=""android.hardware.wifi"" />
     ...
 </manifest>"
<android.service.autofill.CustomDescription: String toString()>,NEITHER,NEITHER,"Returns a string representation of the object. In general the toString method returns a string that
 ""textually represents"" this object. The result should
 be a concise but informative representation that is easy for a
 person to read.
 It is recommended that all subclasses override this method. The toString method for class Object returns a string consisting of the name of the class of which the
 object is an instance the at-sign character ` @ ' and
 the unsigned hexadecimal representation of the hash code of the
 object. In other words this method returns a string equal to the
 value of:",,String a string representation of the object. |||,"Defines a custom description for the autofill save UI.

  This is useful when the autofill service needs to show a detailed view of what would be saved;
 for example when the screen contains a credit card it could display a logo of the credit card
 bank the last four digits of the credit card number and its expiration number.

  A custom description is made of 2 parts:
  A  RemoteViews  containing children views.
    Transformation  to populate the children views.
  For the credit card example mentioned above the (simplified) template would be:

  
 <LinearLayout>
   <ImageView android:id=""@+id/templateccLogo""/>
   <TextView android:id=""@+id/templateCcNumber""/>
   <TextView android:id=""@+id/templateExpDate""/>
 </LinearLayout>
  Which in code translates to:

  
   CustomDescription.Builder buider = new Builder(new RemoteViews(pgkName R.layout.cc_template);
  Then the value of each of the 3 children would be changed at runtime based on the the value of
 the screen fields and the  Transformation :

  
 // Image child - different logo for each bank based on credit card prefix
 builder.addChild(R.id.templateccLogo
   new ImageTransformation.Builder(ccNumberId)
     .addOption(Pattern.compile(""^4815.*$"") R.drawable.ic_credit_card_logo1)
     .addOption(Pattern.compile(""^1623.*$"") R.drawable.ic_credit_card_logo2)
     .addOption(Pattern.compile(""^42.*$"") R.drawable.ic_credit_card_logo3)
     .build();
 // Masked credit card number (as .....LAST_4_DIGITS)
 builder.addChild(R.id.templateCcNumber new CharSequenceTransformation
     .Builder(ccNumberId Pattern.compile(""^.*(\\d\\d\\d\\d)$"") ""...$1"")
     .build();
 // Expiration date as MM / YYYY:
 builder.addChild(R.id.templateExpDate new CharSequenceTransformation
     .Builder(ccExpMonthId Pattern.compile(""^(\\d\\d)$"") ""Exp: $1"")
     .addField(ccExpYearId Pattern.compile(""^(\\d\\d)$"") ""/$1"")
     .build();
  See  ImageTransformation   CharSequenceTransformation  for more info about these
 transformations.",
<android.net.wifi.WifiNetworkSpecifier: String toString()>,SOURCE,SOURCE,"Returns a string representation of the object. In general the toString method returns a string that
 ""textually represents"" this object. The result should
 be a concise but informative representation that is easy for a
 person to read.
 It is recommended that all subclasses override this method. The toString method for class Object returns a string consisting of the name of the class of which the
 object is an instance the at-sign character ` @ ' and
 the unsigned hexadecimal representation of the hash code of the
 object. In other words this method returns a string equal to the
 value of:",,String a string representation of the object. |||,"Network specifier object used to request a local Wi-Fi network. Apps should use the
  WifiNetworkSpecifier.Builder  class to create an instance.","Provides classes to manage Wi-Fi functionality on the device. The Wi-Fi APIs provide a means by which applications can communicate
 with the lower-level wireless stack that provides Wi-Fi network access. Almost all
 information from the device supplicant is available including the connected network's
 link speed IP address negotiation state and more plus information about other
 networks that are available. Some other API features include the ability to
 scan add save terminate and initiate Wi-Fi connections. Some APIs may require the following user permissions: ACCESS_WIFI_STATE CHANGE_WIFI_STATE CHANGE_WIFI_MULTICAST_STATE Note:  Not all Android-powered devices provide Wi-Fi functionality.
 If your application uses Wi-Fi declare so with a  <uses-feature> 
 element in the manifest file: 
 <manifest ...>
     <uses-feature android:name=""android.hardware.wifi"" />
     ...
 </manifest>"
<android.view.textclassifier.TextClassificationContext: String toString()>,NEITHER,NEITHER,"Returns a string representation of the object. In general the toString method returns a string that
 ""textually represents"" this object. The result should
 be a concise but informative representation that is easy for a
 person to read.
 It is recommended that all subclasses override this method. The toString method for class Object returns a string consisting of the name of the class of which the
 object is an instance the at-sign character ` @ ' and
 the unsigned hexadecimal representation of the hash code of the
 object. In other words this method returns a string equal to the
 value of:",,String a string representation of the object. |||,A representation of the context in which text classification would be performed.,
<android.view.textclassifier.SelectionEvent: String toString()>,NEITHER,SOURCE,"Returns a string representation of the object. In general the toString method returns a string that
 ""textually represents"" this object. The result should
 be a concise but informative representation that is easy for a
 person to read.
 It is recommended that all subclasses override this method. The toString method for class Object returns a string consisting of the name of the class of which the
 object is an instance the at-sign character ` @ ' and
 the unsigned hexadecimal representation of the hash code of the
 object. In other words this method returns a string equal to the
 value of:",,String a string representation of the object. |||,"A selection event.
 Specify index parameters as word token indices.",
<android.telephony.CellInfoTdscdma: String toString()>,SOURCE,SOURCE,"Returns a string representation of the object. In general the toString method returns a string that
 ""textually represents"" this object. The result should
 be a concise but informative representation that is easy for a
 person to read.
 It is recommended that all subclasses override this method. The toString method for class Object returns a string consisting of the name of the class of which the
 object is an instance the at-sign character ` @ ' and
 the unsigned hexadecimal representation of the hash code of the
 object. In other words this method returns a string equal to the
 value of:",,String a string representation of the object. |||,A  CellInfo  representing a TD-SCDMA cell that provides identity and measurement info.,
"<android.media.Session2Command: void writeToParcel(Parcel,int)>",NEITHER,NEITHER,Flatten this object in to a Parcel.,"dest Parcel : This value must never be null . |||
flags int : Additional flags about how the object should be written.
May be 0 or Parcelable.PARCELABLE_WRITE_RETURN_VALUE .
Value is either 0 or a combination of Parcelable.PARCELABLE_WRITE_RETURN_VALUE and android.os.Parcelable.PARCELABLE_ELIDE_DUPLICATES |||",void,"This API is not generally intended for third party application developers.
 Use the  AndroidX Media2 session
 Library  for consistent behavior across all devices.
  
 Define a command that a  MediaController2  can send to a  MediaSession2 .
  
 If  getCommandCode()  isn't  COMMAND_CODE_CUSTOM ) it's predefined command.
 If  getCommandCode()  is  COMMAND_CODE_CUSTOM ) it's custom command and
  getCustomAction()  shouldn't be  null .
  
 Refer to the
  AndroidX SessionCommand 
 class for the list of valid commands.","The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager )."
<android.icu.text.Transliterator: String transliterate(String)>,NEITHER,NEITHER,Transliterate an entire string and returns the result. Convenience method.,text String : the string to be transliterated |||,String The transliterated text |||,"Transliterator  is an abstract class that transliterates text from one format to another. The most common
 kind of transliterator is a script or alphabet transliterator. For example a Russian to Latin transliterator
 changes Russian text written in Cyrillic characters to phonetically equivalent Latin characters. It does not
  translate  Russian to English! Transliteration unlike translation operates on characters without reference
 to the meanings of words and sentences.

  
 Although script conversion is its most common use a transliterator can actually perform a more general class of
 tasks. In fact  Transliterator  defines a very general API which specifies only that a segment of the
 input text is replaced by new text. The particulars of this conversion are determined entirely by subclasses of
  Transliterator .

  Transliterators are stateless Transliterator  objects are  stateless ; they retain no information between calls to
  transliterate() . As a result threads may share transliterators without synchronizing them. This might
 seem to limit the complexity of the transliteration operation. In practice subclasses perform complex
 transliterations by delaying the replacement of text until it is known that no other replacements are possible. In
 other words although the  Transliterator  objects are stateless the source text itself embodies all the
 needed information and delayed operation allows arbitrary complexity.

  Batch transliteration 
 The simplest way to perform transliteration is all at once on a string of existing text. This is referred to as
  batch  transliteration. For example given a string  input  and a transliterator  t 
 the call

  String result = t.transliterate(input);
  Replaceable Keyboard transliteration 
 Somewhat more involved is  keyboard  or incremental transliteration. This is the transliteration of text that
 is arriving from some source (typically the user's keyboard) one character at a time or in some other piecemeal
 fashion.

  
 In keyboard transliteration a  Replaceable  buffer stores the text. As text is inserted as much as
 possible is transliterated on the fly. This means a GUI that displays the contents of the buffer may show text being
 modified as each new character arrives.

  
 Consider the simple rule-based Transliterator:

  
 th>{theta} 
 t>{tau}
  
 t>|{tau} 
 {tau}h>{theta}
  transliterate() 
 Keyboard transliteration methods maintain a set of three indices that are updated with each call to
  transliterate()  including the cursor start and limit. These indices are changed by the method and
 they are passed in and out via a Position object. The  start  index marks the beginning of the substring
 that the transliterator will look at. It is advanced as text becomes committed (but it is not the committed index;
 that's the  cursor ). The  cursor  index described above marks the point at which the
 transliterator last stopped either because it reached the end or because it required more characters to
 disambiguate between possible inputs. The  cursor  can also be explicitly set by rules.
 Any characters before the  cursor  index are frozen; future keyboard
 transliteration calls within this input sequence will not change them. New text is inserted at the  limit 
 index which marks the end of the substring that the transliterator looks at.

  
 Because keyboard transliteration assumes that more characters are to arrive it is conservative in its operation. It
 only transliterates when it can do so unambiguously. Otherwise it waits for more characters to arrive. When the
 client code knows that no more characters are forthcoming perhaps because the user has performed some input
 termination operation then it should call  finishTransliteration()  to complete any pending
 transliterations.

  Inverses 
 Pairs of transliterators may be inverses of one another. For example if transliterator  A  transliterates
 characters by incrementing their Unicode value (so ""abc"" -> ""def"") and transliterator  B  decrements character
 values then  A  is an inverse of  B  and vice versa. If we compose  A  with  B  in a compound
 transliterator the result is the indentity transliterator that is a transliterator that does not change its input
 text.

 The  Transliterator  method  getInverse()  returns a transliterator's inverse if one exists
 or  null  otherwise. However the result of  getInverse()  usually will  not  be a true
 mathematical inverse. This is because true inverse transliterators are difficult to formulate. For example consider
 two transliterators:  AB  which transliterates the character 'A' to 'B' and  BA  which transliterates
 'B' to 'A'. It might seem that these are exact inverses since

  ""A"" x  AB  -> ""B"" 
 ""B"" x  BA  -> ""A"" ""ABCD"" x  AB  -> ""BBCD"" 
 ""BBCD"" x  BA  -> ""AACD"" AB BA BA AB AB .getInverse() BA Filtering Each transliterator has a filter which restricts changes to those characters selected by the filter. The
 filter affects just the characters that are changed -- the characters outside of the filter are still part of the
 context for the filter. For example in the following even though 'x' is filtered out and doesn't convert to y it does affect the conversion of 'a'.

  
 String rules = ""x > y; x{a} > b; "";
 Transliterator tempTrans = Transliterator.createFromRules(""temp"" rules Transliterator.FORWARD);
 tempTrans.setFilter(new UnicodeSet(""[a]""));
 String tempResult = tempTrans.transform(""xa"");
 // results in ""xb""
 IDs and display names 
 A transliterator is designated by a short identifier string or  ID . IDs follow the format
  source-destination  where  source  describes the entity being replaced and  destination 
 describes the entity replacing  source . The entities may be the names of scripts particular sequences of
 characters or whatever else it is that the transliterator converts to or from. For example a transliterator from
 Russian to Latin might be named ""Russian-Latin"". A transliterator from keyboard escape sequences to Latin-1
 characters might be named ""KeyboardEscape-Latin1"". By convention system entity names are in English with the
 initial letters of words capitalized; user entity names may follow any format so long as they do not contain dashes.

  
 In addition to programmatic IDs transliterator objects have display names for presentation in user interfaces
 returned by  getDisplayName(String) .

  Composed transliterators 
 In addition to built-in system transliterators like ""Latin-Greek"" there are also built-in  composed 
 transliterators. These are implemented by composing two or more component transliterators. For example if we have
 scripts ""A"" ""B"" ""C"" and ""D"" and we want to transliterate between all pairs of them then we need to write 12
 transliterators: ""A-B"" ""A-C"" ""A-D"" ""B-A""... ""D-A"" ""D-B"" ""D-C"". If it is possible to convert all scripts to an
 intermediate script ""M"" then instead of writing 12 rule sets we only need to write 8: ""A~M"" ""B~M"" ""C~M"" ""D~M""
 ""M~A"" ""M~B"" ""M~C"" ""M~D"". (This might not seem like a big win but it's really 2 n  vs.  n 2  -  n  so as  n  gets larger the gain becomes significant. With 9 scripts it's 18 vs. 72
 rule sets a big difference.) Note the use of ""~"" rather than ""-"" for the script separator here; this indicates that
 the given transliterator is intended to be composed with others rather than be used as is.

  
 Composed transliterators can be instantiated as usual. For example the system transliterator ""Devanagari-Gujarati""
 is a composed transliterator built internally as ""Devanagari~InterIndic;InterIndic~Gujarati"". When this
 transliterator is instantiated it appears externally to be a standard transliterator (e.g. getID() returns
 ""Devanagari-Gujarati"").

  Rule syntax A set of rules determines how to perform translations.
 Rules within a rule set are separated by semicolons (';').
 To include a literal semicolon prefix it with a backslash ('\').
 Unicode Pattern_White_Space is ignored.
 If the first non-blank character on a line is '#'
 the entire line is ignored as a comment.

  Each set of rules consists of two groups one forward and one
 reverse. This is a convention that is not enforced; rules for one
 direction may be omitted with the result that translations in
 that direction will not modify the source text. In addition
 bidirectional forward-reverse rules may be specified for
 symmetrical transformations.

  Note: Another description of the Transliterator rule syntax is available in
  section
 Transform Rules Syntax of UTS #35: Unicode LDML .
 The rules are shown there using arrow symbols â† and â†’ and â†”.
 ICU supports both those and the equivalent ASCII symbols < and > and <>.

  Rule statements take one of the following forms:

  $alefmadda=\\u0622; Variable definition.  The name on the
         left is assigned the text on the right. In this example
         after this statement instances of the left hand name
         "" $alefmadda "" will be replaced by
         the Unicode character U+0622. Variable names must begin
         with a letter and consist only of letters digits and
         underscores. Case is significant. Duplicate names cause
         an exception to be thrown that is variables cannot be
         redefined. The right hand side may contain well-formed
         text of any length including no text at all ("" $empty=; "").
         The right hand side may contain embedded  UnicodeSet 
         patterns for example "" $softvowel=[eiyEIY] "". ai>$alefmadda; Forward translation rule.  This rule
         states that the string on the left will be changed to the
         string on the right when performing forward
         transliteration. ai<$alefmadda; Reverse translation rule.  This rule
         states that the string on the right will be changed to
         the string on the left when performing reverse
         transliteration. ai<>$alefmadda; Bidirectional translation rule.  This
         rule states that the string on the right will be changed
         to the string on the left when performing forward
         transliteration and vice versa when performing reverse
         transliteration. Translation rules consist of a  match pattern  and an  output
 string . The match pattern consists of literal characters
 optionally preceded by context and optionally followed by
 context. Context characters like literal pattern characters
 must be matched in the text being transliterated. However unlike
 literal pattern characters they are not replaced by the output
 text. For example the pattern "" abc{def} ""
 indicates the characters "" def "" must be
 preceded by "" abc "" for a successful match.
 If there is a successful match "" def "" will
 be replaced but not "" abc "". The final ' } '
 is optional so "" abc{def "" is equivalent to
 "" abc{def} "". Another example is "" {123}456 ""
 (or "" 123}456 "") in which the literal
 pattern "" 123 "" must be followed by "" 456 "".

  The output string of a forward or reverse rule consists of
 characters to replace the literal pattern characters. If the
 output string contains the character ' | ' this is
 taken to indicate the location of the  cursor  after
 replacement. The cursor is the point in the text at which the
 next replacement if any will be applied. The cursor is usually
 placed within the replacement text; however it can actually be
 placed into the precending or following context by using the
 special character '@'. Examples:

  
     a {foo} z > | @ bar; # foo -> bar move cursor before a
     {foo} xyz > bar @@|; #Â foo -> bar cursor between y and z
  UnicodeSet UnicodeSet  patterns may appear anywhere that
 makes sense. They may appear in variable definitions.
 Contrariwise  UnicodeSet  patterns may themselves
 contain variable references such as "" $a=[a-z];$not_a=[^$a] ""
 or "" $range=a-z;$ll=[$range] "".

  UnicodeSet  patterns may also be embedded directly
 into rule strings. Thus the following two rules are equivalent:

  
     $vowel=[aeiou]; $vowel>'*'; # One way to do this
     [aeiou]>'*'; # Another way
  See  UnicodeSet  for more documentation and examples.

  Segments Segments of the input string can be matched and copied to the
 output string. This makes certain sets of rules simpler and more
 general and makes reordering possible. For example:

  
     ([a-z]) > $1 $1; # double lowercase letters
     ([:Lu:]) ([:Ll:]) > $2 $1; # reverse order of Lu-Ll pairs
  The segment of the input string to be copied is delimited by
 "" ( "" and "" ) "". Up to
 nine segments may be defined. Segments may not overlap. In the
 output string "" $1 "" through "" $9 ""
 represent the input string segments in left-to-right order of
 definition.

  Anchors Patterns can be anchored to the beginning or the end of the text. This is done with the
 special characters ' ^ ' and ' $ '. For example:

  
   ^ aÂ Â  > 'BEG_A'; Â Â # match 'a' at start of text
   Â  aÂ Â  > 'A'; # match other instances of 'a'
   Â  z $ > 'END_Z'; Â Â # match 'z' at end of text
   Â  zÂ Â  > 'Z';Â Â Â Â Â Â  # match other instances of 'z'
  It is also possible to match the beginning or the end of the text using a  UnicodeSet .
 This is done by including a virtual anchor character ' $ ' at the end of the
 set pattern. Although this is usually the match chafacter for the end anchor the set will
 match either the beginning or the end of the text depending on its placement. For
 example:

  
   $x = [a-z$]; Â Â # match 'a' through 'z' OR anchor
   $x 1Â Â Â  > 2;Â Â  # match '1' after a-z or at the start
   Â Â  3 $x > 4; Â Â # match '3' before a-z or at the end
  Example The following example rules illustrate many of the features of
 the rule language.

  Rule 1. abc{def}>x|y Rule 2. xyz>r Rule 3. yz>q Applying these rules to the string "" adefabcdefz ""
 yields the following results:

  |adefabcdefz Initial state no rules match. Advance
         cursor. a|defabcdefz Still no match. Rule 1 does not match
         because the preceding context is not present. ad|efabcdefz Still no match. Keep advancing until
         there is a match... ade|fabcdefz ... adef|abcdefz ... adefa|bcdefz ... adefab|cdefz ... adefabc|defz Rule 1 matches; replace "" def ""
         with "" xy "" and back up the cursor
         to before the ' y '. adefabcx|yz Although "" xyz "" is
         present rule 2 does not match because the cursor is
         before the ' y ' not before the ' x '.
         Rule 3 does match. Replace "" yz ""
         with "" q "". adefabcxq| The cursor is at the end;
         transliteration is complete. The order of rules is significant. If multiple rules may match
 at some point the first matching rule is applied.

  Forward and reverse rules may have an empty output string.
 Otherwise an empty left or right hand side of any statement is a
 syntax error.

  Single quotes are used to quote any character other than a
 digit or letter. To specify a single quote itself inside or
 outside of quotes use two single quotes in a row. For example
 the rule "" '>'>o''clock "" changes the
 string "" > "" to the string "" o'clock "".

  Notes While a Transliterator is being built from rules it checks that
 the rules are added in proper order. For example if the rule
 ""a>x"" is followed by the rule ""ab>y""
 then the second rule will throw an exception. The reason is that
 the second rule can never be triggered since the first rule
 always matches anything it matches. In other words the first
 rule  masks  the second rule.",
"<android.telephony.TelephonyManager.CellInfoCallback: void onError(int,Throwable)>",NEITHER,NEITHER,"Error response to requestCellInfoUpdate() .

 Invoked when an error condition prevents updated CellInfo from being fetched
 and returned from the modem. Callers of requestCellInfoUpdate() should override this
 function to receive detailed status information in the event of an error. By default
 this function will invoke onCellInfo() with null.","errorCode int : an error code indicating the type of failure.
Value is ERROR_TIMEOUT or ERROR_MODEM_ERROR |||
detail Throwable : a Throwable object with additional detail regarding the failure if
available otherwise null.
This value may be null . |||",void,Callback for providing asynchronous  CellInfo  on request,
"<android.telephony.PhoneNumberUtils: String calledPartyBCDFragmentToString(byte,int,int,int)>",NEITHER,NEITHER,"Like calledPartyBCDToString but field does not start with a
 TOA byte. For example: SIM ADN extension fields","bytes byte |||
offset int |||
length int |||
bcdExtType int : Value is BCD_EXTENDED_TYPE_EF_ADN or BCD_EXTENDED_TYPE_CALLED_PARTY |||",String |||,Various utilities for dealing with phone number strings.,
"<android.telephony.SubscriptionPlan.Builder: SubscriptionPlan.Builder setDataUsage(long,long)>",NEITHER,SOURCE,Set a snapshot of currently known mobile data usage.,"dataUsageBytes long : the currently known mobile data usage
Value is a non-negative number of bytes. |||
dataUsageTime long : the time at which this snapshot was valid
Value is a non-negative timestamp measured as the number of
milliseconds since 1970-01-01T00:00:00Z. |||",SubscriptionPlan.Builder |||,"Description of a billing relationship plan between a carrier and a specific
 subscriber. This information is used to present more useful UI to users such
 as explaining how much mobile data they have remaining and what will happen
 when they run out.",
<android.net.wifi.WifiNetworkSpecifier.Builder: WifiNetworkSpecifier.Builder setIsHiddenSsid(boolean)>,NEITHER,SOURCE,Specifies whether this represents a hidden network.,isHiddenSsid boolean : true to indicate that the network is hidden false otherwise. |||,"WifiNetworkSpecifier.Builder Instance of Builder to enable chaining of the builder method.
 
 This value will never be null . |||",Builder used to create  WifiNetworkSpecifier  objects.,"Provides classes to manage Wi-Fi functionality on the device. The Wi-Fi APIs provide a means by which applications can communicate
 with the lower-level wireless stack that provides Wi-Fi network access. Almost all
 information from the device supplicant is available including the connected network's
 link speed IP address negotiation state and more plus information about other
 networks that are available. Some other API features include the ability to
 scan add save terminate and initiate Wi-Fi connections. Some APIs may require the following user permissions: ACCESS_WIFI_STATE CHANGE_WIFI_STATE CHANGE_WIFI_MULTICAST_STATE Note:  Not all Android-powered devices provide Wi-Fi functionality.
 If your application uses Wi-Fi declare so with a  <uses-feature> 
 element in the manifest file: 
 <manifest ...>
     <uses-feature android:name=""android.hardware.wifi"" />
     ...
 </manifest>"
"<android.icu.text.CaseMap.Lower: A apply(Locale,CharSequence,A,Edits)>",NEITHER,NEITHER,"Lowercases a string and optionally records edits (see omitUnchangedText() ).
 Casing is locale-dependent and context-sensitive.
 The result may be longer or shorter than the original.","locale Locale : The locale ID. Can be null for Locale#getDefault .
(See ULocale#toLocale .) |||
src CharSequence : The original string. |||
dest A : A buffer for the result string. Must not be null. |||
edits Edits : Records edits for index mapping working with styled text
and getting only changes (if any).
This function calls edits.reset() first. edits can be null. |||",A dest with the result string (or only changes) appended. |||,"Low-level case mapping options and methods. Immutable.
 ""Setters"" return instances with the union of the current and new options set.

 This class is not intended for public subclassing.",
"<android.view.textclassifier.TextClassification: void writeToParcel(Parcel,int)>",NEITHER,NEITHER,Flatten this object in to a Parcel.,"dest Parcel : The Parcel in which the object should be written. |||
flags int : Additional flags about how the object should be written.
May be 0 or Parcelable.PARCELABLE_WRITE_RETURN_VALUE .
Value is either 0 or a combination of Parcelable.PARCELABLE_WRITE_RETURN_VALUE and android.os.Parcelable.PARCELABLE_ELIDE_DUPLICATES |||",void,"Information for generating a widget to handle classified text.

  A TextClassification object contains icons labels onClickListeners and intents that may
 be used to build a widget that can be used to act on classified text. There is the concept of a
  primary action  and other  secondary actions .

  e.g. building a view that when clicked shares the classified text with the preferred app:

  // Called preferably outside the UiThread.
   TextClassification classification = textClassifier.classifyText(allText 10 25);

   // Called on the UiThread.
   Button button = new Button(context);
   button.setCompoundDrawablesWithIntrinsicBounds(classification.getIcon() null null null);
   button.setText(classification.getLabel());
   button.setOnClickListener(v -> classification.getActions().get(0).getActionIntent().send());
  e.g. starting an action mode with menu items that can handle the classified text:

  // Called preferably outside the UiThread.
   final TextClassification classification = textClassifier.classifyText(allText 10 25);

   // Called on the UiThread.
   view.startActionMode(new ActionMode.Callback() {

       public boolean onCreateActionMode(ActionMode mode Menu menu) {
           for (int i = 0; i < classification.getActions().size(); ++i) {
              RemoteAction action = classification.getActions().get(i);
              menu.add(Menu.NONE i 20 action.getTitle())
                 .setIcon(action.getIcon());
           }
           return true;
       }

       public boolean onActionItemClicked(ActionMode mode MenuItem item) {
           classification.getActions().get(item.getItemId()).getActionIntent().send();
           return true;
       }

       ...
   });",
<android.app.Person: Icon getIcon()>,NEITHER,SOURCE,,,Icon the icon provided for this person or null if no icon was provided. |||,"Provides an immutable reference to an entity that appears repeatedly on different surfaces of the
 platform. For example this could represent the sender of a message.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 designâ€”especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activityâ€”allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User ."
<android.view.textclassifier.TextClassification.Request.Builder: TextClassification.Request.Builder setDefaultLocales(LocaleList)>,NEITHER,NEITHER,,"defaultLocales LocaleList : ordered list of locale preferences that may be used to
disambiguate the provided text. If no locale preferences exist set this to null
or an empty locale list.
This value may be null . |||",TextClassification.Request.Builder this builder |||,A builder for building TextClassification requests.,
<android.service.autofill.FillResponse.Builder: FillResponse.Builder setUserData(UserData)>,NEITHER,SOURCE,"Sets a specific UserData for field classification for this request only. Any fields in this UserData will override corresponding fields in the generic
 UserData object",userData UserData : This value must never be null . |||,"FillResponse.Builder this builder
 This value will never be null . |||","Builder for  FillResponse  objects. You must to provide at least
 one dataset or set an authentication intent with a presentation view.",
"<android.telephony.SubscriptionPlan: void writeToParcel(Parcel,int)>",NEITHER,NEITHER,Flatten this object in to a Parcel.,"dest Parcel : The Parcel in which the object should be written. |||
flags int : Additional flags about how the object should be written.
May be 0 or Parcelable.PARCELABLE_WRITE_RETURN_VALUE .
Value is either 0 or a combination of Parcelable.PARCELABLE_WRITE_RETURN_VALUE and android.os.Parcelable.PARCELABLE_ELIDE_DUPLICATES |||",void,"Description of a billing relationship plan between a carrier and a specific
 subscriber. This information is used to present more useful UI to users such
 as explaining how much mobile data they have remaining and what will happen
 when they run out.",
<android.provider.MediaStore: Uri setRequireOriginal(Uri)>,NEITHER,NEITHER,"Update the given Uri to indicate that the caller requires the
 original file contents when calling ContentResolver#openFileDescriptor(Uri String) . This can be useful when the caller wants to ensure they're backing up the
 exact bytes of the underlying media without any Exif redaction being
 performed. If the original file contents cannot be provided a UnsupportedOperationException will be thrown when the returned Uri is used such as when the caller doesn't hold Manifest.permission.ACCESS_MEDIA_LOCATION .",uri Uri : This value must never be null . |||,Uri This value will never be null . |||,"The contract between the media provider and applications. Contains
 definitions for the supported URIs and columns.
  
 The media provider provides an indexed collection of common media types such
 as  Audio   Video  and  Images  from any attached
 storage devices. Each collection is organized based on the primary MIME type
 of the underlying content; for example  image/*  content is indexed
 under  Images . The  Files  collection provides a broad view
 across all collections and does not filter by MIME type.","Provides convenience classes to access the content providers supplied by
 Android. Android ships with a number of content providers that store common data such
 as contact informations calendar information and media files. These classes
 provide simplified methods of adding or retrieving data from these content
 providers. For information about how to use a content provider see the  Content Providers  developer
 guide."
<android.app.job.JobInfo.Builder: JobInfo.Builder setRequiredNetwork(NetworkRequest)>,NEITHER,SOURCE,"Set detailed description of the kind of network your job requires. If your job doesn't need a network connection you don't need to call
 this method as the default is null . Calling this method defines network as a strict requirement for your
 job. If the network requested is not available your job will never
 run. See setOverrideDeadline(long) to change this behavior.
 Calling this method will override any requirements previously defined
 by setRequiredNetworkType(int) ; you typically only want to
 call one of these methods. When your job executes in JobService#onStartJob(JobParameters) be sure to use the
 specific network returned by JobParameters#getNetwork() otherwise you'll use the default network which may not meet this
 constraint.","networkRequest NetworkRequest : The detailed description of the kind of network
this job requires or null if no specific kind of
network is required. Defining a NetworkSpecifier is only supported for jobs that aren't persisted.
This value may be null . |||",JobInfo.Builder |||,Builder class for constructing  JobInfo  objects.,"Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 designâ€”especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activityâ€”allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User ."
"<android.view.textclassifier.TextSelection.Request: void writeToParcel(Parcel,int)>",NEITHER,NEITHER,Flatten this object in to a Parcel.,"dest Parcel : The Parcel in which the object should be written. |||
flags int : Additional flags about how the object should be written.
May be 0 or Parcelable.PARCELABLE_WRITE_RETURN_VALUE .
Value is either 0 or a combination of Parcelable.PARCELABLE_WRITE_RETURN_VALUE and android.os.Parcelable.PARCELABLE_ELIDE_DUPLICATES |||",void,A request object for generating TextSelection.,
<android.net.wifi.p2p.WifiP2pConfig.Builder: WifiP2pConfig.Builder setNetworkName(String)>,NEITHER,SOURCE,"Specify the network name a.k.a. group name
 for creating or joining a group. A network name shall begin with ""DIRECT-xy"". x and y are selected
 from the following character set: upper case letters lower case
 letters and numbers. Any byte values allowed for an SSID according to
 IEEE802.11-2012 [1] may be included after the string ""DIRECT-xy""
 (including none). Must be called - an empty network name or an network name
     not conforming to the P2P Group ID naming rule is not valid.","networkName String : network name of a group.
This value must never be null . |||","WifiP2pConfig.Builder The builder to facilitate chaining builder.setXXX(..).setXXX(..) .
 
 This value will never be null . |||","Builder used to build  WifiP2pConfig  objects for
 creating or joining a group.","Provides classes to create peer-to-peer (P2P) connections with Wi-Fi Direct. Using these APIs you can discover and connect to other devices when each
 device supports Wi-Fi Direct then communicate over a speedy connection across distances much longer
 than a Bluetooth connection. The primary class you need to work with is  WifiP2pManager  which you can acquire by calling  getSystemService(WIFI_P2P_SERVICE) . The  WifiP2pManager  includes APIs that allow you to: Initialize your application for P2P connections by calling  initialize() Discover nearby devices by calling  discoverPeers() Start a P2P connection by calling  connect() And more Several other interfaces and classes are necessary as well such as: The  WifiP2pManager.ActionListener  interface allows you to receive
 callbacks when an operation such as discovering peers or connecting to them succeeds or fails. WifiP2pManager.PeerListListener  interface allows you to receive
 information about discovered peers. The callback provides a  WifiP2pDeviceList  from which you can retrieve a  WifiP2pDevice  object for each device within range and get information such as
 the device name address device type the WPS configurations the device supports and more. The  WifiP2pManager.GroupInfoListener  interface allows you to
 receive information about a P2P group. The callback provides a  WifiP2pGroup  object which provides group information such as the owner the
 network name and passphrase. WifiP2pManager.ConnectionInfoListener  interface allows you to
 receive information about the current connection. The callback provides a  WifiP2pInfo  object which has information such as whether a group has been
 formed and who is the group owner. In order to use the Wi-Fi P2P APIs your app must request the following user permissions: ACCESS_WIFI_STATE CHANGE_WIFI_STATE INTERNET  (although your app doesnâ€™t technically connect
 to the Internet communicating to Wi-Fi Direct peers with standard java sockets requires Internet
 permission). For example code see the  Wi-Fi
 Direct Demo  sample application. Note:  Not all Android-powered devices support Wi-Fi
 Direct. If your application uses Wi-Fi Direct declare so with a  <uses-feature> 
 element in the manifest file: 
 <manifest ...>
     <uses-feature android:name=""android.hardware.wifi.direct"" />
     ...
 </manifest>"
"<android.telephony.CellIdentityTdscdma: void writeToParcel(Parcel,int)>",NEITHER,NEITHER,Implement the Parcelable interface,"dest Parcel : The Parcel in which the object should be written. |||
flags int : Additional flags about how the object should be written.
May be 0 or Parcelable.PARCELABLE_WRITE_RETURN_VALUE .
Value is either 0 or a combination of Parcelable.PARCELABLE_WRITE_RETURN_VALUE and android.os.Parcelable.PARCELABLE_ELIDE_DUPLICATES |||",void,"CellIdentity represents the identity of a unique cell. This is the base class for
 CellIdentityXxx which represents cell identity for specific network access technology.",
"<android.view.textclassifier.TextLanguage.Builder: TextLanguage.Builder putLocale(ULocale,float)>",NEITHER,SOURCE,"Sets a language locale for the processed text and assigns a confidence score. If the
 locale has already been set this updates it.","locale ULocale : This value must never be null . |||
confidenceScore float : a value from 0 (low confidence) to 1 (high confidence).
0 implies the locale does not exist for the processed text.
Values greater than 1 are clamped to 1.
Value is between 0.0 and 1.0 inclusive |||",TextLanguage.Builder This value will never be null . |||,Builder used to build TextLanguage objects.,
"<android.net.wifi.rtt.ResponderLocation: void writeToParcel(Parcel,int)>",NEITHER,NEITHER,Flatten this object in to a Parcel.,"parcel Parcel : The Parcel in which the object should be written. |||
flags int : Additional flags about how the object should be written.
May be 0 or Parcelable.PARCELABLE_WRITE_RETURN_VALUE .
Value is either 0 or a combination of Parcelable.PARCELABLE_WRITE_RETURN_VALUE and android.os.Parcelable.PARCELABLE_ELIDE_DUPLICATES |||",void,"ResponderLocation is both a Location Configuration Information (LCI) decoder and a Location Civic
 Report (LCR) decoder for information received from a Wi-Fi Access Point (AP) during Wi-Fi RTT
 ranging process.

  This is based on the IEEE P802.11-REVmc/D8.0 spec section 9.4.2.22 under Measurement Report
 Element. Subelement location data-fields parsed from separate input LCI and LCR Information
 Elements are unified in this class. Note: The information provided by this class is broadcast by a responder (usually an Access
 Point) and passed on as-is. There is no guarantee this information is accurate or correct and
 as a result developers should carefully consider how this information should be used and provide
 corresponding advice to users.","Provides classes which allow applications to use Wi-Fi RTT (IEEE 802.11mc) to measure distance
     to supporting Access Points and peer devices. The primary entry point to Wi-Fi RTT capabilities is the
      WifiRttManager  class which is acquired by calling
      Context.getSystemService(Context.WIFI_RTT_RANGING_SERVICE) Some APIs may require the following user permissions: ACCESS_WIFI_STATE CHANGE_WIFI_STATE ACCESS_FINE_LOCATION Usage of the API is also gated by the device's Location Mode: whether it permits Wi-Fi based
 location to be queried. Note:  Not all Android-powered devices support Wi-Fi RTT
     functionality.
     If your application only works with Wi-Fi RTT (i.e. it should only be installed on devices which
     support Wi-Fi RTT) declare so with a  <uses-feature> 
     element in the manifest file: 
 <manifest ...>
     <uses-feature android:name=""android.hardware.wifi.rtt"" />
     ...
 </manifest>
  Alternatively if your application does not require Wi-Fi RTT but can take advantage of it if
     available you can perform
     the check at run-time in your code using  hasSystemFeature(String)  with  FEATURE_WIFI_RTT : 
     getPackageManager().hasSystemFeature(PackageManager.FEATURE_WIFI_RTT)"
<android.bluetooth.le.ScanFilter.Builder: ScanFilter.Builder setServiceSolicitationUuid(ParcelUuid)>,NEITHER,SOURCE,Set filter on service solicitation uuid.,serviceSolicitationUuid ParcelUuid : This value may be null . |||,ScanFilter.Builder This value will never be null . |||,Builder class for  ScanFilter .,"Provides classes that manage Bluetooth functionality such as scanning for
 devices connecting with devices and managing data transfer between devices.
 The Bluetooth API supports both ""Classic Bluetooth"" and Bluetooth Low Energy. For more information about Classic Bluetooth see the
  Bluetooth  guide.
 For more information about Bluetooth Low Energy see the
  
 Bluetooth Low Energy  (BLE) guide. The Bluetooth APIs let applications: Scan for other Bluetooth devices (including BLE devices). Query the local Bluetooth adapter for paired Bluetooth devices. Establish RFCOMM channels/sockets. Connect to specified sockets on other devices. Transfer data to and from other devices. Communicate with BLE devices such as proximity sensors heart rate
     monitors fitness devices and so on. Act as a GATT client or a GATT server (BLE). 
 To perform Bluetooth communication using these APIs an application must
 declare the  BLUETOOTH  permission. Some
 additional functionality such as requesting device discovery
 also requires the  BLUETOOTH_ADMIN 
 permission.
  Note: 
 Not all Android-powered devices provide Bluetooth functionality."
"<android.telephony.CellInfoNr: void writeToParcel(Parcel,int)>",NEITHER,NEITHER,Implement the Parcelable interface,"dest Parcel : The Parcel in which the object should be written. |||
flags int : Additional flags about how the object should be written.
May be 0 or Parcelable.PARCELABLE_WRITE_RETURN_VALUE .
Value is either 0 or a combination of Parcelable.PARCELABLE_WRITE_RETURN_VALUE and android.os.Parcelable.PARCELABLE_ELIDE_DUPLICATES |||",void,A  CellInfo  representing an 5G NR cell that provides identity and measurement info.,
<android.hardware.camera2.params.OutputConfiguration: void setPhysicalCameraId(String)>,NEITHER,NEITHER,"Set the id of the physical camera for this OutputConfiguration In the case one logical camera is made up of multiple physical cameras it could be
 desirable for the camera application to request streams from individual physical cameras.
 This call achieves it by mapping the OutputConfiguration to the physical camera id. The valid physical camera ids can be queried by CameraCharacteristics.getPhysicalCameraIds() . Passing in a null physicalCameraId means that the OutputConfiguration is for a logical
 stream. This function must be called before CameraDevice#createCaptureSessionByOutputConfigurations or CameraDevice#createReprocessableCaptureSessionByConfigurations . Calling this function
 after CameraDevice#createCaptureSessionByOutputConfigurations or CameraDevice#createReprocessableCaptureSessionByConfigurations has no effect. The surface belonging to a physical camera OutputConfiguration must not be used as input
 or output of a reprocessing request.",physicalCameraId String : This value may be null . |||,void,"A class for describing camera output which contains a  Surface  and its specific
 configuration for creating capture session.

  There are several ways to instantiate modify and use OutputConfigurations. The most common
 and recommended usage patterns are summarized in the following list: Passing a  Surface  to the constructor and using the OutputConfiguration instance as
 argument to  CameraDevice#createCaptureSessionByOutputConfigurations . This is the most
 frequent usage and clients should consider it first before other more complicated alternatives.
  Passing only a surface source class as an argument to the constructor. This is usually
 followed by a call to create a capture session
 (see  CameraDevice#createCaptureSessionByOutputConfigurations  and a  Surface  add
 call  addSurface(Surface)  with a valid  Surface . The sequence completes with
  CameraCaptureSession#finalizeOutputConfigurations . This is the deferred usage case which
 aims to enhance performance by allowing the resource-intensive capture session create call to
 execute in parallel with any  Surface  initialization such as waiting for a
  SurfaceView  to be ready as part of the UI initialization. The third and most complex usage pattern involves surface sharing. Once instantiated an
 OutputConfiguration can be enabled for surface sharing via  enableSurfaceSharing() . This
 must be done before creating a new capture session and enables calls to
  CameraCaptureSession#updateOutputConfiguration . An OutputConfiguration with enabled
 surface sharing can be modified via  addSurface(Surface)  or  removeSurface(Surface) . The updates
 to this OutputConfiguration will only come into effect after
  CameraCaptureSession#updateOutputConfiguration  returns without throwing exceptions.
 Such updates can be done as long as the session is active. Clients should always consider the
 additional requirements and limitations placed on the output surfaces (for more details see
  enableSurfaceSharing()   addSurface(Surface)   removeSurface(Surface) 
  CameraCaptureSession#updateOutputConfiguration ). A trade-off exists between additional
 complexity and flexibility. If exercised correctly surface sharing can switch between different
 output surfaces without interrupting any ongoing repeating capture requests. This saves time and
 can significantly improve the user experience. Surface sharing can be used in combination with deferred surfaces. The rules from both cases
 are combined and clients must call  enableSurfaceSharing()  before creating a capture
 session. Attach and/or remove output surfaces via   addSurface(Surface) / removeSurface(Surface)  and
 finalize the configuration using  CameraCaptureSession#finalizeOutputConfigurations .
  CameraCaptureSession#updateOutputConfiguration  can be called after the configuration
 finalize method returns without exceptions.  As of  Android P  all formats except
  ImageFormat#JPEG  and  ImageFormat#RAW_PRIVATE  can be used for sharing subject to
 device support. On prior API levels only  ImageFormat#PRIVATE  format may be used.","The android.hardware.camera2 package provides an interface to
 individual camera devices connected to an Android device. It replaces
 the deprecated  Camera  class. This package models a camera device as a pipeline which takes in
 input requests for capturing a single frame captures the single image
 per the request and then outputs one capture result metadata packet
 plus a set of output image buffers for the request. The requests are
 processed in-order and multiple requests can be in flight at
 once. Since the camera device is a pipeline with multiple stages
 having multiple requests in flight is required to maintain full
 framerate on most Android devices. To enumerate query and open available camera devices obtain a
  CameraManager  instance. Individual  CameraDevices  provide a set of static property information that
 describes the hardware device and the available settings and output
 parameters for the device. This information is provided through the
  CameraCharacteristics  object and is
 available through  getCameraCharacteristics(String) To capture or stream images from a camera device the application
 must first create a  camera capture session 
 with a set of output Surfaces for use with the camera device with
  createCaptureSession(SessionConfiguration) . Each
 Surface has to be pre-configured with an  appropriate
 size and format  (if applicable) to match the sizes and formats
 available from the camera device. A target Surface can be obtained
 from a variety of classes including  SurfaceView 
  SurfaceTexture  via
  Surface(SurfaceTexture) 
  MediaCodec   MediaRecorder 
  Allocation  and  ImageReader .
  Generally camera preview images are sent to  SurfaceView  or  TextureView  (via its
  SurfaceTexture ). Capture of JPEG images or
 RAW buffers for  DngCreator  can be
 done with  ImageReader  with the  JPEG  and  RAW_SENSOR  formats.  Application-driven
 processing of camera data in RenderScript OpenGL ES or directly in
 managed or native code is best done through  Allocation  with a YUV  Type   SurfaceTexture 
 and  ImageReader  with a  YUV_420_888  format respectively. The application then needs to construct a  CaptureRequest  which defines all the
 capture parameters needed by a camera device to capture a single
 image. The request also lists which of the configured output Surfaces
 should be used as targets for this capture. The CameraDevice has a
  factory method  for creating a  request builder  for a
 given use case which is optimized for the Android device the
 application is running on. Once the request has been set up it can be handed to the active
 capture session either for a one-shot  capture  or for
 an endlessly  repeating  use. Both methods also have a variant that accepts a list
 of requests to use as a burst capture / repeating burst. Repeating
 requests have a lower priority than captures so a request submitted
 through  capture()  while there's a repeating request
 configured will be captured before any new instances of the currently
 repeating (burst) capture will begin capture. After processing a request the camera device will produce a  TotalCaptureResult  object which contains
 information about the state of the camera device at time of capture
 and the final settings used. These may vary somewhat from the request
 if rounding or resolving contradictory parameters was necessary. The
 camera device will also send a frame of image data into each of the
 output  Surfaces  included in the request. These are produced
 asynchronously relative to the output CaptureResult sometimes
 substantially later."
"<android.telephony.euicc.DownloadableSubscription: void writeToParcel(Parcel,int)>",NEITHER,NEITHER,Flatten this object in to a Parcel.,"dest Parcel : The Parcel in which the object should be written. |||
flags int : Additional flags about how the object should be written.
May be 0 or Parcelable.PARCELABLE_WRITE_RETURN_VALUE .
Value is either 0 or a combination of Parcelable.PARCELABLE_WRITE_RETURN_VALUE and android.os.Parcelable.PARCELABLE_ELIDE_DUPLICATES |||",void,"Information about a subscription which is downloadable to an eUICC using
  EuiccManager#downloadSubscription(DownloadableSubscription boolean PendingIntent)",
<android.telephony.SubscriptionManager: int getSubscriptionIds(int)>,NEITHER,SOURCE,Get an array of Subscription Ids for specified slot Index.,slotIndex int : the slot index. |||,"int[] subscription Ids or null if the given slot Index is not valid or there are no active
 subscriptions in the slot. |||","SubscriptionManager is the application interface to SubscriptionController
 and provides information about the current Telephony Subscriptions.",
<android.telephony.emergency.EmergencyNumber: String getNumber()>,NEITHER,SOURCE,"Get the dialing number of the emergency number.

 The character in the number string is only the dial pad
 character('0'-'9' '*' '+' or '#'). For example: 911.

 If the number starts with carrier prefix the carrier prefix is configured in CarrierConfigManager#KEY_EMERGENCY_NUMBER_PREFIX_STRING_ARRAY .",,"String the dialing number.
 
 This value will never be null . |||","A parcelable class that wraps and retrieves the information of number service category(s) and
 country code for a specific emergency number.",
<android.icu.text.Transliterator: String getDisplayName(String)>,NEITHER,NEITHER,"Returns a name for this transliterator that is appropriate for
 display to the user in the default DISPLAY locale.  See getDisplayName(java.lang.String java.util.Locale) for details.",ID String |||,String |||,"Transliterator  is an abstract class that transliterates text from one format to another. The most common
 kind of transliterator is a script or alphabet transliterator. For example a Russian to Latin transliterator
 changes Russian text written in Cyrillic characters to phonetically equivalent Latin characters. It does not
  translate  Russian to English! Transliteration unlike translation operates on characters without reference
 to the meanings of words and sentences.

  
 Although script conversion is its most common use a transliterator can actually perform a more general class of
 tasks. In fact  Transliterator  defines a very general API which specifies only that a segment of the
 input text is replaced by new text. The particulars of this conversion are determined entirely by subclasses of
  Transliterator .

  Transliterators are stateless Transliterator  objects are  stateless ; they retain no information between calls to
  transliterate() . As a result threads may share transliterators without synchronizing them. This might
 seem to limit the complexity of the transliteration operation. In practice subclasses perform complex
 transliterations by delaying the replacement of text until it is known that no other replacements are possible. In
 other words although the  Transliterator  objects are stateless the source text itself embodies all the
 needed information and delayed operation allows arbitrary complexity.

  Batch transliteration 
 The simplest way to perform transliteration is all at once on a string of existing text. This is referred to as
  batch  transliteration. For example given a string  input  and a transliterator  t 
 the call

  String result = t.transliterate(input);
  Replaceable Keyboard transliteration 
 Somewhat more involved is  keyboard  or incremental transliteration. This is the transliteration of text that
 is arriving from some source (typically the user's keyboard) one character at a time or in some other piecemeal
 fashion.

  
 In keyboard transliteration a  Replaceable  buffer stores the text. As text is inserted as much as
 possible is transliterated on the fly. This means a GUI that displays the contents of the buffer may show text being
 modified as each new character arrives.

  
 Consider the simple rule-based Transliterator:

  
 th>{theta} 
 t>{tau}
  
 t>|{tau} 
 {tau}h>{theta}
  transliterate() 
 Keyboard transliteration methods maintain a set of three indices that are updated with each call to
  transliterate()  including the cursor start and limit. These indices are changed by the method and
 they are passed in and out via a Position object. The  start  index marks the beginning of the substring
 that the transliterator will look at. It is advanced as text becomes committed (but it is not the committed index;
 that's the  cursor ). The  cursor  index described above marks the point at which the
 transliterator last stopped either because it reached the end or because it required more characters to
 disambiguate between possible inputs. The  cursor  can also be explicitly set by rules.
 Any characters before the  cursor  index are frozen; future keyboard
 transliteration calls within this input sequence will not change them. New text is inserted at the  limit 
 index which marks the end of the substring that the transliterator looks at.

  
 Because keyboard transliteration assumes that more characters are to arrive it is conservative in its operation. It
 only transliterates when it can do so unambiguously. Otherwise it waits for more characters to arrive. When the
 client code knows that no more characters are forthcoming perhaps because the user has performed some input
 termination operation then it should call  finishTransliteration()  to complete any pending
 transliterations.

  Inverses 
 Pairs of transliterators may be inverses of one another. For example if transliterator  A  transliterates
 characters by incrementing their Unicode value (so ""abc"" -> ""def"") and transliterator  B  decrements character
 values then  A  is an inverse of  B  and vice versa. If we compose  A  with  B  in a compound
 transliterator the result is the indentity transliterator that is a transliterator that does not change its input
 text.

 The  Transliterator  method  getInverse()  returns a transliterator's inverse if one exists
 or  null  otherwise. However the result of  getInverse()  usually will  not  be a true
 mathematical inverse. This is because true inverse transliterators are difficult to formulate. For example consider
 two transliterators:  AB  which transliterates the character 'A' to 'B' and  BA  which transliterates
 'B' to 'A'. It might seem that these are exact inverses since

  ""A"" x  AB  -> ""B"" 
 ""B"" x  BA  -> ""A"" ""ABCD"" x  AB  -> ""BBCD"" 
 ""BBCD"" x  BA  -> ""AACD"" AB BA BA AB AB .getInverse() BA Filtering Each transliterator has a filter which restricts changes to those characters selected by the filter. The
 filter affects just the characters that are changed -- the characters outside of the filter are still part of the
 context for the filter. For example in the following even though 'x' is filtered out and doesn't convert to y it does affect the conversion of 'a'.

  
 String rules = ""x > y; x{a} > b; "";
 Transliterator tempTrans = Transliterator.createFromRules(""temp"" rules Transliterator.FORWARD);
 tempTrans.setFilter(new UnicodeSet(""[a]""));
 String tempResult = tempTrans.transform(""xa"");
 // results in ""xb""
 IDs and display names 
 A transliterator is designated by a short identifier string or  ID . IDs follow the format
  source-destination  where  source  describes the entity being replaced and  destination 
 describes the entity replacing  source . The entities may be the names of scripts particular sequences of
 characters or whatever else it is that the transliterator converts to or from. For example a transliterator from
 Russian to Latin might be named ""Russian-Latin"". A transliterator from keyboard escape sequences to Latin-1
 characters might be named ""KeyboardEscape-Latin1"". By convention system entity names are in English with the
 initial letters of words capitalized; user entity names may follow any format so long as they do not contain dashes.

  
 In addition to programmatic IDs transliterator objects have display names for presentation in user interfaces
 returned by  getDisplayName(String) .

  Composed transliterators 
 In addition to built-in system transliterators like ""Latin-Greek"" there are also built-in  composed 
 transliterators. These are implemented by composing two or more component transliterators. For example if we have
 scripts ""A"" ""B"" ""C"" and ""D"" and we want to transliterate between all pairs of them then we need to write 12
 transliterators: ""A-B"" ""A-C"" ""A-D"" ""B-A""... ""D-A"" ""D-B"" ""D-C"". If it is possible to convert all scripts to an
 intermediate script ""M"" then instead of writing 12 rule sets we only need to write 8: ""A~M"" ""B~M"" ""C~M"" ""D~M""
 ""M~A"" ""M~B"" ""M~C"" ""M~D"". (This might not seem like a big win but it's really 2 n  vs.  n 2  -  n  so as  n  gets larger the gain becomes significant. With 9 scripts it's 18 vs. 72
 rule sets a big difference.) Note the use of ""~"" rather than ""-"" for the script separator here; this indicates that
 the given transliterator is intended to be composed with others rather than be used as is.

  
 Composed transliterators can be instantiated as usual. For example the system transliterator ""Devanagari-Gujarati""
 is a composed transliterator built internally as ""Devanagari~InterIndic;InterIndic~Gujarati"". When this
 transliterator is instantiated it appears externally to be a standard transliterator (e.g. getID() returns
 ""Devanagari-Gujarati"").

  Rule syntax A set of rules determines how to perform translations.
 Rules within a rule set are separated by semicolons (';').
 To include a literal semicolon prefix it with a backslash ('\').
 Unicode Pattern_White_Space is ignored.
 If the first non-blank character on a line is '#'
 the entire line is ignored as a comment.

  Each set of rules consists of two groups one forward and one
 reverse. This is a convention that is not enforced; rules for one
 direction may be omitted with the result that translations in
 that direction will not modify the source text. In addition
 bidirectional forward-reverse rules may be specified for
 symmetrical transformations.

  Note: Another description of the Transliterator rule syntax is available in
  section
 Transform Rules Syntax of UTS #35: Unicode LDML .
 The rules are shown there using arrow symbols â† and â†’ and â†”.
 ICU supports both those and the equivalent ASCII symbols < and > and <>.

  Rule statements take one of the following forms:

  $alefmadda=\\u0622; Variable definition.  The name on the
         left is assigned the text on the right. In this example
         after this statement instances of the left hand name
         "" $alefmadda "" will be replaced by
         the Unicode character U+0622. Variable names must begin
         with a letter and consist only of letters digits and
         underscores. Case is significant. Duplicate names cause
         an exception to be thrown that is variables cannot be
         redefined. The right hand side may contain well-formed
         text of any length including no text at all ("" $empty=; "").
         The right hand side may contain embedded  UnicodeSet 
         patterns for example "" $softvowel=[eiyEIY] "". ai>$alefmadda; Forward translation rule.  This rule
         states that the string on the left will be changed to the
         string on the right when performing forward
         transliteration. ai<$alefmadda; Reverse translation rule.  This rule
         states that the string on the right will be changed to
         the string on the left when performing reverse
         transliteration. ai<>$alefmadda; Bidirectional translation rule.  This
         rule states that the string on the right will be changed
         to the string on the left when performing forward
         transliteration and vice versa when performing reverse
         transliteration. Translation rules consist of a  match pattern  and an  output
 string . The match pattern consists of literal characters
 optionally preceded by context and optionally followed by
 context. Context characters like literal pattern characters
 must be matched in the text being transliterated. However unlike
 literal pattern characters they are not replaced by the output
 text. For example the pattern "" abc{def} ""
 indicates the characters "" def "" must be
 preceded by "" abc "" for a successful match.
 If there is a successful match "" def "" will
 be replaced but not "" abc "". The final ' } '
 is optional so "" abc{def "" is equivalent to
 "" abc{def} "". Another example is "" {123}456 ""
 (or "" 123}456 "") in which the literal
 pattern "" 123 "" must be followed by "" 456 "".

  The output string of a forward or reverse rule consists of
 characters to replace the literal pattern characters. If the
 output string contains the character ' | ' this is
 taken to indicate the location of the  cursor  after
 replacement. The cursor is the point in the text at which the
 next replacement if any will be applied. The cursor is usually
 placed within the replacement text; however it can actually be
 placed into the precending or following context by using the
 special character '@'. Examples:

  
     a {foo} z > | @ bar; # foo -> bar move cursor before a
     {foo} xyz > bar @@|; #Â foo -> bar cursor between y and z
  UnicodeSet UnicodeSet  patterns may appear anywhere that
 makes sense. They may appear in variable definitions.
 Contrariwise  UnicodeSet  patterns may themselves
 contain variable references such as "" $a=[a-z];$not_a=[^$a] ""
 or "" $range=a-z;$ll=[$range] "".

  UnicodeSet  patterns may also be embedded directly
 into rule strings. Thus the following two rules are equivalent:

  
     $vowel=[aeiou]; $vowel>'*'; # One way to do this
     [aeiou]>'*'; # Another way
  See  UnicodeSet  for more documentation and examples.

  Segments Segments of the input string can be matched and copied to the
 output string. This makes certain sets of rules simpler and more
 general and makes reordering possible. For example:

  
     ([a-z]) > $1 $1; # double lowercase letters
     ([:Lu:]) ([:Ll:]) > $2 $1; # reverse order of Lu-Ll pairs
  The segment of the input string to be copied is delimited by
 "" ( "" and "" ) "". Up to
 nine segments may be defined. Segments may not overlap. In the
 output string "" $1 "" through "" $9 ""
 represent the input string segments in left-to-right order of
 definition.

  Anchors Patterns can be anchored to the beginning or the end of the text. This is done with the
 special characters ' ^ ' and ' $ '. For example:

  
   ^ aÂ Â  > 'BEG_A'; Â Â # match 'a' at start of text
   Â  aÂ Â  > 'A'; # match other instances of 'a'
   Â  z $ > 'END_Z'; Â Â # match 'z' at end of text
   Â  zÂ Â  > 'Z';Â Â Â Â Â Â  # match other instances of 'z'
  It is also possible to match the beginning or the end of the text using a  UnicodeSet .
 This is done by including a virtual anchor character ' $ ' at the end of the
 set pattern. Although this is usually the match chafacter for the end anchor the set will
 match either the beginning or the end of the text depending on its placement. For
 example:

  
   $x = [a-z$]; Â Â # match 'a' through 'z' OR anchor
   $x 1Â Â Â  > 2;Â Â  # match '1' after a-z or at the start
   Â Â  3 $x > 4; Â Â # match '3' before a-z or at the end
  Example The following example rules illustrate many of the features of
 the rule language.

  Rule 1. abc{def}>x|y Rule 2. xyz>r Rule 3. yz>q Applying these rules to the string "" adefabcdefz ""
 yields the following results:

  |adefabcdefz Initial state no rules match. Advance
         cursor. a|defabcdefz Still no match. Rule 1 does not match
         because the preceding context is not present. ad|efabcdefz Still no match. Keep advancing until
         there is a match... ade|fabcdefz ... adef|abcdefz ... adefa|bcdefz ... adefab|cdefz ... adefabc|defz Rule 1 matches; replace "" def ""
         with "" xy "" and back up the cursor
         to before the ' y '. adefabcx|yz Although "" xyz "" is
         present rule 2 does not match because the cursor is
         before the ' y ' not before the ' x '.
         Rule 3 does match. Replace "" yz ""
         with "" q "". adefabcxq| The cursor is at the end;
         transliteration is complete. The order of rules is significant. If multiple rules may match
 at some point the first matching rule is applied.

  Forward and reverse rules may have an empty output string.
 Otherwise an empty left or right hand side of any statement is a
 syntax error.

  Single quotes are used to quote any character other than a
 digit or letter. To specify a single quote itself inside or
 outside of quotes use two single quotes in a row. For example
 the rule "" '>'>o''clock "" changes the
 string "" > "" to the string "" o'clock "".

  Notes While a Transliterator is being built from rules it checks that
 the rules are added in proper order. For example if the rule
 ""a>x"" is followed by the rule ""ab>y""
 then the second rule will throw an exception. The reason is that
 the second rule can never be triggered since the first rule
 always matches anything it matches. In other words the first
 rule  masks  the second rule.",
<android.media.MediaMetadataRetriever: Bitmap getImageAtIndex(int)>,NEITHER,SOURCE,"This method is similar to getImageAtIndex(int android.media.MediaMetadataRetriever.BitmapParams) except that
 the default for BitmapParams will be used.",imageIndex int : 0-based index of the image. |||,Bitmap the requested still image or null if the image cannot be retrieved. |||,Contains metadata about an item such as the title artist etc.,"The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager )."
"<android.net.MacAddress: void writeToParcel(Parcel,int)>",NEITHER,NEITHER,Flatten this object in to a Parcel.,"out Parcel : The Parcel in which the object should be written. |||
flags int : Additional flags about how the object should be written.
May be 0 or Parcelable.PARCELABLE_WRITE_RETURN_VALUE .
Value is either 0 or a combination of Parcelable.PARCELABLE_WRITE_RETURN_VALUE and android.os.Parcelable.PARCELABLE_ELIDE_DUPLICATES |||",void,"Representation of a MAC address.

 This class only supports 48 bits long addresses and does not support 64 bits long addresses.
 Instances of this class are immutable.",
<android.view.textclassifier.TextLinks.Request.Builder: TextLinks.Request.Builder setDefaultLocales(LocaleList)>,NEITHER,NEITHER,"Sets ordered list of locale preferences that may be used to disambiguate the
 provided text.","defaultLocales LocaleList : ordered list of locale preferences that may be used to
disambiguate the provided text. If no locale preferences exist
set this to null or an empty locale list.
This value may be null . |||",TextLinks.Request.Builder this builder |||,A builder for building TextLinks requests.,
<android.os.SharedMemory: ByteBuffer mapReadOnly()>,NEITHER,SOURCE,"Creates a read-only mapping of the entire shared memory region. This requires the the
 protection level of the shared memory is at least PROT_READ or the map will fail.

 Use map(int int int) to have more control over the mapping if desired.
 This is equivalent to map(OsConstants.PROT_READ 0 getSize())",,"ByteBuffer A ByteBuffer mapping
 This value will never be null . |||",SharedMemory enables the creation mapping and protection control over anonymous shared memory.,
<android.view.autofill.AutofillManager: void setUserData(UserData)>,NEITHER,SINK,"Sets the UserData used for field classification Note: This method should only be called by an app providing an autofill service
 and it's ignored if the caller currently doesn't have an enabled autofill service for
 the user.",userData UserData : This value may be null . |||,void,"The  AutofillManager  class provides ways for apps and custom views to
 integrate with the Autofill Framework lifecycle.

  To learn about using Autofill in your app read
 the  Autofill Framework  guides.

  Autofill lifecycle The autofill lifecycle starts with the creation of an autofill context associated with an
 activity context. The autofill context is created when one of the following methods is called for
 the first time in an activity context and the current user has an enabled autofill service:

  notifyViewEntered(android.view.View) notifyViewEntered(android.view.View int android.graphics.Rect) requestAutofill(android.view.View) Typically the context is automatically created when the first view of the activity is
 focused because  View.onFocusChanged()  indirectly calls
  notifyViewEntered(android.view.View) . App developers can call  requestAutofill(android.view.View)  to
 explicitly create it (for example a custom view developer could offer a contextual menu action
 in a text-field view to let users manually request autofill).

  After the context is created the Android System creates a  ViewStructure 
 that represents the view hierarchy by calling
  View#dispatchProvideAutofillStructure(android.view.ViewStructure int)  in the root views
 of all application windows. By default  dispatchProvideAutofillStructure()  results in
 subsequent calls to  View#onProvideAutofillStructure(android.view.ViewStructure int)  and
  View#onProvideAutofillVirtualStructure(android.view.ViewStructure int)  for each view in
 the hierarchy.

  The resulting  ViewStructure  is then passed to the autofill service which
 parses it looking for views that can be autofilled. If the service finds such views it returns
 a data structure to the Android System containing the following optional info:

  Datasets used to autofill subsets of views in the activity.
    Id of views that the service can save their values for future autofilling.
  When the service returns datasets the Android System displays an autofill dataset picker
 UI associated with the view when the view is focused on and is part of a dataset.
 The application can be notified when the UI is shown by registering an
  AutofillCallback  through  registerCallback(android.view.autofill.AutofillManager.AutofillCallback) . When the user
 selects a dataset from the UI all views present in the dataset are autofilled through
 calls to  View#autofill(AutofillValue)  or  View#autofill(SparseArray) .

  When the service returns ids of savable views the Android System keeps track of changes
 made to these views so they can be used to determine if the autofill save UI is shown later.

  The context is then finished when one of the following occurs:

  commit()  is called or all savable views are gone.
    cancel()  is called.
  Finally after the autofill context is commited (i.e. not cancelled) the Android System
 shows an autofill save UI if the value of savable views have changed. If the user selects the
 option to Save the current value of the views is then sent to the autofill service.

  Additional notes It is safe to call  AutofillManager  methods from any thread.
 
  
 Requires the  PackageManager#FEATURE_AUTOFILL  feature which can be detected using  PackageManager.hasSystemFeature(String) .",
<android.icu.text.CaseMap.Title: CaseMap.Title wholeString()>,NEITHER,NEITHER,"Returns an instance that behaves like this one but
 titlecases the string as a whole rather than each word.
 (Titlecases only the character at index 0 possibly adjusted.) It is an error to specify multiple titlecasing iterator options together
 including both an option and an explicit BreakIterator.",,CaseMap.Title an options object with this option. |||,"Low-level case mapping options and methods. Immutable.
 ""Setters"" return instances with the union of the current and new options set.

 This class is not intended for public subclassing.",
"<android.net.wifi.aware.WifiAwareNetworkInfo: void writeToParcel(Parcel,int)>",NEITHER,NEITHER,Flatten this object in to a Parcel.,"dest Parcel : The Parcel in which the object should be written. |||
flags int : Additional flags about how the object should be written.
May be 0 or Parcelable.PARCELABLE_WRITE_RETURN_VALUE .
Value is either 0 or a combination of Parcelable.PARCELABLE_WRITE_RETURN_VALUE and android.os.Parcelable.PARCELABLE_ELIDE_DUPLICATES |||",void,"Wi-Fi Aware-specific network information. The information can be extracted from the
  NetworkCapabilities  of the network using
  NetworkCapabilities#getTransportInfo() .
 The  NetworkCapabilities  is provided by the connectivity service to apps e.g. received
 through the
  ConnectivityManager.NetworkCallback.onCapabilitiesChanged(android.net.Network android.net.NetworkCapabilities)  callback.
  
 The Wi-Fi Aware-specific network information include the peer's scoped link-local IPv6 address
 for the Wi-Fi Aware link as well as (optionally) the port and transport protocol specified by
 the peer.
 The scoped link-local IPv6 port and transport protocol can then be used to create a
  Socket  connection to the peer.
  
 Note: these are the peer's IPv6 and port information - not the local device's!","Provides classes to manage Wi-Fi functionality on the device. The Wi-Fi APIs provide a means by which applications can communicate
 with the lower-level wireless stack that provides Wi-Fi network access. Almost all
 information from the device supplicant is available including the connected network's
 link speed IP address negotiation state and more plus information about other
 networks that are available. Some other API features include the ability to
 scan add save terminate and initiate Wi-Fi connections. Some APIs may require the following user permissions: ACCESS_WIFI_STATE CHANGE_WIFI_STATE CHANGE_WIFI_MULTICAST_STATE Note:  Not all Android-powered devices provide Wi-Fi functionality.
 If your application uses Wi-Fi declare so with a  <uses-feature> 
 element in the manifest file: 
 <manifest ...>
     <uses-feature android:name=""android.hardware.wifi"" />
     ...
 </manifest>"
<android.net.wifi.rtt.ResponderLocation: SparseArray toCivicLocationSparseArray()>,NEITHER,SOURCE,,,SparseArray < String > the civic location represented as a SparseArray Valid keys to access the SparseArray can be found in CivicLocationKeys . Will return a null when there is no Civic Location defined. |||,"ResponderLocation is both a Location Configuration Information (LCI) decoder and a Location Civic
 Report (LCR) decoder for information received from a Wi-Fi Access Point (AP) during Wi-Fi RTT
 ranging process.

  This is based on the IEEE P802.11-REVmc/D8.0 spec section 9.4.2.22 under Measurement Report
 Element. Subelement location data-fields parsed from separate input LCI and LCR Information
 Elements are unified in this class. Note: The information provided by this class is broadcast by a responder (usually an Access
 Point) and passed on as-is. There is no guarantee this information is accurate or correct and
 as a result developers should carefully consider how this information should be used and provide
 corresponding advice to users.","Provides classes which allow applications to use Wi-Fi RTT (IEEE 802.11mc) to measure distance
     to supporting Access Points and peer devices. The primary entry point to Wi-Fi RTT capabilities is the
      WifiRttManager  class which is acquired by calling
      Context.getSystemService(Context.WIFI_RTT_RANGING_SERVICE) Some APIs may require the following user permissions: ACCESS_WIFI_STATE CHANGE_WIFI_STATE ACCESS_FINE_LOCATION Usage of the API is also gated by the device's Location Mode: whether it permits Wi-Fi based
 location to be queried. Note:  Not all Android-powered devices support Wi-Fi RTT
     functionality.
     If your application only works with Wi-Fi RTT (i.e. it should only be installed on devices which
     support Wi-Fi RTT) declare so with a  <uses-feature> 
     element in the manifest file: 
 <manifest ...>
     <uses-feature android:name=""android.hardware.wifi.rtt"" />
     ...
 </manifest>
  Alternatively if your application does not require Wi-Fi RTT but can take advantage of it if
     available you can perform
     the check at run-time in your code using  hasSystemFeature(String)  with  FEATURE_WIFI_RTT : 
     getPackageManager().hasSystemFeature(PackageManager.FEATURE_WIFI_RTT)"
"<android.telephony.mbms.StreamingServiceInfo: void writeToParcel(Parcel,int)>",NEITHER,NEITHER,Flatten this object in to a Parcel.,"dest Parcel : The Parcel in which the object should be written. |||
flags int : Additional flags about how the object should be written.
May be 0 or Parcelable.PARCELABLE_WRITE_RETURN_VALUE .
Value is either 0 or a combination of Parcelable.PARCELABLE_WRITE_RETURN_VALUE and android.os.Parcelable.PARCELABLE_ELIDE_DUPLICATES |||",void,Describes a single MBMS streaming service.,
<android.app.slice.SliceItem: CharSequence getText()>,NEITHER,SOURCE,,,CharSequence The text held by this FORMAT_TEXT SliceItem |||,"A SliceItem is a single unit in the tree structure of a  Slice .

 A SliceItem a piece of content and some hints about what that content
 means or how it should be displayed. The types of content can be:
  FORMAT_SLICE FORMAT_TEXT FORMAT_IMAGE FORMAT_ACTION FORMAT_INT FORMAT_LONG FORMAT_REMOTE_INPUT FORMAT_BUNDLE SliceItem Slice","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 designâ€”especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activityâ€”allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User ."
<android.net.IpSecTransform.Builder: IpSecTransform.Builder setEncryption(IpSecAlgorithm)>,NEITHER,SOURCE,Set the encryption algorithm. Encryption is mutually exclusive with authenticated encryption.,"algo IpSecAlgorithm : IpSecAlgorithm specifying the encryption to be applied.
This value must never be null . |||",IpSecTransform.Builder This value will never be null . |||,This class is used to build  IpSecTransform  objects.,
"<android.app.slice.SliceProvider: Uri insert(Uri,ContentValues)>",NEITHER,NEITHER,"Implement this to handle requests to insert a new row. As a courtesy
 call ContentResolver#notifyChange(android.net.Uri android.database.ContentObserver) after inserting. This method can be called from multiple
 threads as described in Processes
 and Threads .","uri Uri : The content:// URI of the insertion request.
This value must never be null . |||
values ContentValues : A set of column_name/value pairs to add to the database.
This value may be null . |||","Uri The URI for the newly inserted item.
 
 This value may be null . |||","A SliceProvider allows an app to provide content to be displayed in system spaces. This content
 is templated and can contain actions and the behavior of how it is surfaced is specific to the
 system surface.
  
 Slices are not currently live content. They are bound once and shown to the user. If the content
 changes due to a callback from user interaction then
  ContentResolver#notifyChange(Uri ContentObserver)  should be used to notify the system.
  
 The provider needs to be declared in the manifest to provide the authority for the app. The
 authority for most slices is expected to match the package of the application.
  
 <provider
     android:name=""com.example.mypkg.MySliceProvider""
     android:authorities=""com.example.mypkg"" />
  
 Slices can be identified by a Uri or by an Intent. To link an Intent with a slice the provider
 must have an  IntentFilter  matching the slice intent. When a slice is being requested via
 an intent  onMapIntentToUri(android.content.Intent)  can be called and is expected to return an
 appropriate Uri representing the slice.

  
 <provider
     android:name=""com.example.mypkg.MySliceProvider""
     android:authorities=""com.example.mypkg"">
     <intent-filter>
         <action android:name=""com.example.mypkg.intent.action.MY_SLICE_INTENT"" />
         <category android:name=""android.app.slice.category.SLICE"" />
     </intent-filter>
 </provider>","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 designâ€”especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activityâ€”allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User ."
<android.app.slice.Slice: List getItems()>,NEITHER,SOURCE,,,List < SliceItem > All child SliceItem s that this Slice contains. |||,"A slice is a piece of app content and actions that can be surfaced outside of the app.

  They are constructed using  Builder  in a tree structure
 that provides the OS some information about how the content should be displayed.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 designâ€”especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activityâ€”allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User ."
<android.view.textclassifier.TextLinks.TextLinkSpan: TextLinks.TextLink getTextLink()>,NEITHER,NEITHER,,,TextLinks.TextLink |||,A link identifying a substring of text and possible entity types for it.,
"<android.telephony.mbms.DownloadRequest: void writeToParcel(Parcel,int)>",NEITHER,NEITHER,Flatten this object in to a Parcel.,"out Parcel : The Parcel in which the object should be written. |||
flags int : Additional flags about how the object should be written.
May be 0 or Parcelable.PARCELABLE_WRITE_RETURN_VALUE .
Value is either 0 or a combination of Parcelable.PARCELABLE_WRITE_RETURN_VALUE and android.os.Parcelable.PARCELABLE_ELIDE_DUPLICATES |||",void,"Describes a request to download files over cell-broadcast. Instances of this class should be
 created by the app when requesting a download and instances of this class will be passed back
 to the app when the middleware updates the status of the download.",
<android.app.admin.DevicePolicyManager: String getGlobalPrivateDnsHost(ComponentName)>,NEITHER,SOURCE,Returns the system-wide Private DNS host.,"admin ComponentName : which DeviceAdminReceiver this request is associated with.
This value must never be null . |||",String The hostname used for Private DNS queries null if none is set. |||,"Public interface for managing policies enforced on a device. Most clients of this class must be
 registered with the system as a  device
 administrator . Additionally a device administrator may be registered as either a profile or
 device owner. A given method is accessible to all device administrators unless the documentation
 for that method specifies that it is restricted to either device or profile owners. Any
 application calling an api may only pass as an argument a device administrator component it
 owns. Otherwise a  SecurityException  will be thrown.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 designâ€”especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activityâ€”allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User ."
<android.hardware.camera2.params.MandatoryStreamCombination: CharSequence getDescription()>,NEITHER,SOURCE,Get the mandatory stream combination description.,,"CharSequence CharSequence with the mandatory combination description.
 
 This value will never be null . |||","Immutable class to store the available mandatory stream combination.

  A mandatory stream combination refers to a specific entry in the documented sets of
 required stream  CameraDevice#createCaptureSession .
 These combinations of streams are required to be supported by the camera device.

  The list of stream combinations is available by invoking
  CameraCharacteristics#get  and passing key
  CameraCharacteristics.SCALER_MANDATORY_STREAM_COMBINATIONS .","The android.hardware.camera2 package provides an interface to
 individual camera devices connected to an Android device. It replaces
 the deprecated  Camera  class. This package models a camera device as a pipeline which takes in
 input requests for capturing a single frame captures the single image
 per the request and then outputs one capture result metadata packet
 plus a set of output image buffers for the request. The requests are
 processed in-order and multiple requests can be in flight at
 once. Since the camera device is a pipeline with multiple stages
 having multiple requests in flight is required to maintain full
 framerate on most Android devices. To enumerate query and open available camera devices obtain a
  CameraManager  instance. Individual  CameraDevices  provide a set of static property information that
 describes the hardware device and the available settings and output
 parameters for the device. This information is provided through the
  CameraCharacteristics  object and is
 available through  getCameraCharacteristics(String) To capture or stream images from a camera device the application
 must first create a  camera capture session 
 with a set of output Surfaces for use with the camera device with
  createCaptureSession(SessionConfiguration) . Each
 Surface has to be pre-configured with an  appropriate
 size and format  (if applicable) to match the sizes and formats
 available from the camera device. A target Surface can be obtained
 from a variety of classes including  SurfaceView 
  SurfaceTexture  via
  Surface(SurfaceTexture) 
  MediaCodec   MediaRecorder 
  Allocation  and  ImageReader .
  Generally camera preview images are sent to  SurfaceView  or  TextureView  (via its
  SurfaceTexture ). Capture of JPEG images or
 RAW buffers for  DngCreator  can be
 done with  ImageReader  with the  JPEG  and  RAW_SENSOR  formats.  Application-driven
 processing of camera data in RenderScript OpenGL ES or directly in
 managed or native code is best done through  Allocation  with a YUV  Type   SurfaceTexture 
 and  ImageReader  with a  YUV_420_888  format respectively. The application then needs to construct a  CaptureRequest  which defines all the
 capture parameters needed by a camera device to capture a single
 image. The request also lists which of the configured output Surfaces
 should be used as targets for this capture. The CameraDevice has a
  factory method  for creating a  request builder  for a
 given use case which is optimized for the Android device the
 application is running on. Once the request has been set up it can be handed to the active
 capture session either for a one-shot  capture  or for
 an endlessly  repeating  use. Both methods also have a variant that accepts a list
 of requests to use as a burst capture / repeating burst. Repeating
 requests have a lower priority than captures so a request submitted
 through  capture()  while there's a repeating request
 configured will be captured before any new instances of the currently
 repeating (burst) capture will begin capture. After processing a request the camera device will produce a  TotalCaptureResult  object which contains
 information about the state of the camera device at time of capture
 and the final settings used. These may vary somewhat from the request
 if rounding or resolving contradictory parameters was necessary. The
 camera device will also send a frame of image data into each of the
 output  Surfaces  included in the request. These are produced
 asynchronously relative to the output CaptureResult sometimes
 substantially later."
"<android.telephony.SmsManager: String createAppSpecificSmsTokenWithPackageInfo(String,PendingIntent)>",NEITHER,SOURCE,"Create a single use app specific incoming SMS request for the calling package.

 This method returns a token that if included in a subsequent incoming SMS message and the
 SMS message has a prefix from the given prefixes list the provided intent will be
 sent with the SMS data to the calling package.

 The token is only good for one use within a reasonable amount of time. After an SMS has been
 received containing the token all subsequent SMS messages with the token will be routed as
 normal.

 An app can only have one request at a time if the app already has a request pending it will
 be replaced with a new request. Note: This method will never trigger an SMS disambiguation
 dialog. If this method is called on a device that has multiple active subscriptions this SmsManager instance has been created with getDefault() and no user-defined
 default subscription is defined the subscription ID associated with this message will be
 INVALID which will result in the operation being completed on the subscription associated
 with logical slot 0. Use getSmsManagerForSubscriptionId(int) to ensure the
 operation is performed on the correct subscription.","prefixes String : this is a list of prefixes string separated by REGEX_PREFIX_DELIMITER. The
matching SMS message should have at least one of the prefixes in the beginning of the
message.
This value may be null . |||
intent PendingIntent : this intent is sent when the matching SMS message is received.
This value must never be null . |||","String Token to include in an SMS message.
 
 This value may be null . |||","Manages SMS operations such as sending data text and pdu SMS messages.
 Get this object by calling the static method  getDefault() . To create an instance of
  SmsManager  associated with a specific subscription ID call
  getSmsManagerForSubscriptionId(int) . This is typically used for devices that support
 multiple active subscriptions at once.

  For information about how to behave as the default SMS app on Android 4.4 (API level 19)
 and higher see  Telephony .",
"<android.provider.MediaStore: String getVersion(Context,String)>",NEITHER,SOURCE,"Return an opaque version string describing the MediaStore state. Applications that import data from MediaStore into their own
 caches can use this to detect that MediaStore has undergone
 substantial changes and that data should be rescanned. No other assumptions should be made about the meaning of the version.","context Context : This value must never be null . |||
volumeName String : specific volume to obtain an opaque version string for.
Must be one of the values returned from getExternalVolumeNames(android.content.Context) .
This value must never be null . |||",String This value will never be null . |||,"The contract between the media provider and applications. Contains
 definitions for the supported URIs and columns.
  
 The media provider provides an indexed collection of common media types such
 as  Audio   Video  and  Images  from any attached
 storage devices. Each collection is organized based on the primary MIME type
 of the underlying content; for example  image/*  content is indexed
 under  Images . The  Files  collection provides a broad view
 across all collections and does not filter by MIME type.","Provides convenience classes to access the content providers supplied by
 Android. Android ships with a number of content providers that store common data such
 as contact informations calendar information and media files. These classes
 provide simplified methods of adding or retrieving data from these content
 providers. For information about how to use a content provider see the  Content Providers  developer
 guide."
"<android.app.Person: void writeToParcel(Parcel,int)>",NEITHER,NEITHER,Flatten this object in to a Parcel.,"dest Parcel : The Parcel in which the object should be written. |||
flags int : Value is either 0 or a combination of Parcelable.PARCELABLE_WRITE_RETURN_VALUE and android.os.Parcelable.PARCELABLE_ELIDE_DUPLICATES |||",void,"Provides an immutable reference to an entity that appears repeatedly on different surfaces of the
 platform. For example this could represent the sender of a message.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 designâ€”especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activityâ€”allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User ."
"<android.icu.text.Transliterator: void transliterate(Replaceable,Transliterator.Position)>",NEITHER,NEITHER,"Transliterates the portion of the text buffer that can be
 transliterated unambiguosly.  This is a convenience method; see transliterate(android.icu.text.Replaceable android.icu.text.Transliterator.Position java.lang.String) for details.","text Replaceable : the buffer holding transliterated and
untransliterated text |||
index Transliterator.Position : the start and limit of the text the position
of the cursor and the start and limit of transliteration. |||",void,"Transliterator  is an abstract class that transliterates text from one format to another. The most common
 kind of transliterator is a script or alphabet transliterator. For example a Russian to Latin transliterator
 changes Russian text written in Cyrillic characters to phonetically equivalent Latin characters. It does not
  translate  Russian to English! Transliteration unlike translation operates on characters without reference
 to the meanings of words and sentences.

  
 Although script conversion is its most common use a transliterator can actually perform a more general class of
 tasks. In fact  Transliterator  defines a very general API which specifies only that a segment of the
 input text is replaced by new text. The particulars of this conversion are determined entirely by subclasses of
  Transliterator .

  Transliterators are stateless Transliterator  objects are  stateless ; they retain no information between calls to
  transliterate() . As a result threads may share transliterators without synchronizing them. This might
 seem to limit the complexity of the transliteration operation. In practice subclasses perform complex
 transliterations by delaying the replacement of text until it is known that no other replacements are possible. In
 other words although the  Transliterator  objects are stateless the source text itself embodies all the
 needed information and delayed operation allows arbitrary complexity.

  Batch transliteration 
 The simplest way to perform transliteration is all at once on a string of existing text. This is referred to as
  batch  transliteration. For example given a string  input  and a transliterator  t 
 the call

  String result = t.transliterate(input);
  Replaceable Keyboard transliteration 
 Somewhat more involved is  keyboard  or incremental transliteration. This is the transliteration of text that
 is arriving from some source (typically the user's keyboard) one character at a time or in some other piecemeal
 fashion.

  
 In keyboard transliteration a  Replaceable  buffer stores the text. As text is inserted as much as
 possible is transliterated on the fly. This means a GUI that displays the contents of the buffer may show text being
 modified as each new character arrives.

  
 Consider the simple rule-based Transliterator:

  
 th>{theta} 
 t>{tau}
  
 t>|{tau} 
 {tau}h>{theta}
  transliterate() 
 Keyboard transliteration methods maintain a set of three indices that are updated with each call to
  transliterate()  including the cursor start and limit. These indices are changed by the method and
 they are passed in and out via a Position object. The  start  index marks the beginning of the substring
 that the transliterator will look at. It is advanced as text becomes committed (but it is not the committed index;
 that's the  cursor ). The  cursor  index described above marks the point at which the
 transliterator last stopped either because it reached the end or because it required more characters to
 disambiguate between possible inputs. The  cursor  can also be explicitly set by rules.
 Any characters before the  cursor  index are frozen; future keyboard
 transliteration calls within this input sequence will not change them. New text is inserted at the  limit 
 index which marks the end of the substring that the transliterator looks at.

  
 Because keyboard transliteration assumes that more characters are to arrive it is conservative in its operation. It
 only transliterates when it can do so unambiguously. Otherwise it waits for more characters to arrive. When the
 client code knows that no more characters are forthcoming perhaps because the user has performed some input
 termination operation then it should call  finishTransliteration()  to complete any pending
 transliterations.

  Inverses 
 Pairs of transliterators may be inverses of one another. For example if transliterator  A  transliterates
 characters by incrementing their Unicode value (so ""abc"" -> ""def"") and transliterator  B  decrements character
 values then  A  is an inverse of  B  and vice versa. If we compose  A  with  B  in a compound
 transliterator the result is the indentity transliterator that is a transliterator that does not change its input
 text.

 The  Transliterator  method  getInverse()  returns a transliterator's inverse if one exists
 or  null  otherwise. However the result of  getInverse()  usually will  not  be a true
 mathematical inverse. This is because true inverse transliterators are difficult to formulate. For example consider
 two transliterators:  AB  which transliterates the character 'A' to 'B' and  BA  which transliterates
 'B' to 'A'. It might seem that these are exact inverses since

  ""A"" x  AB  -> ""B"" 
 ""B"" x  BA  -> ""A"" ""ABCD"" x  AB  -> ""BBCD"" 
 ""BBCD"" x  BA  -> ""AACD"" AB BA BA AB AB .getInverse() BA Filtering Each transliterator has a filter which restricts changes to those characters selected by the filter. The
 filter affects just the characters that are changed -- the characters outside of the filter are still part of the
 context for the filter. For example in the following even though 'x' is filtered out and doesn't convert to y it does affect the conversion of 'a'.

  
 String rules = ""x > y; x{a} > b; "";
 Transliterator tempTrans = Transliterator.createFromRules(""temp"" rules Transliterator.FORWARD);
 tempTrans.setFilter(new UnicodeSet(""[a]""));
 String tempResult = tempTrans.transform(""xa"");
 // results in ""xb""
 IDs and display names 
 A transliterator is designated by a short identifier string or  ID . IDs follow the format
  source-destination  where  source  describes the entity being replaced and  destination 
 describes the entity replacing  source . The entities may be the names of scripts particular sequences of
 characters or whatever else it is that the transliterator converts to or from. For example a transliterator from
 Russian to Latin might be named ""Russian-Latin"". A transliterator from keyboard escape sequences to Latin-1
 characters might be named ""KeyboardEscape-Latin1"". By convention system entity names are in English with the
 initial letters of words capitalized; user entity names may follow any format so long as they do not contain dashes.

  
 In addition to programmatic IDs transliterator objects have display names for presentation in user interfaces
 returned by  getDisplayName(String) .

  Composed transliterators 
 In addition to built-in system transliterators like ""Latin-Greek"" there are also built-in  composed 
 transliterators. These are implemented by composing two or more component transliterators. For example if we have
 scripts ""A"" ""B"" ""C"" and ""D"" and we want to transliterate between all pairs of them then we need to write 12
 transliterators: ""A-B"" ""A-C"" ""A-D"" ""B-A""... ""D-A"" ""D-B"" ""D-C"". If it is possible to convert all scripts to an
 intermediate script ""M"" then instead of writing 12 rule sets we only need to write 8: ""A~M"" ""B~M"" ""C~M"" ""D~M""
 ""M~A"" ""M~B"" ""M~C"" ""M~D"". (This might not seem like a big win but it's really 2 n  vs.  n 2  -  n  so as  n  gets larger the gain becomes significant. With 9 scripts it's 18 vs. 72
 rule sets a big difference.) Note the use of ""~"" rather than ""-"" for the script separator here; this indicates that
 the given transliterator is intended to be composed with others rather than be used as is.

  
 Composed transliterators can be instantiated as usual. For example the system transliterator ""Devanagari-Gujarati""
 is a composed transliterator built internally as ""Devanagari~InterIndic;InterIndic~Gujarati"". When this
 transliterator is instantiated it appears externally to be a standard transliterator (e.g. getID() returns
 ""Devanagari-Gujarati"").

  Rule syntax A set of rules determines how to perform translations.
 Rules within a rule set are separated by semicolons (';').
 To include a literal semicolon prefix it with a backslash ('\').
 Unicode Pattern_White_Space is ignored.
 If the first non-blank character on a line is '#'
 the entire line is ignored as a comment.

  Each set of rules consists of two groups one forward and one
 reverse. This is a convention that is not enforced; rules for one
 direction may be omitted with the result that translations in
 that direction will not modify the source text. In addition
 bidirectional forward-reverse rules may be specified for
 symmetrical transformations.

  Note: Another description of the Transliterator rule syntax is available in
  section
 Transform Rules Syntax of UTS #35: Unicode LDML .
 The rules are shown there using arrow symbols â† and â†’ and â†”.
 ICU supports both those and the equivalent ASCII symbols < and > and <>.

  Rule statements take one of the following forms:

  $alefmadda=\\u0622; Variable definition.  The name on the
         left is assigned the text on the right. In this example
         after this statement instances of the left hand name
         "" $alefmadda "" will be replaced by
         the Unicode character U+0622. Variable names must begin
         with a letter and consist only of letters digits and
         underscores. Case is significant. Duplicate names cause
         an exception to be thrown that is variables cannot be
         redefined. The right hand side may contain well-formed
         text of any length including no text at all ("" $empty=; "").
         The right hand side may contain embedded  UnicodeSet 
         patterns for example "" $softvowel=[eiyEIY] "". ai>$alefmadda; Forward translation rule.  This rule
         states that the string on the left will be changed to the
         string on the right when performing forward
         transliteration. ai<$alefmadda; Reverse translation rule.  This rule
         states that the string on the right will be changed to
         the string on the left when performing reverse
         transliteration. ai<>$alefmadda; Bidirectional translation rule.  This
         rule states that the string on the right will be changed
         to the string on the left when performing forward
         transliteration and vice versa when performing reverse
         transliteration. Translation rules consist of a  match pattern  and an  output
 string . The match pattern consists of literal characters
 optionally preceded by context and optionally followed by
 context. Context characters like literal pattern characters
 must be matched in the text being transliterated. However unlike
 literal pattern characters they are not replaced by the output
 text. For example the pattern "" abc{def} ""
 indicates the characters "" def "" must be
 preceded by "" abc "" for a successful match.
 If there is a successful match "" def "" will
 be replaced but not "" abc "". The final ' } '
 is optional so "" abc{def "" is equivalent to
 "" abc{def} "". Another example is "" {123}456 ""
 (or "" 123}456 "") in which the literal
 pattern "" 123 "" must be followed by "" 456 "".

  The output string of a forward or reverse rule consists of
 characters to replace the literal pattern characters. If the
 output string contains the character ' | ' this is
 taken to indicate the location of the  cursor  after
 replacement. The cursor is the point in the text at which the
 next replacement if any will be applied. The cursor is usually
 placed within the replacement text; however it can actually be
 placed into the precending or following context by using the
 special character '@'. Examples:

  
     a {foo} z > | @ bar; # foo -> bar move cursor before a
     {foo} xyz > bar @@|; #Â foo -> bar cursor between y and z
  UnicodeSet UnicodeSet  patterns may appear anywhere that
 makes sense. They may appear in variable definitions.
 Contrariwise  UnicodeSet  patterns may themselves
 contain variable references such as "" $a=[a-z];$not_a=[^$a] ""
 or "" $range=a-z;$ll=[$range] "".

  UnicodeSet  patterns may also be embedded directly
 into rule strings. Thus the following two rules are equivalent:

  
     $vowel=[aeiou]; $vowel>'*'; # One way to do this
     [aeiou]>'*'; # Another way
  See  UnicodeSet  for more documentation and examples.

  Segments Segments of the input string can be matched and copied to the
 output string. This makes certain sets of rules simpler and more
 general and makes reordering possible. For example:

  
     ([a-z]) > $1 $1; # double lowercase letters
     ([:Lu:]) ([:Ll:]) > $2 $1; # reverse order of Lu-Ll pairs
  The segment of the input string to be copied is delimited by
 "" ( "" and "" ) "". Up to
 nine segments may be defined. Segments may not overlap. In the
 output string "" $1 "" through "" $9 ""
 represent the input string segments in left-to-right order of
 definition.

  Anchors Patterns can be anchored to the beginning or the end of the text. This is done with the
 special characters ' ^ ' and ' $ '. For example:

  
   ^ aÂ Â  > 'BEG_A'; Â Â # match 'a' at start of text
   Â  aÂ Â  > 'A'; # match other instances of 'a'
   Â  z $ > 'END_Z'; Â Â # match 'z' at end of text
   Â  zÂ Â  > 'Z';Â Â Â Â Â Â  # match other instances of 'z'
  It is also possible to match the beginning or the end of the text using a  UnicodeSet .
 This is done by including a virtual anchor character ' $ ' at the end of the
 set pattern. Although this is usually the match chafacter for the end anchor the set will
 match either the beginning or the end of the text depending on its placement. For
 example:

  
   $x = [a-z$]; Â Â # match 'a' through 'z' OR anchor
   $x 1Â Â Â  > 2;Â Â  # match '1' after a-z or at the start
   Â Â  3 $x > 4; Â Â # match '3' before a-z or at the end
  Example The following example rules illustrate many of the features of
 the rule language.

  Rule 1. abc{def}>x|y Rule 2. xyz>r Rule 3. yz>q Applying these rules to the string "" adefabcdefz ""
 yields the following results:

  |adefabcdefz Initial state no rules match. Advance
         cursor. a|defabcdefz Still no match. Rule 1 does not match
         because the preceding context is not present. ad|efabcdefz Still no match. Keep advancing until
         there is a match... ade|fabcdefz ... adef|abcdefz ... adefa|bcdefz ... adefab|cdefz ... adefabc|defz Rule 1 matches; replace "" def ""
         with "" xy "" and back up the cursor
         to before the ' y '. adefabcx|yz Although "" xyz "" is
         present rule 2 does not match because the cursor is
         before the ' y ' not before the ' x '.
         Rule 3 does match. Replace "" yz ""
         with "" q "". adefabcxq| The cursor is at the end;
         transliteration is complete. The order of rules is significant. If multiple rules may match
 at some point the first matching rule is applied.

  Forward and reverse rules may have an empty output string.
 Otherwise an empty left or right hand side of any statement is a
 syntax error.

  Single quotes are used to quote any character other than a
 digit or letter. To specify a single quote itself inside or
 outside of quotes use two single quotes in a row. For example
 the rule "" '>'>o''clock "" changes the
 string "" > "" to the string "" o'clock "".

  Notes While a Transliterator is being built from rules it checks that
 the rules are added in proper order. For example if the rule
 ""a>x"" is followed by the rule ""ab>y""
 then the second rule will throw an exception. The reason is that
 the second rule can never be triggered since the first rule
 always matches anything it matches. In other words the first
 rule  masks  the second rule.",
<android.view.textclassifier.TextClassificationContext.Builder: TextClassificationContext build()>,NEITHER,NEITHER,Builds the text classification context object.,,"TextClassificationContext the built TextClassificationContext object
 
 This value will never be null . |||",A builder for building a TextClassification context.,
<android.app.RemoteInput: int getResultsSource(Intent)>,NEITHER,NEITHER,Get the source of the RemoteInput results.,"intent Intent : The intent object that fired in response to an action or content intent
which also had one or more remote input requested. |||","int The source of the results. If no source was set SOURCE_FREE_FORM_INPUT will
 be returned.
 
 Value is SOURCE_FREE_FORM_INPUT or SOURCE_CHOICE |||","A  RemoteInput  object specifies input to be collected from a user to be passed along with
 an intent inside a  PendingIntent  that is sent.
 Always use  RemoteInput.Builder  to create instances of this class.
   See
  Replying
 to notifications  for more information on how to use this class.

  The following example adds a  RemoteInput  to a  Notification.Action 
 sets the result key as  quick_reply  and sets the label as  Quick reply .
 Users are prompted to input a response when they trigger the action. The results are sent along
 with the intent and can be retrieved with the result key (provided to the  Builder 
 constructor) from the Bundle returned by  getResultsFromIntent(Intent) .

  
 public static final String KEY_QUICK_REPLY_TEXT = ""quick_reply"";
 Notification.Action action = new Notification.Action.Builder(
         R.drawable.reply ""Reply"" actionIntent)
          .addRemoteInput(new RemoteInput.Builder(KEY_QUICK_REPLY_TEXT)
                 .setLabel(""Quick reply"").build() )
         .build(); When the  PendingIntent  is fired the intent inside will contain the
 input results if collected. To access these results use the  getResultsFromIntent(Intent) 
 function. The result values will present under the result key passed to the  Builder 
 constructor.

  
 public static final String KEY_QUICK_REPLY_TEXT = ""quick_reply"";
 Bundle results = RemoteInput.getResultsFromIntent(intent);
 if (results != null) {
     CharSequence quickReplyResult = results.getCharSequence(KEY_QUICK_REPLY_TEXT);
 }","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 designâ€”especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activityâ€”allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User ."
<android.app.Person: String getKey()>,NEITHER,SOURCE,,,String the key provided for this person or null if no key was provided. |||,"Provides an immutable reference to an entity that appears repeatedly on different surfaces of the
 platform. For example this could represent the sender of a message.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 designâ€”especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activityâ€”allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User ."
"<android.app.admin.DevicePolicyManager: void setCrossProfileCalendarPackages(ComponentName,Set)>",NEITHER,NEITHER,"Allows a set of packages to access cross-profile calendar APIs. Called by a profile owner of a managed profile. Calling with a null value for the set disables the restriction so that all
 packages are allowed to access cross-profile calendar APIs. Calling with an empty set
 disallows all packages from accessing cross-profile calendar APIs. If this method isn't
 called no package is allowed to access cross-profile calendar APIs by default.","admin ComponentName : which DeviceAdminReceiver this request is associated with
This value must never be null . |||
packageNames Set : set of packages to be whitelisted
This value may be null . |||",void,"Public interface for managing policies enforced on a device. Most clients of this class must be
 registered with the system as a  device
 administrator . Additionally a device administrator may be registered as either a profile or
 device owner. A given method is accessible to all device administrators unless the documentation
 for that method specifies that it is restricted to either device or profile owners. Any
 application calling an api may only pass as an argument a device administrator component it
 owns. Otherwise a  SecurityException  will be thrown.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 designâ€”especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activityâ€”allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User ."
<android.net.wifi.WifiNetworkSuggestion.Builder: WifiNetworkSuggestion.Builder setSsid(String)>,NEITHER,SOURCE,Set the unicode SSID for the network.,"ssid String : The SSID of the network. It must be valid Unicode.
This value must never be null . |||","WifiNetworkSuggestion.Builder Instance of Builder to enable chaining of the builder method.
 This value will never be null . |||",Builder used to create  WifiNetworkSuggestion  objects.,"Provides classes to manage Wi-Fi functionality on the device. The Wi-Fi APIs provide a means by which applications can communicate
 with the lower-level wireless stack that provides Wi-Fi network access. Almost all
 information from the device supplicant is available including the connected network's
 link speed IP address negotiation state and more plus information about other
 networks that are available. Some other API features include the ability to
 scan add save terminate and initiate Wi-Fi connections. Some APIs may require the following user permissions: ACCESS_WIFI_STATE CHANGE_WIFI_STATE CHANGE_WIFI_MULTICAST_STATE Note:  Not all Android-powered devices provide Wi-Fi functionality.
 If your application uses Wi-Fi declare so with a  <uses-feature> 
 element in the manifest file: 
 <manifest ...>
     <uses-feature android:name=""android.hardware.wifi"" />
     ...
 </manifest>"
"<android.telephony.CellSignalStrengthTdscdma: void writeToParcel(Parcel,int)>",NEITHER,NEITHER,Implement the Parcelable interface,"dest Parcel : The Parcel in which the object should be written. |||
flags int : Additional flags about how the object should be written.
May be 0 or Parcelable.PARCELABLE_WRITE_RETURN_VALUE .
Value is either 0 or a combination of Parcelable.PARCELABLE_WRITE_RETURN_VALUE and android.os.Parcelable.PARCELABLE_ELIDE_DUPLICATES |||",void,Abstract base class for cell phone signal strength related information.,
"<android.bluetooth.BluetoothHidDevice: boolean registerApp(BluetoothHidDeviceAppSdpSettings,BluetoothHidDeviceAppQosSettings,BluetoothHidDeviceAppQosSettings,Executor,BluetoothHidDevice.Callback)>",NEITHER,NEITHER,"Registers application to be used for HID device. Connections to HID Device are only possible
 when application is registered. Only one application can be registered at one time. When an
 application is registered the HID Host service will be disabled until it is unregistered.
 When no longer used application should be unregistered using unregisterApp() . The
 app will be automatically unregistered if it is not foreground. The registration status
 should be tracked by the application by handling callback from Callback#onAppStatusChanged.
 The app registration status is not related to the return value of this method.","sdp BluetoothHidDeviceAppSdpSettings : BluetoothHidDeviceAppSdpSettings object of HID Device SDP record. The HID
Device SDP record is required. |||
inQos BluetoothHidDeviceAppQosSettings : BluetoothHidDeviceAppQosSettings object of Incoming QoS Settings. The
Incoming QoS Settings is not required. Use null or default
BluetoothHidDeviceAppQosSettings.Builder for default values. |||
outQos BluetoothHidDeviceAppQosSettings : BluetoothHidDeviceAppQosSettings object of Outgoing QoS Settings. The
Outgoing QoS Settings is not required. Use null or default
BluetoothHidDeviceAppQosSettings.Builder for default values. |||
executor Executor : Executor object on which callback will be executed. The Executor
object is required. |||
callback BluetoothHidDevice.Callback : Callback object to which callback messages will be sent. The Callback
object is required. |||",boolean true if the command is successfully sent; otherwise false. |||,"Provides the public APIs to control the Bluetooth HID Device profile.

  BluetoothHidDevice is a proxy object for controlling the Bluetooth HID Device Service via IPC.
 Use  BluetoothAdapter#getProfileProxy  to get the BluetoothHidDevice proxy object.","Provides classes that manage Bluetooth functionality such as scanning for
 devices connecting with devices and managing data transfer between devices.
 The Bluetooth API supports both ""Classic Bluetooth"" and Bluetooth Low Energy. For more information about Classic Bluetooth see the
  Bluetooth  guide.
 For more information about Bluetooth Low Energy see the
  
 Bluetooth Low Energy  (BLE) guide. The Bluetooth APIs let applications: Scan for other Bluetooth devices (including BLE devices). Query the local Bluetooth adapter for paired Bluetooth devices. Establish RFCOMM channels/sockets. Connect to specified sockets on other devices. Transfer data to and from other devices. Communicate with BLE devices such as proximity sensors heart rate
     monitors fitness devices and so on. Act as a GATT client or a GATT server (BLE). 
 To perform Bluetooth communication using these APIs an application must
 declare the  BLUETOOTH  permission. Some
 additional functionality such as requesting device discovery
 also requires the  BLUETOOTH_ADMIN 
 permission.
  Note: 
 Not all Android-powered devices provide Bluetooth functionality."