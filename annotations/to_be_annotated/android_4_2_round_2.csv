,Description,Parameters,Return,ApiLevel,ClassDescription,PackageDescription,sensitive data?,shared resource?,sensitive shared resource?,produces sensitive data from shared resource?,writes sensitive data to shared resource?,Source?,Sink?
"<android.accounts.AccountManager: AccountManagerFuture removeAccount(Account,AccountManagerCallback,Handler)>","This method was deprecated
      in API level 22. use removeAccount(android.accounts.Account android.app.Activity android.accounts.AccountManagerCallback android.os.Handler) instead Removes an account from the AccountManager.  Does nothing if the account
 does not exist.  Does not delete the account from the server.
 The authenticator may have its own policies preventing account
 deletion in which case the account will not be deleted. This method requires the caller to have a signature match with the
 authenticator that manages the specified account. NOTE: If targeting your app to work on API level 22 and before
 MANAGE_ACCOUNTS permission is needed for those platforms. See docs for
 this function in API level 22. Requires android.Manifest.permission.MANAGE_ACCOUNTS","account Account : The Account to remove |||
callback AccountManagerCallback : Callback to invoke when the request completes
null for no callback |||
handler Handler : Handler identifying the callback thread
null for the main thread |||","AccountManagerFuture < Boolean > An AccountManagerFuture which resolves to a Boolean
     true if the account has been successfully removed |||",5,"This class provides access to a centralized registry of the user's
 online accounts.  The user enters credentials (username and password) once
 per account granting applications access to online resources with
 ""one-click"" approval.

  Different online services have different ways of handling accounts and
 authentication so the account manager uses pluggable  authenticator 
 modules for different  account types .  Authenticators (which may be
 written by third parties) handle the actual details of validating account
 credentials and storing account information.  For example Google Facebook
 and Microsoft Exchange each have their own authenticator.

  Many servers support some notion of an  authentication token 
 which can be used to authenticate a request to the server without sending
 the user's actual password.  (Auth tokens are normally created with a
 separate request which does include the user's credentials.)  AccountManager
 can generate auth tokens for applications so the application doesn't need to
 handle passwords directly.  Auth tokens are normally reusable and cached by
 AccountManager but must be refreshed periodically.  It's the responsibility
 of applications to  invalidate  auth tokens when they stop working so
 the AccountManager knows it needs to regenerate them.

  Applications accessing a server normally go through these steps:

  Get an instance of AccountManager using  get(android.content.Context) .

  List the available accounts using  getAccountsByType(String)  or
  getAccountsByTypeAndFeatures(String String[] AccountManagerCallback  Handler) .  Normally applications will only
 be interested in accounts with one particular  type  which
 identifies the authenticator.  Account  features  are used to
 identify particular account subtypes and capabilities.  Both the account
 type and features are authenticator-specific strings and must be known by
 the application in coordination with its preferred authenticators.

  Select one or more of the available accounts possibly by asking the
 user for their preference.  If no suitable accounts are available
  addAccount(String String String[] Bundle Activity AccountManagerCallback  Handler)  may be called to prompt the user to create an
 account of the appropriate type.

  Important:  If the application is using a previously remembered
 account selection it must make sure the account is still in the list
 of accounts returned by  getAccountsByType(String) .  Requesting an auth token
 for an account no longer on the device results in an undefined failure.

  Request an auth token for the selected account(s) using one of the
  getAuthToken(Account String Bundle Activity AccountManagerCallback  Handler)  methods or related helpers.  Refer to the description
 of each method for exact usage and error handling details.

  Make the request using the auth token.  The form of the auth token
 the format of the request and the protocol used are all specific to the
 service you are accessing.  The application may use whatever network and
 protocol libraries are useful.

  Important:  If the request fails with an authentication error
 it could be that a cached auth token is stale and no longer honored by
 the server.  The application must call  invalidateAuthToken(String String)  to remove
 the token from the cache otherwise requests will continue failing!  After
 invalidating the auth token immediately go back to the ""Request an auth
 token"" step above.  If the process fails the second time then it can be
 treated as a ""genuine"" authentication failure and the user notified or other
 appropriate actions taken.
  Some AccountManager methods may need to interact with the user to
 prompt for credentials present options or ask the user to add an account.
 The caller may choose whether to allow AccountManager to directly launch the
 necessary user interface and wait for the user or to return an Intent which
 the caller may use to launch the interface or (in some cases) to install a
 notification which the user can select at any time to launch the interface.
 To have AccountManager launch the interface directly the caller must supply
 the current foreground  Activity  context.

  Many AccountManager methods take  AccountManagerCallback  and
  Handler  as parameters.  These methods return immediately and
 run asynchronously. If a callback is provided then
  AccountManagerCallback#run  will be invoked on the Handler's
 thread when the request completes successfully or not.
 The result is retrieved by calling  AccountManagerFuture#getResult() 
 on the  AccountManagerFuture  returned by the method (and also passed
 to the callback).  This method waits for the operation to complete (if
 necessary) and either returns the result or throws an exception if an error
 occurred during the operation.  To make the request synchronously call
  AccountManagerFuture#getResult()  immediately on receiving the
 future from the method; no callback need be supplied.

  Requests which may block including
  AccountManagerFuture#getResult()  must never be called on
 the application's main event thread.  These operations throw
  IllegalStateException  if they are used on the main thread.",,,,,,,,
<android.app.FragmentBreadCrumbs: void setActivity(Activity)>,"Attach the bread crumbs to their activity.  This must be called once
 when creating the bread crumbs.",a Activity |||,void,11,"A Fragment is a piece of an application's user interface or behavior
 that can be placed in an  Activity .  Interaction with fragments
 is done through  FragmentManager  which can be obtained via
  Activity#getFragmentManager()  and
  Fragment#getFragmentManager() .

  The Fragment class can be used many ways to achieve a wide variety of
 results. In its core it represents a particular operation or interface
 that is running within a larger  Activity .  A Fragment is closely
 tied to the Activity it is in and can not be used apart from one.  Though
 Fragment defines its own lifecycle that lifecycle is dependent on its
 activity: if the activity is stopped no fragments inside of it can be
 started; when the activity is destroyed all fragments will be destroyed.

  All subclasses of Fragment must include a public no-argument constructor.
 The framework will often re-instantiate a fragment class when needed
 in particular during state restore and needs to be able to find this
 constructor to instantiate it.  If the no-argument constructor is not
 available a runtime exception will occur in some cases during state
 restore.

  Topics covered here:
  Older Platforms Lifecycle Layout Back Stack","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.app.Dialog: void unregisterForContextMenu(View)>,,view View : This value cannot be null . |||,void,1,"Base class for Dialogs.

  Note: Activities provide a facility to manage the creation saving and
 restoring of dialogs. See  Activity#onCreateDialog(int) 
  Activity#onPrepareDialog(int Dialog) 
  Activity#showDialog(int)  and  Activity#dismissDialog(int) . If
 these methods are used  getOwnerActivity()  will return the Activity
 that managed this dialog.

  Often you will want to have a Dialog display on top of the current
 input method because there is no reason for it to accept text.  You can
 do this by setting the  WindowManager.LayoutParams#FLAG_ALT_FOCUSABLE_IM  window flag (assuming
 your Dialog takes input focus as it the default) with the following code:

  
 getWindow().setFlags(WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM
         WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.view.ViewPropertyAnimator: ViewPropertyAnimator y(float)>,"This method will cause the View's y property to be animated to the
 specified value. Animations already running on the property will be canceled.",value float : The value to be animated to. |||,ViewPropertyAnimator This object allowing calls to methods in this class to be chained. |||,12,"This class enables automatic and optimized animation of select properties on View objects.
 If only one or two properties on a View object are being animated then using an
  ObjectAnimator  is fine; the property setters called by ObjectAnimator
 are well equipped to do the right thing to set the property and invalidate the view
 appropriately. But if several properties are animated simultaneously or if you just want a
 more convenient syntax to animate a specific property then ViewPropertyAnimator might be
 more well-suited to the task.

  This class may provide better performance for several simultaneous animations because
 it will optimize invalidate calls to take place only once for several properties instead of each
 animated property independently causing its own invalidation. Also the syntax of using this
 class could be easier to use because the caller need only tell the View object which
 property to animate and the value to animate either to or by and this class handles the
 details of configuring the underlying Animator class and starting it. This class is not constructed by the caller but rather by the View whose properties
 it will animate. Calls to  View.animate()  will return a reference
 to the appropriate ViewPropertyAnimator object for that View.",,,,,,,,
<android.speech.tts.TextToSpeech: int setLanguage(Locale)>,"Sets the text-to-speech language.
 The TTS engine will try to use the closest match to the specified
 language as represented by the Locale but there is no guarantee that the exact same Locale
 will be used. Use isLanguageAvailable(java.util.Locale) to check the level of support
 before choosing the language to use for the next utterances.

 This method sets the current voice to the default one for the given Locale; getVoice() can be used to retrieve it.",loc Locale : The locale describing the language to be used. |||,int Code indicating the support status for the locale. See LANG_AVAILABLE  LANG_COUNTRY_AVAILABLE  LANG_COUNTRY_VAR_AVAILABLE  LANG_MISSING_DATA and LANG_NOT_SUPPORTED . |||,4,"Synthesizes speech from text for immediate playback or to create a sound file.
  A TextToSpeech instance can only be used to synthesize text once it has completed its
 initialization. Implement the  TextToSpeech.OnInitListener  to be
 notified of the completion of the initialization. 
 When you are done using the TextToSpeech instance call the  shutdown()  method
 to release the native resources used by the TextToSpeech engine.",,,,,,,,
"<android.view.inputmethod.InputMethodManager: void showSoftInputFromInputMethod(IBinder,int)>","This method was deprecated
      in API level 28. Use InputMethodService#requestShowSelf(int) instead. This method was
 intended for IME developers who should be accessing APIs through the service. APIs in this
 class are intended for app developers interacting with the IME. Show the input method's soft input area so the user
 sees the input method window and can interact with it.
 This can only be called from the currently active input method
 as validated by the given token.","token IBinder : Supplies the identifying token given to an input method
when it was started which allows it to perform this operation on
itself. |||
flags int : Provides additional operating flags.  Currently may be
0 or have the SHOW_IMPLICIT or SHOW_FORCED bit set. |||",void,3,"Central system API to the overall input method framework (IMF) architecture
 which arbitrates interaction between applications and the current input method.

  Topics covered here:
  Architecture Overview Applications Input Methods Security Architecture Overview There are three primary parties involved in the input method
 framework (IMF) architecture:  The  input method manager  as expressed by this class
 is the central point of the system that manages interaction between all
 other parts.  It is expressed as the client-side API here which exists
 in each application context and communicates with a global system service
 that manages the interaction across all processes.
   An  input method (IME)  implements a particular
 interaction model allowing the user to generate text.  The system binds
 to the current input method that is in use causing it to be created and run
 and tells it when to hide and show its UI.  Only one IME is running at a time.
   Multiple  client applications  arbitrate with the input
 method manager for input focus and control over the state of the IME.  Only
 one such client is ever active (working with the IME) at a time.
  Applications In most cases applications that are using the standard
  TextView  or its subclasses will have little they need
 to do to work well with soft input methods.  The main things you need to
 be aware of are:  Properly set the  R.attr.inputType  in your editable
 text views so that the input method will have enough context to help the
 user in entering text into them.
   Deal well with losing screen space when the input method is
 displayed.  Ideally an application should handle its window being resized
 smaller but it can rely on the system performing panning of the window
 if needed.  You should set the  R.attr.windowSoftInputMode 
 attribute on your activity or the corresponding values on windows you
 create to help the system determine whether to pan or resize (it will
 try to determine this automatically but may get it wrong).
   You can also control the preferred soft input state (open closed etc)
 for your window using the same  R.attr.windowSoftInputMode 
 attribute.
  More finer-grained control is available through the APIs here to directly
 interact with the IMF and its IME -- either showing or hiding the input
 area letting the user pick an input method etc. For the rare people amongst us writing their own text editors you
 will need to implement  View.onCreateInputConnection(EditorInfo) 
 to return a new instance of your own  InputConnection  interface
 allowing the IME to interact with your editor. Input Methods An input method (IME) is implemented
 as a  Service  typically deriving from
  InputMethodService .  It must provide
 the core  InputMethod  interface though this is normally handled by
  InputMethodService  and implementors will
 only need to deal with the higher-level API there. InputMethodService Security There are a lot of security issues associated with input methods
 since they essentially have freedom to completely drive the UI and monitor
 everything the user enters.  The Android input method framework also allows
 arbitrary third party IMEs so care must be taken to restrict their
 selection and interactions. Here are some key points about the security architecture behind the
 IMF: Only the system is allowed to directly access an IME's
  InputMethod  interface via the
  Manifest.permission.BIND_INPUT_METHOD  permission.  This is
 enforced in the system by not binding to an input method service that does
 not require this permission so the system can guarantee no other untrusted
 clients are accessing the current input method outside of its control. There may be many client processes of the IMF but only one may
 be active at a time.  The inactive clients can not interact with key
 parts of the IMF through the mechanisms described below. Clients of an input method are only given access to its
  InputMethodSession  interface.  One instance of this interface is
 created for each client and only calls from the session associated with
 the active client will be processed by the current IME.  This is enforced
 by  AbstractInputMethodService  for normal
 IMEs but must be explicitly handled by an IME that is customizing the
 raw  InputMethodSession  implementation. Only the active client's  InputConnection  will accept
 operations.  The IMF tells each client process whether it is active and
 the framework enforces that in inactive processes calls on to the current
 InputConnection will be ignored.  This ensures that the current IME can
 only deliver events and text edits to the UI that the user sees as
 being in focus. An IME can never interact with an  InputConnection  while
 the screen is off.  This is enforced by making all clients inactive while
 the screen is off and prevents bad IMEs from driving the UI when the user
 can not be aware of its behavior. A client application can ask that the system let the user pick a
 new IME but can not programmatically switch to one itself.  This avoids
 malicious applications from switching the user to their own IME which
 remains running when the user navigates away to another application.  An
 IME on the other hand  is  allowed to programmatically switch
 the system to another IME since it already has full control of user
 input. The user must explicitly enable a new IME in settings before
 they can switch to it to confirm with the system that they know about it
 and want to make it available for use. PackageManager#FEATURE_INPUT_METHODS PackageManager.hasSystemFeature(String)",,,,,,,,
"<android.content.ContentProviderClient: int update(Uri,ContentValues,String,String)>",See ContentProvider#update,"url Uri : This value cannot be null . |||
values ContentValues : This value may be null . |||
selection String : This value may be null . |||
selectionArgs String : This value may be null . |||",int |||,5,"Content providers are one of the primary building blocks of Android applications providing
 content to applications. They encapsulate data and provide it to applications through the single
  ContentResolver  interface. A content provider is only required if you need to share
 data between multiple applications. For example the contacts data is used by multiple
 applications and must be stored in a content provider. If you don't need to share data amongst
 multiple applications you can use a database directly via
  SQLiteDatabase .

  When a request is made via
 a  ContentResolver  the system inspects the authority of the given URI and passes the
 request to the content provider registered with the authority. The content provider can interpret
 the rest of the URI however it wants. The  UriMatcher  class is helpful for parsing
 URIs. The primary methods that need to be implemented are:
  onCreate()  which is called to initialize the provider query(Uri String[] Bundle CancellationSignal)  which returns data to the caller insert(Uri ContentValues)  which inserts new data into the content provider update(Uri ContentValues String String[])  which updates existing data in the content provider delete(Uri String String[])  which deletes data from the content provider getType(Uri)  which returns the MIME type of data in the content provider Requests to  ContentResolver  are automatically forwarded to the appropriate
 ContentProvider instance so subclasses don't have to worry about the details of
 cross-process calls.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.animation.ValueAnimator: void end()>,"Ends the animation. This causes the animation to assign the end value of the property being
 animated then calling the Animator.AnimatorListener.onAnimationEnd(Animator) method on
 its listeners. This method must be called on the thread that is running the animation.",,void,11,"This class provides a simple timing engine for running animations
 which calculate animated values and set them on target objects.

  There is a single timing pulse that all animations use. It runs in a
 custom handler to ensure that property changes happen on the UI thread. By default ValueAnimator uses non-linear time interpolation via the
  AccelerateDecelerateInterpolator  class which accelerates into and decelerates
 out of an animation. This behavior can be changed by calling
  ValueAnimator#setInterpolator(TimeInterpolator) . Animators can be created from either code or resource files. Here is an example
 of a ValueAnimator resource file: <animator xmlns:android=""http://schemas.android.com/apk/res/android""
    android:duration=""1000""
    android:valueFrom=""1""
    android:valueTo=""0""
    android:valueType=""floatType""
    android:repeatCount=""1""
    android:repeatMode=""reverse""/> Starting from API 23 it is also possible to use a combination of  PropertyValuesHolder 
 and  Keyframe  resource tags to create a multi-step animation.
 Note that you can specify explicit fractional values (from 0 to 1) for
 each keyframe to determine when in the overall duration the animation should arrive at that
 value. Alternatively you can leave the fractions off and the keyframes will be equally
 distributed within the total duration: <animator xmlns:android=""http://schemas.android.com/apk/res/android""
          android:duration=""1000""
          android:repeatCount=""1""
          android:repeatMode=""reverse"">
    <propertyValuesHolder>
        <keyframe android:fraction=""0"" android:value=""1""/>
        <keyframe android:fraction="".2"" android:value="".4""/>
        <keyframe android:fraction=""1"" android:value=""0""/>
    </propertyValuesHolder>
</animator>","These classes provide functionality for the property animation system which allows you
 to animate object properties of any type.  int   float  and hexadecimal
 color values are supported by default. You can animate any other type by telling the system how
 to calculate the values for that given type with a custom  TypeEvaluator .
  For more information see the
  Animation  guide. 
 You can set many different types of interpolators (contained in  android.view.animation )
 specify  keyframes  or group animations to play sequentially
 or simultaneously (with  AnimatorSet ) to further control your animation
 behaviors.",,,,,,,
<android.content.ContentProviderClient: String getType(Uri)>,See ContentProvider#getType,url Uri : This value cannot be null . |||,String This value may be null . |||,5,"Content providers are one of the primary building blocks of Android applications providing
 content to applications. They encapsulate data and provide it to applications through the single
  ContentResolver  interface. A content provider is only required if you need to share
 data between multiple applications. For example the contacts data is used by multiple
 applications and must be stored in a content provider. If you don't need to share data amongst
 multiple applications you can use a database directly via
  SQLiteDatabase .

  When a request is made via
 a  ContentResolver  the system inspects the authority of the given URI and passes the
 request to the content provider registered with the authority. The content provider can interpret
 the rest of the URI however it wants. The  UriMatcher  class is helpful for parsing
 URIs. The primary methods that need to be implemented are:
  onCreate()  which is called to initialize the provider query(Uri String[] Bundle CancellationSignal)  which returns data to the caller insert(Uri ContentValues)  which inserts new data into the content provider update(Uri ContentValues String String[])  which updates existing data in the content provider delete(Uri String String[])  which deletes data from the content provider getType(Uri)  which returns the MIME type of data in the content provider Requests to  ContentResolver  are automatically forwarded to the appropriate
 ContentProvider instance so subclasses don't have to worry about the details of
 cross-process calls.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
"<android.widget.TextView: void setTypeface(Typeface,int)>","Sets the typeface and style in which the text should be displayed
 and turns on the fake bold and italic bits in the Paint if the
 Typeface that you provided does not have all the bits in the
 style that you specified. Related XML Attributes: android:typeface 
android:textStyle","tf Typeface : This value may be null . |||
style int : Value is Typeface.NORMAL  Typeface.BOLD  Typeface.ITALIC or Typeface.BOLD_ITALIC |||",void,1,"A user interface element that displays text to the user.
 To provide user-editable text see  EditText .
  
 The following code sample shows a typical use with an XML layout
 and code to modify the contents of the text view:
  
 <LinearLayout
      xmlns:android=""http://schemas.android.com/apk/res/android""
      android:layout_width=""match_parent""
      android:layout_height=""match_parent"">
    <TextView
        android:id=""@+id/text_view_id""
        android:layout_height=""wrap_content""
        android:layout_width=""wrap_content""
        android:text=""@string/hello"" />
 </LinearLayout>
  
 This code sample demonstrates how to modify the contents of the text view
 defined in the previous XML layout:
  
 public class MainActivity extends Activity {

    protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_main);
         final TextView helloTextView = (TextView) findViewById(R.id.text_view_id);
         helloTextView.setText(R.string.user_greeting);
     }
 }
  
 To customize the appearance of TextView see  Styles and Themes .
  XML attributes 
 See  TextView Attributes 
  View Attributes","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.content.ContextWrapper: void setWallpaper(InputStream)>,This method is deprecated. Use WallpaperManager.set() instead. This method requires the caller to hold the permission Manifest.permission.SET_WALLPAPER .,data InputStream |||,void,1,"Proxying implementation of Context that simply delegates all of its calls to
 another Context.  Can be subclassed to modify behavior without changing
 the original Context.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
"<android.widget.ViewAnimator: void removeViewsInLayout(int,int)>","Removes a range of views during layout. This is useful if in your onLayout() method
 you need to remove more views. Note: do not invoke this method from View.draw(android.graphics.Canvas)  View.onDraw(android.graphics.Canvas)  dispatchDraw(android.graphics.Canvas) or any related method.","start int : the index of the first view to remove from the group |||
count int : the number of views to remove from the group |||",void,1,"Base class for a  FrameLayout  container that will perform animations
 when switching between its views.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
"<android.content.PeriodicSync: void writeToParcel(Parcel,int)>",Flatten this object in to a Parcel.,"dest Parcel : The Parcel in which the object should be written. |||
flags int : Additional flags about how the object should be written.
May be 0 or Parcelable.PARCELABLE_WRITE_RETURN_VALUE .
Value is either 0 or a combination of Parcelable.PARCELABLE_WRITE_RETURN_VALUE and android.os.Parcelable.PARCELABLE_ELIDE_DUPLICATES |||",void,8,Value type that contains information about a periodic sync.,"Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.bluetooth.BluetoothA2dp: List getConnectedDevices()>,Get connected devices for this specific profile. Return the set of devices which are in state STATE_CONNECTED Requires Manifest.permission.BLUETOOTH,,List < BluetoothDevice > List of devices. The list will be empty on error. |||,11,"This class provides the public APIs to control the Bluetooth A2DP
 profile.

  BluetoothA2dp is a proxy object for controlling the Bluetooth A2DP
 Service via IPC. Use  BluetoothAdapter#getProfileProxy  to get
 the BluetoothA2dp proxy object.

   Android only supports one connected Bluetooth A2dp device at a time.
 Each method is protected with its appropriate permission.","Provides classes that manage Bluetooth functionality such as scanning for
 devices connecting with devices and managing data transfer between devices.
 The Bluetooth API supports both ""Classic Bluetooth"" and Bluetooth Low Energy. For more information about Classic Bluetooth see the
  Bluetooth  guide.
 For more information about Bluetooth Low Energy see the
  
 Bluetooth Low Energy  (BLE) guide. The Bluetooth APIs let applications: Scan for other Bluetooth devices (including BLE devices). Query the local Bluetooth adapter for paired Bluetooth devices. Establish RFCOMM channels/sockets. Connect to specified sockets on other devices. Transfer data to and from other devices. Communicate with BLE devices such as proximity sensors heart rate
     monitors fitness devices and so on. Act as a GATT client or a GATT server (BLE). 
 To perform Bluetooth communication using these APIs an application must
 declare the  BLUETOOTH  permission. Some
 additional functionality such as requesting device discovery
 also requires the  BLUETOOTH_ADMIN 
 permission.
  Note: 
 Not all Android-powered devices provide Bluetooth functionality.",,,,,,,
<android.content.pm.ResolveInfo: Drawable loadIcon(PackageManager)>,"Retrieve the current graphical icon associated with this resolution.  This
 will call back on the given PackageManager to load the icon from
 the application.","pm PackageManager : A PackageManager from which the icon can be loaded; usually
the PackageManager from which you originally retrieved this item. |||","Drawable Returns a Drawable containing the resolution's icon.  If the
 item does not have an icon the default activity icon is returned. |||",1,"Information that is returned from resolving an intent
 against an IntentFilter. This partially corresponds to
 information collected from the AndroidManifest.xml's
 <intent> tags.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
"<android.app.admin.DevicePolicyManager: void setPasswordMinimumUpperCase(ComponentName,int)>","Called by an application that is administering the device to set the minimum number of upper
 case letters required in the password. After setting this the user will not be able to enter
 a new password that is not at least as restrictive as what has been set. Note that the
 current password will remain until the user has set a new one so the change does not take
 place immediately. To prompt the user for a new password use ACTION_SET_NEW_PASSWORD or ACTION_SET_NEW_PARENT_PROFILE_PASSWORD after
 setting this value. This constraint is only imposed if the administrator has also requested PASSWORD_QUALITY_COMPLEX with setPasswordQuality(ComponentName int) . If an app targeting
 SDK level Build.VERSION_CODES.R and above enforces this constraint without
 settings password quality to PASSWORD_QUALITY_COMPLEX first this method will throw IllegalStateException . The default value is 0. On devices not supporting PackageManager#FEATURE_SECURE_LOCK_SCREEN feature the
 password is always treated as empty. The calling device admin must have requested DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD to be able to call this method; if it has
 not a security exception will be thrown. This method can be called on the DevicePolicyManager instance returned by getParentProfileInstance(android.content.ComponentName) in order to set restrictions on the parent
 profile.","admin ComponentName : Which DeviceAdminReceiver this request is associated with.
This value cannot be null . |||
length int : The new desired minimum number of upper case letters required in the password.
A value of 0 means there is no restriction. |||",void,11,"Public interface for managing policies enforced on a device. Most clients of this class must be
 registered with the system as a  device
 administrator . Additionally a device administrator may be registered as either a profile or
 device owner. A given method is accessible to all device administrators unless the documentation
 for that method specifies that it is restricted to either device or profile owners. Any
 application calling an api may only pass as an argument a device administrator component it
 owns. Otherwise a  SecurityException  will be thrown.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.net.sip.SipAudioCall: void holdCall(int)>,"Puts a call on hold.  When succeeds Listener#onCallHeld is
 called. The attempt will be timed out if the call is not established
 within timeout seconds and Listener#onError will be called.","timeout int : the timeout value in seconds. Default value (defined by
SIP protocol) is used if timeout is zero or negative. |||",void,9,"Handles an Internet audio call over SIP. You can instantiate this class with  SipManager 
 using  SipManager#makeAudioCall  and   SipManager#takeAudioCall .

  Note:  Using this class require the
    Manifest.permission.INTERNET  and
    Manifest.permission.USE_SIP  permissions. In addition  startAudio()  requires the
    Manifest.permission.RECORD_AUDIO 
    Manifest.permission.ACCESS_WIFI_STATE  and
    Manifest.permission.WAKE_LOCK  permissions; and  setSpeakerMode()  requires the
    Manifest.permission.MODIFY_AUDIO_SETTINGS  permission.",,,,,,,,
<android.net.VpnService: Intent prepare(Context)>,"Prepare to establish a VPN connection. This method returns null if the VPN application is already prepared or if the user has previously
 consented to the VPN application. Otherwise it returns an Intent to a system activity. The application should launch the
 activity using Activity#startActivityForResult to get itself
 prepared. The activity may pop up a dialog to require user action and
 the result will come back via its Activity#onActivityResult .
 If the result is Activity#RESULT_OK the application becomes
 prepared and is granted to use other methods in this class. Only one application can be granted at the same time. The right
 is revoked when another application is granted. The application
 losing the right will be notified via its onRevoke() . Unless
 it becomes prepared again subsequent calls to other methods in this
 class will fail. The user may disable the VPN at any time while it is activated in
 which case this method will return an intent the next time it is
 executed to obtain the user's consent again.",context Context |||,Intent |||,14,"VpnService is a base class for applications to extend and build their
 own VPN solutions. In general it creates a virtual network interface
 configures addresses and routing rules and returns a file descriptor
 to the application. Each read from the descriptor retrieves an outgoing
 packet which was routed to the interface. Each write to the descriptor
 injects an incoming packet just like it was received from the interface.
 The interface is running on Internet Protocol (IP) so packets are
 always started with IP headers. The application then completes a VPN
 connection by processing and exchanging packets with the remote server
 over a tunnel.

  Letting applications intercept packets raises huge security concerns.
 A VPN application can easily break the network. Besides two of them may
 conflict with each other. The system takes several actions to address
 these issues. Here are some key points:
  User action is required the first time an application creates a VPN
       connection. There can be only one VPN connection running at the same time. The
       existing interface is deactivated when a new one is created. A system-managed notification is shown during the lifetime of a
       VPN connection. A system-managed dialog gives the information of the current VPN
       connection. It also provides a button to disconnect. The network is restored automatically when the file descriptor is
       closed. It also covers the cases when a VPN application is crashed
       or killed by the system. There are two primary methods in this class:  prepare(Context)  and
  Builder#establish . The former deals with user action and stops
 the VPN connection created by another application. The latter creates
 a VPN interface using the parameters supplied to the  Builder .
 An application must call  prepare(Context)  to grant the right to use
 other methods in this class and the right can be revoked at any time.
 Here are the general steps to create a VPN connection:
  When the user presses the button to connect call  prepare(Context) 
       and launch the returned intent if non-null. When the application becomes prepared start the service. Create a tunnel to the remote server and negotiate the network
       parameters for the VPN connection. Supply those parameters to a  Builder  and create a VPN
       interface by calling  Builder#establish . Process and exchange packets between the tunnel and the returned
       file descriptor. When  onRevoke()  is invoked close the file descriptor and
       shut down the tunnel gracefully. Services extending this class need to be declared with an appropriate
 permission and intent filter. Their access must be secured by
  Manifest.permission.BIND_VPN_SERVICE  permission and
 their intent filter must match  SERVICE_INTERFACE  action. Here
 is an example of declaring a VPN service in  AndroidManifest.xml :
  
 <service android:name="".ExampleVpnService""
         android:permission=""android.permission.BIND_VPN_SERVICE"">
     <intent-filter>
         <action android:name=""android.net.VpnService""/>
     </intent-filter>
 </service>  The Android system starts a VPN in the background by calling
  startService() . In Android 8.0
 (API level 26) and higher the system places VPN apps on the temporary
 whitelist for a short period so the app can start in the background. The VPN
 app must promote itself to the foreground after it's launched or the system
 will shut down the app.

  Developer's guide To learn more about developing VPN apps read the
  VPN developer's guide .",,,,,,,,
<android.content.pm.LabeledIntent: Drawable loadIcon(PackageManager)>,"Retrieve the icon associated with this object.  If the object does
 not have a icon null will be returned in which case you will probably
 want to load the icon from the underlying resolved info for the Intent.",pm PackageManager |||,Drawable |||,5,"A special subclass of Intent that can have a custom label/icon
 associated with it.  Primarily for use with  Intent#ACTION_CHOOSER .","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.os.Parcel: Parcelable readParcelableArray(ClassLoader)>,"Read and return a new Parcelable array from the parcel.
 The given class loader will be used to load any enclosed
 Parcelables.",loader ClassLoader : This value may be null . |||,Parcelable[] the Parcelable array or null if the array is null |||,1,"Container for a message (data and object references) that can
 be sent through an IBinder.  A Parcel can contain both flattened data
 that will be unflattened on the other side of the IPC (using the various
 methods here for writing specific types or the general
  Parcelable  interface) and references to live  IBinder 
 objects that will result in the other side receiving a proxy IBinder
 connected with the original IBinder in the Parcel.

  Parcel is  not  a general-purpose
 serialization mechanism.  This class (and the corresponding
  Parcelable  API for placing arbitrary objects into a Parcel) is
 designed as a high-performance IPC transport.  As such it is not
 appropriate to place any Parcel data in to persistent storage: changes
 in the underlying implementation of any of the data in the Parcel can
 render older data unreadable. The bulk of the Parcel API revolves around reading and writing data
 of various types.  There are six major classes of such functions available. Primitives The most basic data functions are for writing and reading primitive
 data types:  writeByte(byte)   readByte()   writeDouble(double) 
  readDouble()   writeFloat(float)   readFloat()   writeInt(int) 
  readInt()   writeLong(long)   readLong() 
  writeString(String)   readString() .  Most other
 data operations are built on top of these.  The given data is written and
 read using the endianess of the host CPU. Primitive Arrays There are a variety of methods for reading and writing raw arrays
 of primitive objects which generally result in writing a 4-byte length
 followed by the primitive data items.  The methods for reading can either
 read the data into an existing array or create and return a new array.
 These available types are: writeBooleanArray(boolean[]) 
  readBooleanArray(boolean[])   createBooleanArray() writeByteArray(byte[]) 
  writeByteArray(byte[] int int)   readByteArray(byte[]) 
  createByteArray() writeCharArray(char[])   readCharArray(char[]) 
  createCharArray() writeDoubleArray(double[])   readDoubleArray(double[]) 
  createDoubleArray() writeFloatArray(float[])   readFloatArray(float[]) 
  createFloatArray() writeIntArray(int[])   readIntArray(int[]) 
  createIntArray() writeLongArray(long[])   readLongArray(long[]) 
  createLongArray() writeStringArray(java.lang.String[])   readStringArray(java.lang.String[]) 
  createStringArray() .
  writeSparseBooleanArray(android.util.SparseBooleanArray) 
  readSparseBooleanArray() .
  Parcelables The  Parcelable  protocol provides an extremely efficient (but
 low-level) protocol for objects to write and read themselves from Parcels.
 You can use the direct methods  writeParcelable(android.os.Parcelable int) 
 and  readParcelable(java.lang.ClassLoader)  or
  writeParcelableArray(T[] int)  and
  readParcelableArray(java.lang.ClassLoader)  to write or read.  These
 methods write both the class type and its data to the Parcel allowing
 that class to be reconstructed from the appropriate class loader when
 later reading. There are also some methods that provide a more efficient way to work
 with Parcelables:  writeTypedObject(T int)   writeTypedArray(T[] int) 
  writeTypedList(List )   readTypedObject(Parcelable.Creator ) 
  createTypedArray(Parcelable.Creator )  and  createTypedArrayList(Parcelable.Creator ) .  These methods
 do not write the class information of the original object: instead the
 caller of the read function must know what type to expect and pass in the
 appropriate  Parcelable.Creator  instead to
 properly construct the new object and read its data.  (To more efficient
 write and read a single Parcelable object that is not null you can directly
 call  Parcelable#writeToParcel  and
  Parcelable.Creator#createFromParcel 
 yourself.) Bundles A special type-safe container called  Bundle  is available
 for key/value maps of heterogeneous values.  This has many optimizations
 for improved performance when reading and writing data and its type-safe
 API avoids difficult to debug type errors when finally marshalling the
 data contents into a Parcel.  The methods to use are
  writeBundle(android.os.Bundle)   readBundle()  and
  readBundle(java.lang.ClassLoader) .

  Active Objects An unusual feature of Parcel is the ability to read and write active
 objects.  For these objects the actual contents of the object is not
 written rather a special token referencing the object is written.  When
 reading the object back from the Parcel you do not get a new instance of
 the object but rather a handle that operates on the exact same object that
 was originally written.  There are two forms of active objects available. Binder  objects are a core facility of Android's general cross-process
 communication system.  The  IBinder  interface describes an abstract
 protocol with a Binder object.  Any such interface can be written in to
 a Parcel and upon reading you will receive either the original object
 implementing that interface or a special proxy implementation
 that communicates calls back to the original object.  The methods to use are
  writeStrongBinder(android.os.IBinder) 
  writeStrongInterface(android.os.IInterface)   readStrongBinder() 
  writeBinderArray(android.os.IBinder[])   readBinderArray(android.os.IBinder[]) 
  createBinderArray() 
  writeBinderList(java.util.List)   readBinderList(java.util.List) 
  createBinderArrayList() . FileDescriptor objects representing raw Linux file descriptor identifiers
 can be written and  ParcelFileDescriptor  objects returned to operate
 on the original file descriptor.  The returned file descriptor is a dup
 of the original file descriptor: the object and fd is different but
 operating on the same underlying file stream with the same position etc.
 The methods to use are  writeFileDescriptor(java.io.FileDescriptor) 
  readFileDescriptor() .

  Untyped Containers A final class of methods are for writing and reading standard Java
 containers of arbitrary types.  These all revolve around the
  writeValue(java.lang.Object)  and  readValue(java.lang.ClassLoader)  methods
 which define the types of objects allowed.  The container methods are
  writeArray(java.lang.Object[])   readArray(java.lang.ClassLoader) 
  writeList(java.util.List)   readList(java.util.List java.lang.ClassLoader) 
  readArrayList(java.lang.ClassLoader) 
  writeMap(java.util.Map)   readMap(java.util.Map java.lang.ClassLoader) 
  writeSparseArray(android.util.SparseArray) 
  readSparseArray(java.lang.ClassLoader) .",,,,,,,,
"<android.preference.PreferenceActivity: void startWithFragment(String,Bundle,Fragment,int,int,int)>","Start a new instance of this activity showing only the given
 preference fragment.  When launched in this mode the header list
 will be hidden and the given preference fragment will be instantiated
 and fill the entire activity.","fragmentName String : The name of the fragment to display. |||
args Bundle : Optional arguments to supply to the fragment. |||
resultTo Fragment : Option fragment that should receive the result of
the activity launch. |||
resultRequestCode int : If resultTo is non-null this is the request
code in which to report the result. |||
titleRes int : Resource ID of string to display for the title of
this set of preferences. |||
shortTitleRes int : Resource ID of string to display for the short title of
this set of preferences. |||",void,14,"This is the base class for an activity to show a hierarchy of preferences
 to the user.  Prior to  Build.VERSION_CODES.HONEYCOMB 
 this class only allowed the display of a single set of preference; this
 functionality should now be found in the new  PreferenceFragment 
 class.  If you are using PreferenceActivity in its old mode the documentation
 there applies to the deprecated APIs here.

  This activity shows one or more headers of preferences each of which
 is associated with a  PreferenceFragment  to display the preferences
 of that header.  The actual layout and display of these associations can
 however vary; currently there are two major approaches it may take:

  On a small screen it may display only the headers as a single list when first launched.
 Selecting one of the header items will only show the PreferenceFragment of that header (on
 Android N and lower a new Activity is launched).
  On a large screen it may display both the headers and current PreferenceFragment together as
 panes. Selecting a header item switches to showing the correct PreferenceFragment for that item.
  Subclasses of PreferenceActivity should implement
  onBuildHeaders(List )  to populate the header list with the desired
 items.  Doing this implicitly switches the class into its new ""headers
 + fragments"" mode rather than the old style of just showing a single
 preferences list.",,,,,,,,
"<android.database.DatabaseUtils: ParcelFileDescriptor blobFileDescriptorForQuery(SQLiteStatement,String)>","Utility method to run the pre-compiled query and return the blob value in the
 first column of the first row.","prog SQLiteStatement |||
selectionArgs String |||",ParcelFileDescriptor A read-only file descriptor for a copy of the blob value. |||,11,Static utility methods for dealing with databases and  Cursor s.,"If you need to manage data in a private database use the  android.database.sqlite  classes. These classes are used to manage the  Cursor  object returned from a content provider query. Databases
 are usually created and opened with  openOrCreateDatabase(String int SQLiteDatabase.CursorFactory) 
 To make requests through
 content providers you can use the  content.ContentResolver  class.
  All databases are stored on the device in  /data/data/<package_name>/databases",,,,,,,
"<android.content.res.Resources: void parseBundleExtra(String,AttributeSet,Bundle)>","Parse a name/value pair out of an XML tag holding that data.  The
 AttributeSet must be holding the data defined by R.styleable.Extra .  The following value types are supported: TypedValue#TYPE_STRING : Bundle#putCharSequence 
TypedValue#TYPE_INT_BOOLEAN : Bundle#putCharSequence 
TypedValue#TYPE_FIRST_INT - TypedValue#TYPE_LAST_INT : Bundle#putCharSequence 
TypedValue#TYPE_FLOAT : Bundle#putCharSequence","tagName String : The name of the tag these attributes come from; this is
only used for reporting error messages. |||
attrs AttributeSet : The attributes from which to retrieve the name/value pair. |||
outBundle Bundle : The Bundle in which to place the parsed value. |||",void,3,"Class for accessing an application's resources.  This sits on top of the
 asset manager of the application (accessible through  getAssets() ) and
 provides a high-level API for getting typed data from the assets.

  The Android resource system keeps track of all non-code assets associated with an
 application. You can use this class to access your application's resources. You can generally
 acquire the  Resources  instance associated with your application
 with  getResources() . The Android SDK tools compile your application's resources into the application binary
 at build time.  To use a resource you must install it correctly in the source tree (inside
 your project's  res/  directory) and build your application.  As part of the build
 process the SDK tools generate symbols for each resource which you can use in your application
 code to access the resources. Using application resources makes it easy to update various characteristics of your
 application without modifying code and—by providing sets of alternative
 resources—enables you to optimize your application for a variety of device configurations
 (such as for different languages and screen sizes). This is an important aspect of developing
 Android applications that are compatible on different types of devices. For more information about using resources see the documentation about  Application Resources .","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.content.Intent: ArrayList getStringArrayListExtra(String)>,Retrieve extended data from the intent.,name String : The name of the desired item. |||,"ArrayList < String > the value of an item previously added with
 putStringArrayListExtra() or null if no
 ArrayList value was found. |||",1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.widget.TabWidget: void focusCurrentTab(int)>,"Sets the current tab and focuses the UI on it.
 This method makes sure that the focused tab matches the selected
 tab normally at setCurrentTab(int) .  Normally this would not
 be an issue if we go through the UI since the UI is responsible
 for calling TabWidget.onFocusChanged() but in the case where we
 are selecting the tab programmatically we'll need to make sure
 focus keeps up.","index int : The tab that you want focused (highlighted in orange)
and selected (tab brought to the front of the widget) |||",void,1,"Displays a list of tab labels representing each page in the parent's tab
 collection.
  
 The container object for this widget is  TabHost .
 When the user selects a tab this object sends a message to the parent
 container TabHost to tell it to switch the displayed page. You typically
 won't use many methods directly on this object. The container TabHost is
 used to add labels add the callback handler and manage callbacks. You
 might call this object to iterate the list of tabs or to tweak the layout
 of the tab list but most methods should be called on the containing TabHost
 object.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
"<android.os.Bundle: void putByte(String,byte)>","Inserts a byte value into the mapping of this Bundle replacing
 any existing value for the given key.","key String : a String or null
This value may be null . |||
value byte : a byte |||",void,1,A mapping from String keys to various  Parcelable  values.,,,,,,,,
<android.view.inputmethod.InputMethodManager: void showInputMethodPicker()>,"Show IME picker popup window. Requires the PackageManager#FEATURE_INPUT_METHODS feature which can be detected
 using PackageManager#hasSystemFeature(String) .",,void,3,"Central system API to the overall input method framework (IMF) architecture
 which arbitrates interaction between applications and the current input method.

  Topics covered here:
  Architecture Overview Applications Input Methods Security Architecture Overview There are three primary parties involved in the input method
 framework (IMF) architecture:  The  input method manager  as expressed by this class
 is the central point of the system that manages interaction between all
 other parts.  It is expressed as the client-side API here which exists
 in each application context and communicates with a global system service
 that manages the interaction across all processes.
   An  input method (IME)  implements a particular
 interaction model allowing the user to generate text.  The system binds
 to the current input method that is in use causing it to be created and run
 and tells it when to hide and show its UI.  Only one IME is running at a time.
   Multiple  client applications  arbitrate with the input
 method manager for input focus and control over the state of the IME.  Only
 one such client is ever active (working with the IME) at a time.
  Applications In most cases applications that are using the standard
  TextView  or its subclasses will have little they need
 to do to work well with soft input methods.  The main things you need to
 be aware of are:  Properly set the  R.attr.inputType  in your editable
 text views so that the input method will have enough context to help the
 user in entering text into them.
   Deal well with losing screen space when the input method is
 displayed.  Ideally an application should handle its window being resized
 smaller but it can rely on the system performing panning of the window
 if needed.  You should set the  R.attr.windowSoftInputMode 
 attribute on your activity or the corresponding values on windows you
 create to help the system determine whether to pan or resize (it will
 try to determine this automatically but may get it wrong).
   You can also control the preferred soft input state (open closed etc)
 for your window using the same  R.attr.windowSoftInputMode 
 attribute.
  More finer-grained control is available through the APIs here to directly
 interact with the IMF and its IME -- either showing or hiding the input
 area letting the user pick an input method etc. For the rare people amongst us writing their own text editors you
 will need to implement  View.onCreateInputConnection(EditorInfo) 
 to return a new instance of your own  InputConnection  interface
 allowing the IME to interact with your editor. Input Methods An input method (IME) is implemented
 as a  Service  typically deriving from
  InputMethodService .  It must provide
 the core  InputMethod  interface though this is normally handled by
  InputMethodService  and implementors will
 only need to deal with the higher-level API there. InputMethodService Security There are a lot of security issues associated with input methods
 since they essentially have freedom to completely drive the UI and monitor
 everything the user enters.  The Android input method framework also allows
 arbitrary third party IMEs so care must be taken to restrict their
 selection and interactions. Here are some key points about the security architecture behind the
 IMF: Only the system is allowed to directly access an IME's
  InputMethod  interface via the
  Manifest.permission.BIND_INPUT_METHOD  permission.  This is
 enforced in the system by not binding to an input method service that does
 not require this permission so the system can guarantee no other untrusted
 clients are accessing the current input method outside of its control. There may be many client processes of the IMF but only one may
 be active at a time.  The inactive clients can not interact with key
 parts of the IMF through the mechanisms described below. Clients of an input method are only given access to its
  InputMethodSession  interface.  One instance of this interface is
 created for each client and only calls from the session associated with
 the active client will be processed by the current IME.  This is enforced
 by  AbstractInputMethodService  for normal
 IMEs but must be explicitly handled by an IME that is customizing the
 raw  InputMethodSession  implementation. Only the active client's  InputConnection  will accept
 operations.  The IMF tells each client process whether it is active and
 the framework enforces that in inactive processes calls on to the current
 InputConnection will be ignored.  This ensures that the current IME can
 only deliver events and text edits to the UI that the user sees as
 being in focus. An IME can never interact with an  InputConnection  while
 the screen is off.  This is enforced by making all clients inactive while
 the screen is off and prevents bad IMEs from driving the UI when the user
 can not be aware of its behavior. A client application can ask that the system let the user pick a
 new IME but can not programmatically switch to one itself.  This avoids
 malicious applications from switching the user to their own IME which
 remains running when the user navigates away to another application.  An
 IME on the other hand  is  allowed to programmatically switch
 the system to another IME since it already has full control of user
 input. The user must explicitly enable a new IME in settings before
 they can switch to it to confirm with the system that they know about it
 and want to make it available for use. PackageManager#FEATURE_INPUT_METHODS PackageManager.hasSystemFeature(String)",,,,,,,,
<android.widget.MultiAutoCompleteTextView: void performValidation()>,"Instead of validating the entire text this subclass method validates
 each token of the text individually.  Empty tokens are removed.",,void,1,"An editable text view extending  AutoCompleteTextView  that
 can show completion suggestions for the substring of the text where
 the user is typing instead of necessarily for the entire thing.
  
 You must provide a  Tokenizer  to distinguish the
 various substrings.

  The following code snippet shows how to create a text view which suggests
 various countries names while the user is typing: 
 public class CountriesActivity extends Activity {
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.autocomplete_7);

         ArrayAdapter<String> adapter = new ArrayAdapter<String>(this
                 android.R.layout.simple_dropdown_item_1line COUNTRIES);
         MultiAutoCompleteTextView textView = findViewById(R.id.edit);
         textView.setAdapter(adapter);
         textView.setTokenizer(new MultiAutoCompleteTextView.CommaTokenizer());
     }

     private static final String[] COUNTRIES = new String[] {
         ""Belgium"" ""France"" ""Italy"" ""Germany"" ""Spain""
     };
 }","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.webkit.WebViewFragment: void onDestroy()>,Called when the fragment is no longer in use. Destroys the internal state of the WebView.,,void,11,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",,,,,,,
<android.content.ContentResolver: void cancelSync(Uri)>,"This method was deprecated
      in API level 15. instead use cancelSync(android.accounts.Account java.lang.String) Cancel any active or pending syncs that match the Uri. If the uri is null then
 all syncs will be canceled.",uri Uri : the uri of the provider to sync or null to sync all providers. |||,void,1,This class provides applications access to the content model.,"Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
"<android.net.http.X509TrustManagerExtensions: List checkServerTrusted(X509Certificate,String,String)>","Verifies the given certificate chain. See X509TrustManager#checkServerTrusted(X509Certificate[] String) for a
 description of the chain and authType parameters. The final parameter host should be the
 hostname of the server.","chain X509Certificate |||
authType String |||
host String |||",List < X509Certificate > the properly ordered chain used for verification as a list of X509Certificates. |||,17,"X509TrustManager wrapper exposing Android-added features.
  
 The checkServerTrusted method allows callers to perform additional
 verification of certificate chains after they have been successfully verified
 by the platform.",,,,,,,,
<android.app.Instrumentation: void endPerformanceSnapshot()>,,,void,1,"Base class for implementing application instrumentation code.  When running
 with instrumentation turned on this class will be instantiated for you
 before any of the application code allowing you to monitor all of the
 interaction the system has with the application.  An Instrumentation
 implementation is described to the system through an AndroidManifest.xml's
 <instrumentation> tag.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.media.CamcorderProfile: CamcorderProfile get(int)>,"Returns the camcorder profile for the first back-facing camera on the
 device at the given quality level. If the device has no back-facing
 camera this returns null.",quality int : the target quality level for the camcorder profile |||,CamcorderProfile |||,8,"Retrieves the
 predefined camcorder profile settings for camcorder applications.
 These settings are read-only.

  The compressed output from a recording session with a given
 CamcorderProfile contains two tracks: one for audio and one for video.

  Each profile specifies the following set of parameters:
   The file output format
   Video codec format
   Video bit rate in bits per second
   Video frame rate in frames per second
   Video frame width and height
   Audio codec format
   Audio bit rate in bits per second
   Audio sample rate
   Number of audio channels for recording.","The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",,,,,,,
"<android.os.Bundle: void putIntegerArrayList(String,ArrayList)>","Inserts an ArrayList value into the mapping of this Bundle replacing
 any existing value for the given key.  Either key or value may be null.","key String : a String or null
This value may be null . |||
value ArrayList : an ArrayList object or null
This value may be null . |||",void,1,A mapping from String keys to various  Parcelable  values.,,,,,,,,
<android.app.TaskStackBuilder: TaskStackBuilder addParentStack(Activity)>,"Add the activity parent chain as specified by the Activity#getParentActivityIntent() method of the activity
 specified and the parentActivityName attributes
 of each successive activity (or activity-alias) element in the application's manifest
 to the task stack builder.",sourceActivity Activity : All parents of this activity will be added |||,TaskStackBuilder This TaskStackBuilder for method chaining |||,16,"Utility class for constructing synthetic back stacks for cross-task navigation
 on Android 3.0 and newer.

  In API level 11 (Android 3.0/Honeycomb) the recommended conventions for
 app navigation using the back key changed. The back key's behavior is local
 to the current task and does not capture navigation across different tasks.
 Navigating across tasks and easily reaching the previous task is accomplished
 through the ""recents"" UI accessible through the software-provided Recents key
 on the navigation or system bar. On devices with the older hardware button configuration
 the recents UI can be accessed with a long press on the Home key. When crossing from one task stack to another post-Android 3.0
 the application should synthesize a back stack/history for the new task so that
 the user may navigate out of the new task and back to the Launcher by repeated
 presses of the back key. Back key presses should not navigate across task stacks. TaskStackBuilder provides a way to obey the correct conventions
 around cross-task navigation.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.os.RecoverySystem: void rebootWipeUserData(Context)>,"Reboots the device and wipes the user data and cache
 partitions.  This is sometimes called a ""factory reset"" which
 is something of a misnomer because the system partition is not
 restored to its factory state.  Requires the Manifest.permission.REBOOT permission.",context Context : the Context to use |||,void,8,"RecoverySystem contains methods for interacting with the Android
 recovery system (the separate partition that can be used to install
 system updates wipe user data etc.)",,,,,,,,
<android.view.ViewPropertyAnimator: void start()>,"Starts the currently pending property animations immediately. Calling start() is optional because all animations start automatically at the next opportunity. However
 if the animations are needed to start immediately and synchronously (not at the time when
 the next event is processed by the hierarchy which is when the animations would begin
 otherwise) then this method can be used.",,void,14,"This class enables automatic and optimized animation of select properties on View objects.
 If only one or two properties on a View object are being animated then using an
  ObjectAnimator  is fine; the property setters called by ObjectAnimator
 are well equipped to do the right thing to set the property and invalidate the view
 appropriately. But if several properties are animated simultaneously or if you just want a
 more convenient syntax to animate a specific property then ViewPropertyAnimator might be
 more well-suited to the task.

  This class may provide better performance for several simultaneous animations because
 it will optimize invalidate calls to take place only once for several properties instead of each
 animated property independently causing its own invalidation. Also the syntax of using this
 class could be easier to use because the caller need only tell the View object which
 property to animate and the value to animate either to or by and this class handles the
 details of configuring the underlying Animator class and starting it. This class is not constructed by the caller but rather by the View whose properties
 it will animate. Calls to  View.animate()  will return a reference
 to the appropriate ViewPropertyAnimator object for that View.",,,,,,,,
<android.widget.TextView: void setHint(CharSequence)>,"Sets the text to be displayed when the text of the TextView is empty.
 Null means to use the normal empty text. The hint does not currently
 participate in determining the size of the view. Related XML Attributes: android:hint",hint CharSequence |||,void,1,"A user interface element that displays text to the user.
 To provide user-editable text see  EditText .
  
 The following code sample shows a typical use with an XML layout
 and code to modify the contents of the text view:
  
 <LinearLayout
      xmlns:android=""http://schemas.android.com/apk/res/android""
      android:layout_width=""match_parent""
      android:layout_height=""match_parent"">
    <TextView
        android:id=""@+id/text_view_id""
        android:layout_height=""wrap_content""
        android:layout_width=""wrap_content""
        android:text=""@string/hello"" />
 </LinearLayout>
  
 This code sample demonstrates how to modify the contents of the text view
 defined in the previous XML layout:
  
 public class MainActivity extends Activity {

    protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_main);
         final TextView helloTextView = (TextView) findViewById(R.id.text_view_id);
         helloTextView.setText(R.string.user_greeting);
     }
 }
  
 To customize the appearance of TextView see  Styles and Themes .
  XML attributes 
 See  TextView Attributes 
  View Attributes","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.telephony.TelephonyManager: List getAllCellInfo()>,"Requests all available cell information from all radios on the device including the
 camped/registered serving and neighboring cells. The response can include one or more CellInfoGsm  CellInfoCdma  CellInfoTdscdma  CellInfoLte and CellInfoWcdma objects in any combination.
 It is typical to see instances of one or more of any these in the list. In addition zero
 or more of the returned objects may be considered registered; that is their CellInfo.isRegistered() methods may return true indicating that the cell is being used or would be used for
 signaling communication if necessary. Beginning with Android Q if this API results in a change of the cached CellInfo that change will be reported via onCellInfoChanged() . Apps targeting Android Q or higher will no
 longer trigger a refresh of the cached CellInfo by invoking this API. Instead those apps
 will receive the latest cached results which may not be current. Apps targeting Android Q or higher that wish to request updated
 CellInfo should call requestCellInfoUpdate() ;
 however in all cases updates will be rate-limited and are not guaranteed. To determine the
 recency of CellInfo data callers should check CellInfo#getTimeStamp() . This method returns valid data for devices with FEATURE_TELEPHONY . In cases
 where only partial information is available for a particular CellInfo entry unavailable
 fields will be reported as CellInfo.UNAVAILABLE . All reported
 cells will include at least a valid set of technology-specific identification info and a
 power level measurement. This method is preferred over using getCellLocation() . Requires Manifest.permission.ACCESS_FINE_LOCATION",,"List < CellInfo > List of CellInfo ; null if cell
 information is unavailable. |||",17,"Provides access to information about the telephony services on
 the device. Applications can use the methods in this class to
 determine telephony services and states as well as to access some
 types of subscriber information. Applications can also register
 a listener to receive notification of telephony state changes.
  
 The returned TelephonyManager will use the default subscription for all calls.
 To call an API for a specific subscription use  createForSubscriptionId(int) . e.g.
  
   telephonyManager = defaultSubTelephonyManager.createForSubscriptionId(subId);
  
 Note that access to some telephony information is
 permission-protected. Your application cannot access the protected
 information unless it has the appropriate permissions declared in
 its manifest file. Where permissions apply they are noted in the
 the methods through which you access the protected information.",,,,,,,,
<android.content.pm.PackageItemInfo: Drawable loadLogo(PackageManager)>,"Retrieve the current graphical logo associated with this item. This
 will call back on the given PackageManager to load the logo from
 the application.","pm PackageManager : A PackageManager from which the logo can be loaded; usually
the PackageManager from which you originally retrieved this item. |||","Drawable Returns a Drawable containing the item's logo. If the item
 does not have a logo this method will return null. |||",9,"Base class containing information common to all package items held by
 the package manager.  This provides a very common basic set of attributes:
 a label icon and meta-data.  This class is not intended
 to be used by itself; it is simply here to share common definitions
 between all items returned by the package manager.  As such it does not
 itself implement Parcelable but does provide convenience methods to assist
 in the implementation of Parcelable in subclasses.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
"<android.widget.ResourceCursorAdapter: View newView(Context,Cursor,ViewGroup)>",Inflates view(s) from the specified XML file.,"context Context : Interface to application's global information |||
cursor Cursor : The cursor from which to get the data. The cursor is already
moved to the correct position. |||
parent ViewGroup : The parent to which the new view is attached to |||",View the newly created view. |||,1,"An easy adapter that creates views defined in an XML file. You can specify
 the XML file that defines the appearance of the views.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.telephony.TelephonyManager: String getVoiceMailAlphaTag()>,"Retrieves the alphabetic identifier associated with the voice
 mail number. Requires Permission: READ_PHONE_STATE or that the calling app has carrier privileges (see hasCarrierPrivileges() ). Requires Manifest.permission.READ_PHONE_STATE",,String |||,1,"Provides access to information about the telephony services on
 the device. Applications can use the methods in this class to
 determine telephony services and states as well as to access some
 types of subscriber information. Applications can also register
 a listener to receive notification of telephony state changes.
  
 The returned TelephonyManager will use the default subscription for all calls.
 To call an API for a specific subscription use  createForSubscriptionId(int) . e.g.
  
   telephonyManager = defaultSubTelephonyManager.createForSubscriptionId(subId);
  
 Note that access to some telephony information is
 permission-protected. Your application cannot access the protected
 information unless it has the appropriate permissions declared in
 its manifest file. Where permissions apply they are noted in the
 the methods through which you access the protected information.",,,,,,,,
<android.content.res.Resources: XmlResourceParser getXml(int)>,"Return an XmlResourceParser through which you can read a generic XML
 resource for the given resource ID. The XmlPullParser implementation returned here has some limited
 functionality.  In particular you can't change its input and only
 high-level parsing events are available (since the document was
 pre-parsed for you at build time which involved merging text and
 stripping comments).","id int : The desired resource identifier as generated by the aapt
tool. This integer encodes the package type and resource
entry. The value 0 is an invalid identifier. |||","XmlResourceParser A new parser object through which you can read
         the XML data.

 This value cannot be null . |||",1,"Class for accessing an application's resources.  This sits on top of the
 asset manager of the application (accessible through  getAssets() ) and
 provides a high-level API for getting typed data from the assets.

  The Android resource system keeps track of all non-code assets associated with an
 application. You can use this class to access your application's resources. You can generally
 acquire the  Resources  instance associated with your application
 with  getResources() . The Android SDK tools compile your application's resources into the application binary
 at build time.  To use a resource you must install it correctly in the source tree (inside
 your project's  res/  directory) and build your application.  As part of the build
 process the SDK tools generate symbols for each resource which you can use in your application
 code to access the resources. Using application resources makes it easy to update various characteristics of your
 application without modifying code and—by providing sets of alternative
 resources—enables you to optimize your application for a variety of device configurations
 (such as for different languages and screen sizes). This is an important aspect of developing
 Android applications that are compatible on different types of devices. For more information about using resources see the documentation about  Application Resources .","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.inputmethodservice.InputMethodService: void onExtractingInputChanged(EditorInfo)>,"This is called when while currently displayed in extract mode the
 current input target changes.  The default implementation will
 auto-hide the IME if the new target is not a full editor since this
 can be a confusing experience for the user.",ei EditorInfo |||,void,3,"InputMethodService provides a standard implementation of an InputMethod
 which final implementations can derive from and customize.  See the
 base class  AbstractInputMethodService  and the  InputMethod 
 interface for more information on the basics of writing input methods.

  In addition to the normal Service lifecycle methods this class
 introduces some new specific callbacks that most subclasses will want
 to make use of: onInitializeInterface()  for user-interface initialization
 in particular to deal with configuration changes while the service is
 running.
  onBindInput()  to find out about switching to a new client.
  onStartInput(EditorInfo boolean)  to deal with an input session starting with
 the client.
  onCreateInputView()   onCreateCandidatesView() 
 and  onCreateExtractTextView()  for non-demand generation of the UI.
  onStartInputView(android.view.inputmethod.EditorInfo boolean)  to deal with input
 starting within the input area of the IME.
  An input method has significant discretion in how it goes about its
 work: the  InputMethodService  provides
 a basic framework for standard UI elements (input view candidates view
 and running in fullscreen mode) but it is up to a particular implementor
 to decide how to use them.  For example one input method could implement
 an input area with a keyboard another could allow the user to draw text
 while a third could have no input area (and thus not be visible to the
 user) but instead listen to audio and perform text to speech conversion. In the implementation provided here all of these elements are placed
 together in a single window managed by the InputMethodService.  It will
 execute callbacks as it needs information about them and provides APIs for
 programmatic control over them.  They layout of these elements is explicitly
 defined: The soft input view if available is placed at the bottom of the
 screen.
  The candidates view if currently shown is placed above the soft
 input view.
  If not running fullscreen the application is moved or resized to be
 above these views; if running fullscreen the window will completely cover
 the application and its top part will contain the extract text of what is
 currently being edited by the application.
  Soft Input View Central to most input methods is the soft input view.  This is where most
 user interaction occurs: pressing on soft keys drawing characters or
 however else your input method wants to generate text.  Most implementations
 will simply have their own view doing all of this work and return a new
 instance of it when  onCreateInputView()  is called.  At that point
 as long as the input view is visible you will see user interaction in
 that view and can call back on the InputMethodService to interact with the
 application as appropriate. There are some situations where you want to decide whether or not your
 soft input view should be shown to the user.  This is done by implementing
 the  onEvaluateInputViewShown()  to return true or false based on
 whether it should be shown in the current environment.  If any of your
 state has changed that may impact this call
  updateInputViewShown()  to have it re-evaluated.  The default
 implementation always shows the input view unless there is a hard
 keyboard available which is the appropriate behavior for most input
 methods. Candidates View Often while the user is generating raw text an input method wants to
 provide them with a list of possible interpretations of that text that can
 be selected for use.  This is accomplished with the candidates view and
 like the soft input view you implement  onCreateCandidatesView() 
 to instantiate your own view implementing your candidates UI. Management of the candidates view is a little different than the input
 view because the candidates view tends to be more transient being shown
 only when there are possible candidates for the current text being entered
 by the user.  To control whether the candidates view is shown you use
  setCandidatesViewShown(boolean) .  Note that because the candidate
 view tends to be shown and hidden a lot it does not impact the application
 UI in the same way as the soft input view: it will never cause application
 windows to resize only cause them to be panned if needed for the user to
 see the current focus. Fullscreen Mode Sometimes your input method UI is too large to integrate with the
 application UI so you just want to take over the screen.  This is
 accomplished by switching to full-screen mode causing the input method
 window to fill the entire screen and add its own ""extracted text"" editor
 showing the user the text that is being typed.  Unlike the other UI elements
 there is a standard implementation for the extract editor that you should
 not need to change.  The editor is placed at the top of the IME above the
 input and candidates views. Similar to the input view you control whether the IME is running in
 fullscreen mode by implementing  onEvaluateFullscreenMode() 
 to return true or false based on
 whether it should be fullscreen in the current environment.  If any of your
 state has changed that may impact this call
  updateFullscreenMode()  to have it re-evaluated.  The default
 implementation selects fullscreen mode when the screen is in a landscape
 orientation which is appropriate behavior for most input methods that have
 a significant input area. When in fullscreen mode you have some special requirements because the
 user can not see the application UI.  In particular you should implement
  onDisplayCompletions(android.view.inputmethod.CompletionInfo[])  to show completions
 generated by your application typically in your candidates view like you
 would normally show candidates.


  Generating Text The key part of an IME is of course generating text for the application.
 This is done through calls to the
  InputConnection  interface to the
 application which can be retrieved from  getCurrentInputConnection() .
 This interface allows you to generate raw key events or if the target
 supports it directly edit in strings of candidates and committed text. Information about what the target is expected and supports can be found
 through the  EditorInfo  class which is
 retrieved with  getCurrentInputEditorInfo()  method.  The most
 important part of this is  EditorInfo.inputType ; in particular if this is
  EditorInfo.TYPE_NULL 
 then the target does not support complex edits and you need to only deliver
 raw key events to it.  An input method will also want to look at other
 values here to for example detect password mode auto complete text views
 phone number entry etc. When the user switches between input targets you will receive calls to
  onFinishInput()  and  onStartInput(android.view.inputmethod.EditorInfo boolean) .
 You can use these to reset and initialize your input state for the current
 target.  For example you will often want to clear any input state and
 update a soft keyboard to be appropriate for the new inputType.",,,,,,,,
<android.content.Intent: String getStringArrayExtra(String)>,Retrieve extended data from the intent.,name String : The name of the desired item. |||,"String[] the value of an item previously added with putExtra()
 or null if no String array value was found. |||",1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.app.backup.BackupManager: void dataChanged()>,"Notifies the Android backup system that your application wishes to back up
 new changes to its data.  A backup operation using your application's BackupAgent subclass will be scheduled when you
 call this method.",,void,8,"The interface through which an application interacts with the Android backup service to
 request backup and restore operations.
 Applications instantiate it using the constructor and issue calls through that instance.
  
 When an application has made changes to data which should be backed up a
 call to  dataChanged()  will notify the backup service. The system
 will then schedule a backup operation to occur in the near future. Repeated
 calls to  dataChanged()  have no further effect until the backup
 operation actually occurs.
  
 A backup or restore operation for your application begins when the system launches the
  BackupAgent  subclass you've declared in your manifest. See the
 documentation for  BackupAgent  for a detailed description
 of how the operation then proceeds.
  
 Several attributes affecting the operation of the backup and restore mechanism
 can be set on the  <application> 
 tag in your application's AndroidManifest.xml file.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
"<android.graphics.BitmapFactory: Bitmap decodeResource(Resources,int)>",Synonym for decodeResource(android.content.res.Resources int android.graphics.BitmapFactory.Options) with null Options.,"res Resources : The resources object containing the image data |||
id int : The resource id of the image data |||",Bitmap The decoded bitmap or null if the image could not be decoded. |||,1,"Creates Bitmap objects from various sources including files streams
 and byte-arrays.",,,,,,,,
<android.preference.PreferenceFragment: void addPreferencesFromIntent(Intent)>,Adds preferences from activities that match the given Intent .,intent Intent : The Intent to query activities. |||,void,11,"Represents the basic Preference UI building
 block displayed by a  PreferenceActivity  in the form of a
  ListView . This class provides the  View  to be displayed in
 the activity and associates with a  SharedPreferences  to
 store/retrieve the preference data.
  
 When specifying a preference hierarchy in XML each element can point to a
 subclass of  Preference  similar to the view hierarchy and layouts.
  
 This class contains a  key  that will be used as the key into the
  SharedPreferences . It is up to the subclass to decide how to store
 the value.",,,,,,,,
<android.media.RingtoneManager: Uri getValidRingtoneUri(Context)>,"Returns a valid ringtone URI. No guarantees on which it returns. If it
 cannot find one returns null. If it can only find one on external storage and the caller
 doesn't have the Manifest.permission.READ_EXTERNAL_STORAGE permission
 returns null.",context Context : The context to use for querying. |||,Uri A ringtone URI or null if one cannot be found. |||,1,"RingtoneManager provides access to ringtones notification and other types
 of sounds. It manages querying the different media providers and combines the
 results into a single cursor. It also provides a  Ringtone  for each
 ringtone. We generically call these sounds ringtones however the
  TYPE_RINGTONE  refers to the type of sounds that are suitable for the
 phone ringer.
  
 To show a ringtone picker to the user use the
  ACTION_RINGTONE_PICKER  intent to launch the picker as a subactivity.","The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",,,,,,,
<android.webkit.WebView: void setWebViewClient(WebViewClient)>,"Sets the WebViewClient that will receive various notifications and
 requests. This will replace the current handler.","client WebViewClient : an implementation of WebViewClient
This value cannot be null . |||",void,1,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",,,,,,,
"<android.content.pm.PermissionGroupInfo: void writeToParcel(Parcel,int)>",,"dest Parcel |||
parcelableFlags int |||",void,1,"Information you can retrieve about a particular security permission
 group known to the system.  This corresponds to information collected from the
 AndroidManifest.xml's <permission-group> tags.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
"<android.content.ContentResolver: void setIsSyncable(Account,String,int)>",Set whether this account/provider is syncable. This method requires the caller to hold the permission Manifest.permission.WRITE_SYNC_SETTINGS .,"account Account |||
authority String |||
syncable int : >0 denotes syncable 0 means not syncable <0 means unknown |||",void,5,This class provides applications access to the content model.,"Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.app.TimePickerDialog: Bundle onSaveInstanceState()>,"Saves the state of the dialog into a bundle.

 The default implementation saves the state of its view hierarchy so you'll
 likely want to call through to super if you override this to save additional
 state.",,"Bundle A bundle with the state of the dialog.
 
 This value cannot be null . |||",1,"A dialog that prompts the user for the time of day using a
  TimePicker .

  
 See the  Pickers 
 guide.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
"<android.media.MediaPlayer: MediaPlayer create(Context,Uri,SurfaceHolder)>","Convenience method to create a MediaPlayer for a given Uri.
 On success prepare() will already have been called and must not be called again. When done with the MediaPlayer you should call release() to free the resources. If not released too many MediaPlayer instances will
 result in an exception. Note that since prepare() is called automatically in this method
 you cannot change the audio
 session ID (see setAudioSessionId(int) ) or audio attributes
 (see setAudioAttributes(android.media.AudioAttributes) of the new MediaPlayer.","context Context : the Context to use |||
uri Uri : the Uri from which to get the datasource |||
holder SurfaceHolder : the SurfaceHolder to use for displaying the video |||",MediaPlayer a MediaPlayer object or null if creation failed |||,1,"MediaPlayer class can be used to control playback
 of audio/video files and streams. An example on how to use the methods in
 this class can be found in  VideoView .

  Topics covered here are:
  State Diagram Valid and Invalid States Permissions Register informational and error callbacks","The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",,,,,,,
<android.os.storage.StorageManager: String getMountedObbPath(String)>,"Check the mounted path of an Opaque Binary Blob (OBB) file. This will
 give you the path to where you can obtain access to the internals of the
 OBB.",rawPath String : path to OBB image |||,"String absolute path to mounted OBB image data or null if
         not mounted or exception encountered trying to read status |||",9,"StorageManager is the interface to the systems storage service. The storage
 manager handles storage-related items such as Opaque Binary Blobs (OBBs).
  
 OBBs contain a filesystem that maybe be encrypted on disk and mounted
 on-demand from an application. OBBs are a good way of providing large amounts
 of binary assets without packaging them into APKs as they may be multiple
 gigabytes in size. However due to their size they're most likely stored in
 a shared storage pool accessible from all programs. The system does not
 guarantee the security of the OBB file itself: if any program modifies the
 OBB there is no guarantee that a read from that OBB will produce the
 expected output.",,,,,,,,
<android.net.sip.SipAudioCall: void startAudio()>,"Starts the audio for the established call. This method should be called
 after Listener#onCallEstablished is called. Note: Requires the Manifest.permission.RECORD_AUDIO  Manifest.permission.ACCESS_WIFI_STATE and Manifest.permission.WAKE_LOCK permissions.",,void,9,"Handles an Internet audio call over SIP. You can instantiate this class with  SipManager 
 using  SipManager#makeAudioCall  and   SipManager#takeAudioCall .

  Note:  Using this class require the
    Manifest.permission.INTERNET  and
    Manifest.permission.USE_SIP  permissions. In addition  startAudio()  requires the
    Manifest.permission.RECORD_AUDIO 
    Manifest.permission.ACCESS_WIFI_STATE  and
    Manifest.permission.WAKE_LOCK  permissions; and  setSpeakerMode()  requires the
    Manifest.permission.MODIFY_AUDIO_SETTINGS  permission.",,,,,,,,
<android.view.View: Bitmap getDrawingCache()>,"This method was deprecated
      in API level 28. The view drawing cache was largely made obsolete with the introduction of
 hardware-accelerated rendering in API 11. With hardware-acceleration intermediate cache
 layers are largely unnecessary and can easily result in a net loss in performance due to the
 cost of creating and updating the layer. In the rare cases where caching layers are useful
 such as for alpha animations setLayerType(int android.graphics.Paint) handles this with hardware
 rendering. For software-rendered snapshots of a small part of the View hierarchy or
 individual Views it is recommended to create a Canvas from either a Bitmap or Picture and call draw(android.graphics.Canvas) on the View. However these
 software-rendered usages are discouraged and have compatibility issues with hardware-only
 rendering features such as Config.HARDWARE bitmaps real-time shadows and outline clipping. For screenshots of the UI for feedback
 reports or unit testing the PixelCopy API is recommended. Calling this method is equivalent to calling getDrawingCache(false) .",,Bitmap A non-scaled bitmap representing this view or null if cache is disabled. |||,1,"This class represents the basic building block for user interface components. A View
 occupies a rectangular area on the screen and is responsible for drawing and
 event handling. View is the base class for  widgets  which are
 used to create interactive UI components (buttons text fields etc.). The
  ViewGroup  subclass is the base class for  layouts  which
 are invisible containers that hold other Views (or other ViewGroups) and define
 their layout properties.",,,,,,,,
"<android.content.ContentProvider: AssetFileDescriptor openAssetFile(Uri,String)>","This is like openFile(Uri String) but can be implemented by providers
 that need to be able to return sub-sections of files often assets
 inside of their .apk.
 This method can be called from multiple threads as described in Processes
 and Threads . If you implement this your clients must be able to deal with such
 file slices either directly with ContentResolver#openAssetFileDescriptor or by using the higher-level ContentResolver#openInputStream or ContentResolver#openOutputStream methods. The returned AssetFileDescriptor can be a pipe or socket pair to enable
 streaming of data. If you are implementing this to return a full file you
 should create the AssetFileDescriptor with AssetFileDescriptor#UNKNOWN_LENGTH to be compatible with
 applications that cannot handle sub-sections of files. For use in Intents you will want to implement getType(Uri) to return the appropriate MIME type for the data returned here with
 the same URI.  This will allow intent resolution to automatically determine the data MIME
 type and select the appropriate matching targets as part of its operation. For better interoperability with other applications it is recommended
 that for any URIs that can be opened you also support queries on them
 containing at least the columns specified by OpenableColumns .","uri Uri : The URI whose file is to be opened.
This value cannot be null . |||
mode String : Access mode for the file.  May be ""r"" for read-only access
""w"" for write-only access (erasing whatever data is currently in
the file) ""wa"" for write-only access to append to any existing data
""rw"" for read and write access on any existing data and ""rwt"" for read
and write access that truncates any existing file.
This value cannot be null . |||","AssetFileDescriptor Returns a new AssetFileDescriptor which you can use to access
 the file.

 This value may be null . |||",3,"Content providers are one of the primary building blocks of Android applications providing
 content to applications. They encapsulate data and provide it to applications through the single
  ContentResolver  interface. A content provider is only required if you need to share
 data between multiple applications. For example the contacts data is used by multiple
 applications and must be stored in a content provider. If you don't need to share data amongst
 multiple applications you can use a database directly via
  SQLiteDatabase .

  When a request is made via
 a  ContentResolver  the system inspects the authority of the given URI and passes the
 request to the content provider registered with the authority. The content provider can interpret
 the rest of the URI however it wants. The  UriMatcher  class is helpful for parsing
 URIs. The primary methods that need to be implemented are:
  onCreate()  which is called to initialize the provider query(Uri String[] Bundle CancellationSignal)  which returns data to the caller insert(Uri ContentValues)  which inserts new data into the content provider update(Uri ContentValues String String[])  which updates existing data in the content provider delete(Uri String String[])  which deletes data from the content provider getType(Uri)  which returns the MIME type of data in the content provider Requests to  ContentResolver  are automatically forwarded to the appropriate
 ContentProvider instance so subclasses don't have to worry about the details of
 cross-process calls.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
"<android.os.Bundle: void putStringArrayList(String,ArrayList)>","Inserts an ArrayList value into the mapping of this Bundle replacing
 any existing value for the given key.  Either key or value may be null.","key String : a String or null
This value may be null . |||
value ArrayList : an ArrayList object or null
This value may be null . |||",void,1,A mapping from String keys to various  Parcelable  values.,,,,,,,,
"<android.widget.SimpleCursorAdapter: void setViewText(TextView,String)>","Called by bindView() to set the text for a TextView but only if
 there is no existing ViewBinder or if the existing ViewBinder cannot
 handle binding to a TextView.

 Intended to be overridden by Adapters that need to filter strings
 retrieved from the database.","v TextView : TextView to receive text |||
text String : the text to be set for the TextView |||",void,1,"An easy adapter to map columns from a cursor to TextViews or ImageViews
 defined in an XML file. You can specify which columns you want which
 views you want to display the columns and the XML file that defines
 the appearance of these views.

 Binding occurs in two phases. First if a
  SimpleCursorAdapter.ViewBinder  is available
  ViewBinder#setViewValue(android.view.View android.database.Cursor int) 
 is invoked. If the returned value is true binding has occured. If the
 returned value is false and the view to bind is a TextView
  setViewText(android.widget.TextView java.lang.String)  is invoked. If the returned value
 is false and the view to bind is an ImageView
  setViewImage(android.widget.ImageView java.lang.String)  is invoked. If no appropriate
 binding can be found an  IllegalStateException  is thrown.

 If this adapter is used with filtering for instance in an
  AutoCompleteTextView  you can use the
  SimpleCursorAdapter.CursorToStringConverter  and the
  FilterQueryProvider  interfaces
 to get control over the filtering process. You can refer to
  convertToString(android.database.Cursor)  and
  CursorAdapter.runQueryOnBackgroundThread(java.lang.CharSequence)  for more information.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.content.pm.PackageItemInfo: CharSequence loadLabel(PackageManager)>,"Retrieve the current textual label associated with this item.  This
 will call back on the given PackageManager to load the label from
 the application.","pm PackageManager : A PackageManager from which the label can be loaded; usually
the PackageManager from which you originally retrieved this item.
This value cannot be null . |||","CharSequence Returns a CharSequence containing the item's label.  If the
 item does not have a label its name is returned.
 
 This value cannot be null . |||",1,"Base class containing information common to all package items held by
 the package manager.  This provides a very common basic set of attributes:
 a label icon and meta-data.  This class is not intended
 to be used by itself; it is simply here to share common definitions
 between all items returned by the package manager.  As such it does not
 itself implement Parcelable but does provide convenience methods to assist
 in the implementation of Parcelable in subclasses.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.content.Intent: String resolveType(ContentResolver)>,"Return the MIME data type of this intent.  If the type field is
 explicitly set that is simply returned.  Otherwise if the data is set
 the type of that data is returned.  If neither fields are set a null is
 returned.","resolver ContentResolver : A ContentResolver that can be used to determine the MIME
type of the intent's data.
This value cannot be null . |||",String The MIME type of this intent. |||,1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
"<android.content.pm.PackageManager: PackageInfo getPackageArchiveInfo(String,int)>","Retrieve overall information about an application package defined in a
 package archive file","archiveFilePath String : The path to the archive file
This value cannot be null . |||
flags int : Additional option flags to modify the data returned.
Value is either 0 or a combination of GET_ACTIVITIES  GET_CONFIGURATIONS  GET_GIDS  GET_INSTRUMENTATION  GET_INTENT_FILTERS  GET_META_DATA  GET_PERMISSIONS  GET_PROVIDERS  GET_RECEIVERS  GET_SERVICES  GET_SHARED_LIBRARY_FILES  GET_SIGNATURES  GET_SIGNING_CERTIFICATES  GET_URI_PERMISSION_PATTERNS  MATCH_UNINSTALLED_PACKAGES  MATCH_DISABLED_COMPONENTS  MATCH_DISABLED_UNTIL_USED_COMPONENTS  MATCH_SYSTEM_ONLY android.content.pm.PackageManager.MATCH_FACTORY_ONLY android.content.pm.PackageManager.MATCH_DEBUG_TRIAGED_MISSING android.content.pm.PackageManager.MATCH_INSTANT MATCH_APEX  GET_DISABLED_COMPONENTS  GET_DISABLED_UNTIL_USED_COMPONENTS  GET_UNINSTALLED_PACKAGES and android.content.pm.PackageManager.MATCH_HIDDEN_UNTIL_INSTALLED_COMPONENTS |||","PackageInfo A PackageInfo object containing information about the package
         archive. If the package could not be parsed returns null. |||",1,"Class for retrieving various kinds of information related to the application
 packages that are currently installed on the device.

 You can find this class through  Context#getPackageManager .","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.widget.TextView: Parcelable onSaveInstanceState()>,"Hook allowing a view to generate a representation of its internal state
 that can later be used to create a new instance with that same state.
 This state should only contain information that is not persistent or can
 not be reconstructed later. For example you will never store your
 current position on screen because that will be computed again when a
 new instance of the view is placed in its view hierarchy. Some examples of things you may store here: the current cursor position
 in a text view (but usually not the text itself since that is stored in a
 content provider or other persistent storage) the currently selected
 item in a list view. If you override this method you must call through to the
 superclass implementation.",,"Parcelable Returns a Parcelable object containing the view's current dynamic
         state or null if there is nothing interesting to save. |||",1,"A user interface element that displays text to the user.
 To provide user-editable text see  EditText .
  
 The following code sample shows a typical use with an XML layout
 and code to modify the contents of the text view:
  
 <LinearLayout
      xmlns:android=""http://schemas.android.com/apk/res/android""
      android:layout_width=""match_parent""
      android:layout_height=""match_parent"">
    <TextView
        android:id=""@+id/text_view_id""
        android:layout_height=""wrap_content""
        android:layout_width=""wrap_content""
        android:text=""@string/hello"" />
 </LinearLayout>
  
 This code sample demonstrates how to modify the contents of the text view
 defined in the previous XML layout:
  
 public class MainActivity extends Activity {

    protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_main);
         final TextView helloTextView = (TextView) findViewById(R.id.text_view_id);
         helloTextView.setText(R.string.user_greeting);
     }
 }
  
 To customize the appearance of TextView see  Styles and Themes .
  XML attributes 
 See  TextView Attributes 
  View Attributes","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.service.dreams.DreamService: void finish()>,"Stops the dream and detaches from the window. When the dream ends the system will be allowed to go to sleep fully unless there
 is a reason for it to be awake such as recent user activity or wake locks being held.",,void,17,"Extend this class to implement a custom dream (available to the user as a ""Daydream"").

  Dreams are interactive screensavers launched when a charging device is idle or docked in a
 desk dock. Dreams provide another modality for apps to express themselves tailored for
 an exhibition/lean-back experience. The  DreamService  lifecycle is as follows: onAttachedToWindow() Use this for initial setup such as calling  setContentView() . onDreamingStarted() Your dream has started so you should begin animations or other behaviors here. onDreamingStopped() Use this to stop the things you started in  onDreamingStarted() . onDetachedFromWindow() Use this to dismantle resources (for example detach from handlers
        and listeners). In addition onCreate and onDestroy (from the Service interface) will also be called but
 initialization and teardown should be done by overriding the hooks above. To be available to the system your  DreamService  should be declared in the
 manifest as follows: 
 <service
     android:name="".MyDream""
     android:exported=""true""
     android:icon=""@drawable/my_icon""
     android:label=""@string/my_dream_label"" >

     <intent-filter>
         <action android:name=""android.service.dreams.DreamService"" />
         <category android:name=""android.intent.category.DEFAULT"" />
     </intent-filter>

     <!-- Point to additional information for this dream (optional) -->
     <meta-data
         android:name=""android.service.dream""
         android:resource=""@xml/my_dream"" />
 </service>
  If specified with the  <meta-data>  element
 additional information for the dream is defined using the
  <dream>  element in a separate XML file.
 Currently the only addtional
 information you can provide is for a settings activity that allows the user to configure
 the dream behavior. For example: res/xml/my_dream.xml 
 <dream xmlns:android=""http://schemas.android.com/apk/res/android""
     android:settingsActivity=""com.example.app/.MyDreamSettingsActivity"" />
  This makes a Settings button available alongside your dream's listing in the
 system settings which when pressed opens the specified activity. To specify your dream layout call  setContentView(View)  typically during the
  onAttachedToWindow()  callback. For example: 
 public class MyDream extends DreamService {

     @Override
     public void onAttachedToWindow() {
         super.onAttachedToWindow();

         // Exit dream upon user touch
         setInteractive(false);
         // Hide system UI
         setFullscreen(true);
         // Set the dream layout
         setContentView(R.layout.dream);
     }
 }
  When targeting api level 21 and above you must declare the service in your manifest file
 with the  Manifest.permission.BIND_DREAM_SERVICE  permission. For example: 
 <service
     android:name="".MyDream""
     android:exported=""true""
     android:icon=""@drawable/my_icon""
     android:label=""@string/my_dream_label""
     android:permission=""android.permission.BIND_DREAM_SERVICE"">
   <intent-filter>
     <action android:name=”android.service.dreams.DreamService” />
     <category android:name=”android.intent.category.DEFAULT” />
   </intent-filter>
 </service>",,,,,,,,
<android.nfc.tech.MifareUltralight: MifareUltralight get(Tag)>,"Get an instance of MifareUltralight for the given tag. Returns null if MifareUltralight was not enumerated in Tag#getTechList - this indicates the tag is not MIFARE
 Ultralight compatible or that this Android
 device does not implement MIFARE Ultralight. Does not cause any RF activity and does not block.",tag Tag : an MIFARE Ultralight compatible tag |||,MifareUltralight MIFARE Ultralight object |||,10,"Provides access to MIFARE Ultralight properties and I/O operations on a  Tag .

  Acquire a  MifareUltralight  object using  get(Tag) .

  MIFARE Ultralight compatible tags have 4 byte pages  PAGE_SIZE .
 The primary operations on an Ultralight tag are  readPages(int)  and
  writePage(int byte[]) .

  The original MIFARE Ultralight consists of a 64 byte EEPROM. The first
 4 pages are for the OTP area manufacturer data and locking bits. They are
 readable and some bits are writable. The final 12 pages are the user
 read/write area. For more information see the NXP data sheet MF0ICU1.

  The MIFARE Ultralight C consists of a 192 byte EEPROM. The first 4 pages
 are for OTP manufacturer data and locking bits. The next 36 pages are the
 user read/write area. The next 4 pages are additional locking bits counters
 and authentication configuration and are readable. The final 4 pages are for
 the authentication key and are not readable. For more information see the
 NXP data sheet MF0ICU2.

  Implementation of this class on a Android NFC device is optional.
 If it is not implemented then
  MifareUltralight  will never be enumerated in  Tag#getTechList .
 If it is enumerated then all  MifareUltralight  I/O operations will be supported.
 In either case  NfcA  will also be enumerated on the tag
 because all MIFARE Ultralight tags are also  NfcA  tags.

  Note:  Methods that perform I/O operations
 require the  Manifest.permission.NFC  permission.","These classes provide access to a tag technology's features which vary by the type
 of tag that is scanned. A scanned tag can support multiple technologies and you can find
 out what they are by calling  getTechList() . For more information on dealing with tag technologies and handling the ones that you care about see
  The Tag Dispatch System .
 The  TagTechnology  interface provides an overview of the
 supported technologies.",,,,,,,
"<android.os.storage.StorageVolume: void writeToParcel(Parcel,int)>",Flatten this object in to a Parcel.,"parcel Parcel : The Parcel in which the object should be written. |||
flags int : Additional flags about how the object should be written.
May be 0 or Parcelable.PARCELABLE_WRITE_RETURN_VALUE .
Value is either 0 or a combination of Parcelable.PARCELABLE_WRITE_RETURN_VALUE and android.os.Parcelable.PARCELABLE_ELIDE_DUPLICATES |||",void,24,"Information about a shared/external storage volume for a specific user.

  
 A device always has one (and one only) primary storage volume but it could have extra volumes
 like SD cards and USB drives. This object represents the logical view of a storage
 volume for a specific user: different users might have different views for the same physical
 volume (for example if the volume is a built-in emulated storage).

  
 The storage volume is not necessarily mounted applications should use  getState()  to
 verify its state.

  
 Applications willing to read or write to this storage volume needs to get a permission from the
 user first which can be achieved in the following ways:

  To get access to standard directories (like the  Environment#DIRECTORY_PICTURES ) they
 can use the  createAccessIntent(java.lang.String) . This is the recommend way since it provides a
 simpler API and narrows the access to the given directory (and its descendants).
  To get access to any directory (and its descendants) they can use the Storage Acess
 Framework APIs (such as  Intent#ACTION_OPEN_DOCUMENT  and
  Intent#ACTION_OPEN_DOCUMENT_TREE  although these APIs do not guarantee the user will
 select this specific volume.
  To get read and write access to the primary storage volume applications can declare the
  Manifest.permission.READ_EXTERNAL_STORAGE  and
  Manifest.permission.WRITE_EXTERNAL_STORAGE  permissions respectively with the
 latter including the former. This approach is discouraged since users may be hesitant to grant
 broad access to all files contained on a storage device.
  It can be obtained through  StorageManager#getStorageVolumes()  and
  StorageManager#getPrimaryStorageVolume()  and also as an extra in some broadcasts
 (see  EXTRA_STORAGE_VOLUME ).

  
 See  Environment#getExternalStorageDirectory()  for more info about shared/external
 storage semantics.",,,,,,,,
<android.app.ProgressDialog: void setProgressDrawable(Drawable)>,Sets the drawable to be used to display the progress value.,d Drawable : the drawable to be used |||,void,1,"A dialog showing a progress indicator and an optional text message or view.
 Only a text message or a view can be used at the same time.

  The dialog can be made cancelable on back key press. The progress range is 0 to  max .","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.app.admin.DevicePolicyManager: int getPasswordMinimumUpperCase(ComponentName)>,"Retrieve the current number of upper case letters required in the password
 for a particular admin or all admins that set restrictions on this user and
 its participating profiles. Restrictions on profiles that have a separate challenge
 are not taken into account.
 This is the same value as set by setPasswordMinimumUpperCase(android.content.ComponentName int) and only applies when the password quality is PASSWORD_QUALITY_COMPLEX . On devices not supporting PackageManager#FEATURE_SECURE_LOCK_SCREEN feature the
 password is always treated as empty. This method can be called on the DevicePolicyManager instance
 returned by getParentProfileInstance(android.content.ComponentName) in order to retrieve
 restrictions on the parent profile.","admin ComponentName : The name of the admin component to check or null to
aggregate all admins.
This value may be null . |||","int The minimum number of upper case letters required in the
         password. |||",11,"Public interface for managing policies enforced on a device. Most clients of this class must be
 registered with the system as a  device
 administrator . Additionally a device administrator may be registered as either a profile or
 device owner. A given method is accessible to all device administrators unless the documentation
 for that method specifies that it is restricted to either device or profile owners. Any
 application calling an api may only pass as an argument a device administrator component it
 owns. Otherwise a  SecurityException  will be thrown.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
"<android.widget.Toast: Toast makeText(Context,int,int)>",Make a standard toast that just contains text from a resource.,"context Context : The context to use.  Usually your Application or Activity object. |||
resId int : The resource id of the string resource to use.  Can be formatted text. |||
duration int : How long to display the message.  Either LENGTH_SHORT or LENGTH_LONG Value is LENGTH_SHORT or LENGTH_LONG |||",Toast |||,1,"A toast is a view containing a quick little message for the user.  The toast class
 helps you create and show those.
  
 When the view is shown to the user appears as a floating view over the
 application.  It will never receive focus.  The user will probably be in the
 middle of typing something else.  The idea is to be as unobtrusive as
 possible while still showing the user the information you want them to see.
 Two examples are the volume control and the brief message saying that your
 settings have been saved.
  
 The easiest way to use this class is to call one of the static methods that constructs
 everything you need and returns a new Toast object.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.media.AudioManager: void unregisterMediaButtonEventReceiver(ComponentName)>,"This method was deprecated
      in API level 21. Use MediaSession instead. Unregister the receiver of MEDIA_BUTTON intents.",eventReceiver ComponentName : identifier of a BroadcastReceiver that was registered with registerMediaButtonEventReceiver(android.content.ComponentName) . |||,void,8,AudioManager provides access to volume and ringer mode control.,"The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",,,,,,,
"<android.telephony.SmsManager: void sendDataMessage(String,String,short,byte,PendingIntent,PendingIntent)>","Send a data based SMS to a specific application port. Note: Using this method requires that your app has the Manifest.permission.SEND_SMS permission. Note: If getDefault() is used to instantiate this
 manager on a multi-SIM device this operation may fail sending the SMS message because no
 suitable default subscription could be found. In this case if sentIntent is
 non-null then the PendingIntent will be sent with an error code RESULT_ERROR_GENERIC_FAILURE and an extra string ""noDefault"" containing the
 boolean value true . See getDefault() for more information on the conditions
 where this operation may fail.","destinationAddress String : the address to send the message to |||
scAddress String : is the service center address or null to use
the current default SMSC |||
destinationPort short : the port to deliver the message to |||
data byte : the body of the message to send |||
sentIntent PendingIntent : if not NULL this PendingIntent is
broadcast when the message is successfully sent or failed.
The result code will be Activity.RESULT_OK for success
or one of these errors: RESULT_ERROR_GENERIC_FAILURE RESULT_ERROR_RADIO_OFF RESULT_ERROR_NULL_PDU RESULT_ERROR_NO_SERVICE RESULT_ERROR_NO_SERVICE RESULT_ERROR_LIMIT_EXCEEDED RESULT_ERROR_FDN_CHECK_FAILURE RESULT_ERROR_SHORT_CODE_NOT_ALLOWED RESULT_ERROR_SHORT_CODE_NEVER_ALLOWED RESULT_RADIO_NOT_AVAILABLE RESULT_NETWORK_REJECT RESULT_INVALID_ARGUMENTS RESULT_INVALID_STATE RESULT_NO_MEMORY RESULT_INVALID_SMS_FORMAT RESULT_SYSTEM_ERROR RESULT_MODEM_ERROR RESULT_NETWORK_ERROR RESULT_ENCODING_ERROR RESULT_INVALID_SMSC_ADDRESS RESULT_OPERATION_NOT_ALLOWED RESULT_INTERNAL_ERROR RESULT_NO_RESOURCES RESULT_CANCELLED RESULT_REQUEST_NOT_SUPPORTED RESULT_NO_BLUETOOTH_SERVICE RESULT_INVALID_BLUETOOTH_ADDRESS RESULT_BLUETOOTH_DISCONNECTED RESULT_UNEXPECTED_EVENT_STOP_SENDING RESULT_SMS_BLOCKED_DURING_EMERGENCY RESULT_SMS_SEND_RETRY_FAILED RESULT_REMOTE_EXCEPTION RESULT_NO_DEFAULT_SMS_APP RESULT_RIL_RADIO_NOT_AVAILABLE RESULT_RIL_SMS_SEND_FAIL_RETRY RESULT_RIL_NETWORK_REJECT RESULT_RIL_INVALID_STATE RESULT_RIL_INVALID_ARGUMENTS RESULT_RIL_NO_MEMORY RESULT_RIL_REQUEST_RATE_LIMITED RESULT_RIL_INVALID_SMS_FORMAT RESULT_RIL_SYSTEM_ERR RESULT_RIL_ENCODING_ERR RESULT_RIL_INVALID_SMSC_ADDRESS RESULT_RIL_MODEM_ERR RESULT_RIL_NETWORK_ERR RESULT_RIL_INTERNAL_ERR RESULT_RIL_REQUEST_NOT_SUPPORTED RESULT_RIL_INVALID_MODEM_STATE RESULT_RIL_NETWORK_NOT_READY RESULT_RIL_OPERATION_NOT_ALLOWED RESULT_RIL_NO_RESOURCES RESULT_RIL_CANCELLED RESULT_RIL_SIM_ABSENT For RESULT_ERROR_GENERIC_FAILURE or any of the RESULT_RIL errors
the sentIntent may include the extra ""errorCode"" containing a radio technology specific
value generally only useful for troubleshooting. The per-application based SMS control checks sentIntent. If sentIntent
is NULL the caller will be checked against all unknown applications
which cause smaller number of SMS to be sent in checking period. |||
deliveryIntent PendingIntent : if not NULL this PendingIntent is
broadcast when the message is delivered to the recipient.  The
raw pdu of the status report is in the extended data (""pdu""). |||",void,4,"Manages SMS operations such as sending data text and pdu SMS messages.
 Get this object by calling the static method  getDefault() . To create an instance of
  SmsManager  associated with a specific subscription ID call
  getSmsManagerForSubscriptionId(int) . This is typically used for devices that support
 multiple active subscriptions at once.

  For information about how to behave as the default SMS app on Android 4.4 (API level 19)
 and higher see  Telephony .",,,,,,,,
<android.media.AudioManager: void stopBluetoothSco()>,"Stop bluetooth SCO audio connection. Requires Permission: Manifest.permission.MODIFY_AUDIO_SETTINGS . This method must be called by applications having requested the use of
 bluetooth SCO audio with startBluetoothSco() when finished with the SCO
 connection or if connection fails.",,void,8,AudioManager provides access to volume and ringer mode control.,"The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",,,,,,,
<android.app.ActivityManager: List getProcessesInErrorState()>,"Returns a list of any processes that are currently in an error condition.  The result
 will be null if all processes are running properly at this time.",,"List < ActivityManager.ProcessErrorStateInfo > Returns a list of ProcessErrorStateInfo records or null if there are no
 current error conditions (it will not return an empty list).  This list ordering is not
 specified. |||",1,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
"<android.speech.tts.TextToSpeech: int playEarcon(String,int,HashMap)>","This method was deprecated
      in API level 21. As of API level 21 replaced by playEarcon(java.lang.String int android.os.Bundle java.lang.String) . Plays the earcon using the specified queueing mode and parameters.
 The earcon must already have been added with addEarcon(java.lang.String java.lang.String) or addEarcon(java.lang.String java.lang.String int) .
 This method is asynchronous i.e. the method just adds the request to the queue of TTS
 requests and then returns. The synthesis might not have finished (or even started!) at the
 time when this method returns. In order to reliably detect errors during synthesis
 we recommend setting an utterance progress listener (see setOnUtteranceProgressListener(UtteranceProgressListener) ) and using the Engine#KEY_PARAM_UTTERANCE_ID parameter.","earcon String : The earcon that should be played |||
queueMode int : QUEUE_ADD or QUEUE_FLUSH . |||
params HashMap : Parameters for the request. Can be null.
Supported parameter names: Engine#KEY_PARAM_STREAM  Engine#KEY_PARAM_UTTERANCE_ID .
Engine specific parameters may be passed in but the parameter keys
must be prefixed by the name of the engine they are intended for. For example
the keys ""com.svox.pico_foo"" and ""com.svox.pico:bar"" will be passed to the
engine named ""com.svox.pico"" if it is being used. |||",int ERROR or SUCCESS of queuing the playEarcon operation. |||,4,"Synthesizes speech from text for immediate playback or to create a sound file.
  A TextToSpeech instance can only be used to synthesize text once it has completed its
 initialization. Implement the  TextToSpeech.OnInitListener  to be
 notified of the completion of the initialization. 
 When you are done using the TextToSpeech instance call the  shutdown()  method
 to release the native resources used by the TextToSpeech engine.",,,,,,,,
<android.os.Parcel: void writeArray(Object)>,"Flatten an Object array into the parcel at the current dataPosition()
 growing dataCapacity() if needed.  The array values are written using writeValue(Object) and must follow the specification there.",val Object : This value may be null . |||,void,1,"Container for a message (data and object references) that can
 be sent through an IBinder.  A Parcel can contain both flattened data
 that will be unflattened on the other side of the IPC (using the various
 methods here for writing specific types or the general
  Parcelable  interface) and references to live  IBinder 
 objects that will result in the other side receiving a proxy IBinder
 connected with the original IBinder in the Parcel.

  Parcel is  not  a general-purpose
 serialization mechanism.  This class (and the corresponding
  Parcelable  API for placing arbitrary objects into a Parcel) is
 designed as a high-performance IPC transport.  As such it is not
 appropriate to place any Parcel data in to persistent storage: changes
 in the underlying implementation of any of the data in the Parcel can
 render older data unreadable. The bulk of the Parcel API revolves around reading and writing data
 of various types.  There are six major classes of such functions available. Primitives The most basic data functions are for writing and reading primitive
 data types:  writeByte(byte)   readByte()   writeDouble(double) 
  readDouble()   writeFloat(float)   readFloat()   writeInt(int) 
  readInt()   writeLong(long)   readLong() 
  writeString(String)   readString() .  Most other
 data operations are built on top of these.  The given data is written and
 read using the endianess of the host CPU. Primitive Arrays There are a variety of methods for reading and writing raw arrays
 of primitive objects which generally result in writing a 4-byte length
 followed by the primitive data items.  The methods for reading can either
 read the data into an existing array or create and return a new array.
 These available types are: writeBooleanArray(boolean[]) 
  readBooleanArray(boolean[])   createBooleanArray() writeByteArray(byte[]) 
  writeByteArray(byte[] int int)   readByteArray(byte[]) 
  createByteArray() writeCharArray(char[])   readCharArray(char[]) 
  createCharArray() writeDoubleArray(double[])   readDoubleArray(double[]) 
  createDoubleArray() writeFloatArray(float[])   readFloatArray(float[]) 
  createFloatArray() writeIntArray(int[])   readIntArray(int[]) 
  createIntArray() writeLongArray(long[])   readLongArray(long[]) 
  createLongArray() writeStringArray(java.lang.String[])   readStringArray(java.lang.String[]) 
  createStringArray() .
  writeSparseBooleanArray(android.util.SparseBooleanArray) 
  readSparseBooleanArray() .
  Parcelables The  Parcelable  protocol provides an extremely efficient (but
 low-level) protocol for objects to write and read themselves from Parcels.
 You can use the direct methods  writeParcelable(android.os.Parcelable int) 
 and  readParcelable(java.lang.ClassLoader)  or
  writeParcelableArray(T[] int)  and
  readParcelableArray(java.lang.ClassLoader)  to write or read.  These
 methods write both the class type and its data to the Parcel allowing
 that class to be reconstructed from the appropriate class loader when
 later reading. There are also some methods that provide a more efficient way to work
 with Parcelables:  writeTypedObject(T int)   writeTypedArray(T[] int) 
  writeTypedList(List )   readTypedObject(Parcelable.Creator ) 
  createTypedArray(Parcelable.Creator )  and  createTypedArrayList(Parcelable.Creator ) .  These methods
 do not write the class information of the original object: instead the
 caller of the read function must know what type to expect and pass in the
 appropriate  Parcelable.Creator  instead to
 properly construct the new object and read its data.  (To more efficient
 write and read a single Parcelable object that is not null you can directly
 call  Parcelable#writeToParcel  and
  Parcelable.Creator#createFromParcel 
 yourself.) Bundles A special type-safe container called  Bundle  is available
 for key/value maps of heterogeneous values.  This has many optimizations
 for improved performance when reading and writing data and its type-safe
 API avoids difficult to debug type errors when finally marshalling the
 data contents into a Parcel.  The methods to use are
  writeBundle(android.os.Bundle)   readBundle()  and
  readBundle(java.lang.ClassLoader) .

  Active Objects An unusual feature of Parcel is the ability to read and write active
 objects.  For these objects the actual contents of the object is not
 written rather a special token referencing the object is written.  When
 reading the object back from the Parcel you do not get a new instance of
 the object but rather a handle that operates on the exact same object that
 was originally written.  There are two forms of active objects available. Binder  objects are a core facility of Android's general cross-process
 communication system.  The  IBinder  interface describes an abstract
 protocol with a Binder object.  Any such interface can be written in to
 a Parcel and upon reading you will receive either the original object
 implementing that interface or a special proxy implementation
 that communicates calls back to the original object.  The methods to use are
  writeStrongBinder(android.os.IBinder) 
  writeStrongInterface(android.os.IInterface)   readStrongBinder() 
  writeBinderArray(android.os.IBinder[])   readBinderArray(android.os.IBinder[]) 
  createBinderArray() 
  writeBinderList(java.util.List)   readBinderList(java.util.List) 
  createBinderArrayList() . FileDescriptor objects representing raw Linux file descriptor identifiers
 can be written and  ParcelFileDescriptor  objects returned to operate
 on the original file descriptor.  The returned file descriptor is a dup
 of the original file descriptor: the object and fd is different but
 operating on the same underlying file stream with the same position etc.
 The methods to use are  writeFileDescriptor(java.io.FileDescriptor) 
  readFileDescriptor() .

  Untyped Containers A final class of methods are for writing and reading standard Java
 containers of arbitrary types.  These all revolve around the
  writeValue(java.lang.Object)  and  readValue(java.lang.ClassLoader)  methods
 which define the types of objects allowed.  The container methods are
  writeArray(java.lang.Object[])   readArray(java.lang.ClassLoader) 
  writeList(java.util.List)   readList(java.util.List java.lang.ClassLoader) 
  readArrayList(java.lang.ClassLoader) 
  writeMap(java.util.Map)   readMap(java.util.Map java.lang.ClassLoader) 
  writeSparseArray(android.util.SparseArray) 
  readSparseArray(java.lang.ClassLoader) .",,,,,,,,
"<android.view.View: void scrollBy(int,int)>","Move the scrolled position of your view. This will cause a call to onScrollChanged(int int int int) and the view will be
 invalidated.","x int : the amount of pixels to scroll by horizontally |||
y int : the amount of pixels to scroll by vertically |||",void,1,"This class represents the basic building block for user interface components. A View
 occupies a rectangular area on the screen and is responsible for drawing and
 event handling. View is the base class for  widgets  which are
 used to create interactive UI components (buttons text fields etc.). The
  ViewGroup  subclass is the base class for  layouts  which
 are invisible containers that hold other Views (or other ViewGroups) and define
 their layout properties.",,,,,,,,
<android.bluetooth.BluetoothAdapter: String getAddress()>,"Returns the hardware address of the local Bluetooth adapter. For example ""00:11:22:AA:BB:CC"". Requires Manifest.permission.BLUETOOTH",,String Bluetooth hardware address as string |||,5,"Represents the local device Bluetooth adapter. The  BluetoothAdapter 
 lets you perform fundamental Bluetooth tasks such as initiate
 device discovery query a list of bonded (paired) devices
 instantiate a  BluetoothDevice  using a known MAC address and create
 a  BluetoothServerSocket  to listen for connection requests from other
 devices and start a scan for Bluetooth LE devices.

  To get a  BluetoothAdapter  representing the local Bluetooth
 adapter call the  BluetoothManager#getAdapter  function on  BluetoothManager .
 On JELLY_BEAN_MR1 and below you will need to use the static  getDefaultAdapter() 
 method instead.
  
 Fundamentally this is your starting point for all
 Bluetooth actions. Once you have the local adapter you can get a set of
  BluetoothDevice  objects representing all paired devices with
  getBondedDevices() ; start device discovery with
  startDiscovery() ; or create a  BluetoothServerSocket  to
 listen for incoming RFComm connection requests with  listenUsingRfcommWithServiceRecord(java.lang.String java.util.UUID) ; listen for incoming L2CAP Connection-oriented
 Channels (CoC) connection requests with  listenUsingL2capChannel() ; or start a scan for
 Bluetooth LE devices with  startLeScan(android.bluetooth.BluetoothAdapter.LeScanCallback) .
  This class is thread safe. Note: 
 Most methods require the  Manifest.permission.BLUETOOTH 
 permission and some also require the
  Manifest.permission.BLUETOOTH_ADMIN  permission.","Provides classes that manage Bluetooth functionality such as scanning for
 devices connecting with devices and managing data transfer between devices.
 The Bluetooth API supports both ""Classic Bluetooth"" and Bluetooth Low Energy. For more information about Classic Bluetooth see the
  Bluetooth  guide.
 For more information about Bluetooth Low Energy see the
  
 Bluetooth Low Energy  (BLE) guide. The Bluetooth APIs let applications: Scan for other Bluetooth devices (including BLE devices). Query the local Bluetooth adapter for paired Bluetooth devices. Establish RFCOMM channels/sockets. Connect to specified sockets on other devices. Transfer data to and from other devices. Communicate with BLE devices such as proximity sensors heart rate
     monitors fitness devices and so on. Act as a GATT client or a GATT server (BLE). 
 To perform Bluetooth communication using these APIs an application must
 declare the  BLUETOOTH  permission. Some
 additional functionality such as requesting device discovery
 also requires the  BLUETOOTH_ADMIN 
 permission.
  Note: 
 Not all Android-powered devices provide Bluetooth functionality.",,,,,,,
<android.test.InstrumentationTestCase: void sendKeys(int)>,"Sends a series of key events through instrumentation and waits for idle. For instance:
 sendKeys(KEYCODE_DPAD_LEFT KEYCODE_DPAD_CENTER).",keys int : The series of key codes to send through instrumentation. |||,void,1,A test case that has access to  Instrumentation .,,,,,,,,
"<android.test.AndroidTestCase: void assertReadingContentUriRequiresPermission(Uri,String)>","Asserts that reading from the content uri requires a particular permission by querying the
 uri and ensuring a SecurityException is thrown mentioning the particular permission.","uri Uri : The uri that requires a permission to query. |||
permission String : The permission that should be required. |||",void,4,Extend this if you need to access Resources or other things that depend on Activity Context.,,,,,,,,
<android.widget.TextView: void clearComposingText()>,"Use BaseInputConnection#removeComposingSpans to remove any IME composing
 state from this text view.",,void,3,"A user interface element that displays text to the user.
 To provide user-editable text see  EditText .
  
 The following code sample shows a typical use with an XML layout
 and code to modify the contents of the text view:
  
 <LinearLayout
      xmlns:android=""http://schemas.android.com/apk/res/android""
      android:layout_width=""match_parent""
      android:layout_height=""match_parent"">
    <TextView
        android:id=""@+id/text_view_id""
        android:layout_height=""wrap_content""
        android:layout_width=""wrap_content""
        android:text=""@string/hello"" />
 </LinearLayout>
  
 This code sample demonstrates how to modify the contents of the text view
 defined in the previous XML layout:
  
 public class MainActivity extends Activity {

    protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_main);
         final TextView helloTextView = (TextView) findViewById(R.id.text_view_id);
         helloTextView.setText(R.string.user_greeting);
     }
 }
  
 To customize the appearance of TextView see  Styles and Themes .
  XML attributes 
 See  TextView Attributes 
  View Attributes","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
"<android.widget.CursorAdapter: View newDropDownView(Context,Cursor,ViewGroup)>",Makes a new drop down view to hold the data pointed to by cursor.,"context Context : Interface to application's global information |||
cursor Cursor : The cursor from which to get the data. The cursor is already
moved to the correct position. |||
parent ViewGroup : The parent to which the new view is attached to |||",View the newly created view. |||,1,"Adapter that exposes data from a  Cursor  to a
  ListView  widget.
  
 The Cursor must include a column named ""_id"" or this class will not work.
 Additionally using  MergeCursor  with this class will
 not work if the merged Cursors have overlapping values in their ""_id""
 columns.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.content.Intent: ArrayList getParcelableArrayListExtra(String)>,Retrieve extended data from the intent.,name String : The name of the desired item. |||,"ArrayList <T> the value of an item previously added with
 putParcelableArrayListExtra() or null if no
 ArrayList value was found. |||",1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.media.MediaPlayer: void release()>,"Releases resources associated with this MediaPlayer object.
 It is considered good practice to call this method when you're
 done using the MediaPlayer. In particular whenever an Activity
 of an application is paused (its onPause() method is called)
 or stopped (its onStop() method is called) this method should be
 invoked to release the MediaPlayer object unless the application
 has a special need to keep the object around. In addition to
 unnecessary resources (such as memory and instances of codecs)
 being held failure to call this method immediately if a
 MediaPlayer object is no longer needed may also lead to
 continuous battery consumption for mobile devices and playback
 failure for other applications if no multiple instances of the
 same codec are supported on a device. Even if multiple instances
 of the same codec are supported some performance degradation
 may be expected when unnecessary multiple instances are used
 at the same time.",,void,1,"MediaPlayer class can be used to control playback
 of audio/video files and streams. An example on how to use the methods in
 this class can be found in  VideoView .

  Topics covered here are:
  State Diagram Valid and Invalid States Permissions Register informational and error callbacks","The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",,,,,,,
<android.text.SpannableStringBuilder: SpannableStringBuilder valueOf(CharSequence)>,,source CharSequence |||,SpannableStringBuilder |||,1,"This is the class for text whose content is immutable but to which
 markup objects can be attached and detached.
 For mutable text see  SpannableStringBuilder .","Provides classes used to render or track text and text spans on the screen. You can use these classes to design your own widgets that manage text
 to handle arbitrary text spans for changes or to handle drawing yourself
 for an existing widget. The Span… interfaces and classes are used to create or manage spans of
 text in a View item. You can use these to style the text or background or to
 listen for changes. If creating your own widget extend DynamicLayout to manages
 the actual wrapping and drawing of your text.",,,,,,,
<android.widget.NumberPicker: void computeScroll()>,"Called by a parent to request that a child update its values for mScrollX
 and mScrollY if necessary. This will typically be done if the child is
 animating a scroll using a Scroller object.",,void,11,"A widget that enables the user to select a number from a predefined range.
 There are two flavors of this widget and which one is presented to the user
 depends on the current theme.
  
 If the current theme is derived from  R.style.Theme  the widget
 presents the current value as an editable input field with an increment button
 above and a decrement button below. Long pressing the buttons allows for a quick
 change of the current value. Tapping on the input field allows to type in
 a desired value.
  
 If the current theme is derived from  R.style.Theme_Holo  or
  R.style.Theme_Holo_Light  the widget presents the current
 value as an editable input field with a lesser value above and a greater
 value below. Tapping on the lesser or greater value selects it by animating
 the number axis up or down to make the chosen value current. Flinging up
 or down allows for multiple increments or decrements of the current value.
 Long pressing on the lesser and greater values also allows for a quick change
 of the current value. Tapping on the current value allows to type in a
 desired value.
  
 If the current theme is derived from  R.style.Theme_Material 
 the widget presents the current value as a scrolling vertical selector with
 the selected value in the center and the previous and following numbers above
 and below separated by a divider. The value is changed by flinging vertically.
 The thickness of the divider can be changed by using the
  R.attr.selectionDividerHeight  attribute and the color of the
 divider can be changed by using the
  R.attr.colorControlNormal  attribute.
  
 For an example of using this widget see  TimePicker .","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.net.wifi.WifiManager: DhcpInfo getDhcpInfo()>,"Return the DHCP-assigned addresses from the last successful DHCP request
 if any.",,DhcpInfo the DHCP information |||,1,"This class provides the primary API for managing all aspects of Wi-Fi
 connectivity.
  
 On releases before  Build.VERSION_CODES.N  this object
 should only be obtained from an  Context#getApplicationContext()  and not from any other derived context to avoid memory
 leaks within the calling process.
  
 It deals with several categories of items:
  The list of configured networks. The list can be viewed and updated and
 attributes of individual entries can be modified. The currently active Wi-Fi network if any. Connectivity can be
 established or torn down and dynamic information about the state of the
 network can be queried. Results of access point scans containing enough information to make
 decisions about what access point to connect to. It defines the names of various Intent actions that are broadcast upon
 any sort of change in Wi-Fi state.
  
 This is the API to use when performing Wi-Fi specific operations. To perform
 operations that pertain to network connectivity at an abstract level use
  ConnectivityManager .","Provides classes to manage Wi-Fi functionality on the device. The Wi-Fi APIs provide a means by which applications can communicate
 with the lower-level wireless stack that provides Wi-Fi network access. Almost all
 information from the device supplicant is available including the connected network's
 link speed IP address negotiation state and more plus information about other
 networks that are available. Some other API features include the ability to
 scan add save terminate and initiate Wi-Fi connections. Some APIs may require the following user permissions: ACCESS_WIFI_STATE CHANGE_WIFI_STATE CHANGE_WIFI_MULTICAST_STATE Note:  Not all Android-powered devices provide Wi-Fi functionality.
 If your application uses Wi-Fi declare so with a  <uses-feature> 
 element in the manifest file: 
 <manifest ...>
     <uses-feature android:name=""android.hardware.wifi"" />
     ...
 </manifest>",,,,,,,
<android.webkit.WebView: void goBackOrForward(int)>,"Goes to the history item that is the number of steps away from
 the current item. Steps is negative if backward and positive
 if forward.","steps int : the number of steps to take back or forward in the back
forward list |||",void,1,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",,,,,,,
<android.nfc.tech.IsoDep: int getTimeout()>,Get the current timeout for transceive(byte[]) in milliseconds. Requires the Manifest.permission.NFC permission.,,int timeout value in milliseconds |||,14,"Provides access to ISO-DEP (ISO 14443-4) properties and I/O operations on a  Tag .

  Acquire an  IsoDep  object using  get(Tag) .
  The primary ISO-DEP I/O operation is  transceive(byte[]) . Applications must
 implement their own protocol stack on top of  transceive(byte[]) .
  Tags that enumerate the  IsoDep  technology in  Tag#getTechList 
 will also enumerate
  NfcA  or  NfcB  (since IsoDep builds on top of either of these).

  Note:  Methods that perform I/O operations
 require the  Manifest.permission.NFC  permission.","These classes provide access to a tag technology's features which vary by the type
 of tag that is scanned. A scanned tag can support multiple technologies and you can find
 out what they are by calling  getTechList() . For more information on dealing with tag technologies and handling the ones that you care about see
  The Tag Dispatch System .
 The  TagTechnology  interface provides an overview of the
 supported technologies.",,,,,,,
"<android.test.TouchUtils: void dragViewToBottom(InstrumentationTestCase,Activity,View,int)>",Simulate touching the center of a view and dragging to the bottom of the screen.,"test InstrumentationTestCase : The test case that is being run |||
activity Activity : The activity that is in the foreground of the test case |||
v View : The view that should be dragged |||
stepCount int : How many move steps to include in the drag |||",void,3,"Reusable methods for generating touch events. These methods can be used with
 InstrumentationTestCase or ActivityInstrumentationTestCase2 to simulate user interaction with
 the application through a touch screen.",,,,,,,,
<android.content.Intent: CharSequence getCharSequenceExtra(String)>,Retrieve extended data from the intent.,name String : The name of the desired item. |||,"CharSequence the value of an item previously added with putExtra()
 or null if no CharSequence value was found. |||",1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.widget.GridView: void setRemoteViewsAdapter(Intent)>,"Sets up this AbsListView to use a remote views adapter which connects to a RemoteViewsService
 through the specified intent.",intent Intent : the intent used to identify the RemoteViewsService for the adapter to connect to. |||,void,11,"A view that shows items in two-dimensional scrolling grid. The items in the
 grid come from the  ListAdapter  associated with this view.

  See the  Grid
 View  guide.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.app.Dialog: void onRestoreInstanceState(Bundle)>,"Restore the state of the dialog from a previously saved bundle.

 The default implementation restores the state of the dialog's view
 hierarchy that was saved in the default implementation of onSaveInstanceState() so be sure to call through to super when overriding unless you want to
 do all restoring of state yourself.","savedInstanceState Bundle : The state of the dialog previously saved by onSaveInstanceState() .
This value cannot be null . |||",void,1,"Base class for Dialogs.

  Note: Activities provide a facility to manage the creation saving and
 restoring of dialogs. See  Activity#onCreateDialog(int) 
  Activity#onPrepareDialog(int Dialog) 
  Activity#showDialog(int)  and  Activity#dismissDialog(int) . If
 these methods are used  getOwnerActivity()  will return the Activity
 that managed this dialog.

  Often you will want to have a Dialog display on top of the current
 input method because there is no reason for it to accept text.  You can
 do this by setting the  WindowManager.LayoutParams#FLAG_ALT_FOCUSABLE_IM  window flag (assuming
 your Dialog takes input focus as it the default) with the following code:

  
 getWindow().setFlags(WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM
         WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.os.Bundle: float getFloat(String)>,"Returns the value associated with the given key or 0.0f if
 no mapping of the desired type exists for the given key.",key String : a String |||,float a float value |||,1,A mapping from String keys to various  Parcelable  values.,,,,,,,,
<android.media.effect.EffectContext: void release()>,"Releases the context. Releases all the resources and effects associated with the EffectContext. This renders the
 context and all the effects bound to this context invalid. You must no longer use the context
 or any of its bound effects after calling release(). Note that this method must be called with the proper EGL context made current as the
 EffectContext and its effects may release internal GL resources.",,void,14,"An EffectContext keeps all necessary state information to run Effects within a Open GL ES 2.0
 context. Every EffectContext is bound to one GL context. The application is responsible for creating
 this EGL context and making it current before applying any effect. If your EGL context is
 destroyed the EffectContext becomes invalid and any effects bound to this context can no longer
 be used. If you switch to another EGL context you must create a new EffectContext. Each Effect
 is bound to a single EffectContext and can only be executed in that context.","The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",,,,,,,
"<android.widget.SimpleAdapter: void setViewImage(ImageView,int)>","Called by bindView() to set the image for an ImageView but only if
 there is no existing ViewBinder or if the existing ViewBinder cannot
 handle binding to an ImageView.

 This method is called instead of setViewImage(android.widget.ImageView java.lang.String) if the supplied data is an int or Integer.","v ImageView : ImageView to receive an image |||
value int : the value retrieved from the data set |||",void,1,"An easy adapter to map static data to views defined in an XML file. You can specify the data
 backing the list as an ArrayList of Maps. Each entry in the ArrayList corresponds to one row
 in the list. The Maps contain the data for each row. You also specify an XML file that
 defines the views used to display the row and a mapping from keys in the Map to specific
 views.

 Binding data to views occurs in two phases. First if a
  SimpleAdapter.ViewBinder  is available
  ViewBinder#setViewValue(android.view.View Object String) 
 is invoked. If the returned value is true binding has occurred.
 If the returned value is false the following views are then tried in order:
   A view that implements Checkable (e.g. CheckBox).  The expected bind value is a boolean.
   TextView.  The expected bind value is a string and  setViewText(android.widget.TextView java.lang.String) 
 is invoked.
   ImageView. The expected bind value is a resource id or a string and
  setViewImage(android.widget.ImageView int)  or  setViewImage(android.widget.ImageView java.lang.String)  is invoked.
  IllegalStateException","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.widget.ProgressBar: void onRestoreInstanceState(Parcelable)>,"Hook allowing a view to re-apply a representation of its internal state that had previously
 been generated by onSaveInstanceState() . This function will never be called with a
 null state. If you override this method you must call through to the
 superclass implementation.",state Parcelable : The frozen state that had previously been returned by onSaveInstanceState() . |||,void,1,"A user interface element that indicates the progress of an operation.
 Progress bar supports two modes to represent progress: determinate and indeterminate. For
 a visual overview of the difference between determinate and indeterminate progress modes see
  
 Progress & activity .
 Display progress bars to a user in a non-interruptive way.
 Show the progress bar in your app's user interface or in a notification
 instead of within a dialog.
  Indeterminate Progress 
 Use indeterminate mode for the progress bar when you do not know how long an
 operation will take.
 Indeterminate mode is the default for progress bar and shows a cyclic animation without a
 specific amount of progress indicated.
 The following example shows an indeterminate progress bar:
  
 <ProgressBar
      android:id=""@+id/indeterminateBar""
      android:layout_width=""wrap_content""
      android:layout_height=""wrap_content""
      />
  Determinate Progress 
 Use determinate mode for the progress bar when you want to show that a specific quantity of
 progress has occurred.
 For example the percent remaining of a file being retrieved the amount records in
 a batch written to database or the percent remaining of an audio file that is playing.
  
 To indicate determinate progress you set the style of the progress bar to
  R.style.Widget_ProgressBar_Horizontal  and set the amount of progress.
 The following example shows a determinate progress bar that is 25% complete:
  
 <ProgressBar
      android:id=""@+id/determinateBar""
      style=""@android:style/Widget.ProgressBar.Horizontal""
      android:layout_width=""wrap_content""
      android:layout_height=""wrap_content""
      android:progress=""25""/>
  setProgress(int) incrementProgressBy(int) android:max Other progress bar styles provided by the system include: Widget.ProgressBar.Horizontal Widget.ProgressBar.Small Widget.ProgressBar.Large Widget.ProgressBar.Inverse Widget.ProgressBar.Small.Inverse Widget.ProgressBar.Large.Inverse The ""inverse"" styles provide an inverse color scheme for the spinner which may be necessary
 if your application uses a light colored theme (a white background). XML attributes 
 See  ProgressBar Attributes 
  View Attributes","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.text.SpannableString: SpannableString valueOf(CharSequence)>,,source CharSequence |||,SpannableString |||,1,"This is the class for text whose content is immutable but to which
 markup objects can be attached and detached.
 For mutable text see  SpannableStringBuilder .","Provides classes used to render or track text and text spans on the screen. You can use these classes to design your own widgets that manage text
 to handle arbitrary text spans for changes or to handle drawing yourself
 for an existing widget. The Span… interfaces and classes are used to create or manage spans of
 text in a View item. You can use these to style the text or background or to
 listen for changes. If creating your own widget extend DynamicLayout to manages
 the actual wrapping and drawing of your text.",,,,,,,
"<android.content.ContentResolver: Cursor query(Uri,String,String,String,String)>","Query the given URI returning a Cursor over the result set. For best performance the caller should follow these guidelines: Provide an explicit projection to prevent
 reading data from storage that aren't going to be used. 
Use question mark parameter markers such as 'phone=?' instead of
 explicit values in the selection parameter so that queries
 that differ only by those values will be recognized as the same
 for caching purposes.","uri Uri : The URI using the content:// scheme for the content to
retrieve.
This value cannot be null . |||
projection String : A list of which columns to return. Passing null will
return all columns which is inefficient.
This value may be null . |||
selection String : A filter declaring which rows to return formatted as an
SQL WHERE clause (excluding the WHERE itself). Passing null will
return all rows for the given URI.
This value may be null . |||
selectionArgs String : You may include ?s in selection which will be
replaced by the values from selectionArgs in the order that they
appear in the selection. The values will be bound as Strings.
This value may be null . |||
sortOrder String : How to order the rows formatted as an SQL ORDER BY
clause (excluding the ORDER BY itself). Passing null will use the
default sort order which may be unordered.
This value may be null . |||",Cursor A Cursor object which is positioned before the first entry. May return null if the underlying content provider returns null or if it crashes. |||,1,This class provides applications access to the content model.,"Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.app.TaskStackBuilder: TaskStackBuilder addNextIntentWithParentStack(Intent)>,"Add a new Intent with the resolved chain of parents for the target activity to
 the task stack. This is equivalent to calling addParentStack with the resolved ComponentName of nextIntent (if it can be resolved) followed by addNextIntent with nextIntent.","nextIntent Intent : Intent for the topmost Activity in the synthesized task stack.
Its chain of parents as specified in the manifest will be added. |||",TaskStackBuilder This TaskStackBuilder for method chaining. |||,16,"Utility class for constructing synthetic back stacks for cross-task navigation
 on Android 3.0 and newer.

  In API level 11 (Android 3.0/Honeycomb) the recommended conventions for
 app navigation using the back key changed. The back key's behavior is local
 to the current task and does not capture navigation across different tasks.
 Navigating across tasks and easily reaching the previous task is accomplished
 through the ""recents"" UI accessible through the software-provided Recents key
 on the navigation or system bar. On devices with the older hardware button configuration
 the recents UI can be accessed with a long press on the Home key. When crossing from one task stack to another post-Android 3.0
 the application should synthesize a back stack/history for the new task so that
 the user may navigate out of the new task and back to the Launcher by repeated
 presses of the back key. Back key presses should not navigate across task stacks. TaskStackBuilder provides a way to obey the correct conventions
 around cross-task navigation.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
"<android.bluetooth.BluetoothAdapter: BluetoothServerSocket listenUsingRfcommWithServiceRecord(String,UUID)>","Create a listening secure RFCOMM Bluetooth socket with Service Record. A remote device connecting to this socket will be authenticated and
 communication on this socket will be encrypted. Use BluetoothServerSocket#accept to retrieve incoming
 connections from a listening BluetoothServerSocket . The system will assign an unused RFCOMM channel to listen on. The system will also register a Service Discovery
 Protocol (SDP) record with the local SDP server containing the specified
 UUID service name and auto-assigned channel. Remote Bluetooth devices
 can use the same UUID to query our SDP server and discover which channel
 to connect to. This SDP record will be removed when this socket is
 closed or if this application closes unexpectedly. Use BluetoothDevice#createRfcommSocketToServiceRecord to
 connect to this socket from another device using the same UUID . Requires Manifest.permission.BLUETOOTH","name String : service name for SDP record |||
uuid UUID : uuid for SDP record |||",BluetoothServerSocket a listening RFCOMM BluetoothServerSocket |||,5,"Represents the local device Bluetooth adapter. The  BluetoothAdapter 
 lets you perform fundamental Bluetooth tasks such as initiate
 device discovery query a list of bonded (paired) devices
 instantiate a  BluetoothDevice  using a known MAC address and create
 a  BluetoothServerSocket  to listen for connection requests from other
 devices and start a scan for Bluetooth LE devices.

  To get a  BluetoothAdapter  representing the local Bluetooth
 adapter call the  BluetoothManager#getAdapter  function on  BluetoothManager .
 On JELLY_BEAN_MR1 and below you will need to use the static  getDefaultAdapter() 
 method instead.
  
 Fundamentally this is your starting point for all
 Bluetooth actions. Once you have the local adapter you can get a set of
  BluetoothDevice  objects representing all paired devices with
  getBondedDevices() ; start device discovery with
  startDiscovery() ; or create a  BluetoothServerSocket  to
 listen for incoming RFComm connection requests with  listenUsingRfcommWithServiceRecord(java.lang.String java.util.UUID) ; listen for incoming L2CAP Connection-oriented
 Channels (CoC) connection requests with  listenUsingL2capChannel() ; or start a scan for
 Bluetooth LE devices with  startLeScan(android.bluetooth.BluetoothAdapter.LeScanCallback) .
  This class is thread safe. Note: 
 Most methods require the  Manifest.permission.BLUETOOTH 
 permission and some also require the
  Manifest.permission.BLUETOOTH_ADMIN  permission.","Provides classes that manage Bluetooth functionality such as scanning for
 devices connecting with devices and managing data transfer between devices.
 The Bluetooth API supports both ""Classic Bluetooth"" and Bluetooth Low Energy. For more information about Classic Bluetooth see the
  Bluetooth  guide.
 For more information about Bluetooth Low Energy see the
  
 Bluetooth Low Energy  (BLE) guide. The Bluetooth APIs let applications: Scan for other Bluetooth devices (including BLE devices). Query the local Bluetooth adapter for paired Bluetooth devices. Establish RFCOMM channels/sockets. Connect to specified sockets on other devices. Transfer data to and from other devices. Communicate with BLE devices such as proximity sensors heart rate
     monitors fitness devices and so on. Act as a GATT client or a GATT server (BLE). 
 To perform Bluetooth communication using these APIs an application must
 declare the  BLUETOOTH  permission. Some
 additional functionality such as requesting device discovery
 also requires the  BLUETOOTH_ADMIN 
 permission.
  Note: 
 Not all Android-powered devices provide Bluetooth functionality.",,,,,,,
<android.widget.AdapterViewAnimator: void showPrevious()>,Manually shows the previous child.,,void,11,"An AdapterView is a view whose children are determined by an  Adapter .

  
 See  ListView   GridView   Spinner  and
       Gallery  for commonly used subclasses of AdapterView.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
"<android.view.textservice.SpellCheckerSession: void getSentenceSuggestions(TextInfo,int)>",Get suggestions from the specified sentences,"textInfos TextInfo : an array of text metadata for a spell checker |||
suggestionsLimit int : the maximum number of suggestions that will be returned |||",void,16,"The SpellCheckerSession interface provides the per client functionality of SpellCheckerService.


  Applications In most cases applications that are using the standard
  TextView  or its subclasses will have little they need
 to do to work well with spell checker services.  The main things you need to
 be aware of are:  Properly set the  R.attr.inputType  in your editable
 text views so that the spell checker will have enough context to help the
 user in editing text in them.
  For the rare people amongst us writing client applications that use the spell checker service
 directly you will need to use  getSuggestions(android.view.textservice.TextInfo int)  or
  getSuggestions(android.view.textservice.TextInfo[] int boolean)  for obtaining results from the spell checker
 service by yourself. Security There are a lot of security issues associated with spell checkers
 since they could monitor all the text being sent to them
 through for instance  TextView .
 The Android spell checker framework also allows
 arbitrary third party spell checkers so care must be taken to restrict their
 selection and interactions. Here are some key points about the security architecture behind the
 spell checker framework: Only the system is allowed to directly access a spell checker framework's
  SpellCheckerService  interface via the
  Manifest.permission.BIND_TEXT_SERVICE  permission.  This is
 enforced in the system by not binding to a spell checker service that does
 not require this permission.

  The user must explicitly enable a new spell checker in settings before
 they can be enabled to confirm with the system that they know about it
 and want to make it available for use.",,,,,,,,
"<android.text.Selection: void setSelection(Spannable,int,int)>","Set the selection anchor to start and the selection edge
 to stop .","text Spannable |||
start int |||
stop int |||",void,1,"Utility class for manipulating cursors and selections in CharSequences.
 A cursor is a selection where the start and end are at the same offset.","Provides classes used to render or track text and text spans on the screen. You can use these classes to design your own widgets that manage text
 to handle arbitrary text spans for changes or to handle drawing yourself
 for an existing widget. The Span… interfaces and classes are used to create or manage spans of
 text in a View item. You can use these to style the text or background or to
 listen for changes. If creating your own widget extend DynamicLayout to manages
 the actual wrapping and drawing of your text.",,,,,,,
<android.inputmethodservice.InputMethodService: void switchInputMethod(String)>,"Force switch to a new input method as identified by id .  This
 input method will be destroyed and the requested one started on the
 current input field.",id String : Unique identifier of the new input method to start. |||,void,3,"InputMethodService provides a standard implementation of an InputMethod
 which final implementations can derive from and customize.  See the
 base class  AbstractInputMethodService  and the  InputMethod 
 interface for more information on the basics of writing input methods.

  In addition to the normal Service lifecycle methods this class
 introduces some new specific callbacks that most subclasses will want
 to make use of: onInitializeInterface()  for user-interface initialization
 in particular to deal with configuration changes while the service is
 running.
  onBindInput()  to find out about switching to a new client.
  onStartInput(EditorInfo boolean)  to deal with an input session starting with
 the client.
  onCreateInputView()   onCreateCandidatesView() 
 and  onCreateExtractTextView()  for non-demand generation of the UI.
  onStartInputView(android.view.inputmethod.EditorInfo boolean)  to deal with input
 starting within the input area of the IME.
  An input method has significant discretion in how it goes about its
 work: the  InputMethodService  provides
 a basic framework for standard UI elements (input view candidates view
 and running in fullscreen mode) but it is up to a particular implementor
 to decide how to use them.  For example one input method could implement
 an input area with a keyboard another could allow the user to draw text
 while a third could have no input area (and thus not be visible to the
 user) but instead listen to audio and perform text to speech conversion. In the implementation provided here all of these elements are placed
 together in a single window managed by the InputMethodService.  It will
 execute callbacks as it needs information about them and provides APIs for
 programmatic control over them.  They layout of these elements is explicitly
 defined: The soft input view if available is placed at the bottom of the
 screen.
  The candidates view if currently shown is placed above the soft
 input view.
  If not running fullscreen the application is moved or resized to be
 above these views; if running fullscreen the window will completely cover
 the application and its top part will contain the extract text of what is
 currently being edited by the application.
  Soft Input View Central to most input methods is the soft input view.  This is where most
 user interaction occurs: pressing on soft keys drawing characters or
 however else your input method wants to generate text.  Most implementations
 will simply have their own view doing all of this work and return a new
 instance of it when  onCreateInputView()  is called.  At that point
 as long as the input view is visible you will see user interaction in
 that view and can call back on the InputMethodService to interact with the
 application as appropriate. There are some situations where you want to decide whether or not your
 soft input view should be shown to the user.  This is done by implementing
 the  onEvaluateInputViewShown()  to return true or false based on
 whether it should be shown in the current environment.  If any of your
 state has changed that may impact this call
  updateInputViewShown()  to have it re-evaluated.  The default
 implementation always shows the input view unless there is a hard
 keyboard available which is the appropriate behavior for most input
 methods. Candidates View Often while the user is generating raw text an input method wants to
 provide them with a list of possible interpretations of that text that can
 be selected for use.  This is accomplished with the candidates view and
 like the soft input view you implement  onCreateCandidatesView() 
 to instantiate your own view implementing your candidates UI. Management of the candidates view is a little different than the input
 view because the candidates view tends to be more transient being shown
 only when there are possible candidates for the current text being entered
 by the user.  To control whether the candidates view is shown you use
  setCandidatesViewShown(boolean) .  Note that because the candidate
 view tends to be shown and hidden a lot it does not impact the application
 UI in the same way as the soft input view: it will never cause application
 windows to resize only cause them to be panned if needed for the user to
 see the current focus. Fullscreen Mode Sometimes your input method UI is too large to integrate with the
 application UI so you just want to take over the screen.  This is
 accomplished by switching to full-screen mode causing the input method
 window to fill the entire screen and add its own ""extracted text"" editor
 showing the user the text that is being typed.  Unlike the other UI elements
 there is a standard implementation for the extract editor that you should
 not need to change.  The editor is placed at the top of the IME above the
 input and candidates views. Similar to the input view you control whether the IME is running in
 fullscreen mode by implementing  onEvaluateFullscreenMode() 
 to return true or false based on
 whether it should be fullscreen in the current environment.  If any of your
 state has changed that may impact this call
  updateFullscreenMode()  to have it re-evaluated.  The default
 implementation selects fullscreen mode when the screen is in a landscape
 orientation which is appropriate behavior for most input methods that have
 a significant input area. When in fullscreen mode you have some special requirements because the
 user can not see the application UI.  In particular you should implement
  onDisplayCompletions(android.view.inputmethod.CompletionInfo[])  to show completions
 generated by your application typically in your candidates view like you
 would normally show candidates.


  Generating Text The key part of an IME is of course generating text for the application.
 This is done through calls to the
  InputConnection  interface to the
 application which can be retrieved from  getCurrentInputConnection() .
 This interface allows you to generate raw key events or if the target
 supports it directly edit in strings of candidates and committed text. Information about what the target is expected and supports can be found
 through the  EditorInfo  class which is
 retrieved with  getCurrentInputEditorInfo()  method.  The most
 important part of this is  EditorInfo.inputType ; in particular if this is
  EditorInfo.TYPE_NULL 
 then the target does not support complex edits and you need to only deliver
 raw key events to it.  An input method will also want to look at other
 values here to for example detect password mode auto complete text views
 phone number entry etc. When the user switches between input targets you will receive calls to
  onFinishInput()  and  onStartInput(android.view.inputmethod.EditorInfo boolean) .
 You can use these to reset and initialize your input state for the current
 target.  For example you will often want to clear any input state and
 update a soft keyboard to be appropriate for the new inputType.",,,,,,,,
<android.app.Dialog: void show()>,"Start the dialog and display it on screen.  The window is placed in the
 application layer and opaque.  Note that you should not override this
 method to do initialization when the dialog is shown instead implement
 that in onStart() .",,void,1,"Base class for Dialogs.

  Note: Activities provide a facility to manage the creation saving and
 restoring of dialogs. See  Activity#onCreateDialog(int) 
  Activity#onPrepareDialog(int Dialog) 
  Activity#showDialog(int)  and  Activity#dismissDialog(int) . If
 these methods are used  getOwnerActivity()  will return the Activity
 that managed this dialog.

  Often you will want to have a Dialog display on top of the current
 input method because there is no reason for it to accept text.  You can
 do this by setting the  WindowManager.LayoutParams#FLAG_ALT_FOCUSABLE_IM  window flag (assuming
 your Dialog takes input focus as it the default) with the following code:

  
 getWindow().setFlags(WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM
         WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
"<android.view.AbsSavedState: void writeToParcel(Parcel,int)>",Flatten this object in to a Parcel.,"dest Parcel : The Parcel in which the object should be written. |||
flags int : Additional flags about how the object should be written.
May be 0 or Parcelable.PARCELABLE_WRITE_RETURN_VALUE .
Value is either 0 or a combination of Parcelable.PARCELABLE_WRITE_RETURN_VALUE and android.os.Parcelable.PARCELABLE_ELIDE_DUPLICATES |||",void,1,"A  Parcelable  implementation that should be used by inheritance
 hierarchies to ensure the state of all classes along the chain is saved.",,,,,,,,
<android.text.TextUtils: CharSequence stringOrSpannedString(CharSequence)>,,source CharSequence |||,CharSequence |||,1,,"Provides classes used to render or track text and text spans on the screen. You can use these classes to design your own widgets that manage text
 to handle arbitrary text spans for changes or to handle drawing yourself
 for an existing widget. The Span… interfaces and classes are used to create or manage spans of
 text in a View item. You can use these to style the text or background or to
 listen for changes. If creating your own widget extend DynamicLayout to manages
 the actual wrapping and drawing of your text.",,,,,,,
<android.content.res.TypedArray: String getNonResourceString(int)>,"Retrieves the string value for the attribute at index but
 only if that string comes from an immediate value in an XML file.  That
 is this does not allow references to string resources string
 attributes or conversions from other types.  As such this method
 will only return strings for TypedArray objects that come from
 attributes in an XML file.",index int : Index of attribute to retrieve. |||,"String String holding string data. Any styling information is removed.
         Returns null if the attribute is not defined or is not
         an immediate string value. |||",1,"Container for an array of values that were retrieved with
  Resources.Theme#obtainStyledAttributes(AttributeSet int[] int int) 
 or  Resources#obtainAttributes .  Be
 sure to call  recycle()  when done with them.

 The indices used to retrieve values from this structure correspond to
 the positions of the attributes given to obtainStyledAttributes.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.widget.ListView: void addHeaderView(View)>,"Add a fixed view to appear at the top of the list. If addHeaderView is
 called more than once the views will appear in the order they were
 added. Views added using this call can take focus if they want. Note: When first introduced this method could only be called before
 setting the adapter with setAdapter(android.widget.ListAdapter) . Starting with Build.VERSION_CODES.KITKAT this method may be
 called at any time. If the ListView's adapter does not extend HeaderViewListAdapter it will be wrapped with a supporting
 instance of WrapperListAdapter .",v View : The view to add. |||,void,1,"Displays a vertically-scrollable collection of views where each view is positioned
 immediatelybelow the previous view in the list.  For a more modern flexible and performant
 approach to displaying lists use  RecyclerView . To display a list you can include a list view in your layout XML file: <ListView
      android:id=""@+id/list_view""
      android:layout_width=""match_parent""
      android:layout_height=""match_parent"" /> A list view is an  
 adapter view  that does not know the details such as type and contents of the views it
 contains. Instead list view requests views on demand from a  ListAdapter  as needed
 such as to display new views as the user scrolls up or down. In order to display items in the list call  setAdapter(android.widget.ListAdapter) 
 to associate an adapter with the list.  For a simple example see the discussion of filling an
 adapter view with text in the
  
 Layouts  guide. To display a more custom view for each item in your dataset implement a ListAdapter.
 For example extend  BaseAdapter  and create and configure the view for each data item in
  getView(...) : private class MyAdapter extends BaseAdapter {

      // override other abstract methods here

      @Override
      public View getView(int position View convertView ViewGroup container) {
          if (convertView == null) {
              convertView = getLayoutInflater().inflate(R.layout.list_item container false);
          }

          ((TextView) convertView.findViewById(android.R.id.text1))
                  .setText(getItem(position));
          return convertView;
      }
  } ListView attempts to reuse view objects in order to improve performance and
 avoid a lag in response to user scrolls.  To take advantage of this feature check if the
  convertView  provided to  getView(...)  is null before creating or inflating a new
 view object.  See
  
 Making ListView Scrolling Smooth  for more ways to ensure a smooth user experience. To specify an action when a user clicks or taps on a single list item see
  
     Handling click events . To learn how to populate a list view with a CursorAdapter see the discussion of filling an
 adapter view with text in the
  
 Layouts  guide.
 See  
     Using a Loader 
 to learn how to avoid blocking the main thread when using a cursor. Note many examples use  ListActivity 
 or  ListFragment 
 to display a list view. Instead favor the more flexible approach when writing your own app:
 use a more generic Activity subclass or Fragment subclass and add a list view to the layout
 or view hierarchy directly.  This approach gives you more direct control of the
 list view and adapter.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
"<android.content.ContentResolver: int bulkInsert(Uri,ContentValues)>","Inserts multiple rows into a table at the given URL.

 This function make no guarantees about the atomicity of the insertions.","url Uri : The URL of the table to insert into.
This value cannot be null . |||
values ContentValues : The initial values for the newly inserted rows. The key is the column name for
the field. Passing null will create an empty row.
This value cannot be null . |||",int the number of newly created rows. |||,1,This class provides applications access to the content model.,"Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.app.Instrumentation: void callActivityOnResume(Activity)>,"Perform calling of an activity's Activity#onResume method.  The
 default implementation simply calls through to that method.",activity Activity : The activity being resumed. |||,void,1,"Base class for implementing application instrumentation code.  When running
 with instrumentation turned on this class will be instantiated for you
 before any of the application code allowing you to monitor all of the
 interaction the system has with the application.  An Instrumentation
 implementation is described to the system through an AndroidManifest.xml's
 <instrumentation> tag.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.accounts.AccountManager: Account getAccountsByType(String)>,"Lists all accounts of particular type visible to the caller. These accounts may be visible
 because the user granted access to the account or the AbstractAcccountAuthenticator managing
 the account did so or because the client shares a signature with the managing
 AbstractAccountAuthenticator. The account type is a string token corresponding to the authenticator and useful domain of
 the account. For example there are types corresponding to Google and Facebook. The exact
 string token to use will be published somewhere associated with the authenticator in
 question. It is safe to call this method from the main thread. Caller targeting API level Build.VERSION_CODES.O and above will get list
 of accounts made visible to it by user
 (see newChooseAccountIntent(android.accounts.Account java.util.List java.lang.String[] java.lang.String java.lang.String java.lang.String[] android.os.Bundle) ) or AbstractAcccountAuthenticator
 using setAccountVisibility(Account String int) . Manifest.permission.GET_ACCOUNTS permission is not used. Caller targeting API level below Build.VERSION_CODES.O that have not been
 granted the Manifest.permission.GET_ACCOUNTS permission will only see those
 accounts managed by AbstractAccountAuthenticators whose signature matches the client. NOTE: If targeting your app to work on API level Build.VERSION_CODES.LOLLIPOP_MR1 and before Manifest.permission.GET_ACCOUNTS permission is
 needed for those platforms irrespective of uid or signature match. See docs for this
 function in API level Build.VERSION_CODES.LOLLIPOP_MR1 . Requires Manifest.permission.GET_ACCOUNTS",type String : The type of accounts to return null to retrieve all accounts |||,"Account[] An array of Account one per matching account. Empty (never null) if no
         accounts of the specified type have been added. |||",5,"This class provides access to a centralized registry of the user's
 online accounts.  The user enters credentials (username and password) once
 per account granting applications access to online resources with
 ""one-click"" approval.

  Different online services have different ways of handling accounts and
 authentication so the account manager uses pluggable  authenticator 
 modules for different  account types .  Authenticators (which may be
 written by third parties) handle the actual details of validating account
 credentials and storing account information.  For example Google Facebook
 and Microsoft Exchange each have their own authenticator.

  Many servers support some notion of an  authentication token 
 which can be used to authenticate a request to the server without sending
 the user's actual password.  (Auth tokens are normally created with a
 separate request which does include the user's credentials.)  AccountManager
 can generate auth tokens for applications so the application doesn't need to
 handle passwords directly.  Auth tokens are normally reusable and cached by
 AccountManager but must be refreshed periodically.  It's the responsibility
 of applications to  invalidate  auth tokens when they stop working so
 the AccountManager knows it needs to regenerate them.

  Applications accessing a server normally go through these steps:

  Get an instance of AccountManager using  get(android.content.Context) .

  List the available accounts using  getAccountsByType(String)  or
  getAccountsByTypeAndFeatures(String String[] AccountManagerCallback  Handler) .  Normally applications will only
 be interested in accounts with one particular  type  which
 identifies the authenticator.  Account  features  are used to
 identify particular account subtypes and capabilities.  Both the account
 type and features are authenticator-specific strings and must be known by
 the application in coordination with its preferred authenticators.

  Select one or more of the available accounts possibly by asking the
 user for their preference.  If no suitable accounts are available
  addAccount(String String String[] Bundle Activity AccountManagerCallback  Handler)  may be called to prompt the user to create an
 account of the appropriate type.

  Important:  If the application is using a previously remembered
 account selection it must make sure the account is still in the list
 of accounts returned by  getAccountsByType(String) .  Requesting an auth token
 for an account no longer on the device results in an undefined failure.

  Request an auth token for the selected account(s) using one of the
  getAuthToken(Account String Bundle Activity AccountManagerCallback  Handler)  methods or related helpers.  Refer to the description
 of each method for exact usage and error handling details.

  Make the request using the auth token.  The form of the auth token
 the format of the request and the protocol used are all specific to the
 service you are accessing.  The application may use whatever network and
 protocol libraries are useful.

  Important:  If the request fails with an authentication error
 it could be that a cached auth token is stale and no longer honored by
 the server.  The application must call  invalidateAuthToken(String String)  to remove
 the token from the cache otherwise requests will continue failing!  After
 invalidating the auth token immediately go back to the ""Request an auth
 token"" step above.  If the process fails the second time then it can be
 treated as a ""genuine"" authentication failure and the user notified or other
 appropriate actions taken.
  Some AccountManager methods may need to interact with the user to
 prompt for credentials present options or ask the user to add an account.
 The caller may choose whether to allow AccountManager to directly launch the
 necessary user interface and wait for the user or to return an Intent which
 the caller may use to launch the interface or (in some cases) to install a
 notification which the user can select at any time to launch the interface.
 To have AccountManager launch the interface directly the caller must supply
 the current foreground  Activity  context.

  Many AccountManager methods take  AccountManagerCallback  and
  Handler  as parameters.  These methods return immediately and
 run asynchronously. If a callback is provided then
  AccountManagerCallback#run  will be invoked on the Handler's
 thread when the request completes successfully or not.
 The result is retrieved by calling  AccountManagerFuture#getResult() 
 on the  AccountManagerFuture  returned by the method (and also passed
 to the callback).  This method waits for the operation to complete (if
 necessary) and either returns the result or throws an exception if an error
 occurred during the operation.  To make the request synchronously call
  AccountManagerFuture#getResult()  immediately on receiving the
 future from the method; no callback need be supplied.

  Requests which may block including
  AccountManagerFuture#getResult()  must never be called on
 the application's main event thread.  These operations throw
  IllegalStateException  if they are used on the main thread.",,,,,,,,
<android.webkit.WebView: WebBackForwardList saveState(Bundle)>,"Saves the state of this WebView used in Activity.onSaveInstanceState(Bundle) . Please note that this
 method no longer stores the display data for this WebView. The previous
 behavior could potentially leak files if restoreState(Bundle) was never
 called.","outState Bundle : the Bundle to store this WebView's state
This value cannot be null . |||","WebBackForwardList the same copy of the back/forward list used to save the state null if the
         method fails. |||",1,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",,,,,,,
<android.app.ProgressDialog: void setProgress(int)>,Sets the current progress.,value int : the current progress a value between 0 and getMax() |||,void,1,"A dialog showing a progress indicator and an optional text message or view.
 Only a text message or a view can be used at the same time.

  The dialog can be made cancelable on back key press. The progress range is 0 to  max .","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
"<android.test.TouchUtils: void dragQuarterScreenUp(InstrumentationTestCase,Activity)>",Simulate touching in the center of the screen and dragging one quarter of the way up,"test InstrumentationTestCase : The test case that is being run |||
activity Activity : The activity that is in the foreground of the test case |||",void,3,"Reusable methods for generating touch events. These methods can be used with
 InstrumentationTestCase or ActivityInstrumentationTestCase2 to simulate user interaction with
 the application through a touch screen.",,,,,,,,
"<android.text.Layout: int getOffsetForHorizontal(int,float)>","Get the character offset on the specified line whose position is
 closest to the specified horizontal position.","line int |||
horiz float |||",int |||,1,"A base class that manages text layout in visual elements on
 the screen.
  For text that will be edited use a  DynamicLayout 
 which will be updated as the text changes.
 For text that will not change use a  StaticLayout .","Provides classes used to render or track text and text spans on the screen. You can use these classes to design your own widgets that manage text
 to handle arbitrary text spans for changes or to handle drawing yourself
 for an existing widget. The Span… interfaces and classes are used to create or manage spans of
 text in a View item. You can use these to style the text or background or to
 listen for changes. If creating your own widget extend DynamicLayout to manages
 the actual wrapping and drawing of your text.",,,,,,,
"<android.app.Activity: void finishActivityFromChild(Activity,int)>","This method was deprecated
      in API level 30. Use finishActivity(int) instead. This is called when a child activity of this one calls its
 finishActivity().","child Activity : The activity making the call.
This value cannot be null . |||
requestCode int : Request code that had been used to start the
activity. |||",void,1,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
"<android.widget.VideoView: void setVideoURI(Uri,Map)>",Sets video URI using specific headers.,"uri Uri : the URI of the video. |||
headers Map : the headers for the URI request.
Note that the cross domain redirection is allowed by default but that can be
changed with key/value pairs through the headers parameter with
""android-allow-cross-domain-redirect"" as the key and ""0"" or ""1"" as the value
to disallow or allow cross domain redirection. |||",void,21,"Displays a video file.  The VideoView class
 can load images from various sources (such as resources or content
 providers) takes care of computing its measurement from the video so that
 it can be used in any layout manager and provides various display options
 such as scaling and tinting. Note: VideoView does not retain its full state when going into the
 background.   In particular it does not restore the current play state
 play position selected tracks or any subtitle tracks added via
  addSubtitleSource() .  Applications should
 save and restore these on their own in
  Activity.onSaveInstanceState(Bundle)  and
  Activity.onRestoreInstanceState(Bundle) . 
 Also note that the audio session id (from  getAudioSessionId() ) may
 change from its previously returned value when the VideoView is restored.
  
 By default VideoView requests audio focus with  AudioManager#AUDIOFOCUS_GAIN . Use
  setAudioFocusRequest(int)  to change this behavior.
  
 The default  AudioAttributes  used during playback have a usage of
  AudioAttributes#USAGE_MEDIA  and a content type of
  AudioAttributes#CONTENT_TYPE_MOVIE  use  setAudioAttributes(android.media.AudioAttributes)  to
 modify them.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.view.inputmethod.InputConnectionWrapper: CharSequence getSelectedText(int)>,"Gets the selected text if any. This method may fail if either the input connection has
 become invalid (such as its process crashing) or the client is
 taking too long to respond with the text (it is given a couple
 of seconds to return). In either case null is returned. This method must not cause any changes in the editor's
 state. If GET_TEXT_WITH_STYLES is supplied as flags the
 editor should return a SpannableString with all the spans set on the text. IME authors: please consider this will
 trigger an IPC round-trip that will take some time. Assume this
 method consumes a lot of time. If you are using this to get the
 initial text around the cursor you may consider using EditorInfo#getInitialTextBeforeCursor(int int)  EditorInfo#getInitialSelectedText(int) and EditorInfo#getInitialTextAfterCursor(int int) to prevent IPC costs. Editor authors: please be careful of race
 conditions in implementing this call. An IME can make a change
 to the text or change the selection position and use this
 method right away; you need to make sure the returned value is
 consistent with the results of the latest edits.","flags int : Supplies additional options controlling how the text is
returned. May be either 0 or InputConnection.GET_TEXT_WITH_STYLES . |||","CharSequence the text that is currently selected if any or null if
 no text is selected. In Build.VERSION_CODES.N and
 later returns false when the target application does not implement
 this method. |||",9,Wrapper class for proxying calls to another InputConnection.  Subclass and have fun!,,,,,,,,
"<android.view.inputmethod.InputMethodManager: void updateCursor(View,int,int,int,int)>","This method was deprecated
      in API level 21. Use updateCursorAnchorInfo(android.view.View android.view.inputmethod.CursorAnchorInfo) instead. Report the current cursor location in its window.","view View |||
left int |||
top int |||
right int |||
bottom int |||",void,3,"Central system API to the overall input method framework (IMF) architecture
 which arbitrates interaction between applications and the current input method.

  Topics covered here:
  Architecture Overview Applications Input Methods Security Architecture Overview There are three primary parties involved in the input method
 framework (IMF) architecture:  The  input method manager  as expressed by this class
 is the central point of the system that manages interaction between all
 other parts.  It is expressed as the client-side API here which exists
 in each application context and communicates with a global system service
 that manages the interaction across all processes.
   An  input method (IME)  implements a particular
 interaction model allowing the user to generate text.  The system binds
 to the current input method that is in use causing it to be created and run
 and tells it when to hide and show its UI.  Only one IME is running at a time.
   Multiple  client applications  arbitrate with the input
 method manager for input focus and control over the state of the IME.  Only
 one such client is ever active (working with the IME) at a time.
  Applications In most cases applications that are using the standard
  TextView  or its subclasses will have little they need
 to do to work well with soft input methods.  The main things you need to
 be aware of are:  Properly set the  R.attr.inputType  in your editable
 text views so that the input method will have enough context to help the
 user in entering text into them.
   Deal well with losing screen space when the input method is
 displayed.  Ideally an application should handle its window being resized
 smaller but it can rely on the system performing panning of the window
 if needed.  You should set the  R.attr.windowSoftInputMode 
 attribute on your activity or the corresponding values on windows you
 create to help the system determine whether to pan or resize (it will
 try to determine this automatically but may get it wrong).
   You can also control the preferred soft input state (open closed etc)
 for your window using the same  R.attr.windowSoftInputMode 
 attribute.
  More finer-grained control is available through the APIs here to directly
 interact with the IMF and its IME -- either showing or hiding the input
 area letting the user pick an input method etc. For the rare people amongst us writing their own text editors you
 will need to implement  View.onCreateInputConnection(EditorInfo) 
 to return a new instance of your own  InputConnection  interface
 allowing the IME to interact with your editor. Input Methods An input method (IME) is implemented
 as a  Service  typically deriving from
  InputMethodService .  It must provide
 the core  InputMethod  interface though this is normally handled by
  InputMethodService  and implementors will
 only need to deal with the higher-level API there. InputMethodService Security There are a lot of security issues associated with input methods
 since they essentially have freedom to completely drive the UI and monitor
 everything the user enters.  The Android input method framework also allows
 arbitrary third party IMEs so care must be taken to restrict their
 selection and interactions. Here are some key points about the security architecture behind the
 IMF: Only the system is allowed to directly access an IME's
  InputMethod  interface via the
  Manifest.permission.BIND_INPUT_METHOD  permission.  This is
 enforced in the system by not binding to an input method service that does
 not require this permission so the system can guarantee no other untrusted
 clients are accessing the current input method outside of its control. There may be many client processes of the IMF but only one may
 be active at a time.  The inactive clients can not interact with key
 parts of the IMF through the mechanisms described below. Clients of an input method are only given access to its
  InputMethodSession  interface.  One instance of this interface is
 created for each client and only calls from the session associated with
 the active client will be processed by the current IME.  This is enforced
 by  AbstractInputMethodService  for normal
 IMEs but must be explicitly handled by an IME that is customizing the
 raw  InputMethodSession  implementation. Only the active client's  InputConnection  will accept
 operations.  The IMF tells each client process whether it is active and
 the framework enforces that in inactive processes calls on to the current
 InputConnection will be ignored.  This ensures that the current IME can
 only deliver events and text edits to the UI that the user sees as
 being in focus. An IME can never interact with an  InputConnection  while
 the screen is off.  This is enforced by making all clients inactive while
 the screen is off and prevents bad IMEs from driving the UI when the user
 can not be aware of its behavior. A client application can ask that the system let the user pick a
 new IME but can not programmatically switch to one itself.  This avoids
 malicious applications from switching the user to their own IME which
 remains running when the user navigates away to another application.  An
 IME on the other hand  is  allowed to programmatically switch
 the system to another IME since it already has full control of user
 input. The user must explicitly enable a new IME in settings before
 they can switch to it to confirm with the system that they know about it
 and want to make it available for use. PackageManager#FEATURE_INPUT_METHODS PackageManager.hasSystemFeature(String)",,,,,,,,
"<android.content.ContentResolver: AssetFileDescriptor openTypedAssetFileDescriptor(Uri,String,Bundle)>","Open a raw file descriptor to access (potentially type transformed)
 data from a ""content:"" URI.  This interacts with the underlying ContentProvider#openTypedAssetFile method of the provider
 associated with the given URI to retrieve retrieve any appropriate
 data stream for the data stored there. Unlike openAssetFileDescriptor(Uri String) this function only works
 with ""content:"" URIs because content providers are the only facility
 with an associated MIME type to ensure that the returned data stream
 is of the desired type. All text/* streams are encoded in UTF-8.","uri Uri : The desired URI to open.
This value cannot be null . |||
mimeType String : The desired MIME type of the returned data.  This can
be a pattern such as */* which will allow the content provider to
select a type though there is no way for you to determine what type
it is returning.
This value cannot be null . |||
opts Bundle : Additional provider-dependent options.
This value may be null . |||","AssetFileDescriptor Returns a new ParcelFileDescriptor from which you can read the
 data stream from the provider or null if the provider recently crashed.
 Note that this may be a pipe meaning you can't seek in it.  The only seek you
 should do is if the AssetFileDescriptor contains an offset to move to that offset before
 reading.  You own this descriptor and are responsible for closing it when done. |||",11,This class provides applications access to the content model.,"Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.view.View: void setScrollBarSize(int)>,Define the scrollbar size. Related XML Attributes: android:scrollbarSize,scrollBarSize int : - the scrollbar size |||,void,16,"This class represents the basic building block for user interface components. A View
 occupies a rectangular area on the screen and is responsible for drawing and
 event handling. View is the base class for  widgets  which are
 used to create interactive UI components (buttons text fields etc.). The
  ViewGroup  subclass is the base class for  layouts  which
 are invisible containers that hold other Views (or other ViewGroups) and define
 their layout properties.",,,,,,,,
<android.telephony.TelephonyManager: String getSubscriberId()>,"Returns the unique subscriber ID for example the IMSI for a GSM phone.
 Return null if it is unavailable. Starting with API level 29 persistent device identifiers are guarded behind additional
 restrictions and apps are recommended to use resettable identifiers (see Best practices for unique identifiers ). This method can be invoked if one of
 the following requirements is met: If the calling app has been granted the READ_PRIVILEGED_PHONE_STATE permission; this
     is a privileged permission that can only be granted to apps preloaded on the device. 
If the calling app is the device or profile owner and has been granted the Manifest.permission#READ_PHONE_STATE permission. The profile owner is an app that
     owns a managed profile on the device; for more details see Work profiles .
     Profile owner access is deprecated and will be removed in a future release. 
If the calling app has carrier privileges (see hasCarrierPrivileges() ). 
If the calling app is the default SMS role holder (see RoleManager#isRoleHeld(String) ). 
If the calling app does not meet one of these requirements then this method will behave
 as follows: If the calling app's target SDK is API level 28 or lower and the app has the
     READ_PHONE_STATE permission then null is returned. 
If the calling app's target SDK is API level 28 or lower and the app does not have
     the READ_PHONE_STATE permission or if the calling app is targeting API level 29 or
     higher then a SecurityException is thrown.",,String |||,1,"Provides access to information about the telephony services on
 the device. Applications can use the methods in this class to
 determine telephony services and states as well as to access some
 types of subscriber information. Applications can also register
 a listener to receive notification of telephony state changes.
  
 The returned TelephonyManager will use the default subscription for all calls.
 To call an API for a specific subscription use  createForSubscriptionId(int) . e.g.
  
   telephonyManager = defaultSubTelephonyManager.createForSubscriptionId(subId);
  
 Note that access to some telephony information is
 permission-protected. Your application cannot access the protected
 information unless it has the appropriate permissions declared in
 its manifest file. Where permissions apply they are noted in the
 the methods through which you access the protected information.",,,,,,,,
<android.widget.ViewAnimator: void removeView(View)>,Note: do not invoke this method from View.draw(android.graphics.Canvas)  View.onDraw(android.graphics.Canvas)  dispatchDraw(android.graphics.Canvas) or any related method.,view View |||,void,1,"Base class for a  FrameLayout  container that will perform animations
 when switching between its views.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.view.ViewPropertyAnimator: ViewPropertyAnimator translationYBy(float)>,"This method will cause the View's translationY property to be animated by the
 specified value. Animations already running on the property will be canceled.",value float : The amount to be animated by as an offset from the current value. |||,ViewPropertyAnimator This object allowing calls to methods in this class to be chained. |||,12,"This class enables automatic and optimized animation of select properties on View objects.
 If only one or two properties on a View object are being animated then using an
  ObjectAnimator  is fine; the property setters called by ObjectAnimator
 are well equipped to do the right thing to set the property and invalidate the view
 appropriately. But if several properties are animated simultaneously or if you just want a
 more convenient syntax to animate a specific property then ViewPropertyAnimator might be
 more well-suited to the task.

  This class may provide better performance for several simultaneous animations because
 it will optimize invalidate calls to take place only once for several properties instead of each
 animated property independently causing its own invalidation. Also the syntax of using this
 class could be easier to use because the caller need only tell the View object which
 property to animate and the value to animate either to or by and this class handles the
 details of configuring the underlying Animator class and starting it. This class is not constructed by the caller but rather by the View whose properties
 it will animate. Calls to  View.animate()  will return a reference
 to the appropriate ViewPropertyAnimator object for that View.",,,,,,,,
"<android.accounts.AccountManager: AccountManagerFuture getAuthToken(Account,String,Bundle,Activity,AccountManagerCallback,Handler)>","Gets an auth token of the specified type for a particular account
 prompting the user for credentials if necessary.  This method is
 intended for applications running in the foreground where it makes
 sense to ask the user directly for a password. If a previously generated auth token is cached for this account and
 type then it is returned.  Otherwise if a saved password is
 available it is sent to the server to generate a new auth token.
 Otherwise the user is prompted to enter a password. Some authenticators have auth token types whose value
 is authenticator-dependent.  Some services use different token types to
 access different functionality -- for example Google uses different auth
 tokens to access Gmail and Google Calendar for the same account. NOTE: If targeting your app to work on API level 22 and before
 USE_CREDENTIALS permission is needed for those platforms. See docs for
 this function in API level 22. This method may be called from any thread but the returned AccountManagerFuture must not be used on the main thread. Requires android.Manifest.permission.USE_CREDENTIALS","account Account : The account to fetch an auth token for |||
authTokenType String : The auth token type an authenticator-dependent
string token must not be null |||
options Bundle : Authenticator-specific options for the request
may be null or empty |||
activity Activity : The Activity context to use for launching a new
authenticator-defined sub-Activity to prompt the user for a password
if necessary; used only to call startActivity(); must not be null. |||
callback AccountManagerCallback : Callback to invoke when the request completes
null for no callback |||
handler Handler : Handler identifying the callback thread
null for the main thread |||","AccountManagerFuture < Bundle > An AccountManagerFuture which resolves to a Bundle with
     at least the following fields: KEY_ACCOUNT_NAME - the name of the account you supplied KEY_ACCOUNT_TYPE - the type of the account KEY_AUTHTOKEN - the auth token you wanted (Other authenticator-specific values may be returned.)  If an auth token
 could not be fetched AccountManagerFuture#getResult() throws: AuthenticatorException if the authenticator failed to respond OperationCanceledException if the operation is canceled for
      any reason incluidng the user canceling a credential request IOException if the authenticator experienced an I/O problem
      creating a new auth token usually because of network trouble If the account is no longer present on the device the return value is
 authenticator-dependent.  The caller should verify the validity of the
 account before requesting an auth token. |||",5,"This class provides access to a centralized registry of the user's
 online accounts.  The user enters credentials (username and password) once
 per account granting applications access to online resources with
 ""one-click"" approval.

  Different online services have different ways of handling accounts and
 authentication so the account manager uses pluggable  authenticator 
 modules for different  account types .  Authenticators (which may be
 written by third parties) handle the actual details of validating account
 credentials and storing account information.  For example Google Facebook
 and Microsoft Exchange each have their own authenticator.

  Many servers support some notion of an  authentication token 
 which can be used to authenticate a request to the server without sending
 the user's actual password.  (Auth tokens are normally created with a
 separate request which does include the user's credentials.)  AccountManager
 can generate auth tokens for applications so the application doesn't need to
 handle passwords directly.  Auth tokens are normally reusable and cached by
 AccountManager but must be refreshed periodically.  It's the responsibility
 of applications to  invalidate  auth tokens when they stop working so
 the AccountManager knows it needs to regenerate them.

  Applications accessing a server normally go through these steps:

  Get an instance of AccountManager using  get(android.content.Context) .

  List the available accounts using  getAccountsByType(String)  or
  getAccountsByTypeAndFeatures(String String[] AccountManagerCallback  Handler) .  Normally applications will only
 be interested in accounts with one particular  type  which
 identifies the authenticator.  Account  features  are used to
 identify particular account subtypes and capabilities.  Both the account
 type and features are authenticator-specific strings and must be known by
 the application in coordination with its preferred authenticators.

  Select one or more of the available accounts possibly by asking the
 user for their preference.  If no suitable accounts are available
  addAccount(String String String[] Bundle Activity AccountManagerCallback  Handler)  may be called to prompt the user to create an
 account of the appropriate type.

  Important:  If the application is using a previously remembered
 account selection it must make sure the account is still in the list
 of accounts returned by  getAccountsByType(String) .  Requesting an auth token
 for an account no longer on the device results in an undefined failure.

  Request an auth token for the selected account(s) using one of the
  getAuthToken(Account String Bundle Activity AccountManagerCallback  Handler)  methods or related helpers.  Refer to the description
 of each method for exact usage and error handling details.

  Make the request using the auth token.  The form of the auth token
 the format of the request and the protocol used are all specific to the
 service you are accessing.  The application may use whatever network and
 protocol libraries are useful.

  Important:  If the request fails with an authentication error
 it could be that a cached auth token is stale and no longer honored by
 the server.  The application must call  invalidateAuthToken(String String)  to remove
 the token from the cache otherwise requests will continue failing!  After
 invalidating the auth token immediately go back to the ""Request an auth
 token"" step above.  If the process fails the second time then it can be
 treated as a ""genuine"" authentication failure and the user notified or other
 appropriate actions taken.
  Some AccountManager methods may need to interact with the user to
 prompt for credentials present options or ask the user to add an account.
 The caller may choose whether to allow AccountManager to directly launch the
 necessary user interface and wait for the user or to return an Intent which
 the caller may use to launch the interface or (in some cases) to install a
 notification which the user can select at any time to launch the interface.
 To have AccountManager launch the interface directly the caller must supply
 the current foreground  Activity  context.

  Many AccountManager methods take  AccountManagerCallback  and
  Handler  as parameters.  These methods return immediately and
 run asynchronously. If a callback is provided then
  AccountManagerCallback#run  will be invoked on the Handler's
 thread when the request completes successfully or not.
 The result is retrieved by calling  AccountManagerFuture#getResult() 
 on the  AccountManagerFuture  returned by the method (and also passed
 to the callback).  This method waits for the operation to complete (if
 necessary) and either returns the result or throws an exception if an error
 occurred during the operation.  To make the request synchronously call
  AccountManagerFuture#getResult()  immediately on receiving the
 future from the method; no callback need be supplied.

  Requests which may block including
  AccountManagerFuture#getResult()  must never be called on
 the application's main event thread.  These operations throw
  IllegalStateException  if they are used on the main thread.",,,,,,,,
<android.content.res.Resources: Drawable getDrawable(int)>,"This method was deprecated
      in API level 22. Use getDrawable(int android.content.res.Resources.Theme) instead. Return a drawable object associated with a particular resource ID.
 Various types of objects will be returned depending on the underlying
 resource -- for example a solid color PNG image scalable image etc.
 The Drawable API hides these implementation details. Note: Prior to Build.VERSION_CODES.JELLY_BEAN this function
 would not correctly retrieve the final configuration density when
 the resource ID passed here is an alias to another Drawable resource.
 This means that if the density configuration of the alias resource
 is different than the actual resource the density of the returned
 Drawable would be incorrect resulting in bad scaling. To work
 around this you can instead manually resolve the aliased reference
 by using getValue(int android.util.TypedValue boolean) and passing true for resolveRefs . The resulting TypedValue#resourceId value may be passed to this method. Note: To obtain a themed drawable use Context.getDrawable(int) or getDrawable(int android.content.res.Resources.Theme) passing the desired theme.","id int : The desired resource identifier as generated by the aapt
tool. This integer encodes the package type and resource
entry. The value 0 is an invalid identifier. |||",Drawable Drawable An object that can be used to draw this resource. |||,1,"Class for accessing an application's resources.  This sits on top of the
 asset manager of the application (accessible through  getAssets() ) and
 provides a high-level API for getting typed data from the assets.

  The Android resource system keeps track of all non-code assets associated with an
 application. You can use this class to access your application's resources. You can generally
 acquire the  Resources  instance associated with your application
 with  getResources() . The Android SDK tools compile your application's resources into the application binary
 at build time.  To use a resource you must install it correctly in the source tree (inside
 your project's  res/  directory) and build your application.  As part of the build
 process the SDK tools generate symbols for each resource which you can use in your application
 code to access the resources. Using application resources makes it easy to update various characteristics of your
 application without modifying code and—by providing sets of alternative
 resources—enables you to optimize your application for a variety of device configurations
 (such as for different languages and screen sizes). This is an important aspect of developing
 Android applications that are compatible on different types of devices. For more information about using resources see the documentation about  Application Resources .","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.accessibilityservice.AccessibilityService: AccessibilityServiceInfo getServiceInfo()>,"Gets the an AccessibilityServiceInfo describing this AccessibilityService . This method is useful if one wants
 to change some of the dynamically configurable properties at
 runtime.",,AccessibilityServiceInfo The accessibility service info. |||,16,"Accessibility services should only be used to assist users with disabilities in using
 Android devices and apps. They run in the background and receive callbacks by the system
 when  AccessibilityEvent s are fired. Such events denote some state transition
 in the user interface for example the focus has changed a button has been clicked
 etc. Such a service can optionally request the capability for querying the content
 of the active window. Development of an accessibility service requires extending this
 class and implementing its abstract methods.","The classes in this package are used for development of accessibility service that
   provide alternative or augmented feedback to the user.
  
   An  AccessibilityService  runs in the background and
   receives callbacks by the system when  AccessibilityEvent s
   are fired. Such events denote some state transition in the user interface for example the
   focus has changed a button has been clicked etc. Such a service can optionally request the
   capability for querying the content of the active window. Development of an accessibility
   service requires extends this class and implements its abstract methods.
  
   An  AccessibilityServiceInfo  describes an
    AccessibilityService . The system notifies an
   AccessibilityService for  AccessibilityEvent s
   according to the information encapsulated in this class.",,,,,,,
<android.webkit.WebView: String getUrl()>,"Gets the URL for the current page. This is not always the same as the URL
 passed to WebViewClient.onPageStarted because although the load for
 that URL has begun the current page may not have changed.",,String the URL for the current page or null if no page has been loaded |||,1,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",,,,,,,
"<android.preference.PreferenceActivity: void loadHeadersFromResource(int,List)>","Parse the given XML file as a header description adding each
 parsed Header into the target list.","resid int : The XML resource to load and parse. |||
target List : The list in which the parsed headers should be placed. |||",void,11,"This is the base class for an activity to show a hierarchy of preferences
 to the user.  Prior to  Build.VERSION_CODES.HONEYCOMB 
 this class only allowed the display of a single set of preference; this
 functionality should now be found in the new  PreferenceFragment 
 class.  If you are using PreferenceActivity in its old mode the documentation
 there applies to the deprecated APIs here.

  This activity shows one or more headers of preferences each of which
 is associated with a  PreferenceFragment  to display the preferences
 of that header.  The actual layout and display of these associations can
 however vary; currently there are two major approaches it may take:

  On a small screen it may display only the headers as a single list when first launched.
 Selecting one of the header items will only show the PreferenceFragment of that header (on
 Android N and lower a new Activity is launched).
  On a large screen it may display both the headers and current PreferenceFragment together as
 panes. Selecting a header item switches to showing the correct PreferenceFragment for that item.
  Subclasses of PreferenceActivity should implement
  onBuildHeaders(List )  to populate the header list with the desired
 items.  Doing this implicitly switches the class into its new ""headers
 + fragments"" mode rather than the old style of just showing a single
 preferences list.",,,,,,,,
<android.view.View: void restoreHierarchyState(SparseArray)>,Restore this view hierarchy's frozen state from the given container.,container SparseArray : The SparseArray which holds previously frozen states. |||,void,1,"This class represents the basic building block for user interface components. A View
 occupies a rectangular area on the screen and is responsible for drawing and
 event handling. View is the base class for  widgets  which are
 used to create interactive UI components (buttons text fields etc.). The
  ViewGroup  subclass is the base class for  layouts  which
 are invisible containers that hold other Views (or other ViewGroups) and define
 their layout properties.",,,,,,,,
<android.preference.PreferenceActivity: void addPreferencesFromResource(int)>,"This method was deprecated
      in API level 15. This function is not relevant for a modern fragment-based
 PreferenceActivity. Inflates the given XML resource and adds the preference hierarchy to the current
 preference hierarchy.",preferencesResId int : The XML resource ID to inflate. |||,void,1,"This is the base class for an activity to show a hierarchy of preferences
 to the user.  Prior to  Build.VERSION_CODES.HONEYCOMB 
 this class only allowed the display of a single set of preference; this
 functionality should now be found in the new  PreferenceFragment 
 class.  If you are using PreferenceActivity in its old mode the documentation
 there applies to the deprecated APIs here.

  This activity shows one or more headers of preferences each of which
 is associated with a  PreferenceFragment  to display the preferences
 of that header.  The actual layout and display of these associations can
 however vary; currently there are two major approaches it may take:

  On a small screen it may display only the headers as a single list when first launched.
 Selecting one of the header items will only show the PreferenceFragment of that header (on
 Android N and lower a new Activity is launched).
  On a large screen it may display both the headers and current PreferenceFragment together as
 panes. Selecting a header item switches to showing the correct PreferenceFragment for that item.
  Subclasses of PreferenceActivity should implement
  onBuildHeaders(List )  to populate the header list with the desired
 items.  Doing this implicitly switches the class into its new ""headers
 + fragments"" mode rather than the old style of just showing a single
 preferences list.",,,,,,,,
<android.view.ActionProvider: View onCreateActionView(MenuItem)>,"Factory method called by the Android framework to create new action views.
 This method returns a new action view for the given MenuItem. If your ActionProvider implementation overrides the deprecated no-argument overload onCreateActionView() overriding this method for devices running API 16 or later
 is recommended but optional. The default implementation calls onCreateActionView() for compatibility with applications written for older platform versions.",forItem MenuItem : MenuItem to create the action view for |||,View the new action view |||,16,"An ActionProvider defines rich menu interaction in a single component.
 ActionProvider can generate action views for use in the action bar
 dynamically populate submenus of a MenuItem and handle default menu
 item invocations.

  An ActionProvider can be optionally specified for a  MenuItem  and will be
 responsible for creating the action view that appears in the  ActionBar 
 in place of a simple button in the bar. When the menu item is presented in a way that
 does not allow custom action views (e.g. in an overflow menu) the ActionProvider
 can perform a default action. There are two ways to use an action provider:
  
 Set the action provider on a  MenuItem  directly by calling
  MenuItem#setActionProvider(ActionProvider) .
  
 Declare the action provider in an XML menu resource. For example:
  
   <item android:id=""@+id/my_menu_item""
     android:title=""Title""
     android:icon=""@drawable/my_menu_item_icon""
     android:showAsAction=""ifRoom""
     android:actionProviderClass=""foo.bar.SomeActionProvider"" />",,,,,,,,
<android.os.Bundle: byte getByteArray(String)>,"Returns the value associated with the given key or null if
 no mapping of the desired type exists for the given key or a null
 value is explicitly associated with the key.","key String : a String or null
This value may be null . |||",byte[] a byte[] value or null |||,1,A mapping from String keys to various  Parcelable  values.,,,,,,,,
<android.text.TextUtils: CharSequence concat(CharSequence)>,"Returns a CharSequence concatenating the specified CharSequences
 retaining their spans if any.

 If there are no parameters an empty string will be returned.

 If the number of parameters is exactly one that parameter is returned as output even if it
 is null.

 If the number of parameters is at least two any null CharSequence among the parameters is
 treated as if it was the string ""null"" .

 If there are paragraph spans in the source CharSequences that satisfy paragraph boundary
 requirements in the sources but would no longer satisfy them in the concatenated
 CharSequence they may get extended in the resulting CharSequence or not retained.",text CharSequence |||,CharSequence |||,1,,"Provides classes used to render or track text and text spans on the screen. You can use these classes to design your own widgets that manage text
 to handle arbitrary text spans for changes or to handle drawing yourself
 for an existing widget. The Span… interfaces and classes are used to create or manage spans of
 text in a View item. You can use these to style the text or background or to
 listen for changes. If creating your own widget extend DynamicLayout to manages
 the actual wrapping and drawing of your text.",,,,,,,
"<android.appwidget.AppWidgetHostView: void setAppWidget(int,AppWidgetProviderInfo)>","Set the AppWidget that will be displayed by this view. This method also adds default padding
 to widgets as described in getDefaultPaddingForWidget(android.content.Context android.content.ComponentName android.graphics.Rect) and can be overridden in order to add custom padding.","appWidgetId int |||
info AppWidgetProviderInfo |||",void,3,"Provides the glue to show AppWidget views. This class offers automatic animation
 between updates and will try recycling old views for each incoming
  RemoteViews .","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.app.Activity: void closeContextMenu()>,Programmatically closes the most recently opened context menu if showing.,,void,3,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
"<android.media.AudioManager: void setVibrateSetting(int,int)>","This method was deprecated
      in API level 16. Applications should maintain their own vibrate policy based on
 current ringer mode that can be queried via getRingerMode() . Sets the setting for when the vibrate type should vibrate. This method should only be used by applications that replace the platform-wide
 management of audio settings or the main telephony application.","vibrateType int : The type of vibrate. One of VIBRATE_TYPE_NOTIFICATION or VIBRATE_TYPE_RINGER . |||
vibrateSetting int : The vibrate setting one of VIBRATE_SETTING_ON  VIBRATE_SETTING_OFF or VIBRATE_SETTING_ONLY_SILENT . |||",void,1,AudioManager provides access to volume and ringer mode control.,"The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",,,,,,,
<android.view.ViewGroup: void addView(View)>,"Adds a child view. If no layout parameters are already set on the child the
 default parameters for this ViewGroup are set on the child. Note: do not invoke this method from View.draw(android.graphics.Canvas)  View.onDraw(android.graphics.Canvas)  dispatchDraw(android.graphics.Canvas) or any related method.",child View : the child view to add |||,void,1,"A  ViewGroup  is a special view that can contain other views
 (called children.) The view group is the base class for layouts and views
 containers. This class also defines the
  ViewGroup.LayoutParams  class which serves as the base
 class for layouts parameters.
  
 Also see  LayoutParams  for layout attributes.",,,,,,,,
"<android.content.ContentResolver: void notifyChange(Uri,ContentObserver)>","Notify registered observers that a row was updated and attempt to sync
 changes to the network. To observe events sent through this call use registerContentObserver(android.net.Uri boolean android.database.ContentObserver) . Starting in Build.VERSION_CODES.O all content
 notifications must be backed by a valid ContentProvider .","uri Uri : The uri of the content that was changed.
This value cannot be null . |||
observer ContentObserver : The observer that originated the change may be null. The observer that originated the change
will only receive the notification if it has requested to
receive self-change notifications by implementing ContentObserver#deliverSelfNotifications() to return
true.
This value may be null . |||",void,1,This class provides applications access to the content model.,"Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.view.inputmethod.InputMethodInfo: Drawable loadIcon(PackageManager)>,Load the user-displayed icon for this input method.,"pm PackageManager : Supply a PackageManager used to load the input method's
resources. |||",Drawable |||,3,"This class is used to specify meta information of an input method.

  It should be defined in an XML resource file with an  <input-method>  element.
 For more information see the guide to
  
 Creating an Input Method .",,,,,,,,
<android.preference.DialogPreference: void setDialogIcon(int)>,"Sets the icon (resource ID) of the dialog. This will be shown on
 subsequent dialogs.",dialogIconRes int : The icon as a resource ID. |||,void,1,"A base class for  Preference  objects that are
 dialog-based. These preferences will when clicked open a dialog showing the
 actual preference controls.",,,,,,,,
<android.widget.PopupWindow: void dismiss()>,"Disposes of the popup window. This method can be invoked only after showAsDropDown(android.view.View) has been executed. Failing
 that calling this method will have no effect.",,void,1,"This class represents a popup window that can be used to display an
 arbitrary view. The popup window is a floating container that appears on top
 of the current activity.
  Animation 
 On all versions of Android popup window enter and exit animations may be
 specified by calling  setAnimationStyle(int)  and passing the
 resource ID for an animation style that defines  windowEnterAnimation 
 and  windowExitAnimation . For example passing
  R.style.Animation_Dialog  will give a scale and alpha
 animation.
 
 A window animation style may also be specified in the popup window's style
 XML via the  popupAnimationStyle 
 attribute.
  
 Starting with API 23 more complex popup window enter and exit transitions
 may be specified by calling either  setEnterTransition(android.transition.Transition) 
 or  setExitTransition(android.transition.Transition)  and passing a   Transition .
 
 Popup enter and exit transitions may also be specified in the popup window's
 style XML via the  popupEnterTransition 
 and  popupExitTransition 
 attributes respectively.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
"<android.app.Activity: void startIntentSenderForResult(IntentSender,int,Intent,int,int,int,Bundle)>","Like startActivityForResult(android.content.Intent int) but allowing you
 to use a IntentSender to describe the activity to be started.  If
 the IntentSender is for an activity that activity will be started
 as if you had called the regular startActivityForResult(android.content.Intent int) here; otherwise its associated action will be executed (such as
 sending a broadcast) as if you had called IntentSender#sendIntent on it.","intent IntentSender : The IntentSender to launch. |||
requestCode int : If >= 0 this code will be returned in
onActivityResult() when the activity exits. |||
fillInIntent Intent : If non-null this will be provided as the
intent parameter to IntentSender#sendIntent .
This value may be null . |||
flagsMask int : Intent flags in the original IntentSender that you
would like to change. |||
flagsValues int : Desired values for any bits set in flagsMask |||
extraFlags int : Always set to 0. |||
options Bundle : Additional options for how the Activity should be started.
See Context.startActivity(Intent Bundle) Context.startActivity(Intent Bundle)} for more details.  If options
have also been supplied by the IntentSender options given here will
override any that conflict with those given by the IntentSender. |||",void,16,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
"<android.app.Activity: void dump(String,FileDescriptor,PrintWriter,String)>","Print the Activity's state into the given stream.  This gets invoked if
 you run ""adb shell dumpsys activity <activity_component_name>"".","prefix String : Desired prefix to prepend at each line of output.
This value cannot be null . |||
fd FileDescriptor : The raw file descriptor that the dump is being sent to.
This value may be null . |||
writer PrintWriter : The PrintWriter to which you should dump your state.  This will be
closed for you after you return.
This value cannot be null . |||
args String : additional arguments to the dump request.
This value may be null . |||",void,11,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
"<android.location.LocationManager: void requestSingleUpdate(Criteria,PendingIntent)>","This method was deprecated
      in API level 30. Use getCurrentLocation(java.lang.String android.os.CancellationSignal java.util.concurrent.Executor java.util.function.Consumer) instead as it does not carry a risk of extreme battery drain. Register for a single location update using a Criteria and pending intent. See requestLocationUpdates(long float android.location.Criteria android.app.PendingIntent) for more detail
 on how to use this method. Requires Manifest.permission.ACCESS_COARSE_LOCATION or Manifest.permission.ACCESS_FINE_LOCATION","criteria Criteria : contains parameters to choose the appropriate provider for location
updates
This value cannot be null . |||
pendingIntent PendingIntent : the pending intent to send location updates
This value cannot be null . |||",void,9,"A data class representing a geographic location.

  A location can consist of a latitude longitude timestamp
 and other information such as bearing altitude and velocity.

  All locations generated by the  LocationManager  are
 guaranteed to have a valid latitude longitude and timestamp
 (both UTC time and elapsed real-time since boot) all other
 parameters are optional.","Contains the framework API classes that define Android location-based and
 	related services. This API is not the recommended method for accessing Android location. 
 The
  Google Location Services API 
 part of Google Play services is the preferred way to add location-awareness to
 your app. It offers a simpler API higher accuracy low-power geofencing and
 more. If you are currently using the android.location API you are strongly
 encouraged to switch to the Google Location Services API as soon as
 possible.
  
 To learn more about the Google Location Services API see the
  Location API overview .",,,,,,,
<android.app.Application: void onTrimMemory(int)>,"Called when the operating system has determined that it is a good
 time for a process to trim unneeded memory from its process.  This will
 happen for example when it goes in the background and there is not enough
 memory to keep as many background processes running as desired.  You
 should never compare to exact values of the level since new intermediate
 values may be added -- you will typically want to compare if the value
 is greater or equal to a level you are interested in. To retrieve the processes current trim level at any point you can
 use ActivityManager.getMyMemoryState(RunningAppProcessInfo) .

 If you override this method you must call through to the
 superclass implementation.","level int : The context of the trim giving a hint of the amount of
trimming the application may like to perform.
Value is ComponentCallbacks2.TRIM_MEMORY_COMPLETE  ComponentCallbacks2.TRIM_MEMORY_MODERATE  ComponentCallbacks2.TRIM_MEMORY_BACKGROUND  ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN  ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL  ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW or ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE |||",void,14,"Base class for maintaining global application state. You can provide your own
 implementation by creating a subclass and specifying the fully-qualified name
 of this subclass as the  ""android:name""  attribute in your
 AndroidManifest.xml's  <application>  tag. The Application
 class or your subclass of the Application class is instantiated before any
 other class when the process for your application/package is created.

  Note:  There is normally no need to subclass
 Application.  In most situations static singletons can provide the same
 functionality in a more modular way.  If your singleton needs a global
 context (for example to register broadcast receivers) include
  Context.getApplicationContext() 
 as a  Context  argument when invoking your singleton's
  getInstance()  method.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.widget.ListView: void smoothScrollToPosition(int)>,"Smoothly scroll to the specified adapter position. The view will
 scroll such that the indicated position is displayed.",position int : Scroll to this adapter position. |||,void,8,"Displays a vertically-scrollable collection of views where each view is positioned
 immediatelybelow the previous view in the list.  For a more modern flexible and performant
 approach to displaying lists use  RecyclerView . To display a list you can include a list view in your layout XML file: <ListView
      android:id=""@+id/list_view""
      android:layout_width=""match_parent""
      android:layout_height=""match_parent"" /> A list view is an  
 adapter view  that does not know the details such as type and contents of the views it
 contains. Instead list view requests views on demand from a  ListAdapter  as needed
 such as to display new views as the user scrolls up or down. In order to display items in the list call  setAdapter(android.widget.ListAdapter) 
 to associate an adapter with the list.  For a simple example see the discussion of filling an
 adapter view with text in the
  
 Layouts  guide. To display a more custom view for each item in your dataset implement a ListAdapter.
 For example extend  BaseAdapter  and create and configure the view for each data item in
  getView(...) : private class MyAdapter extends BaseAdapter {

      // override other abstract methods here

      @Override
      public View getView(int position View convertView ViewGroup container) {
          if (convertView == null) {
              convertView = getLayoutInflater().inflate(R.layout.list_item container false);
          }

          ((TextView) convertView.findViewById(android.R.id.text1))
                  .setText(getItem(position));
          return convertView;
      }
  } ListView attempts to reuse view objects in order to improve performance and
 avoid a lag in response to user scrolls.  To take advantage of this feature check if the
  convertView  provided to  getView(...)  is null before creating or inflating a new
 view object.  See
  
 Making ListView Scrolling Smooth  for more ways to ensure a smooth user experience. To specify an action when a user clicks or taps on a single list item see
  
     Handling click events . To learn how to populate a list view with a CursorAdapter see the discussion of filling an
 adapter view with text in the
  
 Layouts  guide.
 See  
     Using a Loader 
 to learn how to avoid blocking the main thread when using a cursor. Note many examples use  ListActivity 
 or  ListFragment 
 to display a list view. Instead favor the more flexible approach when writing your own app:
 use a more generic Activity subclass or Fragment subclass and add a list view to the layout
 or view hierarchy directly.  This approach gives you more direct control of the
 list view and adapter.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.widget.AdapterViewAnimator: void setRemoteViewsAdapter(Intent)>,"Sets up this AdapterViewAnimator to use a remote views adapter which connects to a
 RemoteViewsService through the specified intent.","intent Intent : the intent used to identify the RemoteViewsService for the adapter to
connect to. |||",void,11,"An AdapterView is a view whose children are determined by an  Adapter .

  
 See  ListView   GridView   Spinner  and
       Gallery  for commonly used subclasses of AdapterView.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.provider.MediaStore: String getVersion(Context)>,"Return an opaque version string describing the MediaStore state. Applications that import data from MediaStore into their own
 caches can use this to detect that MediaStore has undergone
 substantial changes and that data should be rescanned. No other assumptions should be made about the meaning of the version. This method returns the version for MediaStore#VOLUME_EXTERNAL_PRIMARY ; to obtain a version for a
 different volume use getVersion(android.content.Context java.lang.String) .",context Context : This value cannot be null . |||,String This value cannot be null . |||,12,"The contract between the media provider and applications. Contains
 definitions for the supported URIs and columns.
  
 The media provider provides an indexed collection of common media types such
 as  Audio   Video  and  Images  from any attached
 storage devices. Each collection is organized based on the primary MIME type
 of the underlying content; for example  image/*  content is indexed
 under  Images . The  Files  collection provides a broad view
 across all collections and does not filter by MIME type.","Provides convenience classes to access the content providers supplied by
 Android. Android ships with a number of content providers that store common data such
 as contact informations calendar information and media files. These classes
 provide simplified methods of adding or retrieving data from these content
 providers. For information about how to use a content provider see the  Content Providers  developer
 guide.",,,,,,,
<android.util.LruCache: void evictAll()>,Clear the cache calling entryRemoved(boolean K V V) on each removed entry.,,void,12,"A cache that holds strong references to a limited number of values. Each time
 a value is accessed it is moved to the head of a queue. When a value is
 added to a full cache the value at the end of that queue is evicted and may
 become eligible for garbage collection.

  If your cached values hold resources that need to be explicitly released
 override  entryRemoved(boolean K V V) .

  If a cache miss should be computed on demand for the corresponding keys
 override  create(K) . This simplifies the calling code allowing it to
 assume a value will always be returned even when there's a cache miss.

  By default the cache size is measured in the number of entries. Override
  sizeOf(K V)  to size the cache in different units. For example this cache
 is limited to 4MiB of bitmaps:
  int cacheSize = 4 * 1024 * 1024; // 4MiB
   LruCache<String Bitmap> bitmapCache = new LruCache<String Bitmap>(cacheSize) {
       protected int sizeOf(String key Bitmap value) {
           return value.getByteCount();
       }
   } This class is thread-safe. Perform multiple cache operations atomically by
 synchronizing on the cache:  synchronized (cache) {
     if (cache.get(key) == null) {
         cache.put(key value);
     }
   } This class does not allow null to be used as a key or value. A return
 value of null from  get(K)   put(K V)  or  remove(K)  is
 unambiguous: the key was not in the cache.

  This class appeared in Android 3.1 (Honeycomb MR1); it's available as part
 of  Android's
 Support Package  for earlier releases.",,,,,,,,
"<android.animation.LayoutTransition: void hideChild(ViewGroup,View,int)>","This method is called by ViewGroup when a child view is about to be hidden in
 container. This callback starts the process of a transition; we grab the starting
 values listen for changes to all of the children of the container and start appropriate
 animations.","parent ViewGroup : The parent ViewGroup of the View being hidden. |||
child View : The View being hidden. |||
newVisibility int : The new visibility value of the child View either View#GONE or View#INVISIBLE . |||",void,16,"This class enables automatic animations on layout changes in ViewGroup objects. To enable
 transitions for a layout container create a LayoutTransition object and set it on any
 ViewGroup by calling  ViewGroup#setLayoutTransition(LayoutTransition) . This will cause
 default animations to run whenever items are added to or removed from that container. To specify
 custom animations use the  LayoutTransition#setAnimator(int Animator)  method.

  One of the core concepts of these transition animations is that there are two types of
 changes that cause the transition and four different animations that run because of
 those changes. The changes that trigger the transition are items being added to a container
 (referred to as an ""appearing"" transition) or removed from a container (also known as
 ""disappearing""). Setting the visibility of views (between GONE and VISIBLE) will trigger
 the same add/remove logic. The animations that run due to those events are one that animates
 items being added one that animates items being removed and two that animate the other
 items in the container that change due to the add/remove occurrence. Users of
 the transition may want different animations for the changing items depending on whether
 they are changing due to an appearing or disappearing event so there is one animation for
 each of these variations of the changing event. Most of the API of this class is concerned
 with setting up the basic properties of the animations used in these four situations
 or with setting up custom animations for any or all of the four. By default the DISAPPEARING animation begins immediately as does the CHANGE_APPEARING
 animation. The other animations begin after a delay that is set to the default duration
 of the animations. This behavior facilitates a sequence of animations in transitions as
 follows: when an item is being added to a layout the other children of that container will
 move first (thus creating space for the new item) then the appearing animation will run to
 animate the item being added. Conversely when an item is removed from a container the
 animation to remove it will run first then the animations of the other children in the
 layout will run (closing the gap created in the layout when the item was removed). If this
 default choreography behavior is not desired the  setDuration(int long)  and
  setStartDelay(int long)  of any or all of the animations can be changed as
 appropriate. Keep in mind however that if you start an APPEARING animation before a
 DISAPPEARING animation is completed the DISAPPEARING animation stops and any effects from
 the DISAPPEARING animation are reverted. If you instead start a DISAPPEARING animation
 before an APPEARING animation is completed a similar set of effects occurs for the
 APPEARING animation. The animations specified for the transition both the defaults and any custom animations
 set on the transition object are templates only. That is these animations exist to hold the
 basic animation properties such as the duration start delay and properties being animated.
 But the actual target object as well as the start and end values for those properties are
 set automatically in the process of setting up the transition each time it runs. Each of the
 animations is cloned from the original copy and the clone is then populated with the dynamic
 values of the target being animated (such as one of the items in a layout container that is
 moving as a result of the layout event) as well as the values that are changing (such as the
 position and size of that object). The actual values that are pushed to each animation
 depends on what properties are specified for the animation. For example the default
 CHANGE_APPEARING animation animates the  left   top   right 
  bottom   scrollX  and  scrollY  properties.
 Values for these properties are updated with the pre- and post-layout
 values when the transition begins. Custom animations will be similarly populated with
 the target and values being animated assuming they use ObjectAnimator objects with
 property names that are known on the target object. This class and the associated XML flag for containers animateLayoutChanges=""true""
 provides a simple utility meant for automating changes in straightforward situations.
 Using LayoutTransition at multiple levels of a nested view hierarchy may not work due to the
 interrelationship of the various levels of layout. Also a container that is being scrolled
 at the same time as items are being added or removed is probably not a good candidate for
 this utility because the before/after locations calculated by LayoutTransition
 may not match the actual locations when the animations finish due to the container
 being scrolled as the animations are running. You can work around that
 particular issue by disabling the 'changing' animations by setting the CHANGE_APPEARING
 and CHANGE_DISAPPEARING animations to null and setting the startDelay of the
 other animations appropriately.","These classes provide functionality for the property animation system which allows you
 to animate object properties of any type.  int   float  and hexadecimal
 color values are supported by default. You can animate any other type by telling the system how
 to calculate the values for that given type with a custom  TypeEvaluator .
  For more information see the
  Animation  guide. 
 You can set many different types of interpolators (contained in  android.view.animation )
 specify  keyframes  or group animations to play sequentially
 or simultaneously (with  AnimatorSet ) to further control your animation
 behaviors.",,,,,,,
<android.nfc.tech.NdefFormatable: void format(NdefMessage)>,"Format a tag as NDEF and write a NdefMessage . This is a multi-step process an IOException is thrown
 if any one step fails. The card is left in a read-write state after this operation. This is an I/O operation and will block until complete. It must
 not be called from the main application thread. A blocked call will be canceled with IOException if close() is called from another thread. Requires the Manifest.permission.NFC permission.",firstMessage NdefMessage : the NDEF message to write after formatting can be null |||,void,10,"Provide access to NDEF format operations on a  Tag .

  Acquire a  NdefFormatable  object using  get(Tag) .

  Android devices with NFC must only enumerate and implement this
 class for tags for which it can format to NDEF.

  Unfortunately the procedures to convert unformated tags to NDEF formatted
 tags are not specified by NFC Forum and are not generally well-known. So
 there is no mandatory set of tags for which all Android devices with NFC
 must support  NdefFormatable .

  Note:  Methods that perform I/O operations
 require the  Manifest.permission.NFC  permission.","These classes provide access to a tag technology's features which vary by the type
 of tag that is scanned. A scanned tag can support multiple technologies and you can find
 out what they are by calling  getTechList() . For more information on dealing with tag technologies and handling the ones that you care about see
  The Tag Dispatch System .
 The  TagTechnology  interface provides an overview of the
 supported technologies.",,,,,,,
"<android.view.View: void addFocusables(ArrayList,int)>","Add any focusable views that are descendants of this view (possibly
 including this view if it is focusable itself) to views.  If we are in touch mode
 only add views that are also focusable in touch mode.","views ArrayList : Focusable views found so far |||
direction int : The direction of the focus
Value is FOCUS_BACKWARD  FOCUS_FORWARD  FOCUS_LEFT  FOCUS_UP  FOCUS_RIGHT or FOCUS_DOWN |||",void,1,"This class represents the basic building block for user interface components. A View
 occupies a rectangular area on the screen and is responsible for drawing and
 event handling. View is the base class for  widgets  which are
 used to create interactive UI components (buttons text fields etc.). The
  ViewGroup  subclass is the base class for  layouts  which
 are invisible containers that hold other Views (or other ViewGroups) and define
 their layout properties.",,,,,,,,
<android.app.NativeActivity: void onConfigurationChanged(Configuration)>,"Called by the system when the device configuration changes while your
 activity is running.  Note that this will only be called if
 you have selected configurations you would like to handle with the R.attr.configChanges attribute in your manifest.  If
 any configuration change occurs that is not selected to be reported
 by that attribute then instead of reporting it the system will stop
 and restart the activity (to have it launched with the new
 configuration). At the time that this function has been called your Resources
 object will have been updated to return resource values matching the
 new configuration.","newConfig Configuration : The new device configuration.
This value cannot be null . |||",void,9,"Convenience for implementing an activity that will be implemented
 purely in native code.  That is a game (or game-like thing).  There
 is no need to derive from this class; you can simply declare it in your
 manifest and use the NDK APIs from there.

  A  sample
 native activity  is available in the NDK samples.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.view.inputmethod.BaseInputConnection: CharSequence getSelectedText(int)>,"The default implementation returns the text currently selected or null if none is
 selected.","flags int : Supplies additional options controlling how the text is
returned. May be either 0 or InputConnection.GET_TEXT_WITH_STYLES . |||","CharSequence the text that is currently selected if any or null if
 no text is selected. In Build.VERSION_CODES.N and
 later returns false when the target application does not implement
 this method. |||",9,"Base class for implementors of the InputConnection interface taking care
 of most of the common behavior for providing a connection to an Editable.
 Implementors of this class will want to be sure to implement
  getEditable()  to provide access to their own editable object and
 to refer to the documentation in  InputConnection .",,,,,,,,
"<android.net.SSLCertificateSocketFactory: Socket createSocket(InetAddress,int,InetAddress,int)>","Creates a socket and connect it to the specified remote address
 on the specified remote port.  The socket will also be bound
 to the local address and port suplied.  The socket is configured using
 the socket options established for this factory. If there is a security manager its checkConnect method is called with the host address and port as its arguments. This could result in a SecurityException. This method returns a socket that is not connected . Warning: Hostname verification is not performed
 with this method.  You MUST verify the server's identity after connecting
 the socket to avoid man-in-the-middle attacks.","addr InetAddress : the server network address |||
port int : the server port |||
localAddr InetAddress : the client network address |||
localPort int : the client port |||",Socket the Socket |||,1,"SSLSocketFactory implementation with several extra features:

  Timeout specification for SSL handshake operations
  Hostname verification in most cases (see WARNINGs below)
  Optional SSL session caching with  SSLSessionCache Optionally bypass all SSL certificate checks
  createSocket() Socket#connect(java.net.SocketAddress int) The recommended way to verify the server's identity is to use
  HttpsURLConnection#getDefaultHostnameVerifier()  to get a
  HostnameVerifier  to verify the certificate hostname.

  Warning : Some methods on this class return connected sockets and some return
 unconnected sockets.  For the methods that return connected sockets setting
 connection- or handshake-related properties on those sockets will have no effect.

  On development devices ""setprop socket.relaxsslcheck yes"" bypasses all
 SSL certificate and hostname checks for testing purposes.  This setting
 requires root access.",,,,,,,,
"<android.test.TouchUtils: int dragViewTo(ActivityInstrumentationTestCase,View,int,int,int)>","This method was deprecated
      in API level 15. ActivityInstrumentationTestCase is deprecated in favor of ActivityInstrumentationTestCase2 which provides more options for
 configuring the Activity under test Simulate touching a view and dragging it to a specified location.","test ActivityInstrumentationTestCase : The test case that is being run |||
v View : The view that should be dragged |||
gravity int : Which part of the view to use for the initial down event. A combination of
(TOP CENTER_VERTICAL BOTTOM) and (LEFT CENTER_HORIZONTAL RIGHT) |||
toX int : Final location of the view after dragging |||
toY int : Final location of the view after dragging |||",int distance in pixels covered by the drag |||,1,"Reusable methods for generating touch events. These methods can be used with
 InstrumentationTestCase or ActivityInstrumentationTestCase2 to simulate user interaction with
 the application through a touch screen.",,,,,,,,
"<android.content.Intent: double getDoubleExtra(String,double)>",Retrieve extended data from the intent.,"name String : The name of the desired item. |||
defaultValue double : the value to be returned if no value of the desired
type is stored with the given name. |||","double the value of an item previously added with putExtra()
 or the default value if none was found. |||",1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.app.Fragment: FragmentManager getChildFragmentManager()>,"Return a private FragmentManager for placing and managing Fragments
 inside of this Fragment.",,FragmentManager |||,17,"A Fragment is a piece of an application's user interface or behavior
 that can be placed in an  Activity .  Interaction with fragments
 is done through  FragmentManager  which can be obtained via
  Activity#getFragmentManager()  and
  Fragment#getFragmentManager() .

  The Fragment class can be used many ways to achieve a wide variety of
 results. In its core it represents a particular operation or interface
 that is running within a larger  Activity .  A Fragment is closely
 tied to the Activity it is in and can not be used apart from one.  Though
 Fragment defines its own lifecycle that lifecycle is dependent on its
 activity: if the activity is stopped no fragments inside of it can be
 started; when the activity is destroyed all fragments will be destroyed.

  All subclasses of Fragment must include a public no-argument constructor.
 The framework will often re-instantiate a fragment class when needed
 in particular during state restore and needs to be able to find this
 constructor to instantiate it.  If the no-argument constructor is not
 available a runtime exception will occur in some cases during state
 restore.

  Topics covered here:
  Older Platforms Lifecycle Layout Back Stack","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.media.AudioManager: void setMode(int)>,"Sets the audio mode. The audio mode encompasses audio routing AND the behavior of
 the telephony layer. Therefore this method should only be used by applications that
 replace the platform-wide management of audio settings or the main telephony application.
 In particular the MODE_IN_CALL mode should only be used by the telephony
 application when it places a phone call as it will cause signals from the radio layer
 to feed the platform mixer.","mode int : the requested audio mode.
Informs the HAL about the current audio state so that
it can route the audio appropriately.
Value is MODE_NORMAL  MODE_RINGTONE  MODE_IN_CALL  MODE_IN_COMMUNICATION or MODE_CALL_SCREENING |||",void,1,AudioManager provides access to volume and ringer mode control.,"The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",,,,,,,
<android.preference.DialogPreference: void onDismiss(DialogInterface)>,This method will be invoked when the dialog is dismissed.,"dialog DialogInterface : the dialog that was dismissed will be passed into the
method |||",void,1,"A base class for  Preference  objects that are
 dialog-based. These preferences will when clicked open a dialog showing the
 actual preference controls.",,,,,,,,
"<android.content.ContextWrapper: void revokeUriPermission(Uri,int)>","Remove all permissions to access a particular content provider Uri
 that were previously added with grantUriPermission(String Uri int) or any other mechanism.
 The given Uri will match all previously granted Uris that are the same or a
 sub-path of the given Uri.  That is revoking ""content://foo/target"" will
 revoke both ""content://foo/target"" and ""content://foo/target/sub"" but not
 ""content://foo"".  It will not remove any prefix grants that exist at a
 higher level. Prior to Build.VERSION_CODES.LOLLIPOP if you did not have
 regular permission access to a Uri but had received access to it through
 a specific Uri permission grant you could not revoke that grant with this
 function and a SecurityException would be thrown.  As of Build.VERSION_CODES.LOLLIPOP this function will not throw a security
 exception but will remove whatever permission grants to the Uri had been given to the app
 (or none). Unlike revokeUriPermission(java.lang.String android.net.Uri int) this method impacts all permission
 grants matching the given Uri for any package they had been granted to through any
 mechanism this had happened (such as indirectly through the clipboard activity launch
 service start etc).  That means this can be potentially dangerous to use as it can
 revoke grants that another app could be strongly expecting to stick around.","uri Uri : The Uri you would like to revoke access to. |||
modeFlags int : The access modes to revoke.
Value is either 0 or a combination of Intent.FLAG_GRANT_READ_URI_PERMISSION and Intent.FLAG_GRANT_WRITE_URI_PERMISSION |||",void,1,"Proxying implementation of Context that simply delegates all of its calls to
 another Context.  Can be subclassed to modify behavior without changing
 the original Context.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.content.Intent: ArrayList getCharSequenceArrayListExtra(String)>,Retrieve extended data from the intent.,name String : The name of the desired item. |||,"ArrayList < CharSequence > the value of an item previously added with
 putCharSequenceArrayListExtra or null if no
 ArrayList value was found. |||",8,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.content.ContentResolver: void unregisterContentObserver(ContentObserver)>,Unregisters a change observer.,"observer ContentObserver : The previously registered observer that is no longer needed.
This value cannot be null . |||",void,1,This class provides applications access to the content model.,"Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
"<android.inputmethodservice.KeyboardView: void onSizeChanged(int,int,int,int)>","This is called during layout when the size of this view has changed. If
 you were just added to the view hierarchy you're called with the old
 values of 0.","w int : Current width of this view. |||
h int : Current height of this view. |||
oldw int : Old width of this view. |||
oldh int : Old height of this view. |||",void,3,"A view that renders a virtual  Keyboard . It handles rendering of keys and
 detecting key presses and touch movements.",,,,,,,,
"<android.app.WallpaperInfo: void writeToParcel(Parcel,int)>",Used to package this object into a Parcel .,"dest Parcel : The Parcel to be written. |||
flags int : The flags used for parceling. |||",void,7,This class is used to specify meta information of a wallpaper service.,"Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
"<android.accounts.AbstractAccountAuthenticator: Bundle getAccountRemovalAllowed(AccountAuthenticatorResponse,Account)>",Checks if the removal of this account is allowed.,"response AccountAuthenticatorResponse : to send the result back to the AccountManager will never be null |||
account Account : the account to check will never be null |||","Bundle a Bundle result or null if the result is to be returned via the response. The result
 will contain either: AccountManager#KEY_INTENT or AccountManager#KEY_BOOLEAN_RESULT true if the removal of the account is
 allowed false otherwise AccountManager#KEY_ERROR_CODE and AccountManager#KEY_ERROR_MESSAGE to
 indicate an error |||",5,"Abstract base class for creating AccountAuthenticators.
 In order to be an authenticator one must extend this class provide implementations for the
 abstract methods and write a service that returns the result of  getIBinder() 
 in the service's  Service.onBind(android.content.Intent)  when invoked
 with an intent with action  AccountManager#ACTION_AUTHENTICATOR_INTENT . This service
 must specify the following intent filter and metadata tags in its AndroidManifest.xml file
  
   <intent-filter>
     <action android:name=""android.accounts.AccountAuthenticator"" />
   </intent-filter>
   <meta-data android:name=""android.accounts.AccountAuthenticator""
             android:resource=""@xml/authenticator"" />
  android:resource 
 <account-authenticator xmlns:android=""http://schemas.android.com/apk/res/android""
    android:accountType=""typeOfAuthenticator""
    android:icon=""@drawable/icon""
    android:smallIcon=""@drawable/miniIcon""
    android:label=""@string/label""
    android:accountPreferences=""@xml/account_preferences""
 />
  android:accountType AccountManager Account#type 
 The preferences attribute points to a PreferenceScreen xml hierarchy that contains
 a list of PreferenceScreens that can be invoked to manage the authenticator. An example is:
  
 <PreferenceScreen xmlns:android=""http://schemas.android.com/apk/res/android"">
    <PreferenceCategory android:title=""@string/title_fmt"" />
    <PreferenceScreen
         android:key=""key1""
         android:title=""@string/key1_action""
         android:summary=""@string/key1_summary"">
         <intent
             android:action=""key1.ACTION""
             android:targetPackage=""key1.package""
             android:targetClass=""key1.class"" />
     </PreferenceScreen>
 </PreferenceScreen>
  
 The standard pattern for implementing any of the abstract methods is the following:
   If the supplied arguments are enough for the authenticator to fully satisfy the request
 then it will do so and return a  Bundle  that contains the results.
   If the authenticator needs information from the user to satisfy the request then it
 will create an  Intent  to an activity that will prompt the user for the information
 and then carry out the request. This intent must be returned in a Bundle as key
  AccountManager#KEY_INTENT .
  
 The activity needs to return the final result when it is complete so the Intent should contain
 the  AccountAuthenticatorResponse  as  AccountManager#KEY_ACCOUNT_MANAGER_RESPONSE .
 The activity must then call  AccountAuthenticatorResponse#onResult  or
  AccountAuthenticatorResponse#onError  when it is complete.
   If the authenticator cannot synchronously process the request and return a result then it
 may choose to return null and then use the AccountManagerResponse to send the result
 when it has completed the request.
  
 The following descriptions of each of the abstract authenticator methods will not describe the
 possible asynchronous nature of the request handling and will instead just describe the input
 parameters and the expected result.
  
 When writing an activity to satisfy these requests one must pass in the AccountManagerResponse
 and return the result via that response when the activity finishes (or whenever else  the
 activity author deems it is the correct time to respond).
 The  AccountAuthenticatorActivity  handles this so one may wish to extend that when
 writing activities to handle these requests.",,,,,,,,
"<android.media.MediaExtractor: void setDataSource(Context,Uri,Map)>",Sets the data source as a content Uri.,"context Context : the Context to use when resolving the Uri
This value cannot be null . |||
uri Uri : the Content URI of the data you want to extract from. When uri refers to a network file the Manifest.permission.INTERNET permission is required.
This value cannot be null . |||
headers Map : the headers to be sent together with the request for the data.
This can be null if no specific headers are to be sent with the
request.
This value may be null . |||",void,16,"MediaExtractor facilitates extraction of demuxed typically encoded  media data
 from a data source.
  It is generally used like this:
  
 MediaExtractor extractor = new MediaExtractor();
 extractor.setDataSource(...);
 int numTracks = extractor.getTrackCount();
 for (int i = 0; i < numTracks; ++i) {
   MediaFormat format = extractor.getTrackFormat(i);
   String mime = format.getString(MediaFormat.KEY_MIME);
   if (weAreInterestedInThisTrack) {
     extractor.selectTrack(i);
   }
 }
 ByteBuffer inputBuffer = ByteBuffer.allocate(...)
 while (extractor.readSampleData(inputBuffer ...) >= 0) {
   int trackIndex = extractor.getSampleTrackIndex();
   long presentationTimeUs = extractor.getSampleTime();
   ...
   extractor.advance();
 }

 extractor.release();
 extractor = null;
  This class requires the  Manifest.permission.INTERNET  permission
 when used with network-based content.","The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",,,,,,,
<android.webkit.WebView: int getProgress()>,Gets the progress for the current page.,,int the progress for the current page between 0 and 100 |||,1,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",,,,,,,
"<android.webkit.WebView: void savePassword(String,String,String)>","This method was deprecated
      in API level 18. Saving passwords in WebView will not be supported in future versions. Sets a username and password pair for the specified host. This data is
 used by the WebView to autocomplete username and password fields in web
 forms. Note that this is unrelated to the credentials used for HTTP
 authentication.","host String : the host that required the credentials |||
username String : the username for the given host |||
password String : the password for the given host |||",void,1,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",,,,,,,
<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo focusSearch(int)>,"Searches for the nearest view in the specified direction that can take
 the input focus. Note: If this view hierarchy has a SurfaceView embedding another
 view hierarchy via SurfaceView#setChildSurfacePackage there is a limitation that
 this API won't be able to find the node for the view in the specified direction on the
 embedded view hierarchy. It's because views don't know about the embedded hierarchies.
 Instead you could traverse all the children to find the node.",direction int : The direction. Can be one of: View#FOCUS_DOWN  View#FOCUS_UP  View#FOCUS_LEFT  View#FOCUS_RIGHT  View#FOCUS_FORWARD  View#FOCUS_BACKWARD . |||,AccessibilityNodeInfo The node info for the view that can take accessibility focus. |||,16,"This class represents a node of the window content as well as actions that
 can be requested from its source. From the point of view of an
  AccessibilityService  a window's content is
 presented as a tree of accessibility node infos which may or may not map one-to-one
 to the view hierarchy. In other words a custom view is free to report itself as
 a tree of accessibility node info.
  
 Once an accessibility node info is delivered to an accessibility service it is
 made immutable and calling a state mutation method generates an error.
  
 Please refer to  AccessibilityService  for
 details about how to obtain a handle to window content as a tree of accessibility
 node info as well as details about the security model.",,,,,,,,
<android.view.View: void setBottom(int)>,"Sets the bottom position of this view relative to its parent. This method is meant to be
 called by the layout system and should not generally be called otherwise because the
 property may be changed at any time by the layout.",bottom int : The bottom of this view in pixels. |||,void,11,"This class represents the basic building block for user interface components. A View
 occupies a rectangular area on the screen and is responsible for drawing and
 event handling. View is the base class for  widgets  which are
 used to create interactive UI components (buttons text fields etc.). The
  ViewGroup  subclass is the base class for  layouts  which
 are invisible containers that hold other Views (or other ViewGroups) and define
 their layout properties.",,,,,,,,
<android.media.AudioManager: void unregisterRemoteControlClient(RemoteControlClient)>,"This method was deprecated
      in API level 21. Use MediaSession instead. Unregisters the remote control client that was providing information to display on the
 remote controls.",rcClient RemoteControlClient : The remote control client to unregister. |||,void,14,AudioManager provides access to volume and ringer mode control.,"The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",,,,,,,
<android.nfc.tech.NdefFormatable: void connect()>,"Enable I/O operations to the tag from this TagTechnology object. May cause RF activity and may block. Must not be called
 from the main application thread. A blocked call will be canceled with IOException by calling close() from another thread. Only one TagTechnology object can be connected to a Tag at a time. Applications must call close() when I/O operations are complete. Requires the Manifest.permission.NFC permission.",,void,-1,"Provide access to NDEF format operations on a  Tag .

  Acquire a  NdefFormatable  object using  get(Tag) .

  Android devices with NFC must only enumerate and implement this
 class for tags for which it can format to NDEF.

  Unfortunately the procedures to convert unformated tags to NDEF formatted
 tags are not specified by NFC Forum and are not generally well-known. So
 there is no mandatory set of tags for which all Android devices with NFC
 must support  NdefFormatable .

  Note:  Methods that perform I/O operations
 require the  Manifest.permission.NFC  permission.","These classes provide access to a tag technology's features which vary by the type
 of tag that is scanned. A scanned tag can support multiple technologies and you can find
 out what they are by calling  getTechList() . For more information on dealing with tag technologies and handling the ones that you care about see
  The Tag Dispatch System .
 The  TagTechnology  interface provides an overview of the
 supported technologies.",,,,,,,
<android.nfc.NfcAdapter: void disableForegroundDispatch(Activity)>,"Disable foreground dispatch to the given activity. After calling enableForegroundDispatch(Activity PendingIntent IntentFilter[] String[][]) an activity
 must call this method before its Activity#onPause callback
 completes. This method must be called from the main thread. Requires the Manifest.permission.NFC permission.",activity Activity : the Activity to disable dispatch to |||,void,10,"Represents the local NFC adapter.
  
 Use the helper  getDefaultAdapter(android.content.Context)  to get the default NFC
 adapter for this Android device.","Provides access to Near Field Communication (NFC) functionality allowing applications to read
 NDEF message in NFC tags. A ""tag"" may actually be another device that appears as a tag. For more information see the
  Near Field Communication  guide. Here's a summary of the classes: NfcManager This is the high level manager used to obtain this device's  NfcAdapter . You can
 acquire an instance using  getSystemService(Class ) . NfcAdapter This represents the device's NFC adapter which is your entry-point to performing NFC
 operations. You can acquire an instance with  getDefaultAdapter()  or
  getDefaultAdapter(android.content.Context) . NdefMessage Represents an NDEF data message which is the standard format in which ""records""
 carrying data are transmitted between devices and tags. Your application can receive these
 messages from an  ACTION_TAG_DISCOVERED  intent. NdefRecord Represents a record which is delivered in a  NdefMessage  and describes the
 type of data being shared and carries the data itself. Note: 
 Not all Android-powered devices provide NFC functionality.",,,,,,,
<android.database.DatabaseUtils: void readExceptionFromParcel(Parcel)>,"Special function for reading an exception result from the header of
 a parcel to be used after receiving the result of a transaction.  This
 will throw the exception for you if it had been written to the Parcel
 otherwise return and let you read the normal result data from the Parcel.",reply Parcel : Parcel to read from |||,void,1,Static utility methods for dealing with databases and  Cursor s.,"If you need to manage data in a private database use the  android.database.sqlite  classes. These classes are used to manage the  Cursor  object returned from a content provider query. Databases
 are usually created and opened with  openOrCreateDatabase(String int SQLiteDatabase.CursorFactory) 
 To make requests through
 content providers you can use the  content.ContentResolver  class.
  All databases are stored on the device in  /data/data/<package_name>/databases",,,,,,,
<android.webkit.WebView: void requestImageRef(Message)>,"Requests the URL of the image last touched by the user. msg will be sent
 to its target with a String representing the URL as its object.","msg Message : the message to be dispatched with the result of the request
as the data member with ""url"" as key. The result can be null .
This value cannot be null . |||",void,1,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",,,,,,,
<android.bluetooth.BluetoothDevice: String getAlias()>,Get the Bluetooth alias of the remote device. Alias is the locally modified name of a remote device. Requires Manifest.permission.BLUETOOTH,,"String the Bluetooth alias the friendly device name if no alias or
 null if there was a problem |||",30,"Represents a remote Bluetooth device. A  BluetoothDevice  lets you
 create a connection with the respective device or query information about
 it such as the name address class and bonding state.

  This class is really just a thin wrapper for a Bluetooth hardware
 address. Objects of this class are immutable. Operations on this class
 are performed on the remote Bluetooth hardware address using the
  BluetoothAdapter  that was used to create this  BluetoothDevice .

  To get a  BluetoothDevice  use
  BluetoothAdapter#getRemoteDevice(String)  to create one representing a device
 of a known MAC address (which you can get through device discovery with
  BluetoothAdapter ) or get one from the set of bonded devices
 returned by  BluetoothAdapter#getBondedDevices() . You can then open a
  BluetoothSocket  for communication with the remote device using
  createRfcommSocketToServiceRecord(java.util.UUID)  over Bluetooth BR/EDR or using
  createL2capChannel(int)  over Bluetooth LE.

  Note: 
 Requires the  Manifest.permission.BLUETOOTH  permission.","Provides classes that manage Bluetooth functionality such as scanning for
 devices connecting with devices and managing data transfer between devices.
 The Bluetooth API supports both ""Classic Bluetooth"" and Bluetooth Low Energy. For more information about Classic Bluetooth see the
  Bluetooth  guide.
 For more information about Bluetooth Low Energy see the
  
 Bluetooth Low Energy  (BLE) guide. The Bluetooth APIs let applications: Scan for other Bluetooth devices (including BLE devices). Query the local Bluetooth adapter for paired Bluetooth devices. Establish RFCOMM channels/sockets. Connect to specified sockets on other devices. Transfer data to and from other devices. Communicate with BLE devices such as proximity sensors heart rate
     monitors fitness devices and so on. Act as a GATT client or a GATT server (BLE). 
 To perform Bluetooth communication using these APIs an application must
 declare the  BLUETOOTH  permission. Some
 additional functionality such as requesting device discovery
 also requires the  BLUETOOTH_ADMIN 
 permission.
  Note: 
 Not all Android-powered devices provide Bluetooth functionality.",,,,,,,
"<android.view.KeyEvent: char getMatch(char,int)>","Gets the first character in the character array that can be generated
 by the specified key code.  If there are multiple choices prefers
 the one that would be generated with the specified meta key modifier state.","chars char : The array of matching characters to consider. |||
metaState int : The preferred meta key modifier state. |||",char The matching associated character or 0 if none. |||,1,"Object used to report key and button events.
  
 Each key press is described by a sequence of key events.  A key press
 starts with a key event with  ACTION_DOWN .  If the key is held
 sufficiently long that it repeats then the initial down is followed
 additional key events with  ACTION_DOWN  and a non-zero value for
  getRepeatCount() .  The last key event is a  ACTION_UP 
 for the key up.  If the key press is canceled the key up event will have the
  FLAG_CANCELED  flag set.
  
 Key events are generally accompanied by a key code ( getKeyCode() )
 scan code ( getScanCode() ) and meta state ( getMetaState() ).
 Key code constants are defined in this class.  Scan code constants are raw
 device-specific codes obtained from the OS and so are not generally meaningful
 to applications unless interpreted using the  KeyCharacterMap .
 Meta states describe the pressed state of key modifiers
 such as  META_SHIFT_ON  or  META_ALT_ON .
  
 Key codes typically correspond one-to-one with individual keys on an input device.
 Many keys and key combinations serve quite different functions on different
 input devices so care must be taken when interpreting them.  Always use the
  KeyCharacterMap  associated with the input device when mapping keys
 to characters.  Be aware that there may be multiple key input devices active
 at the same time and each will have its own key character map.
  
 As soft input methods can use multiple and inventive ways of inputting text
 there is no guarantee that any key press on a soft keyboard will generate a key
 event: this is left to the IME's discretion and in fact sending such events is
 discouraged.  You should never rely on receiving KeyEvents for any key on a soft
 input method.  In particular the default software keyboard will never send any
 key event to any application targetting Jelly Bean or later and will only send
 events for some presses of the delete and return keys to applications targetting
 Ice Cream Sandwich or earlier.  Be aware that other software input methods may
 never send key events regardless of the version.  Consider using editor actions
 like  EditorInfo.IME_ACTION_DONE  if you need
 specific interaction with the software keyboard as it gives more visibility to
 the user as to how your application will react to key presses.
  
 When interacting with an IME the framework may deliver key events
 with the special action  ACTION_MULTIPLE  that either specifies
 that single repeated key code or a sequence of characters to insert.
  
 In general the framework cannot guarantee that the key events it delivers
 to a view always constitute complete key sequences since some events may be dropped
 or modified by containing views before they are delivered.  The view implementation
 should be prepared to handle  FLAG_CANCELED  and should tolerate anomalous
 situations such as receiving a new  ACTION_DOWN  without first having
 received an  ACTION_UP  for the prior key press.
  
 Refer to  InputDevice  for more information about how different kinds of
 input devices and sources represent keys and buttons.",,,,,,,,
"<android.media.MediaScannerConnection: void scanFile(String,String)>","Requests the media scanner to scan a file.
 Success or failure of the scanning operation cannot be determined until MediaScannerConnectionClient#onScanCompleted(String Uri) is called.","path String : the path to the file to be scanned. |||
mimeType String : an optional mimeType for the file.
If mimeType is null then the mimeType will be inferred from the file extension. |||",void,1,"MediaScannerConnection provides a way for applications to pass a
 newly created or downloaded media file to the media scanner service.
 The media scanner service will read metadata from the file and add
 the file to the media content provider.
 The MediaScannerConnectionClient provides an interface for the
 media scanner service to return the Uri for a newly scanned file
 to the client of the MediaScannerConnection class.","The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",,,,,,,
<android.view.accessibility.AccessibilityManager: List getInstalledAccessibilityServiceList()>,Returns the AccessibilityServiceInfo s of the installed accessibility services.,,List < AccessibilityServiceInfo > An unmodifiable list with AccessibilityServiceInfo s. |||,14,"System level service that serves as an event dispatch for  AccessibilityEvent s
 and provides facilities for querying the accessibility state of the system.
 Accessibility events are generated when something notable happens in the user interface
 for example an  Activity  starts the focus or selection of a
  View  changes etc. Parties interested in handling accessibility
 events implement and register an accessibility service which extends
  AccessibilityService .",,,,,,,,
<android.widget.SearchView: void onActionViewExpanded()>,"Called when this view is expanded as an action view.
 See MenuItem#expandActionView() .",,void,14,"A widget that provides a user interface for the user to enter a search query and submit a request
 to a search provider. Shows a list of query suggestions or results if available and allows the
 user to pick a suggestion or result to launch into.

  
 When the SearchView is used in an ActionBar as an action view for a collapsible menu item it
 needs to be set to iconified by default using  setIconifiedByDefault(true) . This is the default so nothing needs to be done.
  
 If you want the search field to always be visible then call setIconifiedByDefault(false).","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.widget.AbsListView: void onFilterComplete(int)>,Notifies the end of a filtering operation.,count int : the number of values computed by the filter |||,void,1,"Base class that can be used to implement virtualized lists of items. A list does
 not have a spatial definition here. For instance subclasses of this class can
 display the content of the list in a grid in a carousel as stack etc.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
"<android.app.admin.DevicePolicyManager: void setPasswordMinimumLetters(ComponentName,int)>","Called by an application that is administering the device to set the minimum number of
 letters required in the password. After setting this the user will not be able to enter a
 new password that is not at least as restrictive as what has been set. Note that the current
 password will remain until the user has set a new one so the change does not take place
 immediately. To prompt the user for a new password use ACTION_SET_NEW_PASSWORD or ACTION_SET_NEW_PARENT_PROFILE_PASSWORD after setting this value. This constraint is
 only imposed if the administrator has also requested PASSWORD_QUALITY_COMPLEX with setPasswordQuality(ComponentName int) . If an app targeting SDK level Build.VERSION_CODES.R and above enforces this constraint without settings
 password quality to PASSWORD_QUALITY_COMPLEX first this method will throw IllegalStateException . The default value is 1. On devices not supporting PackageManager#FEATURE_SECURE_LOCK_SCREEN feature the
 password is always treated as empty. The calling device admin must have requested DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD to be able to call this method; if it has
 not a security exception will be thrown. This method can be called on the DevicePolicyManager instance returned by getParentProfileInstance(android.content.ComponentName) in order to set restrictions on the parent
 profile.","admin ComponentName : Which DeviceAdminReceiver this request is associated with.
This value cannot be null . |||
length int : The new desired minimum number of letters required in the password. A value of
0 means there is no restriction. |||",void,11,"Public interface for managing policies enforced on a device. Most clients of this class must be
 registered with the system as a  device
 administrator . Additionally a device administrator may be registered as either a profile or
 device owner. A given method is accessible to all device administrators unless the documentation
 for that method specifies that it is restricted to either device or profile owners. Any
 application calling an api may only pass as an argument a device administrator component it
 owns. Otherwise a  SecurityException  will be thrown.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
"<android.content.ContextWrapper: void removeStickyBroadcastAsUser(Intent,UserHandle)>","This method is deprecated. Sticky broadcasts should not be used.  They provide no security (anyone
 can access them) no protection (anyone can modify them) and many other problems.
 The recommended pattern is to use a non-sticky broadcast to report that something has changed with another mechanism for apps to retrieve the current value whenever
 desired. Version of removeStickyBroadcast(android.content.Intent) that allows you to specify the
 user the broadcast will be sent to.  This is not available to applications
 that are not pre-installed on the system image. You must hold the Manifest.permission.BROADCAST_STICKY permission in order to use this API.  If you do not hold that
 permission SecurityException will be thrown. Requires android.Manifest.permission.INTERACT_ACROSS_USERS and Manifest.permission.BROADCAST_STICKY","intent Intent : The Intent that was previously broadcast. |||
user UserHandle : UserHandle to remove the sticky broadcast from. |||",void,17,"Proxying implementation of Context that simply delegates all of its calls to
 another Context.  Can be subclassed to modify behavior without changing
 the original Context.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
"<android.accounts.AccountManager: AccountManagerFuture updateCredentials(Account,String,Bundle,Activity,AccountManagerCallback,Handler)>","Asks the user to enter a new password for an account updating the
 saved credentials for the account.  Normally this happens automatically
 when the server rejects credentials during an auth token fetch but this
 can be invoked directly to ensure we have the correct credentials stored. This method may be called from any thread but the returned AccountManagerFuture must not be used on the main thread. NOTE: If targeting your app to work on API level 22 and before
 MANAGE_ACCOUNTS permission is needed for those platforms. See docs for
 this function in API level 22. Requires android.Manifest.permission.MANAGE_ACCOUNTS","account Account : The account to update credentials for |||
authTokenType String : The credentials entered must allow an auth token
of this type to be created (but no actual auth token is returned);
may be null |||
options Bundle : Authenticator-specific options for the request;
may be null or empty |||
activity Activity : The Activity context to use for launching a new
authenticator-defined sub-Activity to prompt the user to enter a
password; used only to call startActivity(); if null the prompt
will not be launched directly but the necessary Intent will be returned to the caller instead |||
callback AccountManagerCallback : Callback to invoke when the request completes
null for no callback |||
handler Handler : Handler identifying the callback thread
null for the main thread |||","AccountManagerFuture < Bundle > An AccountManagerFuture which resolves to a Bundle
     with these fields if an activity was supplied and the account
     credentials were successfully updated: KEY_ACCOUNT_NAME - the name of the account KEY_ACCOUNT_TYPE - the type of the account If no activity was specified the returned Bundle contains KEY_INTENT with the Intent needed to launch the
 password prompt. If an error occurred AccountManagerFuture#getResult() throws: AuthenticatorException if the authenticator failed to respond OperationCanceledException if the operation was canceled for
      any reason including the user canceling the password prompt IOException if the authenticator experienced an I/O problem
      verifying the password usually because of network trouble |||",5,"This class provides access to a centralized registry of the user's
 online accounts.  The user enters credentials (username and password) once
 per account granting applications access to online resources with
 ""one-click"" approval.

  Different online services have different ways of handling accounts and
 authentication so the account manager uses pluggable  authenticator 
 modules for different  account types .  Authenticators (which may be
 written by third parties) handle the actual details of validating account
 credentials and storing account information.  For example Google Facebook
 and Microsoft Exchange each have their own authenticator.

  Many servers support some notion of an  authentication token 
 which can be used to authenticate a request to the server without sending
 the user's actual password.  (Auth tokens are normally created with a
 separate request which does include the user's credentials.)  AccountManager
 can generate auth tokens for applications so the application doesn't need to
 handle passwords directly.  Auth tokens are normally reusable and cached by
 AccountManager but must be refreshed periodically.  It's the responsibility
 of applications to  invalidate  auth tokens when they stop working so
 the AccountManager knows it needs to regenerate them.

  Applications accessing a server normally go through these steps:

  Get an instance of AccountManager using  get(android.content.Context) .

  List the available accounts using  getAccountsByType(String)  or
  getAccountsByTypeAndFeatures(String String[] AccountManagerCallback  Handler) .  Normally applications will only
 be interested in accounts with one particular  type  which
 identifies the authenticator.  Account  features  are used to
 identify particular account subtypes and capabilities.  Both the account
 type and features are authenticator-specific strings and must be known by
 the application in coordination with its preferred authenticators.

  Select one or more of the available accounts possibly by asking the
 user for their preference.  If no suitable accounts are available
  addAccount(String String String[] Bundle Activity AccountManagerCallback  Handler)  may be called to prompt the user to create an
 account of the appropriate type.

  Important:  If the application is using a previously remembered
 account selection it must make sure the account is still in the list
 of accounts returned by  getAccountsByType(String) .  Requesting an auth token
 for an account no longer on the device results in an undefined failure.

  Request an auth token for the selected account(s) using one of the
  getAuthToken(Account String Bundle Activity AccountManagerCallback  Handler)  methods or related helpers.  Refer to the description
 of each method for exact usage and error handling details.

  Make the request using the auth token.  The form of the auth token
 the format of the request and the protocol used are all specific to the
 service you are accessing.  The application may use whatever network and
 protocol libraries are useful.

  Important:  If the request fails with an authentication error
 it could be that a cached auth token is stale and no longer honored by
 the server.  The application must call  invalidateAuthToken(String String)  to remove
 the token from the cache otherwise requests will continue failing!  After
 invalidating the auth token immediately go back to the ""Request an auth
 token"" step above.  If the process fails the second time then it can be
 treated as a ""genuine"" authentication failure and the user notified or other
 appropriate actions taken.
  Some AccountManager methods may need to interact with the user to
 prompt for credentials present options or ask the user to add an account.
 The caller may choose whether to allow AccountManager to directly launch the
 necessary user interface and wait for the user or to return an Intent which
 the caller may use to launch the interface or (in some cases) to install a
 notification which the user can select at any time to launch the interface.
 To have AccountManager launch the interface directly the caller must supply
 the current foreground  Activity  context.

  Many AccountManager methods take  AccountManagerCallback  and
  Handler  as parameters.  These methods return immediately and
 run asynchronously. If a callback is provided then
  AccountManagerCallback#run  will be invoked on the Handler's
 thread when the request completes successfully or not.
 The result is retrieved by calling  AccountManagerFuture#getResult() 
 on the  AccountManagerFuture  returned by the method (and also passed
 to the callback).  This method waits for the operation to complete (if
 necessary) and either returns the result or throws an exception if an error
 occurred during the operation.  To make the request synchronously call
  AccountManagerFuture#getResult()  immediately on receiving the
 future from the method; no callback need be supplied.

  Requests which may block including
  AccountManagerFuture#getResult()  must never be called on
 the application's main event thread.  These operations throw
  IllegalStateException  if they are used on the main thread.",,,,,,,,
"<android.app.Activity: void overridePendingTransition(int,int)>","Call immediately after one of the flavors of startActivity(android.content.Intent) or finish() to specify an explicit transition animation to
 perform next. As of Build.VERSION_CODES.JELLY_BEAN an alternative
 to using this with starting activities is to supply the desired animation
 information through a ActivityOptions bundle to startActivity(android.content.Intent android.os.Bundle) or a related function.  This allows
 you to specify a custom animation even when starting an activity from
 outside the context of the current top activity.","enterAnim int : A resource ID of the animation resource to use for
the incoming activity.  Use 0 for no animation. |||
exitAnim int : A resource ID of the animation resource to use for
the outgoing activity.  Use 0 for no animation. |||",void,5,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
"<android.app.Activity: void setFeatureDrawableAlpha(int,int)>",Convenience for calling Window.setFeatureDrawableAlpha(int int) .,"featureId int |||
alpha int |||",void,1,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.content.res.TypedArray: TypedValue peekValue(int)>,"Retrieve the raw TypedValue for the attribute at index and return a temporary object holding its data.  This object is only
 valid until the next call on to TypedArray .",index int : Index of attribute to retrieve. |||,"TypedValue Returns a TypedValue object if the attribute is defined
         containing its data; otherwise returns null.  (You will not
         receive a TypedValue whose type is TYPE_NULL.) |||",1,"Container for an array of values that were retrieved with
  Resources.Theme#obtainStyledAttributes(AttributeSet int[] int int) 
 or  Resources#obtainAttributes .  Be
 sure to call  recycle()  when done with them.

 The indices used to retrieve values from this structure correspond to
 the positions of the attributes given to obtainStyledAttributes.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
"<android.app.admin.DevicePolicyManager: void setPasswordMinimumLength(ComponentName,int)>","Called by an application that is administering the device to set the minimum allowed password
 length. After setting this the user will not be able to enter a new password that is not at
 least as restrictive as what has been set. Note that the current password will remain until
 the user has set a new one so the change does not take place immediately. To prompt the user
 for a new password use ACTION_SET_NEW_PASSWORD or ACTION_SET_NEW_PARENT_PROFILE_PASSWORD after setting this value. This constraint is
 only imposed if the administrator has also requested either PASSWORD_QUALITY_NUMERIC  PASSWORD_QUALITY_NUMERIC_COMPLEX  PASSWORD_QUALITY_ALPHABETIC  PASSWORD_QUALITY_ALPHANUMERIC or PASSWORD_QUALITY_COMPLEX with setPasswordQuality(ComponentName int) . If an app targeting SDK level Build.VERSION_CODES.R and above enforces this constraint without settings
 password quality to one of these values first this method will throw IllegalStateException . On devices not supporting PackageManager#FEATURE_SECURE_LOCK_SCREEN feature the
 password is always treated as empty. The calling device admin must have requested DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD to be able to call this method; if it has
 not a security exception will be thrown. This method can be called on the DevicePolicyManager instance returned by getParentProfileInstance(android.content.ComponentName) in order to set restrictions on the parent
 profile.","admin ComponentName : Which DeviceAdminReceiver this request is associated with.
This value cannot be null . |||
length int : The new desired minimum password length. A value of 0 means there is no
restriction. |||",void,8,"Public interface for managing policies enforced on a device. Most clients of this class must be
 registered with the system as a  device
 administrator . Additionally a device administrator may be registered as either a profile or
 device owner. A given method is accessible to all device administrators unless the documentation
 for that method specifies that it is restricted to either device or profile owners. Any
 application calling an api may only pass as an argument a device administrator component it
 owns. Otherwise a  SecurityException  will be thrown.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.webkit.WebView: void pauseTimers()>,"Pauses all layout parsing and JavaScript timers for all WebViews. This
 is a global requests not restricted to just this WebView. This can be
 useful if the application has been paused.",,void,1,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",,,,,,,
<android.app.DialogFragment: void onActivityCreated(Bundle)>,"Called when the fragment's activity has been created and this
 fragment's view hierarchy instantiated.  It can be used to do final
 initialization once these pieces are in place such as retrieving
 views or restoring state.  It is also useful for fragments that use setRetainInstance(boolean) to retain their instance
 as this callback tells the fragment when it is fully associated with
 the new activity instance.  This is called after onCreateView(LayoutInflater ViewGroup Bundle) and before onViewStateRestored(android.os.Bundle) . If you override this method you must call through to the
 superclass implementation.","savedInstanceState Bundle : If the fragment is being re-created from
a previous saved state this is the state.
This value may be null . |||",void,11,"Base class for Dialogs.

  Note: Activities provide a facility to manage the creation saving and
 restoring of dialogs. See  Activity#onCreateDialog(int) 
  Activity#onPrepareDialog(int Dialog) 
  Activity#showDialog(int)  and  Activity#dismissDialog(int) . If
 these methods are used  getOwnerActivity()  will return the Activity
 that managed this dialog.

  Often you will want to have a Dialog display on top of the current
 input method because there is no reason for it to accept text.  You can
 do this by setting the  WindowManager.LayoutParams#FLAG_ALT_FOCUSABLE_IM  window flag (assuming
 your Dialog takes input focus as it the default) with the following code:

  
 getWindow().setFlags(WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM
         WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.widget.TextView: void onEditorAction(int)>,"Called when an attached input method calls InputConnection#performEditorAction(int) for this text view.  The default implementation will call your action
 listener supplied to setOnEditorActionListener(TextView.OnEditorActionListener) or perform
 a standard operation for EditorInfo#IME_ACTION_NEXT  EditorInfo#IME_ACTION_PREVIOUS or EditorInfo#IME_ACTION_DONE . For backwards compatibility if no IME options have been set and the
 text view would not normally advance focus on enter then
 the NEXT and DONE actions received here will be turned into an enter
 key down/up pair to go through the normal key handling.",actionCode int : The code of the action being performed. |||,void,3,"A user interface element that displays text to the user.
 To provide user-editable text see  EditText .
  
 The following code sample shows a typical use with an XML layout
 and code to modify the contents of the text view:
  
 <LinearLayout
      xmlns:android=""http://schemas.android.com/apk/res/android""
      android:layout_width=""match_parent""
      android:layout_height=""match_parent"">
    <TextView
        android:id=""@+id/text_view_id""
        android:layout_height=""wrap_content""
        android:layout_width=""wrap_content""
        android:text=""@string/hello"" />
 </LinearLayout>
  
 This code sample demonstrates how to modify the contents of the text view
 defined in the previous XML layout:
  
 public class MainActivity extends Activity {

    protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_main);
         final TextView helloTextView = (TextView) findViewById(R.id.text_view_id);
         helloTextView.setText(R.string.user_greeting);
     }
 }
  
 To customize the appearance of TextView see  Styles and Themes .
  XML attributes 
 See  TextView Attributes 
  View Attributes","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.database.DataSetObservable: void notifyInvalidated()>,"Invokes DataSetObserver#onInvalidated on each observer.
 Called when the data set is no longer valid and cannot be queried again
 such as when the data set has been closed.",,void,1,"A specialization of  Observable  for  DataSetObserver 
 that provides methods for sending notifications to a list of
  DataSetObserver  objects.","If you need to manage data in a private database use the  android.database.sqlite  classes. These classes are used to manage the  Cursor  object returned from a content provider query. Databases
 are usually created and opened with  openOrCreateDatabase(String int SQLiteDatabase.CursorFactory) 
 To make requests through
 content providers you can use the  content.ContentResolver  class.
  All databases are stored on the device in  /data/data/<package_name>/databases",,,,,,,
"<android.content.res.Resources: void parseBundleExtras(XmlResourceParser,Bundle)>","Parse a series of <extra> tags from
 an XML file.  You call this when you are at the parent tag of the
 extra tags and it will return once all of the child tags have been parsed.
 This will call parseBundleExtra(String AttributeSet Bundle) for each extra tag encountered.","parser XmlResourceParser : The parser from which to retrieve the extras. |||
outBundle Bundle : A Bundle in which to place all parsed extras. |||",void,3,"Class for accessing an application's resources.  This sits on top of the
 asset manager of the application (accessible through  getAssets() ) and
 provides a high-level API for getting typed data from the assets.

  The Android resource system keeps track of all non-code assets associated with an
 application. You can use this class to access your application's resources. You can generally
 acquire the  Resources  instance associated with your application
 with  getResources() . The Android SDK tools compile your application's resources into the application binary
 at build time.  To use a resource you must install it correctly in the source tree (inside
 your project's  res/  directory) and build your application.  As part of the build
 process the SDK tools generate symbols for each resource which you can use in your application
 code to access the resources. Using application resources makes it easy to update various characteristics of your
 application without modifying code and—by providing sets of alternative
 resources—enables you to optimize your application for a variety of device configurations
 (such as for different languages and screen sizes). This is an important aspect of developing
 Android applications that are compatible on different types of devices. For more information about using resources see the documentation about  Application Resources .","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
"<android.accounts.AccountManager: String peekAuthToken(Account,String)>","Gets an auth token from the AccountManager's cache.  If no auth
 token is cached for this account null will be returned -- a new
 auth token will not be generated and the server will not be contacted.
 Intended for use by the authenticator not directly by applications. It is safe to call this method from the main thread. This method requires the caller to have a signature match with the
 authenticator that manages the specified account. NOTE: If targeting your app to work on API level 22 and before
 AUTHENTICATE_ACCOUNTS permission and same UID as account's authenticator
 is needed for those platforms. See docs for this function in API level 22. Requires android.Manifest.permission.AUTHENTICATE_ACCOUNTS","account Account : The account for which an auth token is to be fetched. Cannot be null . |||
authTokenType String : The type of auth token to fetch. Cannot be null . |||","String The cached auth token for this account and type or null if
     no auth token is cached the account does not exist or the user is locked |||",5,"This class provides access to a centralized registry of the user's
 online accounts.  The user enters credentials (username and password) once
 per account granting applications access to online resources with
 ""one-click"" approval.

  Different online services have different ways of handling accounts and
 authentication so the account manager uses pluggable  authenticator 
 modules for different  account types .  Authenticators (which may be
 written by third parties) handle the actual details of validating account
 credentials and storing account information.  For example Google Facebook
 and Microsoft Exchange each have their own authenticator.

  Many servers support some notion of an  authentication token 
 which can be used to authenticate a request to the server without sending
 the user's actual password.  (Auth tokens are normally created with a
 separate request which does include the user's credentials.)  AccountManager
 can generate auth tokens for applications so the application doesn't need to
 handle passwords directly.  Auth tokens are normally reusable and cached by
 AccountManager but must be refreshed periodically.  It's the responsibility
 of applications to  invalidate  auth tokens when they stop working so
 the AccountManager knows it needs to regenerate them.

  Applications accessing a server normally go through these steps:

  Get an instance of AccountManager using  get(android.content.Context) .

  List the available accounts using  getAccountsByType(String)  or
  getAccountsByTypeAndFeatures(String String[] AccountManagerCallback  Handler) .  Normally applications will only
 be interested in accounts with one particular  type  which
 identifies the authenticator.  Account  features  are used to
 identify particular account subtypes and capabilities.  Both the account
 type and features are authenticator-specific strings and must be known by
 the application in coordination with its preferred authenticators.

  Select one or more of the available accounts possibly by asking the
 user for their preference.  If no suitable accounts are available
  addAccount(String String String[] Bundle Activity AccountManagerCallback  Handler)  may be called to prompt the user to create an
 account of the appropriate type.

  Important:  If the application is using a previously remembered
 account selection it must make sure the account is still in the list
 of accounts returned by  getAccountsByType(String) .  Requesting an auth token
 for an account no longer on the device results in an undefined failure.

  Request an auth token for the selected account(s) using one of the
  getAuthToken(Account String Bundle Activity AccountManagerCallback  Handler)  methods or related helpers.  Refer to the description
 of each method for exact usage and error handling details.

  Make the request using the auth token.  The form of the auth token
 the format of the request and the protocol used are all specific to the
 service you are accessing.  The application may use whatever network and
 protocol libraries are useful.

  Important:  If the request fails with an authentication error
 it could be that a cached auth token is stale and no longer honored by
 the server.  The application must call  invalidateAuthToken(String String)  to remove
 the token from the cache otherwise requests will continue failing!  After
 invalidating the auth token immediately go back to the ""Request an auth
 token"" step above.  If the process fails the second time then it can be
 treated as a ""genuine"" authentication failure and the user notified or other
 appropriate actions taken.
  Some AccountManager methods may need to interact with the user to
 prompt for credentials present options or ask the user to add an account.
 The caller may choose whether to allow AccountManager to directly launch the
 necessary user interface and wait for the user or to return an Intent which
 the caller may use to launch the interface or (in some cases) to install a
 notification which the user can select at any time to launch the interface.
 To have AccountManager launch the interface directly the caller must supply
 the current foreground  Activity  context.

  Many AccountManager methods take  AccountManagerCallback  and
  Handler  as parameters.  These methods return immediately and
 run asynchronously. If a callback is provided then
  AccountManagerCallback#run  will be invoked on the Handler's
 thread when the request completes successfully or not.
 The result is retrieved by calling  AccountManagerFuture#getResult() 
 on the  AccountManagerFuture  returned by the method (and also passed
 to the callback).  This method waits for the operation to complete (if
 necessary) and either returns the result or throws an exception if an error
 occurred during the operation.  To make the request synchronously call
  AccountManagerFuture#getResult()  immediately on receiving the
 future from the method; no callback need be supplied.

  Requests which may block including
  AccountManagerFuture#getResult()  must never be called on
 the application's main event thread.  These operations throw
  IllegalStateException  if they are used on the main thread.",,,,,,,,
"<android.content.ContentResolver: OutputStream openOutputStream(Uri,String)>","Open a stream on to the content associated with a content URI.  If there
 is no data associated with the URI FileNotFoundException is thrown. content ( SCHEME_CONTENT ) 
file ( SCHEME_FILE ) 
See openAssetFileDescriptor(android.net.Uri java.lang.String) for more information
 on these schemes.","uri Uri : The desired URI.
This value cannot be null . |||
mode String : May be ""w"" ""wa"" ""rw"" or ""rwt"".
This value cannot be null . |||",OutputStream an OutputStream or null if the provider recently crashed. |||,3,This class provides applications access to the content model.,"Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
"<android.view.inputmethod.InputMethodManager: void hideSoftInputFromInputMethod(IBinder,int)>","This method was deprecated
      in API level 28. Use InputMethodService#requestHideSelf(int) instead. This method was
 intended for IME developers who should be accessing APIs through the service. APIs in this
 class are intended for app developers interacting with the IME. Close/hide the input method's soft input area so the user no longer
 sees it or can interact with it.  This can only be called
 from the currently active input method as validated by the given token.","token IBinder : Supplies the identifying token given to an input method
when it was started which allows it to perform this operation on
itself. |||
flags int : Provides additional operating flags.  Currently may be
0 or have the HIDE_IMPLICIT_ONLY  HIDE_NOT_ALWAYS bit set. |||",void,3,"Central system API to the overall input method framework (IMF) architecture
 which arbitrates interaction between applications and the current input method.

  Topics covered here:
  Architecture Overview Applications Input Methods Security Architecture Overview There are three primary parties involved in the input method
 framework (IMF) architecture:  The  input method manager  as expressed by this class
 is the central point of the system that manages interaction between all
 other parts.  It is expressed as the client-side API here which exists
 in each application context and communicates with a global system service
 that manages the interaction across all processes.
   An  input method (IME)  implements a particular
 interaction model allowing the user to generate text.  The system binds
 to the current input method that is in use causing it to be created and run
 and tells it when to hide and show its UI.  Only one IME is running at a time.
   Multiple  client applications  arbitrate with the input
 method manager for input focus and control over the state of the IME.  Only
 one such client is ever active (working with the IME) at a time.
  Applications In most cases applications that are using the standard
  TextView  or its subclasses will have little they need
 to do to work well with soft input methods.  The main things you need to
 be aware of are:  Properly set the  R.attr.inputType  in your editable
 text views so that the input method will have enough context to help the
 user in entering text into them.
   Deal well with losing screen space when the input method is
 displayed.  Ideally an application should handle its window being resized
 smaller but it can rely on the system performing panning of the window
 if needed.  You should set the  R.attr.windowSoftInputMode 
 attribute on your activity or the corresponding values on windows you
 create to help the system determine whether to pan or resize (it will
 try to determine this automatically but may get it wrong).
   You can also control the preferred soft input state (open closed etc)
 for your window using the same  R.attr.windowSoftInputMode 
 attribute.
  More finer-grained control is available through the APIs here to directly
 interact with the IMF and its IME -- either showing or hiding the input
 area letting the user pick an input method etc. For the rare people amongst us writing their own text editors you
 will need to implement  View.onCreateInputConnection(EditorInfo) 
 to return a new instance of your own  InputConnection  interface
 allowing the IME to interact with your editor. Input Methods An input method (IME) is implemented
 as a  Service  typically deriving from
  InputMethodService .  It must provide
 the core  InputMethod  interface though this is normally handled by
  InputMethodService  and implementors will
 only need to deal with the higher-level API there. InputMethodService Security There are a lot of security issues associated with input methods
 since they essentially have freedom to completely drive the UI and monitor
 everything the user enters.  The Android input method framework also allows
 arbitrary third party IMEs so care must be taken to restrict their
 selection and interactions. Here are some key points about the security architecture behind the
 IMF: Only the system is allowed to directly access an IME's
  InputMethod  interface via the
  Manifest.permission.BIND_INPUT_METHOD  permission.  This is
 enforced in the system by not binding to an input method service that does
 not require this permission so the system can guarantee no other untrusted
 clients are accessing the current input method outside of its control. There may be many client processes of the IMF but only one may
 be active at a time.  The inactive clients can not interact with key
 parts of the IMF through the mechanisms described below. Clients of an input method are only given access to its
  InputMethodSession  interface.  One instance of this interface is
 created for each client and only calls from the session associated with
 the active client will be processed by the current IME.  This is enforced
 by  AbstractInputMethodService  for normal
 IMEs but must be explicitly handled by an IME that is customizing the
 raw  InputMethodSession  implementation. Only the active client's  InputConnection  will accept
 operations.  The IMF tells each client process whether it is active and
 the framework enforces that in inactive processes calls on to the current
 InputConnection will be ignored.  This ensures that the current IME can
 only deliver events and text edits to the UI that the user sees as
 being in focus. An IME can never interact with an  InputConnection  while
 the screen is off.  This is enforced by making all clients inactive while
 the screen is off and prevents bad IMEs from driving the UI when the user
 can not be aware of its behavior. A client application can ask that the system let the user pick a
 new IME but can not programmatically switch to one itself.  This avoids
 malicious applications from switching the user to their own IME which
 remains running when the user navigates away to another application.  An
 IME on the other hand  is  allowed to programmatically switch
 the system to another IME since it already has full control of user
 input. The user must explicitly enable a new IME in settings before
 they can switch to it to confirm with the system that they know about it
 and want to make it available for use. PackageManager#FEATURE_INPUT_METHODS PackageManager.hasSystemFeature(String)",,,,,,,,
<android.database.sqlite.SQLiteClosable: void releaseReferenceFromContainer()>,"This method was deprecated
      in API level 16. Do not use. Releases a reference to the object that was owned by the container of the object
 closing the object if the last reference was released.",,void,1,"An object created from a SQLiteDatabase that can be closed.

 This class implements a primitive reference counting scheme for database objects.","If you need to manage data in a private database use the  android.database.sqlite  classes. These classes are used to manage the  Cursor  object returned from a content provider query. Databases
 are usually created and opened with  openOrCreateDatabase(String int SQLiteDatabase.CursorFactory) 
 To make requests through
 content providers you can use the  content.ContentResolver  class.
  All databases are stored on the device in  /data/data/<package_name>/databases",,,,,,,
"<android.media.MediaPlayer: void setWakeMode(Context,int)>","Set the low-level power management behavior for this MediaPlayer.  This
 can be used when the MediaPlayer is not playing through a SurfaceHolder
 set with setDisplay(android.view.SurfaceHolder) and thus can use the
 high-level setScreenOnWhilePlaying(boolean) feature. This function has the MediaPlayer access the low-level power manager
 service to control the device's power usage while playing is occurring.
 The parameter is a combination of PowerManager wake flags.
 Use of this method requires Manifest.permission.WAKE_LOCK permission.
 By default no attempt is made to keep the device awake during playback.","context Context : the Context to use |||
mode int : the power/wake mode to set |||",void,1,"MediaPlayer class can be used to control playback
 of audio/video files and streams. An example on how to use the methods in
 this class can be found in  VideoView .

  Topics covered here are:
  State Diagram Valid and Invalid States Permissions Register informational and error callbacks","The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",,,,,,,
<android.view.View: void draw(Canvas)>,"Manually render this view (and all of its children) to the given Canvas.
 The view must have already done a full layout before this function is
 called.  When implementing a view implement onDraw(android.graphics.Canvas) instead of overriding this method.
 If you do need to override this method call the superclass version. If you override this method you must call through to the
 superclass implementation.",canvas Canvas : The Canvas to which the View is rendered. |||,void,1,"This class represents the basic building block for user interface components. A View
 occupies a rectangular area on the screen and is responsible for drawing and
 event handling. View is the base class for  widgets  which are
 used to create interactive UI components (buttons text fields etc.). The
  ViewGroup  subclass is the base class for  layouts  which
 are invisible containers that hold other Views (or other ViewGroups) and define
 their layout properties.",,,,,,,,
<android.webkit.WebViewFragment: void onDestroyView()>,"Called when the WebView has been detached from the fragment.
 The WebView is no longer available after this time.",,void,11,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",,,,,,,
<android.database.MergeCursor: void close()>,"Closes the Cursor releasing all of its resources and making it completely invalid.
 Unlike deactivate() a call to requery() will not make the Cursor valid
 again.",,void,1,"A convenience class that lets you present an array of Cursors as a single linear Cursor.
 The schema of the cursors presented is entirely up to the creator of the MergeCursor and
 may be different if that is desired. Calls to getColumns getColumnIndex etc will return the
 value for the row that the MergeCursor is currently pointing at.","If you need to manage data in a private database use the  android.database.sqlite  classes. These classes are used to manage the  Cursor  object returned from a content provider query. Databases
 are usually created and opened with  openOrCreateDatabase(String int SQLiteDatabase.CursorFactory) 
 To make requests through
 content providers you can use the  content.ContentResolver  class.
  All databases are stored on the device in  /data/data/<package_name>/databases",,,,,,,
"<android.test.TouchUtils: void dragViewToTop(ActivityInstrumentationTestCase,View,int)>","This method was deprecated
      in API level 15. ActivityInstrumentationTestCase is deprecated in favor of ActivityInstrumentationTestCase2 which provides more options for
 configuring the Activity under test Simulate touching the center of a view and dragging to the top of the screen.","test ActivityInstrumentationTestCase : The test case that is being run |||
v View : The view that should be dragged |||
stepCount int : How many move steps to include in the drag |||",void,1,"Reusable methods for generating touch events. These methods can be used with
 InstrumentationTestCase or ActivityInstrumentationTestCase2 to simulate user interaction with
 the application through a touch screen.",,,,,,,,
<android.app.Dialog: void setTitle(int)>,"Set the title text for this dialog's window. The text is retrieved
 from the resources with the supplied identifier.",titleId int : the title's text resource identifier |||,void,1,"Base class for Dialogs.

  Note: Activities provide a facility to manage the creation saving and
 restoring of dialogs. See  Activity#onCreateDialog(int) 
  Activity#onPrepareDialog(int Dialog) 
  Activity#showDialog(int)  and  Activity#dismissDialog(int) . If
 these methods are used  getOwnerActivity()  will return the Activity
 that managed this dialog.

  Often you will want to have a Dialog display on top of the current
 input method because there is no reason for it to accept text.  You can
 do this by setting the  WindowManager.LayoutParams#FLAG_ALT_FOCUSABLE_IM  window flag (assuming
 your Dialog takes input focus as it the default) with the following code:

  
 getWindow().setFlags(WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM
         WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.appwidget.AppWidgetManager: AppWidgetProviderInfo getAppWidgetInfo(int)>,Get the available info about the AppWidget.,appWidgetId int |||,"AppWidgetProviderInfo A appWidgetId.  If the appWidgetId has not been bound to a provider yet or
 you don't have access to that appWidgetId null is returned. |||",3,"Updates AppWidget state; gets information about installed AppWidget providers and other
 AppWidget related state.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.appwidget.AppWidgetManager: Bundle getAppWidgetOptions(int)>,"Get the extras associated with a given widget instance. The extras can be used to embed additional information about this widget to be accessed
 by the associated widget's AppWidgetProvider.",appWidgetId int : The AppWidget instances for which to set the RemoteViews. |||,Bundle The options associated with the given widget instance. |||,16,"Updates AppWidget state; gets information about installed AppWidget providers and other
 AppWidget related state.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
"<android.telephony.gsm.SmsManager: void sendDataMessage(String,String,short,byte,PendingIntent,PendingIntent)>","This method was deprecated
      in API level 4. Use android.telephony.SmsManager. Send a data based SMS to a specific application port.","destinationAddress String : the address to send the message to |||
scAddress String : is the service center address or null to use
the current default SMSC |||
destinationPort short : the port to deliver the message to |||
data byte : the body of the message to send |||
sentIntent PendingIntent : if not NULL this PendingIntent is
broadcast when the message is sucessfully sent or failed.
The result code will be Activity.RESULT_OK for success
or one of these errors: RESULT_ERROR_GENERIC_FAILURE RESULT_ERROR_RADIO_OFF RESULT_ERROR_NULL_PDU .
The per-application based SMS control checks sentIntent. If sentIntent
is NULL the caller will be checked against all unknown applicaitons
which cause smaller number of SMS to be sent in checking period. |||
deliveryIntent PendingIntent : if not NULL this PendingIntent is
broadcast when the message is delivered to the recipient.  The
raw pdu of the status report is in the extended data (""pdu""). |||",void,1,"Manages SMS operations such as sending data text and pdu SMS messages.
 Get this object by calling the static method SmsManager.getDefault().",,,,,,,,
<android.service.wallpaper.WallpaperService: IBinder onBind(Intent)>,"Implement to return the implementation of the internal accessibility
 service interface.  Subclasses should not override.","intent Intent : The Intent that was used to bind to this service
as given to Context.bindService .  Note that any extras that were included with
the Intent at that point will not be seen here. |||","IBinder Return an IBinder through which clients can call on to the
         service. |||",7,"A wallpaper service is responsible for showing a live wallpaper behind
 applications that would like to sit on top of it.  This service object
 itself does very little -- its only purpose is to generate instances of
  Engine  as needed.  Implementing a wallpaper thus
 involves subclassing from this subclassing an Engine implementation
 and implementing  onCreateEngine()  to return a new instance of
 your engine.",,,,,,,,
<android.widget.ProgressBar: void setMax(int)>,Set the upper range of the progress bar max .,max int : the upper range of this progress bar |||,void,1,"A user interface element that indicates the progress of an operation.
 Progress bar supports two modes to represent progress: determinate and indeterminate. For
 a visual overview of the difference between determinate and indeterminate progress modes see
  
 Progress & activity .
 Display progress bars to a user in a non-interruptive way.
 Show the progress bar in your app's user interface or in a notification
 instead of within a dialog.
  Indeterminate Progress 
 Use indeterminate mode for the progress bar when you do not know how long an
 operation will take.
 Indeterminate mode is the default for progress bar and shows a cyclic animation without a
 specific amount of progress indicated.
 The following example shows an indeterminate progress bar:
  
 <ProgressBar
      android:id=""@+id/indeterminateBar""
      android:layout_width=""wrap_content""
      android:layout_height=""wrap_content""
      />
  Determinate Progress 
 Use determinate mode for the progress bar when you want to show that a specific quantity of
 progress has occurred.
 For example the percent remaining of a file being retrieved the amount records in
 a batch written to database or the percent remaining of an audio file that is playing.
  
 To indicate determinate progress you set the style of the progress bar to
  R.style.Widget_ProgressBar_Horizontal  and set the amount of progress.
 The following example shows a determinate progress bar that is 25% complete:
  
 <ProgressBar
      android:id=""@+id/determinateBar""
      style=""@android:style/Widget.ProgressBar.Horizontal""
      android:layout_width=""wrap_content""
      android:layout_height=""wrap_content""
      android:progress=""25""/>
  setProgress(int) incrementProgressBy(int) android:max Other progress bar styles provided by the system include: Widget.ProgressBar.Horizontal Widget.ProgressBar.Small Widget.ProgressBar.Large Widget.ProgressBar.Inverse Widget.ProgressBar.Small.Inverse Widget.ProgressBar.Large.Inverse The ""inverse"" styles provide an inverse color scheme for the spinner which may be necessary
 if your application uses a light colored theme (a white background). XML attributes 
 See  ProgressBar Attributes 
  View Attributes","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.content.res.TypedArray: Drawable getDrawable(int)>,"Retrieve the Drawable for the attribute at index . This method will throw an exception if the attribute is defined but is
 not a color or drawable resource.",index int : Index of attribute to retrieve. |||,Drawable Drawable for the attribute or null if not defined. |||,1,"Container for an array of values that were retrieved with
  Resources.Theme#obtainStyledAttributes(AttributeSet int[] int int) 
 or  Resources#obtainAttributes .  Be
 sure to call  recycle()  when done with them.

 The indices used to retrieve values from this structure correspond to
 the positions of the attributes given to obtainStyledAttributes.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
"<android.media.AudioManager: void adjustSuggestedStreamVolume(int,int,int)>","Adjusts the volume of the most relevant stream or the given fallback
 stream. This method should only be used by applications that replace the
 platform-wide management of audio settings or the main telephony
 application. This method has no effect if the device implements a fixed volume policy
 as indicated by isVolumeFixed() .","direction int : The direction to adjust the volume. One of ADJUST_LOWER  ADJUST_RAISE  ADJUST_SAME  ADJUST_MUTE  ADJUST_UNMUTE or ADJUST_TOGGLE_MUTE . |||
suggestedStreamType int : The stream type that will be used if there
isn't a relevant stream. USE_DEFAULT_STREAM_TYPE is
valid here. |||
flags int : One or more flags. |||",void,1,AudioManager provides access to volume and ringer mode control.,"The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",,,,,,,
<android.media.Ringtone: void stop()>,Stops a playing ringtone.,,void,1,"Ringtone provides a quick method for playing a ringtone notification or
 other similar types of sounds.
  
 For ways of retrieving  Ringtone  objects or to show a ringtone
 picker see  RingtoneManager .","The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",,,,,,,
<android.widget.EditText: void setSelection(int)>,Convenience for Selection#setSelection(Spannable int) .,index int |||,void,1,"A user interface element for entering and modifying text.
 When you define an edit text widget you must specify the
  R.styleable.TextView_inputType 
 attribute. For example for plain text input set inputType to ""text"":
  
 <EditText
     android:id=""@+id/plain_text_input""
     android:layout_height=""wrap_content""
     android:layout_width=""match_parent""
     android:inputType=""text""/> 
 See the  Text Fields 
 guide for examples of other
  R.styleable.TextView_inputType  settings.
  You also can receive callbacks as a user changes text by
 adding a  TextWatcher  to the edit text.
 This is useful when you want to add auto-save functionality as changes are made
 or validate the format of user input for example.
 You add a text watcher using the  TextView#addTextChangedListener  method.
  
 This widget does not support auto-sizing text.
  XML attributes 
 See  EditText Attributes 
  TextView Attributes 
  View Attributes","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
"<android.content.ContextWrapper: void enforceUriPermission(Uri,String,String,int,int,int,String)>","Enforce both a Uri and normal permission.  This allows you to perform
 both enforcePermission(String int int String) and enforceUriPermission(Uri int int int String) in one
 call.","uri Uri : The Uri whose permission is to be checked or null to not
do this check.
This value may be null . |||
readPermission String : The permission that provides overall read access
or null to not do this check.
This value may be null . |||
writePermission String : The permission that provides overall write
access or null to not do this check.
This value may be null . |||
pid int : The process ID being checked against.  Must be > 0. |||
uid int : The user ID being checked against.  A uid of 0 is the root
user which will pass every permission check. |||
modeFlags int : The access modes to enforce.
Value is either 0 or a combination of Intent.FLAG_GRANT_READ_URI_PERMISSION and Intent.FLAG_GRANT_WRITE_URI_PERMISSION |||
message String : A message to include in the exception if it is thrown.
This value may be null . |||",void,1,"Proxying implementation of Context that simply delegates all of its calls to
 another Context.  Can be subclassed to modify behavior without changing
 the original Context.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.nfc.tech.NfcA: void connect()>,"Enable I/O operations to the tag from this TagTechnology object. May cause RF activity and may block. Must not be called
 from the main application thread. A blocked call will be canceled with IOException by calling close() from another thread. Only one TagTechnology object can be connected to a Tag at a time. Applications must call close() when I/O operations are complete. Requires the Manifest.permission.NFC permission.",,void,-1,"Provides access to NFC-A (ISO 14443-3A) properties and I/O operations on a  Tag .

  Acquire a  NfcA  object using  get(Tag) .
  The primary NFC-A I/O operation is  transceive(byte[]) . Applications must
 implement their own protocol stack on top of  transceive(byte[]) .

  Note:  Methods that perform I/O operations
 require the  Manifest.permission.NFC  permission.","These classes provide access to a tag technology's features which vary by the type
 of tag that is scanned. A scanned tag can support multiple technologies and you can find
 out what they are by calling  getTechList() . For more information on dealing with tag technologies and handling the ones that you care about see
  The Tag Dispatch System .
 The  TagTechnology  interface provides an overview of the
 supported technologies.",,,,,,,
<android.widget.PopupWindow: void showAsDropDown(View)>,"Display the content view in a popup window anchored to the bottom-left
 corner of the anchor view. If there is not enough room on screen to show
 the popup in its entirety this method tries to find a parent scroll
 view to scroll. If no parent scroll view can be scrolled the
 bottom-left corner of the popup is pinned at the top left corner of the
 anchor view.",anchor View : the view on which to pin the popup window |||,void,1,"This class represents a popup window that can be used to display an
 arbitrary view. The popup window is a floating container that appears on top
 of the current activity.
  Animation 
 On all versions of Android popup window enter and exit animations may be
 specified by calling  setAnimationStyle(int)  and passing the
 resource ID for an animation style that defines  windowEnterAnimation 
 and  windowExitAnimation . For example passing
  R.style.Animation_Dialog  will give a scale and alpha
 animation.
 
 A window animation style may also be specified in the popup window's style
 XML via the  popupAnimationStyle 
 attribute.
  
 Starting with API 23 more complex popup window enter and exit transitions
 may be specified by calling either  setEnterTransition(android.transition.Transition) 
 or  setExitTransition(android.transition.Transition)  and passing a   Transition .
 
 Popup enter and exit transitions may also be specified in the popup window's
 style XML via the  popupEnterTransition 
 and  popupExitTransition 
 attributes respectively.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.bluetooth.BluetoothDevice: String getName()>,"Get the friendly Bluetooth name of the remote device. The local adapter will automatically retrieve remote names when
 performing a device scan and will cache them. This method just returns
 the name for this device from the cache. Requires Manifest.permission.BLUETOOTH",,String the Bluetooth name or null if there was a problem. |||,5,"Represents a remote Bluetooth device. A  BluetoothDevice  lets you
 create a connection with the respective device or query information about
 it such as the name address class and bonding state.

  This class is really just a thin wrapper for a Bluetooth hardware
 address. Objects of this class are immutable. Operations on this class
 are performed on the remote Bluetooth hardware address using the
  BluetoothAdapter  that was used to create this  BluetoothDevice .

  To get a  BluetoothDevice  use
  BluetoothAdapter#getRemoteDevice(String)  to create one representing a device
 of a known MAC address (which you can get through device discovery with
  BluetoothAdapter ) or get one from the set of bonded devices
 returned by  BluetoothAdapter#getBondedDevices() . You can then open a
  BluetoothSocket  for communication with the remote device using
  createRfcommSocketToServiceRecord(java.util.UUID)  over Bluetooth BR/EDR or using
  createL2capChannel(int)  over Bluetooth LE.

  Note: 
 Requires the  Manifest.permission.BLUETOOTH  permission.","Provides classes that manage Bluetooth functionality such as scanning for
 devices connecting with devices and managing data transfer between devices.
 The Bluetooth API supports both ""Classic Bluetooth"" and Bluetooth Low Energy. For more information about Classic Bluetooth see the
  Bluetooth  guide.
 For more information about Bluetooth Low Energy see the
  
 Bluetooth Low Energy  (BLE) guide. The Bluetooth APIs let applications: Scan for other Bluetooth devices (including BLE devices). Query the local Bluetooth adapter for paired Bluetooth devices. Establish RFCOMM channels/sockets. Connect to specified sockets on other devices. Transfer data to and from other devices. Communicate with BLE devices such as proximity sensors heart rate
     monitors fitness devices and so on. Act as a GATT client or a GATT server (BLE). 
 To perform Bluetooth communication using these APIs an application must
 declare the  BLUETOOTH  permission. Some
 additional functionality such as requesting device discovery
 also requires the  BLUETOOTH_ADMIN 
 permission.
  Note: 
 Not all Android-powered devices provide Bluetooth functionality.",,,,,,,
"<android.view.inputmethod.InputMethodManager: void toggleSoftInput(int,int)>","This method toggles the input method window display.

 If the input window is already displayed it gets hidden.
 If not the input window will be displayed.","showFlags int : Provides additional operating flags.  May be
0 or have the SHOW_IMPLICIT  SHOW_FORCED bit set. |||
hideFlags int : Provides additional operating flags.  May be
0 or have the HIDE_IMPLICIT_ONLY  HIDE_NOT_ALWAYS bit set. |||",void,3,"Central system API to the overall input method framework (IMF) architecture
 which arbitrates interaction between applications and the current input method.

  Topics covered here:
  Architecture Overview Applications Input Methods Security Architecture Overview There are three primary parties involved in the input method
 framework (IMF) architecture:  The  input method manager  as expressed by this class
 is the central point of the system that manages interaction between all
 other parts.  It is expressed as the client-side API here which exists
 in each application context and communicates with a global system service
 that manages the interaction across all processes.
   An  input method (IME)  implements a particular
 interaction model allowing the user to generate text.  The system binds
 to the current input method that is in use causing it to be created and run
 and tells it when to hide and show its UI.  Only one IME is running at a time.
   Multiple  client applications  arbitrate with the input
 method manager for input focus and control over the state of the IME.  Only
 one such client is ever active (working with the IME) at a time.
  Applications In most cases applications that are using the standard
  TextView  or its subclasses will have little they need
 to do to work well with soft input methods.  The main things you need to
 be aware of are:  Properly set the  R.attr.inputType  in your editable
 text views so that the input method will have enough context to help the
 user in entering text into them.
   Deal well with losing screen space when the input method is
 displayed.  Ideally an application should handle its window being resized
 smaller but it can rely on the system performing panning of the window
 if needed.  You should set the  R.attr.windowSoftInputMode 
 attribute on your activity or the corresponding values on windows you
 create to help the system determine whether to pan or resize (it will
 try to determine this automatically but may get it wrong).
   You can also control the preferred soft input state (open closed etc)
 for your window using the same  R.attr.windowSoftInputMode 
 attribute.
  More finer-grained control is available through the APIs here to directly
 interact with the IMF and its IME -- either showing or hiding the input
 area letting the user pick an input method etc. For the rare people amongst us writing their own text editors you
 will need to implement  View.onCreateInputConnection(EditorInfo) 
 to return a new instance of your own  InputConnection  interface
 allowing the IME to interact with your editor. Input Methods An input method (IME) is implemented
 as a  Service  typically deriving from
  InputMethodService .  It must provide
 the core  InputMethod  interface though this is normally handled by
  InputMethodService  and implementors will
 only need to deal with the higher-level API there. InputMethodService Security There are a lot of security issues associated with input methods
 since they essentially have freedom to completely drive the UI and monitor
 everything the user enters.  The Android input method framework also allows
 arbitrary third party IMEs so care must be taken to restrict their
 selection and interactions. Here are some key points about the security architecture behind the
 IMF: Only the system is allowed to directly access an IME's
  InputMethod  interface via the
  Manifest.permission.BIND_INPUT_METHOD  permission.  This is
 enforced in the system by not binding to an input method service that does
 not require this permission so the system can guarantee no other untrusted
 clients are accessing the current input method outside of its control. There may be many client processes of the IMF but only one may
 be active at a time.  The inactive clients can not interact with key
 parts of the IMF through the mechanisms described below. Clients of an input method are only given access to its
  InputMethodSession  interface.  One instance of this interface is
 created for each client and only calls from the session associated with
 the active client will be processed by the current IME.  This is enforced
 by  AbstractInputMethodService  for normal
 IMEs but must be explicitly handled by an IME that is customizing the
 raw  InputMethodSession  implementation. Only the active client's  InputConnection  will accept
 operations.  The IMF tells each client process whether it is active and
 the framework enforces that in inactive processes calls on to the current
 InputConnection will be ignored.  This ensures that the current IME can
 only deliver events and text edits to the UI that the user sees as
 being in focus. An IME can never interact with an  InputConnection  while
 the screen is off.  This is enforced by making all clients inactive while
 the screen is off and prevents bad IMEs from driving the UI when the user
 can not be aware of its behavior. A client application can ask that the system let the user pick a
 new IME but can not programmatically switch to one itself.  This avoids
 malicious applications from switching the user to their own IME which
 remains running when the user navigates away to another application.  An
 IME on the other hand  is  allowed to programmatically switch
 the system to another IME since it already has full control of user
 input. The user must explicitly enable a new IME in settings before
 they can switch to it to confirm with the system that they know about it
 and want to make it available for use. PackageManager#FEATURE_INPUT_METHODS PackageManager.hasSystemFeature(String)",,,,,,,,
<android.app.admin.DevicePolicyManager: void wipeData(int)>,"Ask that all user data be wiped. If called as a secondary user the user will be removed and
 other users will remain unaffected. Calling from the primary user will cause the device to
 reboot erasing all device data - including all the secondary users and their data - while
 booting up. The calling device admin must have requested DeviceAdminInfo#USES_POLICY_WIPE_DATA to
 be able to call this method; if it has not a security exception will be thrown.

 If the caller is a profile owner of an organization-owned managed profile it may
 additionally call this method on the parent instance.
 Calling this method on the parent DevicePolicyManager instance would wipe the
 entire device while calling it on the current profile instance would relinquish the device
 for personal use removing the managed profile and all policies set by the profile owner.",flags int : Bit mask of additional options: currently supported flags are WIPE_EXTERNAL_STORAGE  WIPE_RESET_PROTECTION_DATA  WIPE_EUICC and WIPE_SILENTLY . |||,void,8,"Public interface for managing policies enforced on a device. Most clients of this class must be
 registered with the system as a  device
 administrator . Additionally a device administrator may be registered as either a profile or
 device owner. A given method is accessible to all device administrators unless the documentation
 for that method specifies that it is restricted to either device or profile owners. Any
 application calling an api may only pass as an argument a device administrator component it
 owns. Otherwise a  SecurityException  will be thrown.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.app.Dialog: void cancel()>,"Cancel the dialog.  This is essentially the same as calling dismiss() but it will
 also call your DialogInterface.OnCancelListener (if registered).",,void,1,"Base class for Dialogs.

  Note: Activities provide a facility to manage the creation saving and
 restoring of dialogs. See  Activity#onCreateDialog(int) 
  Activity#onPrepareDialog(int Dialog) 
  Activity#showDialog(int)  and  Activity#dismissDialog(int) . If
 these methods are used  getOwnerActivity()  will return the Activity
 that managed this dialog.

  Often you will want to have a Dialog display on top of the current
 input method because there is no reason for it to accept text.  You can
 do this by setting the  WindowManager.LayoutParams#FLAG_ALT_FOCUSABLE_IM  window flag (assuming
 your Dialog takes input focus as it the default) with the following code:

  
 getWindow().setFlags(WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM
         WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.content.ContextWrapper: Drawable peekWallpaper()>,This method is deprecated. Use WallpaperManager.peek() instead.,,Drawable |||,1,"Proxying implementation of Context that simply delegates all of its calls to
 another Context.  Can be subclassed to modify behavior without changing
 the original Context.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.speech.SpeechRecognizer: SpeechRecognizer createSpeechRecognizer(Context)>,"Factory method to create a new SpeechRecognizer . Please note that setRecognitionListener(android.speech.RecognitionListener) should be called before dispatching any
 command to the created SpeechRecognizer otherwise no notifications will be
 received.",context Context : in which to create SpeechRecognizer |||,SpeechRecognizer a new SpeechRecognizer |||,8,"This class provides access to the speech recognition service. This service allows access to the
 speech recognizer. Do not instantiate this class directly instead call
  SpeechRecognizer#createSpeechRecognizer(Context) . This class's methods must be
 invoked only from the main application thread.

  The implementation of this API is likely to stream audio to remote servers to perform speech
 recognition. As such this API is not intended to be used for continuous recognition which would
 consume a significant amount of battery and bandwidth.

  Please note that the application must have  Manifest.permission.RECORD_AUDIO 
 permission to use this class.",,,,,,,,
<android.widget.ArrayAdapter: void sort(Comparator)>,Sorts the content of this adapter using the specified comparator.,"comparator Comparator : The comparator used to sort the objects contained
in this adapter.
This value cannot be null . |||",void,3,"You can use this adapter to provide views for an  AdapterView 
 Returns a view for each object in a collection of data objects you
 provide and can be used with list-based user interface widgets such as
  ListView  or  Spinner .
  
 By default the array adapter creates a view by calling  Object#toString()  on each
 data object in the collection you provide and places the result in a TextView.
 You may also customize what type of view is used for the data object in the collection.
 To customize what type of view is used for the data object
 override  getView(int android.view.View android.view.ViewGroup) 
 and inflate a view resource.
 For a code example see
 the  
 CustomChoiceList  sample.
  
 For an example of using an array adapter with a ListView see the
  
 Adapter Views  guide.
  
 For an example of using an array adapter with a Spinner see the
  Spinners  guide.
  Note: 
 If you are considering using array adapter with a ListView consider using
  RecyclerView  instead.
 RecyclerView offers similar features with better performance and more flexibility than
 ListView provides.
 See the
  
 Recycler View  guide.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.media.AudioManager: void registerMediaButtonEventReceiver(ComponentName)>,"This method was deprecated
      in API level 21. Use MediaSession#setMediaButtonReceiver(PendingIntent) instead. Register a component to be the sole receiver of MEDIA_BUTTON intents.","eventReceiver ComponentName : identifier of a BroadcastReceiver that will receive the media button intent. This broadcast receiver must be declared
in the application manifest. The package of the component must match that of
the context you're registering from. |||",void,8,AudioManager provides access to volume and ringer mode control.,"The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",,,,,,,
"<android.net.sip.SipManager: void register(SipProfile,int,SipRegistrationListener)>","Manually registers the profile to the corresponding SIP provider for
 receiving calls. open(android.net.sip.SipProfile android.app.PendingIntent android.net.sip.SipRegistrationListener) is
 still needed to be called at least once in order for the SIP service to
 notify the caller with the PendingIntent when an incoming call is
 received.","localProfile SipProfile : the SIP profile to register with |||
expiryTime int : registration expiration time (in seconds) |||
listener SipRegistrationListener : to listen to the registration events |||",void,9,"Provides APIs for SIP tasks such as initiating SIP connections and provides access to related
 SIP services. This class is the starting point for any SIP actions. You can acquire an instance
 of it with  newInstance() . The APIs in this class allows you to: Create a  SipSession  to get ready for making calls or listen for incoming calls. See
  createSipSession()  and  getSessionFor() . Initiate and receive generic SIP calls or audio-only SIP calls. Generic SIP calls may
 be video audio or other and are initiated with  open() . Audio-only SIP calls
 should be handled with a  SipAudioCall  which you can acquire with  makeAudioCall()  and  takeAudioCall() . Register and unregister with a SIP service provider with
       register()  and  unregister() . Verify session connectivity with  isOpened()  and
       isRegistered() . Note:  Not all Android-powered devices support VOIP calls using
 SIP. You should always call  isVoipSupported()  to verify that the device supports VOIP calling and  isApiSupported()  to verify that the device supports
 the SIP APIs. Your application must also request the  Manifest.permission.INTERNET  and  Manifest.permission.USE_SIP 
 permissions.",,,,,,,,
"<android.net.SSLCertificateSocketFactory: Socket createSocket(InetAddress,int)>","Creates a socket and connects it to the specified port number
 at the specified address.  This socket is configured using
 the socket options established for this factory. If there is a security manager its checkConnect method is called with the host address and port as its arguments. This could result in a SecurityException. This method returns a socket that is not connected . Warning: Hostname verification is not performed
 with this method.  You MUST verify the server's identity after connecting
 the socket to avoid man-in-the-middle attacks.","addr InetAddress : the server host |||
port int : the server port |||",Socket the Socket |||,1,"SSLSocketFactory implementation with several extra features:

  Timeout specification for SSL handshake operations
  Hostname verification in most cases (see WARNINGs below)
  Optional SSL session caching with  SSLSessionCache Optionally bypass all SSL certificate checks
  createSocket() Socket#connect(java.net.SocketAddress int) The recommended way to verify the server's identity is to use
  HttpsURLConnection#getDefaultHostnameVerifier()  to get a
  HostnameVerifier  to verify the certificate hostname.

  Warning : Some methods on this class return connected sockets and some return
 unconnected sockets.  For the methods that return connected sockets setting
 connection- or handshake-related properties on those sockets will have no effect.

  On development devices ""setprop socket.relaxsslcheck yes"" bypasses all
 SSL certificate and hostname checks for testing purposes.  This setting
 requires root access.",,,,,,,,
"<android.text.TextUtils: CharSequence replace(CharSequence,String,CharSequence)>","Return a new CharSequence in which each of the source strings is
 replaced by the corresponding element of the destinations.","template CharSequence |||
sources String |||
destinations CharSequence |||",CharSequence |||,1,,"Provides classes used to render or track text and text spans on the screen. You can use these classes to design your own widgets that manage text
 to handle arbitrary text spans for changes or to handle drawing yourself
 for an existing widget. The Span… interfaces and classes are used to create or manage spans of
 text in a View item. You can use these to style the text or background or to
 listen for changes. If creating your own widget extend DynamicLayout to manages
 the actual wrapping and drawing of your text.",,,,,,,
"<android.widget.TextView: void setText(char,int,int)>","Sets the TextView to display the specified slice of the specified
 char array. You must promise that you will not change the contents
 of the array except for right before another call to setText()
 since the TextView has no way to know that the text
 has changed and that it needs to invalidate and re-layout.","text char : char array to be displayed |||
start int : start index in the char array |||
len int : length of char count after start |||",void,1,"A user interface element that displays text to the user.
 To provide user-editable text see  EditText .
  
 The following code sample shows a typical use with an XML layout
 and code to modify the contents of the text view:
  
 <LinearLayout
      xmlns:android=""http://schemas.android.com/apk/res/android""
      android:layout_width=""match_parent""
      android:layout_height=""match_parent"">
    <TextView
        android:id=""@+id/text_view_id""
        android:layout_height=""wrap_content""
        android:layout_width=""wrap_content""
        android:text=""@string/hello"" />
 </LinearLayout>
  
 This code sample demonstrates how to modify the contents of the text view
 defined in the previous XML layout:
  
 public class MainActivity extends Activity {

    protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_main);
         final TextView helloTextView = (TextView) findViewById(R.id.text_view_id);
         helloTextView.setText(R.string.user_greeting);
     }
 }
  
 To customize the appearance of TextView see  Styles and Themes .
  XML attributes 
 See  TextView Attributes 
  View Attributes","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.os.Bundle: char getCharArray(String)>,"Returns the value associated with the given key or null if
 no mapping of the desired type exists for the given key or a null
 value is explicitly associated with the key.","key String : a String or null
This value may be null . |||",char[] a char[] value or null |||,1,A mapping from String keys to various  Parcelable  values.,,,,,,,,
<android.widget.TextView: void setInputType(int)>,"Set the type of the content with a constant as defined for EditorInfo#inputType . This
 will take care of changing the key listener by calling setKeyListener(android.text.method.KeyListener) to match the given content type.  If the given content type is EditorInfo#TYPE_NULL then a soft keyboard will not be displayed for this text view.

 Note that the maximum number of displayed lines (see setMaxLines(int) ) will be
 modified if you change the EditorInfo#TYPE_TEXT_FLAG_MULTI_LINE flag of the input
 type. Related XML Attributes: android:inputType",type int |||,void,3,"A user interface element that displays text to the user.
 To provide user-editable text see  EditText .
  
 The following code sample shows a typical use with an XML layout
 and code to modify the contents of the text view:
  
 <LinearLayout
      xmlns:android=""http://schemas.android.com/apk/res/android""
      android:layout_width=""match_parent""
      android:layout_height=""match_parent"">
    <TextView
        android:id=""@+id/text_view_id""
        android:layout_height=""wrap_content""
        android:layout_width=""wrap_content""
        android:text=""@string/hello"" />
 </LinearLayout>
  
 This code sample demonstrates how to modify the contents of the text view
 defined in the previous XML layout:
  
 public class MainActivity extends Activity {

    protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_main);
         final TextView helloTextView = (TextView) findViewById(R.id.text_view_id);
         helloTextView.setText(R.string.user_greeting);
     }
 }
  
 To customize the appearance of TextView see  Styles and Themes .
  XML attributes 
 See  TextView Attributes 
  View Attributes","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.widget.VideoView: void setVideoPath(String)>,Sets video path.,path String : the path of the video. |||,void,1,"Displays a video file.  The VideoView class
 can load images from various sources (such as resources or content
 providers) takes care of computing its measurement from the video so that
 it can be used in any layout manager and provides various display options
 such as scaling and tinting. Note: VideoView does not retain its full state when going into the
 background.   In particular it does not restore the current play state
 play position selected tracks or any subtitle tracks added via
  addSubtitleSource() .  Applications should
 save and restore these on their own in
  Activity.onSaveInstanceState(Bundle)  and
  Activity.onRestoreInstanceState(Bundle) . 
 Also note that the audio session id (from  getAudioSessionId() ) may
 change from its previously returned value when the VideoView is restored.
  
 By default VideoView requests audio focus with  AudioManager#AUDIOFOCUS_GAIN . Use
  setAudioFocusRequest(int)  to change this behavior.
  
 The default  AudioAttributes  used during playback have a usage of
  AudioAttributes#USAGE_MEDIA  and a content type of
  AudioAttributes#CONTENT_TYPE_MOVIE  use  setAudioAttributes(android.media.AudioAttributes)  to
 modify them.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.net.ConnectivityManager: NetworkInfo getActiveNetworkInfo()>,"This method was deprecated
      in API level 29. See NetworkInfo . Returns details about the currently active default data network. When
 connected this network is the default route for outgoing connections.
 You should always check NetworkInfo#isConnected() before initiating
 network traffic. This may return null when there is no default
 network.
 Note that if the default network is a VPN this method will return the
 NetworkInfo for one of its underlying networks instead or null if the
 VPN agent did not specify any. Apps interested in learning about VPNs
 should use getNetworkInfo(android.net.Network) instead. Requires Manifest.permission.ACCESS_NETWORK_STATE",,"NetworkInfo a NetworkInfo object for the current default network
        or null if no default network is currently active |||",1,"Class that answers queries about the state of network connectivity. It also
 notifies applications when network connectivity changes.
  
 The primary responsibilities of this class are to:
  Monitor network connections (Wi-Fi GPRS UMTS etc.) Send broadcast intents when network connectivity changes Attempt to ""fail over"" to another network when connectivity to a network
 is lost Provide an API that allows applications to query the coarse-grained or fine-grained
 state of the available networks Provide an API that allows applications to request and select networks for their data
 traffic",,,,,,,,
<android.content.pm.ResolveInfo: CharSequence loadLabel(PackageManager)>,"Retrieve the current textual label associated with this resolution.  This
 will call back on the given PackageManager to load the label from
 the application.","pm PackageManager : A PackageManager from which the label can be loaded; usually
the PackageManager from which you originally retrieved this item. |||","CharSequence Returns a CharSequence containing the resolutions's label.  If the
 item does not have a label its name is returned. |||",1,"Information that is returned from resolving an intent
 against an IntentFilter. This partially corresponds to
 information collected from the AndroidManifest.xml's
 <intent> tags.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.content.ContextWrapper: int checkCallingOrSelfPermission(String)>,"Determine whether the calling process of an IPC or you have been
 granted a particular permission.  This is the same as checkCallingPermission(String) except it grants your own permissions
 if you are not currently processing an IPC.  Use with care!","permission String : The name of the permission being checked.
This value cannot be null . |||","int PackageManager#PERMISSION_GRANTED if the calling
 pid/uid is allowed that permission or PackageManager#PERMISSION_DENIED if it is not.

 Value is PackageManager.PERMISSION_GRANTED or PackageManager.PERMISSION_DENIED |||",1,"Proxying implementation of Context that simply delegates all of its calls to
 another Context.  Can be subclassed to modify behavior without changing
 the original Context.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
"<android.test.TouchUtils: void scrollToBottom(ActivityInstrumentationTestCase,ViewGroup)>","This method was deprecated
      in API level 15. ActivityInstrumentationTestCase is deprecated in favor of ActivityInstrumentationTestCase2 which provides more options for
 configuring the Activity under test Scroll a ViewGroup to the bottom by repeatedly calling dragQuarterScreenUp(android.test.InstrumentationTestCase android.app.Activity)","test ActivityInstrumentationTestCase : The test case that is being run |||
v ViewGroup : The ViewGroup that should be dragged |||",void,1,"Reusable methods for generating touch events. These methods can be used with
 InstrumentationTestCase or ActivityInstrumentationTestCase2 to simulate user interaction with
 the application through a touch screen.",,,,,,,,
"<android.hardware.usb.UsbInterface: void writeToParcel(Parcel,int)>",Flatten this object in to a Parcel.,"parcel Parcel : The Parcel in which the object should be written. |||
flags int : Additional flags about how the object should be written.
May be 0 or Parcelable.PARCELABLE_WRITE_RETURN_VALUE .
Value is either 0 or a combination of Parcelable.PARCELABLE_WRITE_RETURN_VALUE and android.os.Parcelable.PARCELABLE_ELIDE_DUPLICATES |||",void,12,"A class representing an interface on a  UsbDevice .
 USB devices can have one or more interfaces each one providing a different
 piece of functionality separate from the other interfaces.
 An interface will have one or more  UsbEndpoint s which are the
 channels by which the host transfers data with the device.","Provides support to communicate with USB hardware peripherals that are connected to
 Android-powered devices. For more information see the
  USB  guide. Use  UsbManager  to access the state of the USB and to
 communicate with connected hardware peripherals. Use  UsbDevice  to
 communicate with the hardware peripheral if the Android-powered device is acting as the USB host.
 Use  UsbAccessory  if the peripheral is acting as the USB host.",,,,,,,
<android.view.Display: int getHeight()>,"This method was deprecated
      in API level 15. Use WindowMetrics#getBounds() instead.",,int |||,1,"Provides information about the size and density of a logical display.
  
 The display area is described in two different ways.
  The application display area specifies the part of the display that may contain
 an application window excluding the system decorations.  The application display area may
 be smaller than the real display area because the system subtracts the space needed
 for decor elements such as the status bar.  Use the following methods to query the
 application display area:  getSize(Point)   getRectSize(Rect)  and  getMetrics(DisplayMetrics) . The real display area specifies the part of the display that contains content
 including the system decorations.  Even so the real display area may be smaller than the
 physical size of the display if the window manager is emulating a smaller display
 using (adb shell wm size).  Use the following methods to query the
 real display area:  getRealSize(Point)   getRealMetrics(DisplayMetrics) . 
 A logical display does not necessarily represent a particular physical display device
 such as the built-in screen or an external monitor.  The contents of a logical
 display may be presented on one or more physical displays according to the devices
 that are currently attached and whether mirroring has been enabled.",,,,,,,,
"<android.content.ContentResolver: AssetFileDescriptor openAssetFileDescriptor(Uri,String)>","Open a raw file descriptor to access data under a URI.  This
 interacts with the underlying ContentProvider#openAssetFile method of the provider associated with the given URI to retrieve any file stored there. content ( SCHEME_CONTENT ) 
android.resource ( SCHEME_ANDROID_RESOURCE ) 
file ( SCHEME_FILE ) 
A Uri object can be used to reference a resource in an APK file.  The
 Uri should be one of the following formats: android.resource://package_name/id_number package_name is your package name as listed in your AndroidManifest.xml.
 For example com.example.myapp id_number is the int form of the ID. The easiest way to construct this form is Uri uri = Uri.parse(""android.resource://com.example.myapp/"" + R.raw.my_resource""); 
android.resource://package_name/type/name package_name is your package name as listed in your AndroidManifest.xml.
 For example com.example.myapp type is the string form of the resource type.  For example raw or drawable . name is the string form of the resource name.  That is whatever the file
 name was in your res directory without the type extension.
 The easiest way to construct this form is Uri uri = Uri.parse(""android.resource://com.example.myapp/raw/my_resource""); 
Note that if this function is called for read-only input (mode is ""r"")
 on a content: URI it will instead call openTypedAssetFileDescriptor(Uri String Bundle) for you with a MIME type of ""*/*"".  This allows such callers to benefit
 from any built-in data conversion that a provider implements.","uri Uri : The desired URI to open.
This value cannot be null . |||
mode String : The file mode to use as per ContentProvider#openAssetFile .
This value cannot be null . |||","AssetFileDescriptor Returns a new ParcelFileDescriptor pointing to the file or null if the
 provider recently crashed. You own this descriptor and are responsible for closing it
 when done. |||",3,This class provides applications access to the content model.,"Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.widget.TabWidget: void setLeftStripDrawable(int)>,"Sets the drawable to use as the left part of the strip below the tab
 indicators. Related XML Attributes: android:tabStripLeft","resId int : the resource identifier of the drawable to use as the left
strip drawable |||",void,8,"Displays a list of tab labels representing each page in the parent's tab
 collection.
  
 The container object for this widget is  TabHost .
 When the user selects a tab this object sends a message to the parent
 container TabHost to tell it to switch the displayed page. You typically
 won't use many methods directly on this object. The container TabHost is
 used to add labels add the callback handler and manage callbacks. You
 might call this object to iterate the list of tabs or to tweak the layout
 of the tab list but most methods should be called on the containing TabHost
 object.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.os.Parcel: void writeSparseArray(SparseArray)>,"Flatten a generic SparseArray into the parcel at the current
 dataPosition() growing dataCapacity() if needed.  The SparseArray
 values are written using writeValue(Object) and must follow the
 specification there.",val SparseArray : This value may be null . |||,void,1,"Container for a message (data and object references) that can
 be sent through an IBinder.  A Parcel can contain both flattened data
 that will be unflattened on the other side of the IPC (using the various
 methods here for writing specific types or the general
  Parcelable  interface) and references to live  IBinder 
 objects that will result in the other side receiving a proxy IBinder
 connected with the original IBinder in the Parcel.

  Parcel is  not  a general-purpose
 serialization mechanism.  This class (and the corresponding
  Parcelable  API for placing arbitrary objects into a Parcel) is
 designed as a high-performance IPC transport.  As such it is not
 appropriate to place any Parcel data in to persistent storage: changes
 in the underlying implementation of any of the data in the Parcel can
 render older data unreadable. The bulk of the Parcel API revolves around reading and writing data
 of various types.  There are six major classes of such functions available. Primitives The most basic data functions are for writing and reading primitive
 data types:  writeByte(byte)   readByte()   writeDouble(double) 
  readDouble()   writeFloat(float)   readFloat()   writeInt(int) 
  readInt()   writeLong(long)   readLong() 
  writeString(String)   readString() .  Most other
 data operations are built on top of these.  The given data is written and
 read using the endianess of the host CPU. Primitive Arrays There are a variety of methods for reading and writing raw arrays
 of primitive objects which generally result in writing a 4-byte length
 followed by the primitive data items.  The methods for reading can either
 read the data into an existing array or create and return a new array.
 These available types are: writeBooleanArray(boolean[]) 
  readBooleanArray(boolean[])   createBooleanArray() writeByteArray(byte[]) 
  writeByteArray(byte[] int int)   readByteArray(byte[]) 
  createByteArray() writeCharArray(char[])   readCharArray(char[]) 
  createCharArray() writeDoubleArray(double[])   readDoubleArray(double[]) 
  createDoubleArray() writeFloatArray(float[])   readFloatArray(float[]) 
  createFloatArray() writeIntArray(int[])   readIntArray(int[]) 
  createIntArray() writeLongArray(long[])   readLongArray(long[]) 
  createLongArray() writeStringArray(java.lang.String[])   readStringArray(java.lang.String[]) 
  createStringArray() .
  writeSparseBooleanArray(android.util.SparseBooleanArray) 
  readSparseBooleanArray() .
  Parcelables The  Parcelable  protocol provides an extremely efficient (but
 low-level) protocol for objects to write and read themselves from Parcels.
 You can use the direct methods  writeParcelable(android.os.Parcelable int) 
 and  readParcelable(java.lang.ClassLoader)  or
  writeParcelableArray(T[] int)  and
  readParcelableArray(java.lang.ClassLoader)  to write or read.  These
 methods write both the class type and its data to the Parcel allowing
 that class to be reconstructed from the appropriate class loader when
 later reading. There are also some methods that provide a more efficient way to work
 with Parcelables:  writeTypedObject(T int)   writeTypedArray(T[] int) 
  writeTypedList(List )   readTypedObject(Parcelable.Creator ) 
  createTypedArray(Parcelable.Creator )  and  createTypedArrayList(Parcelable.Creator ) .  These methods
 do not write the class information of the original object: instead the
 caller of the read function must know what type to expect and pass in the
 appropriate  Parcelable.Creator  instead to
 properly construct the new object and read its data.  (To more efficient
 write and read a single Parcelable object that is not null you can directly
 call  Parcelable#writeToParcel  and
  Parcelable.Creator#createFromParcel 
 yourself.) Bundles A special type-safe container called  Bundle  is available
 for key/value maps of heterogeneous values.  This has many optimizations
 for improved performance when reading and writing data and its type-safe
 API avoids difficult to debug type errors when finally marshalling the
 data contents into a Parcel.  The methods to use are
  writeBundle(android.os.Bundle)   readBundle()  and
  readBundle(java.lang.ClassLoader) .

  Active Objects An unusual feature of Parcel is the ability to read and write active
 objects.  For these objects the actual contents of the object is not
 written rather a special token referencing the object is written.  When
 reading the object back from the Parcel you do not get a new instance of
 the object but rather a handle that operates on the exact same object that
 was originally written.  There are two forms of active objects available. Binder  objects are a core facility of Android's general cross-process
 communication system.  The  IBinder  interface describes an abstract
 protocol with a Binder object.  Any such interface can be written in to
 a Parcel and upon reading you will receive either the original object
 implementing that interface or a special proxy implementation
 that communicates calls back to the original object.  The methods to use are
  writeStrongBinder(android.os.IBinder) 
  writeStrongInterface(android.os.IInterface)   readStrongBinder() 
  writeBinderArray(android.os.IBinder[])   readBinderArray(android.os.IBinder[]) 
  createBinderArray() 
  writeBinderList(java.util.List)   readBinderList(java.util.List) 
  createBinderArrayList() . FileDescriptor objects representing raw Linux file descriptor identifiers
 can be written and  ParcelFileDescriptor  objects returned to operate
 on the original file descriptor.  The returned file descriptor is a dup
 of the original file descriptor: the object and fd is different but
 operating on the same underlying file stream with the same position etc.
 The methods to use are  writeFileDescriptor(java.io.FileDescriptor) 
  readFileDescriptor() .

  Untyped Containers A final class of methods are for writing and reading standard Java
 containers of arbitrary types.  These all revolve around the
  writeValue(java.lang.Object)  and  readValue(java.lang.ClassLoader)  methods
 which define the types of objects allowed.  The container methods are
  writeArray(java.lang.Object[])   readArray(java.lang.ClassLoader) 
  writeList(java.util.List)   readList(java.util.List java.lang.ClassLoader) 
  readArrayList(java.lang.ClassLoader) 
  writeMap(java.util.Map)   readMap(java.util.Map java.lang.ClassLoader) 
  writeSparseArray(android.util.SparseArray) 
  readSparseArray(java.lang.ClassLoader) .",,,,,,,,
"<android.test.TouchUtils: void scrollToTop(ActivityInstrumentationTestCase,ViewGroup)>","This method was deprecated
      in API level 15. ActivityInstrumentationTestCase is deprecated in favor of ActivityInstrumentationTestCase2 which provides more options for
 configuring the Activity under test Scroll a ViewGroup to the top by repeatedly calling dragQuarterScreenDown(android.test.InstrumentationTestCase android.app.Activity)","test ActivityInstrumentationTestCase : The test case that is being run |||
v ViewGroup : The ViewGroup that should be dragged |||",void,1,"Reusable methods for generating touch events. These methods can be used with
 InstrumentationTestCase or ActivityInstrumentationTestCase2 to simulate user interaction with
 the application through a touch screen.",,,,,,,,
"<android.view.ViewGroup: View focusSearch(View,int)>","Find the nearest view in the specified direction that wants to take
 focus.","focused View : The view that currently has focus |||
direction int : One of FOCUS_UP FOCUS_DOWN FOCUS_LEFT and
FOCUS_RIGHT or 0 for not applicable. |||",View |||,1,"A  ViewGroup  is a special view that can contain other views
 (called children.) The view group is the base class for layouts and views
 containers. This class also defines the
  ViewGroup.LayoutParams  class which serves as the base
 class for layouts parameters.
  
 Also see  LayoutParams  for layout attributes.",,,,,,,,
"<android.app.Service: void startForeground(int,Notification)>","If your service is started (running through Context#startService(Intent) ) then
 also make this service run in the foreground supplying the ongoing
 notification to be shown to the user while in this state.
 By default started services are background meaning that their process won't be given
 foreground CPU scheduling (unless something else in that process is foreground) and
 if the system needs to kill them to reclaim more memory (such as to display a large page in a
 web browser) they can be killed without too much harm.  You use startForeground(int Notification) if killing your service would be disruptive to the user such as
 if your service is performing background music playback so the user
 would notice if their music stopped playing. Note that calling this method does not put the service in the started state
 itself even though the name sounds like it.  You must always call ContextWrapper.startService(android.content.Intent) first to tell the system it should keep the service running
 and then use this method to tell it to keep it running harder. Apps targeting API Build.VERSION_CODES.P or later must request
 the permission Manifest.permission.FOREGROUND_SERVICE in order to use
 this API. Apps built with SDK version Build.VERSION_CODES.Q or later can specify
 the foreground service types using attribute R.attr.foregroundServiceType in
 service element of manifest file. The value of attribute R.attr.foregroundServiceType can be multiple flags ORed together.","id int : The identifier for this notification as per NotificationManager#notify(int Notification) ; must not be 0. |||
notification Notification : The Notification to be displayed. |||",void,5,"A Service is an application component representing either an application's desire
 to perform a longer-running operation while not interacting with the user
 or to supply functionality for other applications to use.  Each service
 class must have a corresponding
  <service> 
 declaration in its package's  AndroidManifest.xml .  Services
 can be started with
  Context.startService()  and
  Context.bindService() .

  Note that services like other application objects run in the main
 thread of their hosting process.  This means that if your service is going
 to do any CPU intensive (such as MP3 playback) or blocking (such as
 networking) operations it should spawn its own thread in which to do that
 work.  More information on this can be found in
  Processes and
 Threads .  The  IntentService  class is available
 as a standard implementation of Service that has its own thread where it
 schedules its work to be done. Topics covered here:
  What is a Service? Service Lifecycle Permissions Process Lifecycle Local Service Sample Remote Messenger Service Sample","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.text.format.Time: String format(String)>,"Print the current value given the format string provided. See man
 strftime for what means what. The final string must be less than 256
 characters.",format String : a string containing the desired format. |||,String a String containing the current time expressed in the current locale. |||,3,"An alternative to the  Calendar  and
  GregorianCalendar  classes. An instance of the Time class represents
 a moment in time specified with second precision. It is modelled after
 struct tm. This class is not thread-safe and does not consider leap seconds.

  This class has a number of issues and it is recommended that
  GregorianCalendar  is used instead.

  Known issues:
  For historical reasons when performing time calculations all arithmetic currently takes
     place using 32-bit integers. This limits the reliable time range representable from 1902
     until 2037.See the wikipedia article on the
      Year 2038 problem  for details.
     Do not rely on this behavior; it may change in the future.
      Calling  switchTimezone(java.lang.String)  on a date that cannot exist such as a wall time
     that was skipped due to a DST transition will result in a date in 1969 (i.e. -1 or 1 second
     before 1st Jan 1970 UTC). Much of the formatting / parsing assumes ASCII text and is therefore not suitable for
     use with non-ASCII scripts. No support for pseudo-zones like ""GMT-07:00"".","Provides classes used to render or track text and text spans on the screen. You can use these classes to design your own widgets that manage text
 to handle arbitrary text spans for changes or to handle drawing yourself
 for an existing widget. The Span… interfaces and classes are used to create or manage spans of
 text in a View item. You can use these to style the text or background or to
 listen for changes. If creating your own widget extend DynamicLayout to manages
 the actual wrapping and drawing of your text.",,,,,,,
"<android.widget.Spinner: void onClick(DialogInterface,int)>",This method will be invoked when a button in the dialog is clicked.,"dialog DialogInterface : the dialog that received the click |||
which int : the button that was clicked (ex. DialogInterface#BUTTON_POSITIVE ) or the position
of the item clicked |||",void,1,"A view that displays one child at a time and lets the user pick among them.
 The items in the Spinner come from the  Adapter  associated with
 this view.

  See the  Spinners  guide.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.widget.DialerFilter: void setMode(int)>,Change the mode of the widget.,newMode int : The mode to switch to. |||,void,1,"This widget is a layout that contains several specifically-named child views that
 handle keyboard entry interpreted as standard phone dialpad digits.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
"<android.database.sqlite.SQLiteDatabase: int delete(String,String,String)>",Convenience method for deleting rows in the database.,"table String : the table to delete from |||
whereClause String : the optional WHERE clause to apply when deleting.
Passing null will delete all rows. |||
whereArgs String : You may include ?s in the where clause which
will be replaced by the values from whereArgs. The values
will be bound as Strings. |||","int the number of rows affected if a whereClause is passed in 0
         otherwise. To remove all rows and get a count pass ""1"" as the
         whereClause. |||",1,"Exposes methods to manage a SQLite database.

  
 SQLiteDatabase has methods to create delete execute SQL commands and
 perform other common database management tasks.
  
 See the Notepad sample application in the SDK for an example of creating
 and managing a database.
  
 Database names must be unique within an application not across all applications.
  Localized Collation - ORDER BY 
 In addition to SQLite's default  BINARY  collator Android supplies
 two more  LOCALIZED  which changes with the system's current locale
 and  UNICODE  which is the Unicode Collation Algorithm and not tailored
 to the current locale.","If you need to manage data in a private database use the  android.database.sqlite  classes. These classes are used to manage the  Cursor  object returned from a content provider query. Databases
 are usually created and opened with  openOrCreateDatabase(String int SQLiteDatabase.CursorFactory) 
 To make requests through
 content providers you can use the  content.ContentResolver  class.
  All databases are stored on the device in  /data/data/<package_name>/databases",,,,,,,
<android.preference.PreferenceFragment: void onActivityCreated(Bundle)>,"Called when the fragment's activity has been created and this
 fragment's view hierarchy instantiated.  It can be used to do final
 initialization once these pieces are in place such as retrieving
 views or restoring state.  It is also useful for fragments that use setRetainInstance(boolean) to retain their instance
 as this callback tells the fragment when it is fully associated with
 the new activity instance.  This is called after onCreateView(LayoutInflater ViewGroup Bundle) and before onViewStateRestored(android.os.Bundle) . If you override this method you must call through to the
 superclass implementation.",savedInstanceState Bundle : This value may be null . |||,void,11,"Represents the basic Preference UI building
 block displayed by a  PreferenceActivity  in the form of a
  ListView . This class provides the  View  to be displayed in
 the activity and associates with a  SharedPreferences  to
 store/retrieve the preference data.
  
 When specifying a preference hierarchy in XML each element can point to a
 subclass of  Preference  similar to the view hierarchy and layouts.
  
 This class contains a  key  that will be used as the key into the
  SharedPreferences . It is up to the subclass to decide how to store
 the value.",,,,,,,,
<android.net.sip.SipSession: int getState()>,Gets the session state. The value returned must be one of the states in State .,,int the session state |||,9,"Represents a SIP session that is associated with a SIP dialog or a standalone
 transaction not within a dialog.
  You can get a  SipSession  from  SipManager  with  SipManager#createSipSession  (when initiating calls) or  SipManager#getSessionFor  (when receiving calls).",,,,,,,,
"<android.view.Display: void getCurrentSizeRange(Point,Point)>","Return the range of display sizes an application can expect to encounter
 under normal operation as long as there is no physical change in screen
 size.  This is basically the sizes you will see as the orientation
 changes taking into account whatever screen decoration there is in
 each rotation.  For example the status bar is always at the top of the
 screen so it will reduce the height both in landscape and portrait and
 the smallest height returned here will be the smaller of the two.

 This is intended for applications to get an idea of the range of sizes
 they will encounter while going through device rotations to provide a
 stable UI through rotation.  The sizes here take into account all standard
 system decorations that reduce the size actually available to the
 application: the status bar navigation bar system bar etc.  It does not take into account more transient elements like an IME
 soft keyboard.","outSmallestSize Point : Filled in with the smallest width and height
that the application will encounter in pixels (not dp units).  The x
(width) dimension here directly corresponds to Configuration.smallestScreenWidthDp except the value here is in raw
screen pixels rather than dp units.  Your application may of course
still get smaller space yet if for example a soft keyboard is
being displayed. |||
outLargestSize Point : Filled in with the largest width and height
that the application will encounter in pixels (not dp units).  Your
application may of course still get larger space than this if
for example screen decorations like the status bar are being hidden. |||",void,16,"Provides information about the size and density of a logical display.
  
 The display area is described in two different ways.
  The application display area specifies the part of the display that may contain
 an application window excluding the system decorations.  The application display area may
 be smaller than the real display area because the system subtracts the space needed
 for decor elements such as the status bar.  Use the following methods to query the
 application display area:  getSize(Point)   getRectSize(Rect)  and  getMetrics(DisplayMetrics) . The real display area specifies the part of the display that contains content
 including the system decorations.  Even so the real display area may be smaller than the
 physical size of the display if the window manager is emulating a smaller display
 using (adb shell wm size).  Use the following methods to query the
 real display area:  getRealSize(Point)   getRealMetrics(DisplayMetrics) . 
 A logical display does not necessarily represent a particular physical display device
 such as the built-in screen or an external monitor.  The contents of a logical
 display may be presented on one or more physical displays according to the devices
 that are currently attached and whether mirroring has been enabled.",,,,,,,,
"<android.widget.TextView: void setTextAppearance(Context,int)>","This method was deprecated
      in API level 23. Use setTextAppearance(int) instead. Sets the text color size style hint color and highlight color
 from the specified TextAppearance resource.","context Context |||
resId int |||",void,1,"A user interface element that displays text to the user.
 To provide user-editable text see  EditText .
  
 The following code sample shows a typical use with an XML layout
 and code to modify the contents of the text view:
  
 <LinearLayout
      xmlns:android=""http://schemas.android.com/apk/res/android""
      android:layout_width=""match_parent""
      android:layout_height=""match_parent"">
    <TextView
        android:id=""@+id/text_view_id""
        android:layout_height=""wrap_content""
        android:layout_width=""wrap_content""
        android:text=""@string/hello"" />
 </LinearLayout>
  
 This code sample demonstrates how to modify the contents of the text view
 defined in the previous XML layout:
  
 public class MainActivity extends Activity {

    protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_main);
         final TextView helloTextView = (TextView) findViewById(R.id.text_view_id);
         helloTextView.setText(R.string.user_greeting);
     }
 }
  
 To customize the appearance of TextView see  Styles and Themes .
  XML attributes 
 See  TextView Attributes 
  View Attributes","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
"<android.test.TouchUtils: void dragViewToTop(InstrumentationTestCase,View)>",Simulate touching the center of a view and dragging to the top of the screen.,"test InstrumentationTestCase : The test case that is being run |||
v View : The view that should be dragged |||",void,3,"Reusable methods for generating touch events. These methods can be used with
 InstrumentationTestCase or ActivityInstrumentationTestCase2 to simulate user interaction with
 the application through a touch screen.",,,,,,,,
<android.preference.Preference: void setSummary(int)>,Sets the summary for this Preference with a resource ID.,summaryResId int : the summary as a resource |||,void,1,"Represents the basic Preference UI building
 block displayed by a  PreferenceActivity  in the form of a
  ListView . This class provides the  View  to be displayed in
 the activity and associates with a  SharedPreferences  to
 store/retrieve the preference data.
  
 When specifying a preference hierarchy in XML each element can point to a
 subclass of  Preference  similar to the view hierarchy and layouts.
  
 This class contains a  key  that will be used as the key into the
  SharedPreferences . It is up to the subclass to decide how to store
 the value.",,,,,,,,
<android.view.ViewGroup: void endViewTransition(View)>,"This method should always be called following an earlier call to startViewTransition(android.view.View) . The given View is finally removed from its parent
 and will no longer be displayed. Note that this method does not perform the functionality
 of removing a view from its parent; it just discontinues the display of a View that
 has previously been removed.",view View |||,"void view The View object that has been removed but is being kept around in the visible
 hierarchy by an earlier call to startViewTransition(android.view.View) . |||",11,"A  ViewGroup  is a special view that can contain other views
 (called children.) The view group is the base class for layouts and views
 containers. This class also defines the
  ViewGroup.LayoutParams  class which serves as the base
 class for layouts parameters.
  
 Also see  LayoutParams  for layout attributes.",,,,,,,,
<android.app.PendingIntent: String getTargetPackage()>,"This method was deprecated
      in API level 17. Renamed to getCreatorPackage() .",,String |||,1,"A description of an Intent and target action to perform with it.  Instances
 of this class are created with  getActivity(Context int Intent int)   getActivities(Context int Intent[] int) 
  getBroadcast(Context int Intent int)  and  getService(Context int Intent int) ; the returned object can be
 handed to other applications so that they can perform the action you
 described on your behalf at a later time.

  By giving a PendingIntent to another application
 you are granting it the right to perform the operation you have specified
 as if the other application was yourself (with the same permissions and
 identity).  As such you should be careful about how you build the PendingIntent:
 almost always for example the base Intent you supply should have the component
 name explicitly set to one of your own components to ensure it is ultimately
 sent there and nowhere else.

  A PendingIntent itself is simply a reference to a token maintained by
 the system describing the original data used to retrieve it.  This means
 that even if its owning application's process is killed the
 PendingIntent itself will remain usable from other processes that
 have been given it.  If the creating application later re-retrieves the
 same kind of PendingIntent (same operation same Intent action data
 categories and components and same flags) it will receive a PendingIntent
 representing the same token if that is still valid and can thus call
  cancel()  to remove it.

  Because of this behavior it is important to know when two Intents
 are considered to be the same for purposes of retrieving a PendingIntent.
 A common mistake people make is to create multiple PendingIntent objects
 with Intents that only vary in their ""extra"" contents expecting to get
 a different PendingIntent each time.  This does  not  happen.  The
 parts of the Intent that are used for matching are the same ones defined
 by  Intent#filterEquals(Intent) .  If you use two
 Intent objects that are equivalent as per
  Intent#filterEquals(Intent)  then you will get
 the same PendingIntent for both of them.

  There are two typical ways to deal with this.

  If you truly need multiple distinct PendingIntent objects active at
 the same time (such as to use as two notifications that are both shown
 at the same time) then you will need to ensure there is something that
 is different about them to associate them with different PendingIntents.
 This may be any of the Intent attributes considered by
  Intent#filterEquals(Intent)  or different
 request code integers supplied to  getActivity(Context int Intent int)   getActivities(Context int Intent[] int) 
  getBroadcast(Context int Intent int)  or  getService(Context int Intent int) .

  If you only need one PendingIntent active at a time for any of the
 Intents you will use then you can alternatively use the flags
  FLAG_CANCEL_CURRENT  or  FLAG_UPDATE_CURRENT  to either
 cancel or modify whatever current PendingIntent is associated with the
 Intent you are supplying.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.widget.TextView: void setHint(int)>,"Sets the text to be displayed when the text of the TextView is empty
 from a resource. Related XML Attributes: android:hint",resid int |||,void,1,"A user interface element that displays text to the user.
 To provide user-editable text see  EditText .
  
 The following code sample shows a typical use with an XML layout
 and code to modify the contents of the text view:
  
 <LinearLayout
      xmlns:android=""http://schemas.android.com/apk/res/android""
      android:layout_width=""match_parent""
      android:layout_height=""match_parent"">
    <TextView
        android:id=""@+id/text_view_id""
        android:layout_height=""wrap_content""
        android:layout_width=""wrap_content""
        android:text=""@string/hello"" />
 </LinearLayout>
  
 This code sample demonstrates how to modify the contents of the text view
 defined in the previous XML layout:
  
 public class MainActivity extends Activity {

    protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_main);
         final TextView helloTextView = (TextView) findViewById(R.id.text_view_id);
         helloTextView.setText(R.string.user_greeting);
     }
 }
  
 To customize the appearance of TextView see  Styles and Themes .
  XML attributes 
 See  TextView Attributes 
  View Attributes","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.media.RemoteControlClient: void setPlaybackState(int)>,Sets the current playback state.,state int : The current playback state one of the following values: PLAYSTATE_STOPPED  PLAYSTATE_PAUSED  PLAYSTATE_PLAYING  PLAYSTATE_FAST_FORWARDING  PLAYSTATE_REWINDING  PLAYSTATE_SKIPPING_FORWARDS  PLAYSTATE_SKIPPING_BACKWARDS  PLAYSTATE_BUFFERING  PLAYSTATE_ERROR . |||,void,14,"RemoteControlClient enables exposing information meant to be consumed by remote controls
 capable of displaying metadata artwork and media transport control buttons.

  A remote control client object is associated with a media button event receiver. This
 event receiver must have been previously registered with
  AudioManager#registerMediaButtonEventReceiver(ComponentName)  before the
 RemoteControlClient can be registered through
  AudioManager#registerRemoteControlClient(RemoteControlClient) .

  Here is an example of creating a RemoteControlClient instance after registering a media
 button event receiver:
  ComponentName myEventReceiver = new ComponentName(getPackageName() MyRemoteControlEventReceiver.class.getName());
 AudioManager myAudioManager = (AudioManager) getSystemService(Context.AUDIO_SERVICE);
 myAudioManager.registerMediaButtonEventReceiver(myEventReceiver);
 // build the PendingIntent for the remote control client
 Intent mediaButtonIntent = new Intent(Intent.ACTION_MEDIA_BUTTON);
 mediaButtonIntent.setComponent(myEventReceiver);
 PendingIntent mediaPendingIntent = PendingIntent.getBroadcast(getApplicationContext() 0 mediaButtonIntent 0);
 // create and register the remote control client
 RemoteControlClient myRemoteControlClient = new RemoteControlClient(mediaPendingIntent);
 myAudioManager.registerRemoteControlClient(myRemoteControlClient);","The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",,,,,,,
<android.os.ParcelFileDescriptor: void close()>,"Close the ParcelFileDescriptor. This implementation closes the underlying
 OS resources allocated to represent this stream.",,void,1,"Container for a message (data and object references) that can
 be sent through an IBinder.  A Parcel can contain both flattened data
 that will be unflattened on the other side of the IPC (using the various
 methods here for writing specific types or the general
  Parcelable  interface) and references to live  IBinder 
 objects that will result in the other side receiving a proxy IBinder
 connected with the original IBinder in the Parcel.

  Parcel is  not  a general-purpose
 serialization mechanism.  This class (and the corresponding
  Parcelable  API for placing arbitrary objects into a Parcel) is
 designed as a high-performance IPC transport.  As such it is not
 appropriate to place any Parcel data in to persistent storage: changes
 in the underlying implementation of any of the data in the Parcel can
 render older data unreadable. The bulk of the Parcel API revolves around reading and writing data
 of various types.  There are six major classes of such functions available. Primitives The most basic data functions are for writing and reading primitive
 data types:  writeByte(byte)   readByte()   writeDouble(double) 
  readDouble()   writeFloat(float)   readFloat()   writeInt(int) 
  readInt()   writeLong(long)   readLong() 
  writeString(String)   readString() .  Most other
 data operations are built on top of these.  The given data is written and
 read using the endianess of the host CPU. Primitive Arrays There are a variety of methods for reading and writing raw arrays
 of primitive objects which generally result in writing a 4-byte length
 followed by the primitive data items.  The methods for reading can either
 read the data into an existing array or create and return a new array.
 These available types are: writeBooleanArray(boolean[]) 
  readBooleanArray(boolean[])   createBooleanArray() writeByteArray(byte[]) 
  writeByteArray(byte[] int int)   readByteArray(byte[]) 
  createByteArray() writeCharArray(char[])   readCharArray(char[]) 
  createCharArray() writeDoubleArray(double[])   readDoubleArray(double[]) 
  createDoubleArray() writeFloatArray(float[])   readFloatArray(float[]) 
  createFloatArray() writeIntArray(int[])   readIntArray(int[]) 
  createIntArray() writeLongArray(long[])   readLongArray(long[]) 
  createLongArray() writeStringArray(java.lang.String[])   readStringArray(java.lang.String[]) 
  createStringArray() .
  writeSparseBooleanArray(android.util.SparseBooleanArray) 
  readSparseBooleanArray() .
  Parcelables The  Parcelable  protocol provides an extremely efficient (but
 low-level) protocol for objects to write and read themselves from Parcels.
 You can use the direct methods  writeParcelable(android.os.Parcelable int) 
 and  readParcelable(java.lang.ClassLoader)  or
  writeParcelableArray(T[] int)  and
  readParcelableArray(java.lang.ClassLoader)  to write or read.  These
 methods write both the class type and its data to the Parcel allowing
 that class to be reconstructed from the appropriate class loader when
 later reading. There are also some methods that provide a more efficient way to work
 with Parcelables:  writeTypedObject(T int)   writeTypedArray(T[] int) 
  writeTypedList(List )   readTypedObject(Parcelable.Creator ) 
  createTypedArray(Parcelable.Creator )  and  createTypedArrayList(Parcelable.Creator ) .  These methods
 do not write the class information of the original object: instead the
 caller of the read function must know what type to expect and pass in the
 appropriate  Parcelable.Creator  instead to
 properly construct the new object and read its data.  (To more efficient
 write and read a single Parcelable object that is not null you can directly
 call  Parcelable#writeToParcel  and
  Parcelable.Creator#createFromParcel 
 yourself.) Bundles A special type-safe container called  Bundle  is available
 for key/value maps of heterogeneous values.  This has many optimizations
 for improved performance when reading and writing data and its type-safe
 API avoids difficult to debug type errors when finally marshalling the
 data contents into a Parcel.  The methods to use are
  writeBundle(android.os.Bundle)   readBundle()  and
  readBundle(java.lang.ClassLoader) .

  Active Objects An unusual feature of Parcel is the ability to read and write active
 objects.  For these objects the actual contents of the object is not
 written rather a special token referencing the object is written.  When
 reading the object back from the Parcel you do not get a new instance of
 the object but rather a handle that operates on the exact same object that
 was originally written.  There are two forms of active objects available. Binder  objects are a core facility of Android's general cross-process
 communication system.  The  IBinder  interface describes an abstract
 protocol with a Binder object.  Any such interface can be written in to
 a Parcel and upon reading you will receive either the original object
 implementing that interface or a special proxy implementation
 that communicates calls back to the original object.  The methods to use are
  writeStrongBinder(android.os.IBinder) 
  writeStrongInterface(android.os.IInterface)   readStrongBinder() 
  writeBinderArray(android.os.IBinder[])   readBinderArray(android.os.IBinder[]) 
  createBinderArray() 
  writeBinderList(java.util.List)   readBinderList(java.util.List) 
  createBinderArrayList() . FileDescriptor objects representing raw Linux file descriptor identifiers
 can be written and  ParcelFileDescriptor  objects returned to operate
 on the original file descriptor.  The returned file descriptor is a dup
 of the original file descriptor: the object and fd is different but
 operating on the same underlying file stream with the same position etc.
 The methods to use are  writeFileDescriptor(java.io.FileDescriptor) 
  readFileDescriptor() .

  Untyped Containers A final class of methods are for writing and reading standard Java
 containers of arbitrary types.  These all revolve around the
  writeValue(java.lang.Object)  and  readValue(java.lang.ClassLoader)  methods
 which define the types of objects allowed.  The container methods are
  writeArray(java.lang.Object[])   readArray(java.lang.ClassLoader) 
  writeList(java.util.List)   readList(java.util.List java.lang.ClassLoader) 
  readArrayList(java.lang.ClassLoader) 
  writeMap(java.util.Map)   readMap(java.util.Map java.lang.ClassLoader) 
  writeSparseArray(android.util.SparseArray) 
  readSparseArray(java.lang.ClassLoader) .",,,,,,,,
<android.telephony.PhoneNumberUtils: String formatNumber(String)>,"This method was deprecated
      in API level 21. Use link #formatNumber(String phoneNumber String defaultCountryIso) instead Breaks the given number down and formats it according to the rules
 for the country the number is from.",source String : The phone number to format |||,"String A locally acceptable formatting of the input or the raw input if
  formatting rules aren't known for the number |||",1,Various utilities for dealing with phone number strings.,,,,,,,,
<android.net.SSLCertificateSocketFactory: String getSupportedCipherSuites()>,"Returns the names of the cipher suites which could be enabled for use
 on an SSL connection.  Normally only a subset of these will actually
 be enabled by default since this list may include cipher suites which
 do not meet quality of service requirements for those defaults.  Such
 cipher suites are useful in specialized applications. Applications should not blindly enable all supported
 cipher suites.  The supported cipher suites can include signaling cipher suite
 values that can cause connection problems if enabled inappropriately. The proper way to use this method is to either check if a specific cipher
 suite is supported via Arrays.asList(getSupportedCipherSuites()).contains(...) or to filter a desired list of cipher suites to only the supported ones via desiredSuiteSet.retainAll(Arrays.asList(getSupportedCipherSuites())) .",,String[] an array of cipher suite names |||,1,"SSLSocketFactory implementation with several extra features:

  Timeout specification for SSL handshake operations
  Hostname verification in most cases (see WARNINGs below)
  Optional SSL session caching with  SSLSessionCache Optionally bypass all SSL certificate checks
  createSocket() Socket#connect(java.net.SocketAddress int) The recommended way to verify the server's identity is to use
  HttpsURLConnection#getDefaultHostnameVerifier()  to get a
  HostnameVerifier  to verify the certificate hostname.

  Warning : Some methods on this class return connected sockets and some return
 unconnected sockets.  For the methods that return connected sockets setting
 connection- or handshake-related properties on those sockets will have no effect.

  On development devices ""setprop socket.relaxsslcheck yes"" bypasses all
 SSL certificate and hostname checks for testing purposes.  This setting
 requires root access.",,,,,,,,
"<android.view.ViewGroup: void addFocusables(ArrayList,int,int)>","Adds any focusable views that are descendants of this view (possibly
 including this view if it is focusable itself) to views. This method
 adds all focusable views regardless if we are in touch mode or
 only views focusable in touch mode if we are in touch mode or
 only views that can take accessibility focus if accessibility is enabled
 depending on the focusable mode parameter.","views ArrayList : Focusable views found so far or null if all we are interested is
the number of focusables. |||
direction int : The direction of the focus.
Value is View.FOCUS_BACKWARD  View.FOCUS_FORWARD  View.FOCUS_LEFT  View.FOCUS_UP  View.FOCUS_RIGHT or View.FOCUS_DOWN |||
focusableMode int : The type of focusables to be added.
Value is either 0 or a combination of View.FOCUSABLES_ALL and View.FOCUSABLES_TOUCH_MODE |||",void,4,"A  ViewGroup  is a special view that can contain other views
 (called children.) The view group is the base class for layouts and views
 containers. This class also defines the
  ViewGroup.LayoutParams  class which serves as the base
 class for layouts parameters.
  
 Also see  LayoutParams  for layout attributes.",,,,,,,,
<android.text.method.MetaKeyKeyListener: void resetMetaState(Spannable)>,Resets all meta state to inactive.,text Spannable |||,void,1,"This base class encapsulates the behavior for tracking the state of
 meta keys such as SHIFT ALT and SYM as well as the pseudo-meta state of selecting text.
  
 Key listeners that care about meta state should inherit from this class;
 you should not instantiate this class directly in a client.
  
 This class provides two mechanisms for tracking meta state that can be used
 together or independently.
  Methods such as  handleKeyDown(long int android.view.KeyEvent)  and
  getMetaState(long)  operate on a meta key state bit mask. Methods such as  onKeyDown(android.view.View android.text.Editable int android.view.KeyEvent)  and
  getMetaState(java.lang.CharSequence int)  operate on meta key state flags stored
 as spans in an  Editable  text buffer.  The spans only describe the current
 meta key state of the text editor; they do not carry any positional information. 
 The behavior of this class varies according to the keyboard capabilities
 described by the  KeyCharacterMap  of the keyboard device such as
 the  KeyCharacterMap#getModifierBehavior() .
  MetaKeyKeyListener  implements chorded and toggled key modifiers.
 When key modifiers are toggled into a latched or locked state the state
 of the modifier is stored in the  Editable  text buffer or in a
 meta state integer managed by the client.  These latched or locked modifiers
 should be considered to be held  in addition to  those that the
 keyboard already reported as being pressed in  KeyEvent#getMetaState() .
 In other words the  MetaKeyKeyListener  augments the meta state
 provided by the keyboard; it does not replace it.  This distinction is important
 to ensure that meta keys not handled by  MetaKeyKeyListener  such as
  KeyEvent#KEYCODE_CAPS_LOCK  or  KeyEvent#KEYCODE_NUM_LOCK  are
 taken into consideration.
  
 To ensure correct meta key behavior the following pattern should be used
 when mapping key codes to characters:
  
 private char getUnicodeChar(TextKeyListener listener KeyEvent event Editable textBuffer) {
     // Use the combined meta states from the event and the key listener.
     int metaState = event.getMetaState() | listener.getMetaState(textBuffer);
     return event.getUnicodeChar(metaState);
 }","Provides classes that monitor or modify keypad input. You can use these classes to modify the type of keypad entry
 for your application or decipher the keypresses entered for your specific
 entry method. For example: 
 // Set the text to password display style:
 EditText txtView = (EditText)findViewById(R.id.text);
 txtView.setTransformationMethod(PasswordTransformationMethod.getInstance());

 //Set the input style to numbers rather than qwerty keyboard style.
 txtView.setInputMethod(DigitsInputMethod.getInstance());

 // Find out whether the caps lock is on.
 // 0 is no 1 is yes 2 is caps lock on.
 int active = MultiTapInputMethod.getCapsActive(txtView.getText());",,,,,,,
"<android.test.TouchUtils: void dragViewToTop(ActivityInstrumentationTestCase,View)>","This method was deprecated
      in API level 15. ActivityInstrumentationTestCase is deprecated in favor of ActivityInstrumentationTestCase2 which provides more options for
 configuring the Activity under test Simulate touching the center of a view and dragging to the top of the screen.","test ActivityInstrumentationTestCase : The test case that is being run |||
v View : The view that should be dragged |||",void,1,"Reusable methods for generating touch events. These methods can be used with
 InstrumentationTestCase or ActivityInstrumentationTestCase2 to simulate user interaction with
 the application through a touch screen.",,,,,,,,
<android.preference.DialogPreference: void setPositiveButtonText(int)>,,positiveButtonTextResId int : The positive button text as a resource. |||,void,1,"A base class for  Preference  objects that are
 dialog-based. These preferences will when clicked open a dialog showing the
 actual preference controls.",,,,,,,,
<android.database.DatabaseUtils: void readExceptionWithOperationApplicationExceptionFromParcel(Parcel)>,,reply Parcel |||,void,5,Static utility methods for dealing with databases and  Cursor s.,"If you need to manage data in a private database use the  android.database.sqlite  classes. These classes are used to manage the  Cursor  object returned from a content provider query. Databases
 are usually created and opened with  openOrCreateDatabase(String int SQLiteDatabase.CursorFactory) 
 To make requests through
 content providers you can use the  content.ContentResolver  class.
  All databases are stored on the device in  /data/data/<package_name>/databases",,,,,,,
"<android.net.sip.SipManager: void unregister(SipProfile,SipRegistrationListener)>","Manually unregisters the profile from the corresponding SIP provider for
 stop receiving further calls. This may interference with the auto
 registration process in the SIP service if the auto-registration option
 in the profile is enabled.","localProfile SipProfile : the SIP profile to register with |||
listener SipRegistrationListener : to listen to the registration events |||",void,9,"Provides APIs for SIP tasks such as initiating SIP connections and provides access to related
 SIP services. This class is the starting point for any SIP actions. You can acquire an instance
 of it with  newInstance() . The APIs in this class allows you to: Create a  SipSession  to get ready for making calls or listen for incoming calls. See
  createSipSession()  and  getSessionFor() . Initiate and receive generic SIP calls or audio-only SIP calls. Generic SIP calls may
 be video audio or other and are initiated with  open() . Audio-only SIP calls
 should be handled with a  SipAudioCall  which you can acquire with  makeAudioCall()  and  takeAudioCall() . Register and unregister with a SIP service provider with
       register()  and  unregister() . Verify session connectivity with  isOpened()  and
       isRegistered() . Note:  Not all Android-powered devices support VOIP calls using
 SIP. You should always call  isVoipSupported()  to verify that the device supports VOIP calling and  isApiSupported()  to verify that the device supports
 the SIP APIs. Your application must also request the  Manifest.permission.INTERNET  and  Manifest.permission.USE_SIP 
 permissions.",,,,,,,,
"<android.view.inputmethod.InputMethodManager: void updateSelection(View,int,int,int,int)>","Report the current selection range. Editor authors you need to call this method whenever
 the cursor moves in your editor. Remember that in addition to doing this your
 editor needs to always supply current cursor values in EditorInfo#initialSelStart and EditorInfo#initialSelEnd every
 time View.onCreateInputConnection(EditorInfo) is
 called which happens whenever the keyboard shows up or the focus changes
 to a text field among other cases.","view View |||
selStart int |||
selEnd int |||
candidatesStart int |||
candidatesEnd int |||",void,3,"Central system API to the overall input method framework (IMF) architecture
 which arbitrates interaction between applications and the current input method.

  Topics covered here:
  Architecture Overview Applications Input Methods Security Architecture Overview There are three primary parties involved in the input method
 framework (IMF) architecture:  The  input method manager  as expressed by this class
 is the central point of the system that manages interaction between all
 other parts.  It is expressed as the client-side API here which exists
 in each application context and communicates with a global system service
 that manages the interaction across all processes.
   An  input method (IME)  implements a particular
 interaction model allowing the user to generate text.  The system binds
 to the current input method that is in use causing it to be created and run
 and tells it when to hide and show its UI.  Only one IME is running at a time.
   Multiple  client applications  arbitrate with the input
 method manager for input focus and control over the state of the IME.  Only
 one such client is ever active (working with the IME) at a time.
  Applications In most cases applications that are using the standard
  TextView  or its subclasses will have little they need
 to do to work well with soft input methods.  The main things you need to
 be aware of are:  Properly set the  R.attr.inputType  in your editable
 text views so that the input method will have enough context to help the
 user in entering text into them.
   Deal well with losing screen space when the input method is
 displayed.  Ideally an application should handle its window being resized
 smaller but it can rely on the system performing panning of the window
 if needed.  You should set the  R.attr.windowSoftInputMode 
 attribute on your activity or the corresponding values on windows you
 create to help the system determine whether to pan or resize (it will
 try to determine this automatically but may get it wrong).
   You can also control the preferred soft input state (open closed etc)
 for your window using the same  R.attr.windowSoftInputMode 
 attribute.
  More finer-grained control is available through the APIs here to directly
 interact with the IMF and its IME -- either showing or hiding the input
 area letting the user pick an input method etc. For the rare people amongst us writing their own text editors you
 will need to implement  View.onCreateInputConnection(EditorInfo) 
 to return a new instance of your own  InputConnection  interface
 allowing the IME to interact with your editor. Input Methods An input method (IME) is implemented
 as a  Service  typically deriving from
  InputMethodService .  It must provide
 the core  InputMethod  interface though this is normally handled by
  InputMethodService  and implementors will
 only need to deal with the higher-level API there. InputMethodService Security There are a lot of security issues associated with input methods
 since they essentially have freedom to completely drive the UI and monitor
 everything the user enters.  The Android input method framework also allows
 arbitrary third party IMEs so care must be taken to restrict their
 selection and interactions. Here are some key points about the security architecture behind the
 IMF: Only the system is allowed to directly access an IME's
  InputMethod  interface via the
  Manifest.permission.BIND_INPUT_METHOD  permission.  This is
 enforced in the system by not binding to an input method service that does
 not require this permission so the system can guarantee no other untrusted
 clients are accessing the current input method outside of its control. There may be many client processes of the IMF but only one may
 be active at a time.  The inactive clients can not interact with key
 parts of the IMF through the mechanisms described below. Clients of an input method are only given access to its
  InputMethodSession  interface.  One instance of this interface is
 created for each client and only calls from the session associated with
 the active client will be processed by the current IME.  This is enforced
 by  AbstractInputMethodService  for normal
 IMEs but must be explicitly handled by an IME that is customizing the
 raw  InputMethodSession  implementation. Only the active client's  InputConnection  will accept
 operations.  The IMF tells each client process whether it is active and
 the framework enforces that in inactive processes calls on to the current
 InputConnection will be ignored.  This ensures that the current IME can
 only deliver events and text edits to the UI that the user sees as
 being in focus. An IME can never interact with an  InputConnection  while
 the screen is off.  This is enforced by making all clients inactive while
 the screen is off and prevents bad IMEs from driving the UI when the user
 can not be aware of its behavior. A client application can ask that the system let the user pick a
 new IME but can not programmatically switch to one itself.  This avoids
 malicious applications from switching the user to their own IME which
 remains running when the user navigates away to another application.  An
 IME on the other hand  is  allowed to programmatically switch
 the system to another IME since it already has full control of user
 input. The user must explicitly enable a new IME in settings before
 they can switch to it to confirm with the system that they know about it
 and want to make it available for use. PackageManager#FEATURE_INPUT_METHODS PackageManager.hasSystemFeature(String)",,,,,,,,
<android.text.SpannableStringBuilder: void removeSpan(Object)>,Remove the specified markup object from the buffer.,what Object |||,void,1,"This is the class for text whose content is immutable but to which
 markup objects can be attached and detached.
 For mutable text see  SpannableStringBuilder .","Provides classes used to render or track text and text spans on the screen. You can use these classes to design your own widgets that manage text
 to handle arbitrary text spans for changes or to handle drawing yourself
 for an existing widget. The Span… interfaces and classes are used to create or manage spans of
 text in a View item. You can use these to style the text or background or to
 listen for changes. If creating your own widget extend DynamicLayout to manages
 the actual wrapping and drawing of your text.",,,,,,,
<android.app.MediaRouteButton: void setVisibility(int)>,Set the visibility state of this view.,"visibility int : One of View.VISIBLE  View.INVISIBLE or View.GONE .
Value is View.VISIBLE  View.INVISIBLE or View.GONE |||",void,16,,"Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.text.SpannableString: void removeSpan(Object)>,"Remove the specified object from the range of text to which it
 was attached if any.  It is OK to remove an object that was never
 attached in the first place.",what Object |||,void,1,"This is the class for text whose content is immutable but to which
 markup objects can be attached and detached.
 For mutable text see  SpannableStringBuilder .","Provides classes used to render or track text and text spans on the screen. You can use these classes to design your own widgets that manage text
 to handle arbitrary text spans for changes or to handle drawing yourself
 for an existing widget. The Span… interfaces and classes are used to create or manage spans of
 text in a View item. You can use these to style the text or background or to
 listen for changes. If creating your own widget extend DynamicLayout to manages
 the actual wrapping and drawing of your text.",,,,,,,
"<android.text.format.DateFormat: CharSequence format(CharSequence,Calendar)>","Given a format string and a Calendar object returns a CharSequence
 containing the requested date.","inFormat CharSequence : the format string as described in DateFormat |||
inDate Calendar : the date to format |||",CharSequence a CharSequence containing the requested text |||,3,"Utility class for producing strings with formatted date/time.

  Most callers should avoid supplying their own format strings to this
 class'  format  methods and rely on the correctly localized ones
 supplied by the system. This class' factory methods return
 appropriately-localized  DateFormat  instances suitable
 for both formatting and parsing dates. For the canonical documentation
 of format strings see  SimpleDateFormat .

  In cases where the system does not provide a suitable pattern
 this class offers the  getBestDateTimePattern(Locale String)  method.

  The  format  methods in this class implement a subset of Unicode
  UTS #35  patterns.
 The subset currently supported by this class includes the following format characters:
  acdEHhLKkLMmsyz . Up to API level 17 only  adEhkMmszy  were supported.
 Note that this class incorrectly implements  k  as if it were  H  for backwards
 compatibility.

  See  SimpleDateFormat  for more documentation
 about patterns or if you need a more complete or correct implementation.
 Note that the non- format  methods in this class are implemented by
  SimpleDateFormat .","Provides classes used to render or track text and text spans on the screen. You can use these classes to design your own widgets that manage text
 to handle arbitrary text spans for changes or to handle drawing yourself
 for an existing widget. The Span… interfaces and classes are used to create or manage spans of
 text in a View item. You can use these to style the text or background or to
 listen for changes. If creating your own widget extend DynamicLayout to manages
 the actual wrapping and drawing of your text.",,,,,,,
<android.widget.ProgressBar: void incrementSecondaryProgressBy(int)>,Increase the progress bar's secondary progress by the specified amount.,diff int : the amount by which the secondary progress must be increased |||,void,1,"A user interface element that indicates the progress of an operation.
 Progress bar supports two modes to represent progress: determinate and indeterminate. For
 a visual overview of the difference between determinate and indeterminate progress modes see
  
 Progress & activity .
 Display progress bars to a user in a non-interruptive way.
 Show the progress bar in your app's user interface or in a notification
 instead of within a dialog.
  Indeterminate Progress 
 Use indeterminate mode for the progress bar when you do not know how long an
 operation will take.
 Indeterminate mode is the default for progress bar and shows a cyclic animation without a
 specific amount of progress indicated.
 The following example shows an indeterminate progress bar:
  
 <ProgressBar
      android:id=""@+id/indeterminateBar""
      android:layout_width=""wrap_content""
      android:layout_height=""wrap_content""
      />
  Determinate Progress 
 Use determinate mode for the progress bar when you want to show that a specific quantity of
 progress has occurred.
 For example the percent remaining of a file being retrieved the amount records in
 a batch written to database or the percent remaining of an audio file that is playing.
  
 To indicate determinate progress you set the style of the progress bar to
  R.style.Widget_ProgressBar_Horizontal  and set the amount of progress.
 The following example shows a determinate progress bar that is 25% complete:
  
 <ProgressBar
      android:id=""@+id/determinateBar""
      style=""@android:style/Widget.ProgressBar.Horizontal""
      android:layout_width=""wrap_content""
      android:layout_height=""wrap_content""
      android:progress=""25""/>
  setProgress(int) incrementProgressBy(int) android:max Other progress bar styles provided by the system include: Widget.ProgressBar.Horizontal Widget.ProgressBar.Small Widget.ProgressBar.Large Widget.ProgressBar.Inverse Widget.ProgressBar.Small.Inverse Widget.ProgressBar.Large.Inverse The ""inverse"" styles provide an inverse color scheme for the spinner which may be necessary
 if your application uses a light colored theme (a white background). XML attributes 
 See  ProgressBar Attributes 
  View Attributes","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.accessibilityservice.AccessibilityService: AccessibilityNodeInfo getRootInActiveWindow()>,"Gets the root node in the currently active window if this service
 can retrieve window content. The active window is the one that the user
 is currently touching or the window with input focus if the user is not
 touching any window. It could be from any logical display. The currently active window is defined as the window that most recently fired one
 of the following events: AccessibilityEvent#TYPE_WINDOW_STATE_CHANGED  AccessibilityEvent#TYPE_VIEW_HOVER_ENTER  AccessibilityEvent#TYPE_VIEW_HOVER_EXIT .
 In other words the last window shown that also has input focus. Note: In order to access the root node your service has
 to declare the capability to retrieve window content by setting the R.styleable.AccessibilityService_canRetrieveWindowContent property in its meta-data. For details refer to SERVICE_META_DATA .",,AccessibilityNodeInfo The root node if this service can retrieve window content. |||,16,"Accessibility services should only be used to assist users with disabilities in using
 Android devices and apps. They run in the background and receive callbacks by the system
 when  AccessibilityEvent s are fired. Such events denote some state transition
 in the user interface for example the focus has changed a button has been clicked
 etc. Such a service can optionally request the capability for querying the content
 of the active window. Development of an accessibility service requires extending this
 class and implementing its abstract methods.","The classes in this package are used for development of accessibility service that
   provide alternative or augmented feedback to the user.
  
   An  AccessibilityService  runs in the background and
   receives callbacks by the system when  AccessibilityEvent s
   are fired. Such events denote some state transition in the user interface for example the
   focus has changed a button has been clicked etc. Such a service can optionally request the
   capability for querying the content of the active window. Development of an accessibility
   service requires extends this class and implements its abstract methods.
  
   An  AccessibilityServiceInfo  describes an
    AccessibilityService . The system notifies an
   AccessibilityService for  AccessibilityEvent s
   according to the information encapsulated in this class.",,,,,,,
<android.widget.QuickContactBadge: void setImageToDefault()>,Resets the contact photo to the default state.,,void,11,"Widget used to show an image with the standard QuickContact badge
 and on-click behavior.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.app.Fragment: void registerForContextMenu(View)>,"Registers a context menu to be shown for the given view (multiple views
 can show the context menu). This method will set the OnCreateContextMenuListener on the view to this fragment so onCreateContextMenu(android.view.ContextMenu android.view.View android.view.ContextMenu.ContextMenuInfo) will be
 called when it is time to show the context menu.",view View : The view that should show a context menu. |||,void,11,"A Fragment is a piece of an application's user interface or behavior
 that can be placed in an  Activity .  Interaction with fragments
 is done through  FragmentManager  which can be obtained via
  Activity#getFragmentManager()  and
  Fragment#getFragmentManager() .

  The Fragment class can be used many ways to achieve a wide variety of
 results. In its core it represents a particular operation or interface
 that is running within a larger  Activity .  A Fragment is closely
 tied to the Activity it is in and can not be used apart from one.  Though
 Fragment defines its own lifecycle that lifecycle is dependent on its
 activity: if the activity is stopped no fragments inside of it can be
 started; when the activity is destroyed all fragments will be destroyed.

  All subclasses of Fragment must include a public no-argument constructor.
 The framework will often re-instantiate a fragment class when needed
 in particular during state restore and needs to be able to find this
 constructor to instantiate it.  If the no-argument constructor is not
 available a runtime exception will occur in some cases during state
 restore.

  Topics covered here:
  Older Platforms Lifecycle Layout Back Stack","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
"<android.net.sip.SipAudioCall: void sendDtmf(int,Message)>","Sends a DTMF code. According to RFC 2883 event 0--9 maps to decimal
 value 0--9 '*' to 10 '#' to 11 event 'A'--'D' to 12--15 and event
 flash to 16. Currently event flash is not supported.","code int : the DTMF code to send. Value 0 to 15 (inclusive) are valid
inputs. |||
result Message : the result message to send when done |||",void,9,"Handles an Internet audio call over SIP. You can instantiate this class with  SipManager 
 using  SipManager#makeAudioCall  and   SipManager#takeAudioCall .

  Note:  Using this class require the
    Manifest.permission.INTERNET  and
    Manifest.permission.USE_SIP  permissions. In addition  startAudio()  requires the
    Manifest.permission.RECORD_AUDIO 
    Manifest.permission.ACCESS_WIFI_STATE  and
    Manifest.permission.WAKE_LOCK  permissions; and  setSpeakerMode()  requires the
    Manifest.permission.MODIFY_AUDIO_SETTINGS  permission.",,,,,,,,
<android.widget.VideoView: void stopPlayback()>,,,void,1,"Displays a video file.  The VideoView class
 can load images from various sources (such as resources or content
 providers) takes care of computing its measurement from the video so that
 it can be used in any layout manager and provides various display options
 such as scaling and tinting. Note: VideoView does not retain its full state when going into the
 background.   In particular it does not restore the current play state
 play position selected tracks or any subtitle tracks added via
  addSubtitleSource() .  Applications should
 save and restore these on their own in
  Activity.onSaveInstanceState(Bundle)  and
  Activity.onRestoreInstanceState(Bundle) . 
 Also note that the audio session id (from  getAudioSessionId() ) may
 change from its previously returned value when the VideoView is restored.
  
 By default VideoView requests audio focus with  AudioManager#AUDIOFOCUS_GAIN . Use
  setAudioFocusRequest(int)  to change this behavior.
  
 The default  AudioAttributes  used during playback have a usage of
  AudioAttributes#USAGE_MEDIA  and a content type of
  AudioAttributes#CONTENT_TYPE_MOVIE  use  setAudioAttributes(android.media.AudioAttributes)  to
 modify them.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.view.inputmethod.InputMethodManager: void hideStatusIcon(IBinder)>,"This method was deprecated
      in API level 28. Use InputMethodService#hideStatusIcon() instead. This method was
 intended for IME developers who should be accessing APIs through the service. APIs in
 this class are intended for app developers interacting with the IME.",imeToken IBinder |||,void,3,"Central system API to the overall input method framework (IMF) architecture
 which arbitrates interaction between applications and the current input method.

  Topics covered here:
  Architecture Overview Applications Input Methods Security Architecture Overview There are three primary parties involved in the input method
 framework (IMF) architecture:  The  input method manager  as expressed by this class
 is the central point of the system that manages interaction between all
 other parts.  It is expressed as the client-side API here which exists
 in each application context and communicates with a global system service
 that manages the interaction across all processes.
   An  input method (IME)  implements a particular
 interaction model allowing the user to generate text.  The system binds
 to the current input method that is in use causing it to be created and run
 and tells it when to hide and show its UI.  Only one IME is running at a time.
   Multiple  client applications  arbitrate with the input
 method manager for input focus and control over the state of the IME.  Only
 one such client is ever active (working with the IME) at a time.
  Applications In most cases applications that are using the standard
  TextView  or its subclasses will have little they need
 to do to work well with soft input methods.  The main things you need to
 be aware of are:  Properly set the  R.attr.inputType  in your editable
 text views so that the input method will have enough context to help the
 user in entering text into them.
   Deal well with losing screen space when the input method is
 displayed.  Ideally an application should handle its window being resized
 smaller but it can rely on the system performing panning of the window
 if needed.  You should set the  R.attr.windowSoftInputMode 
 attribute on your activity or the corresponding values on windows you
 create to help the system determine whether to pan or resize (it will
 try to determine this automatically but may get it wrong).
   You can also control the preferred soft input state (open closed etc)
 for your window using the same  R.attr.windowSoftInputMode 
 attribute.
  More finer-grained control is available through the APIs here to directly
 interact with the IMF and its IME -- either showing or hiding the input
 area letting the user pick an input method etc. For the rare people amongst us writing their own text editors you
 will need to implement  View.onCreateInputConnection(EditorInfo) 
 to return a new instance of your own  InputConnection  interface
 allowing the IME to interact with your editor. Input Methods An input method (IME) is implemented
 as a  Service  typically deriving from
  InputMethodService .  It must provide
 the core  InputMethod  interface though this is normally handled by
  InputMethodService  and implementors will
 only need to deal with the higher-level API there. InputMethodService Security There are a lot of security issues associated with input methods
 since they essentially have freedom to completely drive the UI and monitor
 everything the user enters.  The Android input method framework also allows
 arbitrary third party IMEs so care must be taken to restrict their
 selection and interactions. Here are some key points about the security architecture behind the
 IMF: Only the system is allowed to directly access an IME's
  InputMethod  interface via the
  Manifest.permission.BIND_INPUT_METHOD  permission.  This is
 enforced in the system by not binding to an input method service that does
 not require this permission so the system can guarantee no other untrusted
 clients are accessing the current input method outside of its control. There may be many client processes of the IMF but only one may
 be active at a time.  The inactive clients can not interact with key
 parts of the IMF through the mechanisms described below. Clients of an input method are only given access to its
  InputMethodSession  interface.  One instance of this interface is
 created for each client and only calls from the session associated with
 the active client will be processed by the current IME.  This is enforced
 by  AbstractInputMethodService  for normal
 IMEs but must be explicitly handled by an IME that is customizing the
 raw  InputMethodSession  implementation. Only the active client's  InputConnection  will accept
 operations.  The IMF tells each client process whether it is active and
 the framework enforces that in inactive processes calls on to the current
 InputConnection will be ignored.  This ensures that the current IME can
 only deliver events and text edits to the UI that the user sees as
 being in focus. An IME can never interact with an  InputConnection  while
 the screen is off.  This is enforced by making all clients inactive while
 the screen is off and prevents bad IMEs from driving the UI when the user
 can not be aware of its behavior. A client application can ask that the system let the user pick a
 new IME but can not programmatically switch to one itself.  This avoids
 malicious applications from switching the user to their own IME which
 remains running when the user navigates away to another application.  An
 IME on the other hand  is  allowed to programmatically switch
 the system to another IME since it already has full control of user
 input. The user must explicitly enable a new IME in settings before
 they can switch to it to confirm with the system that they know about it
 and want to make it available for use. PackageManager#FEATURE_INPUT_METHODS PackageManager.hasSystemFeature(String)",,,,,,,,
<android.view.ViewPropertyAnimator: ViewPropertyAnimator rotationX(float)>,"This method will cause the View's rotationX property to be animated to the
 specified value. Animations already running on the property will be canceled.",value float : The value to be animated to. |||,ViewPropertyAnimator This object allowing calls to methods in this class to be chained. |||,12,"This class enables automatic and optimized animation of select properties on View objects.
 If only one or two properties on a View object are being animated then using an
  ObjectAnimator  is fine; the property setters called by ObjectAnimator
 are well equipped to do the right thing to set the property and invalidate the view
 appropriately. But if several properties are animated simultaneously or if you just want a
 more convenient syntax to animate a specific property then ViewPropertyAnimator might be
 more well-suited to the task.

  This class may provide better performance for several simultaneous animations because
 it will optimize invalidate calls to take place only once for several properties instead of each
 animated property independently causing its own invalidation. Also the syntax of using this
 class could be easier to use because the caller need only tell the View object which
 property to animate and the value to animate either to or by and this class handles the
 details of configuring the underlying Animator class and starting it. This class is not constructed by the caller but rather by the View whose properties
 it will animate. Calls to  View.animate()  will return a reference
 to the appropriate ViewPropertyAnimator object for that View.",,,,,,,,
"<android.content.ContentProviderClient: Bundle call(String,String,Bundle)>",See ContentProvider#call(String String Bundle),"method String : This value cannot be null . |||
arg String : This value may be null . |||
extras Bundle : This value may be null . |||",Bundle This value may be null . |||,17,"Content providers are one of the primary building blocks of Android applications providing
 content to applications. They encapsulate data and provide it to applications through the single
  ContentResolver  interface. A content provider is only required if you need to share
 data between multiple applications. For example the contacts data is used by multiple
 applications and must be stored in a content provider. If you don't need to share data amongst
 multiple applications you can use a database directly via
  SQLiteDatabase .

  When a request is made via
 a  ContentResolver  the system inspects the authority of the given URI and passes the
 request to the content provider registered with the authority. The content provider can interpret
 the rest of the URI however it wants. The  UriMatcher  class is helpful for parsing
 URIs. The primary methods that need to be implemented are:
  onCreate()  which is called to initialize the provider query(Uri String[] Bundle CancellationSignal)  which returns data to the caller insert(Uri ContentValues)  which inserts new data into the content provider update(Uri ContentValues String String[])  which updates existing data in the content provider delete(Uri String String[])  which deletes data from the content provider getType(Uri)  which returns the MIME type of data in the content provider Requests to  ContentResolver  are automatically forwarded to the appropriate
 ContentProvider instance so subclasses don't have to worry about the details of
 cross-process calls.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.database.sqlite.SQLiteDatabase: void execSQL(String)>,"Execute a single SQL statement that is NOT a SELECT
 or any other SQL statement that returns data. It has no means to return any data (such as the number of affected rows).
 Instead you're encouraged to use insert(java.lang.String java.lang.String android.content.ContentValues)  update(java.lang.String android.content.ContentValues java.lang.String java.lang.String[]) et al when possible. When using enableWriteAheadLogging() journal_mode is
 automatically managed by this class. So do not set journal_mode
 using ""PRAGMA journal_mode' "" statement if your app is using enableWriteAheadLogging() Note that PRAGMA values which apply on a per-connection basis
 should not be configured using this method; you should instead
 use execPerConnectionSQL(String Object[]) to ensure that they are uniformly
 applied to all current and future connections.","sql String : the SQL statement to be executed. Multiple statements separated by semicolons are
not supported. |||",void,1,"Exposes methods to manage a SQLite database.

  
 SQLiteDatabase has methods to create delete execute SQL commands and
 perform other common database management tasks.
  
 See the Notepad sample application in the SDK for an example of creating
 and managing a database.
  
 Database names must be unique within an application not across all applications.
  Localized Collation - ORDER BY 
 In addition to SQLite's default  BINARY  collator Android supplies
 two more  LOCALIZED  which changes with the system's current locale
 and  UNICODE  which is the Unicode Collation Algorithm and not tailored
 to the current locale.","If you need to manage data in a private database use the  android.database.sqlite  classes. These classes are used to manage the  Cursor  object returned from a content provider query. Databases
 are usually created and opened with  openOrCreateDatabase(String int SQLiteDatabase.CursorFactory) 
 To make requests through
 content providers you can use the  content.ContentResolver  class.
  All databases are stored on the device in  /data/data/<package_name>/databases",,,,,,,
"<android.net.TrafficStats: void incrementOperationCount(int,int)>","Increment count of network operations performed under the given
 accounting tag. This can be used to derive bytes-per-operation.","tag int : Accounting tag used in setThreadStatsTag(int) . |||
operationCount int : Number of operations to increment count by. |||",void,14,"Class that provides network traffic statistics. These statistics include
 bytes transmitted and received and network packets transmitted and received
 over all interfaces over the mobile interface and on a per-UID basis.
  
 These statistics may not be available on all platforms. If the statistics are
 not supported by this device  UNSUPPORTED  will be returned.
  
 Note that the statistics returned by this class reset and start from zero
 after every reboot. To access more robust historical network statistics data
 use  NetworkStatsManager  instead.",,,,,,,,
"<android.content.ContextWrapper: int checkCallingOrSelfUriPermission(Uri,int)>","Determine whether the calling process of an IPC or you has been granted
 permission to access a specific URI.  This is the same as checkCallingUriPermission(Uri int) except it grants your own permissions
 if you are not currently processing an IPC.  Use with care!","uri Uri : The uri that is being checked. |||
modeFlags int : The access modes to check.
Value is either 0 or a combination of Intent.FLAG_GRANT_READ_URI_PERMISSION and Intent.FLAG_GRANT_WRITE_URI_PERMISSION |||","int PackageManager#PERMISSION_GRANTED if the caller
 is allowed to access that uri or PackageManager#PERMISSION_DENIED if it is not.

 Value is PackageManager.PERMISSION_GRANTED or PackageManager.PERMISSION_DENIED |||",1,"Proxying implementation of Context that simply delegates all of its calls to
 another Context.  Can be subclassed to modify behavior without changing
 the original Context.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.nfc.tech.Ndef: void writeNdefMessage(NdefMessage)>,"Overwrite the NdefMessage on this tag. This is an I/O operation and will block until complete. It must
 not be called from the main application thread. A blocked call will be canceled with IOException if close() is called from another thread. Requires the Manifest.permission.NFC permission.",msg NdefMessage : the NDEF Message to write must not be null |||,void,10,"Provides access to NDEF content and operations on a  Tag .

  Acquire a  Ndef  object using  get(Tag) .

  NDEF is an NFC Forum data format. The data formats are implemented in
  NdefMessage  and
  NdefRecord . This class provides methods to
 retrieve and modify the  NdefMessage 
 on a tag.

  There are currently four NFC Forum standardized tag types that can be
 formatted to contain NDEF data.
  NFC Forum Type 1 Tag ( NFC_FORUM_TYPE_1 ) such as the Innovision Topaz
  NFC Forum Type 2 Tag ( NFC_FORUM_TYPE_2 ) such as the NXP MIFARE Ultralight
  NFC Forum Type 3 Tag ( NFC_FORUM_TYPE_3 ) such as Sony Felica
  NFC Forum Type 4 Tag ( NFC_FORUM_TYPE_4 ) such as NXP MIFARE Desfire
  Ndef Some vendors have their own well defined specifications for storing NDEF data
 on tags that do not fall into the above categories. Android devices with NFC
 should enumerate and implement  Ndef  under these vendor specifications
 where possible but it is not mandatory.  getType()  returns a String
 describing this specification for example  MIFARE_CLASSIC  is
  com.nxp.ndef.mifareclassic .

  Android devices that support MIFARE Classic must also correctly
 implement  Ndef  on MIFARE Classic tags formatted to NDEF.

  For guaranteed compatibility across all Android devices with NFC it is
 recommended to use NFC Forum Types 1-4 in new deployments of NFC tags
 with NDEF payload. Vendor NDEF formats will not work on all Android devices.

  Note:  Methods that perform I/O operations
 require the  Manifest.permission.NFC  permission.","These classes provide access to a tag technology's features which vary by the type
 of tag that is scanned. A scanned tag can support multiple technologies and you can find
 out what they are by calling  getTechList() . For more information on dealing with tag technologies and handling the ones that you care about see
  The Tag Dispatch System .
 The  TagTechnology  interface provides an overview of the
 supported technologies.",,,,,,,
<android.app.Presentation: void show()>,Inherited from Dialog#show . Will throw WindowManager.InvalidDisplayException if the specified secondary Display can't be found or if it does not have Display#FLAG_PRESENTATION set.,,void,17,"Base class for presentations.
  
 A presentation is a special kind of dialog whose purpose is to present
 content on a secondary display.  A  Presentation  is associated with
 the target  Display  at creation time and configures its context and
 resource configuration according to the display's metrics.
  
 Notably the  Context  of a presentation is different from the context
 of its containing  Activity .  It is important to inflate the layout
 of a presentation and load other resources using the presentation's own context
 to ensure that assets of the correct size and density for the target display
 are loaded.
  
 A presentation is automatically canceled (see  Dialog#cancel() ) when
 the display to which it is attached is removed.  An activity should take
 care of pausing and resuming whatever content is playing within the presentation
 whenever the activity itself is paused or resumed.
  Choosing a presentation display 
 Before showing a  Presentation  it's important to choose the  Display 
 on which it will appear.  Choosing a presentation display is sometimes difficult
 because there may be multiple displays attached.  Rather than trying to guess
 which display is best an application should let the system choose a suitable
 presentation display.
  
 There are two main ways to choose a  Display .
  Using the media router to choose a presentation display 
 The easiest way to choose a presentation display is to use the
  MediaRouter  API.  The media router service keeps
 track of which audio and video routes are available on the system.
 The media router sends notifications whenever routes are selected or unselected
 or when the preferred presentation display of a route changes.
 So an application can simply watch for these notifications and show or dismiss
 a presentation on the preferred presentation display automatically.
  
 The preferred presentation display is the display that the media router recommends
 that the application should use if it wants to show content on the secondary display.
 Sometimes there may not be a preferred presentation display in which
 case the application should show its content locally without using a presentation.
  
 Here's how to use the media router to create and show a presentation on the preferred
 presentation display using  MediaRouter.RouteInfo.getPresentationDisplay() .
  
 MediaRouter mediaRouter = (MediaRouter) context.getSystemService(Context.MEDIA_ROUTER_SERVICE);
 MediaRouter.RouteInfo route = mediaRouter.getSelectedRoute();
 if (route != null) {
     Display presentationDisplay = route.getPresentationDisplay();
     if (presentationDisplay != null) {
         Presentation presentation = new MyPresentation(context presentationDisplay);
         presentation.show();
     }
 } 
 The following sample code from  ApiDemos  demonstrates how to use the media
 router to automatically switch between showing content in the main activity and showing
 the content in a presentation when a presentation display is available.
  /**
 * <h3>Presentation Activity</h3>
 *
 * <p>
 * This demonstrates how to create an activity that shows some content
 * on a secondary display using a {@link Presentation}.
 * </p><p>
 * The activity uses the {@link MediaRouter} API to automatically detect when
 * a presentation display is available and to allow the user to control the
 * media routes using a menu item.  When a presentation display is available
 * we stop showing content in the main activity and instead open up a
 * {@link Presentation} on the preferred presentation display.  When a presentation
 * display is removed we revert to showing content in the main activity.
 * We also write information about displays and display-related events to
 * the Android log which you can read using <code>adb logcat</code>.
 * </p><p>
 * You can try this out using an HDMI or Wifi display or by using the
 * ""Simulate secondary displays"" feature in Development Settings to create a few
 * simulated secondary displays.  Each display will appear in the list along with a
 * checkbox to show a presentation on that display.
 * </p><p>
 * See also the {@link PresentationActivity} sample which
 * uses the low-level display manager to enumerate displays and to show multiple
 * simultaneous presentations on different displays.
 * </p>
 */
public class PresentationWithMediaRouterActivity extends Activity {
    private final String TAG = ""PresentationWithMediaRouterActivity"";

    private MediaRouter mMediaRouter;
    private DemoPresentation mPresentation;
    private GLSurfaceView mSurfaceView;
    private TextView mInfoTextView;
    private boolean mPaused;

    /**
     * Initialization of the Activity after it is first created.  Must at least
     * call {@link android.app.Activity#setContentView setContentView()} to
     * describe what is to be displayed in the screen.
     */
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        // Be sure to call the super class.
        super.onCreate(savedInstanceState);

        // Get the media router service.
        mMediaRouter = (MediaRouter)getSystemService(Context.MEDIA_ROUTER_SERVICE);

        // See assets/res/any/layout/presentation_with_media_router_activity.xml for this
        // view layout definition which is being set here as
        // the content of our screen.
        setContentView(R.layout.presentation_with_media_router_activity);

        // Set up the surface view for visual interest.
        mSurfaceView = (GLSurfaceView)findViewById(R.id.surface_view);
        mSurfaceView.setRenderer(new CubeRenderer(false));

        // Get a text view where we will show information about what's happening.
        mInfoTextView = (TextView)findViewById(R.id.info);
    }

    @Override
    protected void onResume() {
        // Be sure to call the super class.
        super.onResume();

        // Listen for changes to media routes.
        mMediaRouter.addCallback(MediaRouter.ROUTE_TYPE_LIVE_VIDEO mMediaRouterCallback);

        // Update the presentation based on the currently selected route.
        mPaused = false;
        updatePresentation();
    }

    @Override
    protected void onPause() {
        // Be sure to call the super class.
        super.onPause();

        // Stop listening for changes to media routes.
        mMediaRouter.removeCallback(mMediaRouterCallback);

        // Pause rendering.
        mPaused = true;
        updateContents();
    }

    @Override
    protected void onStop() {
        // Be sure to call the super class.
        super.onStop();

        // Dismiss the presentation when the activity is not visible.
        if (mPresentation != null) {
            Log.i(TAG ""Dismissing presentation because the activity is no longer visible."");
            mPresentation.dismiss();
            mPresentation = null;
        }
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        // Be sure to call the super class.
        super.onCreateOptionsMenu(menu);

        // Inflate the menu and configure the media router action provider.
        getMenuInflater().inflate(R.menu.presentation_with_media_router_menu menu);

        MenuItem mediaRouteMenuItem = menu.findItem(R.id.menu_media_route);
        MediaRouteActionProvider mediaRouteActionProvider =
                (MediaRouteActionProvider)mediaRouteMenuItem.getActionProvider();
        mediaRouteActionProvider.setRouteTypes(MediaRouter.ROUTE_TYPE_LIVE_VIDEO);

        // Return true to show the menu.
        return true;
    }

    private void updatePresentation() {
        // Get the current route and its presentation display.
        MediaRouter.RouteInfo route = mMediaRouter.getSelectedRoute(
                MediaRouter.ROUTE_TYPE_LIVE_VIDEO);
        Display presentationDisplay = route != null ? route.getPresentationDisplay() : null;

        // Dismiss the current presentation if the display has changed.
        if (mPresentation != null && mPresentation.getDisplay() != presentationDisplay) {
            Log.i(TAG ""Dismissing presentation because the current route no longer ""
                    + ""has a presentation display."");
            mPresentation.dismiss();
            mPresentation = null;
        }

        // Show a new presentation if needed.
        if (mPresentation == null && presentationDisplay != null) {
            Log.i(TAG ""Showing presentation on display: "" + presentationDisplay);
            mPresentation = new DemoPresentation(this presentationDisplay);
            mPresentation.setOnDismissListener(mOnDismissListener);
            try {
                mPresentation.show();
            } catch (WindowManager.InvalidDisplayException ex) {
                Log.w(TAG ""Couldn't show presentation!  Display was removed in ""
                        + ""the meantime."" ex);
                mPresentation = null;
            }
        }

        // Update the contents playing in this activity.
        updateContents();
    }

    private void updateContents() {
        // Show either the content in the main activity or the content in the presentation
        // along with some descriptive text about what is happening.
        if (mPresentation != null) {
            mInfoTextView.setText(getResources().getString(
                    R.string.presentation_with_media_router_now_playing_remotely
                    mPresentation.getDisplay().getName()));
            mSurfaceView.setVisibility(View.INVISIBLE);
            mSurfaceView.onPause();
            if (mPaused) {
                mPresentation.getSurfaceView().onPause();
            } else {
                mPresentation.getSurfaceView().onResume();
            }
        } else {
            mInfoTextView.setText(getResources().getString(
                    R.string.presentation_with_media_router_now_playing_locally
                    getWindowManager().getDefaultDisplay().getName()));
            mSurfaceView.setVisibility(View.VISIBLE);
            if (mPaused) {
                mSurfaceView.onPause();
            } else {
                mSurfaceView.onResume();
            }
        }
    }

    private final MediaRouter.SimpleCallback mMediaRouterCallback =
            new MediaRouter.SimpleCallback() {
        @Override
        public void onRouteSelected(MediaRouter router int type RouteInfo info) {
            Log.d(TAG ""onRouteSelected: type="" + type + "" info="" + info);
            updatePresentation();
        }

        @Override
        public void onRouteUnselected(MediaRouter router int type RouteInfo info) {
            Log.d(TAG ""onRouteUnselected: type="" + type + "" info="" + info);
            updatePresentation();
        }

        @Override
        public void onRoutePresentationDisplayChanged(MediaRouter router RouteInfo info) {
            Log.d(TAG ""onRoutePresentationDisplayChanged: info="" + info);
            updatePresentation();
        }
    };

    /**
     * Listens for when presentations are dismissed.
     */
    private final DialogInterface.OnDismissListener mOnDismissListener =
            new DialogInterface.OnDismissListener() {
        @Override
        public void onDismiss(DialogInterface dialog) {
            if (dialog == mPresentation) {
                Log.i(TAG ""Presentation was dismissed."");
                mPresentation = null;
                updateContents();
            }
        }
    };

    /**
     * The presentation to show on the secondary display.
     * <p>
     * Note that this display may have different metrics from the display on which
     * the main activity is showing so we must be careful to use the presentation's
     * own {@link Context} whenever we load resources.
     * </p>
     */
    private final static class DemoPresentation extends Presentation {
        private GLSurfaceView mSurfaceView;

        public DemoPresentation(Context context Display display) {
            super(context display);
        }

        @Override
        protected void onCreate(Bundle savedInstanceState) {
            // Be sure to call the super class.
            super.onCreate(savedInstanceState);

            // Get the resources for the context of the presentation.
            // Notice that we are getting the resources from the context of the presentation.
            Resources r = getContext().getResources();

            // Inflate the layout.
            setContentView(R.layout.presentation_with_media_router_content);

            // Set up the surface view for visual interest.
            mSurfaceView = (GLSurfaceView)findViewById(R.id.surface_view);
            mSurfaceView.setRenderer(new CubeRenderer(false));
        }

        public GLSurfaceView getSurfaceView() {
            return mSurfaceView;
        }
    }
} Using the display manager to choose a presentation display 
 Another way to choose a presentation display is to use the  DisplayManager  API
 directly.  The display manager service provides functions to enumerate and describe all
 displays that are attached to the system including displays that may be used
 for presentations.
  
 The display manager keeps track of all displays in the system.  However not all
 displays are appropriate for showing presentations.  For example if an activity
 attempted to show a presentation on the main display it might obscure its own content
 (it's like opening a dialog on top of your activity).
  
 Here's how to identify suitable displays for showing presentations using
  DisplayManager#getDisplays(String)  and the
  DisplayManager#DISPLAY_CATEGORY_PRESENTATION  category.
  
 DisplayManager displayManager = (DisplayManager) context.getSystemService(Context.DISPLAY_SERVICE);
 Display[] presentationDisplays = displayManager.getDisplays(DisplayManager.DISPLAY_CATEGORY_PRESENTATION);
 if (presentationDisplays.length > 0) {
     // If there is more than one suitable presentation display then we could consider
     // giving the user a choice.  For this example we simply choose the first display
     // which is the one the system recommends as the preferred presentation display.
     Display display = presentationDisplays[0];
     Presentation presentation = new MyPresentation(context presentationDisplay);
     presentation.show();
 } 
 The following sample code from  ApiDemos  demonstrates how to use the display
 manager to enumerate displays and show content on multiple presentation displays
 simultaneously.
  /**
 * <h3>Presentation Activity</h3>
 *
 * <p>
 * This demonstrates how to create an activity that shows some content
 * on a secondary display using a {@link Presentation}.
 * </p><p>
 * The activity uses the {@link DisplayManager} API to enumerate displays.
 * When the user selects a display the activity opens a {@link Presentation}
 * on that display.  We show a different photograph in each presentation
 * on a unique background along with a label describing the display.
 * We also write information about displays and display-related events to
 * the Android log which you can read using <code>adb logcat</code>.
 * </p><p>
 * You can try this out using an HDMI or Wifi display or by using the
 * ""Simulate secondary displays"" feature in Development Settings to create a few
 * simulated secondary displays.  Each display will appear in the list along with a
 * checkbox to show a presentation on that display.
 * </p><p>
 * See also the {@link PresentationWithMediaRouterActivity} sample which
 * uses the media router to automatically select a secondary display
 * on which to show content based on the currently selected route.
 * </p>
 */
public class PresentationActivity extends Activity
        implements OnCheckedChangeListener OnClickListener OnItemSelectedListener {
    private final String TAG = ""PresentationActivity"";

    // Key for storing saved instance state.
    private static final String PRESENTATION_KEY = ""presentation"";

    // The content that we want to show on the presentation.
    private static final int[] PHOTOS = new int[] {
        R.drawable.frantic
        R.drawable.photo1 R.drawable.photo2 R.drawable.photo3
        R.drawable.photo4 R.drawable.photo5 R.drawable.photo6
        R.drawable.sample_4
    };

    private DisplayManager mDisplayManager;
    private DisplayListAdapter mDisplayListAdapter;
    private CheckBox mShowAllDisplaysCheckbox;
    private ListView mListView;
    private int mNextImageNumber;

    // List of presentation contents indexed by displayId.
    // This state persists so that we can restore the old presentation
    // contents when the activity is paused or resumed.
    private SparseArray<DemoPresentationContents> mSavedPresentationContents;

    // List of all currently visible presentations indexed by display id.
    private final SparseArray<DemoPresentation> mActivePresentations =
            new SparseArray<DemoPresentation>();

    /**
     * Initialization of the Activity after it is first created.  Must at least
     * call {@link android.app.Activity#setContentView setContentView()} to
     * describe what is to be displayed in the screen.
     */
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        // Be sure to call the super class.
        super.onCreate(savedInstanceState);

        // Restore saved instance state.
        if (savedInstanceState != null) {
            mSavedPresentationContents =
                    savedInstanceState.getSparseParcelableArray(PRESENTATION_KEY);
        } else {
            mSavedPresentationContents = new SparseArray<DemoPresentationContents>();
        }

        // Get the display manager service.
        mDisplayManager = (DisplayManager)getSystemService(Context.DISPLAY_SERVICE);

        // See assets/res/any/layout/presentation_activity.xml for this
        // view layout definition which is being set here as
        // the content of our screen.
        setContentView(R.layout.presentation_activity);

        // Set up checkbox to toggle between showing all displays or only presentation displays.
        mShowAllDisplaysCheckbox = (CheckBox)findViewById(R.id.show_all_displays);
        mShowAllDisplaysCheckbox.setOnCheckedChangeListener(this);

        // Set up the list of displays.
        mDisplayListAdapter = new DisplayListAdapter(this);
        mListView = (ListView)findViewById(R.id.display_list);
        mListView.setAdapter(mDisplayListAdapter);
    }

    @Override
    protected void onResume() {
        // Be sure to call the super class.
        super.onResume();

        // Update our list of displays on resume.
        mDisplayListAdapter.updateContents();

        // Restore presentations from before the activity was paused.
        final int numDisplays = mDisplayListAdapter.getCount();
        for (int i = 0; i < numDisplays; i++) {
            final Display display = mDisplayListAdapter.getItem(i);
            final DemoPresentationContents contents =
                    mSavedPresentationContents.get(display.getDisplayId());
            if (contents != null) {
                showPresentation(display contents);
            }
        }
        mSavedPresentationContents.clear();

        // Register to receive events from the display manager.
        mDisplayManager.registerDisplayListener(mDisplayListener null);
    }

    @Override
    protected void onPause() {
        // Be sure to call the super class.
        super.onPause();

        // Unregister from the display manager.
        mDisplayManager.unregisterDisplayListener(mDisplayListener);

        // Dismiss all of our presentations but remember their contents.
        Log.d(TAG ""Activity is being paused.  Dismissing all active presentation."");
        for (int i = 0; i < mActivePresentations.size(); i++) {
            DemoPresentation presentation = mActivePresentations.valueAt(i);
            int displayId = mActivePresentations.keyAt(i);
            mSavedPresentationContents.put(displayId presentation.mContents);
            presentation.dismiss();
        }
        mActivePresentations.clear();
    }

    @Override
    protected void onSaveInstanceState(Bundle outState) {
        // Be sure to call the super class.
        super.onSaveInstanceState(outState);
        outState.putSparseParcelableArray(PRESENTATION_KEY mSavedPresentationContents);
    }

    /**
     * Shows a {@link Presentation} on the specified display.
     */
    private void showPresentation(Display display DemoPresentationContents contents) {
        final int displayId = display.getDisplayId();
        if (mActivePresentations.get(displayId) != null) {
            return;
        }

        Log.d(TAG ""Showing presentation photo #"" + contents.photo
                + "" on display #"" + displayId + ""."");

        DemoPresentation presentation = new DemoPresentation(this display contents);
        presentation.show();
        presentation.setOnDismissListener(mOnDismissListener);
        mActivePresentations.put(displayId presentation);
    }

    /**
     * Hides a {@link Presentation} on the specified display.
     */
    private void hidePresentation(Display display) {
        final int displayId = display.getDisplayId();
        DemoPresentation presentation = mActivePresentations.get(displayId);
        if (presentation == null) {
            return;
        }

        Log.d(TAG ""Dismissing presentation on display #"" + displayId + ""."");

        presentation.dismiss();
        mActivePresentations.delete(displayId);
    }

    /**
     * Sets the display mode of the {@link Presentation} on the specified display
     * if it is already shown.
     */
    private void setPresentationDisplayMode(Display display int displayModeId) {
        final int displayId = display.getDisplayId();
        DemoPresentation presentation = mActivePresentations.get(displayId);
        if (presentation == null) {
            return;
        }

        presentation.setPreferredDisplayMode(displayModeId);
    }

    private int getNextPhoto() {
        final int photo = mNextImageNumber;
        mNextImageNumber = (mNextImageNumber + 1) % PHOTOS.length;
        return photo;
    }

    /**
     * Called when the show all displays checkbox is toggled or when
     * an item in the list of displays is checked or unchecked.
     */
    @Override
    public void onCheckedChanged(CompoundButton buttonView boolean isChecked) {
        if (buttonView == mShowAllDisplaysCheckbox) {
            // Show all displays checkbox was toggled.
            mDisplayListAdapter.updateContents();
        } else {
            // Display item checkbox was toggled.
            final Display display = (Display)buttonView.getTag();
            if (isChecked) {
                DemoPresentationContents contents = new DemoPresentationContents(getNextPhoto());
                showPresentation(display contents);
            } else {
                hidePresentation(display);
            }
            mDisplayListAdapter.updateContents();
        }
    }

    /**
     * Called when the Info button next to a display is clicked to show information
     * about the display.
     */
    @Override
    public void onClick(View v) {
        Context context = v.getContext();
        AlertDialog.Builder builder = new AlertDialog.Builder(context);
        final Display display = (Display)v.getTag();
        Resources r = context.getResources();
        AlertDialog alert = builder
                .setTitle(r.getString(
                        R.string.presentation_alert_info_text display.getDisplayId()))
                .setMessage(display.toString())
                .setNeutralButton(R.string.presentation_alert_dismiss_text
                        new DialogInterface.OnClickListener() {
                            @Override
                            public void onClick(DialogInterface dialog int which) {
                                dialog.dismiss();
                            }
                    })
                .create();
        alert.show();
    }

    /**
     * Called when a display mode has been selected.
     */
    @Override
    public void onItemSelected(AdapterView<?> parent View view int position long id) {
        final Display display = (Display)parent.getTag();
        final Display.Mode[] modes = display.getSupportedModes();
        setPresentationDisplayMode(display position >= 1 && position <= modes.length ?
                modes[position - 1].getModeId() : 0);
    }

    /**
     * Called when a display mode has been unselected.
     */
    @Override
    public void onNothingSelected(AdapterView<?> parent) {
        final Display display = (Display)parent.getTag();
        setPresentationDisplayMode(display 0);
    }

    /**
     * Listens for displays to be added changed or removed.
     * We use it to update the list and show a new {@link Presentation} when a
     * display is connected.
     *
     * Note that we don't bother dismissing the {@link Presentation} when a
     * display is removed although we could.  The presentation API takes care
     * of doing that automatically for us.
     */
    private final DisplayManager.DisplayListener mDisplayListener =
            new DisplayManager.DisplayListener() {
        @Override
        public void onDisplayAdded(int displayId) {
            Log.d(TAG ""Display #"" + displayId + "" added."");
            mDisplayListAdapter.updateContents();
        }

        @Override
        public void onDisplayChanged(int displayId) {
            Log.d(TAG ""Display #"" + displayId + "" changed."");
            mDisplayListAdapter.updateContents();
        }

        @Override
        public void onDisplayRemoved(int displayId) {
            Log.d(TAG ""Display #"" + displayId + "" removed."");
            mDisplayListAdapter.updateContents();
        }
    };

    /**
     * Listens for when presentations are dismissed.
     */
    private final DialogInterface.OnDismissListener mOnDismissListener =
            new DialogInterface.OnDismissListener() {
        @Override
        public void onDismiss(DialogInterface dialog) {
            DemoPresentation presentation = (DemoPresentation)dialog;
            int displayId = presentation.getDisplay().getDisplayId();
            Log.d(TAG ""Presentation on display #"" + displayId + "" was dismissed."");
            mActivePresentations.delete(displayId);
            mDisplayListAdapter.notifyDataSetChanged();
        }
    };

    /**
     * List adapter.
     * Shows information about all displays.
     */
    private final class DisplayListAdapter extends ArrayAdapter<Display> {
        final Context mContext;

        public DisplayListAdapter(Context context) {
            super(context R.layout.presentation_list_item);
            mContext = context;
        }

        @Override
        public View getView(int position View convertView ViewGroup parent) {
            final View v;
            if (convertView == null) {
                v = ((Activity) mContext).getLayoutInflater().inflate(
                        R.layout.presentation_list_item null);
            } else {
                v = convertView;
            }

            final Display display = getItem(position);
            final int displayId = display.getDisplayId();

            DemoPresentation presentation = mActivePresentations.get(displayId);
            DemoPresentationContents contents = presentation != null ?
                    presentation.mContents : null;
            if (contents == null) {
                contents = mSavedPresentationContents.get(displayId);
            }

            CheckBox cb = (CheckBox)v.findViewById(R.id.checkbox_presentation);
            cb.setTag(display);
            cb.setOnCheckedChangeListener(PresentationActivity.this);
            cb.setChecked(contents != null);

            TextView tv = (TextView)v.findViewById(R.id.display_id);
            tv.setText(v.getContext().getResources().getString(
                    R.string.presentation_display_id_text displayId display.getName()));

            Button b = (Button)v.findViewById(R.id.info);
            b.setTag(display);
            b.setOnClickListener(PresentationActivity.this);

            Spinner s = (Spinner)v.findViewById(R.id.modes);
            Display.Mode[] modes = display.getSupportedModes();
            if (contents == null || modes.length == 1) {
                s.setVisibility(View.GONE);
                s.setAdapter(null);
            } else {
                ArrayAdapter<String> modeAdapter = new ArrayAdapter<String>(mContext
                        android.R.layout.simple_list_item_1);
                s.setVisibility(View.VISIBLE);
                s.setAdapter(modeAdapter);
                s.setTag(display);
                s.setOnItemSelectedListener(PresentationActivity.this);

                modeAdapter.add(""<default mode>"");

                for (Display.Mode mode : modes) {
                    modeAdapter.add(String.format(""Mode %d: %dx%d/%.1ffps""
                            mode.getModeId()
                            mode.getPhysicalWidth() mode.getPhysicalHeight()
                            mode.getRefreshRate()));
                    if (contents.displayModeId == mode.getModeId()) {
                        s.setSelection(modeAdapter.getCount() - 1);
                    }
                }
            }

            return v;
        }

        /**
         * Update the contents of the display list adapter to show
         * information about all current displays.
         */
        public void updateContents() {
            clear();

            String displayCategory = getDisplayCategory();
            Display[] displays = mDisplayManager.getDisplays(displayCategory);
            addAll(displays);

            Log.d(TAG ""There are currently "" + displays.length + "" displays connected."");
            for (Display display : displays) {
                Log.d(TAG ""  "" + display);
            }
        }

        private String getDisplayCategory() {
            return mShowAllDisplaysCheckbox.isChecked() ? null :
                DisplayManager.DISPLAY_CATEGORY_PRESENTATION;
        }
    }

    /**
     * The presentation to show on the secondary display.
     *
     * Note that the presentation display may have different metrics from the display on which
     * the main activity is showing so we must be careful to use the presentation's
     * own {@link Context} whenever we load resources.
     */
    private final class DemoPresentation extends Presentation {

        final DemoPresentationContents mContents;

        public DemoPresentation(Context context Display display
                DemoPresentationContents contents) {
            super(context display);
            mContents = contents;
        }

        /**
         * Sets the preferred display mode id for the presentation.
         */
        public void setPreferredDisplayMode(int modeId) {
            mContents.displayModeId = modeId;

            WindowManager.LayoutParams params = getWindow().getAttributes();
            params.preferredDisplayModeId = modeId;
            getWindow().setAttributes(params);
        }

        @Override
        protected void onCreate(Bundle savedInstanceState) {
            // Be sure to call the super class.
            super.onCreate(savedInstanceState);

            // Get the resources for the context of the presentation.
            // Notice that we are getting the resources from the context of the presentation.
            Resources r = getContext().getResources();

            // Inflate the layout.
            setContentView(R.layout.presentation_content);

            final Display display = getDisplay();
            final int displayId = display.getDisplayId();
            final int photo = mContents.photo;

            // Show a caption to describe what's going on.
            TextView text = (TextView)findViewById(R.id.text);
            text.setText(r.getString(R.string.presentation_photo_text
                    photo displayId display.getName()));

            // Show a n image for visual interest.
            ImageView image = (ImageView)findViewById(R.id.image);
            image.setImageDrawable(r.getDrawable(PHOTOS[photo]));

            GradientDrawable drawable = new GradientDrawable();
            drawable.setShape(GradientDrawable.RECTANGLE);
            drawable.setGradientType(GradientDrawable.RADIAL_GRADIENT);

            // Set the background to a random gradient.
            Point p = new Point();
            getDisplay().getSize(p);
            drawable.setGradientRadius(Math.max(p.x p.y) / 2);
            drawable.setColors(mContents.colors);
            findViewById(android.R.id.content).setBackground(drawable);
        }
    }

    /**
     * Information about the content we want to show in the presentation.
     */
    private final static class DemoPresentationContents implements Parcelable {
        final int photo;
        final int[] colors;
        int displayModeId;

        public static final Creator<DemoPresentationContents> CREATOR =
                new Creator<DemoPresentationContents>() {
            @Override
            public DemoPresentationContents createFromParcel(Parcel in) {
                return new DemoPresentationContents(in);
            }

            @Override
            public DemoPresentationContents[] newArray(int size) {
                return new DemoPresentationContents[size];
            }
        };

        public DemoPresentationContents(int photo) {
            this.photo = photo;
            colors = new int[] {
                    ((int) (Math.random() * Integer.MAX_VALUE)) | 0xFF000000
                    ((int) (Math.random() * Integer.MAX_VALUE)) | 0xFF000000 };
        }

        private DemoPresentationContents(Parcel in) {
            photo = in.readInt();
            colors = new int[] { in.readInt() in.readInt() };
            displayModeId = in.readInt();
        }

        @Override
        public int describeContents() {
            return 0;
        }

        @Override
        public void writeToParcel(Parcel dest int flags) {
            dest.writeInt(photo);
            dest.writeInt(colors[0]);
            dest.writeInt(colors[1]);
            dest.writeInt(displayModeId);
        }
    }
}","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.webkit.WebView: void clearView()>,"This method was deprecated
      in API level 18. Use WebView.loadUrl(""about:blank"") to reliably reset the view state
             and release page resources (including any running JavaScript). Clears this WebView so that onDraw() will draw nothing but white background
 and onMeasure() will return 0 if MeasureSpec is not MeasureSpec.EXACTLY.",,void,1,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",,,,,,,
"<android.widget.ArrayAdapter: View getDropDownView(int,View,ViewGroup)>","Gets a View that displays in the drop down popup
 the data at the specified position in the data set.","position int : index of the item whose view we want. |||
convertView View : This value may be null . |||
parent ViewGroup : This value cannot be null . |||","View a View corresponding to the data at the
         specified position. |||",1,"You can use this adapter to provide views for an  AdapterView 
 Returns a view for each object in a collection of data objects you
 provide and can be used with list-based user interface widgets such as
  ListView  or  Spinner .
  
 By default the array adapter creates a view by calling  Object#toString()  on each
 data object in the collection you provide and places the result in a TextView.
 You may also customize what type of view is used for the data object in the collection.
 To customize what type of view is used for the data object
 override  getView(int android.view.View android.view.ViewGroup) 
 and inflate a view resource.
 For a code example see
 the  
 CustomChoiceList  sample.
  
 For an example of using an array adapter with a ListView see the
  
 Adapter Views  guide.
  
 For an example of using an array adapter with a Spinner see the
  Spinners  guide.
  Note: 
 If you are considering using array adapter with a ListView consider using
  RecyclerView  instead.
 RecyclerView offers similar features with better performance and more flexibility than
 ListView provides.
 See the
  
 Recycler View  guide.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
"<android.location.LocationManager: void requestSingleUpdate(String,PendingIntent)>","This method was deprecated
      in API level 30. Use getCurrentLocation(java.lang.String android.os.CancellationSignal java.util.concurrent.Executor java.util.function.Consumer) instead as it does not carry a risk of extreme battery drain. Register for a single location update using a named provider and pending intent. See requestLocationUpdates(long float android.location.Criteria android.app.PendingIntent) for more detail
 on how to use this method. Requires Manifest.permission.ACCESS_COARSE_LOCATION or Manifest.permission.ACCESS_FINE_LOCATION","provider String : a provider listed by getAllProviders() This value cannot be null . |||
pendingIntent PendingIntent : the pending intent to send location updates
This value cannot be null . |||",void,9,"A data class representing a geographic location.

  A location can consist of a latitude longitude timestamp
 and other information such as bearing altitude and velocity.

  All locations generated by the  LocationManager  are
 guaranteed to have a valid latitude longitude and timestamp
 (both UTC time and elapsed real-time since boot) all other
 parameters are optional.","Contains the framework API classes that define Android location-based and
 	related services. This API is not the recommended method for accessing Android location. 
 The
  Google Location Services API 
 part of Google Play services is the preferred way to add location-awareness to
 your app. It offers a simpler API higher accuracy low-power geofencing and
 more. If you are currently using the android.location API you are strongly
 encouraged to switch to the Google Location Services API as soon as
 possible.
  
 To learn more about the Google Location Services API see the
  Location API overview .",,,,,,,
<android.os.Bundle: ArrayList getIntegerArrayList(String)>,"Returns the value associated with the given key or null if
 no mapping of the desired type exists for the given key or a null
 value is explicitly associated with the key.","key String : a String or null
This value may be null . |||",ArrayList < Integer > an ArrayList value or null |||,1,A mapping from String keys to various  Parcelable  values.,,,,,,,,
"<android.bluetooth.BluetoothAdapter: BluetoothServerSocket listenUsingInsecureRfcommWithServiceRecord(String,UUID)>","Create a listening insecure RFCOMM Bluetooth socket with Service Record. The link key is not required to be authenticated i.e the communication may be
 vulnerable to Man In the Middle attacks. For Bluetooth 2.1 devices
 the link will be encrypted as encryption is mandartory.
 For legacy devices (pre Bluetooth 2.1 devices) the link will not
 be encrypted. Use listenUsingRfcommWithServiceRecord(String UUID) if an
 encrypted and authenticated communication channel is desired. Use BluetoothServerSocket#accept to retrieve incoming
 connections from a listening BluetoothServerSocket . The system will assign an unused RFCOMM channel to listen on. The system will also register a Service Discovery
 Protocol (SDP) record with the local SDP server containing the specified
 UUID service name and auto-assigned channel. Remote Bluetooth devices
 can use the same UUID to query our SDP server and discover which channel
 to connect to. This SDP record will be removed when this socket is
 closed or if this application closes unexpectedly. Use BluetoothDevice#createRfcommSocketToServiceRecord to
 connect to this socket from another device using the same UUID . Requires Manifest.permission.BLUETOOTH","name String : service name for SDP record |||
uuid UUID : uuid for SDP record |||",BluetoothServerSocket a listening RFCOMM BluetoothServerSocket |||,10,"Represents the local device Bluetooth adapter. The  BluetoothAdapter 
 lets you perform fundamental Bluetooth tasks such as initiate
 device discovery query a list of bonded (paired) devices
 instantiate a  BluetoothDevice  using a known MAC address and create
 a  BluetoothServerSocket  to listen for connection requests from other
 devices and start a scan for Bluetooth LE devices.

  To get a  BluetoothAdapter  representing the local Bluetooth
 adapter call the  BluetoothManager#getAdapter  function on  BluetoothManager .
 On JELLY_BEAN_MR1 and below you will need to use the static  getDefaultAdapter() 
 method instead.
  
 Fundamentally this is your starting point for all
 Bluetooth actions. Once you have the local adapter you can get a set of
  BluetoothDevice  objects representing all paired devices with
  getBondedDevices() ; start device discovery with
  startDiscovery() ; or create a  BluetoothServerSocket  to
 listen for incoming RFComm connection requests with  listenUsingRfcommWithServiceRecord(java.lang.String java.util.UUID) ; listen for incoming L2CAP Connection-oriented
 Channels (CoC) connection requests with  listenUsingL2capChannel() ; or start a scan for
 Bluetooth LE devices with  startLeScan(android.bluetooth.BluetoothAdapter.LeScanCallback) .
  This class is thread safe. Note: 
 Most methods require the  Manifest.permission.BLUETOOTH 
 permission and some also require the
  Manifest.permission.BLUETOOTH_ADMIN  permission.","Provides classes that manage Bluetooth functionality such as scanning for
 devices connecting with devices and managing data transfer between devices.
 The Bluetooth API supports both ""Classic Bluetooth"" and Bluetooth Low Energy. For more information about Classic Bluetooth see the
  Bluetooth  guide.
 For more information about Bluetooth Low Energy see the
  
 Bluetooth Low Energy  (BLE) guide. The Bluetooth APIs let applications: Scan for other Bluetooth devices (including BLE devices). Query the local Bluetooth adapter for paired Bluetooth devices. Establish RFCOMM channels/sockets. Connect to specified sockets on other devices. Transfer data to and from other devices. Communicate with BLE devices such as proximity sensors heart rate
     monitors fitness devices and so on. Act as a GATT client or a GATT server (BLE). 
 To perform Bluetooth communication using these APIs an application must
 declare the  BLUETOOTH  permission. Some
 additional functionality such as requesting device discovery
 also requires the  BLUETOOTH_ADMIN 
 permission.
  Note: 
 Not all Android-powered devices provide Bluetooth functionality.",,,,,,,
<android.view.ViewConfiguration: int getKeyRepeatTimeout()>,,,int the time before the first key repeat in milliseconds. |||,12,Contains methods to standard constants used in the UI for timeouts sizes and distances.,,,,,,,,
<android.content.ContextWrapper: File getExternalCacheDir()>,"Returns absolute path to application-specific directory on the primary
 shared/external storage device where the application can place cache
 files it owns. These files are internal to the application and not
 typically visible to the user as media. This is like getCacheDir() in that these files will be deleted
 when the application is uninstalled however there are some important
 differences: The platform does not always monitor the space available in shared
 storage and thus may not automatically delete these files. Apps should
 always manage the maximum space used in this location. Currently the only
 time files here will be deleted by the platform is when running on Build.VERSION_CODES.JELLY_BEAN_MR1 or later and Environment#isExternalStorageEmulated(File) returns true. 
Shared storage may not always be available since removable media can
 be ejected by the user. Media state can be checked using Environment#getExternalStorageState(File) . 
There is no security enforced with these files. For example any
 application holding Manifest.permission.WRITE_EXTERNAL_STORAGE can write to
 these files. 
If a shared storage device is emulated (as determined by Environment#isExternalStorageEmulated(File) ) its contents are
 backed by a private user data partition which means there is little
 benefit to storing data here instead of the private directory returned by getCacheDir() . Starting in Build.VERSION_CODES.KITKAT no permissions
 are required to read or write to the returned path; it's always
 accessible to the calling app. This only applies to paths generated for
 package name of the calling application. To access paths belonging to
 other packages Manifest.permission.WRITE_EXTERNAL_STORAGE and/or Manifest.permission.READ_EXTERNAL_STORAGE are required. On devices with multiple users (as described by UserManager )
 each user has their own isolated shared storage. Applications only have
 access to the shared storage for the user they're running as. The returned path may change over time if different shared storage media
 is inserted so only relative paths should be persisted.",,File the absolute path to application-specific directory. May return null if shared storage is not currently available. |||,8,"Proxying implementation of Context that simply delegates all of its calls to
 another Context.  Can be subclassed to modify behavior without changing
 the original Context.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
"<android.view.LayoutInflater: View inflate(int,ViewGroup)>",Inflate a new view hierarchy from the specified xml resource. Throws InflateException if there is an error.,"resource int : ID for an XML layout resource to load (e.g. R.layout.main_page ) |||
root ViewGroup : Optional view to be the parent of the generated hierarchy.
This value may be null . |||","View The root View of the inflated hierarchy. If root was supplied
         this is the root View; otherwise it is the root of the inflated
         XML file. |||",1,"Instantiates a layout XML file into its corresponding  View 
 objects. It is never used directly. Instead use
  Activity.getLayoutInflater()  or
  Context#getSystemService  to retrieve a standard LayoutInflater instance
 that is already hooked up to the current context and correctly configured
 for the device you are running on.

  
 To create a new LayoutInflater with an additional  Factory  for your
 own views you can use  cloneInContext(Context)  to clone an existing
 ViewFactory and then call  setFactory(LayoutInflater.Factory)  on it to include your
 Factory.

  
 For performance reasons view inflation relies heavily on pre-processing of
 XML files that is done at build time. Therefore it is not currently possible
 to use LayoutInflater with an XmlPullParser over a plain XML file at runtime;
 it only works with an XmlPullParser returned from a compiled resource
 (R. something  file.)",,,,,,,,
<android.bluetooth.BluetoothDevice: BluetoothSocket createRfcommSocketToServiceRecord(UUID)>,"Create an RFCOMM BluetoothSocket ready to start a secure
 outgoing connection to this remote device using SDP lookup of uuid. This is designed to be used with BluetoothAdapter#listenUsingRfcommWithServiceRecord for peer-peer
 Bluetooth applications. Use BluetoothSocket#connect to initiate the outgoing
 connection. This will also perform an SDP lookup of the given uuid to
 determine which channel to connect to. The remote device will be authenticated and communication on this
 socket will be encrypted. Use this socket only if an authenticated socket link is possible.
 Authentication refers to the authentication of the link key to
 prevent man-in-the-middle type of attacks.
 For example for Bluetooth 2.1 devices if any of the devices does not
 have an input and output capability or just has the ability to
 display a numeric key a secure socket connection is not possible.
 In such a case use createInsecureRfcommSocketToServiceRecord(UUID) .
 For more details refer to the Security Model section 5.2 (vol 3) of
 Bluetooth Core Specification version 2.1 + EDR. Hint: If you are connecting to a Bluetooth serial board then try
 using the well-known SPP UUID 00001101-0000-1000-8000-00805F9B34FB.
 However if you are connecting to an Android peer then please generate
 your own unique UUID. Requires Manifest.permission.BLUETOOTH",uuid UUID : service record uuid to lookup RFCOMM channel |||,BluetoothSocket a RFCOMM BluetoothServerSocket ready for an outgoing connection |||,5,"Represents a remote Bluetooth device. A  BluetoothDevice  lets you
 create a connection with the respective device or query information about
 it such as the name address class and bonding state.

  This class is really just a thin wrapper for a Bluetooth hardware
 address. Objects of this class are immutable. Operations on this class
 are performed on the remote Bluetooth hardware address using the
  BluetoothAdapter  that was used to create this  BluetoothDevice .

  To get a  BluetoothDevice  use
  BluetoothAdapter#getRemoteDevice(String)  to create one representing a device
 of a known MAC address (which you can get through device discovery with
  BluetoothAdapter ) or get one from the set of bonded devices
 returned by  BluetoothAdapter#getBondedDevices() . You can then open a
  BluetoothSocket  for communication with the remote device using
  createRfcommSocketToServiceRecord(java.util.UUID)  over Bluetooth BR/EDR or using
  createL2capChannel(int)  over Bluetooth LE.

  Note: 
 Requires the  Manifest.permission.BLUETOOTH  permission.","Provides classes that manage Bluetooth functionality such as scanning for
 devices connecting with devices and managing data transfer between devices.
 The Bluetooth API supports both ""Classic Bluetooth"" and Bluetooth Low Energy. For more information about Classic Bluetooth see the
  Bluetooth  guide.
 For more information about Bluetooth Low Energy see the
  
 Bluetooth Low Energy  (BLE) guide. The Bluetooth APIs let applications: Scan for other Bluetooth devices (including BLE devices). Query the local Bluetooth adapter for paired Bluetooth devices. Establish RFCOMM channels/sockets. Connect to specified sockets on other devices. Transfer data to and from other devices. Communicate with BLE devices such as proximity sensors heart rate
     monitors fitness devices and so on. Act as a GATT client or a GATT server (BLE). 
 To perform Bluetooth communication using these APIs an application must
 declare the  BLUETOOTH  permission. Some
 additional functionality such as requesting device discovery
 also requires the  BLUETOOTH_ADMIN 
 permission.
  Note: 
 Not all Android-powered devices provide Bluetooth functionality.",,,,,,,
<android.view.InputEvent: InputDevice getDevice()>,Gets the device that this event came from.,,InputDevice The device or null if unknown. |||,9,Common base class for input events.,,,,,,,,
<android.app.DialogFragment: void dismiss()>,"Dismiss the fragment and its dialog.  If the fragment was added to the
 back stack all back stack state up to and including this entry will
 be popped.  Otherwise a new transaction will be committed to remove
 the fragment.",,void,11,"Base class for Dialogs.

  Note: Activities provide a facility to manage the creation saving and
 restoring of dialogs. See  Activity#onCreateDialog(int) 
  Activity#onPrepareDialog(int Dialog) 
  Activity#showDialog(int)  and  Activity#dismissDialog(int) . If
 these methods are used  getOwnerActivity()  will return the Activity
 that managed this dialog.

  Often you will want to have a Dialog display on top of the current
 input method because there is no reason for it to accept text.  You can
 do this by setting the  WindowManager.LayoutParams#FLAG_ALT_FOCUSABLE_IM  window flag (assuming
 your Dialog takes input focus as it the default) with the following code:

  
 getWindow().setFlags(WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM
         WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.content.ContentResolver: String getType(Uri)>,Return the MIME type of the given content URL.,"url Uri : A Uri identifying content (either a list or specific type)
using the content:// scheme.
This value cannot be null . |||",String A MIME type for the content or null if the URL is invalid or the type is unknown |||,1,This class provides applications access to the content model.,"Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.app.AlertDialog: void setMessage(CharSequence)>,,message CharSequence |||,void,1,"A subclass of Dialog that can display one two or three buttons. If you only want to
 display a String in this dialog box use the setMessage() method.  If you
 want to display a more complex view look up the FrameLayout called ""custom""
 and add your view to it:

  
 FrameLayout fl = findViewById(android.R.id.custom);
 fl.addView(myView new LayoutParams(MATCH_PARENT WRAP_CONTENT));
  The AlertDialog class takes care of automatically setting
  WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM  for you based on whether
 any views in the dialog return true from  View#onCheckIsTextEditor() .  Generally you want this set for a Dialog
 without text editors so that it will be placed on top of the current
 input method UI.  You can modify this behavior by forcing the flag to your
 desired mode after calling  onCreate(Bundle) .","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
"<android.widget.SimpleCursorTreeAdapter: void setViewText(TextView,String)>","Called by bindView() to set the text for a TextView but only if
 there is no existing ViewBinder or if the existing ViewBinder cannot
 handle binding to a TextView.

 Intended to be overridden by Adapters that need to filter strings
 retrieved from the database.","v TextView : TextView to receive text |||
text String : the text to be set for the TextView |||",void,5,"An easy adapter to map columns from a cursor to TextViews or ImageViews
 defined in an XML file. You can specify which columns you want which views
 you want to display the columns and the XML file that defines the appearance
 of these views. Separate XML files for child and groups are possible.

 Binding occurs in two phases. First if a
  SimpleCursorTreeAdapter.ViewBinder  is available
  ViewBinder#setViewValue(android.view.View android.database.Cursor int) 
 is invoked. If the returned value is true binding has occurred. If the
 returned value is false and the view to bind is a TextView
  setViewText(android.widget.TextView java.lang.String)  is invoked. If the returned value
 is false and the view to bind is an ImageView
  setViewImage(android.widget.ImageView java.lang.String)  is invoked. If no appropriate
 binding can be found an  IllegalStateException  is thrown.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.net.http.SslCertificate: Bundle saveState(SslCertificate)>,Saves the certificate state to a bundle,certificate SslCertificate : The SSL certificate to store |||,Bundle A bundle with the certificate stored in it or null if fails |||,1,SSL certificate info (certificate details) class,,,,,,,,
<android.view.SurfaceView: void setVisibility(int)>,Set the visibility state of this view.,"visibility int : One of View.VISIBLE  View.INVISIBLE or View.GONE .
Value is View.VISIBLE  View.INVISIBLE or View.GONE |||",void,1,"Handle onto a raw buffer that is being managed by the screen compositor.

  A Surface is generally created by or from a consumer of image buffers (such as a
  SurfaceTexture   MediaRecorder  or
  Allocation ) and is handed to some kind of producer (such as
  OpenGL 
  MediaPlayer  or
  CameraDevice ) to draw
 into. Note:  A Surface acts like a
  weak reference  to the consumer it is associated with. By
 itself it will not keep its parent consumer from being reclaimed.",,,,,,,,
"<android.preference.PreferenceActivity: void finishPreferencePanel(Fragment,int,Intent)>",Called by a preference panel fragment to finish itself.,"caller Fragment : The fragment that is asking to be finished. |||
resultCode int : Optional result code to send back to the original
launching fragment. |||
resultData Intent : Optional result data to send back to the original
launching fragment. |||",void,11,"This is the base class for an activity to show a hierarchy of preferences
 to the user.  Prior to  Build.VERSION_CODES.HONEYCOMB 
 this class only allowed the display of a single set of preference; this
 functionality should now be found in the new  PreferenceFragment 
 class.  If you are using PreferenceActivity in its old mode the documentation
 there applies to the deprecated APIs here.

  This activity shows one or more headers of preferences each of which
 is associated with a  PreferenceFragment  to display the preferences
 of that header.  The actual layout and display of these associations can
 however vary; currently there are two major approaches it may take:

  On a small screen it may display only the headers as a single list when first launched.
 Selecting one of the header items will only show the PreferenceFragment of that header (on
 Android N and lower a new Activity is launched).
  On a large screen it may display both the headers and current PreferenceFragment together as
 panes. Selecting a header item switches to showing the correct PreferenceFragment for that item.
  Subclasses of PreferenceActivity should implement
  onBuildHeaders(List )  to populate the header list with the desired
 items.  Doing this implicitly switches the class into its new ""headers
 + fragments"" mode rather than the old style of just showing a single
 preferences list.",,,,,,,,
"<android.content.res.Resources: CharSequence getQuantityText(int,int)>","Returns the character sequence necessary for grammatically correct pluralization
 of the given resource ID for the given quantity.
 Note that the character sequence is selected based solely on grammatical necessity
 and that such rules differ between languages. Do not assume you know which string
 will be returned for a given quantity. See String Resources for more detail.","id int : The desired resource identifier as generated by the aapt
tool. This integer encodes the package type and resource
entry. The value 0 is an invalid identifier. |||
quantity int : The number used to get the correct string for the current language's
plural rules. |||","CharSequence CharSequence The string data associated with the resource plus
         possibly styled text information.
 
 This value cannot be null . |||",1,"Class for accessing an application's resources.  This sits on top of the
 asset manager of the application (accessible through  getAssets() ) and
 provides a high-level API for getting typed data from the assets.

  The Android resource system keeps track of all non-code assets associated with an
 application. You can use this class to access your application's resources. You can generally
 acquire the  Resources  instance associated with your application
 with  getResources() . The Android SDK tools compile your application's resources into the application binary
 at build time.  To use a resource you must install it correctly in the source tree (inside
 your project's  res/  directory) and build your application.  As part of the build
 process the SDK tools generate symbols for each resource which you can use in your application
 code to access the resources. Using application resources makes it easy to update various characteristics of your
 application without modifying code and—by providing sets of alternative
 resources—enables you to optimize your application for a variety of device configurations
 (such as for different languages and screen sizes). This is an important aspect of developing
 Android applications that are compatible on different types of devices. For more information about using resources see the documentation about  Application Resources .","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.text.Selection: void removeSelection(Spannable)>,Remove the selection or cursor if any from the text.,text Spannable |||,void,1,"Utility class for manipulating cursors and selections in CharSequences.
 A cursor is a selection where the start and end are at the same offset.","Provides classes used to render or track text and text spans on the screen. You can use these classes to design your own widgets that manage text
 to handle arbitrary text spans for changes or to handle drawing yourself
 for an existing widget. The Span… interfaces and classes are used to create or manage spans of
 text in a View item. You can use these to style the text or background or to
 listen for changes. If creating your own widget extend DynamicLayout to manages
 the actual wrapping and drawing of your text.",,,,,,,
<android.widget.TextView: void setGravity(int)>,"Sets the horizontal alignment of the text and the
 vertical gravity that will be used when there is extra space
 in the TextView beyond what is required for the text itself. Related XML Attributes: android:gravity",gravity int |||,void,1,"A user interface element that displays text to the user.
 To provide user-editable text see  EditText .
  
 The following code sample shows a typical use with an XML layout
 and code to modify the contents of the text view:
  
 <LinearLayout
      xmlns:android=""http://schemas.android.com/apk/res/android""
      android:layout_width=""match_parent""
      android:layout_height=""match_parent"">
    <TextView
        android:id=""@+id/text_view_id""
        android:layout_height=""wrap_content""
        android:layout_width=""wrap_content""
        android:text=""@string/hello"" />
 </LinearLayout>
  
 This code sample demonstrates how to modify the contents of the text view
 defined in the previous XML layout:
  
 public class MainActivity extends Activity {

    protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_main);
         final TextView helloTextView = (TextView) findViewById(R.id.text_view_id);
         helloTextView.setText(R.string.user_greeting);
     }
 }
  
 To customize the appearance of TextView see  Styles and Themes .
  XML attributes 
 See  TextView Attributes 
  View Attributes","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
"<android.app.Dialog: void setFeatureDrawableUri(int,Uri)>",Convenience for calling Window.setFeatureDrawableUri(int Uri) .,"featureId int |||
uri Uri : This value may be null . |||",void,1,"Base class for Dialogs.

  Note: Activities provide a facility to manage the creation saving and
 restoring of dialogs. See  Activity#onCreateDialog(int) 
  Activity#onPrepareDialog(int Dialog) 
  Activity#showDialog(int)  and  Activity#dismissDialog(int) . If
 these methods are used  getOwnerActivity()  will return the Activity
 that managed this dialog.

  Often you will want to have a Dialog display on top of the current
 input method because there is no reason for it to accept text.  You can
 do this by setting the  WindowManager.LayoutParams#FLAG_ALT_FOCUSABLE_IM  window flag (assuming
 your Dialog takes input focus as it the default) with the following code:

  
 getWindow().setFlags(WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM
         WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.speech.tts.TextToSpeech: String getDefaultEngine()>,Gets the package name of the default speech synthesis engine.,,"String Package name of the TTS engine that the user has chosen
        as their default. |||",8,"Synthesizes speech from text for immediate playback or to create a sound file.
  A TextToSpeech instance can only be used to synthesize text once it has completed its
 initialization. Implement the  TextToSpeech.OnInitListener  to be
 notified of the completion of the initialization. 
 When you are done using the TextToSpeech instance call the  shutdown()  method
 to release the native resources used by the TextToSpeech engine.",,,,,,,,
"<android.media.MediaPlayer: void setDataSource(Context,Uri)>",Sets the data source as a content Uri.,"context Context : the Context to use when resolving the Uri
This value cannot be null . |||
uri Uri : the Content URI of the data you want to play
This value cannot be null . |||",void,1,"MediaPlayer class can be used to control playback
 of audio/video files and streams. An example on how to use the methods in
 this class can be found in  VideoView .

  Topics covered here are:
  State Diagram Valid and Invalid States Permissions Register informational and error callbacks","The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",,,,,,,
<android.view.KeyCharacterMap: KeyCharacterMap load(int)>,Loads the key character maps for the keyboard with the specified device id.,deviceId int : The device id of the keyboard. |||,KeyCharacterMap The associated key character map. |||,1,Describes the keys provided by a keyboard device and their associated labels.,,,,,,,,
<android.widget.BaseExpandableListAdapter: void notifyDataSetChanged()>,,,void,1,"Base class for a  ExpandableListAdapter  used to provide data and Views
 from some data to an expandable list view.
  
 Adapters inheriting this class should verify that the base implementations of
  getCombinedChildId(long long)  and  getCombinedGroupId(long) 
 are correct in generating unique IDs from the group/children IDs.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
"<android.media.SoundPool: int load(String,int)>",Load the sound from the specified path.,"path String : the path to the audio file |||
priority int : the priority of the sound. Currently has no effect. Use
a value of 1 for future compatibility. |||",int a sound ID. This value can be used to play or unload the sound. |||,1,"The SoundPool class manages and plays audio resources for applications.

  A SoundPool is a collection of samples that can be loaded into memory
 from a resource inside the APK or from a file in the file system. The
 SoundPool library uses the MediaPlayer service to decode the audio
 into a raw 16-bit PCM mono or stereo stream. This allows applications
 to ship with compressed streams without having to suffer the CPU load
 and latency of decompressing during playback. In addition to low-latency playback SoundPool can also manage the number
 of audio streams being rendered at once. When the SoundPool object is
 constructed the maxStreams parameter sets the maximum number of streams
 that can be played at a time from this single SoundPool. SoundPool tracks
 the number of active streams. If the maximum number of streams is exceeded
 SoundPool will automatically stop a previously playing stream based first
 on priority and then by age within that priority. Limiting the maximum
 number of streams helps to cap CPU loading and reducing the likelihood that
 audio mixing will impact visuals or UI performance. Sounds can be looped by setting a non-zero loop value. A value of -1
 causes the sound to loop forever. In this case the application must
 explicitly call the stop() function to stop the sound. Any other non-zero
 value will cause the sound to repeat the specified number of times e.g.
 a value of 3 causes the sound to play a total of 4 times. The playback rate can also be changed. A playback rate of 1.0 causes
 the sound to play at its original frequency (resampled if necessary
 to the hardware output frequency). A playback rate of 2.0 causes the
 sound to play at twice its original frequency and a playback rate of
 0.5 causes it to play at half its original frequency. The playback
 rate range is 0.5 to 2.0. Priority runs low to high i.e. higher numbers are higher priority.
 Priority is used when a call to play() would cause the number of active
 streams to exceed the value established by the maxStreams parameter when
 the SoundPool was created. In this case the stream allocator will stop
 the lowest priority stream. If there are multiple streams with the same
 low priority it will choose the oldest stream to stop. In the case
 where the priority of the new stream is lower than all the active
 streams the new sound will not play and the play() function will return
 a streamID of zero. Let's examine a typical use case: A game consists of several levels of
 play. For each level there is a set of unique sounds that are used only
 by that level. In this case the game logic should create a new SoundPool
 object when the first level is loaded. The level data itself might contain
 the list of sounds to be used by this level. The loading logic iterates
 through the list of sounds calling the appropriate SoundPool.load()
 function. This should typically be done early in the process to allow time
 for decompressing the audio to raw PCM format before they are needed for
 playback. Once the sounds are loaded and play has started the application can
 trigger sounds by calling SoundPool.play(). Playing streams can be
 paused or resumed and the application can also alter the pitch by
 adjusting the playback rate in real-time for doppler or synthesis
 effects. Note that since streams can be stopped due to resource constraints the
 streamID is a reference to a particular instance of a stream. If the stream
 is stopped to allow a higher priority stream to play the stream is no
 longer valid. However the application is allowed to call methods on
 the streamID without error. This may help simplify program logic since
 the application need not concern itself with the stream lifecycle. In our example when the player has completed the level the game
 logic should call SoundPool.release() to release all the native resources
 in use and then set the SoundPool reference to null. If the player starts
 another level a new SoundPool is created sounds are loaded and play
 resumes.","The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",,,,,,,
<android.widget.TabHost: void setCurrentTabByTag(String)>,Sets the current tab based on its tag.,tag String : the tag for the tab to set as current |||,void,1,"Container for a tabbed window view. This object holds two children: a set of tab labels that the
 user clicks to select a specific tab and a FrameLayout object that displays the contents of that
 page. The individual elements are typically controlled using this container object rather than
 setting values on the child elements themselves.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.app.Activity: void openOptionsMenu()>,"Programmatically opens the options menu. If the options menu is already
 open this method does nothing.",,void,1,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.preference.DialogPreference: void setNegativeButtonText(int)>,,negativeButtonTextResId int : The negative button text as a resource. |||,void,1,"A base class for  Preference  objects that are
 dialog-based. These preferences will when clicked open a dialog showing the
 actual preference controls.",,,,,,,,
<android.app.Dialog: void setContentView(View)>,"Set the screen content to an explicit view.  This view is placed
 directly into the screen's view hierarchy.  It can itself be a complex
 view hierarchy.","view View : The desired content to display.
This value cannot be null . |||",void,1,"Base class for Dialogs.

  Note: Activities provide a facility to manage the creation saving and
 restoring of dialogs. See  Activity#onCreateDialog(int) 
  Activity#onPrepareDialog(int Dialog) 
  Activity#showDialog(int)  and  Activity#dismissDialog(int) . If
 these methods are used  getOwnerActivity()  will return the Activity
 that managed this dialog.

  Often you will want to have a Dialog display on top of the current
 input method because there is no reason for it to accept text.  You can
 do this by setting the  WindowManager.LayoutParams#FLAG_ALT_FOCUSABLE_IM  window flag (assuming
 your Dialog takes input focus as it the default) with the following code:

  
 getWindow().setFlags(WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM
         WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.media.MediaActionSound: void play(int)>,"Play one of the predefined platform sounds for media actions. Use this method to play a platform-specific sound for various media
 actions. The sound playback is done asynchronously with the same
 behavior and content as the sounds played by Camera.takePicture  MediaRecorder.start and MediaRecorder.stop . With the camera2 API this method can be used to play
 standard camera operation sounds with the appropriate system behavior for such sounds. With the older Camera API using this method makes it easy to
 match the default device sounds when recording or capturing data through the preview
 callbacks or when implementing custom camera-like features in your application. If the sound has not been loaded by load(int) before calling play
 play will load the sound at the cost of some additional latency before
 sound playback begins.","soundName int : The type of sound to play selected from
SHUTTER_CLICK FOCUS_COMPLETE START_VIDEO_RECORDING or
STOP_VIDEO_RECORDING. |||",void,16,"A class for producing sounds that match those produced by various actions
 taken by the media and camera APIs.   This class is recommended for use with the  android.hardware.camera2  API since the
 camera2 API does not play any sounds on its own for any capture or video recording actions. With the older  Camera  API use this class to play an appropriate
 camera operation sound when implementing a custom still or video recording mechanism (through the
 Camera preview callbacks with
  Camera.setPreviewCallback  or through GPU
 processing with  Camera.setPreviewTexture  for
 example) or when implementing some other camera-like function in your application. There is no need to play sounds when using
  Camera.takePicture  or
  MediaRecorder  for still images or video respectively
 as the Android framework will play the appropriate sounds when needed for
 these calls.","The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",,,,,,,
<android.view.inputmethod.InputConnectionWrapper: int getCursorCapsMode(int)>,"Retrieve the current capitalization mode in effect at the
 current cursor position in the text. See TextUtils.getCapsMode for more information. This method may fail either if the input connection has
 become invalid (such as its process crashing) or the client is
 taking too long to respond with the text (it is given a couple
 seconds to return). In either case 0 is returned. This method does not affect the text in the editor in any
 way nor does it affect the selection or composing spans. Editor authors: please be careful of race
 conditions in implementing this call. An IME can change the
 cursor position and use this method right away; you need to make
 sure the returned value is consistent with the results of the
 latest edits and changes to the cursor position.","reqModes int : The desired modes to retrieve as defined by TextUtils.getCapsMode . These
constants are defined so that you can simply pass the current EditorInfo#inputType value
directly in to here. |||","int the caps mode flags that are in effect at the current
 cursor position. See TYPE_TEXT_FLAG_CAPS_* in InputType . |||",3,Wrapper class for proxying calls to another InputConnection.  Subclass and have fun!,,,,,,,,
"<android.content.ContentProviderClient: AssetFileDescriptor openAssetFile(Uri,String)>","See ContentProvider#openAssetFile .
 Note that this does not take care of non-content: URIs such as file:.  It is strongly recommended
 you use the ContentResolver#openAssetFileDescriptor API instead.","url Uri : This value cannot be null . |||
mode String : This value cannot be null . |||",AssetFileDescriptor This value may be null . |||,5,"Content providers are one of the primary building blocks of Android applications providing
 content to applications. They encapsulate data and provide it to applications through the single
  ContentResolver  interface. A content provider is only required if you need to share
 data between multiple applications. For example the contacts data is used by multiple
 applications and must be stored in a content provider. If you don't need to share data amongst
 multiple applications you can use a database directly via
  SQLiteDatabase .

  When a request is made via
 a  ContentResolver  the system inspects the authority of the given URI and passes the
 request to the content provider registered with the authority. The content provider can interpret
 the rest of the URI however it wants. The  UriMatcher  class is helpful for parsing
 URIs. The primary methods that need to be implemented are:
  onCreate()  which is called to initialize the provider query(Uri String[] Bundle CancellationSignal)  which returns data to the caller insert(Uri ContentValues)  which inserts new data into the content provider update(Uri ContentValues String String[])  which updates existing data in the content provider delete(Uri String String[])  which deletes data from the content provider getType(Uri)  which returns the MIME type of data in the content provider Requests to  ContentResolver  are automatically forwarded to the appropriate
 ContentProvider instance so subclasses don't have to worry about the details of
 cross-process calls.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.preference.PreferenceFragment: void onCreate(Bundle)>,"Called to do initial creation of a fragment.  This is called after onAttach(android.app.Activity) and before onCreateView(android.view.LayoutInflater android.view.ViewGroup android.os.Bundle) but is not called if the fragment
 instance is retained across Activity re-creation (see setRetainInstance(boolean) ). Note that this can be called while the fragment's activity is
 still in the process of being created.  As such you can not rely
 on things like the activity's content view hierarchy being initialized
 at this point.  If you want to do work once the activity itself is
 created see onActivityCreated(android.os.Bundle) . If your app's targetSdkVersion is Build.VERSION_CODES.M or lower child fragments being restored from the savedInstanceState are restored after onCreate returns. When targeting Build.VERSION_CODES.N or
 above and running on an N or newer platform version
 they are restored by Fragment.onCreate .",savedInstanceState Bundle : This value may be null . |||,void,11,"Represents the basic Preference UI building
 block displayed by a  PreferenceActivity  in the form of a
  ListView . This class provides the  View  to be displayed in
 the activity and associates with a  SharedPreferences  to
 store/retrieve the preference data.
  
 When specifying a preference hierarchy in XML each element can point to a
 subclass of  Preference  similar to the view hierarchy and layouts.
  
 This class contains a  key  that will be used as the key into the
  SharedPreferences . It is up to the subclass to decide how to store
 the value.",,,,,,,,
<android.app.MediaRouteButton: void showDialog()>,"Show the route chooser or controller dialog. If the default route is selected or if the currently selected route does
 not match the route types then shows the route chooser dialog.
 Otherwise shows the route controller dialog to offer the user
 a choice to disconnect from the route or perform other control actions
 such as setting the route's volume. This will attach a DialogFragment to the containing Activity.",,void,16,,"Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
"<android.view.inputmethod.InputMethodManager: void showStatusIcon(IBinder,String,int)>","This method was deprecated
      in API level 28. Use InputMethodService#showStatusIcon(int) instead. This method was
 intended for IME developers who should be accessing APIs through the service. APIs in this
 class are intended for app developers interacting with the IME.","imeToken IBinder |||
packageName String |||
iconId int |||",void,3,"Central system API to the overall input method framework (IMF) architecture
 which arbitrates interaction between applications and the current input method.

  Topics covered here:
  Architecture Overview Applications Input Methods Security Architecture Overview There are three primary parties involved in the input method
 framework (IMF) architecture:  The  input method manager  as expressed by this class
 is the central point of the system that manages interaction between all
 other parts.  It is expressed as the client-side API here which exists
 in each application context and communicates with a global system service
 that manages the interaction across all processes.
   An  input method (IME)  implements a particular
 interaction model allowing the user to generate text.  The system binds
 to the current input method that is in use causing it to be created and run
 and tells it when to hide and show its UI.  Only one IME is running at a time.
   Multiple  client applications  arbitrate with the input
 method manager for input focus and control over the state of the IME.  Only
 one such client is ever active (working with the IME) at a time.
  Applications In most cases applications that are using the standard
  TextView  or its subclasses will have little they need
 to do to work well with soft input methods.  The main things you need to
 be aware of are:  Properly set the  R.attr.inputType  in your editable
 text views so that the input method will have enough context to help the
 user in entering text into them.
   Deal well with losing screen space when the input method is
 displayed.  Ideally an application should handle its window being resized
 smaller but it can rely on the system performing panning of the window
 if needed.  You should set the  R.attr.windowSoftInputMode 
 attribute on your activity or the corresponding values on windows you
 create to help the system determine whether to pan or resize (it will
 try to determine this automatically but may get it wrong).
   You can also control the preferred soft input state (open closed etc)
 for your window using the same  R.attr.windowSoftInputMode 
 attribute.
  More finer-grained control is available through the APIs here to directly
 interact with the IMF and its IME -- either showing or hiding the input
 area letting the user pick an input method etc. For the rare people amongst us writing their own text editors you
 will need to implement  View.onCreateInputConnection(EditorInfo) 
 to return a new instance of your own  InputConnection  interface
 allowing the IME to interact with your editor. Input Methods An input method (IME) is implemented
 as a  Service  typically deriving from
  InputMethodService .  It must provide
 the core  InputMethod  interface though this is normally handled by
  InputMethodService  and implementors will
 only need to deal with the higher-level API there. InputMethodService Security There are a lot of security issues associated with input methods
 since they essentially have freedom to completely drive the UI and monitor
 everything the user enters.  The Android input method framework also allows
 arbitrary third party IMEs so care must be taken to restrict their
 selection and interactions. Here are some key points about the security architecture behind the
 IMF: Only the system is allowed to directly access an IME's
  InputMethod  interface via the
  Manifest.permission.BIND_INPUT_METHOD  permission.  This is
 enforced in the system by not binding to an input method service that does
 not require this permission so the system can guarantee no other untrusted
 clients are accessing the current input method outside of its control. There may be many client processes of the IMF but only one may
 be active at a time.  The inactive clients can not interact with key
 parts of the IMF through the mechanisms described below. Clients of an input method are only given access to its
  InputMethodSession  interface.  One instance of this interface is
 created for each client and only calls from the session associated with
 the active client will be processed by the current IME.  This is enforced
 by  AbstractInputMethodService  for normal
 IMEs but must be explicitly handled by an IME that is customizing the
 raw  InputMethodSession  implementation. Only the active client's  InputConnection  will accept
 operations.  The IMF tells each client process whether it is active and
 the framework enforces that in inactive processes calls on to the current
 InputConnection will be ignored.  This ensures that the current IME can
 only deliver events and text edits to the UI that the user sees as
 being in focus. An IME can never interact with an  InputConnection  while
 the screen is off.  This is enforced by making all clients inactive while
 the screen is off and prevents bad IMEs from driving the UI when the user
 can not be aware of its behavior. A client application can ask that the system let the user pick a
 new IME but can not programmatically switch to one itself.  This avoids
 malicious applications from switching the user to their own IME which
 remains running when the user navigates away to another application.  An
 IME on the other hand  is  allowed to programmatically switch
 the system to another IME since it already has full control of user
 input. The user must explicitly enable a new IME in settings before
 they can switch to it to confirm with the system that they know about it
 and want to make it available for use. PackageManager#FEATURE_INPUT_METHODS PackageManager.hasSystemFeature(String)",,,,,,,,
<android.widget.TextView: void setText(CharSequence)>,"Sets the text to be displayed. TextView does not accept
 HTML-like formatting which you can do with text strings in XML resource files.
 To style your strings attach android.text.style.* objects to a SpannableString or see the Available Resource Types documentation for an example of setting
 formatted text in the XML resource file. Related XML Attributes: android:text",text CharSequence : text to be displayed |||,void,1,"A user interface element that displays text to the user.
 To provide user-editable text see  EditText .
  
 The following code sample shows a typical use with an XML layout
 and code to modify the contents of the text view:
  
 <LinearLayout
      xmlns:android=""http://schemas.android.com/apk/res/android""
      android:layout_width=""match_parent""
      android:layout_height=""match_parent"">
    <TextView
        android:id=""@+id/text_view_id""
        android:layout_height=""wrap_content""
        android:layout_width=""wrap_content""
        android:text=""@string/hello"" />
 </LinearLayout>
  
 This code sample demonstrates how to modify the contents of the text view
 defined in the previous XML layout:
  
 public class MainActivity extends Activity {

    protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_main);
         final TextView helloTextView = (TextView) findViewById(R.id.text_view_id);
         helloTextView.setText(R.string.user_greeting);
     }
 }
  
 To customize the appearance of TextView see  Styles and Themes .
  XML attributes 
 See  TextView Attributes 
  View Attributes","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.app.DatePickerDialog: Bundle onSaveInstanceState()>,"Saves the state of the dialog into a bundle.

 The default implementation saves the state of its view hierarchy so you'll
 likely want to call through to super if you override this to save additional
 state.",,"Bundle A bundle with the state of the dialog.
 
 This value cannot be null . |||",1,"A simple dialog containing an  DatePicker .
  
 See the  Pickers 
 guide.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.widget.AbsListView: void setRemoteViewsAdapter(Intent)>,"Sets up this AbsListView to use a remote views adapter which connects to a RemoteViewsService
 through the specified intent.",intent Intent : the intent used to identify the RemoteViewsService for the adapter to connect to. |||,void,11,"Base class that can be used to implement virtualized lists of items. A list does
 not have a spatial definition here. For instance subclasses of this class can
 display the content of the list in a grid in a carousel as stack etc.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.view.View: void setScrollX(int)>,"Set the horizontal scrolled position of your view. This will cause a call to onScrollChanged(int int int int) and the view will be
 invalidated.",value int : the x position to scroll to |||,void,14,"This class represents the basic building block for user interface components. A View
 occupies a rectangular area on the screen and is responsible for drawing and
 event handling. View is the base class for  widgets  which are
 used to create interactive UI components (buttons text fields etc.). The
  ViewGroup  subclass is the base class for  layouts  which
 are invisible containers that hold other Views (or other ViewGroups) and define
 their layout properties.",,,,,,,,
"<android.test.TouchUtils: void dragViewToBottom(InstrumentationTestCase,Activity,View)>",Simulate touching the center of a view and dragging to the bottom of the screen.,"test InstrumentationTestCase : The test case that is being run |||
activity Activity : The activity that is in the foreground of the test case |||
v View : The view that should be dragged |||",void,3,"Reusable methods for generating touch events. These methods can be used with
 InstrumentationTestCase or ActivityInstrumentationTestCase2 to simulate user interaction with
 the application through a touch screen.",,,,,,,,
<android.media.AudioManager: int getVibrateSetting(int)>,"This method was deprecated
      in API level 16. Applications should maintain their own vibrate policy based on
 current ringer mode that can be queried via getRingerMode() . Returns whether the user's vibrate setting for a vibrate type. This shouldn't be needed by most clients that want to vibrate instead
 see shouldVibrate(int) .",vibrateType int : The type of vibrate. One of VIBRATE_TYPE_NOTIFICATION or VIBRATE_TYPE_RINGER . |||,int The vibrate setting one of VIBRATE_SETTING_ON  VIBRATE_SETTING_OFF or VIBRATE_SETTING_ONLY_SILENT . |||,1,AudioManager provides access to volume and ringer mode control.,"The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",,,,,,,
<android.accounts.AccountManager: void removeOnAccountsUpdatedListener(OnAccountsUpdateListener)>,"Removes an OnAccountsUpdateListener previously registered with addOnAccountsUpdatedListener(OnAccountsUpdateListener Handler boolean) .  The listener will no longer
 receive notifications of account changes. It is safe to call this method from the main thread. No permission is required to call this method.",listener OnAccountsUpdateListener : The previously added listener to remove |||,void,5,"This class provides access to a centralized registry of the user's
 online accounts.  The user enters credentials (username and password) once
 per account granting applications access to online resources with
 ""one-click"" approval.

  Different online services have different ways of handling accounts and
 authentication so the account manager uses pluggable  authenticator 
 modules for different  account types .  Authenticators (which may be
 written by third parties) handle the actual details of validating account
 credentials and storing account information.  For example Google Facebook
 and Microsoft Exchange each have their own authenticator.

  Many servers support some notion of an  authentication token 
 which can be used to authenticate a request to the server without sending
 the user's actual password.  (Auth tokens are normally created with a
 separate request which does include the user's credentials.)  AccountManager
 can generate auth tokens for applications so the application doesn't need to
 handle passwords directly.  Auth tokens are normally reusable and cached by
 AccountManager but must be refreshed periodically.  It's the responsibility
 of applications to  invalidate  auth tokens when they stop working so
 the AccountManager knows it needs to regenerate them.

  Applications accessing a server normally go through these steps:

  Get an instance of AccountManager using  get(android.content.Context) .

  List the available accounts using  getAccountsByType(String)  or
  getAccountsByTypeAndFeatures(String String[] AccountManagerCallback  Handler) .  Normally applications will only
 be interested in accounts with one particular  type  which
 identifies the authenticator.  Account  features  are used to
 identify particular account subtypes and capabilities.  Both the account
 type and features are authenticator-specific strings and must be known by
 the application in coordination with its preferred authenticators.

  Select one or more of the available accounts possibly by asking the
 user for their preference.  If no suitable accounts are available
  addAccount(String String String[] Bundle Activity AccountManagerCallback  Handler)  may be called to prompt the user to create an
 account of the appropriate type.

  Important:  If the application is using a previously remembered
 account selection it must make sure the account is still in the list
 of accounts returned by  getAccountsByType(String) .  Requesting an auth token
 for an account no longer on the device results in an undefined failure.

  Request an auth token for the selected account(s) using one of the
  getAuthToken(Account String Bundle Activity AccountManagerCallback  Handler)  methods or related helpers.  Refer to the description
 of each method for exact usage and error handling details.

  Make the request using the auth token.  The form of the auth token
 the format of the request and the protocol used are all specific to the
 service you are accessing.  The application may use whatever network and
 protocol libraries are useful.

  Important:  If the request fails with an authentication error
 it could be that a cached auth token is stale and no longer honored by
 the server.  The application must call  invalidateAuthToken(String String)  to remove
 the token from the cache otherwise requests will continue failing!  After
 invalidating the auth token immediately go back to the ""Request an auth
 token"" step above.  If the process fails the second time then it can be
 treated as a ""genuine"" authentication failure and the user notified or other
 appropriate actions taken.
  Some AccountManager methods may need to interact with the user to
 prompt for credentials present options or ask the user to add an account.
 The caller may choose whether to allow AccountManager to directly launch the
 necessary user interface and wait for the user or to return an Intent which
 the caller may use to launch the interface or (in some cases) to install a
 notification which the user can select at any time to launch the interface.
 To have AccountManager launch the interface directly the caller must supply
 the current foreground  Activity  context.

  Many AccountManager methods take  AccountManagerCallback  and
  Handler  as parameters.  These methods return immediately and
 run asynchronously. If a callback is provided then
  AccountManagerCallback#run  will be invoked on the Handler's
 thread when the request completes successfully or not.
 The result is retrieved by calling  AccountManagerFuture#getResult() 
 on the  AccountManagerFuture  returned by the method (and also passed
 to the callback).  This method waits for the operation to complete (if
 necessary) and either returns the result or throws an exception if an error
 occurred during the operation.  To make the request synchronously call
  AccountManagerFuture#getResult()  immediately on receiving the
 future from the method; no callback need be supplied.

  Requests which may block including
  AccountManagerFuture#getResult()  must never be called on
 the application's main event thread.  These operations throw
  IllegalStateException  if they are used on the main thread.",,,,,,,,
<android.widget.RatingBar: void setStepSize(float)>,Sets the step size (granularity) of this rating bar.,"stepSize float : The step size of this rating bar. For example if
half-star granularity is wanted this would be 0.5. |||",void,1,"A RatingBar is an extension of SeekBar and ProgressBar that shows a rating in
 stars. The user can touch/drag or use arrow keys to set the rating when using
 the default size RatingBar. The smaller RatingBar style (
  R.attr.ratingBarStyleSmall ) and the larger indicator-only
 style ( R.attr.ratingBarStyleIndicator ) do not support user
 interaction and should only be used as indicators.
  
 When using a RatingBar that supports user interaction placing widgets to the
 left or right of the RatingBar is discouraged.
  
 The number of stars set (via  setNumStars(int)  or in an XML layout)
 will be shown when the layout width is set to wrap content (if another layout
 width is set the results may be unpredictable).
  
 The secondary progress should not be modified by the client as it is used
 internally as the background for a fractionally filled star.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.net.sip.SipAudioCall: void continueCall(int)>,"Continues a call that's on hold. When succeeds Listener#onCallEstablished is called. The attempt will be timed
 out if the call is not established within timeout seconds and Listener#onError will be called.","timeout int : the timeout value in seconds. Default value (defined by
SIP protocol) is used if timeout is zero or negative. |||",void,9,"Handles an Internet audio call over SIP. You can instantiate this class with  SipManager 
 using  SipManager#makeAudioCall  and   SipManager#takeAudioCall .

  Note:  Using this class require the
    Manifest.permission.INTERNET  and
    Manifest.permission.USE_SIP  permissions. In addition  startAudio()  requires the
    Manifest.permission.RECORD_AUDIO 
    Manifest.permission.ACCESS_WIFI_STATE  and
    Manifest.permission.WAKE_LOCK  permissions; and  setSpeakerMode()  requires the
    Manifest.permission.MODIFY_AUDIO_SETTINGS  permission.",,,,,,,,
<android.widget.AdapterViewAnimator: void showNext()>,Manually shows the next child.,,void,11,"An AdapterView is a view whose children are determined by an  Adapter .

  
 See  ListView   GridView   Spinner  and
       Gallery  for commonly used subclasses of AdapterView.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
"<android.telephony.gsm.SmsManager: void sendMultipartTextMessage(String,String,ArrayList,ArrayList,ArrayList)>","This method was deprecated
      in API level 4. Use android.telephony.SmsManager. Send a multi-part text based SMS.  The callee should have already
 divided the message into correctly sized parts by calling divideMessage .","destinationAddress String : the address to send the message to |||
scAddress String : is the service center address or null to use
the current default SMSC |||
parts ArrayList : an ArrayList of strings that in order
comprise the original message |||
sentIntents ArrayList : if not null an ArrayList of PendingIntent s (one for each message part) that is
broadcast when the corresponding message part has been sent.
The result code will be Activity.RESULT_OK for success
or one of these errors: RESULT_ERROR_GENERIC_FAILURE RESULT_ERROR_RADIO_OFF RESULT_ERROR_NULL_PDU .
The per-application based SMS control checks sentIntent. If sentIntent
is NULL the caller will be checked against all unknown applicaitons
which cause smaller number of SMS to be sent in checking period. |||
deliveryIntents ArrayList : if not null an ArrayList of PendingIntent s (one for each message part) that is
broadcast when the corresponding message part has been delivered
to the recipient.  The raw pdu of the status report is in the
extended data (""pdu""). |||",void,1,"Manages SMS operations such as sending data text and pdu SMS messages.
 Get this object by calling the static method SmsManager.getDefault().",,,,,,,,
<android.view.ViewGroup: void removeAllViews()>,"Call this method to remove all child views from the
 ViewGroup. Note: do not invoke this method from View.draw(android.graphics.Canvas)  View.onDraw(android.graphics.Canvas)  dispatchDraw(android.graphics.Canvas) or any related method.",,void,1,"A  ViewGroup  is a special view that can contain other views
 (called children.) The view group is the base class for layouts and views
 containers. This class also defines the
  ViewGroup.LayoutParams  class which serves as the base
 class for layouts parameters.
  
 Also see  LayoutParams  for layout attributes.",,,,,,,,
<android.appwidget.AppWidgetManager: int getAppWidgetIds(ComponentName)>,"Get the list of appWidgetIds that have been bound to the given AppWidget
 provider.","provider ComponentName : The BroadcastReceiver that is the
AppWidget provider to find appWidgetIds for. |||",int[] |||,3,"Updates AppWidget state; gets information about installed AppWidget providers and other
 AppWidget related state.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.app.Activity: Intent getParentActivityIntent()>,"Obtain an Intent that will launch an explicit target activity specified by
 this activity's logical parent. The logical parent is named in the application's manifest
 by the parentActivityName attribute.
 Activity subclasses may override this method to modify the Intent returned by
 super.getParentActivityIntent() or to implement a different mechanism of retrieving
 the parent intent entirely.",,"Intent a new Intent targeting the defined parent of this activity or null if
         there is no valid parent. |||",16,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
"<android.accounts.AccountManager: AccountManagerFuture editProperties(String,Activity,AccountManagerCallback,Handler)>","Offers the user an opportunity to change an authenticator's settings.
 These properties are for the authenticator in general not a particular
 account.  Not all authenticators support this method. This method may be called from any thread but the returned AccountManagerFuture must not be used on the main thread. This method requires the caller to have the same signature as the
 authenticator associated with the specified account type. NOTE: If targeting your app to work on API level 22 and before
 MANAGE_ACCOUNTS permission is needed for those platforms. See docs
 for this function in API level 22. Requires android.Manifest.permission.MANAGE_ACCOUNTS","accountType String : The account type associated with the authenticator
to adjust |||
activity Activity : The Activity context to use for launching a new
authenticator-defined sub-Activity to adjust authenticator settings;
used only to call startActivity(); if null the settings dialog will
not be launched directly but the necessary Intent will be
returned to the caller instead |||
callback AccountManagerCallback : Callback to invoke when the request completes
null for no callback |||
handler Handler : Handler identifying the callback thread
null for the main thread |||","AccountManagerFuture < Bundle > An AccountManagerFuture which resolves to a Bundle
     which is empty if properties were edited successfully or
     if no activity was specified contains only KEY_INTENT needed to launch the authenticator's settings dialog.
     If an error occurred AccountManagerFuture#getResult() throws: AuthenticatorException if no authenticator was registered for
      this account type or the authenticator failed to respond OperationCanceledException if the operation was canceled for
      any reason including the user canceling the settings dialog IOException if the authenticator experienced an I/O problem
      updating settings usually because of network trouble |||",5,"This class provides access to a centralized registry of the user's
 online accounts.  The user enters credentials (username and password) once
 per account granting applications access to online resources with
 ""one-click"" approval.

  Different online services have different ways of handling accounts and
 authentication so the account manager uses pluggable  authenticator 
 modules for different  account types .  Authenticators (which may be
 written by third parties) handle the actual details of validating account
 credentials and storing account information.  For example Google Facebook
 and Microsoft Exchange each have their own authenticator.

  Many servers support some notion of an  authentication token 
 which can be used to authenticate a request to the server without sending
 the user's actual password.  (Auth tokens are normally created with a
 separate request which does include the user's credentials.)  AccountManager
 can generate auth tokens for applications so the application doesn't need to
 handle passwords directly.  Auth tokens are normally reusable and cached by
 AccountManager but must be refreshed periodically.  It's the responsibility
 of applications to  invalidate  auth tokens when they stop working so
 the AccountManager knows it needs to regenerate them.

  Applications accessing a server normally go through these steps:

  Get an instance of AccountManager using  get(android.content.Context) .

  List the available accounts using  getAccountsByType(String)  or
  getAccountsByTypeAndFeatures(String String[] AccountManagerCallback  Handler) .  Normally applications will only
 be interested in accounts with one particular  type  which
 identifies the authenticator.  Account  features  are used to
 identify particular account subtypes and capabilities.  Both the account
 type and features are authenticator-specific strings and must be known by
 the application in coordination with its preferred authenticators.

  Select one or more of the available accounts possibly by asking the
 user for their preference.  If no suitable accounts are available
  addAccount(String String String[] Bundle Activity AccountManagerCallback  Handler)  may be called to prompt the user to create an
 account of the appropriate type.

  Important:  If the application is using a previously remembered
 account selection it must make sure the account is still in the list
 of accounts returned by  getAccountsByType(String) .  Requesting an auth token
 for an account no longer on the device results in an undefined failure.

  Request an auth token for the selected account(s) using one of the
  getAuthToken(Account String Bundle Activity AccountManagerCallback  Handler)  methods or related helpers.  Refer to the description
 of each method for exact usage and error handling details.

  Make the request using the auth token.  The form of the auth token
 the format of the request and the protocol used are all specific to the
 service you are accessing.  The application may use whatever network and
 protocol libraries are useful.

  Important:  If the request fails with an authentication error
 it could be that a cached auth token is stale and no longer honored by
 the server.  The application must call  invalidateAuthToken(String String)  to remove
 the token from the cache otherwise requests will continue failing!  After
 invalidating the auth token immediately go back to the ""Request an auth
 token"" step above.  If the process fails the second time then it can be
 treated as a ""genuine"" authentication failure and the user notified or other
 appropriate actions taken.
  Some AccountManager methods may need to interact with the user to
 prompt for credentials present options or ask the user to add an account.
 The caller may choose whether to allow AccountManager to directly launch the
 necessary user interface and wait for the user or to return an Intent which
 the caller may use to launch the interface or (in some cases) to install a
 notification which the user can select at any time to launch the interface.
 To have AccountManager launch the interface directly the caller must supply
 the current foreground  Activity  context.

  Many AccountManager methods take  AccountManagerCallback  and
  Handler  as parameters.  These methods return immediately and
 run asynchronously. If a callback is provided then
  AccountManagerCallback#run  will be invoked on the Handler's
 thread when the request completes successfully or not.
 The result is retrieved by calling  AccountManagerFuture#getResult() 
 on the  AccountManagerFuture  returned by the method (and also passed
 to the callback).  This method waits for the operation to complete (if
 necessary) and either returns the result or throws an exception if an error
 occurred during the operation.  To make the request synchronously call
  AccountManagerFuture#getResult()  immediately on receiving the
 future from the method; no callback need be supplied.

  Requests which may block including
  AccountManagerFuture#getResult()  must never be called on
 the application's main event thread.  These operations throw
  IllegalStateException  if they are used on the main thread.",,,,,,,,
<android.view.ViewPropertyAnimator: ViewPropertyAnimator rotationBy(float)>,"This method will cause the View's rotation property to be animated by the
 specified value. Animations already running on the property will be canceled.",value float : The amount to be animated by as an offset from the current value. |||,ViewPropertyAnimator This object allowing calls to methods in this class to be chained. |||,12,"This class enables automatic and optimized animation of select properties on View objects.
 If only one or two properties on a View object are being animated then using an
  ObjectAnimator  is fine; the property setters called by ObjectAnimator
 are well equipped to do the right thing to set the property and invalidate the view
 appropriately. But if several properties are animated simultaneously or if you just want a
 more convenient syntax to animate a specific property then ViewPropertyAnimator might be
 more well-suited to the task.

  This class may provide better performance for several simultaneous animations because
 it will optimize invalidate calls to take place only once for several properties instead of each
 animated property independently causing its own invalidation. Also the syntax of using this
 class could be easier to use because the caller need only tell the View object which
 property to animate and the value to animate either to or by and this class handles the
 details of configuring the underlying Animator class and starting it. This class is not constructed by the caller but rather by the View whose properties
 it will animate. Calls to  View.animate()  will return a reference
 to the appropriate ViewPropertyAnimator object for that View.",,,,,,,,
"<android.content.ContextWrapper: void sendStickyOrderedBroadcast(Intent,BroadcastReceiver,Handler,int,String,Bundle)>","This method is deprecated. Sticky broadcasts should not be used.  They provide no security (anyone
 can access them) no protection (anyone can modify them) and many other problems.
 The recommended pattern is to use a non-sticky broadcast to report that something has changed with another mechanism for apps to retrieve the current value whenever
 desired. Version of sendStickyBroadcast(Intent) that allows you to
 receive data back from the broadcast.  This is accomplished by
 supplying your own BroadcastReceiver when calling which will be
 treated as a final receiver at the end of the broadcast -- its BroadcastReceiver#onReceive method will be called with
 the result values collected from the other receivers.  The broadcast will
 be serialized in the same way as calling sendOrderedBroadcast(android.content.Intent java.lang.String) . Like sendBroadcast(android.content.Intent) this method is
 asynchronous; it will return before
 resultReceiver.onReceive() is called.  Note that the sticky data
 stored is only the data you initially supply to the broadcast not
 the result of any changes made by the receivers. See BroadcastReceiver for more information on Intent broadcasts. Requires Manifest.permission.BROADCAST_STICKY","intent Intent : The Intent to broadcast; all receivers matching this
Intent will receive the broadcast. |||
resultReceiver BroadcastReceiver : Your own BroadcastReceiver to treat as the final
receiver of the broadcast. |||
scheduler Handler : A custom Handler with which to schedule the
resultReceiver callback; if null it will be
scheduled in the Context's main thread.
This value may be null . |||
initialCode int : An initial value for the result code.  Often
Activity.RESULT_OK. |||
initialData String : An initial value for the result data.  Often
null.
This value may be null . |||
initialExtras Bundle : An initial value for the result extras.  Often
null.
This value may be null . |||",void,5,"Proxying implementation of Context that simply delegates all of its calls to
 another Context.  Can be subclassed to modify behavior without changing
 the original Context.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.media.MediaActionSound: void load(int)>,"Preload a predefined platform sound to minimize latency when the sound is
 played later by play(int) .","soundName int : The type of sound to preload selected from
SHUTTER_CLICK FOCUS_COMPLETE START_VIDEO_RECORDING or
STOP_VIDEO_RECORDING. |||",void,16,"A class for producing sounds that match those produced by various actions
 taken by the media and camera APIs.   This class is recommended for use with the  android.hardware.camera2  API since the
 camera2 API does not play any sounds on its own for any capture or video recording actions. With the older  Camera  API use this class to play an appropriate
 camera operation sound when implementing a custom still or video recording mechanism (through the
 Camera preview callbacks with
  Camera.setPreviewCallback  or through GPU
 processing with  Camera.setPreviewTexture  for
 example) or when implementing some other camera-like function in your application. There is no need to play sounds when using
  Camera.takePicture  or
  MediaRecorder  for still images or video respectively
 as the Android framework will play the appropriate sounds when needed for
 these calls.","The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",,,,,,,
<android.speech.tts.TextToSpeechService: void onCreate()>,Called by the system when the service is first created.  Do not call this method directly.,,void,14,"Abstract base class for TTS engine implementations. The following methods
 need to be implemented:
  onIsLanguageAvailable(String String String) onLoadLanguage(String String String) onGetLanguage() onSynthesizeText(SynthesisRequest SynthesisCallback) onStop() onSynthesizeText(SynthesisRequest SynthesisCallback) onStop() onGetLanguage() onGetVoices() onIsValidVoiceName(java.lang.String) onLoadVoice(java.lang.String) onGetDefaultVoiceNameFor(java.lang.String java.lang.String java.lang.String) onGetLanguage() onIsLanguageAvailable(String String String) onLoadLanguage(String String String) onGetDefaultVoiceNameFor(java.lang.String java.lang.String java.lang.String) TextToSpeech#setLanguage TextToSpeech#setVoice onGetDefaultVoiceNameFor(java.lang.String java.lang.String java.lang.String) SynthesisRequest",,,,,,,,
<android.app.TaskStackBuilder: void startActivities()>,Start the task stack constructed by this builder.,,void,16,"Utility class for constructing synthetic back stacks for cross-task navigation
 on Android 3.0 and newer.

  In API level 11 (Android 3.0/Honeycomb) the recommended conventions for
 app navigation using the back key changed. The back key's behavior is local
 to the current task and does not capture navigation across different tasks.
 Navigating across tasks and easily reaching the previous task is accomplished
 through the ""recents"" UI accessible through the software-provided Recents key
 on the navigation or system bar. On devices with the older hardware button configuration
 the recents UI can be accessed with a long press on the Home key. When crossing from one task stack to another post-Android 3.0
 the application should synthesize a back stack/history for the new task so that
 the user may navigate out of the new task and back to the Launcher by repeated
 presses of the back key. Back key presses should not navigate across task stacks. TaskStackBuilder provides a way to obey the correct conventions
 around cross-task navigation.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
"<android.database.AbstractCursor: void copyStringToBuffer(int,CharArrayBuffer)>","Retrieves the requested column text and stores it in the buffer provided.
 If the buffer size is not sufficient a new char buffer will be allocated
 and assigned to CharArrayBuffer.data","columnIndex int : the zero-based index of the target column.
if the target column is null return buffer |||
buffer CharArrayBuffer : the buffer to copy the text into. |||",void,1,"This is an abstract cursor class that handles a lot of the common code
 that all cursors need to deal with and is provided for convenience reasons.","If you need to manage data in a private database use the  android.database.sqlite  classes. These classes are used to manage the  Cursor  object returned from a content provider query. Databases
 are usually created and opened with  openOrCreateDatabase(String int SQLiteDatabase.CursorFactory) 
 To make requests through
 content providers you can use the  content.ContentResolver  class.
  All databases are stored on the device in  /data/data/<package_name>/databases",,,,,,,
<android.widget.GridView: void smoothScrollByOffset(int)>,"Smoothly scroll to the specified adapter position offset. The view will
 scroll such that the indicated position is displayed.",offset int : The amount to offset from the adapter position to scroll to. |||,void,11,"A view that shows items in two-dimensional scrolling grid. The items in the
 grid come from the  ListAdapter  associated with this view.

  See the  Grid
 View  guide.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
"<android.accounts.AccountManager: AccountManagerFuture hasFeatures(Account,String,AccountManagerCallback,Handler)>","Finds out whether a particular account has all the specified features. Account features are
 authenticator-specific string tokens identifying boolean account properties. For example
 features are used to tell whether Google accounts have a particular service (such as Google
 Calendar or Google Talk) enabled. The feature names and their meanings are published
 somewhere associated with the authenticator in question. This method may be called from any thread but the returned AccountManagerFuture must
 not be used on the main thread. If caller target API level is below Build.VERSION_CODES.O it is
 required to hold the permission Manifest.permission.GET_ACCOUNTS or have a
 signature match with the AbstractAccountAuthenticator that manages the account.","account Account : The Account to test |||
features String : An array of the account features to check |||
callback AccountManagerCallback : Callback to invoke when the request completes null for no callback |||
handler Handler : Handler identifying the callback thread null for the main thread |||","AccountManagerFuture < Boolean > An AccountManagerFuture which resolves to a Boolean true if the account
         exists and has all of the specified features. |||",8,"This class provides access to a centralized registry of the user's
 online accounts.  The user enters credentials (username and password) once
 per account granting applications access to online resources with
 ""one-click"" approval.

  Different online services have different ways of handling accounts and
 authentication so the account manager uses pluggable  authenticator 
 modules for different  account types .  Authenticators (which may be
 written by third parties) handle the actual details of validating account
 credentials and storing account information.  For example Google Facebook
 and Microsoft Exchange each have their own authenticator.

  Many servers support some notion of an  authentication token 
 which can be used to authenticate a request to the server without sending
 the user's actual password.  (Auth tokens are normally created with a
 separate request which does include the user's credentials.)  AccountManager
 can generate auth tokens for applications so the application doesn't need to
 handle passwords directly.  Auth tokens are normally reusable and cached by
 AccountManager but must be refreshed periodically.  It's the responsibility
 of applications to  invalidate  auth tokens when they stop working so
 the AccountManager knows it needs to regenerate them.

  Applications accessing a server normally go through these steps:

  Get an instance of AccountManager using  get(android.content.Context) .

  List the available accounts using  getAccountsByType(String)  or
  getAccountsByTypeAndFeatures(String String[] AccountManagerCallback  Handler) .  Normally applications will only
 be interested in accounts with one particular  type  which
 identifies the authenticator.  Account  features  are used to
 identify particular account subtypes and capabilities.  Both the account
 type and features are authenticator-specific strings and must be known by
 the application in coordination with its preferred authenticators.

  Select one or more of the available accounts possibly by asking the
 user for their preference.  If no suitable accounts are available
  addAccount(String String String[] Bundle Activity AccountManagerCallback  Handler)  may be called to prompt the user to create an
 account of the appropriate type.

  Important:  If the application is using a previously remembered
 account selection it must make sure the account is still in the list
 of accounts returned by  getAccountsByType(String) .  Requesting an auth token
 for an account no longer on the device results in an undefined failure.

  Request an auth token for the selected account(s) using one of the
  getAuthToken(Account String Bundle Activity AccountManagerCallback  Handler)  methods or related helpers.  Refer to the description
 of each method for exact usage and error handling details.

  Make the request using the auth token.  The form of the auth token
 the format of the request and the protocol used are all specific to the
 service you are accessing.  The application may use whatever network and
 protocol libraries are useful.

  Important:  If the request fails with an authentication error
 it could be that a cached auth token is stale and no longer honored by
 the server.  The application must call  invalidateAuthToken(String String)  to remove
 the token from the cache otherwise requests will continue failing!  After
 invalidating the auth token immediately go back to the ""Request an auth
 token"" step above.  If the process fails the second time then it can be
 treated as a ""genuine"" authentication failure and the user notified or other
 appropriate actions taken.
  Some AccountManager methods may need to interact with the user to
 prompt for credentials present options or ask the user to add an account.
 The caller may choose whether to allow AccountManager to directly launch the
 necessary user interface and wait for the user or to return an Intent which
 the caller may use to launch the interface or (in some cases) to install a
 notification which the user can select at any time to launch the interface.
 To have AccountManager launch the interface directly the caller must supply
 the current foreground  Activity  context.

  Many AccountManager methods take  AccountManagerCallback  and
  Handler  as parameters.  These methods return immediately and
 run asynchronously. If a callback is provided then
  AccountManagerCallback#run  will be invoked on the Handler's
 thread when the request completes successfully or not.
 The result is retrieved by calling  AccountManagerFuture#getResult() 
 on the  AccountManagerFuture  returned by the method (and also passed
 to the callback).  This method waits for the operation to complete (if
 necessary) and either returns the result or throws an exception if an error
 occurred during the operation.  To make the request synchronously call
  AccountManagerFuture#getResult()  immediately on receiving the
 future from the method; no callback need be supplied.

  Requests which may block including
  AccountManagerFuture#getResult()  must never be called on
 the application's main event thread.  These operations throw
  IllegalStateException  if they are used on the main thread.",,,,,,,,
<android.os.Bundle: ArrayList getParcelableArrayList(String)>,"Returns the value associated with the given key or null if
 no mapping of the desired type exists for the given key or a null value is explicitly associated with the key. Note: if the expected value is not a class provided by the Android platform
 you must call setClassLoader(java.lang.ClassLoader) with the proper ClassLoader first.
 Otherwise this method might throw an exception or return null .",key String : a String or null This value may be null . |||,ArrayList <T> an ArrayList value or null |||,1,A mapping from String keys to various  Parcelable  values.,,,,,,,,
<android.app.admin.DeviceAdminReceiver: DevicePolicyManager getManager(Context)>,"Retrieve the DevicePolicyManager interface for this administrator to work
 with the system.",context Context : This value cannot be null . |||,DevicePolicyManager This value cannot be null . |||,8,"Base class for implementing a device administration component.  This
 class provides a convenience for interpreting the raw intent actions
 that are sent by the system.

  The callback methods like the base
  BroadcastReceiver#onReceive(Context Intent) 
 method happen on the main thread of the process.  Thus long running
 operations must be done on another thread.  Note that because a receiver
 is done once returning from its receive function such long-running operations
 should probably be done in a  Service .

  When publishing your DeviceAdmin subclass as a receiver it must
 handle  ACTION_DEVICE_ADMIN_ENABLED  and require the
  Manifest.permission.BIND_DEVICE_ADMIN  permission.  A typical
 manifest entry would look like: <receiver android:name="".app.DeviceAdminSample$DeviceAdminSampleReceiver""
        android:label=""@string/sample_device_admin""
        android:description=""@string/sample_device_admin_description""
        android:permission=""android.permission.BIND_DEVICE_ADMIN"">
    <meta-data android:name=""android.app.device_admin""
               android:resource=""@xml/device_admin_sample"" />
    <intent-filter>
        <action android:name=""android.app.action.DEVICE_ADMIN_ENABLED"" />
    </intent-filter>
</receiver>
<receiver android:name="".app.DeviceAdminSample$DeviceAdminSampleReceiver2""
    android:label=""@string/sample_device_admin2""
    android:description=""@string/sample_device_admin_description2""
    android:permission=""android.permission.BIND_DEVICE_ADMIN"">
    <meta-data android:name=""android.app.device_admin""
        android:resource=""@xml/device_admin_sample"" />
    <intent-filter>
        <action android:name=""android.app.action.DEVICE_ADMIN_ENABLED"" />
    </intent-filter>
</receiver> The meta-data referenced here provides addition information specific
 to the device administrator as parsed by the  DeviceAdminInfo  class.
 A typical file would be: <device-admin xmlns:android=""http://schemas.android.com/apk/res/android"">
    <uses-policies>
        <limit-password />
        <watch-login />
        <reset-password />
        <force-lock />
        <wipe-data />
        <expire-password />
        <encrypted-storage />
        <disable-camera />
        <disable-keyguard-features />
    </uses-policies>
</device-admin>","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
"<android.os.Bundle: void putSerializable(String,Serializable)>","Inserts a Serializable value into the mapping of this Bundle replacing
 any existing value for the given key.  Either key or value may be null.","key String : a String or null
This value may be null . |||
value Serializable : a Serializable object or null
This value may be null . |||",void,1,A mapping from String keys to various  Parcelable  values.,,,,,,,,
"<android.text.method.LinkMovementMethod: void initialize(TextView,Spannable)>",,"widget TextView |||
text Spannable |||",void,1,"A movement method that traverses links in the text buffer and scrolls if necessary.
 Supports clicking on links with DPad Center or Enter.","Provides classes that monitor or modify keypad input. You can use these classes to modify the type of keypad entry
 for your application or decipher the keypresses entered for your specific
 entry method. For example: 
 // Set the text to password display style:
 EditText txtView = (EditText)findViewById(R.id.text);
 txtView.setTransformationMethod(PasswordTransformationMethod.getInstance());

 //Set the input style to numbers rather than qwerty keyboard style.
 txtView.setInputMethod(DigitsInputMethod.getInstance());

 // Find out whether the caps lock is on.
 // 0 is no 1 is yes 2 is caps lock on.
 int active = MultiTapInputMethod.getCapsActive(txtView.getText());",,,,,,,
<android.app.LocalActivityManager: void dispatchCreate(Bundle)>,"Restore a state that was previously returned by saveInstanceState() .  This
 adds to the activity group information about all activity IDs that had
 previously been saved even if they have not been started yet so if the
 user later navigates to them the correct state will be restored. Note: This does not change the current running activity or
 start whatever activity was previously running when the state was saved.
 That is up to the client to do in whatever way it thinks is best.",state Bundle : a previously saved state; does nothing if this is null |||,void,1,"Helper class for managing multiple running embedded activities in the same
 process. This class is not normally used directly but rather created for
 you as part of the  ActivityGroup  implementation.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
"<android.app.Instrumentation: void callActivityOnPostCreate(Activity,Bundle)>","Perform calling of an activity's Activity#onPostCreate method.
 The default implementation simply calls through to that method.","activity Activity : The activity being created.
This value cannot be null . |||
savedInstanceState Bundle : The previously saved state (or null) to pass through to
onPostCreate().
This value may be null . |||",void,1,"Base class for implementing application instrumentation code.  When running
 with instrumentation turned on this class will be instantiated for you
 before any of the application code allowing you to monitor all of the
 interaction the system has with the application.  An Instrumentation
 implementation is described to the system through an AndroidManifest.xml's
 <instrumentation> tag.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
"<android.nfc.NdefMessage: void writeToParcel(Parcel,int)>",Flatten this object in to a Parcel.,"dest Parcel : The Parcel in which the object should be written. |||
flags int : Additional flags about how the object should be written.
May be 0 or Parcelable.PARCELABLE_WRITE_RETURN_VALUE .
Value is either 0 or a combination of Parcelable.PARCELABLE_WRITE_RETURN_VALUE and android.os.Parcelable.PARCELABLE_ELIDE_DUPLICATES |||",void,9,"Represents an immutable NDEF Message.
  
 NDEF (NFC Data Exchange Format) is a light-weight binary format
 used to encapsulate typed data. It is specified by the NFC Forum
 for transmission and storage with NFC however it is transport agnostic.
  
 NDEF defines messages and records. An NDEF Record contains
 typed data such as MIME-type media a URI or a custom
 application payload. An NDEF Message is a container for
 one or more NDEF Records.
  
 When an Android device receives an NDEF Message
 (for example by reading an NFC tag) it processes it through
 a dispatch mechanism to determine an activity to launch.
 The type of the  first  record in the message has
 special importance for message dispatch so design this record
 carefully.
  
 Use  NdefMessage(byte[])  to construct an NDEF Message from
 binary data or  NdefMessage(android.nfc.NdefRecord[])  to
 construct from one or more  NdefRecord s.
  NdefMessage  and  NdefRecord  implementations are
 always available even on Android devices that do not have NFC hardware.
  NdefRecord s are intended to be immutable (and thread-safe)
 however they may contain mutable fields. So take care not to modify
 mutable fields passed into constructors or modify mutable fields
 obtained by getter methods unless such modification is explicitly
 marked as safe.","Provides access to Near Field Communication (NFC) functionality allowing applications to read
 NDEF message in NFC tags. A ""tag"" may actually be another device that appears as a tag. For more information see the
  Near Field Communication  guide. Here's a summary of the classes: NfcManager This is the high level manager used to obtain this device's  NfcAdapter . You can
 acquire an instance using  getSystemService(Class ) . NfcAdapter This represents the device's NFC adapter which is your entry-point to performing NFC
 operations. You can acquire an instance with  getDefaultAdapter()  or
  getDefaultAdapter(android.content.Context) . NdefMessage Represents an NDEF data message which is the standard format in which ""records""
 carrying data are transmitted between devices and tags. Your application can receive these
 messages from an  ACTION_TAG_DISCOVERED  intent. NdefRecord Represents a record which is delivered in a  NdefMessage  and describes the
 type of data being shared and carries the data itself. Note: 
 Not all Android-powered devices provide NFC functionality.",,,,,,,
"<android.text.SpannableStringBuilder: SpannableStringBuilder replace(int,int,CharSequence,int,int)>","Replaces the specified range ( st…en ) of text in this
 Editable with a copy of the slice start…end from source .  The destination slice may be empty in which case
 the operation is an insertion or the source slice may be empty
 in which case the operation is a deletion. Before the change is committed each filter that was set with setFilters(InputFilter[]) is given the opportunity to modify the source text. If source is Spanned the spans from it are preserved into the Editable.
 Existing spans within the Editable that entirely cover the replaced
 range are retained but any that were strictly within the range
 that was replaced are removed. If the source contains a span
 with Spanned#SPAN_PARAGRAPH flag and it does not satisfy the
 paragraph boundary constraint it is not retained. As a special case the
 cursor position is preserved even when the entire range where it is located
 is replaced.","start int |||
end int |||
tb CharSequence |||
tbstart int |||
tbend int |||",SpannableStringBuilder a reference to this object. |||,1,"This is the class for text whose content is immutable but to which
 markup objects can be attached and detached.
 For mutable text see  SpannableStringBuilder .","Provides classes used to render or track text and text spans on the screen. You can use these classes to design your own widgets that manage text
 to handle arbitrary text spans for changes or to handle drawing yourself
 for an existing widget. The Span… interfaces and classes are used to create or manage spans of
 text in a View item. You can use these to style the text or background or to
 listen for changes. If creating your own widget extend DynamicLayout to manages
 the actual wrapping and drawing of your text.",,,,,,,
"<android.util.Log: int wtf(String,String,Throwable)>","What a Terrible Failure: Report an exception that should never happen.
 Similar to wtf(java.lang.String java.lang.Throwable) with a message as well.","tag String : Used to identify the source of a log message.
This value may be null . |||
msg String : The message you would like logged.
This value may be null . |||
tr Throwable : An exception to log.  May be null.
This value may be null . |||",int |||,8,"API for sending log output.

  Generally you should use the  Log.v()   Log.d() 
  Log.i()   Log.w()  and  Log.e()  methods to write logs.
 You can then  view the logs in logcat .

  The order in terms of verbosity from least to most is
 ERROR WARN INFO DEBUG VERBOSE.  Verbose should never be compiled
 into an application except during development.  Debug logs are compiled
 in but stripped at runtime.  Error warning and info logs are always kept.

  Tip:  A good convention is to declare a  TAG  constant
 in your class:

  private static final String TAG = ""MyActivity""; Tip:  Don't forget that when you make a call like
  Log.v(TAG ""index="" + i);",,,,,,,,
<android.os.storage.StorageVolume: String getDescription(Context)>,Returns a user-visible description of the volume.,context Context |||,String the volume description |||,24,"Information about a shared/external storage volume for a specific user.

  
 A device always has one (and one only) primary storage volume but it could have extra volumes
 like SD cards and USB drives. This object represents the logical view of a storage
 volume for a specific user: different users might have different views for the same physical
 volume (for example if the volume is a built-in emulated storage).

  
 The storage volume is not necessarily mounted applications should use  getState()  to
 verify its state.

  
 Applications willing to read or write to this storage volume needs to get a permission from the
 user first which can be achieved in the following ways:

  To get access to standard directories (like the  Environment#DIRECTORY_PICTURES ) they
 can use the  createAccessIntent(java.lang.String) . This is the recommend way since it provides a
 simpler API and narrows the access to the given directory (and its descendants).
  To get access to any directory (and its descendants) they can use the Storage Acess
 Framework APIs (such as  Intent#ACTION_OPEN_DOCUMENT  and
  Intent#ACTION_OPEN_DOCUMENT_TREE  although these APIs do not guarantee the user will
 select this specific volume.
  To get read and write access to the primary storage volume applications can declare the
  Manifest.permission.READ_EXTERNAL_STORAGE  and
  Manifest.permission.WRITE_EXTERNAL_STORAGE  permissions respectively with the
 latter including the former. This approach is discouraged since users may be hesitant to grant
 broad access to all files contained on a storage device.
  It can be obtained through  StorageManager#getStorageVolumes()  and
  StorageManager#getPrimaryStorageVolume()  and also as an extra in some broadcasts
 (see  EXTRA_STORAGE_VOLUME ).

  
 See  Environment#getExternalStorageDirectory()  for more info about shared/external
 storage semantics.",,,,,,,,
"<android.os.Bundle: void putChar(String,char)>","Inserts a char value into the mapping of this Bundle replacing
 any existing value for the given key.","key String : a String or null
This value may be null . |||
value char : a char |||",void,1,A mapping from String keys to various  Parcelable  values.,,,,,,,,
<android.text.Layout: void draw(Canvas)>,Draw this Layout on the specified Canvas.,c Canvas |||,void,1,"A base class that manages text layout in visual elements on
 the screen.
  For text that will be edited use a  DynamicLayout 
 which will be updated as the text changes.
 For text that will not change use a  StaticLayout .","Provides classes used to render or track text and text spans on the screen. You can use these classes to design your own widgets that manage text
 to handle arbitrary text spans for changes or to handle drawing yourself
 for an existing widget. The Span… interfaces and classes are used to create or manage spans of
 text in a View item. You can use these to style the text or background or to
 listen for changes. If creating your own widget extend DynamicLayout to manages
 the actual wrapping and drawing of your text.",,,,,,,
<android.telephony.CellLocation: void requestLocationUpdate()>,"Request an update of the current location.  If the location has changed
 a broadcast will be sent to everyone registered with PhoneStateListener#LISTEN_CELL_LOCATION .",,void,1,Abstract class that represents the location of the device.,,,,,,,,
"<android.animation.AnimatorInflater: Animator loadAnimator(Context,int)>",Loads an Animator object from a resource,"context Context : Application context used to access resources |||
id int : The resource id of the animation to load |||",Animator The animator object reference by the specified id |||,11,"This class is used to instantiate animator XML files into Animator objects.
  
 For performance reasons inflation relies heavily on pre-processing of
 XML files that is done at build time. Therefore it is not currently possible
 to use this inflater with an XmlPullParser over a plain XML file at runtime;
 it only works with an XmlPullParser returned from a compiled resource (R.
  something  file.)","These classes provide functionality for the property animation system which allows you
 to animate object properties of any type.  int   float  and hexadecimal
 color values are supported by default. You can animate any other type by telling the system how
 to calculate the values for that given type with a custom  TypeEvaluator .
  For more information see the
  Animation  guide. 
 You can set many different types of interpolators (contained in  android.view.animation )
 specify  keyframes  or group animations to play sequentially
 or simultaneously (with  AnimatorSet ) to further control your animation
 behaviors.",,,,,,,
"<android.test.AndroidTestCase: void assertWritingContentUriRequiresPermission(Uri,String)>","Asserts that writing to the content uri requires a particular permission by inserting into
 the uri and ensuring a SecurityException is thrown mentioning the particular
 permission.","uri Uri : The uri that requires a permission to query. |||
permission String : The permission that should be required. |||",void,4,Extend this if you need to access Resources or other things that depend on Activity Context.,,,,,,,,
<android.app.DialogFragment: void dismissAllowingStateLoss()>,"Version of dismiss() that uses FragmentTransaction#commitAllowingStateLoss() .  See linked
 documentation for further details.",,void,12,"Base class for Dialogs.

  Note: Activities provide a facility to manage the creation saving and
 restoring of dialogs. See  Activity#onCreateDialog(int) 
  Activity#onPrepareDialog(int Dialog) 
  Activity#showDialog(int)  and  Activity#dismissDialog(int) . If
 these methods are used  getOwnerActivity()  will return the Activity
 that managed this dialog.

  Often you will want to have a Dialog display on top of the current
 input method because there is no reason for it to accept text.  You can
 do this by setting the  WindowManager.LayoutParams#FLAG_ALT_FOCUSABLE_IM  window flag (assuming
 your Dialog takes input focus as it the default) with the following code:

  
 getWindow().setFlags(WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM
         WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.os.Parcel: void writeValue(Object)>,"Flatten a generic object in to a parcel.  The given Object value may
 currently be one of the following types: null 
String 
Byte 
Short 
Integer 
Long 
Float 
Double 
Boolean 
String[] 
boolean[] 
byte[] 
int[] 
long[] 
Object[] (supporting objects of the same type defined here). 
Bundle 
Map (as supported by writeMap(Map) ). 
Any object that implements the Parcelable protocol. 
Parcelable[] 
CharSequence (as supported by TextUtils#writeToParcel ). 
List (as supported by writeList(List) ). 
SparseArray (as supported by writeSparseArray(android.util.SparseArray) ). 
IBinder 
Any object that implements Serializable (but see writeSerializable(Serializable) for caveats).  Note that all of the
      previous types have relatively efficient implementations for
      writing to a Parcel; having to rely on the generic serialization
      approach is much less efficient and should be avoided whenever
      possible. 
Parcelable objects are written with Parcelable#writeToParcel using contextual flags of 0.  When
 serializing objects containing ParcelFileDescriptor s
 this may result in file descriptor leaks when they are returned from
 Binder calls (where Parcelable#PARCELABLE_WRITE_RETURN_VALUE should be used).",v Object : This value may be null . |||,void,1,"Container for a message (data and object references) that can
 be sent through an IBinder.  A Parcel can contain both flattened data
 that will be unflattened on the other side of the IPC (using the various
 methods here for writing specific types or the general
  Parcelable  interface) and references to live  IBinder 
 objects that will result in the other side receiving a proxy IBinder
 connected with the original IBinder in the Parcel.

  Parcel is  not  a general-purpose
 serialization mechanism.  This class (and the corresponding
  Parcelable  API for placing arbitrary objects into a Parcel) is
 designed as a high-performance IPC transport.  As such it is not
 appropriate to place any Parcel data in to persistent storage: changes
 in the underlying implementation of any of the data in the Parcel can
 render older data unreadable. The bulk of the Parcel API revolves around reading and writing data
 of various types.  There are six major classes of such functions available. Primitives The most basic data functions are for writing and reading primitive
 data types:  writeByte(byte)   readByte()   writeDouble(double) 
  readDouble()   writeFloat(float)   readFloat()   writeInt(int) 
  readInt()   writeLong(long)   readLong() 
  writeString(String)   readString() .  Most other
 data operations are built on top of these.  The given data is written and
 read using the endianess of the host CPU. Primitive Arrays There are a variety of methods for reading and writing raw arrays
 of primitive objects which generally result in writing a 4-byte length
 followed by the primitive data items.  The methods for reading can either
 read the data into an existing array or create and return a new array.
 These available types are: writeBooleanArray(boolean[]) 
  readBooleanArray(boolean[])   createBooleanArray() writeByteArray(byte[]) 
  writeByteArray(byte[] int int)   readByteArray(byte[]) 
  createByteArray() writeCharArray(char[])   readCharArray(char[]) 
  createCharArray() writeDoubleArray(double[])   readDoubleArray(double[]) 
  createDoubleArray() writeFloatArray(float[])   readFloatArray(float[]) 
  createFloatArray() writeIntArray(int[])   readIntArray(int[]) 
  createIntArray() writeLongArray(long[])   readLongArray(long[]) 
  createLongArray() writeStringArray(java.lang.String[])   readStringArray(java.lang.String[]) 
  createStringArray() .
  writeSparseBooleanArray(android.util.SparseBooleanArray) 
  readSparseBooleanArray() .
  Parcelables The  Parcelable  protocol provides an extremely efficient (but
 low-level) protocol for objects to write and read themselves from Parcels.
 You can use the direct methods  writeParcelable(android.os.Parcelable int) 
 and  readParcelable(java.lang.ClassLoader)  or
  writeParcelableArray(T[] int)  and
  readParcelableArray(java.lang.ClassLoader)  to write or read.  These
 methods write both the class type and its data to the Parcel allowing
 that class to be reconstructed from the appropriate class loader when
 later reading. There are also some methods that provide a more efficient way to work
 with Parcelables:  writeTypedObject(T int)   writeTypedArray(T[] int) 
  writeTypedList(List )   readTypedObject(Parcelable.Creator ) 
  createTypedArray(Parcelable.Creator )  and  createTypedArrayList(Parcelable.Creator ) .  These methods
 do not write the class information of the original object: instead the
 caller of the read function must know what type to expect and pass in the
 appropriate  Parcelable.Creator  instead to
 properly construct the new object and read its data.  (To more efficient
 write and read a single Parcelable object that is not null you can directly
 call  Parcelable#writeToParcel  and
  Parcelable.Creator#createFromParcel 
 yourself.) Bundles A special type-safe container called  Bundle  is available
 for key/value maps of heterogeneous values.  This has many optimizations
 for improved performance when reading and writing data and its type-safe
 API avoids difficult to debug type errors when finally marshalling the
 data contents into a Parcel.  The methods to use are
  writeBundle(android.os.Bundle)   readBundle()  and
  readBundle(java.lang.ClassLoader) .

  Active Objects An unusual feature of Parcel is the ability to read and write active
 objects.  For these objects the actual contents of the object is not
 written rather a special token referencing the object is written.  When
 reading the object back from the Parcel you do not get a new instance of
 the object but rather a handle that operates on the exact same object that
 was originally written.  There are two forms of active objects available. Binder  objects are a core facility of Android's general cross-process
 communication system.  The  IBinder  interface describes an abstract
 protocol with a Binder object.  Any such interface can be written in to
 a Parcel and upon reading you will receive either the original object
 implementing that interface or a special proxy implementation
 that communicates calls back to the original object.  The methods to use are
  writeStrongBinder(android.os.IBinder) 
  writeStrongInterface(android.os.IInterface)   readStrongBinder() 
  writeBinderArray(android.os.IBinder[])   readBinderArray(android.os.IBinder[]) 
  createBinderArray() 
  writeBinderList(java.util.List)   readBinderList(java.util.List) 
  createBinderArrayList() . FileDescriptor objects representing raw Linux file descriptor identifiers
 can be written and  ParcelFileDescriptor  objects returned to operate
 on the original file descriptor.  The returned file descriptor is a dup
 of the original file descriptor: the object and fd is different but
 operating on the same underlying file stream with the same position etc.
 The methods to use are  writeFileDescriptor(java.io.FileDescriptor) 
  readFileDescriptor() .

  Untyped Containers A final class of methods are for writing and reading standard Java
 containers of arbitrary types.  These all revolve around the
  writeValue(java.lang.Object)  and  readValue(java.lang.ClassLoader)  methods
 which define the types of objects allowed.  The container methods are
  writeArray(java.lang.Object[])   readArray(java.lang.ClassLoader) 
  writeList(java.util.List)   readList(java.util.List java.lang.ClassLoader) 
  readArrayList(java.lang.ClassLoader) 
  writeMap(java.util.Map)   readMap(java.util.Map java.lang.ClassLoader) 
  writeSparseArray(android.util.SparseArray) 
  readSparseArray(java.lang.ClassLoader) .",,,,,,,,
"<android.text.method.LinkMovementMethod: void onTakeFocus(TextView,Spannable,int)>",,"view TextView |||
text Spannable |||
dir int |||",void,1,"A movement method that traverses links in the text buffer and scrolls if necessary.
 Supports clicking on links with DPad Center or Enter.","Provides classes that monitor or modify keypad input. You can use these classes to modify the type of keypad entry
 for your application or decipher the keypresses entered for your specific
 entry method. For example: 
 // Set the text to password display style:
 EditText txtView = (EditText)findViewById(R.id.text);
 txtView.setTransformationMethod(PasswordTransformationMethod.getInstance());

 //Set the input style to numbers rather than qwerty keyboard style.
 txtView.setInputMethod(DigitsInputMethod.getInstance());

 // Find out whether the caps lock is on.
 // 0 is no 1 is yes 2 is caps lock on.
 int active = MultiTapInputMethod.getCapsActive(txtView.getText());",,,,,,,
"<android.app.Notification: void writeToParcel(Parcel,int)>",Flatten this notification into a parcel.,"parcel Parcel : The Parcel in which the object should be written. |||
flags int : Additional flags about how the object should be written.
May be 0 or Parcelable.PARCELABLE_WRITE_RETURN_VALUE .
Value is either 0 or a combination of Parcelable.PARCELABLE_WRITE_RETURN_VALUE and android.os.Parcelable.PARCELABLE_ELIDE_DUPLICATES |||",void,1,"A class that represents how a persistent notification is to be presented to
 the user using the  NotificationManager .

  The  Notification.Builder  has been added to make it
 easier to construct Notifications.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.inputmethodservice.InputMethodService: void hideStatusIcon()>,,,void,3,"InputMethodService provides a standard implementation of an InputMethod
 which final implementations can derive from and customize.  See the
 base class  AbstractInputMethodService  and the  InputMethod 
 interface for more information on the basics of writing input methods.

  In addition to the normal Service lifecycle methods this class
 introduces some new specific callbacks that most subclasses will want
 to make use of: onInitializeInterface()  for user-interface initialization
 in particular to deal with configuration changes while the service is
 running.
  onBindInput()  to find out about switching to a new client.
  onStartInput(EditorInfo boolean)  to deal with an input session starting with
 the client.
  onCreateInputView()   onCreateCandidatesView() 
 and  onCreateExtractTextView()  for non-demand generation of the UI.
  onStartInputView(android.view.inputmethod.EditorInfo boolean)  to deal with input
 starting within the input area of the IME.
  An input method has significant discretion in how it goes about its
 work: the  InputMethodService  provides
 a basic framework for standard UI elements (input view candidates view
 and running in fullscreen mode) but it is up to a particular implementor
 to decide how to use them.  For example one input method could implement
 an input area with a keyboard another could allow the user to draw text
 while a third could have no input area (and thus not be visible to the
 user) but instead listen to audio and perform text to speech conversion. In the implementation provided here all of these elements are placed
 together in a single window managed by the InputMethodService.  It will
 execute callbacks as it needs information about them and provides APIs for
 programmatic control over them.  They layout of these elements is explicitly
 defined: The soft input view if available is placed at the bottom of the
 screen.
  The candidates view if currently shown is placed above the soft
 input view.
  If not running fullscreen the application is moved or resized to be
 above these views; if running fullscreen the window will completely cover
 the application and its top part will contain the extract text of what is
 currently being edited by the application.
  Soft Input View Central to most input methods is the soft input view.  This is where most
 user interaction occurs: pressing on soft keys drawing characters or
 however else your input method wants to generate text.  Most implementations
 will simply have their own view doing all of this work and return a new
 instance of it when  onCreateInputView()  is called.  At that point
 as long as the input view is visible you will see user interaction in
 that view and can call back on the InputMethodService to interact with the
 application as appropriate. There are some situations where you want to decide whether or not your
 soft input view should be shown to the user.  This is done by implementing
 the  onEvaluateInputViewShown()  to return true or false based on
 whether it should be shown in the current environment.  If any of your
 state has changed that may impact this call
  updateInputViewShown()  to have it re-evaluated.  The default
 implementation always shows the input view unless there is a hard
 keyboard available which is the appropriate behavior for most input
 methods. Candidates View Often while the user is generating raw text an input method wants to
 provide them with a list of possible interpretations of that text that can
 be selected for use.  This is accomplished with the candidates view and
 like the soft input view you implement  onCreateCandidatesView() 
 to instantiate your own view implementing your candidates UI. Management of the candidates view is a little different than the input
 view because the candidates view tends to be more transient being shown
 only when there are possible candidates for the current text being entered
 by the user.  To control whether the candidates view is shown you use
  setCandidatesViewShown(boolean) .  Note that because the candidate
 view tends to be shown and hidden a lot it does not impact the application
 UI in the same way as the soft input view: it will never cause application
 windows to resize only cause them to be panned if needed for the user to
 see the current focus. Fullscreen Mode Sometimes your input method UI is too large to integrate with the
 application UI so you just want to take over the screen.  This is
 accomplished by switching to full-screen mode causing the input method
 window to fill the entire screen and add its own ""extracted text"" editor
 showing the user the text that is being typed.  Unlike the other UI elements
 there is a standard implementation for the extract editor that you should
 not need to change.  The editor is placed at the top of the IME above the
 input and candidates views. Similar to the input view you control whether the IME is running in
 fullscreen mode by implementing  onEvaluateFullscreenMode() 
 to return true or false based on
 whether it should be fullscreen in the current environment.  If any of your
 state has changed that may impact this call
  updateFullscreenMode()  to have it re-evaluated.  The default
 implementation selects fullscreen mode when the screen is in a landscape
 orientation which is appropriate behavior for most input methods that have
 a significant input area. When in fullscreen mode you have some special requirements because the
 user can not see the application UI.  In particular you should implement
  onDisplayCompletions(android.view.inputmethod.CompletionInfo[])  to show completions
 generated by your application typically in your candidates view like you
 would normally show candidates.


  Generating Text The key part of an IME is of course generating text for the application.
 This is done through calls to the
  InputConnection  interface to the
 application which can be retrieved from  getCurrentInputConnection() .
 This interface allows you to generate raw key events or if the target
 supports it directly edit in strings of candidates and committed text. Information about what the target is expected and supports can be found
 through the  EditorInfo  class which is
 retrieved with  getCurrentInputEditorInfo()  method.  The most
 important part of this is  EditorInfo.inputType ; in particular if this is
  EditorInfo.TYPE_NULL 
 then the target does not support complex edits and you need to only deliver
 raw key events to it.  An input method will also want to look at other
 values here to for example detect password mode auto complete text views
 phone number entry etc. When the user switches between input targets you will receive calls to
  onFinishInput()  and  onStartInput(android.view.inputmethod.EditorInfo boolean) .
 You can use these to reset and initialize your input state for the current
 target.  For example you will often want to clear any input state and
 update a soft keyboard to be appropriate for the new inputType.",,,,,,,,
"<android.content.ContentProviderClient: Uri insert(Uri,ContentValues)>",See ContentProvider#insert,"url Uri : This value cannot be null . |||
initialValues ContentValues : This value may be null . |||",Uri This value may be null . |||,5,"Content providers are one of the primary building blocks of Android applications providing
 content to applications. They encapsulate data and provide it to applications through the single
  ContentResolver  interface. A content provider is only required if you need to share
 data between multiple applications. For example the contacts data is used by multiple
 applications and must be stored in a content provider. If you don't need to share data amongst
 multiple applications you can use a database directly via
  SQLiteDatabase .

  When a request is made via
 a  ContentResolver  the system inspects the authority of the given URI and passes the
 request to the content provider registered with the authority. The content provider can interpret
 the rest of the URI however it wants. The  UriMatcher  class is helpful for parsing
 URIs. The primary methods that need to be implemented are:
  onCreate()  which is called to initialize the provider query(Uri String[] Bundle CancellationSignal)  which returns data to the caller insert(Uri ContentValues)  which inserts new data into the content provider update(Uri ContentValues String String[])  which updates existing data in the content provider delete(Uri String String[])  which deletes data from the content provider getType(Uri)  which returns the MIME type of data in the content provider Requests to  ContentResolver  are automatically forwarded to the appropriate
 ContentProvider instance so subclasses don't have to worry about the details of
 cross-process calls.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
"<android.hardware.usb.UsbManager: void requestPermission(UsbDevice,PendingIntent)>","Requests temporary permission for the given package to access the device.
 This may result in a system dialog being displayed to the user
 if permission had not already been granted.
 Success or failure is returned via the PendingIntent pi.
 If successful this grants the caller permission to access the device only
 until the device is disconnected.

 The following extras will be added to pi: EXTRA_DEVICE containing the device passed into this call 
EXTRA_PERMISSION_GRANTED containing boolean indicating whether
 permission was granted by the user","device UsbDevice : to request permissions for |||
pi PendingIntent : PendingIntent for returning result |||",void,12,"This class allows you to access the state of USB and communicate with USB devices.
 Currently only host mode is supported in the public API.","Provides support to communicate with USB hardware peripherals that are connected to
 Android-powered devices. For more information see the
  USB  guide. Use  UsbManager  to access the state of the USB and to
 communicate with connected hardware peripherals. Use  UsbDevice  to
 communicate with the hardware peripheral if the Android-powered device is acting as the USB host.
 Use  UsbAccessory  if the peripheral is acting as the USB host.",,,,,,,
<android.app.UiModeManager: void disableCarMode(int)>,Turn off special mode if currently in car mode.,"flags int : One of the disable car mode flags.
Value is DISABLE_CAR_MODE_GO_HOME |||",void,8,"This class provides access to the system uimode services.  These services
 allow applications to control UI modes of the device.
 It provides functionality to disable the car mode and it gives access to the
 night mode settings.

  These facilities are built on top of the underlying
  Intent.ACTION_DOCK_EVENT  broadcasts that are sent when the user
 physical places the device into and out of a dock.  When that happens
 the UiModeManager switches the system  Configuration 
 to the appropriate UI mode sends broadcasts about the mode switch and
 starts the corresponding mode activity if appropriate.  See the
 broadcasts  ACTION_ENTER_CAR_MODE  and
  ACTION_ENTER_DESK_MODE  for more information.

  In addition the user may manually switch the system to car mode without
 physically being in a dock.  While in car mode -- whether by manual action
 from the user or being physically placed in a dock -- a notification is
 displayed allowing the user to exit dock mode.  Thus the dock mode
 represented here may be different than the current state of the underlying
 dock event broadcast.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.app.WallpaperInfo: CharSequence loadAuthor(PackageManager)>,Return a string indicating the author(s) of this wallpaper.,pm PackageManager |||,CharSequence |||,7,This class is used to specify meta information of a wallpaper service.,"Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.app.UiModeManager: void setNightMode(int)>,"Sets the system-wide night mode. The mode can be one of: MODE_NIGHT_NO sets the device into notnight mode 
MODE_NIGHT_YES sets the device into night mode 
MODE_NIGHT_CUSTOM automatically switches between night and notnight based on the custom time set (or default) 
MODE_NIGHT_AUTO automatically switches between night and notnight based on the device's current
       location and certain other sensors 
Note: On API 22 and below changes to the night mode
 are only effective when the Configuration#UI_MODE_TYPE_CAR or Configuration#UI_MODE_TYPE_DESK mode is enabled on a
 device. On API 23 through API 28 changes to night mode are always effective. Starting in API 29 when the device is in car mode and this method is called night mode
 will change but the new setting is not persisted and the previously persisted setting
 will be restored when the device exits car mode. Changes to night mode take effect globally and will result in a configuration change
 (and potentially an Activity lifecycle event) being applied to all running apps.
 Developers interested in an app-local implementation of night mode should consider using AppCompatDelegate.setDefaultNightMode(int) to manage the
 -night qualifier locally.","mode int : the night mode to set
Value is MODE_NIGHT_AUTO  MODE_NIGHT_CUSTOM  MODE_NIGHT_NO or MODE_NIGHT_YES |||",void,8,"This class provides access to the system uimode services.  These services
 allow applications to control UI modes of the device.
 It provides functionality to disable the car mode and it gives access to the
 night mode settings.

  These facilities are built on top of the underlying
  Intent.ACTION_DOCK_EVENT  broadcasts that are sent when the user
 physical places the device into and out of a dock.  When that happens
 the UiModeManager switches the system  Configuration 
 to the appropriate UI mode sends broadcasts about the mode switch and
 starts the corresponding mode activity if appropriate.  See the
 broadcasts  ACTION_ENTER_CAR_MODE  and
  ACTION_ENTER_DESK_MODE  for more information.

  In addition the user may manually switch the system to car mode without
 physically being in a dock.  While in car mode -- whether by manual action
 from the user or being physically placed in a dock -- a notification is
 displayed allowing the user to exit dock mode.  Thus the dock mode
 represented here may be different than the current state of the underlying
 dock event broadcast.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
"<android.text.method.MultiTapKeyListener: void onSpanChanged(Spannable,Object,int,int,int,int)>","This method is called to notify you that the specified object
 has been relocated from the range ostart…oend to the new range nstart…nend of the text.","buf Spannable |||
what Object |||
s int |||
e int |||
start int |||
stop int |||",void,1,"This is the standard key listener for alphabetic input on 12-key
 keyboards.  You should generally not need to instantiate this yourself;
 TextKeyListener will do it for you.
  KeyListener","Provides classes that monitor or modify keypad input. You can use these classes to modify the type of keypad entry
 for your application or decipher the keypresses entered for your specific
 entry method. For example: 
 // Set the text to password display style:
 EditText txtView = (EditText)findViewById(R.id.text);
 txtView.setTransformationMethod(PasswordTransformationMethod.getInstance());

 //Set the input style to numbers rather than qwerty keyboard style.
 txtView.setInputMethod(DigitsInputMethod.getInstance());

 // Find out whether the caps lock is on.
 // 0 is no 1 is yes 2 is caps lock on.
 int active = MultiTapInputMethod.getCapsActive(txtView.getText());",,,,,,,
"<android.accounts.AccountManager: String getUserData(Account,String)>","Gets the user data named by ""key"" associated with the account. This is intended for
 authenticators and related code to store arbitrary metadata along with accounts. The meaning
 of the keys and values is up to the authenticator for the account. It is safe to call this method from the main thread. This method requires the caller to have a signature match with the authenticator that owns
 the specified account. NOTE: If targeting your app to work on API level Build.VERSION_CODES.LOLLIPOP_MR1 and before AUTHENTICATE_ACCOUNTS
 permission is needed for those platforms. See docs for this function in API level Build.VERSION_CODES.LOLLIPOP_MR1 . Requires android.Manifest.permission.AUTHENTICATE_ACCOUNTS","account Account : The account to query for user data |||
key String |||",String The user data null if the account key doesn't exist or the user is locked |||,5,"This class provides access to a centralized registry of the user's
 online accounts.  The user enters credentials (username and password) once
 per account granting applications access to online resources with
 ""one-click"" approval.

  Different online services have different ways of handling accounts and
 authentication so the account manager uses pluggable  authenticator 
 modules for different  account types .  Authenticators (which may be
 written by third parties) handle the actual details of validating account
 credentials and storing account information.  For example Google Facebook
 and Microsoft Exchange each have their own authenticator.

  Many servers support some notion of an  authentication token 
 which can be used to authenticate a request to the server without sending
 the user's actual password.  (Auth tokens are normally created with a
 separate request which does include the user's credentials.)  AccountManager
 can generate auth tokens for applications so the application doesn't need to
 handle passwords directly.  Auth tokens are normally reusable and cached by
 AccountManager but must be refreshed periodically.  It's the responsibility
 of applications to  invalidate  auth tokens when they stop working so
 the AccountManager knows it needs to regenerate them.

  Applications accessing a server normally go through these steps:

  Get an instance of AccountManager using  get(android.content.Context) .

  List the available accounts using  getAccountsByType(String)  or
  getAccountsByTypeAndFeatures(String String[] AccountManagerCallback  Handler) .  Normally applications will only
 be interested in accounts with one particular  type  which
 identifies the authenticator.  Account  features  are used to
 identify particular account subtypes and capabilities.  Both the account
 type and features are authenticator-specific strings and must be known by
 the application in coordination with its preferred authenticators.

  Select one or more of the available accounts possibly by asking the
 user for their preference.  If no suitable accounts are available
  addAccount(String String String[] Bundle Activity AccountManagerCallback  Handler)  may be called to prompt the user to create an
 account of the appropriate type.

  Important:  If the application is using a previously remembered
 account selection it must make sure the account is still in the list
 of accounts returned by  getAccountsByType(String) .  Requesting an auth token
 for an account no longer on the device results in an undefined failure.

  Request an auth token for the selected account(s) using one of the
  getAuthToken(Account String Bundle Activity AccountManagerCallback  Handler)  methods or related helpers.  Refer to the description
 of each method for exact usage and error handling details.

  Make the request using the auth token.  The form of the auth token
 the format of the request and the protocol used are all specific to the
 service you are accessing.  The application may use whatever network and
 protocol libraries are useful.

  Important:  If the request fails with an authentication error
 it could be that a cached auth token is stale and no longer honored by
 the server.  The application must call  invalidateAuthToken(String String)  to remove
 the token from the cache otherwise requests will continue failing!  After
 invalidating the auth token immediately go back to the ""Request an auth
 token"" step above.  If the process fails the second time then it can be
 treated as a ""genuine"" authentication failure and the user notified or other
 appropriate actions taken.
  Some AccountManager methods may need to interact with the user to
 prompt for credentials present options or ask the user to add an account.
 The caller may choose whether to allow AccountManager to directly launch the
 necessary user interface and wait for the user or to return an Intent which
 the caller may use to launch the interface or (in some cases) to install a
 notification which the user can select at any time to launch the interface.
 To have AccountManager launch the interface directly the caller must supply
 the current foreground  Activity  context.

  Many AccountManager methods take  AccountManagerCallback  and
  Handler  as parameters.  These methods return immediately and
 run asynchronously. If a callback is provided then
  AccountManagerCallback#run  will be invoked on the Handler's
 thread when the request completes successfully or not.
 The result is retrieved by calling  AccountManagerFuture#getResult() 
 on the  AccountManagerFuture  returned by the method (and also passed
 to the callback).  This method waits for the operation to complete (if
 necessary) and either returns the result or throws an exception if an error
 occurred during the operation.  To make the request synchronously call
  AccountManagerFuture#getResult()  immediately on receiving the
 future from the method; no callback need be supplied.

  Requests which may block including
  AccountManagerFuture#getResult()  must never be called on
 the application's main event thread.  These operations throw
  IllegalStateException  if they are used on the main thread.",,,,,,,,
"<android.content.ContentProviderOperation: ContentProviderResult apply(ContentProvider,ContentProviderResult,int)>","Applies this operation using the given provider. The backRefs array is used to resolve any
 back references that were requested using Builder#withValueBackReferences(ContentValues) and Builder#withSelectionBackReference .","provider ContentProvider : the ContentProvider on which this batch is applied
This value cannot be null . |||
backRefs ContentProviderResult : a ContentProviderResult array that will be consulted
to resolve any requested back references.
This value cannot be null . |||
numBackRefs int : the number of valid results on the backRefs array. |||","ContentProviderResult a ContentProviderResult that contains either the Uri of the inserted
 row if this was an insert otherwise the number of rows affected.
 This value cannot be null . |||",5,"Content providers are one of the primary building blocks of Android applications providing
 content to applications. They encapsulate data and provide it to applications through the single
  ContentResolver  interface. A content provider is only required if you need to share
 data between multiple applications. For example the contacts data is used by multiple
 applications and must be stored in a content provider. If you don't need to share data amongst
 multiple applications you can use a database directly via
  SQLiteDatabase .

  When a request is made via
 a  ContentResolver  the system inspects the authority of the given URI and passes the
 request to the content provider registered with the authority. The content provider can interpret
 the rest of the URI however it wants. The  UriMatcher  class is helpful for parsing
 URIs. The primary methods that need to be implemented are:
  onCreate()  which is called to initialize the provider query(Uri String[] Bundle CancellationSignal)  which returns data to the caller insert(Uri ContentValues)  which inserts new data into the content provider update(Uri ContentValues String String[])  which updates existing data in the content provider delete(Uri String String[])  which deletes data from the content provider getType(Uri)  which returns the MIME type of data in the content provider Requests to  ContentResolver  are automatically forwarded to the appropriate
 ContentProvider instance so subclasses don't have to worry about the details of
 cross-process calls.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.app.Activity: void setProgress(int)>,"This method was deprecated
      in API level 24. No longer supported starting in API 21. Sets the progress for the progress bars in the title. In order for the progress bar to be shown the feature must be requested
 via requestWindowFeature(int) .","progress int : The progress for the progress bar. Valid ranges are from
0 to 10000 (both inclusive). If 10000 is given the progress
bar will be completely filled and will fade out. |||",void,1,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
"<android.os.Bundle: void putCharSequence(String,CharSequence)>","Inserts a CharSequence value into the mapping of this Bundle replacing
 any existing value for the given key.  Either key or value may be null.","key String : a String or null
This value may be null . |||
value CharSequence : a CharSequence or null
This value may be null . |||",void,1,A mapping from String keys to various  Parcelable  values.,,,,,,,,
"<android.view.inputmethod.InputMethodManager: void sendAppPrivateCommand(View,String,Bundle)>",Call InputMethodSession#appPrivateCommand(String Bundle) on the current Input Method.,"view View : Optional View that is sending the command or null if
you want to send the command regardless of the view that is attached
to the input method. |||
action String : Name of the command to be performed.  This must be a scoped name i.e. prefixed with a package name you own so that
different developers will not create conflicting commands. |||
data Bundle : Any data to include with the command. |||",void,3,"Central system API to the overall input method framework (IMF) architecture
 which arbitrates interaction between applications and the current input method.

  Topics covered here:
  Architecture Overview Applications Input Methods Security Architecture Overview There are three primary parties involved in the input method
 framework (IMF) architecture:  The  input method manager  as expressed by this class
 is the central point of the system that manages interaction between all
 other parts.  It is expressed as the client-side API here which exists
 in each application context and communicates with a global system service
 that manages the interaction across all processes.
   An  input method (IME)  implements a particular
 interaction model allowing the user to generate text.  The system binds
 to the current input method that is in use causing it to be created and run
 and tells it when to hide and show its UI.  Only one IME is running at a time.
   Multiple  client applications  arbitrate with the input
 method manager for input focus and control over the state of the IME.  Only
 one such client is ever active (working with the IME) at a time.
  Applications In most cases applications that are using the standard
  TextView  or its subclasses will have little they need
 to do to work well with soft input methods.  The main things you need to
 be aware of are:  Properly set the  R.attr.inputType  in your editable
 text views so that the input method will have enough context to help the
 user in entering text into them.
   Deal well with losing screen space when the input method is
 displayed.  Ideally an application should handle its window being resized
 smaller but it can rely on the system performing panning of the window
 if needed.  You should set the  R.attr.windowSoftInputMode 
 attribute on your activity or the corresponding values on windows you
 create to help the system determine whether to pan or resize (it will
 try to determine this automatically but may get it wrong).
   You can also control the preferred soft input state (open closed etc)
 for your window using the same  R.attr.windowSoftInputMode 
 attribute.
  More finer-grained control is available through the APIs here to directly
 interact with the IMF and its IME -- either showing or hiding the input
 area letting the user pick an input method etc. For the rare people amongst us writing their own text editors you
 will need to implement  View.onCreateInputConnection(EditorInfo) 
 to return a new instance of your own  InputConnection  interface
 allowing the IME to interact with your editor. Input Methods An input method (IME) is implemented
 as a  Service  typically deriving from
  InputMethodService .  It must provide
 the core  InputMethod  interface though this is normally handled by
  InputMethodService  and implementors will
 only need to deal with the higher-level API there. InputMethodService Security There are a lot of security issues associated with input methods
 since they essentially have freedom to completely drive the UI and monitor
 everything the user enters.  The Android input method framework also allows
 arbitrary third party IMEs so care must be taken to restrict their
 selection and interactions. Here are some key points about the security architecture behind the
 IMF: Only the system is allowed to directly access an IME's
  InputMethod  interface via the
  Manifest.permission.BIND_INPUT_METHOD  permission.  This is
 enforced in the system by not binding to an input method service that does
 not require this permission so the system can guarantee no other untrusted
 clients are accessing the current input method outside of its control. There may be many client processes of the IMF but only one may
 be active at a time.  The inactive clients can not interact with key
 parts of the IMF through the mechanisms described below. Clients of an input method are only given access to its
  InputMethodSession  interface.  One instance of this interface is
 created for each client and only calls from the session associated with
 the active client will be processed by the current IME.  This is enforced
 by  AbstractInputMethodService  for normal
 IMEs but must be explicitly handled by an IME that is customizing the
 raw  InputMethodSession  implementation. Only the active client's  InputConnection  will accept
 operations.  The IMF tells each client process whether it is active and
 the framework enforces that in inactive processes calls on to the current
 InputConnection will be ignored.  This ensures that the current IME can
 only deliver events and text edits to the UI that the user sees as
 being in focus. An IME can never interact with an  InputConnection  while
 the screen is off.  This is enforced by making all clients inactive while
 the screen is off and prevents bad IMEs from driving the UI when the user
 can not be aware of its behavior. A client application can ask that the system let the user pick a
 new IME but can not programmatically switch to one itself.  This avoids
 malicious applications from switching the user to their own IME which
 remains running when the user navigates away to another application.  An
 IME on the other hand  is  allowed to programmatically switch
 the system to another IME since it already has full control of user
 input. The user must explicitly enable a new IME in settings before
 they can switch to it to confirm with the system that they know about it
 and want to make it available for use. PackageManager#FEATURE_INPUT_METHODS PackageManager.hasSystemFeature(String)",,,,,,,,
"<android.drm.DrmManagerClient: ContentValues getConstraints(Uri,int)>",Retrieves constraint information for rights-protected content.,"uri Uri : URI for the content from which you are retrieving DRM constraints. |||
action int : Action defined in DrmStore.Action . |||","ContentValues A ContentValues instance that contains
 key-value pairs representing the constraints. Null in case of failure. |||",11,"The main programming interface for the DRM framework. An application must instantiate this class
 to access DRM agents through the DRM framework.","Provides classes for managing DRM content and determining the capabilities of DRM plugins
 (agents). Common uses of the DRM API include: Determining which DRM plug-ins (agents) are installed on a device. Retrieving information about specific plug-ins such as the MIME types and file suffixes
   they support. Registering a user or a device with an online DRM service. Retrieving license constraints for rights-protected content. Checking whether a user has the proper rights to play or use rights-protected
   content. Associating rights-protected content with its license so you can use the
    MediaPlayer  API to play the content.",,,,,,,
<android.speech.tts.TextToSpeechService: void onDestroy()>,"Called by the system to notify a Service that it is no longer used and is being removed.  The
 service should clean up any resources it holds (threads registered
 receivers etc) at this point.  Upon return there will be no more calls
 in to this Service object and it is effectively dead.  Do not call this method directly.",,void,14,"Abstract base class for TTS engine implementations. The following methods
 need to be implemented:
  onIsLanguageAvailable(String String String) onLoadLanguage(String String String) onGetLanguage() onSynthesizeText(SynthesisRequest SynthesisCallback) onStop() onSynthesizeText(SynthesisRequest SynthesisCallback) onStop() onGetLanguage() onGetVoices() onIsValidVoiceName(java.lang.String) onLoadVoice(java.lang.String) onGetDefaultVoiceNameFor(java.lang.String java.lang.String java.lang.String) onGetLanguage() onIsLanguageAvailable(String String String) onLoadLanguage(String String String) onGetDefaultVoiceNameFor(java.lang.String java.lang.String java.lang.String) TextToSpeech#setLanguage TextToSpeech#setVoice onGetDefaultVoiceNameFor(java.lang.String java.lang.String java.lang.String) SynthesisRequest",,,,,,,,
"<android.app.NotificationManager: void notify(int,Notification)>","Post a notification to be shown in the status bar. If a notification with
 the same id has already been posted by your application and has not yet been canceled it
 will be replaced by the updated information.","id int : An identifier for this notification unique within your
application. |||
notification Notification : A Notification object describing what to show the user. Must not
be null. |||",void,1,"A class that represents how a persistent notification is to be presented to
 the user using the  NotificationManager .

  The  Notification.Builder  has been added to make it
 easier to construct Notifications.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
"<android.content.pm.PackageInfo: void writeToParcel(Parcel,int)>",Flatten this object in to a Parcel.,"dest Parcel : The Parcel in which the object should be written. |||
parcelableFlags int : Additional flags about how the object should be written.
May be 0 or Parcelable.PARCELABLE_WRITE_RETURN_VALUE .
Value is either 0 or a combination of Parcelable.PARCELABLE_WRITE_RETURN_VALUE and android.os.Parcelable.PARCELABLE_ELIDE_DUPLICATES |||",void,1,"Overall information about the contents of a package.  This corresponds
 to all of the information collected from AndroidManifest.xml.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.inputmethodservice.InputMethodService: void sendDownUpKeyEvents(int)>,"Send the given key event code (as defined by KeyEvent ) to the
 current input connection is a key down + key up event pair.  The sent
 events have KeyEvent#FLAG_SOFT_KEYBOARD set so that the recipient can identify them as coming from a software
 input method and KeyEvent#FLAG_KEEP_TOUCH_MODE so
 that they don't impact the current touch mode of the UI. Note that it's discouraged to send such key events in normal operation;
 this is mainly for use with InputType.TYPE_NULL type
 text fields or for non-rich input methods. A reasonably capable software
 input method should use the InputConnection.commitText(CharSequence int) family of methods
 to send text to an application rather than sending key events.",keyEventCode int : The raw key code to send as defined by KeyEvent . |||,void,3,"InputMethodService provides a standard implementation of an InputMethod
 which final implementations can derive from and customize.  See the
 base class  AbstractInputMethodService  and the  InputMethod 
 interface for more information on the basics of writing input methods.

  In addition to the normal Service lifecycle methods this class
 introduces some new specific callbacks that most subclasses will want
 to make use of: onInitializeInterface()  for user-interface initialization
 in particular to deal with configuration changes while the service is
 running.
  onBindInput()  to find out about switching to a new client.
  onStartInput(EditorInfo boolean)  to deal with an input session starting with
 the client.
  onCreateInputView()   onCreateCandidatesView() 
 and  onCreateExtractTextView()  for non-demand generation of the UI.
  onStartInputView(android.view.inputmethod.EditorInfo boolean)  to deal with input
 starting within the input area of the IME.
  An input method has significant discretion in how it goes about its
 work: the  InputMethodService  provides
 a basic framework for standard UI elements (input view candidates view
 and running in fullscreen mode) but it is up to a particular implementor
 to decide how to use them.  For example one input method could implement
 an input area with a keyboard another could allow the user to draw text
 while a third could have no input area (and thus not be visible to the
 user) but instead listen to audio and perform text to speech conversion. In the implementation provided here all of these elements are placed
 together in a single window managed by the InputMethodService.  It will
 execute callbacks as it needs information about them and provides APIs for
 programmatic control over them.  They layout of these elements is explicitly
 defined: The soft input view if available is placed at the bottom of the
 screen.
  The candidates view if currently shown is placed above the soft
 input view.
  If not running fullscreen the application is moved or resized to be
 above these views; if running fullscreen the window will completely cover
 the application and its top part will contain the extract text of what is
 currently being edited by the application.
  Soft Input View Central to most input methods is the soft input view.  This is where most
 user interaction occurs: pressing on soft keys drawing characters or
 however else your input method wants to generate text.  Most implementations
 will simply have their own view doing all of this work and return a new
 instance of it when  onCreateInputView()  is called.  At that point
 as long as the input view is visible you will see user interaction in
 that view and can call back on the InputMethodService to interact with the
 application as appropriate. There are some situations where you want to decide whether or not your
 soft input view should be shown to the user.  This is done by implementing
 the  onEvaluateInputViewShown()  to return true or false based on
 whether it should be shown in the current environment.  If any of your
 state has changed that may impact this call
  updateInputViewShown()  to have it re-evaluated.  The default
 implementation always shows the input view unless there is a hard
 keyboard available which is the appropriate behavior for most input
 methods. Candidates View Often while the user is generating raw text an input method wants to
 provide them with a list of possible interpretations of that text that can
 be selected for use.  This is accomplished with the candidates view and
 like the soft input view you implement  onCreateCandidatesView() 
 to instantiate your own view implementing your candidates UI. Management of the candidates view is a little different than the input
 view because the candidates view tends to be more transient being shown
 only when there are possible candidates for the current text being entered
 by the user.  To control whether the candidates view is shown you use
  setCandidatesViewShown(boolean) .  Note that because the candidate
 view tends to be shown and hidden a lot it does not impact the application
 UI in the same way as the soft input view: it will never cause application
 windows to resize only cause them to be panned if needed for the user to
 see the current focus. Fullscreen Mode Sometimes your input method UI is too large to integrate with the
 application UI so you just want to take over the screen.  This is
 accomplished by switching to full-screen mode causing the input method
 window to fill the entire screen and add its own ""extracted text"" editor
 showing the user the text that is being typed.  Unlike the other UI elements
 there is a standard implementation for the extract editor that you should
 not need to change.  The editor is placed at the top of the IME above the
 input and candidates views. Similar to the input view you control whether the IME is running in
 fullscreen mode by implementing  onEvaluateFullscreenMode() 
 to return true or false based on
 whether it should be fullscreen in the current environment.  If any of your
 state has changed that may impact this call
  updateFullscreenMode()  to have it re-evaluated.  The default
 implementation selects fullscreen mode when the screen is in a landscape
 orientation which is appropriate behavior for most input methods that have
 a significant input area. When in fullscreen mode you have some special requirements because the
 user can not see the application UI.  In particular you should implement
  onDisplayCompletions(android.view.inputmethod.CompletionInfo[])  to show completions
 generated by your application typically in your candidates view like you
 would normally show candidates.


  Generating Text The key part of an IME is of course generating text for the application.
 This is done through calls to the
  InputConnection  interface to the
 application which can be retrieved from  getCurrentInputConnection() .
 This interface allows you to generate raw key events or if the target
 supports it directly edit in strings of candidates and committed text. Information about what the target is expected and supports can be found
 through the  EditorInfo  class which is
 retrieved with  getCurrentInputEditorInfo()  method.  The most
 important part of this is  EditorInfo.inputType ; in particular if this is
  EditorInfo.TYPE_NULL 
 then the target does not support complex edits and you need to only deliver
 raw key events to it.  An input method will also want to look at other
 values here to for example detect password mode auto complete text views
 phone number entry etc. When the user switches between input targets you will receive calls to
  onFinishInput()  and  onStartInput(android.view.inputmethod.EditorInfo boolean) .
 You can use these to reset and initialize your input state for the current
 target.  For example you will often want to clear any input state and
 update a soft keyboard to be appropriate for the new inputType.",,,,,,,,
<android.media.MediaRouter: void clearUserRoutes()>,Remove all app-specified routes from the MediaRouter.,,void,16,"MediaRouter allows applications to control the routing of media channels
 and streams from the current device to external speakers and destination devices.

  A MediaRouter is retrieved through  Context#getSystemService(String)  of a  Context#MEDIA_ROUTER_SERVICE .

  The media router API is not thread-safe; all interactions with it must be
 done from the main thread of the process.","The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",,,,,,,
"<android.os.Bundle: void writeToParcel(Parcel,int)>","Writes the Bundle contents to a Parcel typically in order for
 it to be passed through an IBinder connection.","parcel Parcel : The parcel to copy this bundle to. |||
flags int : Additional flags about how the object should be written.
May be 0 or Parcelable.PARCELABLE_WRITE_RETURN_VALUE .
Value is either 0 or a combination of Parcelable.PARCELABLE_WRITE_RETURN_VALUE and android.os.Parcelable.PARCELABLE_ELIDE_DUPLICATES |||",void,1,A mapping from String keys to various  Parcelable  values.,,,,,,,,
<android.view.View: void playSoundEffect(int)>,"Play a sound effect for this view. The framework will play sound effects for some built in actions such as
 clicking but you may wish to play these effects in your widget
 for instance for internal navigation. The sound effect will only be played if sound effects are enabled by the user and isSoundEffectsEnabled() is true.",soundConstant int : One of the constants defined in SoundEffectConstants |||,void,1,"This class represents the basic building block for user interface components. A View
 occupies a rectangular area on the screen and is responsible for drawing and
 event handling. View is the base class for  widgets  which are
 used to create interactive UI components (buttons text fields etc.). The
  ViewGroup  subclass is the base class for  layouts  which
 are invisible containers that hold other Views (or other ViewGroups) and define
 their layout properties.",,,,,,,,
<android.app.admin.DeviceAdminInfo: Drawable loadIcon(PackageManager)>,Load the user-displayed icon for this device admin.,"pm PackageManager : Supply a PackageManager used to load the device admin's
resources. |||",Drawable |||,8,"This class is used to specify meta information of a device administrator
 component.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.widget.BaseAdapter: void notifyDataSetInvalidated()>,"Notifies the attached observers that the underlying data is no longer valid
 or available. Once invoked this adapter is no longer valid and should
 not report further data set changes.",,void,1,"Common base class of common implementation for an  Adapter  that can be
 used in both  ListView  (by implementing the specialized
  ListAdapter  interface) and  Spinner  (by implementing the
 specialized  SpinnerAdapter  interface).","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
"<android.test.TouchUtils: int dragViewTo(InstrumentationTestCase,View,int,int,int)>",Simulate touching a view and dragging it to a specified location.,"test InstrumentationTestCase : The test case that is being run |||
v View : The view that should be dragged |||
gravity int : Which part of the view to use for the initial down event. A combination of
(TOP CENTER_VERTICAL BOTTOM) and (LEFT CENTER_HORIZONTAL RIGHT) |||
toX int : Final location of the view after dragging |||
toY int : Final location of the view after dragging |||",int distance in pixels covered by the drag |||,3,"Reusable methods for generating touch events. These methods can be used with
 InstrumentationTestCase or ActivityInstrumentationTestCase2 to simulate user interaction with
 the application through a touch screen.",,,,,,,,
<android.database.sqlite.SQLiteDatabase: void beginTransactionWithListener(SQLiteTransactionListener)>,"Begins a transaction in EXCLUSIVE mode. Transactions can be nested.
 When the outer transaction is ended all of
 the work done in that transaction and all of the nested transactions will be committed or
 rolled back. The changes will be rolled back if any transaction is ended without being
 marked as clean (by calling setTransactionSuccessful). Otherwise they will be committed. Here is the standard idiom for transactions:","transactionListener SQLiteTransactionListener : listener that should be notified when the transaction begins
commits or is rolled back either explicitly or by a call to yieldIfContendedSafely() . |||",void,5,"Exposes methods to manage a SQLite database.

  
 SQLiteDatabase has methods to create delete execute SQL commands and
 perform other common database management tasks.
  
 See the Notepad sample application in the SDK for an example of creating
 and managing a database.
  
 Database names must be unique within an application not across all applications.
  Localized Collation - ORDER BY 
 In addition to SQLite's default  BINARY  collator Android supplies
 two more  LOCALIZED  which changes with the system's current locale
 and  UNICODE  which is the Unicode Collation Algorithm and not tailored
 to the current locale.","If you need to manage data in a private database use the  android.database.sqlite  classes. These classes are used to manage the  Cursor  object returned from a content provider query. Databases
 are usually created and opened with  openOrCreateDatabase(String int SQLiteDatabase.CursorFactory) 
 To make requests through
 content providers you can use the  content.ContentResolver  class.
  All databases are stored on the device in  /data/data/<package_name>/databases",,,,,,,
<android.widget.QuickContactBadge: void onClick(View)>,Called when a view has been clicked.,v View : The view that was clicked. |||,void,5,"Widget used to show an image with the standard QuickContact badge
 and on-click behavior.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.nfc.tech.NfcBarcode: NfcBarcode get(Tag)>,Get an instance of NfcBarcode for the given tag. Returns null if NfcBarcode was not enumerated in Tag#getTechList . Does not cause any RF activity and does not block.,tag Tag : an NfcBarcode compatible tag |||,NfcBarcode NfcBarcode object |||,17,"Provides access to NFC-B (ISO 14443-3B) properties and I/O operations on a  Tag .

  Acquire a  NfcB  object using  get(Tag) .
  The primary NFC-B I/O operation is  transceive(byte[]) . Applications must
 implement their own protocol stack on top of  transceive(byte[]) .

  Note:  Methods that perform I/O operations
 require the  Manifest.permission.NFC  permission.","These classes provide access to a tag technology's features which vary by the type
 of tag that is scanned. A scanned tag can support multiple technologies and you can find
 out what they are by calling  getTechList() . For more information on dealing with tag technologies and handling the ones that you care about see
  The Tag Dispatch System .
 The  TagTechnology  interface provides an overview of the
 supported technologies.",,,,,,,
<android.media.AudioManager: void setRingerMode(int)>,"Sets the ringer mode. Silent mode will mute the volume and will not vibrate. Vibrate mode will
 mute the volume and vibrate. Normal mode will be audible and may vibrate
 according to user settings. This method has no effect if the device implements a fixed volume policy
 as indicated by isVolumeFixed() .
 * From N onward ringer mode adjustments that would toggle Do Not Disturb are not allowed
 unless the app has been granted Do Not Disturb Access.
 See NotificationManager#isNotificationPolicyAccessGranted() .",ringerMode int : The ringer mode one of RINGER_MODE_NORMAL  RINGER_MODE_SILENT or RINGER_MODE_VIBRATE . |||,void,1,AudioManager provides access to volume and ringer mode control.,"The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",,,,,,,
"<android.app.Activity: void setFeatureDrawableResource(int,int)>",Convenience for calling Window.setFeatureDrawableResource(int int) .,"featureId int |||
resId int |||",void,1,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.widget.RadioButton: void toggle()>,Change the checked state of the view to the inverse of its current state If the radio button is already checked this method will not toggle the radio button.,,void,1,"A radio button is a two-states button that can be either checked or
 unchecked. When the radio button is unchecked the user can press or click it
 to check it. However contrary to a  CheckBox  a radio
 button cannot be unchecked by the user once checked.
  
 Radio buttons are normally used together in a
  RadioGroup . When several radio buttons live inside
 a radio group checking one radio button unchecks all the others. See the  Radio Buttons 
 guide. XML attributes 
 See  CompoundButton Attributes 
  Button Attributes 
  TextView Attributes 
  View Attributes","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.widget.AutoCompleteTextView: void onFilterComplete(int)>,Notifies the end of a filtering operation.,count int : the number of values computed by the filter |||,void,1,"An editable text view that shows completion suggestions automatically
 while the user is typing. The list of suggestions is displayed in a drop
 down menu from which the user can choose an item to replace the content
 of the edit box with. The drop down can be dismissed at any time by pressing the back key or
 if no item is selected in the drop down by pressing the enter/dpad center
 key. The list of suggestions is obtained from a data adapter and appears
 only after a given number of characters defined by
  the threshold . The following code snippet shows how to create a text view which suggests
 various countries names while the user is typing: 
 public class CountriesActivity extends Activity {
     protected void onCreate(Bundle icicle) {
         super.onCreate(icicle);
         setContentView(R.layout.countries);

         ArrayAdapter<String> adapter = new ArrayAdapter<String>(this
                 android.R.layout.simple_dropdown_item_1line COUNTRIES);
         AutoCompleteTextView textView = (AutoCompleteTextView)
                 findViewById(R.id.countries_list);
         textView.setAdapter(adapter);
     }

     private static final String[] COUNTRIES = new String[] {
         ""Belgium"" ""France"" ""Italy"" ""Germany"" ""Spain""
     };
 }
  See the  Text Fields 
 guide.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.preference.PreferenceManager: SharedPreferences getDefaultSharedPreferences(Context)>,"Gets a SharedPreferences instance that points to the default file that is used by
 the preference framework in the given context.",context Context : The context of the preferences whose values are wanted. |||,"SharedPreferences A SharedPreferences instance that can be used to retrieve and listen
         to values of the preferences. |||",1,"Used to help create  Preference  hierarchies
 from activities or XML.
  
 In most cases clients should use
  PreferenceActivity#addPreferencesFromIntent  or
  PreferenceActivity#addPreferencesFromResource(int) .",,,,,,,,
"<android.content.ContextWrapper: Context createPackageContext(String,int)>","Return a new Context object for the given application name.  This
 Context is the same as what the named application gets when it is
 launched containing the same resources and class loader.  Each call to
 this method returns a new instance of a Context object; Context objects
 are not shared however they share common state (Resources ClassLoader
 etc) so the Context instance itself is fairly lightweight. Throws PackageManager.NameNotFoundException if there is no
 application with the given package name. Throws SecurityException if the Context requested
 can not be loaded into the caller's process for security reasons (see CONTEXT_INCLUDE_CODE for more information}.","packageName String : Name of the application's package. |||
flags int : Option flags.
Value is either 0 or a combination of Context.CONTEXT_INCLUDE_CODE  Context.CONTEXT_IGNORE_SECURITY  Context.CONTEXT_RESTRICTED android.content.Context.CONTEXT_DEVICE_PROTECTED_STORAGE android.content.Context.CONTEXT_CREDENTIAL_PROTECTED_STORAGE and android.content.Context.CONTEXT_REGISTER_PACKAGE |||",Context A Context for the application. |||,1,"Proxying implementation of Context that simply delegates all of its calls to
 another Context.  Can be subclassed to modify behavior without changing
 the original Context.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.widget.AdapterViewFlipper: void showNext()>,Manually shows the next child.,,void,11,"Simple  ViewAnimator  that will animate between two or more views
 that have been added to it.  Only one child is shown at a time.  If
 requested can automatically flip between each child at a regular interval.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.accounts.AccountManager: AccountManager get(Context)>,"Gets an AccountManager instance associated with a Context.
 The Context will be used as long as the AccountManager is
 active so make sure to use a Context whose lifetime is
 commensurate with any listeners registered to addOnAccountsUpdatedListener(OnAccountsUpdateListener Handler boolean) or similar methods. It is safe to call this method from the main thread. No permission is required to call this method.",context Context : The Context to use when necessary |||,AccountManager An AccountManager instance |||,5,"This class provides access to a centralized registry of the user's
 online accounts.  The user enters credentials (username and password) once
 per account granting applications access to online resources with
 ""one-click"" approval.

  Different online services have different ways of handling accounts and
 authentication so the account manager uses pluggable  authenticator 
 modules for different  account types .  Authenticators (which may be
 written by third parties) handle the actual details of validating account
 credentials and storing account information.  For example Google Facebook
 and Microsoft Exchange each have their own authenticator.

  Many servers support some notion of an  authentication token 
 which can be used to authenticate a request to the server without sending
 the user's actual password.  (Auth tokens are normally created with a
 separate request which does include the user's credentials.)  AccountManager
 can generate auth tokens for applications so the application doesn't need to
 handle passwords directly.  Auth tokens are normally reusable and cached by
 AccountManager but must be refreshed periodically.  It's the responsibility
 of applications to  invalidate  auth tokens when they stop working so
 the AccountManager knows it needs to regenerate them.

  Applications accessing a server normally go through these steps:

  Get an instance of AccountManager using  get(android.content.Context) .

  List the available accounts using  getAccountsByType(String)  or
  getAccountsByTypeAndFeatures(String String[] AccountManagerCallback  Handler) .  Normally applications will only
 be interested in accounts with one particular  type  which
 identifies the authenticator.  Account  features  are used to
 identify particular account subtypes and capabilities.  Both the account
 type and features are authenticator-specific strings and must be known by
 the application in coordination with its preferred authenticators.

  Select one or more of the available accounts possibly by asking the
 user for their preference.  If no suitable accounts are available
  addAccount(String String String[] Bundle Activity AccountManagerCallback  Handler)  may be called to prompt the user to create an
 account of the appropriate type.

  Important:  If the application is using a previously remembered
 account selection it must make sure the account is still in the list
 of accounts returned by  getAccountsByType(String) .  Requesting an auth token
 for an account no longer on the device results in an undefined failure.

  Request an auth token for the selected account(s) using one of the
  getAuthToken(Account String Bundle Activity AccountManagerCallback  Handler)  methods or related helpers.  Refer to the description
 of each method for exact usage and error handling details.

  Make the request using the auth token.  The form of the auth token
 the format of the request and the protocol used are all specific to the
 service you are accessing.  The application may use whatever network and
 protocol libraries are useful.

  Important:  If the request fails with an authentication error
 it could be that a cached auth token is stale and no longer honored by
 the server.  The application must call  invalidateAuthToken(String String)  to remove
 the token from the cache otherwise requests will continue failing!  After
 invalidating the auth token immediately go back to the ""Request an auth
 token"" step above.  If the process fails the second time then it can be
 treated as a ""genuine"" authentication failure and the user notified or other
 appropriate actions taken.
  Some AccountManager methods may need to interact with the user to
 prompt for credentials present options or ask the user to add an account.
 The caller may choose whether to allow AccountManager to directly launch the
 necessary user interface and wait for the user or to return an Intent which
 the caller may use to launch the interface or (in some cases) to install a
 notification which the user can select at any time to launch the interface.
 To have AccountManager launch the interface directly the caller must supply
 the current foreground  Activity  context.

  Many AccountManager methods take  AccountManagerCallback  and
  Handler  as parameters.  These methods return immediately and
 run asynchronously. If a callback is provided then
  AccountManagerCallback#run  will be invoked on the Handler's
 thread when the request completes successfully or not.
 The result is retrieved by calling  AccountManagerFuture#getResult() 
 on the  AccountManagerFuture  returned by the method (and also passed
 to the callback).  This method waits for the operation to complete (if
 necessary) and either returns the result or throws an exception if an error
 occurred during the operation.  To make the request synchronously call
  AccountManagerFuture#getResult()  immediately on receiving the
 future from the method; no callback need be supplied.

  Requests which may block including
  AccountManagerFuture#getResult()  must never be called on
 the application's main event thread.  These operations throw
  IllegalStateException  if they are used on the main thread.",,,,,,,,
"<android.widget.RemoteViews: void setUri(int,String,Uri)>",Call a method taking one Uri on a view in the layout for this RemoteViews.,"viewId int : The id of the view on which to call the method. |||
methodName String : The name of the method to call. |||
value Uri : The value to pass to the method. |||",void,3,"A class that describes a view hierarchy that can be displayed in
 another process. The hierarchy is inflated from a layout resource
 file and this class provides some basic operations for modifying
 the content of the inflated hierarchy.

  RemoteViews  is limited to support for the following layouts: AdapterViewFlipper FrameLayout GridLayout GridView LinearLayout ListView RelativeLayout StackView ViewFlipper And the following widgets: AnalogClock Button Chronometer ImageButton ImageView ProgressBar TextClock TextView Descendants of these classes are not supported.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
"<android.os.DropBoxManager: void addData(String,byte,int)>",Stores binary data which may be ignored or discarded as with addText(String String) .,"tag String : describing the type of entry being stored |||
data byte : value to store |||
flags int : describing the data |||",void,8,"Enqueues chunks of data (from various sources -- application crashes kernel
 log records etc.).  The queue is size bounded and will drop old data if the
 enqueued data exceeds the maximum size.  You can think of this as a
 persistent system-wide blob-oriented ""logcat"".

  DropBoxManager entries are not sent anywhere directly but other system
 services and debugging tools may scan and upload entries for processing.",,,,,,,,
<android.inputmethodservice.InputMethodService: int getMaxWidth()>,"Return the maximum width in pixels available the input method.
 Input methods are positioned at the bottom of the screen and unless
 running in fullscreen will generally want to be as short as possible
 so should compute their height based on their contents.  However they
 can stretch as much as needed horizontally.  The function returns to
 you the maximum amount of space available horizontally which you can
 use if needed for UI placement. In many cases this is not needed you can just rely on the normal
 view layout mechanisms to position your views within the full horizontal
 space given to the input method. Note that this value can change dynamically in particular when the
 screen orientation changes.",,int |||,3,"InputMethodService provides a standard implementation of an InputMethod
 which final implementations can derive from and customize.  See the
 base class  AbstractInputMethodService  and the  InputMethod 
 interface for more information on the basics of writing input methods.

  In addition to the normal Service lifecycle methods this class
 introduces some new specific callbacks that most subclasses will want
 to make use of: onInitializeInterface()  for user-interface initialization
 in particular to deal with configuration changes while the service is
 running.
  onBindInput()  to find out about switching to a new client.
  onStartInput(EditorInfo boolean)  to deal with an input session starting with
 the client.
  onCreateInputView()   onCreateCandidatesView() 
 and  onCreateExtractTextView()  for non-demand generation of the UI.
  onStartInputView(android.view.inputmethod.EditorInfo boolean)  to deal with input
 starting within the input area of the IME.
  An input method has significant discretion in how it goes about its
 work: the  InputMethodService  provides
 a basic framework for standard UI elements (input view candidates view
 and running in fullscreen mode) but it is up to a particular implementor
 to decide how to use them.  For example one input method could implement
 an input area with a keyboard another could allow the user to draw text
 while a third could have no input area (and thus not be visible to the
 user) but instead listen to audio and perform text to speech conversion. In the implementation provided here all of these elements are placed
 together in a single window managed by the InputMethodService.  It will
 execute callbacks as it needs information about them and provides APIs for
 programmatic control over them.  They layout of these elements is explicitly
 defined: The soft input view if available is placed at the bottom of the
 screen.
  The candidates view if currently shown is placed above the soft
 input view.
  If not running fullscreen the application is moved or resized to be
 above these views; if running fullscreen the window will completely cover
 the application and its top part will contain the extract text of what is
 currently being edited by the application.
  Soft Input View Central to most input methods is the soft input view.  This is where most
 user interaction occurs: pressing on soft keys drawing characters or
 however else your input method wants to generate text.  Most implementations
 will simply have their own view doing all of this work and return a new
 instance of it when  onCreateInputView()  is called.  At that point
 as long as the input view is visible you will see user interaction in
 that view and can call back on the InputMethodService to interact with the
 application as appropriate. There are some situations where you want to decide whether or not your
 soft input view should be shown to the user.  This is done by implementing
 the  onEvaluateInputViewShown()  to return true or false based on
 whether it should be shown in the current environment.  If any of your
 state has changed that may impact this call
  updateInputViewShown()  to have it re-evaluated.  The default
 implementation always shows the input view unless there is a hard
 keyboard available which is the appropriate behavior for most input
 methods. Candidates View Often while the user is generating raw text an input method wants to
 provide them with a list of possible interpretations of that text that can
 be selected for use.  This is accomplished with the candidates view and
 like the soft input view you implement  onCreateCandidatesView() 
 to instantiate your own view implementing your candidates UI. Management of the candidates view is a little different than the input
 view because the candidates view tends to be more transient being shown
 only when there are possible candidates for the current text being entered
 by the user.  To control whether the candidates view is shown you use
  setCandidatesViewShown(boolean) .  Note that because the candidate
 view tends to be shown and hidden a lot it does not impact the application
 UI in the same way as the soft input view: it will never cause application
 windows to resize only cause them to be panned if needed for the user to
 see the current focus. Fullscreen Mode Sometimes your input method UI is too large to integrate with the
 application UI so you just want to take over the screen.  This is
 accomplished by switching to full-screen mode causing the input method
 window to fill the entire screen and add its own ""extracted text"" editor
 showing the user the text that is being typed.  Unlike the other UI elements
 there is a standard implementation for the extract editor that you should
 not need to change.  The editor is placed at the top of the IME above the
 input and candidates views. Similar to the input view you control whether the IME is running in
 fullscreen mode by implementing  onEvaluateFullscreenMode() 
 to return true or false based on
 whether it should be fullscreen in the current environment.  If any of your
 state has changed that may impact this call
  updateFullscreenMode()  to have it re-evaluated.  The default
 implementation selects fullscreen mode when the screen is in a landscape
 orientation which is appropriate behavior for most input methods that have
 a significant input area. When in fullscreen mode you have some special requirements because the
 user can not see the application UI.  In particular you should implement
  onDisplayCompletions(android.view.inputmethod.CompletionInfo[])  to show completions
 generated by your application typically in your candidates view like you
 would normally show candidates.


  Generating Text The key part of an IME is of course generating text for the application.
 This is done through calls to the
  InputConnection  interface to the
 application which can be retrieved from  getCurrentInputConnection() .
 This interface allows you to generate raw key events or if the target
 supports it directly edit in strings of candidates and committed text. Information about what the target is expected and supports can be found
 through the  EditorInfo  class which is
 retrieved with  getCurrentInputEditorInfo()  method.  The most
 important part of this is  EditorInfo.inputType ; in particular if this is
  EditorInfo.TYPE_NULL 
 then the target does not support complex edits and you need to only deliver
 raw key events to it.  An input method will also want to look at other
 values here to for example detect password mode auto complete text views
 phone number entry etc. When the user switches between input targets you will receive calls to
  onFinishInput()  and  onStartInput(android.view.inputmethod.EditorInfo boolean) .
 You can use these to reset and initialize your input state for the current
 target.  For example you will often want to clear any input state and
 update a soft keyboard to be appropriate for the new inputType.",,,,,,,,
<android.animation.ValueAnimator: void reverse()>,"Plays the ValueAnimator in reverse. If the animation is already running
 it will stop itself and play backwards from the point reached when reverse was called.
 If the animation is not currently running then it will start from the end and
 play backwards. This behavior is only set for the current animation; future playing
 of the animation will use the default behavior of playing forward.",,void,11,"This class provides a simple timing engine for running animations
 which calculate animated values and set them on target objects.

  There is a single timing pulse that all animations use. It runs in a
 custom handler to ensure that property changes happen on the UI thread. By default ValueAnimator uses non-linear time interpolation via the
  AccelerateDecelerateInterpolator  class which accelerates into and decelerates
 out of an animation. This behavior can be changed by calling
  ValueAnimator#setInterpolator(TimeInterpolator) . Animators can be created from either code or resource files. Here is an example
 of a ValueAnimator resource file: <animator xmlns:android=""http://schemas.android.com/apk/res/android""
    android:duration=""1000""
    android:valueFrom=""1""
    android:valueTo=""0""
    android:valueType=""floatType""
    android:repeatCount=""1""
    android:repeatMode=""reverse""/> Starting from API 23 it is also possible to use a combination of  PropertyValuesHolder 
 and  Keyframe  resource tags to create a multi-step animation.
 Note that you can specify explicit fractional values (from 0 to 1) for
 each keyframe to determine when in the overall duration the animation should arrive at that
 value. Alternatively you can leave the fractions off and the keyframes will be equally
 distributed within the total duration: <animator xmlns:android=""http://schemas.android.com/apk/res/android""
          android:duration=""1000""
          android:repeatCount=""1""
          android:repeatMode=""reverse"">
    <propertyValuesHolder>
        <keyframe android:fraction=""0"" android:value=""1""/>
        <keyframe android:fraction="".2"" android:value="".4""/>
        <keyframe android:fraction=""1"" android:value=""0""/>
    </propertyValuesHolder>
</animator>","These classes provide functionality for the property animation system which allows you
 to animate object properties of any type.  int   float  and hexadecimal
 color values are supported by default. You can animate any other type by telling the system how
 to calculate the values for that given type with a custom  TypeEvaluator .
  For more information see the
  Animation  guide. 
 You can set many different types of interpolators (contained in  android.view.animation )
 specify  keyframes  or group animations to play sequentially
 or simultaneously (with  AnimatorSet ) to further control your animation
 behaviors.",,,,,,,
<android.accounts.AccountManager: Account getAccounts()>,"Lists all accounts visible to the caller regardless of type. Equivalent to
 getAccountsByType(null). These accounts may be visible because the user granted access to the
 account or the AbstractAcccountAuthenticator managing the account did so or because the
 client shares a signature with the managing AbstractAccountAuthenticator. It is safe to call this method from the main thread. Requires Manifest.permission.GET_ACCOUNTS",,"Account[] An array of Account one for each account. Empty (never null) if no accounts
         have been added. |||",5,"This class provides access to a centralized registry of the user's
 online accounts.  The user enters credentials (username and password) once
 per account granting applications access to online resources with
 ""one-click"" approval.

  Different online services have different ways of handling accounts and
 authentication so the account manager uses pluggable  authenticator 
 modules for different  account types .  Authenticators (which may be
 written by third parties) handle the actual details of validating account
 credentials and storing account information.  For example Google Facebook
 and Microsoft Exchange each have their own authenticator.

  Many servers support some notion of an  authentication token 
 which can be used to authenticate a request to the server without sending
 the user's actual password.  (Auth tokens are normally created with a
 separate request which does include the user's credentials.)  AccountManager
 can generate auth tokens for applications so the application doesn't need to
 handle passwords directly.  Auth tokens are normally reusable and cached by
 AccountManager but must be refreshed periodically.  It's the responsibility
 of applications to  invalidate  auth tokens when they stop working so
 the AccountManager knows it needs to regenerate them.

  Applications accessing a server normally go through these steps:

  Get an instance of AccountManager using  get(android.content.Context) .

  List the available accounts using  getAccountsByType(String)  or
  getAccountsByTypeAndFeatures(String String[] AccountManagerCallback  Handler) .  Normally applications will only
 be interested in accounts with one particular  type  which
 identifies the authenticator.  Account  features  are used to
 identify particular account subtypes and capabilities.  Both the account
 type and features are authenticator-specific strings and must be known by
 the application in coordination with its preferred authenticators.

  Select one or more of the available accounts possibly by asking the
 user for their preference.  If no suitable accounts are available
  addAccount(String String String[] Bundle Activity AccountManagerCallback  Handler)  may be called to prompt the user to create an
 account of the appropriate type.

  Important:  If the application is using a previously remembered
 account selection it must make sure the account is still in the list
 of accounts returned by  getAccountsByType(String) .  Requesting an auth token
 for an account no longer on the device results in an undefined failure.

  Request an auth token for the selected account(s) using one of the
  getAuthToken(Account String Bundle Activity AccountManagerCallback  Handler)  methods or related helpers.  Refer to the description
 of each method for exact usage and error handling details.

  Make the request using the auth token.  The form of the auth token
 the format of the request and the protocol used are all specific to the
 service you are accessing.  The application may use whatever network and
 protocol libraries are useful.

  Important:  If the request fails with an authentication error
 it could be that a cached auth token is stale and no longer honored by
 the server.  The application must call  invalidateAuthToken(String String)  to remove
 the token from the cache otherwise requests will continue failing!  After
 invalidating the auth token immediately go back to the ""Request an auth
 token"" step above.  If the process fails the second time then it can be
 treated as a ""genuine"" authentication failure and the user notified or other
 appropriate actions taken.
  Some AccountManager methods may need to interact with the user to
 prompt for credentials present options or ask the user to add an account.
 The caller may choose whether to allow AccountManager to directly launch the
 necessary user interface and wait for the user or to return an Intent which
 the caller may use to launch the interface or (in some cases) to install a
 notification which the user can select at any time to launch the interface.
 To have AccountManager launch the interface directly the caller must supply
 the current foreground  Activity  context.

  Many AccountManager methods take  AccountManagerCallback  and
  Handler  as parameters.  These methods return immediately and
 run asynchronously. If a callback is provided then
  AccountManagerCallback#run  will be invoked on the Handler's
 thread when the request completes successfully or not.
 The result is retrieved by calling  AccountManagerFuture#getResult() 
 on the  AccountManagerFuture  returned by the method (and also passed
 to the callback).  This method waits for the operation to complete (if
 necessary) and either returns the result or throws an exception if an error
 occurred during the operation.  To make the request synchronously call
  AccountManagerFuture#getResult()  immediately on receiving the
 future from the method; no callback need be supplied.

  Requests which may block including
  AccountManagerFuture#getResult()  must never be called on
 the application's main event thread.  These operations throw
  IllegalStateException  if they are used on the main thread.",,,,,,,,
<android.view.accessibility.AccessibilityNodeInfo: List findAccessibilityNodeInfosByText(String)>,"Finds AccessibilityNodeInfo s by text. The match is case
 insensitive containment. The search is relative to this info i.e.
 this info is the root of the traversed tree. Note: It is a client responsibility to recycle the
     received info by calling AccessibilityNodeInfo#recycle() to avoid creating of multiple instances. Note: If this view hierarchy has a SurfaceView embedding another
 view hierarchy via SurfaceView#setChildSurfacePackage there is a limitation that
 this API won't be able to find the node for the view on the embedded view hierarchy. It's
 because views don't know about the embedded hierarchies. Instead you could traverse all
 the children to find the node.",text String : The searched text. |||,List < AccessibilityNodeInfo > A list of node info. |||,14,"This class represents a node of the window content as well as actions that
 can be requested from its source. From the point of view of an
  AccessibilityService  a window's content is
 presented as a tree of accessibility node infos which may or may not map one-to-one
 to the view hierarchy. In other words a custom view is free to report itself as
 a tree of accessibility node info.
  
 Once an accessibility node info is delivered to an accessibility service it is
 made immutable and calling a state mutation method generates an error.
  
 Please refer to  AccessibilityService  for
 details about how to obtain a handle to window content as a tree of accessibility
 node info as well as details about the security model.",,,,,,,,
<android.widget.RadioGroup: void check(int)>,"Sets the selection to the radio button whose identifier is passed in
 parameter. Using -1 as the selection identifier clears the selection;
 such an operation is equivalent to invoking clearCheck() .",id int : the unique id of the radio button to select in this group |||,void,1,"This class is used to create a multiple-exclusion scope for a set of radio
 buttons. Checking one radio button that belongs to a radio group unchecks
 any previously checked radio button within the same group. Intially all of the radio buttons are unchecked. While it is not possible
 to uncheck a particular radio button the radio group can be cleared to
 remove the checked state. The selection is identified by the unique id of the radio button as defined
 in the XML layout file. XML Attributes See  RadioGroup Attributes 
  LinearLayout Attributes 
  ViewGroup Attributes 
  View Attributes Also see
  LinearLayout.LayoutParams 
 for layout attributes.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.webkit.WebView: void saveWebArchive(String)>,Saves the current view as a web archive.,"filename String : the filename where the archive should be placed
This value cannot be null . |||",void,11,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",,,,,,,
"<android.widget.PopupWindow: void showAsDropDown(View,int,int)>","Display the content view in a popup window anchored to the bottom-left
 corner of the anchor view offset by the specified x and y coordinates.
 If there is not enough room on screen to show the popup in its entirety
 this method tries to find a parent scroll view to scroll. If no parent
 scroll view can be scrolled the bottom-left corner of the popup is
 pinned at the top left corner of the anchor view. If the view later scrolls to move anchor to a different
 location the popup will be moved correspondingly.","anchor View : the view on which to pin the popup window |||
xoff int : A horizontal offset from the anchor in pixels |||
yoff int : A vertical offset from the anchor in pixels |||",void,1,"This class represents a popup window that can be used to display an
 arbitrary view. The popup window is a floating container that appears on top
 of the current activity.
  Animation 
 On all versions of Android popup window enter and exit animations may be
 specified by calling  setAnimationStyle(int)  and passing the
 resource ID for an animation style that defines  windowEnterAnimation 
 and  windowExitAnimation . For example passing
  R.style.Animation_Dialog  will give a scale and alpha
 animation.
 
 A window animation style may also be specified in the popup window's style
 XML via the  popupAnimationStyle 
 attribute.
  
 Starting with API 23 more complex popup window enter and exit transitions
 may be specified by calling either  setEnterTransition(android.transition.Transition) 
 or  setExitTransition(android.transition.Transition)  and passing a   Transition .
 
 Popup enter and exit transitions may also be specified in the popup window's
 style XML via the  popupEnterTransition 
 and  popupExitTransition 
 attributes respectively.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
"<android.media.RingtoneManager: Uri getActualDefaultRingtoneUri(Context,int)>","Gets the current default sound's Uri . This will give the actual
 sound Uri instead of using this most clients can use System#DEFAULT_RINGTONE_URI .","context Context : A context used for querying. |||
type int : The type whose default sound should be returned. One of TYPE_RINGTONE  TYPE_NOTIFICATION or TYPE_ALARM . |||",Uri A Uri pointing to the default sound for the sound type. |||,1,"RingtoneManager provides access to ringtones notification and other types
 of sounds. It manages querying the different media providers and combines the
 results into a single cursor. It also provides a  Ringtone  for each
 ringtone. We generically call these sounds ringtones however the
  TYPE_RINGTONE  refers to the type of sounds that are suitable for the
 phone ringer.
  
 To show a ringtone picker to the user use the
  ACTION_RINGTONE_PICKER  intent to launch the picker as a subactivity.","The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",,,,,,,
"<android.text.SpannableStringBuilder: SpannableStringBuilder append(CharSequence,int,int)>",Convenience for replace(length() length() text start end),"text CharSequence : The character sequence from which a subsequence will be
appended.  If csq is null then characters
will be appended as if csq contained the four
characters ""null"" . |||
start int : The index of the first character in the subsequence |||
end int : The index of the character following the last character in the
subsequence |||",SpannableStringBuilder A reference to this Appendable |||,1,"This is the class for text whose content is immutable but to which
 markup objects can be attached and detached.
 For mutable text see  SpannableStringBuilder .","Provides classes used to render or track text and text spans on the screen. You can use these classes to design your own widgets that manage text
 to handle arbitrary text spans for changes or to handle drawing yourself
 for an existing widget. The Span… interfaces and classes are used to create or manage spans of
 text in a View item. You can use these to style the text or background or to
 listen for changes. If creating your own widget extend DynamicLayout to manages
 the actual wrapping and drawing of your text.",,,,,,,
"<android.text.Layout: void draw(Canvas,Path,Paint,int)>","Draw this Layout on the specified canvas with the highlight path drawn
 between the background and the text.","canvas Canvas : the canvas |||
highlight Path : the path of the highlight or cursor; can be null |||
highlightPaint Paint : the paint for the highlight |||
cursorOffsetVertical int : the amount to temporarily translate the
canvas while rendering the highlight |||",void,1,"A base class that manages text layout in visual elements on
 the screen.
  For text that will be edited use a  DynamicLayout 
 which will be updated as the text changes.
 For text that will not change use a  StaticLayout .","Provides classes used to render or track text and text spans on the screen. You can use these classes to design your own widgets that manage text
 to handle arbitrary text spans for changes or to handle drawing yourself
 for an existing widget. The Span… interfaces and classes are used to create or manage spans of
 text in a View item. You can use these to style the text or background or to
 listen for changes. If creating your own widget extend DynamicLayout to manages
 the actual wrapping and drawing of your text.",,,,,,,
<android.widget.SlidingDrawer: void animateOpen()>,Opens the drawer with an animation.,,void,3,"SlidingDrawer hides content out of the screen and allows the user to drag a handle
 to bring the content on screen. SlidingDrawer can be used vertically or horizontally.

 A special widget composed of two children views: the handle that the users drags
 and the content attached to the handle and dragged with it.

 SlidingDrawer should be used as an overlay inside layouts. This means SlidingDrawer
 should only be used inside of a FrameLayout or a RelativeLayout for instance. The
 size of the SlidingDrawer defines how much space the content will occupy once slid
 out so SlidingDrawer should usually use match_parent for both its dimensions.

 Inside an XML layout SlidingDrawer must define the id of the handle and of the
 content:

  
 <SlidingDrawer
     android:id=""@+id/drawer""
     android:layout_width=""match_parent""
     android:layout_height=""match_parent""

     android:handle=""@+id/handle""
     android:content=""@+id/content"">

     <ImageView
         android:id=""@id/handle""
         android:layout_width=""88dip""
         android:layout_height=""44dip"" />

     <GridView
         android:id=""@id/content""
         android:layout_width=""match_parent""
         android:layout_height=""match_parent"" />

 </SlidingDrawer>","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.preference.DialogPreference: void onActivityDestroy()>,See Activity's onDestroy.,,void,1,"A base class for  Preference  objects that are
 dialog-based. These preferences will when clicked open a dialog showing the
 actual preference controls.",,,,,,,,
"<android.net.sip.SipSession: void makeCall(SipProfile,String,int)>","Initiates a call to the specified profile. The session listener is called
 back upon defined session events. The method is only valid to call when
 the session state is in State#READY_TO_CALL .","callee SipProfile : the SIP profile to make the call to |||
sessionDescription String : the session description of this call |||
timeout int : the session will be timed out if the call is not
established within timeout seconds. Default value (defined
by SIP protocol) is used if timeout is zero or negative. |||",void,9,"Represents a SIP session that is associated with a SIP dialog or a standalone
 transaction not within a dialog.
  You can get a  SipSession  from  SipManager  with  SipManager#createSipSession  (when initiating calls) or  SipManager#getSessionFor  (when receiving calls).",,,,,,,,
"<android.content.pm.PackageItemInfo: void writeToParcel(Parcel,int)>",,"dest Parcel |||
parcelableFlags int |||",void,1,"Base class containing information common to all package items held by
 the package manager.  This provides a very common basic set of attributes:
 a label icon and meta-data.  This class is not intended
 to be used by itself; it is simply here to share common definitions
 between all items returned by the package manager.  As such it does not
 itself implement Parcelable but does provide convenience methods to assist
 in the implementation of Parcelable in subclasses.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.widget.ListView: void smoothScrollByOffset(int)>,"Smoothly scroll to the specified adapter position offset. The view will
 scroll such that the indicated position is displayed.",offset int : The amount to offset from the adapter position to scroll to. |||,void,11,"Displays a vertically-scrollable collection of views where each view is positioned
 immediatelybelow the previous view in the list.  For a more modern flexible and performant
 approach to displaying lists use  RecyclerView . To display a list you can include a list view in your layout XML file: <ListView
      android:id=""@+id/list_view""
      android:layout_width=""match_parent""
      android:layout_height=""match_parent"" /> A list view is an  
 adapter view  that does not know the details such as type and contents of the views it
 contains. Instead list view requests views on demand from a  ListAdapter  as needed
 such as to display new views as the user scrolls up or down. In order to display items in the list call  setAdapter(android.widget.ListAdapter) 
 to associate an adapter with the list.  For a simple example see the discussion of filling an
 adapter view with text in the
  
 Layouts  guide. To display a more custom view for each item in your dataset implement a ListAdapter.
 For example extend  BaseAdapter  and create and configure the view for each data item in
  getView(...) : private class MyAdapter extends BaseAdapter {

      // override other abstract methods here

      @Override
      public View getView(int position View convertView ViewGroup container) {
          if (convertView == null) {
              convertView = getLayoutInflater().inflate(R.layout.list_item container false);
          }

          ((TextView) convertView.findViewById(android.R.id.text1))
                  .setText(getItem(position));
          return convertView;
      }
  } ListView attempts to reuse view objects in order to improve performance and
 avoid a lag in response to user scrolls.  To take advantage of this feature check if the
  convertView  provided to  getView(...)  is null before creating or inflating a new
 view object.  See
  
 Making ListView Scrolling Smooth  for more ways to ensure a smooth user experience. To specify an action when a user clicks or taps on a single list item see
  
     Handling click events . To learn how to populate a list view with a CursorAdapter see the discussion of filling an
 adapter view with text in the
  
 Layouts  guide.
 See  
     Using a Loader 
 to learn how to avoid blocking the main thread when using a cursor. Note many examples use  ListActivity 
 or  ListFragment 
 to display a list view. Instead favor the more flexible approach when writing your own app:
 use a more generic Activity subclass or Fragment subclass and add a list view to the layout
 or view hierarchy directly.  This approach gives you more direct control of the
 list view and adapter.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
"<android.content.ContentProviderClient: int bulkInsert(Uri,ContentValues)>",See ContentProvider#bulkInsert,"url Uri : This value cannot be null . |||
initialValues ContentValues : This value cannot be null . |||",int |||,5,"Content providers are one of the primary building blocks of Android applications providing
 content to applications. They encapsulate data and provide it to applications through the single
  ContentResolver  interface. A content provider is only required if you need to share
 data between multiple applications. For example the contacts data is used by multiple
 applications and must be stored in a content provider. If you don't need to share data amongst
 multiple applications you can use a database directly via
  SQLiteDatabase .

  When a request is made via
 a  ContentResolver  the system inspects the authority of the given URI and passes the
 request to the content provider registered with the authority. The content provider can interpret
 the rest of the URI however it wants. The  UriMatcher  class is helpful for parsing
 URIs. The primary methods that need to be implemented are:
  onCreate()  which is called to initialize the provider query(Uri String[] Bundle CancellationSignal)  which returns data to the caller insert(Uri ContentValues)  which inserts new data into the content provider update(Uri ContentValues String String[])  which updates existing data in the content provider delete(Uri String String[])  which deletes data from the content provider getType(Uri)  which returns the MIME type of data in the content provider Requests to  ContentResolver  are automatically forwarded to the appropriate
 ContentProvider instance so subclasses don't have to worry about the details of
 cross-process calls.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
"<android.widget.DatePicker: void updateDate(int,int,int)>",Update the current date.,"year int : The year. |||
month int : The month which is starting from zero . |||
dayOfMonth int : The day of the month. |||",void,1,"Provides a widget for selecting a date.
  
 When the  R.styleable.DatePicker_datePickerMode  attribute is
 set to  spinner  the date can be selected using year month and day
 spinners or a  CalendarView . The set of spinners and the calendar
 view are automatically synchronized. The client can customize whether only
 the spinners or only the calendar view or both to be displayed.
  
 When the  R.styleable.DatePicker_datePickerMode  attribute is
 set to  calendar  the month and day can be selected using a
 calendar-style view while the year can be selected separately using a list.
  
 See the  Pickers 
 guide.
  
 For a dialog using this view see  DatePickerDialog .","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.view.Display: void getSize(Point)>,"This method was deprecated
      in API level 30. Use WindowManager#getCurrentWindowMetrics() to obtain an instance of WindowMetrics and use WindowMetrics#getBounds() instead. Gets the size of the display in pixels.
 Value returned by this method does not necessarily represent the actual raw size
 (native resolution) of the display. 1. The returned size may be adjusted to exclude certain system decor elements
 that are always visible. 2. It may be scaled to provide compatibility with older applications that
 were originally designed for smaller displays. 3. It can be different depending on the WindowManager to which the display belongs. - If requested from non-Activity context (e.g. Application context via (WindowManager) getApplicationContext().getSystemService(Context.WINDOW_SERVICE) )
 it will report the size of the entire display based on current rotation and with subtracted
 system decoration areas. - If requested from activity (either using getWindowManager() or (WindowManager) getSystemService(Context.WINDOW_SERVICE) ) resulting size will
 correspond to current app window size. In this case it can be smaller than physical size in
 multi-window mode. Typically for the purposes of layout apps should make a request from activity context
 to obtain size available for the app content.",outSize Point : A Point object to receive the size information. |||,void,13,"Provides information about the size and density of a logical display.
  
 The display area is described in two different ways.
  The application display area specifies the part of the display that may contain
 an application window excluding the system decorations.  The application display area may
 be smaller than the real display area because the system subtracts the space needed
 for decor elements such as the status bar.  Use the following methods to query the
 application display area:  getSize(Point)   getRectSize(Rect)  and  getMetrics(DisplayMetrics) . The real display area specifies the part of the display that contains content
 including the system decorations.  Even so the real display area may be smaller than the
 physical size of the display if the window manager is emulating a smaller display
 using (adb shell wm size).  Use the following methods to query the
 real display area:  getRealSize(Point)   getRealMetrics(DisplayMetrics) . 
 A logical display does not necessarily represent a particular physical display device
 such as the built-in screen or an external monitor.  The contents of a logical
 display may be presented on one or more physical displays according to the devices
 that are currently attached and whether mirroring has been enabled.",,,,,,,,
<android.content.Intent: String toURI()>,"This method was deprecated
      in API level 15. Use toUri(int) instead. Call toUri(int) with 0 flags.",,String |||,1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.content.Intent: Bundle getBundleExtra(String)>,Retrieve extended data from the intent.,name String : The name of the desired item. |||,"Bundle the value of an item previously added with putExtra()
 or null if no Bundle value was found. |||",1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.speech.tts.TextToSpeech: int setSpeechRate(float)>,"Sets the speech rate.

 This has no effect on any pre-recorded speech.","speechRate float : Speech rate. 1.0 is the normal speech rate
lower values slow down the speech ( 0.5 is half the normal speech rate)
greater values accelerate it ( 2.0 is twice the normal speech rate). |||",int ERROR or SUCCESS . |||,4,"Synthesizes speech from text for immediate playback or to create a sound file.
  A TextToSpeech instance can only be used to synthesize text once it has completed its
 initialization. Implement the  TextToSpeech.OnInitListener  to be
 notified of the completion of the initialization. 
 When you are done using the TextToSpeech instance call the  shutdown()  method
 to release the native resources used by the TextToSpeech engine.",,,,,,,,
<android.content.ContextWrapper: File getObbDir()>,"Return the primary shared/external storage directory where this
 application's OBB files (if there are any) can be found. Note if the
 application does not have any OBB files this directory may not exist. This is like getFilesDir() in that these files will be deleted
 when the application is uninstalled however there are some important
 differences: Shared storage may not always be available since removable media can
 be ejected by the user. Media state can be checked using Environment#getExternalStorageState(File) . 
There is no security enforced with these files. For example any
 application holding Manifest.permission.WRITE_EXTERNAL_STORAGE can write to
 these files. 
Starting in Build.VERSION_CODES.KITKAT no permissions
 are required to read or write to the path that this method returns.
 However starting from Build.VERSION_CODES.M to read the OBB expansion files you must declare the Manifest.permission.READ_EXTERNAL_STORAGE permission in the app manifest and ask for
 permission at runtime as follows: <uses-permission android:name=""android.permission.READ_EXTERNAL_STORAGE""
 android:maxSdkVersion=""23"" /> Starting from Build.VERSION_CODES.N  Manifest.permission.READ_EXTERNAL_STORAGE permission is not required so don?t ask for this
 permission at runtime. To handle both cases your app must first try to read the OBB file
 and if it fails you must request Manifest.permission.READ_EXTERNAL_STORAGE permission at runtime. The following code snippet shows how to do this:",,File the absolute path to application-specific directory. May return null if shared storage is not currently available. |||,11,"Proxying implementation of Context that simply delegates all of its calls to
 another Context.  Can be subclassed to modify behavior without changing
 the original Context.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
"<android.animation.LayoutTransition: void showChild(ViewGroup,View)>","This method was deprecated
      in API level 16. Use showChild(android.view.ViewGroup android.view.View int) .","parent ViewGroup |||
child View |||",void,11,"This class enables automatic animations on layout changes in ViewGroup objects. To enable
 transitions for a layout container create a LayoutTransition object and set it on any
 ViewGroup by calling  ViewGroup#setLayoutTransition(LayoutTransition) . This will cause
 default animations to run whenever items are added to or removed from that container. To specify
 custom animations use the  LayoutTransition#setAnimator(int Animator)  method.

  One of the core concepts of these transition animations is that there are two types of
 changes that cause the transition and four different animations that run because of
 those changes. The changes that trigger the transition are items being added to a container
 (referred to as an ""appearing"" transition) or removed from a container (also known as
 ""disappearing""). Setting the visibility of views (between GONE and VISIBLE) will trigger
 the same add/remove logic. The animations that run due to those events are one that animates
 items being added one that animates items being removed and two that animate the other
 items in the container that change due to the add/remove occurrence. Users of
 the transition may want different animations for the changing items depending on whether
 they are changing due to an appearing or disappearing event so there is one animation for
 each of these variations of the changing event. Most of the API of this class is concerned
 with setting up the basic properties of the animations used in these four situations
 or with setting up custom animations for any or all of the four. By default the DISAPPEARING animation begins immediately as does the CHANGE_APPEARING
 animation. The other animations begin after a delay that is set to the default duration
 of the animations. This behavior facilitates a sequence of animations in transitions as
 follows: when an item is being added to a layout the other children of that container will
 move first (thus creating space for the new item) then the appearing animation will run to
 animate the item being added. Conversely when an item is removed from a container the
 animation to remove it will run first then the animations of the other children in the
 layout will run (closing the gap created in the layout when the item was removed). If this
 default choreography behavior is not desired the  setDuration(int long)  and
  setStartDelay(int long)  of any or all of the animations can be changed as
 appropriate. Keep in mind however that if you start an APPEARING animation before a
 DISAPPEARING animation is completed the DISAPPEARING animation stops and any effects from
 the DISAPPEARING animation are reverted. If you instead start a DISAPPEARING animation
 before an APPEARING animation is completed a similar set of effects occurs for the
 APPEARING animation. The animations specified for the transition both the defaults and any custom animations
 set on the transition object are templates only. That is these animations exist to hold the
 basic animation properties such as the duration start delay and properties being animated.
 But the actual target object as well as the start and end values for those properties are
 set automatically in the process of setting up the transition each time it runs. Each of the
 animations is cloned from the original copy and the clone is then populated with the dynamic
 values of the target being animated (such as one of the items in a layout container that is
 moving as a result of the layout event) as well as the values that are changing (such as the
 position and size of that object). The actual values that are pushed to each animation
 depends on what properties are specified for the animation. For example the default
 CHANGE_APPEARING animation animates the  left   top   right 
  bottom   scrollX  and  scrollY  properties.
 Values for these properties are updated with the pre- and post-layout
 values when the transition begins. Custom animations will be similarly populated with
 the target and values being animated assuming they use ObjectAnimator objects with
 property names that are known on the target object. This class and the associated XML flag for containers animateLayoutChanges=""true""
 provides a simple utility meant for automating changes in straightforward situations.
 Using LayoutTransition at multiple levels of a nested view hierarchy may not work due to the
 interrelationship of the various levels of layout. Also a container that is being scrolled
 at the same time as items are being added or removed is probably not a good candidate for
 this utility because the before/after locations calculated by LayoutTransition
 may not match the actual locations when the animations finish due to the container
 being scrolled as the animations are running. You can work around that
 particular issue by disabling the 'changing' animations by setting the CHANGE_APPEARING
 and CHANGE_DISAPPEARING animations to null and setting the startDelay of the
 other animations appropriately.","These classes provide functionality for the property animation system which allows you
 to animate object properties of any type.  int   float  and hexadecimal
 color values are supported by default. You can animate any other type by telling the system how
 to calculate the values for that given type with a custom  TypeEvaluator .
  For more information see the
  Animation  guide. 
 You can set many different types of interpolators (contained in  android.view.animation )
 specify  keyframes  or group animations to play sequentially
 or simultaneously (with  AnimatorSet ) to further control your animation
 behaviors.",,,,,,,
"<android.os.Bundle: void putCharSequenceArray(String,CharSequence)>","Inserts a CharSequence array value into the mapping of this Bundle replacing
 any existing value for the given key.  Either key or value may be null.","key String : a String or null
This value may be null . |||
value CharSequence : a CharSequence array object or null
This value may be null . |||",void,8,A mapping from String keys to various  Parcelable  values.,,,,,,,,
<android.telephony.TelephonyManager: String getSimSerialNumber()>,"Returns the serial number of the SIM if applicable. Return null if it is
 unavailable. Starting with API level 29 persistent device identifiers are guarded behind additional
 restrictions and apps are recommended to use resettable identifiers (see Best practices for unique identifiers ). This method can be invoked if one of
 the following requirements is met: If the calling app has been granted the READ_PRIVILEGED_PHONE_STATE permission; this
     is a privileged permission that can only be granted to apps preloaded on the device. 
If the calling app is the device or profile owner and has been granted the Manifest.permission#READ_PHONE_STATE permission. The profile owner is an app that
     owns a managed profile on the device; for more details see Work profiles .
     Profile owner access is deprecated and will be removed in a future release. 
If the calling app has carrier privileges (see hasCarrierPrivileges() ). 
If the calling app is the default SMS role holder (see RoleManager#isRoleHeld(String) ). 
If the calling app does not meet one of these requirements then this method will behave
 as follows: If the calling app's target SDK is API level 28 or lower and the app has the
     READ_PHONE_STATE permission then null is returned. 
If the calling app's target SDK is API level 28 or lower and the app does not have
     the READ_PHONE_STATE permission or if the calling app is targeting API level 29 or
     higher then a SecurityException is thrown.",,String |||,1,"Provides access to information about the telephony services on
 the device. Applications can use the methods in this class to
 determine telephony services and states as well as to access some
 types of subscriber information. Applications can also register
 a listener to receive notification of telephony state changes.
  
 The returned TelephonyManager will use the default subscription for all calls.
 To call an API for a specific subscription use  createForSubscriptionId(int) . e.g.
  
   telephonyManager = defaultSubTelephonyManager.createForSubscriptionId(subId);
  
 Note that access to some telephony information is
 permission-protected. Your application cannot access the protected
 information unless it has the appropriate permissions declared in
 its manifest file. Where permissions apply they are noted in the
 the methods through which you access the protected information.",,,,,,,,
<android.text.method.TextKeyListener: void clear(Editable)>,"Clear all the input state (autotext autocap multitap undo)
 from the specified Editable going beyond Editable.clear() which
 just clears the text but not the input state.",e Editable : the buffer whose text and state are to be cleared. |||,void,1,"This is the key listener for typing normal text.  It delegates to
 other key listeners appropriate to the current keyboard and language.
  KeyListener","Provides classes that monitor or modify keypad input. You can use these classes to modify the type of keypad entry
 for your application or decipher the keypresses entered for your specific
 entry method. For example: 
 // Set the text to password display style:
 EditText txtView = (EditText)findViewById(R.id.text);
 txtView.setTransformationMethod(PasswordTransformationMethod.getInstance());

 //Set the input style to numbers rather than qwerty keyboard style.
 txtView.setInputMethod(DigitsInputMethod.getInstance());

 // Find out whether the caps lock is on.
 // 0 is no 1 is yes 2 is caps lock on.
 int active = MultiTapInputMethod.getCapsActive(txtView.getText());",,,,,,,
"<android.text.Layout: float getDesiredWidth(CharSequence,TextPaint)>","Return how wide a layout must be in order to display the specified text with one line per
 paragraph. As of O Uses TextDirectionHeuristics#FIRSTSTRONG_LTR as the default text direction heuristics. In
 the earlier versions uses TextDirectionHeuristics#LTR as the default.","source CharSequence |||
paint TextPaint |||",float |||,1,"A base class that manages text layout in visual elements on
 the screen.
  For text that will be edited use a  DynamicLayout 
 which will be updated as the text changes.
 For text that will not change use a  StaticLayout .","Provides classes used to render or track text and text spans on the screen. You can use these classes to design your own widgets that manage text
 to handle arbitrary text spans for changes or to handle drawing yourself
 for an existing widget. The Span… interfaces and classes are used to create or manage spans of
 text in a View item. You can use these to style the text or background or to
 listen for changes. If creating your own widget extend DynamicLayout to manages
 the actual wrapping and drawing of your text.",,,,,,,
<android.telephony.CellLocation: CellLocation getEmpty()>,"Return a new CellLocation object representing an unknown
 location or null for unknown/none phone radio types.",,CellLocation |||,1,Abstract class that represents the location of the device.,,,,,,,,
<android.widget.SearchView: CharSequence getQueryHint()>,Returns the hint text that will be displayed in the query text field. The displayed query hint is chosen in the following order: Related XML Attributes: android:queryHint,,CharSequence the displayed query hint text or null if none set |||,16,"A widget that provides a user interface for the user to enter a search query and submit a request
 to a search provider. Shows a list of query suggestions or results if available and allows the
 user to pick a suggestion or result to launch into.

  
 When the SearchView is used in an ActionBar as an action view for a collapsible menu item it
 needs to be set to iconified by default using  setIconifiedByDefault(true) . This is the default so nothing needs to be done.
  
 If you want the search field to always be visible then call setIconifiedByDefault(false).","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.appwidget.AppWidgetHost: int getAppWidgetIds()>,Gets a list of all the appWidgetIds that are bound to the current host,,int[] |||,26,"AppWidgetHost provides the interaction with the AppWidget service for apps
 like the home screen that want to embed AppWidgets in their UI.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
"<android.app.Fragment: Fragment instantiate(Context,String,Bundle)>","Create a new instance of a Fragment with the given class name.  This is
 the same as calling its empty constructor.","context Context : The calling context being used to instantiate the fragment.
This is currently just used to get its ClassLoader. |||
fname String : The class name of the fragment to instantiate. |||
args Bundle : Bundle of arguments to supply to the fragment which it
can retrieve with getArguments() .  May be null.
This value may be null . |||",Fragment Returns a new fragment instance. |||,11,"A Fragment is a piece of an application's user interface or behavior
 that can be placed in an  Activity .  Interaction with fragments
 is done through  FragmentManager  which can be obtained via
  Activity#getFragmentManager()  and
  Fragment#getFragmentManager() .

  The Fragment class can be used many ways to achieve a wide variety of
 results. In its core it represents a particular operation or interface
 that is running within a larger  Activity .  A Fragment is closely
 tied to the Activity it is in and can not be used apart from one.  Though
 Fragment defines its own lifecycle that lifecycle is dependent on its
 activity: if the activity is stopped no fragments inside of it can be
 started; when the activity is destroyed all fragments will be destroyed.

  All subclasses of Fragment must include a public no-argument constructor.
 The framework will often re-instantiate a fragment class when needed
 in particular during state restore and needs to be able to find this
 constructor to instantiate it.  If the no-argument constructor is not
 available a runtime exception will occur in some cases during state
 restore.

  Topics covered here:
  Older Platforms Lifecycle Layout Back Stack","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.widget.ImageView: void setVisibility(int)>,Set the visibility state of this view.,"visibility int : One of View.VISIBLE  View.INVISIBLE or View.GONE .
Value is View.VISIBLE  View.INVISIBLE or View.GONE |||",void,1,"Displays image resources for example  Bitmap 
 or  Drawable  resources.
 ImageView is also commonly used to
  apply tints to an image  and
 handle  image scaling .

  
 The following XML snippet is a common example of using an ImageView to display an image resource:
  
 <LinearLayout
     xmlns:android=""http://schemas.android.com/apk/res/android""
     android:layout_width=""match_parent""
     android:layout_height=""match_parent"">
     <ImageView
         android:layout_width=""wrap_content""
         android:layout_height=""wrap_content""
         android:src=""@drawable/my_image""
         android:contentDescription=""@string/my_image_description""
         />
 </LinearLayout>
  
 To learn more about Drawables see:  Drawable Resources .
 To learn more about working with Bitmaps see:  Handling Bitmaps .","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
"<android.content.ContentProvider: Cursor query(Uri,String,String,String,String,CancellationSignal)>","Implement this to handle query requests from clients with support for cancellation. Apps targeting Build.VERSION_CODES.O or higher should override query(android.net.Uri java.lang.String[] android.os.Bundle android.os.CancellationSignal) instead of this method. This method can be called from multiple threads as described in Processes
 and Threads . Example client call: If you implement this method then you must also implement the version of query(android.net.Uri java.lang.String[] java.lang.String java.lang.String[] java.lang.String) that does not take a cancellation
 signal to ensure correct operation on older versions of the Android Framework in
 which the cancellation signal overload was not available.","uri Uri : The URI to query. This will be the full URI sent by the client;
if the client is requesting a specific record the URI will end in a record number
that the implementation should parse and add to a WHERE or HAVING clause specifying
that _id value.
This value cannot be null . |||
projection String : The list of columns to put into the cursor. If null all columns are included.
This value may be null . |||
selection String : A selection criteria to apply when filtering rows.
If null then all rows are included.
This value may be null . |||
selectionArgs String : You may include ?s in selection which will be replaced by
the values from selectionArgs in order that they appear in the selection.
The values will be bound as Strings.
This value may be null . |||
sortOrder String : How the rows in the cursor should be sorted.
If null then the provider is free to define the sort order.
This value may be null . |||
cancellationSignal CancellationSignal : A signal to cancel the operation in progress or null if none.
If the operation is canceled then OperationCanceledException will be thrown
when the query is executed.
This value may be null . |||",Cursor a Cursor or null . |||,16,"Content providers are one of the primary building blocks of Android applications providing
 content to applications. They encapsulate data and provide it to applications through the single
  ContentResolver  interface. A content provider is only required if you need to share
 data between multiple applications. For example the contacts data is used by multiple
 applications and must be stored in a content provider. If you don't need to share data amongst
 multiple applications you can use a database directly via
  SQLiteDatabase .

  When a request is made via
 a  ContentResolver  the system inspects the authority of the given URI and passes the
 request to the content provider registered with the authority. The content provider can interpret
 the rest of the URI however it wants. The  UriMatcher  class is helpful for parsing
 URIs. The primary methods that need to be implemented are:
  onCreate()  which is called to initialize the provider query(Uri String[] Bundle CancellationSignal)  which returns data to the caller insert(Uri ContentValues)  which inserts new data into the content provider update(Uri ContentValues String String[])  which updates existing data in the content provider delete(Uri String String[])  which deletes data from the content provider getType(Uri)  which returns the MIME type of data in the content provider Requests to  ContentResolver  are automatically forwarded to the appropriate
 ContentProvider instance so subclasses don't have to worry about the details of
 cross-process calls.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.app.admin.DevicePolicyManager: int getPasswordHistoryLength(ComponentName)>,"Retrieve the current password history length for a particular admin or all admins that
 set restrictions on this user and its participating profiles. Restrictions on profiles that
 have a separate challenge are not taken into account. This method can be called on the DevicePolicyManager instance
 returned by getParentProfileInstance(android.content.ComponentName) in order to retrieve
 restrictions on the parent profile. On devices not supporting PackageManager#FEATURE_SECURE_LOCK_SCREEN feature the
 password history length is always 0. Requires the PackageManager#FEATURE_SECURE_LOCK_SCREEN feature which can be detected using PackageManager.hasSystemFeature(String) .","admin ComponentName : The name of the admin component to check or null to aggregate
all admins.
This value may be null . |||",int The length of the password history |||,11,"Public interface for managing policies enforced on a device. Most clients of this class must be
 registered with the system as a  device
 administrator . Additionally a device administrator may be registered as either a profile or
 device owner. A given method is accessible to all device administrators unless the documentation
 for that method specifies that it is restricted to either device or profile owners. Any
 application calling an api may only pass as an argument a device administrator component it
 owns. Otherwise a  SecurityException  will be thrown.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
"<android.app.ListFragment: View onCreateView(LayoutInflater,ViewGroup,Bundle)>","Provide default implementation to return a simple list view.  Subclasses
 can override to replace with their own layout.  If doing so the
 returned view hierarchy must have a ListView whose id
 is android.R.id.list and can optionally
 have a sibling view id android.R.id.empty that is to be shown when the list is empty. If you are overriding this method with your own custom content
 consider including the standard layout R.layout.list_content in your layout file so that you continue to retain all of the standard
 behavior of ListFragment.  In particular this is currently the only
 way to have the built-in indeterminant progress state be shown.","inflater LayoutInflater : The LayoutInflater object that can be used to inflate
any views in the fragment |||
container ViewGroup : If non-null this is the parent view that the fragment's
UI should be attached to.  The fragment should not add the view itself
but this can be used to generate the LayoutParams of the view.
This value may be null . |||
savedInstanceState Bundle : If non-null this fragment is being re-constructed
from a previous saved state as given here. |||",View Return the View for the fragment's UI or null. |||,11,"A fragment that displays a list of items by binding to a data source such as
 an array or Cursor and exposes event handlers when the user selects an item.
  
 ListFragment hosts a  ListView  object that can
 be bound to different data sources typically either an array or a Cursor
 holding query results. Binding screen layout and row layout are discussed
 in the following sections.
  Screen Layout 
 ListFragment has a default layout that consists of a single list view.
 However if you desire you can customize the fragment layout by returning
 your own view hierarchy from  onCreateView(LayoutInflater ViewGroup Bundle) .
 To do this your view hierarchy  must  contain a ListView object with the
 id ""@android:id/list"" (or  R.id.list  if it's in code)
  
 Optionally your view hierarchy can contain another view object of any type to
 display when the list view is empty. This ""empty list"" notifier must have an
 id ""android:empty"". Note that when an empty view is present the list view
 will be hidden when there is no data to display.
  
 The following code demonstrates an (ugly) custom list layout. It has a list
 with a green background and an alternate red ""no data"" message.
  
 <?xml version=""1.0"" encoding=""utf-8""?>
 <LinearLayout xmlns:android=""http://schemas.android.com/apk/res/android""
         android:orientation=""vertical""
         android:layout_width=""match_parent""
         android:layout_height=""match_parent""
         android:paddingLeft=""8dp""
         android:paddingRight=""8dp"">

     <ListView android:id=""@id/android:list""
               android:layout_width=""match_parent""
               android:layout_height=""match_parent""
               android:background=""#00FF00""
               android:layout_weight=""1""
               android:drawSelectorOnTop=""false""/>

     <TextView android:id=""@id/android:empty""
               android:layout_width=""match_parent""
               android:layout_height=""match_parent""
               android:background=""#FF0000""
               android:text=""No data""/>
 </LinearLayout>
  Row Layout 
 You can specify the layout of individual rows in the list. You do this by
 specifying a layout resource in the ListAdapter object hosted by the fragment
 (the ListAdapter binds the ListView to the data; more on this later).
  
 A ListAdapter constructor takes a parameter that specifies a layout resource
 for each row. It also has two additional parameters that let you specify
 which data field to associate with which object in the row layout resource.
 These two parameters are typically parallel arrays.
  
 Android provides some standard row layout resources. These are in the
  R.layout  class and have names such as simple_list_item_1
 simple_list_item_2 and two_line_list_item. The following layout XML is the
 source for the resource two_line_list_item which displays two data
 fieldsone above the other for each list row.
  
 <?xml version=""1.0"" encoding=""utf-8""?>
 <LinearLayout xmlns:android=""http://schemas.android.com/apk/res/android""
     android:layout_width=""match_parent""
     android:layout_height=""wrap_content""
     android:orientation=""vertical"">

     <TextView android:id=""@+id/text1""
         android:textSize=""16sp""
         android:textStyle=""bold""
         android:layout_width=""match_parent""
         android:layout_height=""wrap_content""/>

     <TextView android:id=""@+id/text2""
         android:textSize=""16sp""
         android:layout_width=""match_parent""
         android:layout_height=""wrap_content""/>
 </LinearLayout>
  
 You must identify the data bound to each TextView object in this layout. The
 syntax for this is discussed in the next section.
  Binding to Data 
 You bind the ListFragment's ListView object to data using a class that
 implements the  ListAdapter  interface.
 Android provides two standard list adapters:
  SimpleAdapter  for static data (Maps)
 and  SimpleCursorAdapter  for Cursor
 query results.
  
 You  must  use
  ListFragment.setListAdapter()  to
 associate the list with an adapter.  Do not directly call
  ListView#setAdapter(ListAdapter)  or else
 important initialization will be skipped.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
"<android.widget.PopupWindow: int getMaxAvailableHeight(View,int)>","Returns the maximum height that is available for the popup to be
 completely shown. It is recommended that this height be the maximum for
 the popup's height otherwise it is possible that the popup will be
 clipped.","anchor View : The view on which the popup window must be anchored.
This value cannot be null . |||
yOffset int : y offset from the view's bottom edge |||","int The maximum available height for the popup to be completely
         shown. |||",3,"This class represents a popup window that can be used to display an
 arbitrary view. The popup window is a floating container that appears on top
 of the current activity.
  Animation 
 On all versions of Android popup window enter and exit animations may be
 specified by calling  setAnimationStyle(int)  and passing the
 resource ID for an animation style that defines  windowEnterAnimation 
 and  windowExitAnimation . For example passing
  R.style.Animation_Dialog  will give a scale and alpha
 animation.
 
 A window animation style may also be specified in the popup window's style
 XML via the  popupAnimationStyle 
 attribute.
  
 Starting with API 23 more complex popup window enter and exit transitions
 may be specified by calling either  setEnterTransition(android.transition.Transition) 
 or  setExitTransition(android.transition.Transition)  and passing a   Transition .
 
 Popup enter and exit transitions may also be specified in the popup window's
 style XML via the  popupEnterTransition 
 and  popupExitTransition 
 attributes respectively.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.app.Instrumentation: void startPerformanceSnapshot()>,,,void,1,"Base class for implementing application instrumentation code.  When running
 with instrumentation turned on this class will be instantiated for you
 before any of the application code allowing you to monitor all of the
 interaction the system has with the application.  An Instrumentation
 implementation is described to the system through an AndroidManifest.xml's
 <instrumentation> tag.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.widget.AbsListView: void setSelector(int)>,Set a Drawable that should be used to highlight the currently selected item. Related XML Attributes: android:listSelector,resID int : A Drawable resource to use as the selection highlight. |||,void,1,"Base class that can be used to implement virtualized lists of items. A list does
 not have a spatial definition here. For instance subclasses of this class can
 display the content of the list in a grid in a carousel as stack etc.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.util.LruCache: void trimToSize(int)>,"Remove the eldest entries until the total of remaining entries is at or
 below the requested size.","maxSize int : the maximum size of the cache before returning. May be -1
to evict even 0-sized elements. |||",void,17,"A cache that holds strong references to a limited number of values. Each time
 a value is accessed it is moved to the head of a queue. When a value is
 added to a full cache the value at the end of that queue is evicted and may
 become eligible for garbage collection.

  If your cached values hold resources that need to be explicitly released
 override  entryRemoved(boolean K V V) .

  If a cache miss should be computed on demand for the corresponding keys
 override  create(K) . This simplifies the calling code allowing it to
 assume a value will always be returned even when there's a cache miss.

  By default the cache size is measured in the number of entries. Override
  sizeOf(K V)  to size the cache in different units. For example this cache
 is limited to 4MiB of bitmaps:
  int cacheSize = 4 * 1024 * 1024; // 4MiB
   LruCache<String Bitmap> bitmapCache = new LruCache<String Bitmap>(cacheSize) {
       protected int sizeOf(String key Bitmap value) {
           return value.getByteCount();
       }
   } This class is thread-safe. Perform multiple cache operations atomically by
 synchronizing on the cache:  synchronized (cache) {
     if (cache.get(key) == null) {
         cache.put(key value);
     }
   } This class does not allow null to be used as a key or value. A return
 value of null from  get(K)   put(K V)  or  remove(K)  is
 unambiguous: the key was not in the cache.

  This class appeared in Android 3.1 (Honeycomb MR1); it's available as part
 of  Android's
 Support Package  for earlier releases.",,,,,,,,
<android.text.Layout: float getLineLeft(int)>,"Get the leftmost position that should be exposed for horizontal
 scrolling on the specified line.",line int |||,float |||,1,"A base class that manages text layout in visual elements on
 the screen.
  For text that will be edited use a  DynamicLayout 
 which will be updated as the text changes.
 For text that will not change use a  StaticLayout .","Provides classes used to render or track text and text spans on the screen. You can use these classes to design your own widgets that manage text
 to handle arbitrary text spans for changes or to handle drawing yourself
 for an existing widget. The Span… interfaces and classes are used to create or manage spans of
 text in a View item. You can use these to style the text or background or to
 listen for changes. If creating your own widget extend DynamicLayout to manages
 the actual wrapping and drawing of your text.",,,,,,,
"<android.os.Bundle: void putCharSequenceArrayList(String,ArrayList)>","Inserts an ArrayList value into the mapping of this Bundle replacing
 any existing value for the given key.  Either key or value may be null.","key String : a String or null
This value may be null . |||
value ArrayList : an ArrayList object or null
This value may be null . |||",void,8,A mapping from String keys to various  Parcelable  values.,,,,,,,,
"<android.app.Instrumentation: void finish(int,Bundle)>","Terminate instrumentation of the application.  This will cause the
 application process to exit removing this instrumentation from the next
 time the application is started.  If multiple processes are currently running
 for this instrumentation all of those processes will be killed.","resultCode int : Overall success/failure of instrumentation. |||
results Bundle : Any results to send back to the code that started the
instrumentation. |||",void,1,"Base class for implementing application instrumentation code.  When running
 with instrumentation turned on this class will be instantiated for you
 before any of the application code allowing you to monitor all of the
 interaction the system has with the application.  An Instrumentation
 implementation is described to the system through an AndroidManifest.xml's
 <instrumentation> tag.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.telephony.gsm.SmsMessage: int getTPLayerLengthForPDU(String)>,"This method was deprecated
      in API level 4. Use android.telephony.SmsMessage. Get the TP-Layer-Length for the given SMS-SUBMIT PDU Basically the
 length in bytes (not hex chars) less the SMSC header",pdu String |||,int |||,1,A Short Message Service message.,,,,,,,,
"<android.location.Location: void writeToParcel(Parcel,int)>",Flatten this object in to a Parcel.,"parcel Parcel : The Parcel in which the object should be written. |||
flags int : Additional flags about how the object should be written.
May be 0 or Parcelable.PARCELABLE_WRITE_RETURN_VALUE .
Value is either 0 or a combination of Parcelable.PARCELABLE_WRITE_RETURN_VALUE and android.os.Parcelable.PARCELABLE_ELIDE_DUPLICATES |||",void,1,"A data class representing a geographic location.

  A location can consist of a latitude longitude timestamp
 and other information such as bearing altitude and velocity.

  All locations generated by the  LocationManager  are
 guaranteed to have a valid latitude longitude and timestamp
 (both UTC time and elapsed real-time since boot) all other
 parameters are optional.","Contains the framework API classes that define Android location-based and
 	related services. This API is not the recommended method for accessing Android location. 
 The
  Google Location Services API 
 part of Google Play services is the preferred way to add location-awareness to
 your app. It offers a simpler API higher accuracy low-power geofencing and
 more. If you are currently using the android.location API you are strongly
 encouraged to switch to the Google Location Services API as soon as
 possible.
  
 To learn more about the Google Location Services API see the
  Location API overview .",,,,,,,
"<android.net.LinkProperties: void writeToParcel(Parcel,int)>",Implement the Parcelable interface.,"dest Parcel : The Parcel in which the object should be written. |||
flags int : Additional flags about how the object should be written.
May be 0 or Parcelable.PARCELABLE_WRITE_RETURN_VALUE .
Value is either 0 or a combination of Parcelable.PARCELABLE_WRITE_RETURN_VALUE and android.os.Parcelable.PARCELABLE_ELIDE_DUPLICATES |||",void,21,"Describes the properties of a network link.

 A link represents a connection to a network.
 It may have multiple addresses and multiple gateways
 multiple dns servers but only one http proxy and one
 network interface.

 Note that this is just a holder of data.  Modifying it
 does not affect live networks.",,,,,,,,
<android.app.DialogFragment: void onDismiss(DialogInterface)>,This method will be invoked when the dialog is dismissed.,"dialog DialogInterface : the dialog that was dismissed will be passed into the
method |||",void,11,"Base class for Dialogs.

  Note: Activities provide a facility to manage the creation saving and
 restoring of dialogs. See  Activity#onCreateDialog(int) 
  Activity#onPrepareDialog(int Dialog) 
  Activity#showDialog(int)  and  Activity#dismissDialog(int) . If
 these methods are used  getOwnerActivity()  will return the Activity
 that managed this dialog.

  Often you will want to have a Dialog display on top of the current
 input method because there is no reason for it to accept text.  You can
 do this by setting the  WindowManager.LayoutParams#FLAG_ALT_FOCUSABLE_IM  window flag (assuming
 your Dialog takes input focus as it the default) with the following code:

  
 getWindow().setFlags(WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM
         WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.app.ActivityManager: List getRunningServices(int)>,"This method was deprecated
      in API level 26. As of Build.VERSION_CODES.O this method
 is no longer available to third party applications.  For backwards compatibility
 it will still return the caller's own services. Return a list of the services that are currently running. Note: this method is only intended for debugging or implementing
 service management type user interfaces.","maxNum int : The maximum number of entries to return in the list.  The
actual number returned may be smaller depending on how many services
are running. |||","List < ActivityManager.RunningServiceInfo > Returns a list of RunningServiceInfo records describing each of
 the running tasks. |||",1,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.database.AbstractCursor: void close()>,"Closes the Cursor releasing all of its resources and making it completely invalid.
 Unlike deactivate() a call to requery() will not make the Cursor valid
 again.",,void,1,"This is an abstract cursor class that handles a lot of the common code
 that all cursors need to deal with and is provided for convenience reasons.","If you need to manage data in a private database use the  android.database.sqlite  classes. These classes are used to manage the  Cursor  object returned from a content provider query. Databases
 are usually created and opened with  openOrCreateDatabase(String int SQLiteDatabase.CursorFactory) 
 To make requests through
 content providers you can use the  content.ContentResolver  class.
  All databases are stored on the device in  /data/data/<package_name>/databases",,,,,,,
<android.app.Service: void stopSelf(int)>,Old version of stopSelfResult(int) that doesn't return a result.,startId int |||,void,1,"A Service is an application component representing either an application's desire
 to perform a longer-running operation while not interacting with the user
 or to supply functionality for other applications to use.  Each service
 class must have a corresponding
  <service> 
 declaration in its package's  AndroidManifest.xml .  Services
 can be started with
  Context.startService()  and
  Context.bindService() .

  Note that services like other application objects run in the main
 thread of their hosting process.  This means that if your service is going
 to do any CPU intensive (such as MP3 playback) or blocking (such as
 networking) operations it should spawn its own thread in which to do that
 work.  More information on this can be found in
  Processes and
 Threads .  The  IntentService  class is available
 as a standard implementation of Service that has its own thread where it
 schedules its work to be done. Topics covered here:
  What is a Service? Service Lifecycle Permissions Process Lifecycle Local Service Sample Remote Messenger Service Sample","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.widget.ViewAnimator: void removeViewAt(int)>,Removes the view at the specified position in the group. Note: do not invoke this method from View.draw(android.graphics.Canvas)  View.onDraw(android.graphics.Canvas)  dispatchDraw(android.graphics.Canvas) or any related method.,index int : the position in the group of the view to remove |||,void,1,"Base class for a  FrameLayout  container that will perform animations
 when switching between its views.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
"<android.content.ClipData: void writeToParcel(Parcel,int)>",Flatten this object in to a Parcel.,"dest Parcel : The Parcel in which the object should be written. |||
flags int : Additional flags about how the object should be written.
May be 0 or Parcelable.PARCELABLE_WRITE_RETURN_VALUE .
Value is either 0 or a combination of Parcelable.PARCELABLE_WRITE_RETURN_VALUE and android.os.Parcelable.PARCELABLE_ELIDE_DUPLICATES |||",void,11,"Representation of a clipped data on the clipboard.

  ClipData is a complex type containing one or more Item instances
 each of which can hold one or more representations of an item of data.
 For display to the user it also has a label. A ClipData contains a  ClipDescription  which describes
 important meta-data about the clip.  In particular its
  ClipDescription#getMimeType(int) 
 must return correct MIME type(s) describing the data in the clip.  For help
 in correctly constructing a clip with the correct MIME type use
  newPlainText(java.lang.CharSequence java.lang.CharSequence) 
  newUri(android.content.ContentResolver java.lang.CharSequence android.net.Uri)  and
  newIntent(java.lang.CharSequence android.content.Intent) .

  Each Item instance can be one of three main classes of data: a simple
 CharSequence of text a single Intent object or a Uri.  See  Item 
 for more details.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.widget.PopupWindow: int getMaxAvailableHeight(View)>,"Returns the maximum height that is available for the popup to be
 completely shown. It is recommended that this height be the maximum for
 the popup's height otherwise it is possible that the popup will be
 clipped.","anchor View : The view on which the popup window must be anchored.
This value cannot be null . |||","int The maximum available height for the popup to be completely
         shown. |||",1,"This class represents a popup window that can be used to display an
 arbitrary view. The popup window is a floating container that appears on top
 of the current activity.
  Animation 
 On all versions of Android popup window enter and exit animations may be
 specified by calling  setAnimationStyle(int)  and passing the
 resource ID for an animation style that defines  windowEnterAnimation 
 and  windowExitAnimation . For example passing
  R.style.Animation_Dialog  will give a scale and alpha
 animation.
 
 A window animation style may also be specified in the popup window's style
 XML via the  popupAnimationStyle 
 attribute.
  
 Starting with API 23 more complex popup window enter and exit transitions
 may be specified by calling either  setEnterTransition(android.transition.Transition) 
 or  setExitTransition(android.transition.Transition)  and passing a   Transition .
 
 Popup enter and exit transitions may also be specified in the popup window's
 style XML via the  popupEnterTransition 
 and  popupExitTransition 
 attributes respectively.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.nfc.tech.IsoDep: void connect()>,"Enable I/O operations to the tag from this TagTechnology object. May cause RF activity and may block. Must not be called
 from the main application thread. A blocked call will be canceled with IOException by calling close() from another thread. Only one TagTechnology object can be connected to a Tag at a time. Applications must call close() when I/O operations are complete. Requires the Manifest.permission.NFC permission.",,void,-1,"Provides access to ISO-DEP (ISO 14443-4) properties and I/O operations on a  Tag .

  Acquire an  IsoDep  object using  get(Tag) .
  The primary ISO-DEP I/O operation is  transceive(byte[]) . Applications must
 implement their own protocol stack on top of  transceive(byte[]) .
  Tags that enumerate the  IsoDep  technology in  Tag#getTechList 
 will also enumerate
  NfcA  or  NfcB  (since IsoDep builds on top of either of these).

  Note:  Methods that perform I/O operations
 require the  Manifest.permission.NFC  permission.","These classes provide access to a tag technology's features which vary by the type
 of tag that is scanned. A scanned tag can support multiple technologies and you can find
 out what they are by calling  getTechList() . For more information on dealing with tag technologies and handling the ones that you care about see
  The Tag Dispatch System .
 The  TagTechnology  interface provides an overview of the
 supported technologies.",,,,,,,
"<android.test.TouchUtils: void longClickView(ActivityInstrumentationTestCase,View)>","This method was deprecated
      in API level 15. ActivityInstrumentationTestCase is deprecated in favor of ActivityInstrumentationTestCase2 which provides more options for
 configuring the Activity under test Simulate touching the center of a view holding until it is a long press and then releasing.","test ActivityInstrumentationTestCase : The test case that is being run |||
v View : The view that should be clicked |||",void,1,"Reusable methods for generating touch events. These methods can be used with
 InstrumentationTestCase or ActivityInstrumentationTestCase2 to simulate user interaction with
 the application through a touch screen.",,,,,,,,
<android.app.admin.DevicePolicyManager: int getPasswordMinimumLength(ComponentName)>,"Retrieve the current minimum password length for a particular admin or all admins that set
 restrictions on this user and its participating profiles. Restrictions on profiles that have
 a separate challenge are not taken into account. On devices not supporting PackageManager#FEATURE_SECURE_LOCK_SCREEN feature the
 password is always treated as empty. This method can be called on the DevicePolicyManager instance
 returned by getParentProfileInstance(android.content.ComponentName) in order to retrieve
 restrictions on the parent profile.","admin ComponentName : The name of the admin component to check or null to aggregate
all admins.
This value may be null . |||",int |||,8,"Public interface for managing policies enforced on a device. Most clients of this class must be
 registered with the system as a  device
 administrator . Additionally a device administrator may be registered as either a profile or
 device owner. A given method is accessible to all device administrators unless the documentation
 for that method specifies that it is restricted to either device or profile owners. Any
 application calling an api may only pass as an argument a device administrator component it
 owns. Otherwise a  SecurityException  will be thrown.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
"<android.view.inputmethod.EditorInfo: void writeToParcel(Parcel,int)>",Used to package this object into a Parcel .,"dest Parcel : The Parcel to be written. |||
flags int : The flags used for parceling. |||",void,3,"An EditorInfo describes several attributes of a text editing object
 that an input method is communicating with (typically an EditText) most
 importantly the type of text content it contains and the current cursor position.",,,,,,,,
<android.database.sqlite.SQLiteStatement: String simpleQueryForString()>,"Execute a statement that returns a 1 by 1 table with a text value.
 For example SELECT COUNT(*) FROM table;",,String The result of the query. |||,1,"Represents a statement that can be executed against a database.  The statement
 cannot return multiple rows or columns but single value (1 x 1) result sets
 are supported.
  
 This class is not thread-safe.","If you need to manage data in a private database use the  android.database.sqlite  classes. These classes are used to manage the  Cursor  object returned from a content provider query. Databases
 are usually created and opened with  openOrCreateDatabase(String int SQLiteDatabase.CursorFactory) 
 To make requests through
 content providers you can use the  content.ContentResolver  class.
  All databases are stored on the device in  /data/data/<package_name>/databases",,,,,,,
<android.content.IntentSender: UserHandle getCreatorUserHandle()>,"Return the user handle of the application that created this
 PendingIntent that is the user under which you will actually be
 sending the Intent.  The returned UserHandle is supplied by the system so
 that an application can not spoof its user.  See Process.myUserHandle() for
 more explanation of user handles.",,"UserHandle The user handle of the PendingIntent or null if there is
 none associated with it. |||",17,"A description of an Intent and target action to perform with it.
 The returned object can be
 handed to other applications so that they can perform the action you
 described on your behalf at a later time.

  By giving a IntentSender to another application
 you are granting it the right to perform the operation you have specified
 as if the other application was yourself (with the same permissions and
 identity).  As such you should be careful about how you build the IntentSender:
 often for example the base Intent you supply will have the component
 name explicitly set to one of your own components to ensure it is ultimately
 sent there and nowhere else.

  A IntentSender itself is simply a reference to a token maintained by
 the system describing the original data used to retrieve it.  This means
 that even if its owning application's process is killed the
 IntentSender itself will remain usable from other processes that
 have been given it.  If the creating application later re-retrieves the
 same kind of IntentSender (same operation same Intent action data
 categories and components and same flags) it will receive a IntentSender
 representing the same token if that is still valid.

  Instances of this class can not be made directly but rather must be
 created from an existing  PendingIntent  with
  PendingIntent.getIntentSender() .","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
"<android.test.TouchUtils: int dragViewToX(ActivityInstrumentationTestCase,View,int,int)>","This method was deprecated
      in API level 15. ActivityInstrumentationTestCase is deprecated in favor of ActivityInstrumentationTestCase2 which provides more options for
 configuring the Activity under test Simulate touching a view and dragging it to a specified location. Only moves horizontally.","test ActivityInstrumentationTestCase : The test case that is being run |||
v View : The view that should be dragged |||
gravity int : Which part of the view to use for the initial down event. A combination of
(TOP CENTER_VERTICAL BOTTOM) and (LEFT CENTER_HORIZONTAL RIGHT) |||
toX int : Final location of the view after dragging |||",int distance in pixels covered by the drag |||,1,"Reusable methods for generating touch events. These methods can be used with
 InstrumentationTestCase or ActivityInstrumentationTestCase2 to simulate user interaction with
 the application through a touch screen.",,,,,,,,
"<android.app.DatePickerDialog: void onDateChanged(DatePicker,int,int,int)>",Called upon a date change.,"view DatePicker : This value cannot be null . |||
year int : The year that was set. |||
month int : The month that was set (0-11) for compatibility
with Calendar . |||
dayOfMonth int : The day of the month that was set. |||",void,1,"A simple dialog containing an  DatePicker .
  
 See the  Pickers 
 guide.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
"<android.app.Fragment: String getString(int,Object)>","Return a localized formatted string from the application's package's
 default string table substituting the format arguments as defined in Formatter and String.format(String Object...) .","resId int : Resource id for the format string |||
formatArgs Object : The format arguments that will be used for substitution. |||",String |||,11,"A Fragment is a piece of an application's user interface or behavior
 that can be placed in an  Activity .  Interaction with fragments
 is done through  FragmentManager  which can be obtained via
  Activity#getFragmentManager()  and
  Fragment#getFragmentManager() .

  The Fragment class can be used many ways to achieve a wide variety of
 results. In its core it represents a particular operation or interface
 that is running within a larger  Activity .  A Fragment is closely
 tied to the Activity it is in and can not be used apart from one.  Though
 Fragment defines its own lifecycle that lifecycle is dependent on its
 activity: if the activity is stopped no fragments inside of it can be
 started; when the activity is destroyed all fragments will be destroyed.

  All subclasses of Fragment must include a public no-argument constructor.
 The framework will often re-instantiate a fragment class when needed
 in particular during state restore and needs to be able to find this
 constructor to instantiate it.  If the no-argument constructor is not
 available a runtime exception will occur in some cases during state
 restore.

  Topics covered here:
  Older Platforms Lifecycle Layout Back Stack","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
"<android.view.inputmethod.InputMethodManager: void updateExtractedText(View,int,ExtractedText)>",,"view View |||
token int |||
text ExtractedText |||",void,3,"Central system API to the overall input method framework (IMF) architecture
 which arbitrates interaction between applications and the current input method.

  Topics covered here:
  Architecture Overview Applications Input Methods Security Architecture Overview There are three primary parties involved in the input method
 framework (IMF) architecture:  The  input method manager  as expressed by this class
 is the central point of the system that manages interaction between all
 other parts.  It is expressed as the client-side API here which exists
 in each application context and communicates with a global system service
 that manages the interaction across all processes.
   An  input method (IME)  implements a particular
 interaction model allowing the user to generate text.  The system binds
 to the current input method that is in use causing it to be created and run
 and tells it when to hide and show its UI.  Only one IME is running at a time.
   Multiple  client applications  arbitrate with the input
 method manager for input focus and control over the state of the IME.  Only
 one such client is ever active (working with the IME) at a time.
  Applications In most cases applications that are using the standard
  TextView  or its subclasses will have little they need
 to do to work well with soft input methods.  The main things you need to
 be aware of are:  Properly set the  R.attr.inputType  in your editable
 text views so that the input method will have enough context to help the
 user in entering text into them.
   Deal well with losing screen space when the input method is
 displayed.  Ideally an application should handle its window being resized
 smaller but it can rely on the system performing panning of the window
 if needed.  You should set the  R.attr.windowSoftInputMode 
 attribute on your activity or the corresponding values on windows you
 create to help the system determine whether to pan or resize (it will
 try to determine this automatically but may get it wrong).
   You can also control the preferred soft input state (open closed etc)
 for your window using the same  R.attr.windowSoftInputMode 
 attribute.
  More finer-grained control is available through the APIs here to directly
 interact with the IMF and its IME -- either showing or hiding the input
 area letting the user pick an input method etc. For the rare people amongst us writing their own text editors you
 will need to implement  View.onCreateInputConnection(EditorInfo) 
 to return a new instance of your own  InputConnection  interface
 allowing the IME to interact with your editor. Input Methods An input method (IME) is implemented
 as a  Service  typically deriving from
  InputMethodService .  It must provide
 the core  InputMethod  interface though this is normally handled by
  InputMethodService  and implementors will
 only need to deal with the higher-level API there. InputMethodService Security There are a lot of security issues associated with input methods
 since they essentially have freedom to completely drive the UI and monitor
 everything the user enters.  The Android input method framework also allows
 arbitrary third party IMEs so care must be taken to restrict their
 selection and interactions. Here are some key points about the security architecture behind the
 IMF: Only the system is allowed to directly access an IME's
  InputMethod  interface via the
  Manifest.permission.BIND_INPUT_METHOD  permission.  This is
 enforced in the system by not binding to an input method service that does
 not require this permission so the system can guarantee no other untrusted
 clients are accessing the current input method outside of its control. There may be many client processes of the IMF but only one may
 be active at a time.  The inactive clients can not interact with key
 parts of the IMF through the mechanisms described below. Clients of an input method are only given access to its
  InputMethodSession  interface.  One instance of this interface is
 created for each client and only calls from the session associated with
 the active client will be processed by the current IME.  This is enforced
 by  AbstractInputMethodService  for normal
 IMEs but must be explicitly handled by an IME that is customizing the
 raw  InputMethodSession  implementation. Only the active client's  InputConnection  will accept
 operations.  The IMF tells each client process whether it is active and
 the framework enforces that in inactive processes calls on to the current
 InputConnection will be ignored.  This ensures that the current IME can
 only deliver events and text edits to the UI that the user sees as
 being in focus. An IME can never interact with an  InputConnection  while
 the screen is off.  This is enforced by making all clients inactive while
 the screen is off and prevents bad IMEs from driving the UI when the user
 can not be aware of its behavior. A client application can ask that the system let the user pick a
 new IME but can not programmatically switch to one itself.  This avoids
 malicious applications from switching the user to their own IME which
 remains running when the user navigates away to another application.  An
 IME on the other hand  is  allowed to programmatically switch
 the system to another IME since it already has full control of user
 input. The user must explicitly enable a new IME in settings before
 they can switch to it to confirm with the system that they know about it
 and want to make it available for use. PackageManager#FEATURE_INPUT_METHODS PackageManager.hasSystemFeature(String)",,,,,,,,
<android.widget.AutoCompleteTextView: void setDropDownBackgroundResource(int)>,Sets the background of the auto-complete drop-down list. Related XML Attributes: android:popupBackground,id int : the id of the drawable to set as the background |||,void,5,"An editable text view that shows completion suggestions automatically
 while the user is typing. The list of suggestions is displayed in a drop
 down menu from which the user can choose an item to replace the content
 of the edit box with. The drop down can be dismissed at any time by pressing the back key or
 if no item is selected in the drop down by pressing the enter/dpad center
 key. The list of suggestions is obtained from a data adapter and appears
 only after a given number of characters defined by
  the threshold . The following code snippet shows how to create a text view which suggests
 various countries names while the user is typing: 
 public class CountriesActivity extends Activity {
     protected void onCreate(Bundle icicle) {
         super.onCreate(icicle);
         setContentView(R.layout.countries);

         ArrayAdapter<String> adapter = new ArrayAdapter<String>(this
                 android.R.layout.simple_dropdown_item_1line COUNTRIES);
         AutoCompleteTextView textView = (AutoCompleteTextView)
                 findViewById(R.id.countries_list);
         textView.setAdapter(adapter);
     }

     private static final String[] COUNTRIES = new String[] {
         ""Belgium"" ""France"" ""Italy"" ""Germany"" ""Spain""
     };
 }
  See the  Text Fields 
 guide.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.app.Activity: void setTitle(int)>,"Change the title associated with this activity.  If this is a
 top-level activity the title for its window will change.  If it
 is an embedded activity the parent can do whatever it wants
 with it.",titleId int |||,void,1,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.telephony.SmsMessage: int getTPLayerLengthForPDU(String)>,"Get the TP-Layer-Length for the given SMS-SUBMIT PDU Basically the
 length in bytes (not hex chars) less the SMSC header

 FIXME: This method is only used by a CTS test case that isn't run on CDMA devices.
 We should probably deprecate it and remove the obsolete test case.",pdu String |||,int |||,4,A Short Message Service message.,,,,,,,,
<android.widget.TextView: void setMovementMethod(MovementMethod)>,"Sets the MovementMethod for handling arrow key movement
 for this TextView. This can be null to disallow using the arrow keys to move the
 cursor or scroll the view. Be warned that if you want a TextView with a key listener or movement
 method not to be focusable or if you want a TextView without a
 key listener or movement method to be focusable you must call View.setFocusable(boolean) again after calling this to get the focusability
 back the way you want it.",movement MovementMethod |||,void,1,"A user interface element that displays text to the user.
 To provide user-editable text see  EditText .
  
 The following code sample shows a typical use with an XML layout
 and code to modify the contents of the text view:
  
 <LinearLayout
      xmlns:android=""http://schemas.android.com/apk/res/android""
      android:layout_width=""match_parent""
      android:layout_height=""match_parent"">
    <TextView
        android:id=""@+id/text_view_id""
        android:layout_height=""wrap_content""
        android:layout_width=""wrap_content""
        android:text=""@string/hello"" />
 </LinearLayout>
  
 This code sample demonstrates how to modify the contents of the text view
 defined in the previous XML layout:
  
 public class MainActivity extends Activity {

    protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_main);
         final TextView helloTextView = (TextView) findViewById(R.id.text_view_id);
         helloTextView.setText(R.string.user_greeting);
     }
 }
  
 To customize the appearance of TextView see  Styles and Themes .
  XML attributes 
 See  TextView Attributes 
  View Attributes","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
"<android.view.ViewGroup: void layout(int,int,int,int)>","Assign a size and position to a view and all of its
 descendants This is the second phase of the layout mechanism.
 (The first is measuring). In this phase each parent calls
 layout on all of its children to position them.
 This is typically done using the child measurements
 that were stored in the measure pass(). Derived classes should not override this method.
 Derived classes with children should override
 onLayout. In that method they should
 call layout on each of their children.","l int : Left position relative to parent |||
t int : Top position relative to parent |||
r int : Right position relative to parent |||
b int : Bottom position relative to parent |||",void,1,"A  ViewGroup  is a special view that can contain other views
 (called children.) The view group is the base class for layouts and views
 containers. This class also defines the
  ViewGroup.LayoutParams  class which serves as the base
 class for layouts parameters.
  
 Also see  LayoutParams  for layout attributes.",,,,,,,,
"<android.content.Intent: int fillIn(Intent,int)>","Copy the contents of other in to this object but only
 where fields are not defined by this object.  For purposes of a field
 being defined the following pieces of data in the Intent are
 considered to be separate fields: action as set by setAction(String) . 
data Uri and MIME type as set by setData(android.net.Uri)  setType(java.lang.String) or setDataAndType(android.net.Uri java.lang.String) . 
identifier as set by setIdentifier(String) . 
categories as set by addCategory(String) . 
package as set by setPackage(String) . 
component as set by setComponent(android.content.ComponentName) or
 related methods. 
source bounds as set by setSourceBounds(Rect) . 
selector as set by setSelector(android.content.Intent) . 
clip data as set by setClipData(android.content.ClipData) . 
each top-level name in the associated extras. 
In addition you can use the FILL_IN_ACTION  FILL_IN_DATA  FILL_IN_IDENTIFIER  FILL_IN_CATEGORIES  FILL_IN_PACKAGE  FILL_IN_COMPONENT  FILL_IN_SOURCE_BOUNDS  FILL_IN_SELECTOR and FILL_IN_CLIP_DATA to override
 the restriction where the corresponding field will not be replaced if
 it is already set. Note: The component field will only be copied if FILL_IN_COMPONENT is explicitly specified.  The selector will only be copied if FILL_IN_SELECTOR is explicitly specified. For example consider Intent A with {data=""foo"" categories=""bar""}
 and Intent B with {action=""gotit"" data-type=""some/thing""
 categories=""one""""two""}. Calling A.fillIn(B Intent.FILL_IN_DATA) will result in A now
 containing: {action=""gotit"" data-type=""some/thing""
 categories=""bar""}.","other Intent : Another Intent whose values are to be used to fill in
the current one.
This value cannot be null . |||
flags int : Options to control which fields can be filled in.
Value is either 0 or a combination of FILL_IN_ACTION  FILL_IN_DATA  FILL_IN_CATEGORIES  FILL_IN_COMPONENT  FILL_IN_PACKAGE  FILL_IN_SOURCE_BOUNDS  FILL_IN_SELECTOR and FILL_IN_CLIP_DATA |||","int Returns a bit mask of FILL_IN_ACTION  FILL_IN_DATA  FILL_IN_CATEGORIES  FILL_IN_PACKAGE  FILL_IN_COMPONENT  FILL_IN_SOURCE_BOUNDS  FILL_IN_SELECTOR and FILL_IN_CLIP_DATA indicating which fields were
 changed.
 
 Value is either 0 or a combination of FILL_IN_ACTION  FILL_IN_DATA  FILL_IN_CATEGORIES  FILL_IN_COMPONENT  FILL_IN_PACKAGE  FILL_IN_SOURCE_BOUNDS  FILL_IN_SELECTOR and FILL_IN_CLIP_DATA |||",1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
"<android.view.inputmethod.InputMethodManager: void setInputMethodAndSubtype(IBinder,String,InputMethodSubtype)>","This method was deprecated
      in API level 28. Use InputMethodService#switchInputMethod(String InputMethodSubtype) instead. This method was intended for IME developers who should be accessing APIs through
 the service. APIs in this class are intended for app developers interacting with the IME. Force switch to a new input method and subtype. This can only be called
 from an application or a service which has a token of the currently active input method. On Android Build.VERSION_CODES#Q and later devices token cannot be null even with Manifest.permission.WRITE_SECURE_SETTINGS . Instead
 update Settings.Secure.DEFAULT_INPUT_METHOD and Settings.Secure.SELECTED_INPUT_METHOD_SUBTYPE directly.","token IBinder : Supplies the identifying token given to an input method
when it was started which allows it to perform this operation on
itself.
This value cannot be null . |||
id String : The unique identifier for the new input method to be switched to. |||
subtype InputMethodSubtype : The new subtype of the new input method to be switched to. |||",void,11,"Central system API to the overall input method framework (IMF) architecture
 which arbitrates interaction between applications and the current input method.

  Topics covered here:
  Architecture Overview Applications Input Methods Security Architecture Overview There are three primary parties involved in the input method
 framework (IMF) architecture:  The  input method manager  as expressed by this class
 is the central point of the system that manages interaction between all
 other parts.  It is expressed as the client-side API here which exists
 in each application context and communicates with a global system service
 that manages the interaction across all processes.
   An  input method (IME)  implements a particular
 interaction model allowing the user to generate text.  The system binds
 to the current input method that is in use causing it to be created and run
 and tells it when to hide and show its UI.  Only one IME is running at a time.
   Multiple  client applications  arbitrate with the input
 method manager for input focus and control over the state of the IME.  Only
 one such client is ever active (working with the IME) at a time.
  Applications In most cases applications that are using the standard
  TextView  or its subclasses will have little they need
 to do to work well with soft input methods.  The main things you need to
 be aware of are:  Properly set the  R.attr.inputType  in your editable
 text views so that the input method will have enough context to help the
 user in entering text into them.
   Deal well with losing screen space when the input method is
 displayed.  Ideally an application should handle its window being resized
 smaller but it can rely on the system performing panning of the window
 if needed.  You should set the  R.attr.windowSoftInputMode 
 attribute on your activity or the corresponding values on windows you
 create to help the system determine whether to pan or resize (it will
 try to determine this automatically but may get it wrong).
   You can also control the preferred soft input state (open closed etc)
 for your window using the same  R.attr.windowSoftInputMode 
 attribute.
  More finer-grained control is available through the APIs here to directly
 interact with the IMF and its IME -- either showing or hiding the input
 area letting the user pick an input method etc. For the rare people amongst us writing their own text editors you
 will need to implement  View.onCreateInputConnection(EditorInfo) 
 to return a new instance of your own  InputConnection  interface
 allowing the IME to interact with your editor. Input Methods An input method (IME) is implemented
 as a  Service  typically deriving from
  InputMethodService .  It must provide
 the core  InputMethod  interface though this is normally handled by
  InputMethodService  and implementors will
 only need to deal with the higher-level API there. InputMethodService Security There are a lot of security issues associated with input methods
 since they essentially have freedom to completely drive the UI and monitor
 everything the user enters.  The Android input method framework also allows
 arbitrary third party IMEs so care must be taken to restrict their
 selection and interactions. Here are some key points about the security architecture behind the
 IMF: Only the system is allowed to directly access an IME's
  InputMethod  interface via the
  Manifest.permission.BIND_INPUT_METHOD  permission.  This is
 enforced in the system by not binding to an input method service that does
 not require this permission so the system can guarantee no other untrusted
 clients are accessing the current input method outside of its control. There may be many client processes of the IMF but only one may
 be active at a time.  The inactive clients can not interact with key
 parts of the IMF through the mechanisms described below. Clients of an input method are only given access to its
  InputMethodSession  interface.  One instance of this interface is
 created for each client and only calls from the session associated with
 the active client will be processed by the current IME.  This is enforced
 by  AbstractInputMethodService  for normal
 IMEs but must be explicitly handled by an IME that is customizing the
 raw  InputMethodSession  implementation. Only the active client's  InputConnection  will accept
 operations.  The IMF tells each client process whether it is active and
 the framework enforces that in inactive processes calls on to the current
 InputConnection will be ignored.  This ensures that the current IME can
 only deliver events and text edits to the UI that the user sees as
 being in focus. An IME can never interact with an  InputConnection  while
 the screen is off.  This is enforced by making all clients inactive while
 the screen is off and prevents bad IMEs from driving the UI when the user
 can not be aware of its behavior. A client application can ask that the system let the user pick a
 new IME but can not programmatically switch to one itself.  This avoids
 malicious applications from switching the user to their own IME which
 remains running when the user navigates away to another application.  An
 IME on the other hand  is  allowed to programmatically switch
 the system to another IME since it already has full control of user
 input. The user must explicitly enable a new IME in settings before
 they can switch to it to confirm with the system that they know about it
 and want to make it available for use. PackageManager#FEATURE_INPUT_METHODS PackageManager.hasSystemFeature(String)",,,,,,,,
<android.test.InstrumentationTestCase: void sendRepeatedKeys(int)>,"Sends a series of key events through instrumentation and waits for idle. Each key code
 must be preceded by the number of times the key code must be sent. For instance:
 sendRepeatedKeys(1 KEYCODE_DPAD_CENTER 2 KEYCODE_DPAD_LEFT).",keys int : The series of key repeats and codes to send through instrumentation. |||,void,1,A test case that has access to  Instrumentation .,,,,,,,,
<android.view.View: void setLayerPaint(Paint)>,"Updates the Paint object used with the current layer (used only if the current
 layer type is not set to LAYER_TYPE_NONE ). Changed properties of the Paint
 provided to setLayerType(int android.graphics.Paint) will be used the next time
 the View is redrawn but setLayerPaint(android.graphics.Paint) must be called to
 ensure that the view gets redrawn immediately. A layer is associated with an optional Paint instance that controls how the layer is composed on screen. The following
 properties of the paint are taken into account when composing the layer: Translucency (alpha) 
Blending mode 
Color filter 
If this view has an alpha value set to < 1.0 by calling setAlpha(float) the
 alpha value of the layer's paint is superseded by this view's alpha value.","paint Paint : The paint used to compose the layer. This argument is optional
and can be null. It is ignored when the layer type is LAYER_TYPE_NONE This value may be null . |||",void,17,"This class represents the basic building block for user interface components. A View
 occupies a rectangular area on the screen and is responsible for drawing and
 event handling. View is the base class for  widgets  which are
 used to create interactive UI components (buttons text fields etc.). The
  ViewGroup  subclass is the base class for  layouts  which
 are invisible containers that hold other Views (or other ViewGroups) and define
 their layout properties.",,,,,,,,
<android.view.ViewPropertyAnimator: ViewPropertyAnimator rotationY(float)>,"This method will cause the View's rotationY property to be animated to the
 specified value. Animations already running on the property will be canceled.",value float : The value to be animated to. |||,ViewPropertyAnimator This object allowing calls to methods in this class to be chained. |||,12,"This class enables automatic and optimized animation of select properties on View objects.
 If only one or two properties on a View object are being animated then using an
  ObjectAnimator  is fine; the property setters called by ObjectAnimator
 are well equipped to do the right thing to set the property and invalidate the view
 appropriately. But if several properties are animated simultaneously or if you just want a
 more convenient syntax to animate a specific property then ViewPropertyAnimator might be
 more well-suited to the task.

  This class may provide better performance for several simultaneous animations because
 it will optimize invalidate calls to take place only once for several properties instead of each
 animated property independently causing its own invalidation. Also the syntax of using this
 class could be easier to use because the caller need only tell the View object which
 property to animate and the value to animate either to or by and this class handles the
 details of configuring the underlying Animator class and starting it. This class is not constructed by the caller but rather by the View whose properties
 it will animate. Calls to  View.animate()  will return a reference
 to the appropriate ViewPropertyAnimator object for that View.",,,,,,,,
<android.inputmethodservice.KeyboardView: void setKeyboard(Keyboard)>,"Attaches a keyboard to this view. The keyboard can be switched at any time and the
 view will re-layout itself to accommodate the keyboard.",keyboard Keyboard : the keyboard to display in this view |||,void,3,"A view that renders a virtual  Keyboard . It handles rendering of keys and
 detecting key presses and touch movements.",,,,,,,,
<android.bluetooth.BluetoothServerSocket: BluetoothSocket accept()>,"Block until a connection is established. Returns a connected BluetoothSocket on successful connection. Once this call returns it can be called again to accept subsequent
 incoming connections. close() can be used to abort this call from another thread.",,BluetoothSocket a connected BluetoothSocket |||,5,"A listening Bluetooth socket.

  The interface for Bluetooth Sockets is similar to that of TCP sockets:
  Socket  and  ServerSocket . On the server
 side use a  BluetoothServerSocket  to create a listening server
 socket. When a connection is accepted by the  BluetoothServerSocket 
 it will return a new  BluetoothSocket  to manage the connection.
 On the client side use a single  BluetoothSocket  to both initiate
 an outgoing connection and to manage the connection.

  For Bluetooth BR/EDR the most common type of socket is RFCOMM which is the type supported by
 the Android APIs. RFCOMM is a connection-oriented streaming transport over Bluetooth BR/EDR. It
 is also known as the Serial Port Profile (SPP). To create a listening
  BluetoothServerSocket  that's ready for incoming Bluetooth BR/EDR connections use  BluetoothAdapter#listenUsingRfcommWithServiceRecord .

  For Bluetooth LE the socket uses LE Connection-oriented Channel (CoC). LE CoC is a
 connection-oriented streaming transport over Bluetooth LE and has a credit-based flow control.
 Correspondingly use  BluetoothAdapter#listenUsingL2capChannel  to create a listening  BluetoothServerSocket 
 that's ready for incoming Bluetooth LE CoC connections. For LE CoC you can use  getPsm() 
 to get the protocol/service multiplexer (PSM) value that the peer needs to use to connect to your
 socket.

   After the listening  BluetoothServerSocket  is created call  accept()  to
 listen for incoming connection requests. This call will block until a connection is established
 at which point it will return a  BluetoothSocket  to manage the connection. Once the
  BluetoothSocket  is acquired it's a good idea to call  close()  on the  BluetoothServerSocket  when it's no longer needed for accepting
 connections. Closing the  BluetoothServerSocket  will  not  close the returned
  BluetoothSocket .

  BluetoothServerSocket  is thread
 safe. In particular  close()  will always immediately abort ongoing
 operations and close the server socket.

  Note: 
 Requires the  Manifest.permission.BLUETOOTH  permission.","Provides classes that manage Bluetooth functionality such as scanning for
 devices connecting with devices and managing data transfer between devices.
 The Bluetooth API supports both ""Classic Bluetooth"" and Bluetooth Low Energy. For more information about Classic Bluetooth see the
  Bluetooth  guide.
 For more information about Bluetooth Low Energy see the
  
 Bluetooth Low Energy  (BLE) guide. The Bluetooth APIs let applications: Scan for other Bluetooth devices (including BLE devices). Query the local Bluetooth adapter for paired Bluetooth devices. Establish RFCOMM channels/sockets. Connect to specified sockets on other devices. Transfer data to and from other devices. Communicate with BLE devices such as proximity sensors heart rate
     monitors fitness devices and so on. Act as a GATT client or a GATT server (BLE). 
 To perform Bluetooth communication using these APIs an application must
 declare the  BLUETOOTH  permission. Some
 additional functionality such as requesting device discovery
 also requires the  BLUETOOTH_ADMIN 
 permission.
  Note: 
 Not all Android-powered devices provide Bluetooth functionality.",,,,,,,
"<android.os.Bundle: void putParcelableArrayList(String,ArrayList)>","Inserts a List of Parcelable values into the mapping of this Bundle
 replacing any existing value for the given key.  Either key or value may
 be null.","key String : a String or null
This value may be null . |||
value ArrayList : an ArrayList of Parcelable objects or null
This value may be null . |||",void,1,A mapping from String keys to various  Parcelable  values.,,,,,,,,
<android.content.ContentResolver: List getCurrentSyncs()>,"Returns a list with information about all the active syncs. This list will be empty
 if there are no active syncs. This method requires the caller to hold the permission Manifest.permission.READ_SYNC_STATS .",,List < SyncInfo > a List of SyncInfo objects for the currently active syncs. |||,11,This class provides applications access to the content model.,"Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.hardware.usb.UsbManager: UsbDeviceConnection openDevice(UsbDevice)>,"Opens the device so it can be used to send and receive
 data using UsbRequest . Requires the PackageManager#FEATURE_USB_HOST feature which can be detected using PackageManager.hasSystemFeature(String) .",device UsbDevice : the device to open |||,UsbDeviceConnection a UsbDeviceConnection or null if open failed |||,12,"This class allows you to access the state of USB and communicate with USB devices.
 Currently only host mode is supported in the public API.","Provides support to communicate with USB hardware peripherals that are connected to
 Android-powered devices. For more information see the
  USB  guide. Use  UsbManager  to access the state of the USB and to
 communicate with connected hardware peripherals. Use  UsbDevice  to
 communicate with the hardware peripheral if the Android-powered device is acting as the USB host.
 Use  UsbAccessory  if the peripheral is acting as the USB host.",,,,,,,
<android.app.WallpaperManager: WallpaperManager getInstance(Context)>,Retrieve a WallpaperManager associated with the given Context.,context Context |||,WallpaperManager |||,5,"Provides access to the system wallpaper. With WallpaperManager you can
 get the current wallpaper get the desired dimensions for the wallpaper set
 the wallpaper and more.

   An app can check whether wallpapers are supported for the current user by calling
  isWallpaperSupported()  and whether setting of wallpapers is allowed by calling
  isSetWallpaperAllowed() .","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.view.View: void getWindowVisibleDisplayFrame(Rect)>,"Retrieve the overall visible display size in which the window this view is
 attached to has been positioned in.  This takes into account screen
 decorations above the window for both cases where the window itself
 is being position inside of them or the window is being placed under
 then and covered insets are used for the window to position its content
 inside.  In effect this tells you the available area where content can
 be placed and remain visible to users. This function requires an IPC back to the window manager to retrieve
 the requested information so should not be used in performance critical
 code like drawing.","outRect Rect : Filled in with the visible display frame.  If the view
is not attached to a window this is simply the raw display size. |||",void,3,"This class represents the basic building block for user interface components. A View
 occupies a rectangular area on the screen and is responsible for drawing and
 event handling. View is the base class for  widgets  which are
 used to create interactive UI components (buttons text fields etc.). The
  ViewGroup  subclass is the base class for  layouts  which
 are invisible containers that hold other Views (or other ViewGroups) and define
 their layout properties.",,,,,,,,
"<android.text.Layout: void getSelectionPath(int,int,Path)>","Fills in the specified Path with a representation of a highlight
 between the specified offsets.  This will often be a rectangle
 or a potentially discontinuous set of rectangles.  If the start
 and end are the same the returned path is empty.","start int |||
end int |||
dest Path |||",void,1,"A base class that manages text layout in visual elements on
 the screen.
  For text that will be edited use a  DynamicLayout 
 which will be updated as the text changes.
 For text that will not change use a  StaticLayout .","Provides classes used to render or track text and text spans on the screen. You can use these classes to design your own widgets that manage text
 to handle arbitrary text spans for changes or to handle drawing yourself
 for an existing widget. The Span… interfaces and classes are used to create or manage spans of
 text in a View item. You can use these to style the text or background or to
 listen for changes. If creating your own widget extend DynamicLayout to manages
 the actual wrapping and drawing of your text.",,,,,,,
<android.app.Instrumentation: Bundle getBinderCounts()>,"Returns a bundle with the counts for various binder counts for this process. Currently the only two that are
 reported are the number of send and the number of received transactions.",,Bundle |||,1,"Base class for implementing application instrumentation code.  When running
 with instrumentation turned on this class will be instantiated for you
 before any of the application code allowing you to monitor all of the
 interaction the system has with the application.  An Instrumentation
 implementation is described to the system through an AndroidManifest.xml's
 <instrumentation> tag.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
"<android.content.ContextWrapper: void enforceUriPermission(Uri,int,int,int,String)>","If a particular process and user ID has not been granted
 permission to access a specific URI throw SecurityException .  This only checks for permissions that have
 been explicitly granted -- if the given process/uid has more
 general access to the URI's content provider then this check
 will always fail.","uri Uri : The uri that is being checked. |||
pid int : The process ID being checked against.  Must be > 0. |||
uid int : The user ID being checked against.  A uid of 0 is the root
user which will pass every permission check. |||
modeFlags int : The access modes to enforce.
Value is either 0 or a combination of Intent.FLAG_GRANT_READ_URI_PERMISSION and Intent.FLAG_GRANT_WRITE_URI_PERMISSION |||
message String : A message to include in the exception if it is thrown. |||",void,1,"Proxying implementation of Context that simply delegates all of its calls to
 another Context.  Can be subclassed to modify behavior without changing
 the original Context.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.view.ViewPropertyAnimator: ViewPropertyAnimator translationX(float)>,"This method will cause the View's translationX property to be animated to the
 specified value. Animations already running on the property will be canceled.",value float : The value to be animated to. |||,ViewPropertyAnimator This object allowing calls to methods in this class to be chained. |||,12,"This class enables automatic and optimized animation of select properties on View objects.
 If only one or two properties on a View object are being animated then using an
  ObjectAnimator  is fine; the property setters called by ObjectAnimator
 are well equipped to do the right thing to set the property and invalidate the view
 appropriately. But if several properties are animated simultaneously or if you just want a
 more convenient syntax to animate a specific property then ViewPropertyAnimator might be
 more well-suited to the task.

  This class may provide better performance for several simultaneous animations because
 it will optimize invalidate calls to take place only once for several properties instead of each
 animated property independently causing its own invalidation. Also the syntax of using this
 class could be easier to use because the caller need only tell the View object which
 property to animate and the value to animate either to or by and this class handles the
 details of configuring the underlying Animator class and starting it. This class is not constructed by the caller but rather by the View whose properties
 it will animate. Calls to  View.animate()  will return a reference
 to the appropriate ViewPropertyAnimator object for that View.",,,,,,,,
<android.view.View: void setScrollBarFadeDuration(int)>,Define the scrollbar fade duration. Related XML Attributes: android:scrollbarFadeDuration,scrollBarFadeDuration int : - the scrollbar fade duration in milliseconds |||,void,16,"This class represents the basic building block for user interface components. A View
 occupies a rectangular area on the screen and is responsible for drawing and
 event handling. View is the base class for  widgets  which are
 used to create interactive UI components (buttons text fields etc.). The
  ViewGroup  subclass is the base class for  layouts  which
 are invisible containers that hold other Views (or other ViewGroups) and define
 their layout properties.",,,,,,,,
<android.accounts.AccountAuthenticatorResponse: void onResult(Bundle)>,,result Bundle |||,void,5,Object used to communicate responses back to the AccountManager,,,,,,,,
"<android.net.sip.SipSession: void changeCall(String,int)>","Changes the session description during a call. The method is only valid
 to call when the session state is in State#IN_CALL .","sessionDescription String : the new session description |||
timeout int : the session will be timed out if the call is not
established within timeout seconds. Default value (defined
by SIP protocol) is used if timeout is zero or negative. |||",void,9,"Represents a SIP session that is associated with a SIP dialog or a standalone
 transaction not within a dialog.
  You can get a  SipSession  from  SipManager  with  SipManager#createSipSession  (when initiating calls) or  SipManager#getSessionFor  (when receiving calls).",,,,,,,,
<android.widget.StackView: void advance()>,"Called by an AppWidgetHost in order to advance the current view when
 it is being used within an app widget.",,void,11,,"The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
"<android.app.Fragment: Fragment instantiate(Context,String)>","Like instantiate(android.content.Context java.lang.String android.os.Bundle) but with a null
 argument Bundle.","context Context |||
fname String |||",Fragment |||,11,"A Fragment is a piece of an application's user interface or behavior
 that can be placed in an  Activity .  Interaction with fragments
 is done through  FragmentManager  which can be obtained via
  Activity#getFragmentManager()  and
  Fragment#getFragmentManager() .

  The Fragment class can be used many ways to achieve a wide variety of
 results. In its core it represents a particular operation or interface
 that is running within a larger  Activity .  A Fragment is closely
 tied to the Activity it is in and can not be used apart from one.  Though
 Fragment defines its own lifecycle that lifecycle is dependent on its
 activity: if the activity is stopped no fragments inside of it can be
 started; when the activity is destroyed all fragments will be destroyed.

  All subclasses of Fragment must include a public no-argument constructor.
 The framework will often re-instantiate a fragment class when needed
 in particular during state restore and needs to be able to find this
 constructor to instantiate it.  If the no-argument constructor is not
 available a runtime exception will occur in some cases during state
 restore.

  Topics covered here:
  Older Platforms Lifecycle Layout Back Stack","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
"<android.widget.AdapterViewAnimator: void setOutAnimation(Context,int)>",Specifies the animation used to animate a View that exit the screen.,"context Context : The application's environment. |||
resourceID int : The resource id of the animation. |||",void,11,"An AdapterView is a view whose children are determined by an  Adapter .

  
 See  ListView   GridView   Spinner  and
       Gallery  for commonly used subclasses of AdapterView.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.nfc.tech.MifareUltralight: void close()>,"Disable I/O operations to the tag from this TagTechnology object and release resources. Also causes all blocked I/O operations on other thread to be canceled and
 return with IOException . Requires the Manifest.permission.NFC permission.",,void,-1,"Provides access to MIFARE Ultralight properties and I/O operations on a  Tag .

  Acquire a  MifareUltralight  object using  get(Tag) .

  MIFARE Ultralight compatible tags have 4 byte pages  PAGE_SIZE .
 The primary operations on an Ultralight tag are  readPages(int)  and
  writePage(int byte[]) .

  The original MIFARE Ultralight consists of a 64 byte EEPROM. The first
 4 pages are for the OTP area manufacturer data and locking bits. They are
 readable and some bits are writable. The final 12 pages are the user
 read/write area. For more information see the NXP data sheet MF0ICU1.

  The MIFARE Ultralight C consists of a 192 byte EEPROM. The first 4 pages
 are for OTP manufacturer data and locking bits. The next 36 pages are the
 user read/write area. The next 4 pages are additional locking bits counters
 and authentication configuration and are readable. The final 4 pages are for
 the authentication key and are not readable. For more information see the
 NXP data sheet MF0ICU2.

  Implementation of this class on a Android NFC device is optional.
 If it is not implemented then
  MifareUltralight  will never be enumerated in  Tag#getTechList .
 If it is enumerated then all  MifareUltralight  I/O operations will be supported.
 In either case  NfcA  will also be enumerated on the tag
 because all MIFARE Ultralight tags are also  NfcA  tags.

  Note:  Methods that perform I/O operations
 require the  Manifest.permission.NFC  permission.","These classes provide access to a tag technology's features which vary by the type
 of tag that is scanned. A scanned tag can support multiple technologies and you can find
 out what they are by calling  getTechList() . For more information on dealing with tag technologies and handling the ones that you care about see
  The Tag Dispatch System .
 The  TagTechnology  interface provides an overview of the
 supported technologies.",,,,,,,
"<android.media.MediaPlayer: MediaPlayer create(Context,Uri)>","Convenience method to create a MediaPlayer for a given Uri.
 On success prepare() will already have been called and must not be called again. When done with the MediaPlayer you should call release() to free the resources. If not released too many MediaPlayer instances will
 result in an exception. Note that since prepare() is called automatically in this method
 you cannot change the audio
 session ID (see setAudioSessionId(int) ) or audio attributes
 (see setAudioAttributes(android.media.AudioAttributes) of the new MediaPlayer.","context Context : the Context to use |||
uri Uri : the Uri from which to get the datasource |||",MediaPlayer a MediaPlayer object or null if creation failed |||,1,"MediaPlayer class can be used to control playback
 of audio/video files and streams. An example on how to use the methods in
 this class can be found in  VideoView .

  Topics covered here are:
  State Diagram Valid and Invalid States Permissions Register informational and error callbacks","The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",,,,,,,
<android.widget.VideoView: void start()>,,,void,1,"Displays a video file.  The VideoView class
 can load images from various sources (such as resources or content
 providers) takes care of computing its measurement from the video so that
 it can be used in any layout manager and provides various display options
 such as scaling and tinting. Note: VideoView does not retain its full state when going into the
 background.   In particular it does not restore the current play state
 play position selected tracks or any subtitle tracks added via
  addSubtitleSource() .  Applications should
 save and restore these on their own in
  Activity.onSaveInstanceState(Bundle)  and
  Activity.onRestoreInstanceState(Bundle) . 
 Also note that the audio session id (from  getAudioSessionId() ) may
 change from its previously returned value when the VideoView is restored.
  
 By default VideoView requests audio focus with  AudioManager#AUDIOFOCUS_GAIN . Use
  setAudioFocusRequest(int)  to change this behavior.
  
 The default  AudioAttributes  used during playback have a usage of
  AudioAttributes#USAGE_MEDIA  and a content type of
  AudioAttributes#CONTENT_TYPE_MOVIE  use  setAudioAttributes(android.media.AudioAttributes)  to
 modify them.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.service.wallpaper.WallpaperService: void onCreate()>,Called by the system when the service is first created.  Do not call this method directly.,,void,7,"A wallpaper service is responsible for showing a live wallpaper behind
 applications that would like to sit on top of it.  This service object
 itself does very little -- its only purpose is to generate instances of
  Engine  as needed.  Implementing a wallpaper thus
 involves subclassing from this subclassing an Engine implementation
 and implementing  onCreateEngine()  to return a new instance of
 your engine.",,,,,,,,
"<android.content.Intent: Intent putExtra(String,Bundle)>","Add extended data to the intent.  The name must include a package
 prefix for example the app com.android.contacts would use names
 like ""com.android.contacts.ShowAll"".","name String : The name of the extra data with package prefix. |||
value Bundle : The Bundle data value.
This value may be null . |||","Intent Returns the same Intent object for chaining multiple calls
 into a single statement.

 This value cannot be null . |||",1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.content.CursorLoader: Cursor loadInBackground()>,"Called on a worker thread to perform the actual load and to return
 the result of the load operation.

 Implementations should not deliver the result directly but should return them
 from this method which will eventually end up calling Loader.deliverResult(D) on
 the UI thread.  If implementations need to process the results on the UI thread
 they may override Loader.deliverResult(D) and do so there.

 To support cancellation this method should periodically check the value of isLoadInBackgroundCanceled() and terminate when it returns true.
 Subclasses may also override cancelLoadInBackground() to interrupt the load
 directly instead of polling isLoadInBackgroundCanceled() .

 When the load is canceled this method may either return normally or throw OperationCanceledException .  In either case the Loader will
 call onCanceled(D) to perform post-cancellation cleanup and to dispose of the
 result object if any.",,Cursor The result of the load operation. |||,11,"A loader that queries the  ContentResolver  and returns a  Cursor .
 This class implements the  Loader  protocol in a standard way for
 querying cursors building on  AsyncTaskLoader  to perform the cursor
 query on a background thread so that it does not block the application's UI.

  A CursorLoader must be built with the full information for the query to
 perform either through the
  CursorLoader(android.content.Context android.net.Uri java.lang.String[] java.lang.String java.lang.String[] java.lang.String)  or
 creating an empty instance with  CursorLoader(android.content.Context)  and filling
 in the desired parameters with  setUri(android.net.Uri)   setSelection(java.lang.String) 
  setSelectionArgs(java.lang.String[])   setSortOrder(java.lang.String) 
 and  setProjection(java.lang.String[]) .","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
"<android.app.SearchManager: void triggerSearch(String,ComponentName,Bundle)>","Similar to startSearch(String boolean ComponentName Bundle boolean) but actually fires off the search query after invoking
 the search dialog.  Made available for testing purposes.","query String : The query to trigger.  If empty request will be ignored. |||
launchActivity ComponentName : The ComponentName of the activity that has launched this search. |||
appSearchData Bundle : An application can insert application-specific
context here in order to improve quality or specificity of its own
searches.  This data will be returned with SEARCH intent(s).  Null if
no extra data is required. |||",void,5,"This class provides access to the system search services.

  In practice you won't interact with this class directly as search
 services are provided through methods in  Activity 
 and the  ACTION_SEARCH Intent .

  Configuration#UI_MODE_TYPE_WATCH  does not support this system service.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
"<android.os.Bundle: char getChar(String,char)>","Returns the value associated with the given key or defaultValue if
 no mapping of the desired type exists for the given key.","key String : a String |||
defaultValue char : Value to return if key does not exist |||",char a char value |||,1,A mapping from String keys to various  Parcelable  values.,,,,,,,,
"<android.content.pm.ActivityInfo: void writeToParcel(Parcel,int)>",,"dest Parcel |||
parcelableFlags int |||",void,1,"Information you can retrieve about a particular application
 activity or receiver. This corresponds to information collected
 from the AndroidManifest.xml's <activity> and
 <receiver> tags.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
"<android.content.ContentProviderClient: int delete(Uri,String,String)>",See ContentProvider#delete,"url Uri : This value cannot be null . |||
selection String : This value may be null . |||
selectionArgs String : This value may be null . |||",int |||,5,"Content providers are one of the primary building blocks of Android applications providing
 content to applications. They encapsulate data and provide it to applications through the single
  ContentResolver  interface. A content provider is only required if you need to share
 data between multiple applications. For example the contacts data is used by multiple
 applications and must be stored in a content provider. If you don't need to share data amongst
 multiple applications you can use a database directly via
  SQLiteDatabase .

  When a request is made via
 a  ContentResolver  the system inspects the authority of the given URI and passes the
 request to the content provider registered with the authority. The content provider can interpret
 the rest of the URI however it wants. The  UriMatcher  class is helpful for parsing
 URIs. The primary methods that need to be implemented are:
  onCreate()  which is called to initialize the provider query(Uri String[] Bundle CancellationSignal)  which returns data to the caller insert(Uri ContentValues)  which inserts new data into the content provider update(Uri ContentValues String String[])  which updates existing data in the content provider delete(Uri String String[])  which deletes data from the content provider getType(Uri)  which returns the MIME type of data in the content provider Requests to  ContentResolver  are automatically forwarded to the appropriate
 ContentProvider instance so subclasses don't have to worry about the details of
 cross-process calls.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
"<android.app.Activity: Cursor managedQuery(Uri,String,String,String,String)>","This method was deprecated
      in API level 15. Use CursorLoader instead. Wrapper around ContentResolver#query(android.net.Uri  String[] String String[] String) that gives the resulting Cursor to call startManagingCursor(Cursor) so that the activity will manage its
 lifecycle for you. If you are targeting Build.VERSION_CODES.HONEYCOMB or later consider instead using LoaderManager instead available
 via getLoaderManager() . Warning: Do not call Cursor#close() on a cursor obtained using
 this method because the activity will do that for you at the appropriate time. However if
 you call stopManagingCursor(Cursor) on a cursor from a managed query the system will
 not automatically close the cursor and in that case you must call Cursor#close() .","uri Uri : The URI of the content provider to query. |||
projection String : List of columns to return. |||
selection String : SQL WHERE clause. |||
selectionArgs String : The arguments to selection if any ?s are pesent |||
sortOrder String : SQL ORDER BY clause. |||",Cursor The Cursor that was returned by query(). |||,1,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.widget.EditText: void selectAll()>,Convenience for Selection#selectAll .,,void,1,"A user interface element for entering and modifying text.
 When you define an edit text widget you must specify the
  R.styleable.TextView_inputType 
 attribute. For example for plain text input set inputType to ""text"":
  
 <EditText
     android:id=""@+id/plain_text_input""
     android:layout_height=""wrap_content""
     android:layout_width=""match_parent""
     android:inputType=""text""/> 
 See the  Text Fields 
 guide for examples of other
  R.styleable.TextView_inputType  settings.
  You also can receive callbacks as a user changes text by
 adding a  TextWatcher  to the edit text.
 This is useful when you want to add auto-save functionality as changes are made
 or validate the format of user input for example.
 You add a text watcher using the  TextView#addTextChangedListener  method.
  
 This widget does not support auto-sizing text.
  XML attributes 
 See  EditText Attributes 
  TextView Attributes 
  View Attributes","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.inputmethodservice.InputMethodService: void onCreate()>,Called by the system when the service is first created.  Do not call this method directly.,,void,3,"InputMethodService provides a standard implementation of an InputMethod
 which final implementations can derive from and customize.  See the
 base class  AbstractInputMethodService  and the  InputMethod 
 interface for more information on the basics of writing input methods.

  In addition to the normal Service lifecycle methods this class
 introduces some new specific callbacks that most subclasses will want
 to make use of: onInitializeInterface()  for user-interface initialization
 in particular to deal with configuration changes while the service is
 running.
  onBindInput()  to find out about switching to a new client.
  onStartInput(EditorInfo boolean)  to deal with an input session starting with
 the client.
  onCreateInputView()   onCreateCandidatesView() 
 and  onCreateExtractTextView()  for non-demand generation of the UI.
  onStartInputView(android.view.inputmethod.EditorInfo boolean)  to deal with input
 starting within the input area of the IME.
  An input method has significant discretion in how it goes about its
 work: the  InputMethodService  provides
 a basic framework for standard UI elements (input view candidates view
 and running in fullscreen mode) but it is up to a particular implementor
 to decide how to use them.  For example one input method could implement
 an input area with a keyboard another could allow the user to draw text
 while a third could have no input area (and thus not be visible to the
 user) but instead listen to audio and perform text to speech conversion. In the implementation provided here all of these elements are placed
 together in a single window managed by the InputMethodService.  It will
 execute callbacks as it needs information about them and provides APIs for
 programmatic control over them.  They layout of these elements is explicitly
 defined: The soft input view if available is placed at the bottom of the
 screen.
  The candidates view if currently shown is placed above the soft
 input view.
  If not running fullscreen the application is moved or resized to be
 above these views; if running fullscreen the window will completely cover
 the application and its top part will contain the extract text of what is
 currently being edited by the application.
  Soft Input View Central to most input methods is the soft input view.  This is where most
 user interaction occurs: pressing on soft keys drawing characters or
 however else your input method wants to generate text.  Most implementations
 will simply have their own view doing all of this work and return a new
 instance of it when  onCreateInputView()  is called.  At that point
 as long as the input view is visible you will see user interaction in
 that view and can call back on the InputMethodService to interact with the
 application as appropriate. There are some situations where you want to decide whether or not your
 soft input view should be shown to the user.  This is done by implementing
 the  onEvaluateInputViewShown()  to return true or false based on
 whether it should be shown in the current environment.  If any of your
 state has changed that may impact this call
  updateInputViewShown()  to have it re-evaluated.  The default
 implementation always shows the input view unless there is a hard
 keyboard available which is the appropriate behavior for most input
 methods. Candidates View Often while the user is generating raw text an input method wants to
 provide them with a list of possible interpretations of that text that can
 be selected for use.  This is accomplished with the candidates view and
 like the soft input view you implement  onCreateCandidatesView() 
 to instantiate your own view implementing your candidates UI. Management of the candidates view is a little different than the input
 view because the candidates view tends to be more transient being shown
 only when there are possible candidates for the current text being entered
 by the user.  To control whether the candidates view is shown you use
  setCandidatesViewShown(boolean) .  Note that because the candidate
 view tends to be shown and hidden a lot it does not impact the application
 UI in the same way as the soft input view: it will never cause application
 windows to resize only cause them to be panned if needed for the user to
 see the current focus. Fullscreen Mode Sometimes your input method UI is too large to integrate with the
 application UI so you just want to take over the screen.  This is
 accomplished by switching to full-screen mode causing the input method
 window to fill the entire screen and add its own ""extracted text"" editor
 showing the user the text that is being typed.  Unlike the other UI elements
 there is a standard implementation for the extract editor that you should
 not need to change.  The editor is placed at the top of the IME above the
 input and candidates views. Similar to the input view you control whether the IME is running in
 fullscreen mode by implementing  onEvaluateFullscreenMode() 
 to return true or false based on
 whether it should be fullscreen in the current environment.  If any of your
 state has changed that may impact this call
  updateFullscreenMode()  to have it re-evaluated.  The default
 implementation selects fullscreen mode when the screen is in a landscape
 orientation which is appropriate behavior for most input methods that have
 a significant input area. When in fullscreen mode you have some special requirements because the
 user can not see the application UI.  In particular you should implement
  onDisplayCompletions(android.view.inputmethod.CompletionInfo[])  to show completions
 generated by your application typically in your candidates view like you
 would normally show candidates.


  Generating Text The key part of an IME is of course generating text for the application.
 This is done through calls to the
  InputConnection  interface to the
 application which can be retrieved from  getCurrentInputConnection() .
 This interface allows you to generate raw key events or if the target
 supports it directly edit in strings of candidates and committed text. Information about what the target is expected and supports can be found
 through the  EditorInfo  class which is
 retrieved with  getCurrentInputEditorInfo()  method.  The most
 important part of this is  EditorInfo.inputType ; in particular if this is
  EditorInfo.TYPE_NULL 
 then the target does not support complex edits and you need to only deliver
 raw key events to it.  An input method will also want to look at other
 values here to for example detect password mode auto complete text views
 phone number entry etc. When the user switches between input targets you will receive calls to
  onFinishInput()  and  onStartInput(android.view.inputmethod.EditorInfo boolean) .
 You can use these to reset and initialize your input state for the current
 target.  For example you will often want to clear any input state and
 update a soft keyboard to be appropriate for the new inputType.",,,,,,,,
<android.nfc.tech.NfcV: void connect()>,"Enable I/O operations to the tag from this TagTechnology object. May cause RF activity and may block. Must not be called
 from the main application thread. A blocked call will be canceled with IOException by calling close() from another thread. Only one TagTechnology object can be connected to a Tag at a time. Applications must call close() when I/O operations are complete. Requires the Manifest.permission.NFC permission.",,void,-1,"Provides access to NFC-V (ISO 15693) properties and I/O operations on a  Tag .

  Acquire a  NfcV  object using  get(Tag) .
  The primary NFC-V I/O operation is  transceive(byte[]) . Applications must
 implement their own protocol stack on top of  transceive(byte[]) .

  Note:  Methods that perform I/O operations
 require the  Manifest.permission.NFC  permission.","These classes provide access to a tag technology's features which vary by the type
 of tag that is scanned. A scanned tag can support multiple technologies and you can find
 out what they are by calling  getTechList() . For more information on dealing with tag technologies and handling the ones that you care about see
  The Tag Dispatch System .
 The  TagTechnology  interface provides an overview of the
 supported technologies.",,,,,,,
<android.media.Ringtone: String getTitle(Context)>,"Returns a human-presentable title for ringtone. Looks in media
 content provider. If not in either uses the filename",context Context : A context used for querying. |||,String |||,1,"Ringtone provides a quick method for playing a ringtone notification or
 other similar types of sounds.
  
 For ways of retrieving  Ringtone  objects or to show a ringtone
 picker see  RingtoneManager .","The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",,,,,,,
"<android.content.SearchRecentSuggestionsProvider: Cursor query(Uri,String,String,String,String)>","This method is provided for use by the ContentResolver.  Do not override or directly
 call from your own code.","uri Uri : The URI to query. This will be the full URI sent by the client;
if the client is requesting a specific record the URI will end in a record number
that the implementation should parse and add to a WHERE or HAVING clause specifying
that _id value.
This value cannot be null . |||
projection String : The list of columns to put into the cursor. If null all columns are included.
This value may be null . |||
selection String : A selection criteria to apply when filtering rows.
If null then all rows are included.
This value may be null . |||
selectionArgs String : You may include ?s in selection which will be replaced by
the values from selectionArgs in order that they appear in the selection.
The values will be bound as Strings.
This value may be null . |||
sortOrder String : How the rows in the cursor should be sorted.
If null then the provider is free to define the sort order.
This value may be null . |||",Cursor a Cursor or null . |||,1,"This superclass can be used to create a simple search suggestions provider for your application.
 It creates suggestions (as the user types) based on recent queries and/or recent views.

  In order to use this class you must do the following.

  Implement and test query search as described in  SearchManager .  (This
 provider will send any suggested queries via the standard
  ACTION_SEARCH  Intent which you'll already
 support once you have implemented and tested basic searchability.) Create a Content Provider within your application by extending
  SearchRecentSuggestionsProvider .  The class you create will be
 very simple - typically it will have only a constructor.  But the constructor has a very
 important responsibility:  When it calls  setupSuggestions(java.lang.String int)  it
  configures  the provider to match the requirements of your searchable activity. Create a manifest entry describing your provider.  Typically this would be as simple
 as adding the following lines:
  
     <!-- Content provider for search suggestions -->
     <provider android:name=""YourSuggestionProviderClass""
               android:authorities=""your.suggestion.authority"" /> Please note that you  do not  instantiate this content provider directly from within
 your code.  This is done automatically by the system Content Resolver when the search dialog
 looks for suggestions. In order for the Content Resolver to do this you must update your searchable activity's
 XML configuration file with information about your content provider.  The following additions
 are usually sufficient:
  
     android:searchSuggestAuthority=""your.suggestion.authority""
     android:searchSuggestSelection="" ? "" In your searchable activities capture any user-generated queries and record them
 for future searches by calling  SearchRecentSuggestions.saveRecentQuery() .","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.appwidget.AppWidgetHostView: void updateAppWidget(RemoteViews)>,"Process a set of RemoteViews coming in as an update from the
 AppWidget provider. Will animate into these new views as needed",remoteViews RemoteViews |||,void,3,"Provides the glue to show AppWidget views. This class offers automatic animation
 between updates and will try recycling old views for each incoming
  RemoteViews .","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
"<android.view.inputmethod.InputConnectionWrapper: CharSequence getTextAfterCursor(int,int)>","Get n characters of text after the current cursor
 position. This method may fail either if the input connection has
 become invalid (such as its process crashing) or the client is
 taking too long to respond with the text (it is given a couple
 seconds to return). In either case null is returned. This method does not affect the text in the editor in any
 way nor does it affect the selection or composing spans. If GET_TEXT_WITH_STYLES is supplied as flags the
 editor should return a SpannableString with all the spans set on the text. IME authors: please consider this will
 trigger an IPC round-trip that will take some time. Assume this
 method consumes a lot of time. If you are using this to get the
 initial text around the cursor you may consider using EditorInfo#getInitialTextBeforeCursor(int int)  EditorInfo#getInitialSelectedText(int) and EditorInfo#getInitialTextAfterCursor(int int) to prevent IPC costs. Editor authors: please be careful of race
 conditions in implementing this call. An IME can make a change
 to the text and use this method right away; you need to make
 sure the returned value is consistent with the result of the
 latest edits. Also you may return less than n characters if performance
 dictates so but keep in mind IMEs are relying on this for many
 functions: you should not for example limit the returned value to
 the current line and specifically do not return 0 characters unless
 the cursor is really at the end of the text.","n int : The expected length of the text. |||
flags int : Supplies additional options controlling how the text is
returned. May be either 0 or InputConnection.GET_TEXT_WITH_STYLES . |||","CharSequence the text after the cursor position; the length of the
 returned text might be less than n . |||",3,Wrapper class for proxying calls to another InputConnection.  Subclass and have fun!,,,,,,,,
<android.nfc.tech.MifareClassic: void setTimeout(int)>,"Set the transceive(byte[]) timeout in milliseconds. The timeout only applies to transceive(byte[]) on this object
 and is reset to a default value when close() is called. Setting a longer timeout may be useful when performing
 transactions that require a long processing time on the tag
 such as key generation. Requires the Manifest.permission.NFC permission.",timeout int : timeout value in milliseconds |||,void,14,"Provides access to MIFARE Classic properties and I/O operations on a  Tag .

  Acquire a  MifareClassic  object using  get(Tag) .

  MIFARE Classic is also known as MIFARE Standard.
  MIFARE Classic tags are divided into sectors and each sector is sub-divided into
 blocks. Block size is always 16 bytes ( BLOCK_SIZE . Sector size varies.
  MIFARE Classic Mini are 320 bytes ( SIZE_MINI ) with 5 sectors each of 4 blocks.
  MIFARE Classic 1k are 1024 bytes ( SIZE_1K ) with 16 sectors each of 4 blocks.
  MIFARE Classic 2k are 2048 bytes ( SIZE_2K ) with 32 sectors each of 4 blocks.
  MIFARE Classic 4k are 4096 bytes ( SIZE_4K ). The first 32 sectors contain 4 blocks
 and the last 8 sectors contain 16 blocks.
  MIFARE Classic tags require authentication on a per-sector basis before any
 other I/O operations on that sector can be performed. There are two keys per sector
 and ACL bits determine what I/O operations are allowed on that sector after
 authenticating with a key.  and
 .

  Three well-known authentication keys are defined in this class:
  KEY_DEFAULT   KEY_MIFARE_APPLICATION_DIRECTORY 
  KEY_NFC_FORUM .
  KEY_DEFAULT  is the default factory key for MIFARE Classic.
  KEY_MIFARE_APPLICATION_DIRECTORY  is the well-known key for
 MIFARE Classic cards that have been formatted according to the
 MIFARE Application Directory (MAD) specification.
  KEY_NFC_FORUM  is the well-known key for MIFARE Classic cards that
 have been formatted according to the NXP specification for NDEF on MIFARE Classic.

  Implementation of this class on a Android NFC device is optional.
 If it is not implemented then
  MifareClassic  will never be enumerated in  Tag#getTechList .
 If it is enumerated then all  MifareClassic  I/O operations will be supported
 and  Ndef#MIFARE_CLASSIC  NDEF tags will also be supported. In either case
  NfcA  will also be enumerated on the tag because all MIFARE Classic tags are also
  NfcA .

  Note:  Methods that perform I/O operations
 require the  Manifest.permission.NFC  permission.","These classes provide access to a tag technology's features which vary by the type
 of tag that is scanned. A scanned tag can support multiple technologies and you can find
 out what they are by calling  getTechList() . For more information on dealing with tag technologies and handling the ones that you care about see
  The Tag Dispatch System .
 The  TagTechnology  interface provides an overview of the
 supported technologies.",,,,,,,
<android.view.View: int getScrollBarSize()>,Returns the scrollbar size. Related XML Attributes: android:scrollbarSize,,int the scrollbar size |||,16,"This class represents the basic building block for user interface components. A View
 occupies a rectangular area on the screen and is responsible for drawing and
 event handling. View is the base class for  widgets  which are
 used to create interactive UI components (buttons text fields etc.). The
  ViewGroup  subclass is the base class for  layouts  which
 are invisible containers that hold other Views (or other ViewGroups) and define
 their layout properties.",,,,,,,,
"<android.app.Fragment: void startActivityForResult(Intent,int)>","Call Activity#startActivityForResult(Intent int) from the fragment's
 containing Activity.","intent Intent |||
requestCode int |||",void,11,"A Fragment is a piece of an application's user interface or behavior
 that can be placed in an  Activity .  Interaction with fragments
 is done through  FragmentManager  which can be obtained via
  Activity#getFragmentManager()  and
  Fragment#getFragmentManager() .

  The Fragment class can be used many ways to achieve a wide variety of
 results. In its core it represents a particular operation or interface
 that is running within a larger  Activity .  A Fragment is closely
 tied to the Activity it is in and can not be used apart from one.  Though
 Fragment defines its own lifecycle that lifecycle is dependent on its
 activity: if the activity is stopped no fragments inside of it can be
 started; when the activity is destroyed all fragments will be destroyed.

  All subclasses of Fragment must include a public no-argument constructor.
 The framework will often re-instantiate a fragment class when needed
 in particular during state restore and needs to be able to find this
 constructor to instantiate it.  If the no-argument constructor is not
 available a runtime exception will occur in some cases during state
 restore.

  Topics covered here:
  Older Platforms Lifecycle Layout Back Stack","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
"<android.widget.ViewAnimator: void setOutAnimation(Context,int)>",Specifies the animation used to animate a View that exit the screen.,"context Context : The application's environment. |||
resourceID int : The resource id of the animation. |||",void,1,"Base class for a  FrameLayout  container that will perform animations
 when switching between its views.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.bluetooth.BluetoothDevice: ParcelUuid getUuids()>,"Returns the supported features (UUIDs) of the remote device. This method does not start a service discovery procedure to retrieve the UUIDs
 from the remote device. Instead the local cached copy of the service
 UUIDs are returned. Use fetchUuidsWithSdp() if fresh UUIDs are desired. Requires Manifest.permission.BLUETOOTH",,ParcelUuid[] the supported features (UUIDs) of the remote device or null on error |||,15,"Represents a remote Bluetooth device. A  BluetoothDevice  lets you
 create a connection with the respective device or query information about
 it such as the name address class and bonding state.

  This class is really just a thin wrapper for a Bluetooth hardware
 address. Objects of this class are immutable. Operations on this class
 are performed on the remote Bluetooth hardware address using the
  BluetoothAdapter  that was used to create this  BluetoothDevice .

  To get a  BluetoothDevice  use
  BluetoothAdapter#getRemoteDevice(String)  to create one representing a device
 of a known MAC address (which you can get through device discovery with
  BluetoothAdapter ) or get one from the set of bonded devices
 returned by  BluetoothAdapter#getBondedDevices() . You can then open a
  BluetoothSocket  for communication with the remote device using
  createRfcommSocketToServiceRecord(java.util.UUID)  over Bluetooth BR/EDR or using
  createL2capChannel(int)  over Bluetooth LE.

  Note: 
 Requires the  Manifest.permission.BLUETOOTH  permission.","Provides classes that manage Bluetooth functionality such as scanning for
 devices connecting with devices and managing data transfer between devices.
 The Bluetooth API supports both ""Classic Bluetooth"" and Bluetooth Low Energy. For more information about Classic Bluetooth see the
  Bluetooth  guide.
 For more information about Bluetooth Low Energy see the
  
 Bluetooth Low Energy  (BLE) guide. The Bluetooth APIs let applications: Scan for other Bluetooth devices (including BLE devices). Query the local Bluetooth adapter for paired Bluetooth devices. Establish RFCOMM channels/sockets. Connect to specified sockets on other devices. Transfer data to and from other devices. Communicate with BLE devices such as proximity sensors heart rate
     monitors fitness devices and so on. Act as a GATT client or a GATT server (BLE). 
 To perform Bluetooth communication using these APIs an application must
 declare the  BLUETOOTH  permission. Some
 additional functionality such as requesting device discovery
 also requires the  BLUETOOTH_ADMIN 
 permission.
  Note: 
 Not all Android-powered devices provide Bluetooth functionality.",,,,,,,
<android.widget.ListView: void addFooterView(View)>,"Add a fixed view to appear at the bottom of the list. If addFooterView is
 called more than once the views will appear in the order they were
 added. Views added using this call can take focus if they want. Note: When first introduced this method could only be called before
 setting the adapter with setAdapter(android.widget.ListAdapter) . Starting with Build.VERSION_CODES.KITKAT this method may be
 called at any time. If the ListView's adapter does not extend HeaderViewListAdapter it will be wrapped with a supporting
 instance of WrapperListAdapter .",v View : The view to add. |||,void,1,"Displays a vertically-scrollable collection of views where each view is positioned
 immediatelybelow the previous view in the list.  For a more modern flexible and performant
 approach to displaying lists use  RecyclerView . To display a list you can include a list view in your layout XML file: <ListView
      android:id=""@+id/list_view""
      android:layout_width=""match_parent""
      android:layout_height=""match_parent"" /> A list view is an  
 adapter view  that does not know the details such as type and contents of the views it
 contains. Instead list view requests views on demand from a  ListAdapter  as needed
 such as to display new views as the user scrolls up or down. In order to display items in the list call  setAdapter(android.widget.ListAdapter) 
 to associate an adapter with the list.  For a simple example see the discussion of filling an
 adapter view with text in the
  
 Layouts  guide. To display a more custom view for each item in your dataset implement a ListAdapter.
 For example extend  BaseAdapter  and create and configure the view for each data item in
  getView(...) : private class MyAdapter extends BaseAdapter {

      // override other abstract methods here

      @Override
      public View getView(int position View convertView ViewGroup container) {
          if (convertView == null) {
              convertView = getLayoutInflater().inflate(R.layout.list_item container false);
          }

          ((TextView) convertView.findViewById(android.R.id.text1))
                  .setText(getItem(position));
          return convertView;
      }
  } ListView attempts to reuse view objects in order to improve performance and
 avoid a lag in response to user scrolls.  To take advantage of this feature check if the
  convertView  provided to  getView(...)  is null before creating or inflating a new
 view object.  See
  
 Making ListView Scrolling Smooth  for more ways to ensure a smooth user experience. To specify an action when a user clicks or taps on a single list item see
  
     Handling click events . To learn how to populate a list view with a CursorAdapter see the discussion of filling an
 adapter view with text in the
  
 Layouts  guide.
 See  
     Using a Loader 
 to learn how to avoid blocking the main thread when using a cursor. Note many examples use  ListActivity 
 or  ListFragment 
 to display a list view. Instead favor the more flexible approach when writing your own app:
 use a more generic Activity subclass or Fragment subclass and add a list view to the layout
 or view hierarchy directly.  This approach gives you more direct control of the
 list view and adapter.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.app.MediaRouteButton: void onDetachedFromWindow()>,"This is called when the view is detached from a window.  At this point it
 no longer has a surface for drawing. If you override this method you must call through to the
 superclass implementation.",,void,16,,"Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.content.res.Resources: ColorStateList getColorStateList(int)>,"This method was deprecated
      in API level 23. Use getColorStateList(int android.content.res.Resources.Theme) instead. Returns a color state list associated with a particular resource ID. The
 resource may contain either a single raw color value or a complex ColorStateList holding multiple possible colors.","id int : The desired resource identifier of a ColorStateList as generated by the aapt tool. This integer encodes the
package type and resource entry. The value 0 is an invalid
identifier. |||","ColorStateList A ColorStateList object containing either a single solid color
         or multiple colors that can be selected based on a state.
 This value cannot be null . |||",1,"Class for accessing an application's resources.  This sits on top of the
 asset manager of the application (accessible through  getAssets() ) and
 provides a high-level API for getting typed data from the assets.

  The Android resource system keeps track of all non-code assets associated with an
 application. You can use this class to access your application's resources. You can generally
 acquire the  Resources  instance associated with your application
 with  getResources() . The Android SDK tools compile your application's resources into the application binary
 at build time.  To use a resource you must install it correctly in the source tree (inside
 your project's  res/  directory) and build your application.  As part of the build
 process the SDK tools generate symbols for each resource which you can use in your application
 code to access the resources. Using application resources makes it easy to update various characteristics of your
 application without modifying code and—by providing sets of alternative
 resources—enables you to optimize your application for a variety of device configurations
 (such as for different languages and screen sizes). This is an important aspect of developing
 Android applications that are compatible on different types of devices. For more information about using resources see the documentation about  Application Resources .","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.webkit.WebView: void resumeTimers()>,"Resumes all layout parsing and JavaScript timers for all WebViews.
 This will resume dispatching all timers.",,void,1,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",,,,,,,
<android.widget.TabWidget: void setDividerDrawable(int)>,Sets the drawable to use as a divider between the tab indicators. Related XML Attributes: android:divider,resId int : the resource identifier of the drawable to use as a divider |||,void,4,"Displays a list of tab labels representing each page in the parent's tab
 collection.
  
 The container object for this widget is  TabHost .
 When the user selects a tab this object sends a message to the parent
 container TabHost to tell it to switch the displayed page. You typically
 won't use many methods directly on this object. The container TabHost is
 used to add labels add the callback handler and manage callbacks. You
 might call this object to iterate the list of tabs or to tweak the layout
 of the tab list but most methods should be called on the containing TabHost
 object.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.location.LocationManager: void clearTestProviderLocation(String)>,"This method was deprecated
      in API level 29. This method has always been a no-op and may be removed in the future. Does nothing.",provider String : This value cannot be null . |||,void,3,"A data class representing a geographic location.

  A location can consist of a latitude longitude timestamp
 and other information such as bearing altitude and velocity.

  All locations generated by the  LocationManager  are
 guaranteed to have a valid latitude longitude and timestamp
 (both UTC time and elapsed real-time since boot) all other
 parameters are optional.","Contains the framework API classes that define Android location-based and
 	related services. This API is not the recommended method for accessing Android location. 
 The
  Google Location Services API 
 part of Google Play services is the preferred way to add location-awareness to
 your app. It offers a simpler API higher accuracy low-power geofencing and
 more. If you are currently using the android.location API you are strongly
 encouraged to switch to the Google Location Services API as soon as
 possible.
  
 To learn more about the Google Location Services API see the
  Location API overview .",,,,,,,
"<android.app.DatePickerDialog: void updateDate(int,int,int)>",Sets the current date.,"year int : the year |||
month int : the month (0-11 for compatibility with Calendar#MONTH ) |||
dayOfMonth int : the day of month (1-31 depending on month) |||",void,1,"A simple dialog containing an  DatePicker .
  
 See the  Pickers 
 guide.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.animation.ValueAnimator: void cancel()>,"Cancels the animation. Unlike end()  cancel() causes the animation to
 stop in its tracks sending an Animator.AnimatorListener.onAnimationCancel(Animator) to
 its listeners followed by an Animator.AnimatorListener.onAnimationEnd(Animator) message. This method must be called on the thread that is running the animation.",,void,11,"This class provides a simple timing engine for running animations
 which calculate animated values and set them on target objects.

  There is a single timing pulse that all animations use. It runs in a
 custom handler to ensure that property changes happen on the UI thread. By default ValueAnimator uses non-linear time interpolation via the
  AccelerateDecelerateInterpolator  class which accelerates into and decelerates
 out of an animation. This behavior can be changed by calling
  ValueAnimator#setInterpolator(TimeInterpolator) . Animators can be created from either code or resource files. Here is an example
 of a ValueAnimator resource file: <animator xmlns:android=""http://schemas.android.com/apk/res/android""
    android:duration=""1000""
    android:valueFrom=""1""
    android:valueTo=""0""
    android:valueType=""floatType""
    android:repeatCount=""1""
    android:repeatMode=""reverse""/> Starting from API 23 it is also possible to use a combination of  PropertyValuesHolder 
 and  Keyframe  resource tags to create a multi-step animation.
 Note that you can specify explicit fractional values (from 0 to 1) for
 each keyframe to determine when in the overall duration the animation should arrive at that
 value. Alternatively you can leave the fractions off and the keyframes will be equally
 distributed within the total duration: <animator xmlns:android=""http://schemas.android.com/apk/res/android""
          android:duration=""1000""
          android:repeatCount=""1""
          android:repeatMode=""reverse"">
    <propertyValuesHolder>
        <keyframe android:fraction=""0"" android:value=""1""/>
        <keyframe android:fraction="".2"" android:value="".4""/>
        <keyframe android:fraction=""1"" android:value=""0""/>
    </propertyValuesHolder>
</animator>","These classes provide functionality for the property animation system which allows you
 to animate object properties of any type.  int   float  and hexadecimal
 color values are supported by default. You can animate any other type by telling the system how
 to calculate the values for that given type with a custom  TypeEvaluator .
  For more information see the
  Animation  guide. 
 You can set many different types of interpolators (contained in  android.view.animation )
 specify  keyframes  or group animations to play sequentially
 or simultaneously (with  AnimatorSet ) to further control your animation
 behaviors.",,,,,,,
<android.view.accessibility.AccessibilityManager: List getAccessibilityServiceList()>,"This method was deprecated
      in API level 15. Use getInstalledAccessibilityServiceList() Returns the ServiceInfo s of the installed accessibility services.",,List < ServiceInfo > An unmodifiable list with ServiceInfo s. |||,4,"System level service that serves as an event dispatch for  AccessibilityEvent s
 and provides facilities for querying the accessibility state of the system.
 Accessibility events are generated when something notable happens in the user interface
 for example an  Activity  starts the focus or selection of a
  View  changes etc. Parties interested in handling accessibility
 events implement and register an accessibility service which extends
  AccessibilityService .",,,,,,,,
"<android.widget.SimpleCursorAdapter: void bindView(View,Context,Cursor)>","Binds all of the field names passed into the ""to"" parameter of the
 constructor with their corresponding cursor columns as specified in the
 ""from"" parameter.

 Binding occurs in two phases. First if a SimpleCursorAdapter.ViewBinder is available ViewBinder#setViewValue(android.view.View android.database.Cursor int) is invoked. If the returned value is true binding has occured. If the
 returned value is false and the view to bind is a TextView setViewText(android.widget.TextView java.lang.String) is invoked. If the returned value is
 false and the view to bind is an ImageView setViewImage(android.widget.ImageView java.lang.String) is invoked. If no appropriate
 binding can be found an IllegalStateException is thrown.","view View : Existing view returned earlier by newView |||
context Context : Interface to application's global information |||
cursor Cursor : The cursor from which to get the data. The cursor is already
moved to the correct position. |||",void,1,"An easy adapter to map columns from a cursor to TextViews or ImageViews
 defined in an XML file. You can specify which columns you want which
 views you want to display the columns and the XML file that defines
 the appearance of these views.

 Binding occurs in two phases. First if a
  SimpleCursorAdapter.ViewBinder  is available
  ViewBinder#setViewValue(android.view.View android.database.Cursor int) 
 is invoked. If the returned value is true binding has occured. If the
 returned value is false and the view to bind is a TextView
  setViewText(android.widget.TextView java.lang.String)  is invoked. If the returned value
 is false and the view to bind is an ImageView
  setViewImage(android.widget.ImageView java.lang.String)  is invoked. If no appropriate
 binding can be found an  IllegalStateException  is thrown.

 If this adapter is used with filtering for instance in an
  AutoCompleteTextView  you can use the
  SimpleCursorAdapter.CursorToStringConverter  and the
  FilterQueryProvider  interfaces
 to get control over the filtering process. You can refer to
  convertToString(android.database.Cursor)  and
  CursorAdapter.runQueryOnBackgroundThread(java.lang.CharSequence)  for more information.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
"<android.speech.tts.TextToSpeech: int synthesizeToFile(String,HashMap,String)>","This method was deprecated
      in API level 21. As of API level 21 replaced by synthesizeToFile(java.lang.CharSequence android.os.Bundle java.io.File java.lang.String) . Synthesizes the given text to a file using the specified parameters.
 This method is asynchronous i.e. the method just adds the request to the queue of TTS
 requests and then returns. The synthesis might not have finished (or even started!) at the
 time when this method returns. In order to reliably detect errors during synthesis
 we recommend setting an utterance progress listener (see setOnUtteranceProgressListener(UtteranceProgressListener) ) and using the Engine#KEY_PARAM_UTTERANCE_ID parameter.","text String : The text that should be synthesized. No longer than getMaxSpeechInputLength() characters. |||
params HashMap : Parameters for the request. Cannot be null.
Supported parameter names: Engine#KEY_PARAM_UTTERANCE_ID .
Engine specific parameters may be passed in but the parameter keys
must be prefixed by the name of the engine they are intended for. For example
the keys ""com.svox.pico_foo"" and ""com.svox.pico:bar"" will be passed to the
engine named ""com.svox.pico"" if it is being used. |||
filename String : Absolute file filename to write the generated audio data to.It should be
something like ""/sdcard/myappsounds/mysound.wav"". |||",int ERROR or SUCCESS of queuing the synthesizeToFile operation. |||,4,"Synthesizes speech from text for immediate playback or to create a sound file.
  A TextToSpeech instance can only be used to synthesize text once it has completed its
 initialization. Implement the  TextToSpeech.OnInitListener  to be
 notified of the completion of the initialization. 
 When you are done using the TextToSpeech instance call the  shutdown()  method
 to release the native resources used by the TextToSpeech engine.",,,,,,,,
<android.telephony.gsm.SmsMessage: SmsMessage createFromPdu(byte)>,"This method was deprecated
      in API level 4. Use android.telephony.SmsMessage. Create an SmsMessage from a raw PDU.",pdu byte |||,SmsMessage |||,1,A Short Message Service message.,,,,,,,,
"<android.app.Instrumentation: void callActivityOnRestoreInstanceState(Activity,Bundle)>",Perform calling of an activity's Activity#onRestoreInstanceState method.  The default implementation simply calls through to that method.,"activity Activity : The activity being restored.
This value cannot be null . |||
savedInstanceState Bundle : The previously saved state being restored.
This value cannot be null . |||",void,1,"Base class for implementing application instrumentation code.  When running
 with instrumentation turned on this class will be instantiated for you
 before any of the application code allowing you to monitor all of the
 interaction the system has with the application.  An Instrumentation
 implementation is described to the system through an AndroidManifest.xml's
 <instrumentation> tag.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.content.ContentResolver: ContentProviderClient acquireContentProviderClient(Uri)>,"Returns a ContentProviderClient that is associated with the ContentProvider that services the content at uri starting the provider if necessary. Returns
 null if there is no provider associated wih the uri. The caller must indicate that they are
 done with the provider by calling ContentProviderClient#release which will allow
 the system to release the provider if it determines that there is no other reason for
 keeping it active.","uri Uri : specifies which provider should be acquired
This value cannot be null . |||",ContentProviderClient a ContentProviderClient that is associated with the ContentProvider that services the content at uri or null if there isn't one. |||,5,This class provides applications access to the content model.,"Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.telephony.TelephonyManager: int getCallState()>,"Returns the state of all calls on the device. This method considers not only calls in the Telephony stack but also calls via other ConnectionService implementations. Note: The call state returned via this method may differ from what is reported by PhoneStateListener#onCallStateChanged(int String) as that callback only considers
 Telephony (mobile) calls.",,"int the current call state.
 
 Value is CALL_STATE_IDLE  CALL_STATE_RINGING or CALL_STATE_OFFHOOK |||",1,"Provides access to information about the telephony services on
 the device. Applications can use the methods in this class to
 determine telephony services and states as well as to access some
 types of subscriber information. Applications can also register
 a listener to receive notification of telephony state changes.
  
 The returned TelephonyManager will use the default subscription for all calls.
 To call an API for a specific subscription use  createForSubscriptionId(int) . e.g.
  
   telephonyManager = defaultSubTelephonyManager.createForSubscriptionId(subId);
  
 Note that access to some telephony information is
 permission-protected. Your application cannot access the protected
 information unless it has the appropriate permissions declared in
 its manifest file. Where permissions apply they are noted in the
 the methods through which you access the protected information.",,,,,,,,
"<android.view.ViewGroup: void requestChildFocus(View,View)>",Called when a child of this parent wants focus,"child View : The child of this ViewParent that wants focus. This view
will contain the focused view. It is not necessarily the view that
actually has focus. |||
focused View : The view that is a descendant of child that actually has
focus |||",void,1,"A  ViewGroup  is a special view that can contain other views
 (called children.) The view group is the base class for layouts and views
 containers. This class also defines the
  ViewGroup.LayoutParams  class which serves as the base
 class for layouts parameters.
  
 Also see  LayoutParams  for layout attributes.",,,,,,,,
<android.nfc.tech.MifareUltralight: void connect()>,"Enable I/O operations to the tag from this TagTechnology object. May cause RF activity and may block. Must not be called
 from the main application thread. A blocked call will be canceled with IOException by calling close() from another thread. Only one TagTechnology object can be connected to a Tag at a time. Applications must call close() when I/O operations are complete. Requires the Manifest.permission.NFC permission.",,void,-1,"Provides access to MIFARE Ultralight properties and I/O operations on a  Tag .

  Acquire a  MifareUltralight  object using  get(Tag) .

  MIFARE Ultralight compatible tags have 4 byte pages  PAGE_SIZE .
 The primary operations on an Ultralight tag are  readPages(int)  and
  writePage(int byte[]) .

  The original MIFARE Ultralight consists of a 64 byte EEPROM. The first
 4 pages are for the OTP area manufacturer data and locking bits. They are
 readable and some bits are writable. The final 12 pages are the user
 read/write area. For more information see the NXP data sheet MF0ICU1.

  The MIFARE Ultralight C consists of a 192 byte EEPROM. The first 4 pages
 are for OTP manufacturer data and locking bits. The next 36 pages are the
 user read/write area. The next 4 pages are additional locking bits counters
 and authentication configuration and are readable. The final 4 pages are for
 the authentication key and are not readable. For more information see the
 NXP data sheet MF0ICU2.

  Implementation of this class on a Android NFC device is optional.
 If it is not implemented then
  MifareUltralight  will never be enumerated in  Tag#getTechList .
 If it is enumerated then all  MifareUltralight  I/O operations will be supported.
 In either case  NfcA  will also be enumerated on the tag
 because all MIFARE Ultralight tags are also  NfcA  tags.

  Note:  Methods that perform I/O operations
 require the  Manifest.permission.NFC  permission.","These classes provide access to a tag technology's features which vary by the type
 of tag that is scanned. A scanned tag can support multiple technologies and you can find
 out what they are by calling  getTechList() . For more information on dealing with tag technologies and handling the ones that you care about see
  The Tag Dispatch System .
 The  TagTechnology  interface provides an overview of the
 supported technologies.",,,,,,,
<android.widget.PopupMenu: void dismiss()>,Dismiss the menu popup.,,void,11,"A PopupMenu displays a  Menu  in a modal popup window anchored to a
  View . The popup will appear below the anchor view if there is room
 or above it if there is not. If the IME is visible the popup will not
 overlap it until it is touched. Touching outside of the popup will dismiss
 it.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.os.Parcel: void writeBundle(Bundle)>,"Flatten a Bundle into the parcel at the current dataPosition()
 growing dataCapacity() if needed.",val Bundle : This value may be null . |||,void,1,"Container for a message (data and object references) that can
 be sent through an IBinder.  A Parcel can contain both flattened data
 that will be unflattened on the other side of the IPC (using the various
 methods here for writing specific types or the general
  Parcelable  interface) and references to live  IBinder 
 objects that will result in the other side receiving a proxy IBinder
 connected with the original IBinder in the Parcel.

  Parcel is  not  a general-purpose
 serialization mechanism.  This class (and the corresponding
  Parcelable  API for placing arbitrary objects into a Parcel) is
 designed as a high-performance IPC transport.  As such it is not
 appropriate to place any Parcel data in to persistent storage: changes
 in the underlying implementation of any of the data in the Parcel can
 render older data unreadable. The bulk of the Parcel API revolves around reading and writing data
 of various types.  There are six major classes of such functions available. Primitives The most basic data functions are for writing and reading primitive
 data types:  writeByte(byte)   readByte()   writeDouble(double) 
  readDouble()   writeFloat(float)   readFloat()   writeInt(int) 
  readInt()   writeLong(long)   readLong() 
  writeString(String)   readString() .  Most other
 data operations are built on top of these.  The given data is written and
 read using the endianess of the host CPU. Primitive Arrays There are a variety of methods for reading and writing raw arrays
 of primitive objects which generally result in writing a 4-byte length
 followed by the primitive data items.  The methods for reading can either
 read the data into an existing array or create and return a new array.
 These available types are: writeBooleanArray(boolean[]) 
  readBooleanArray(boolean[])   createBooleanArray() writeByteArray(byte[]) 
  writeByteArray(byte[] int int)   readByteArray(byte[]) 
  createByteArray() writeCharArray(char[])   readCharArray(char[]) 
  createCharArray() writeDoubleArray(double[])   readDoubleArray(double[]) 
  createDoubleArray() writeFloatArray(float[])   readFloatArray(float[]) 
  createFloatArray() writeIntArray(int[])   readIntArray(int[]) 
  createIntArray() writeLongArray(long[])   readLongArray(long[]) 
  createLongArray() writeStringArray(java.lang.String[])   readStringArray(java.lang.String[]) 
  createStringArray() .
  writeSparseBooleanArray(android.util.SparseBooleanArray) 
  readSparseBooleanArray() .
  Parcelables The  Parcelable  protocol provides an extremely efficient (but
 low-level) protocol for objects to write and read themselves from Parcels.
 You can use the direct methods  writeParcelable(android.os.Parcelable int) 
 and  readParcelable(java.lang.ClassLoader)  or
  writeParcelableArray(T[] int)  and
  readParcelableArray(java.lang.ClassLoader)  to write or read.  These
 methods write both the class type and its data to the Parcel allowing
 that class to be reconstructed from the appropriate class loader when
 later reading. There are also some methods that provide a more efficient way to work
 with Parcelables:  writeTypedObject(T int)   writeTypedArray(T[] int) 
  writeTypedList(List )   readTypedObject(Parcelable.Creator ) 
  createTypedArray(Parcelable.Creator )  and  createTypedArrayList(Parcelable.Creator ) .  These methods
 do not write the class information of the original object: instead the
 caller of the read function must know what type to expect and pass in the
 appropriate  Parcelable.Creator  instead to
 properly construct the new object and read its data.  (To more efficient
 write and read a single Parcelable object that is not null you can directly
 call  Parcelable#writeToParcel  and
  Parcelable.Creator#createFromParcel 
 yourself.) Bundles A special type-safe container called  Bundle  is available
 for key/value maps of heterogeneous values.  This has many optimizations
 for improved performance when reading and writing data and its type-safe
 API avoids difficult to debug type errors when finally marshalling the
 data contents into a Parcel.  The methods to use are
  writeBundle(android.os.Bundle)   readBundle()  and
  readBundle(java.lang.ClassLoader) .

  Active Objects An unusual feature of Parcel is the ability to read and write active
 objects.  For these objects the actual contents of the object is not
 written rather a special token referencing the object is written.  When
 reading the object back from the Parcel you do not get a new instance of
 the object but rather a handle that operates on the exact same object that
 was originally written.  There are two forms of active objects available. Binder  objects are a core facility of Android's general cross-process
 communication system.  The  IBinder  interface describes an abstract
 protocol with a Binder object.  Any such interface can be written in to
 a Parcel and upon reading you will receive either the original object
 implementing that interface or a special proxy implementation
 that communicates calls back to the original object.  The methods to use are
  writeStrongBinder(android.os.IBinder) 
  writeStrongInterface(android.os.IInterface)   readStrongBinder() 
  writeBinderArray(android.os.IBinder[])   readBinderArray(android.os.IBinder[]) 
  createBinderArray() 
  writeBinderList(java.util.List)   readBinderList(java.util.List) 
  createBinderArrayList() . FileDescriptor objects representing raw Linux file descriptor identifiers
 can be written and  ParcelFileDescriptor  objects returned to operate
 on the original file descriptor.  The returned file descriptor is a dup
 of the original file descriptor: the object and fd is different but
 operating on the same underlying file stream with the same position etc.
 The methods to use are  writeFileDescriptor(java.io.FileDescriptor) 
  readFileDescriptor() .

  Untyped Containers A final class of methods are for writing and reading standard Java
 containers of arbitrary types.  These all revolve around the
  writeValue(java.lang.Object)  and  readValue(java.lang.ClassLoader)  methods
 which define the types of objects allowed.  The container methods are
  writeArray(java.lang.Object[])   readArray(java.lang.ClassLoader) 
  writeList(java.util.List)   readList(java.util.List java.lang.ClassLoader) 
  readArrayList(java.lang.ClassLoader) 
  writeMap(java.util.Map)   readMap(java.util.Map java.lang.ClassLoader) 
  writeSparseArray(android.util.SparseArray) 
  readSparseArray(java.lang.ClassLoader) .",,,,,,,,
"<android.content.ContentResolver: Uri insert(Uri,ContentValues)>","Inserts a row into a table at the given URL.

 If the content provider supports transactions the insertion will be atomic.","url Uri : The URL of the table to insert into.
This value cannot be null . |||
values ContentValues : The initial values for the newly inserted row. The key is the column name for
the field. Passing an empty ContentValues will create an empty row.
This value may be null . |||","Uri the URL of the newly created row. May return null if the underlying
         content provider returns null or if it crashes. |||",1,This class provides applications access to the content model.,"Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.app.PendingIntent: int getCreatorUid()>,"Return the uid of the application that created this
 PendingIntent that is the identity under which you will actually be
 sending the Intent.  The returned integer is supplied by the system so
 that an application can not spoof its uid. Be careful about how you use this.  All this tells you is
 who created the PendingIntent.  It does not tell you who
 handed the PendingIntent to you: that is PendingIntent objects are intended to be
 passed between applications so the PendingIntent you receive from an application
 could actually be one it received from another application meaning the result
 you get here will identify the original application.  Because of this you should
 only use this information to identify who you expect to be interacting with
 through a send() call not who gave you the PendingIntent.",,"int The uid of the PendingIntent or -1 if there is
 none associated with it. |||",17,"A description of an Intent and target action to perform with it.  Instances
 of this class are created with  getActivity(Context int Intent int)   getActivities(Context int Intent[] int) 
  getBroadcast(Context int Intent int)  and  getService(Context int Intent int) ; the returned object can be
 handed to other applications so that they can perform the action you
 described on your behalf at a later time.

  By giving a PendingIntent to another application
 you are granting it the right to perform the operation you have specified
 as if the other application was yourself (with the same permissions and
 identity).  As such you should be careful about how you build the PendingIntent:
 almost always for example the base Intent you supply should have the component
 name explicitly set to one of your own components to ensure it is ultimately
 sent there and nowhere else.

  A PendingIntent itself is simply a reference to a token maintained by
 the system describing the original data used to retrieve it.  This means
 that even if its owning application's process is killed the
 PendingIntent itself will remain usable from other processes that
 have been given it.  If the creating application later re-retrieves the
 same kind of PendingIntent (same operation same Intent action data
 categories and components and same flags) it will receive a PendingIntent
 representing the same token if that is still valid and can thus call
  cancel()  to remove it.

  Because of this behavior it is important to know when two Intents
 are considered to be the same for purposes of retrieving a PendingIntent.
 A common mistake people make is to create multiple PendingIntent objects
 with Intents that only vary in their ""extra"" contents expecting to get
 a different PendingIntent each time.  This does  not  happen.  The
 parts of the Intent that are used for matching are the same ones defined
 by  Intent#filterEquals(Intent) .  If you use two
 Intent objects that are equivalent as per
  Intent#filterEquals(Intent)  then you will get
 the same PendingIntent for both of them.

  There are two typical ways to deal with this.

  If you truly need multiple distinct PendingIntent objects active at
 the same time (such as to use as two notifications that are both shown
 at the same time) then you will need to ensure there is something that
 is different about them to associate them with different PendingIntents.
 This may be any of the Intent attributes considered by
  Intent#filterEquals(Intent)  or different
 request code integers supplied to  getActivity(Context int Intent int)   getActivities(Context int Intent[] int) 
  getBroadcast(Context int Intent int)  or  getService(Context int Intent int) .

  If you only need one PendingIntent active at a time for any of the
 Intents you will use then you can alternatively use the flags
  FLAG_CANCEL_CURRENT  or  FLAG_UPDATE_CURRENT  to either
 cancel or modify whatever current PendingIntent is associated with the
 Intent you are supplying.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.view.inputmethod.BaseInputConnection: int getCursorCapsMode(int)>,"The default implementation uses TextUtils.getCapsMode to get the
 cursor caps mode for the current selection position in the editable
 text unless in dummy mode in which case 0 is always returned.","reqModes int : The desired modes to retrieve as defined by TextUtils.getCapsMode . These
constants are defined so that you can simply pass the current EditorInfo#inputType value
directly in to here. |||","int the caps mode flags that are in effect at the current
 cursor position. See TYPE_TEXT_FLAG_CAPS_* in InputType . |||",3,"Base class for implementors of the InputConnection interface taking care
 of most of the common behavior for providing a connection to an Editable.
 Implementors of this class will want to be sure to implement
  getEditable()  to provide access to their own editable object and
 to refer to the documentation in  InputConnection .",,,,,,,,
"<android.text.AutoText: String get(CharSequence,int,int,View)>","Retrieves a possible spelling correction for the specified range
 of text.  Returns null if no correction can be found.
 The View is used to get the current Locale and Resources.","src CharSequence |||
start int |||
end int |||
view View |||",String |||,1,This class accesses a dictionary of corrections to frequent misspellings.,"Provides classes used to render or track text and text spans on the screen. You can use these classes to design your own widgets that manage text
 to handle arbitrary text spans for changes or to handle drawing yourself
 for an existing widget. The Span… interfaces and classes are used to create or manage spans of
 text in a View item. You can use these to style the text or background or to
 listen for changes. If creating your own widget extend DynamicLayout to manages
 the actual wrapping and drawing of your text.",,,,,,,
<android.content.Intent: String getStringExtra(String)>,Retrieve extended data from the intent.,name String : The name of the desired item. |||,"String the value of an item previously added with putExtra()
 or null if no String value was found. |||",1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.widget.SearchView: void setSearchableInfo(SearchableInfo)>,"Sets the SearchableInfo for this SearchView. Properties in the SearchableInfo are used
 to display labels hints suggestions create intents for launching search results screens
 and controlling other affordances such as a voice button.","searchable SearchableInfo : a SearchableInfo can be retrieved from the SearchManager for a specific
activity or a global search provider. |||",void,11,"A widget that provides a user interface for the user to enter a search query and submit a request
 to a search provider. Shows a list of query suggestions or results if available and allows the
 user to pick a suggestion or result to launch into.

  
 When the SearchView is used in an ActionBar as an action view for a collapsible menu item it
 needs to be set to iconified by default using  setIconifiedByDefault(true) . This is the default so nothing needs to be done.
  
 If you want the search field to always be visible then call setIconifiedByDefault(false).","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
"<android.test.TouchUtils: void drag(ActivityInstrumentationTestCase,float,float,float,float,int)>","This method was deprecated
      in API level 15. ActivityInstrumentationTestCase is deprecated in favor of ActivityInstrumentationTestCase2 which provides more options for
 configuring the Activity under test Simulate touching a specific location and dragging to a new location.","test ActivityInstrumentationTestCase : The test case that is being run |||
fromX float : X coordinate of the initial touch in screen coordinates |||
toX float : Xcoordinate of the drag destination in screen coordinates |||
fromY float : X coordinate of the initial touch in screen coordinates |||
toY float : Y coordinate of the drag destination in screen coordinates |||
stepCount int : How many move steps to include in the drag |||",void,1,"Reusable methods for generating touch events. These methods can be used with
 InstrumentationTestCase or ActivityInstrumentationTestCase2 to simulate user interaction with
 the application through a touch screen.",,,,,,,,
"<android.text.method.TextKeyListener: void onSpanChanged(Spannable,Object,int,int,int,int)>","This method is called to notify you that the specified object
 has been relocated from the range ostart…oend to the new range nstart…nend of the text.","s Spannable |||
what Object |||
start int |||
end int |||
st int |||
en int |||",void,1,"This is the key listener for typing normal text.  It delegates to
 other key listeners appropriate to the current keyboard and language.
  KeyListener","Provides classes that monitor or modify keypad input. You can use these classes to modify the type of keypad entry
 for your application or decipher the keypresses entered for your specific
 entry method. For example: 
 // Set the text to password display style:
 EditText txtView = (EditText)findViewById(R.id.text);
 txtView.setTransformationMethod(PasswordTransformationMethod.getInstance());

 //Set the input style to numbers rather than qwerty keyboard style.
 txtView.setInputMethod(DigitsInputMethod.getInstance());

 // Find out whether the caps lock is on.
 // 0 is no 1 is yes 2 is caps lock on.
 int active = MultiTapInputMethod.getCapsActive(txtView.getText());",,,,,,,
<android.app.Instrumentation: void sendStringSync(String)>,"Sends the key events corresponding to the text to the app being
 instrumented.",text String : The text to be sent. |||,void,1,"Base class for implementing application instrumentation code.  When running
 with instrumentation turned on this class will be instantiated for you
 before any of the application code allowing you to monitor all of the
 interaction the system has with the application.  An Instrumentation
 implementation is described to the system through an AndroidManifest.xml's
 <instrumentation> tag.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.view.Display: int getRotation()>,"Returns the rotation of the screen from its ""natural"" orientation.
 The returned value may be Surface#ROTATION_0 (no rotation) Surface#ROTATION_90  Surface#ROTATION_180 or Surface#ROTATION_270 .  For
 example if a device has a naturally tall screen and the user has
 turned it on its side to go into a landscape orientation the value
 returned here may be either Surface#ROTATION_90 or Surface#ROTATION_270 depending on
 the direction it was turned.  The angle is the rotation of the drawn
 graphics on the screen which is the opposite direction of the physical
 rotation of the device.  For example if the device is rotated 90
 degrees counter-clockwise to compensate rendering will be rotated by
 90 degrees clockwise and thus the returned value here will be Surface#ROTATION_90 .",,int Value is Surface.ROTATION_0  Surface.ROTATION_90  Surface.ROTATION_180 or Surface.ROTATION_270 |||,8,"Provides information about the size and density of a logical display.
  
 The display area is described in two different ways.
  The application display area specifies the part of the display that may contain
 an application window excluding the system decorations.  The application display area may
 be smaller than the real display area because the system subtracts the space needed
 for decor elements such as the status bar.  Use the following methods to query the
 application display area:  getSize(Point)   getRectSize(Rect)  and  getMetrics(DisplayMetrics) . The real display area specifies the part of the display that contains content
 including the system decorations.  Even so the real display area may be smaller than the
 physical size of the display if the window manager is emulating a smaller display
 using (adb shell wm size).  Use the following methods to query the
 real display area:  getRealSize(Point)   getRealMetrics(DisplayMetrics) . 
 A logical display does not necessarily represent a particular physical display device
 such as the built-in screen or an external monitor.  The contents of a logical
 display may be presented on one or more physical displays according to the devices
 that are currently attached and whether mirroring has been enabled.",,,,,,,,
"<android.app.Dialog: void setFeatureDrawableResource(int,int)>",Convenience for calling Window.setFeatureDrawableResource(int int) .,"featureId int |||
resId int |||",void,1,"Base class for Dialogs.

  Note: Activities provide a facility to manage the creation saving and
 restoring of dialogs. See  Activity#onCreateDialog(int) 
  Activity#onPrepareDialog(int Dialog) 
  Activity#showDialog(int)  and  Activity#dismissDialog(int) . If
 these methods are used  getOwnerActivity()  will return the Activity
 that managed this dialog.

  Often you will want to have a Dialog display on top of the current
 input method because there is no reason for it to accept text.  You can
 do this by setting the  WindowManager.LayoutParams#FLAG_ALT_FOCUSABLE_IM  window flag (assuming
 your Dialog takes input focus as it the default) with the following code:

  
 getWindow().setFlags(WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM
         WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.accounts.AccountAuthenticatorResponse: void onRequestContinued()>,,,void,5,Object used to communicate responses back to the AccountManager,,,,,,,,
"<android.app.PendingIntent: PendingIntent getService(Context,int,Intent,int)>","Retrieve a PendingIntent that will start a service like calling Context#startService .  The start
 arguments given to the service will come from the extras of the Intent. For security reasons the Intent you supply here should almost always be an explicit intent that is specify an explicit component to be delivered to through Intent#setClass(android.content.Context Class)","context Context : The Context in which this PendingIntent should start
the service. |||
requestCode int : Private request code for the sender |||
intent Intent : An Intent describing the service to be started.
This value cannot be null . |||
flags int : May be FLAG_ONE_SHOT  FLAG_NO_CREATE  FLAG_CANCEL_CURRENT  FLAG_UPDATE_CURRENT  FLAG_IMMUTABLE or any of the flags as supported by Intent#fillIn to control which unspecified parts
of the intent that can be supplied when the actual send happens.
Value is either 0 or a combination of FLAG_ONE_SHOT  FLAG_NO_CREATE  FLAG_CANCEL_CURRENT  FLAG_UPDATE_CURRENT  FLAG_IMMUTABLE  Intent.FILL_IN_ACTION  Intent.FILL_IN_DATA  Intent.FILL_IN_CATEGORIES  Intent.FILL_IN_COMPONENT  Intent.FILL_IN_PACKAGE  Intent.FILL_IN_SOURCE_BOUNDS  Intent.FILL_IN_SELECTOR and Intent.FILL_IN_CLIP_DATA |||","PendingIntent Returns an existing or new PendingIntent matching the given
 parameters.  May return null only if FLAG_NO_CREATE has been
 supplied. |||",1,"A description of an Intent and target action to perform with it.  Instances
 of this class are created with  getActivity(Context int Intent int)   getActivities(Context int Intent[] int) 
  getBroadcast(Context int Intent int)  and  getService(Context int Intent int) ; the returned object can be
 handed to other applications so that they can perform the action you
 described on your behalf at a later time.

  By giving a PendingIntent to another application
 you are granting it the right to perform the operation you have specified
 as if the other application was yourself (with the same permissions and
 identity).  As such you should be careful about how you build the PendingIntent:
 almost always for example the base Intent you supply should have the component
 name explicitly set to one of your own components to ensure it is ultimately
 sent there and nowhere else.

  A PendingIntent itself is simply a reference to a token maintained by
 the system describing the original data used to retrieve it.  This means
 that even if its owning application's process is killed the
 PendingIntent itself will remain usable from other processes that
 have been given it.  If the creating application later re-retrieves the
 same kind of PendingIntent (same operation same Intent action data
 categories and components and same flags) it will receive a PendingIntent
 representing the same token if that is still valid and can thus call
  cancel()  to remove it.

  Because of this behavior it is important to know when two Intents
 are considered to be the same for purposes of retrieving a PendingIntent.
 A common mistake people make is to create multiple PendingIntent objects
 with Intents that only vary in their ""extra"" contents expecting to get
 a different PendingIntent each time.  This does  not  happen.  The
 parts of the Intent that are used for matching are the same ones defined
 by  Intent#filterEquals(Intent) .  If you use two
 Intent objects that are equivalent as per
  Intent#filterEquals(Intent)  then you will get
 the same PendingIntent for both of them.

  There are two typical ways to deal with this.

  If you truly need multiple distinct PendingIntent objects active at
 the same time (such as to use as two notifications that are both shown
 at the same time) then you will need to ensure there is something that
 is different about them to associate them with different PendingIntents.
 This may be any of the Intent attributes considered by
  Intent#filterEquals(Intent)  or different
 request code integers supplied to  getActivity(Context int Intent int)   getActivities(Context int Intent[] int) 
  getBroadcast(Context int Intent int)  or  getService(Context int Intent int) .

  If you only need one PendingIntent active at a time for any of the
 Intents you will use then you can alternatively use the flags
  FLAG_CANCEL_CURRENT  or  FLAG_UPDATE_CURRENT  to either
 cancel or modify whatever current PendingIntent is associated with the
 Intent you are supplying.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.telephony.TelephonyManager: int getPhoneType()>,"Returns a constant indicating the device phone type.  This
 indicates the type of radio used to transmit voice calls.",,int |||,1,"Provides access to information about the telephony services on
 the device. Applications can use the methods in this class to
 determine telephony services and states as well as to access some
 types of subscriber information. Applications can also register
 a listener to receive notification of telephony state changes.
  
 The returned TelephonyManager will use the default subscription for all calls.
 To call an API for a specific subscription use  createForSubscriptionId(int) . e.g.
  
   telephonyManager = defaultSubTelephonyManager.createForSubscriptionId(subId);
  
 Note that access to some telephony information is
 permission-protected. Your application cannot access the protected
 information unless it has the appropriate permissions declared in
 its manifest file. Where permissions apply they are noted in the
 the methods through which you access the protected information.",,,,,,,,
<android.webkit.WebView: void clearHistory()>,Tells this WebView to clear its internal back/forward list.,,void,1,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",,,,,,,
<android.app.WallpaperManager: void clearWallpaperOffsets(IBinder)>,"Clear the offsets previously associated with this window through setWallpaperOffsets(android.os.IBinder float float) .  This reverts
 the window to its default state where it does not cause the wallpaper
 to scroll from whatever its last offsets were.","windowToken IBinder : The window who these offsets should be associated
with as returned by View.getWindowToken() . |||",void,5,"Provides access to the system wallpaper. With WallpaperManager you can
 get the current wallpaper get the desired dimensions for the wallpaper set
 the wallpaper and more.

   An app can check whether wallpapers are supported for the current user by calling
  isWallpaperSupported()  and whether setting of wallpapers is allowed by calling
  isSetWallpaperAllowed() .","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.widget.Spinner: void setPromptId(int)>,Sets the prompt to display when the dialog is shown.,promptId int : the resource ID of the prompt to display when the dialog is shown |||,void,1,"A view that displays one child at a time and lets the user pick among them.
 The items in the Spinner come from the  Adapter  associated with
 this view.

  See the  Spinners  guide.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
"<android.location.Address: void writeToParcel(Parcel,int)>",Flatten this object in to a Parcel.,"parcel Parcel : The Parcel in which the object should be written. |||
flags int : Additional flags about how the object should be written.
May be 0 or Parcelable.PARCELABLE_WRITE_RETURN_VALUE .
Value is either 0 or a combination of Parcelable.PARCELABLE_WRITE_RETURN_VALUE and android.os.Parcelable.PARCELABLE_ELIDE_DUPLICATES |||",void,1,"A class representing an Address i.e a set of Strings describing a location.

 The address format is a simplified version of xAL (eXtensible Address Language)
 http://www.oasis-open.org/committees/ciq/ciq.html#6","Contains the framework API classes that define Android location-based and
 	related services. This API is not the recommended method for accessing Android location. 
 The
  Google Location Services API 
 part of Google Play services is the preferred way to add location-awareness to
 your app. It offers a simpler API higher accuracy low-power geofencing and
 more. If you are currently using the android.location API you are strongly
 encouraged to switch to the Google Location Services API as soon as
 possible.
  
 To learn more about the Google Location Services API see the
  Location API overview .",,,,,,,
<android.webkit.WebView: InputConnection onCreateInputConnection(EditorInfo)>,"Creates a new InputConnection for an InputMethod to interact with the WebView.
 This is similar to View#onCreateInputConnection but note that WebView
 calls InputConnection methods on a thread other than the UI thread.
 If these methods are overridden then the overriding methods should respect
 thread restrictions when calling View methods or accessing data.",outAttrs EditorInfo : Fill in with attribute information about the connection. |||,InputConnection |||,3,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",,,,,,,
"<android.widget.AbsListView: void smoothScrollToPosition(int,int)>","Smoothly scroll to the specified adapter position. The view will
 scroll such that the indicated position is displayed but it will
 stop early if scrolling further would scroll boundPosition out of
 view.","position int : Scroll to this adapter position. |||
boundPosition int : Do not scroll if it would move this adapter
position out of view. |||",void,8,"Base class that can be used to implement virtualized lists of items. A list does
 not have a spatial definition here. For instance subclasses of this class can
 display the content of the list in a grid in a carousel as stack etc.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
"<android.webkit.WebView: void loadData(String,String,String)>","Loads the given data into this WebView using a 'data' scheme URL. Note that JavaScript's same origin policy means that script running in a
 page loaded using this method will be unable to access content loaded
 using any scheme other than 'data' including 'http(s)'. To avoid this
 restriction use loadDataWithBaseURL() with an appropriate base URL. The encoding parameter specifies whether the data is base64 or URL
 encoded. If the data is base64 encoded the value of the encoding
 parameter must be ""base64"" . HTML can be encoded with Base64.encodeToString(byte[] int) like so: For all other values of encoding (including null ) it is assumed that the
 data uses ASCII encoding for octets inside the range of safe URL characters and use the
 standard %xx hex encoding of URLs for octets outside that range. See RFC 3986 for more information.
 Applications targeting Build.VERSION_CODES.Q or later must either use
 base64 or encode any # characters in the content as %23 otherwise they
 will be treated as the end of the content and the remaining text used as a document
 fragment identifier. The mimeType parameter specifies the format of the data.
 If WebView can't handle the specified MIME type it will download the data.
 If null defaults to 'text/html'. The 'data' scheme URL formed by this method uses the default US-ASCII
 charset. If you need to set a different charset you should form a
 'data' scheme URL which explicitly specifies a charset parameter in the
 mediatype portion of the URL and call loadUrl(java.lang.String) instead.
 Note that the charset obtained from the mediatype portion of a data URL
 always overrides that specified in the HTML or XML document itself. Content loaded using this method will have a window.origin value
 of ""null"" . This must not be considered to be a trusted origin
 by the application or by any JavaScript code running inside the WebView
 (for example event sources in DOM event handlers or web messages)
 because malicious content can also create frames with a null origin. If
 you need to identify the main frame's origin in a trustworthy way you
 should use loadDataWithBaseURL() with a valid HTTP or HTTPS base URL to set the
 origin.","data String : a String of data in the given encoding
This value cannot be null . |||
mimeType String : the MIME type of the data e.g. 'text/html'.
This value may be null . |||
encoding String : the encoding of the data
This value may be null . |||",void,1,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",,,,,,,
<android.view.ViewPropertyAnimator: ViewPropertyAnimator rotationYBy(float)>,"This method will cause the View's rotationY property to be animated by the
 specified value. Animations already running on the property will be canceled.",value float : The amount to be animated by as an offset from the current value. |||,ViewPropertyAnimator This object allowing calls to methods in this class to be chained. |||,12,"This class enables automatic and optimized animation of select properties on View objects.
 If only one or two properties on a View object are being animated then using an
  ObjectAnimator  is fine; the property setters called by ObjectAnimator
 are well equipped to do the right thing to set the property and invalidate the view
 appropriately. But if several properties are animated simultaneously or if you just want a
 more convenient syntax to animate a specific property then ViewPropertyAnimator might be
 more well-suited to the task.

  This class may provide better performance for several simultaneous animations because
 it will optimize invalidate calls to take place only once for several properties instead of each
 animated property independently causing its own invalidation. Also the syntax of using this
 class could be easier to use because the caller need only tell the View object which
 property to animate and the value to animate either to or by and this class handles the
 details of configuring the underlying Animator class and starting it. This class is not constructed by the caller but rather by the View whose properties
 it will animate. Calls to  View.animate()  will return a reference
 to the appropriate ViewPropertyAnimator object for that View.",,,,,,,,
"<android.util.Log: int wtf(String,Throwable)>","What a Terrible Failure: Report an exception that should never happen.
 Similar to wtf(java.lang.String java.lang.String) with an exception to log.","tag String : Used to identify the source of a log message.
This value may be null . |||
tr Throwable : An exception to log.
This value cannot be null . |||",int |||,8,"API for sending log output.

  Generally you should use the  Log.v()   Log.d() 
  Log.i()   Log.w()  and  Log.e()  methods to write logs.
 You can then  view the logs in logcat .

  The order in terms of verbosity from least to most is
 ERROR WARN INFO DEBUG VERBOSE.  Verbose should never be compiled
 into an application except during development.  Debug logs are compiled
 in but stripped at runtime.  Error warning and info logs are always kept.

  Tip:  A good convention is to declare a  TAG  constant
 in your class:

  private static final String TAG = ""MyActivity""; Tip:  Don't forget that when you make a call like
  Log.v(TAG ""index="" + i);",,,,,,,,
"<android.graphics.drawable.Drawable: Drawable createFromXmlInner(Resources,XmlPullParser,AttributeSet)>","Create from inside an XML document.  Called on a parser positioned at
 a tag in an XML document tries to create a Drawable from that tag.
 Returns null if the tag is not a valid drawable.","r Resources : This value cannot be null . |||
parser XmlPullParser : This value cannot be null . |||
attrs AttributeSet : This value cannot be null . |||",Drawable |||,1,"A Drawable is a general abstraction for ""something that can be drawn.""  Most
 often you will deal with Drawable as the type of resource retrieved for
 drawing things to the screen; the Drawable class provides a generic API for
 dealing with an underlying visual resource that may take a variety of forms.
 Unlike a  View  a Drawable does not have any facility to
 receive events or otherwise interact with the user.

  In addition to simple drawing Drawable provides a number of generic
 mechanisms for its client to interact with what is being drawn:

   The  setBounds(Rect)  method  must  be called to tell the
     Drawable where it is drawn and how large it should be.  All Drawables
     should respect the requested size often simply by scaling their
     imagery.  A client can find the preferred size for some Drawables with
     the  getIntrinsicHeight()  and  getIntrinsicWidth()  methods.

       The  getPadding(Rect)  method can return from some Drawables
     information about how to frame content that is placed inside of them.
     For example a Drawable that is intended to be the frame for a button
     widget would need to return padding that correctly places the label
     inside of itself.

       The  setState(int[])  method allows the client to tell the Drawable
     in which state it is to be drawn such as ""focused"" ""selected"" etc.
     Some drawables may modify their imagery based on the selected state.

       The  setLevel(int)  method allows the client to supply a single
     continuous controller that can modify the Drawable is displayed such as
     a battery level or progress level.  Some drawables may modify their
     imagery based on the current level.

       A Drawable can perform animations by calling back to its client
     through the  Callback  interface.  All clients should support this
     interface (via  setCallback(Drawable.Callback) ) so that animations will work.  A
     simple way to do this is through the system facilities such as
      View.setBackground(Drawable)  and
      ImageView .
  Bitmap : the simplest Drawable a PNG or JPEG image.
      Nine Patch : an extension to the PNG format allows it to
     specify information about how to stretch it and place things inside of
     it.
      Vector : a drawable defined in an XML file as a set of points
     lines and curves along with its associated color information. This type
     of drawable can be scaled without loss of display quality.
      Shape : contains simple drawing commands instead of a raw
     bitmap allowing it to resize better in some cases.
      Layers : a compound drawable which draws multiple underlying
     drawables on top of each other.
      States : a compound drawable that selects one of a set of
     drawables based on its state.
      Levels : a compound drawable that selects one of a set of
     drawables based on its level.
      Scale : a compound drawable with a single child drawable
     whose overall size is modified based on the current level.
  Custom drawables 
 All versions of Android allow the Drawable class to be extended and used at
 run time in place of framework-provided drawable classes. Starting in
  API 24  custom drawables classes
 may also be used in XML.
  Note:  Custom drawable classes are only accessible from
 within your application package. Other applications will not be able to load
 them.
  
 At a minimum custom drawable classes must implement the abstract methods on
 Drawable and should override the  Drawable#draw(Canvas)  method to
 draw content.
  
 Custom drawables classes may be used in XML in multiple ways:
  
         Using the fully-qualified class name as the XML element name. For
         this method the custom drawable class must be a public top-level
         class.
  
 <com.myapp.MyCustomDrawable xmlns:android=""http://schemas.android.com/apk/res/android""
     android:color=""#ffff0000"" />
  
         Using  drawable  as the XML element name and specifying the
         fully-qualified class name from the  class  attribute. This
         method may be used for both public top-level classes and public
         static inner classes.
  
 <drawable xmlns:android=""http://schemas.android.com/apk/res/android""
     class=""com.myapp.MyTopLevelClass$InnerCustomDrawable""
     android:color=""#ffff0000"" />",,,,,,,,
<android.app.DownloadManager: Long getRecommendedMaxBytesOverMobile(Context)>,"Returns recommended maximum size in bytes of downloads that may go over a mobile
 connection; or null if there's no recommended limit.  The user will have the option to bypass
 this limit.",context Context : the Context to use for accessing the ContentResolver |||,"Long recommended maximum size in bytes of downloads that may go over a mobile
 connection; or null if there's no recommended limit. |||",11,"The download manager is a system service that handles long-running HTTP downloads. Clients may
 request that a URI be downloaded to a particular destination file. The download manager will
 conduct the download in the background taking care of HTTP interactions and retrying downloads
 after failures or across connectivity changes and system reboots.
  
 Apps that request downloads through this API should register a broadcast receiver for
  ACTION_NOTIFICATION_CLICKED  to appropriately handle when the user clicks on a running
 download in a notification or from the downloads UI.
  
 Note that the application must have the  Manifest.permission.INTERNET 
 permission to use this class.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.media.AudioManager: int getRingerMode()>,Returns the current ringtone mode.,,int The current ringtone mode one of RINGER_MODE_NORMAL  RINGER_MODE_SILENT or RINGER_MODE_VIBRATE . |||,1,AudioManager provides access to volume and ringer mode control.,"The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",,,,,,,
"<android.security.KeyChain: X509Certificate getCertificateChain(Context,String)>","Returns the X509Certificate chain for the requested alias or null if the alias
 does not exist or the caller has no permission to access it (see note on exceptions
 in getPrivateKey(Context String) ). Note: If a certificate chain was explicitly specified when the alias was
 installed this method will return that chain. If only the client certificate was specified
 at the installation time this method will try to build a certificate chain using all
 available trust anchors (preinstalled and user-added). This method may block while waiting for a connection to another process and must never
 be called from the main thread. As Activity and Service contexts are short-lived and can be destroyed
 at any time from the main thread it is safer to rely on a long-lived context such as one
 returned from Context#getApplicationContext() . In case the caller specifies an alias for which it lacks a grant it must call choosePrivateKeyAlias(Activity KeyChainAliasCallback String[] Principal[] Uri String) again. See getPrivateKey(Context String) for more details on
 coping with this scenario. This method may take several seconds to complete so it should
 only be called from a worker thread.","context Context : This value cannot be null . |||
alias String : The alias of the desired certificate chain typically
returned via KeyChainAliasCallback#alias .
This value cannot be null . |||",X509Certificate[] |||,14,"The  KeyChain  class provides access to private keys and
 their corresponding certificate chains in credential storage.

  Applications accessing the  KeyChain  normally go through
 these steps:

  Receive a callback from an  X509KeyManager  that a private key is requested.

  Call  choosePrivateKeyAlias  to allow the user to select from a
 list of currently available private keys and corresponding
 certificate chains. The chosen alias will be returned by the
 callback  KeyChainAliasCallback#alias  or null if no private
 key is available or the user cancels the request.

  Call  getPrivateKey(Context String)  and  getCertificateChain(Context String)  to
 retrieve the credentials to return to the corresponding  X509KeyManager  callbacks.

  An application may remember the value of a selected alias to
 avoid prompting the user with  choosePrivateKeyAlias  on subsequent connections. If the alias is
 no longer valid null will be returned on lookups using that value

  An application can request the installation of private keys and
 certificates via the  Intent  provided by  createInstallIntent() . Private keys installed via this  Intent  will be accessible via  choosePrivateKeyAlias(Activity KeyChainAliasCallback String[] Principal[] Uri String)  while
 Certificate Authority (CA) certificates will be trusted by all
 applications through the default  X509TrustManager .","Provides access to a few facilities of the Android security
     subsystems.",,,,,,,
"<android.text.SpannableString: void setSpan(Object,int,int,int)>","Attach the specified markup object to the range start…end of the text or move the object to that range if it was already
 attached elsewhere.  See Spanned for an explanation of
 what the flags mean.  The object can be one that has meaning only
 within your application or it can be one that the text system will
 use to affect text display or behavior.  Some noteworthy ones are
 the subclasses of CharacterStyle and ParagraphStyle and TextWatcher and SpanWatcher .","what Object |||
start int |||
end int |||
flags int |||",void,1,"This is the class for text whose content is immutable but to which
 markup objects can be attached and detached.
 For mutable text see  SpannableStringBuilder .","Provides classes used to render or track text and text spans on the screen. You can use these classes to design your own widgets that manage text
 to handle arbitrary text spans for changes or to handle drawing yourself
 for an existing widget. The Span… interfaces and classes are used to create or manage spans of
 text in a View item. You can use these to style the text or background or to
 listen for changes. If creating your own widget extend DynamicLayout to manages
 the actual wrapping and drawing of your text.",,,,,,,
<android.nfc.tech.NfcA: void setTimeout(int)>,"Set the transceive(byte[]) timeout in milliseconds. The timeout only applies to transceive(byte[]) on this object
 and is reset to a default value when close() is called. Setting a longer timeout may be useful when performing
 transactions that require a long processing time on the tag
 such as key generation. Requires the Manifest.permission.NFC permission.",timeout int : timeout value in milliseconds |||,void,14,"Provides access to NFC-A (ISO 14443-3A) properties and I/O operations on a  Tag .

  Acquire a  NfcA  object using  get(Tag) .
  The primary NFC-A I/O operation is  transceive(byte[]) . Applications must
 implement their own protocol stack on top of  transceive(byte[]) .

  Note:  Methods that perform I/O operations
 require the  Manifest.permission.NFC  permission.","These classes provide access to a tag technology's features which vary by the type
 of tag that is scanned. A scanned tag can support multiple technologies and you can find
 out what they are by calling  getTechList() . For more information on dealing with tag technologies and handling the ones that you care about see
  The Tag Dispatch System .
 The  TagTechnology  interface provides an overview of the
 supported technologies.",,,,,,,
"<android.content.ContextWrapper: int checkUriPermission(Uri,int,int,int)>","Determine whether a particular process and user ID has been granted
 permission to access a specific URI.  This only checks for permissions
 that have been explicitly granted -- if the given process/uid has
 more general access to the URI's content provider then this check will
 always fail.","uri Uri : The uri that is being checked. |||
pid int : The process ID being checked against.  Must be > 0. |||
uid int : The user ID being checked against.  A uid of 0 is the root
user which will pass every permission check. |||
modeFlags int : The access modes to check.
Value is either 0 or a combination of Intent.FLAG_GRANT_READ_URI_PERMISSION and Intent.FLAG_GRANT_WRITE_URI_PERMISSION |||","int PackageManager#PERMISSION_GRANTED if the given
 pid/uid is allowed to access that uri or PackageManager#PERMISSION_DENIED if it is not.

 Value is PackageManager.PERMISSION_GRANTED or PackageManager.PERMISSION_DENIED |||",1,"Proxying implementation of Context that simply delegates all of its calls to
 another Context.  Can be subclassed to modify behavior without changing
 the original Context.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.app.Activity: void dismissDialog(int)>,"This method was deprecated
      in API level 15. Use the new DialogFragment class with FragmentManager instead; this is also
 available on older platforms through the Android compatibility package. Dismiss a dialog that was previously shown via showDialog(int) .",id int : The id of the managed dialog. |||,void,1,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.database.sqlite.SQLiteDatabase: void beginTransactionWithListenerNonExclusive(SQLiteTransactionListener)>,"Begins a transaction in IMMEDIATE mode. Transactions can be nested. When
 the outer transaction is ended all of the work done in that transaction
 and all of the nested transactions will be committed or rolled back. The
 changes will be rolled back if any transaction is ended without being
 marked as clean (by calling setTransactionSuccessful). Otherwise they
 will be committed. Here is the standard idiom for transactions:","transactionListener SQLiteTransactionListener : listener that should be notified when the
transaction begins commits or is rolled back either
explicitly or by a call to yieldIfContendedSafely() . |||",void,11,"Exposes methods to manage a SQLite database.

  
 SQLiteDatabase has methods to create delete execute SQL commands and
 perform other common database management tasks.
  
 See the Notepad sample application in the SDK for an example of creating
 and managing a database.
  
 Database names must be unique within an application not across all applications.
  Localized Collation - ORDER BY 
 In addition to SQLite's default  BINARY  collator Android supplies
 two more  LOCALIZED  which changes with the system's current locale
 and  UNICODE  which is the Unicode Collation Algorithm and not tailored
 to the current locale.","If you need to manage data in a private database use the  android.database.sqlite  classes. These classes are used to manage the  Cursor  object returned from a content provider query. Databases
 are usually created and opened with  openOrCreateDatabase(String int SQLiteDatabase.CursorFactory) 
 To make requests through
 content providers you can use the  content.ContentResolver  class.
  All databases are stored on the device in  /data/data/<package_name>/databases",,,,,,,
<android.app.ListFragment: int getSelectedItemPosition()>,Get the position of the currently selected list item.,,int |||,11,"A fragment that displays a list of items by binding to a data source such as
 an array or Cursor and exposes event handlers when the user selects an item.
  
 ListFragment hosts a  ListView  object that can
 be bound to different data sources typically either an array or a Cursor
 holding query results. Binding screen layout and row layout are discussed
 in the following sections.
  Screen Layout 
 ListFragment has a default layout that consists of a single list view.
 However if you desire you can customize the fragment layout by returning
 your own view hierarchy from  onCreateView(LayoutInflater ViewGroup Bundle) .
 To do this your view hierarchy  must  contain a ListView object with the
 id ""@android:id/list"" (or  R.id.list  if it's in code)
  
 Optionally your view hierarchy can contain another view object of any type to
 display when the list view is empty. This ""empty list"" notifier must have an
 id ""android:empty"". Note that when an empty view is present the list view
 will be hidden when there is no data to display.
  
 The following code demonstrates an (ugly) custom list layout. It has a list
 with a green background and an alternate red ""no data"" message.
  
 <?xml version=""1.0"" encoding=""utf-8""?>
 <LinearLayout xmlns:android=""http://schemas.android.com/apk/res/android""
         android:orientation=""vertical""
         android:layout_width=""match_parent""
         android:layout_height=""match_parent""
         android:paddingLeft=""8dp""
         android:paddingRight=""8dp"">

     <ListView android:id=""@id/android:list""
               android:layout_width=""match_parent""
               android:layout_height=""match_parent""
               android:background=""#00FF00""
               android:layout_weight=""1""
               android:drawSelectorOnTop=""false""/>

     <TextView android:id=""@id/android:empty""
               android:layout_width=""match_parent""
               android:layout_height=""match_parent""
               android:background=""#FF0000""
               android:text=""No data""/>
 </LinearLayout>
  Row Layout 
 You can specify the layout of individual rows in the list. You do this by
 specifying a layout resource in the ListAdapter object hosted by the fragment
 (the ListAdapter binds the ListView to the data; more on this later).
  
 A ListAdapter constructor takes a parameter that specifies a layout resource
 for each row. It also has two additional parameters that let you specify
 which data field to associate with which object in the row layout resource.
 These two parameters are typically parallel arrays.
  
 Android provides some standard row layout resources. These are in the
  R.layout  class and have names such as simple_list_item_1
 simple_list_item_2 and two_line_list_item. The following layout XML is the
 source for the resource two_line_list_item which displays two data
 fieldsone above the other for each list row.
  
 <?xml version=""1.0"" encoding=""utf-8""?>
 <LinearLayout xmlns:android=""http://schemas.android.com/apk/res/android""
     android:layout_width=""match_parent""
     android:layout_height=""wrap_content""
     android:orientation=""vertical"">

     <TextView android:id=""@+id/text1""
         android:textSize=""16sp""
         android:textStyle=""bold""
         android:layout_width=""match_parent""
         android:layout_height=""wrap_content""/>

     <TextView android:id=""@+id/text2""
         android:textSize=""16sp""
         android:layout_width=""match_parent""
         android:layout_height=""wrap_content""/>
 </LinearLayout>
  
 You must identify the data bound to each TextView object in this layout. The
 syntax for this is discussed in the next section.
  Binding to Data 
 You bind the ListFragment's ListView object to data using a class that
 implements the  ListAdapter  interface.
 Android provides two standard list adapters:
  SimpleAdapter  for static data (Maps)
 and  SimpleCursorAdapter  for Cursor
 query results.
  
 You  must  use
  ListFragment.setListAdapter()  to
 associate the list with an adapter.  Do not directly call
  ListView#setAdapter(ListAdapter)  or else
 important initialization will be skipped.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.appwidget.AppWidgetManager: AppWidgetManager getInstance(Context)>,Get the AppWidgetManager instance to use for the supplied Context object.,context Context |||,AppWidgetManager |||,3,"Updates AppWidget state; gets information about installed AppWidget providers and other
 AppWidget related state.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.app.DownloadManager: Long getMaxBytesOverMobile(Context)>,"Returns maximum size in bytes of downloads that may go over a mobile connection; or null if
 there's no limit",context Context : the Context to use for accessing the ContentResolver |||,"Long maximum size in bytes of downloads that may go over a mobile connection; or null if
 there's no limit |||",11,"The download manager is a system service that handles long-running HTTP downloads. Clients may
 request that a URI be downloaded to a particular destination file. The download manager will
 conduct the download in the background taking care of HTTP interactions and retrying downloads
 after failures or across connectivity changes and system reboots.
  
 Apps that request downloads through this API should register a broadcast receiver for
  ACTION_NOTIFICATION_CLICKED  to appropriately handle when the user clicks on a running
 download in a notification or from the downloads UI.
  
 Note that the application must have the  Manifest.permission.INTERNET 
 permission to use this class.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
"<android.graphics.drawable.Drawable: Drawable createFromXml(Resources,XmlPullParser)>","Create a drawable from an XML document. For more information on how to
 create resources in XML see Drawable Resources .","r Resources : This value cannot be null . |||
parser XmlPullParser : This value cannot be null . |||",Drawable This value cannot be null . |||,1,"A Drawable is a general abstraction for ""something that can be drawn.""  Most
 often you will deal with Drawable as the type of resource retrieved for
 drawing things to the screen; the Drawable class provides a generic API for
 dealing with an underlying visual resource that may take a variety of forms.
 Unlike a  View  a Drawable does not have any facility to
 receive events or otherwise interact with the user.

  In addition to simple drawing Drawable provides a number of generic
 mechanisms for its client to interact with what is being drawn:

   The  setBounds(Rect)  method  must  be called to tell the
     Drawable where it is drawn and how large it should be.  All Drawables
     should respect the requested size often simply by scaling their
     imagery.  A client can find the preferred size for some Drawables with
     the  getIntrinsicHeight()  and  getIntrinsicWidth()  methods.

       The  getPadding(Rect)  method can return from some Drawables
     information about how to frame content that is placed inside of them.
     For example a Drawable that is intended to be the frame for a button
     widget would need to return padding that correctly places the label
     inside of itself.

       The  setState(int[])  method allows the client to tell the Drawable
     in which state it is to be drawn such as ""focused"" ""selected"" etc.
     Some drawables may modify their imagery based on the selected state.

       The  setLevel(int)  method allows the client to supply a single
     continuous controller that can modify the Drawable is displayed such as
     a battery level or progress level.  Some drawables may modify their
     imagery based on the current level.

       A Drawable can perform animations by calling back to its client
     through the  Callback  interface.  All clients should support this
     interface (via  setCallback(Drawable.Callback) ) so that animations will work.  A
     simple way to do this is through the system facilities such as
      View.setBackground(Drawable)  and
      ImageView .
  Bitmap : the simplest Drawable a PNG or JPEG image.
      Nine Patch : an extension to the PNG format allows it to
     specify information about how to stretch it and place things inside of
     it.
      Vector : a drawable defined in an XML file as a set of points
     lines and curves along with its associated color information. This type
     of drawable can be scaled without loss of display quality.
      Shape : contains simple drawing commands instead of a raw
     bitmap allowing it to resize better in some cases.
      Layers : a compound drawable which draws multiple underlying
     drawables on top of each other.
      States : a compound drawable that selects one of a set of
     drawables based on its state.
      Levels : a compound drawable that selects one of a set of
     drawables based on its level.
      Scale : a compound drawable with a single child drawable
     whose overall size is modified based on the current level.
  Custom drawables 
 All versions of Android allow the Drawable class to be extended and used at
 run time in place of framework-provided drawable classes. Starting in
  API 24  custom drawables classes
 may also be used in XML.
  Note:  Custom drawable classes are only accessible from
 within your application package. Other applications will not be able to load
 them.
  
 At a minimum custom drawable classes must implement the abstract methods on
 Drawable and should override the  Drawable#draw(Canvas)  method to
 draw content.
  
 Custom drawables classes may be used in XML in multiple ways:
  
         Using the fully-qualified class name as the XML element name. For
         this method the custom drawable class must be a public top-level
         class.
  
 <com.myapp.MyCustomDrawable xmlns:android=""http://schemas.android.com/apk/res/android""
     android:color=""#ffff0000"" />
  
         Using  drawable  as the XML element name and specifying the
         fully-qualified class name from the  class  attribute. This
         method may be used for both public top-level classes and public
         static inner classes.
  
 <drawable xmlns:android=""http://schemas.android.com/apk/res/android""
     class=""com.myapp.MyTopLevelClass$InnerCustomDrawable""
     android:color=""#ffff0000"" />",,,,,,,,
<android.net.wifi.WifiManager: WifiInfo getConnectionInfo()>,"Return dynamic information about the current Wi-Fi connection if any is active. In the connected state access to the SSID and BSSID requires
 the same permissions as getScanResults() . If such access is not allowed WifiInfo#getSSID will return UNKNOWN_SSID and WifiInfo#getBSSID will return ""02:00:00:00:00:00"" . WifiInfo#getPasspointFqdn() will return null. WifiInfo#getPasspointProviderFriendlyName() will return null.",,WifiInfo the Wi-Fi information contained in WifiInfo . |||,1,"This class provides the primary API for managing all aspects of Wi-Fi
 connectivity.
  
 On releases before  Build.VERSION_CODES.N  this object
 should only be obtained from an  Context#getApplicationContext()  and not from any other derived context to avoid memory
 leaks within the calling process.
  
 It deals with several categories of items:
  The list of configured networks. The list can be viewed and updated and
 attributes of individual entries can be modified. The currently active Wi-Fi network if any. Connectivity can be
 established or torn down and dynamic information about the state of the
 network can be queried. Results of access point scans containing enough information to make
 decisions about what access point to connect to. It defines the names of various Intent actions that are broadcast upon
 any sort of change in Wi-Fi state.
  
 This is the API to use when performing Wi-Fi specific operations. To perform
 operations that pertain to network connectivity at an abstract level use
  ConnectivityManager .","Provides classes to manage Wi-Fi functionality on the device. The Wi-Fi APIs provide a means by which applications can communicate
 with the lower-level wireless stack that provides Wi-Fi network access. Almost all
 information from the device supplicant is available including the connected network's
 link speed IP address negotiation state and more plus information about other
 networks that are available. Some other API features include the ability to
 scan add save terminate and initiate Wi-Fi connections. Some APIs may require the following user permissions: ACCESS_WIFI_STATE CHANGE_WIFI_STATE CHANGE_WIFI_MULTICAST_STATE Note:  Not all Android-powered devices provide Wi-Fi functionality.
 If your application uses Wi-Fi declare so with a  <uses-feature> 
 element in the manifest file: 
 <manifest ...>
     <uses-feature android:name=""android.hardware.wifi"" />
     ...
 </manifest>",,,,,,,
<android.app.admin.DevicePolicyManager: int getPasswordQuality(ComponentName)>,"Retrieve the current minimum password quality for a particular admin or all admins that set
 restrictions on this user and its participating profiles. Restrictions on profiles that have
 a separate challenge are not taken into account. This method can be called on the DevicePolicyManager instance
 returned by getParentProfileInstance(android.content.ComponentName) in order to retrieve
 restrictions on the parent profile. Note: on devices not supporting PackageManager#FEATURE_SECURE_LOCK_SCREEN feature
 the password is always treated as empty.","admin ComponentName : The name of the admin component to check or null to aggregate
all admins.
This value may be null . |||",int |||,8,"Public interface for managing policies enforced on a device. Most clients of this class must be
 registered with the system as a  device
 administrator . Additionally a device administrator may be registered as either a profile or
 device owner. A given method is accessible to all device administrators unless the documentation
 for that method specifies that it is restricted to either device or profile owners. Any
 application calling an api may only pass as an argument a device administrator component it
 owns. Otherwise a  SecurityException  will be thrown.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
"<android.view.ViewGroup: void removeViews(int,int)>",Removes the specified range of views from the group. Note: do not invoke this method from View.draw(android.graphics.Canvas)  View.onDraw(android.graphics.Canvas)  dispatchDraw(android.graphics.Canvas) or any related method.,"start int : the first position in the group of the range of views to remove |||
count int : the number of views to remove |||",void,1,"A  ViewGroup  is a special view that can contain other views
 (called children.) The view group is the base class for layouts and views
 containers. This class also defines the
  ViewGroup.LayoutParams  class which serves as the base
 class for layouts parameters.
  
 Also see  LayoutParams  for layout attributes.",,,,,,,,
<android.widget.GridView: void smoothScrollToPosition(int)>,"Smoothly scroll to the specified adapter position. The view will
 scroll such that the indicated position is displayed.",position int : Scroll to this adapter position. |||,void,8,"A view that shows items in two-dimensional scrolling grid. The items in the
 grid come from the  ListAdapter  associated with this view.

  See the  Grid
 View  guide.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.content.ClipboardManager: CharSequence getText()>,"This method is deprecated. Use getPrimaryClip() instead.  This retrieves
 the primary clip and tries to coerce it to a string. Returns the text on the clipboard.  It will eventually be possible
 to store types other than text too in which case this will return
 null if the type cannot be coerced to text.",,CharSequence |||,11,"Interface to the clipboard service for placing and retrieving text in
 the global clipboard.

  
 The ClipboardManager API itself is very simple: it consists of methods
 to atomically get and set the current primary clipboard data.  That data
 is expressed as a  ClipData  object which defines the protocol
 for data exchange between applications.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.bluetooth.BluetoothAdapter: int getProfileConnectionState(int)>,"Get the current connection state of a profile.
 This function can be used to check whether the local Bluetooth adapter
 is connected to any remote device for a specific profile.
 Profile can be one of BluetoothProfile#HEADSET  BluetoothProfile#A2DP . Return value can be one of BluetoothProfile#STATE_DISCONNECTED  BluetoothProfile#STATE_CONNECTING  BluetoothProfile#STATE_CONNECTED  BluetoothProfile#STATE_DISCONNECTING Requires Manifest.permission.BLUETOOTH",profile int |||,int |||,14,"Represents the local device Bluetooth adapter. The  BluetoothAdapter 
 lets you perform fundamental Bluetooth tasks such as initiate
 device discovery query a list of bonded (paired) devices
 instantiate a  BluetoothDevice  using a known MAC address and create
 a  BluetoothServerSocket  to listen for connection requests from other
 devices and start a scan for Bluetooth LE devices.

  To get a  BluetoothAdapter  representing the local Bluetooth
 adapter call the  BluetoothManager#getAdapter  function on  BluetoothManager .
 On JELLY_BEAN_MR1 and below you will need to use the static  getDefaultAdapter() 
 method instead.
  
 Fundamentally this is your starting point for all
 Bluetooth actions. Once you have the local adapter you can get a set of
  BluetoothDevice  objects representing all paired devices with
  getBondedDevices() ; start device discovery with
  startDiscovery() ; or create a  BluetoothServerSocket  to
 listen for incoming RFComm connection requests with  listenUsingRfcommWithServiceRecord(java.lang.String java.util.UUID) ; listen for incoming L2CAP Connection-oriented
 Channels (CoC) connection requests with  listenUsingL2capChannel() ; or start a scan for
 Bluetooth LE devices with  startLeScan(android.bluetooth.BluetoothAdapter.LeScanCallback) .
  This class is thread safe. Note: 
 Most methods require the  Manifest.permission.BLUETOOTH 
 permission and some also require the
  Manifest.permission.BLUETOOTH_ADMIN  permission.","Provides classes that manage Bluetooth functionality such as scanning for
 devices connecting with devices and managing data transfer between devices.
 The Bluetooth API supports both ""Classic Bluetooth"" and Bluetooth Low Energy. For more information about Classic Bluetooth see the
  Bluetooth  guide.
 For more information about Bluetooth Low Energy see the
  
 Bluetooth Low Energy  (BLE) guide. The Bluetooth APIs let applications: Scan for other Bluetooth devices (including BLE devices). Query the local Bluetooth adapter for paired Bluetooth devices. Establish RFCOMM channels/sockets. Connect to specified sockets on other devices. Transfer data to and from other devices. Communicate with BLE devices such as proximity sensors heart rate
     monitors fitness devices and so on. Act as a GATT client or a GATT server (BLE). 
 To perform Bluetooth communication using these APIs an application must
 declare the  BLUETOOTH  permission. Some
 additional functionality such as requesting device discovery
 also requires the  BLUETOOTH_ADMIN 
 permission.
  Note: 
 Not all Android-powered devices provide Bluetooth functionality.",,,,,,,
"<android.media.AudioManager: void adjustStreamVolume(int,int,int)>","Adjusts the volume of a particular stream by one step in a direction. This method should only be used by applications that replace the platform-wide
 management of audio settings or the main telephony application. This method has no effect if the device implements a fixed volume policy
 as indicated by isVolumeFixed() . From N onward ringer mode adjustments that would toggle Do Not Disturb are not allowed
 unless the app has been granted Do Not Disturb Access.
 See NotificationManager#isNotificationPolicyAccessGranted() .","streamType int : The stream type to adjust. One of STREAM_VOICE_CALL  STREAM_SYSTEM  STREAM_RING  STREAM_MUSIC  STREAM_ALARM or STREAM_ACCESSIBILITY . |||
direction int : The direction to adjust the volume. One of ADJUST_LOWER  ADJUST_RAISE or ADJUST_SAME . |||
flags int : One or more flags. |||",void,1,AudioManager provides access to volume and ringer mode control.,"The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",,,,,,,
"<android.preference.PreferenceActivity: void showBreadCrumbs(CharSequence,CharSequence)>","Change the base title of the bread crumbs for the current preferences.
 This will normally be called for you.  See FragmentBreadCrumbs for more information.","title CharSequence |||
shortTitle CharSequence |||",void,11,"This is the base class for an activity to show a hierarchy of preferences
 to the user.  Prior to  Build.VERSION_CODES.HONEYCOMB 
 this class only allowed the display of a single set of preference; this
 functionality should now be found in the new  PreferenceFragment 
 class.  If you are using PreferenceActivity in its old mode the documentation
 there applies to the deprecated APIs here.

  This activity shows one or more headers of preferences each of which
 is associated with a  PreferenceFragment  to display the preferences
 of that header.  The actual layout and display of these associations can
 however vary; currently there are two major approaches it may take:

  On a small screen it may display only the headers as a single list when first launched.
 Selecting one of the header items will only show the PreferenceFragment of that header (on
 Android N and lower a new Activity is launched).
  On a large screen it may display both the headers and current PreferenceFragment together as
 panes. Selecting a header item switches to showing the correct PreferenceFragment for that item.
  Subclasses of PreferenceActivity should implement
  onBuildHeaders(List )  to populate the header list with the desired
 items.  Doing this implicitly switches the class into its new ""headers
 + fragments"" mode rather than the old style of just showing a single
 preferences list.",,,,,,,,
<android.hardware.usb.UsbManager: HashMap getDeviceList()>,"Returns a HashMap containing all USB devices currently attached.
 USB device name is the key for the returned HashMap.
 The result will be empty if no devices are attached or if
 USB host mode is inactive or unsupported. Requires the PackageManager#FEATURE_USB_HOST feature which can be detected using PackageManager.hasSystemFeature(String) .",,HashMap < String  UsbDevice > HashMap containing all connected USB devices. |||,12,"This class allows you to access the state of USB and communicate with USB devices.
 Currently only host mode is supported in the public API.","Provides support to communicate with USB hardware peripherals that are connected to
 Android-powered devices. For more information see the
  USB  guide. Use  UsbManager  to access the state of the USB and to
 communicate with connected hardware peripherals. Use  UsbDevice  to
 communicate with the hardware peripheral if the Android-powered device is acting as the USB host.
 Use  UsbAccessory  if the peripheral is acting as the USB host.",,,,,,,
<android.telephony.gsm.GsmCellLocation: void fillInNotifierBundle(Bundle)>,Set intent notifier Bundle based on service state,m Bundle : intent notifier Bundle |||,void,1,Represents the cell location on a GSM phone.,,,,,,,,
"<android.os.Bundle: void putBundle(String,Bundle)>","Inserts a Bundle value into the mapping of this Bundle replacing
 any existing value for the given key.  Either key or value may be null.","key String : a String or null
This value may be null . |||
value Bundle : a Bundle object or null
This value may be null . |||",void,1,A mapping from String keys to various  Parcelable  values.,,,,,,,,
"<android.text.SpannableStringBuilder: SpannableStringBuilder delete(int,int)>","Convenience for replace(st en """" 0 0)","start int |||
end int |||",SpannableStringBuilder |||,1,"This is the class for text whose content is immutable but to which
 markup objects can be attached and detached.
 For mutable text see  SpannableStringBuilder .","Provides classes used to render or track text and text spans on the screen. You can use these classes to design your own widgets that manage text
 to handle arbitrary text spans for changes or to handle drawing yourself
 for an existing widget. The Span… interfaces and classes are used to create or manage spans of
 text in a View item. You can use these to style the text or background or to
 listen for changes. If creating your own widget extend DynamicLayout to manages
 the actual wrapping and drawing of your text.",,,,,,,
<android.hardware.display.DisplayManager: Display getDisplays(String)>,"Gets all currently valid logical displays of the specified category. When there are multiple displays in a category the returned displays are sorted
 of preference.  For example if the requested category is DISPLAY_CATEGORY_PRESENTATION and there are multiple presentation displays
 then the displays are sorted so that the first display in the returned array
 is the most preferred presentation display.  The application may simply
 use the first display or allow the user to choose.",category String : The requested display category or null to return all displays. |||,Display[] An array containing all displays sorted by order of preference. |||,17,Manages the properties of attached displays.,,,,,,,,
<android.inputmethodservice.InputMethodService: void updateFullscreenMode()>,"Re-evaluate whether the input method should be running in fullscreen
 mode and update its UI if this has changed since the last time it
 was evaluated.  This will call onEvaluateFullscreenMode() to
 determine whether it should currently run in fullscreen mode.  You
 can use isFullscreenMode() to determine if the input method
 is currently running in fullscreen mode.",,void,3,"InputMethodService provides a standard implementation of an InputMethod
 which final implementations can derive from and customize.  See the
 base class  AbstractInputMethodService  and the  InputMethod 
 interface for more information on the basics of writing input methods.

  In addition to the normal Service lifecycle methods this class
 introduces some new specific callbacks that most subclasses will want
 to make use of: onInitializeInterface()  for user-interface initialization
 in particular to deal with configuration changes while the service is
 running.
  onBindInput()  to find out about switching to a new client.
  onStartInput(EditorInfo boolean)  to deal with an input session starting with
 the client.
  onCreateInputView()   onCreateCandidatesView() 
 and  onCreateExtractTextView()  for non-demand generation of the UI.
  onStartInputView(android.view.inputmethod.EditorInfo boolean)  to deal with input
 starting within the input area of the IME.
  An input method has significant discretion in how it goes about its
 work: the  InputMethodService  provides
 a basic framework for standard UI elements (input view candidates view
 and running in fullscreen mode) but it is up to a particular implementor
 to decide how to use them.  For example one input method could implement
 an input area with a keyboard another could allow the user to draw text
 while a third could have no input area (and thus not be visible to the
 user) but instead listen to audio and perform text to speech conversion. In the implementation provided here all of these elements are placed
 together in a single window managed by the InputMethodService.  It will
 execute callbacks as it needs information about them and provides APIs for
 programmatic control over them.  They layout of these elements is explicitly
 defined: The soft input view if available is placed at the bottom of the
 screen.
  The candidates view if currently shown is placed above the soft
 input view.
  If not running fullscreen the application is moved or resized to be
 above these views; if running fullscreen the window will completely cover
 the application and its top part will contain the extract text of what is
 currently being edited by the application.
  Soft Input View Central to most input methods is the soft input view.  This is where most
 user interaction occurs: pressing on soft keys drawing characters or
 however else your input method wants to generate text.  Most implementations
 will simply have their own view doing all of this work and return a new
 instance of it when  onCreateInputView()  is called.  At that point
 as long as the input view is visible you will see user interaction in
 that view and can call back on the InputMethodService to interact with the
 application as appropriate. There are some situations where you want to decide whether or not your
 soft input view should be shown to the user.  This is done by implementing
 the  onEvaluateInputViewShown()  to return true or false based on
 whether it should be shown in the current environment.  If any of your
 state has changed that may impact this call
  updateInputViewShown()  to have it re-evaluated.  The default
 implementation always shows the input view unless there is a hard
 keyboard available which is the appropriate behavior for most input
 methods. Candidates View Often while the user is generating raw text an input method wants to
 provide them with a list of possible interpretations of that text that can
 be selected for use.  This is accomplished with the candidates view and
 like the soft input view you implement  onCreateCandidatesView() 
 to instantiate your own view implementing your candidates UI. Management of the candidates view is a little different than the input
 view because the candidates view tends to be more transient being shown
 only when there are possible candidates for the current text being entered
 by the user.  To control whether the candidates view is shown you use
  setCandidatesViewShown(boolean) .  Note that because the candidate
 view tends to be shown and hidden a lot it does not impact the application
 UI in the same way as the soft input view: it will never cause application
 windows to resize only cause them to be panned if needed for the user to
 see the current focus. Fullscreen Mode Sometimes your input method UI is too large to integrate with the
 application UI so you just want to take over the screen.  This is
 accomplished by switching to full-screen mode causing the input method
 window to fill the entire screen and add its own ""extracted text"" editor
 showing the user the text that is being typed.  Unlike the other UI elements
 there is a standard implementation for the extract editor that you should
 not need to change.  The editor is placed at the top of the IME above the
 input and candidates views. Similar to the input view you control whether the IME is running in
 fullscreen mode by implementing  onEvaluateFullscreenMode() 
 to return true or false based on
 whether it should be fullscreen in the current environment.  If any of your
 state has changed that may impact this call
  updateFullscreenMode()  to have it re-evaluated.  The default
 implementation selects fullscreen mode when the screen is in a landscape
 orientation which is appropriate behavior for most input methods that have
 a significant input area. When in fullscreen mode you have some special requirements because the
 user can not see the application UI.  In particular you should implement
  onDisplayCompletions(android.view.inputmethod.CompletionInfo[])  to show completions
 generated by your application typically in your candidates view like you
 would normally show candidates.


  Generating Text The key part of an IME is of course generating text for the application.
 This is done through calls to the
  InputConnection  interface to the
 application which can be retrieved from  getCurrentInputConnection() .
 This interface allows you to generate raw key events or if the target
 supports it directly edit in strings of candidates and committed text. Information about what the target is expected and supports can be found
 through the  EditorInfo  class which is
 retrieved with  getCurrentInputEditorInfo()  method.  The most
 important part of this is  EditorInfo.inputType ; in particular if this is
  EditorInfo.TYPE_NULL 
 then the target does not support complex edits and you need to only deliver
 raw key events to it.  An input method will also want to look at other
 values here to for example detect password mode auto complete text views
 phone number entry etc. When the user switches between input targets you will receive calls to
  onFinishInput()  and  onStartInput(android.view.inputmethod.EditorInfo boolean) .
 You can use these to reset and initialize your input state for the current
 target.  For example you will often want to clear any input state and
 update a soft keyboard to be appropriate for the new inputType.",,,,,,,,
<android.widget.AdapterViewAnimator: void setSelection(int)>,"Sets the currently selected item. To support accessibility subclasses that
 override this method must invoke the overridden super method first.",position int : Index (starting at 0) of the data item to be selected. |||,void,11,"An AdapterView is a view whose children are determined by an  Adapter .

  
 See  ListView   GridView   Spinner  and
       Gallery  for commonly used subclasses of AdapterView.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.app.ActivityOptions: Bundle toBundle()>,"Returns the created options as a Bundle which can be passed to Context.startActivity(Intent Bundle) and related methods.
 Note that the returned Bundle is still owned by the ActivityOptions
 object; you must not modify it but can supply it to the startActivity
 methods that take an options Bundle.",,Bundle |||,16,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
"<android.app.admin.DevicePolicyManager: void setPasswordQuality(ComponentName,int)>","Called by an application that is administering the device to set the password restrictions it
 is imposing. After setting this the user will not be able to enter a new password that is
 not at least as restrictive as what has been set. Note that the current password will remain
 until the user has set a new one so the change does not take place immediately. To prompt
 the user for a new password use ACTION_SET_NEW_PASSWORD or ACTION_SET_NEW_PARENT_PROFILE_PASSWORD after calling this method. Quality constants are ordered so that higher values are more restrictive; thus the highest
 requested quality constant (between the policy set here the user's preference and any other
 considerations) is the one that is in effect. On devices not supporting PackageManager#FEATURE_SECURE_LOCK_SCREEN feature the
 password is always treated as empty. The calling device admin must have requested DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD to be able to call this method; if it has
 not a security exception will be thrown. This method can be called on the DevicePolicyManager instance returned by getParentProfileInstance(android.content.ComponentName) in order to set restrictions on the parent
 profile.","admin ComponentName : Which DeviceAdminReceiver this request is associated with.
This value cannot be null . |||
quality int : The new desired quality. One of PASSWORD_QUALITY_UNSPECIFIED  PASSWORD_QUALITY_BIOMETRIC_WEAK  PASSWORD_QUALITY_SOMETHING  PASSWORD_QUALITY_NUMERIC  PASSWORD_QUALITY_NUMERIC_COMPLEX  PASSWORD_QUALITY_ALPHABETIC  PASSWORD_QUALITY_ALPHANUMERIC or PASSWORD_QUALITY_COMPLEX . |||",void,8,"Public interface for managing policies enforced on a device. Most clients of this class must be
 registered with the system as a  device
 administrator . Additionally a device administrator may be registered as either a profile or
 device owner. A given method is accessible to all device administrators unless the documentation
 for that method specifies that it is restricted to either device or profile owners. Any
 application calling an api may only pass as an argument a device administrator component it
 owns. Otherwise a  SecurityException  will be thrown.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.widget.RemoteViews: RemoteViews clone()>,"This method was deprecated
      in API level 28. use RemoteViews(android.widget.RemoteViews) instead. Returns a deep copy of the RemoteViews object. The RemoteView may not be
 attached to another RemoteView -- it must be the root of a hierarchy.",,RemoteViews a clone of this instance. |||,1,"A class that describes a view hierarchy that can be displayed in
 another process. The hierarchy is inflated from a layout resource
 file and this class provides some basic operations for modifying
 the content of the inflated hierarchy.

  RemoteViews  is limited to support for the following layouts: AdapterViewFlipper FrameLayout GridLayout GridView LinearLayout ListView RelativeLayout StackView ViewFlipper And the following widgets: AnalogClock Button Chronometer ImageButton ImageView ProgressBar TextClock TextView Descendants of these classes are not supported.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.view.View: void setRight(int)>,"Sets the right position of this view relative to its parent. This method is meant to be called
 by the layout system and should not generally be called otherwise because the property
 may be changed at any time by the layout.",right int : The right of this view in pixels. |||,void,11,"This class represents the basic building block for user interface components. A View
 occupies a rectangular area on the screen and is responsible for drawing and
 event handling. View is the base class for  widgets  which are
 used to create interactive UI components (buttons text fields etc.). The
  ViewGroup  subclass is the base class for  layouts  which
 are invisible containers that hold other Views (or other ViewGroups) and define
 their layout properties.",,,,,,,,
"<android.app.admin.DevicePolicyManager: void setPasswordHistoryLength(ComponentName,int)>","Called by an application that is administering the device to set the length of the password
 history. After setting this the user will not be able to enter a new password that is the
 same as any password in the history. Note that the current password will remain until the
 user has set a new one so the change does not take place immediately. To prompt the user for
 a new password use ACTION_SET_NEW_PASSWORD or ACTION_SET_NEW_PARENT_PROFILE_PASSWORD after setting this value. On devices not supporting PackageManager#FEATURE_SECURE_LOCK_SCREEN feature the
 password history length is always 0. The calling device admin must have requested DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD to be able to call this method; if it has
 not a security exception will be thrown. This method can be called on the DevicePolicyManager instance returned by getParentProfileInstance(android.content.ComponentName) in order to set restrictions on the parent
 profile. Requires the PackageManager#FEATURE_SECURE_LOCK_SCREEN feature which can be detected using PackageManager.hasSystemFeature(String) .","admin ComponentName : Which DeviceAdminReceiver this request is associated with.
This value cannot be null . |||
length int : The new desired length of password history. A value of 0 means there is no
restriction. |||",void,11,"Public interface for managing policies enforced on a device. Most clients of this class must be
 registered with the system as a  device
 administrator . Additionally a device administrator may be registered as either a profile or
 device owner. A given method is accessible to all device administrators unless the documentation
 for that method specifies that it is restricted to either device or profile owners. Any
 application calling an api may only pass as an argument a device administrator component it
 owns. Otherwise a  SecurityException  will be thrown.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
"<android.database.DatabaseUtils: void createDbFromSqlStatements(Context,String,int,String)>",Creates a db and populates it with the sql statements in sqlStatements.,"context Context : the context to use to create the db |||
dbName String : the name of the db to create |||
dbVersion int : the version to set on the db |||
sqlStatements String : the statements to use to populate the db. This should be a single string
of the form returned by sqlite3's .dump command (statements separated by
semicolons) |||",void,1,Static utility methods for dealing with databases and  Cursor s.,"If you need to manage data in a private database use the  android.database.sqlite  classes. These classes are used to manage the  Cursor  object returned from a content provider query. Databases
 are usually created and opened with  openOrCreateDatabase(String int SQLiteDatabase.CursorFactory) 
 To make requests through
 content providers you can use the  content.ContentResolver  class.
  All databases are stored on the device in  /data/data/<package_name>/databases",,,,,,,
<android.view.View: void saveHierarchyState(SparseArray)>,Store this view hierarchy's frozen state into the given container.,container SparseArray : The SparseArray in which to save the view's state. |||,void,1,"This class represents the basic building block for user interface components. A View
 occupies a rectangular area on the screen and is responsible for drawing and
 event handling. View is the base class for  widgets  which are
 used to create interactive UI components (buttons text fields etc.). The
  ViewGroup  subclass is the base class for  layouts  which
 are invisible containers that hold other Views (or other ViewGroups) and define
 their layout properties.",,,,,,,,
<android.app.Fragment: CharSequence getText(int)>,"Return a localized styled CharSequence from the application's package's
 default string table.",resId int : Resource id for the CharSequence text |||,CharSequence |||,11,"A Fragment is a piece of an application's user interface or behavior
 that can be placed in an  Activity .  Interaction with fragments
 is done through  FragmentManager  which can be obtained via
  Activity#getFragmentManager()  and
  Fragment#getFragmentManager() .

  The Fragment class can be used many ways to achieve a wide variety of
 results. In its core it represents a particular operation or interface
 that is running within a larger  Activity .  A Fragment is closely
 tied to the Activity it is in and can not be used apart from one.  Though
 Fragment defines its own lifecycle that lifecycle is dependent on its
 activity: if the activity is stopped no fragments inside of it can be
 started; when the activity is destroyed all fragments will be destroyed.

  All subclasses of Fragment must include a public no-argument constructor.
 The framework will often re-instantiate a fragment class when needed
 in particular during state restore and needs to be able to find this
 constructor to instantiate it.  If the no-argument constructor is not
 available a runtime exception will occur in some cases during state
 restore.

  Topics covered here:
  Older Platforms Lifecycle Layout Back Stack","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
"<android.content.pm.ComponentInfo: void writeToParcel(Parcel,int)>",,"dest Parcel |||
parcelableFlags int |||",void,1,"Base class containing information common to all application components
 ( ActivityInfo   ServiceInfo ).  This class is not intended
 to be used by itself; it is simply here to share common definitions
 between all application components.  As such it does not itself
 implement Parcelable but does provide convenience methods to assist
 in the implementation of Parcelable in subclasses.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.nfc.tech.NdefFormatable: void close()>,"Disable I/O operations to the tag from this TagTechnology object and release resources. Also causes all blocked I/O operations on other thread to be canceled and
 return with IOException . Requires the Manifest.permission.NFC permission.",,void,-1,"Provide access to NDEF format operations on a  Tag .

  Acquire a  NdefFormatable  object using  get(Tag) .

  Android devices with NFC must only enumerate and implement this
 class for tags for which it can format to NDEF.

  Unfortunately the procedures to convert unformated tags to NDEF formatted
 tags are not specified by NFC Forum and are not generally well-known. So
 there is no mandatory set of tags for which all Android devices with NFC
 must support  NdefFormatable .

  Note:  Methods that perform I/O operations
 require the  Manifest.permission.NFC  permission.","These classes provide access to a tag technology's features which vary by the type
 of tag that is scanned. A scanned tag can support multiple technologies and you can find
 out what they are by calling  getTechList() . For more information on dealing with tag technologies and handling the ones that you care about see
  The Tag Dispatch System .
 The  TagTechnology  interface provides an overview of the
 supported technologies.",,,,,,,
"<android.widget.CursorAdapter: View getView(int,View,ViewGroup)>","Get a View that displays the data at the specified position in the data set. You can either
 create a View manually or inflate it from an XML layout file. When the View is inflated the
 parent View (GridView ListView...) will apply default layout parameters unless you use LayoutInflater.inflate(int android.view.ViewGroup boolean) to specify a root view and to prevent attachment to the root.","position int : The position of the item within the adapter's data set of the item whose view
we want. |||
convertView View : The old view to reuse if possible. Note: You should check that this view
is non-null and of an appropriate type before using. If it is not possible to convert
this view to display the correct data this method can create a new view.
Heterogeneous lists can specify their number of view types so that this View is
always of the right type (see BaseAdapter.getViewTypeCount() and BaseAdapter.getItemViewType(int) ). |||
parent ViewGroup : The parent that this view will eventually be attached to |||",View A View corresponding to the data at the specified position. |||,1,"Adapter that exposes data from a  Cursor  to a
  ListView  widget.
  
 The Cursor must include a column named ""_id"" or this class will not work.
 Additionally using  MergeCursor  with this class will
 not work if the merged Cursors have overlapping values in their ""_id""
 columns.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getParent()>,"Gets the parent. Note: It is a client responsibility to recycle the
     received info by calling AccessibilityNodeInfo#recycle() to avoid creating of multiple instances.",,AccessibilityNodeInfo The parent. |||,14,"This class represents a node of the window content as well as actions that
 can be requested from its source. From the point of view of an
  AccessibilityService  a window's content is
 presented as a tree of accessibility node infos which may or may not map one-to-one
 to the view hierarchy. In other words a custom view is free to report itself as
 a tree of accessibility node info.
  
 Once an accessibility node info is delivered to an accessibility service it is
 made immutable and calling a state mutation method generates an error.
  
 Please refer to  AccessibilityService  for
 details about how to obtain a handle to window content as a tree of accessibility
 node info as well as details about the security model.",,,,,,,,
<android.app.WallpaperManager: void setBitmap(Bitmap)>,"Change the current system wallpaper to a bitmap.  The given bitmap is
 converted to a PNG and stored as the wallpaper.  On success the intent Intent#ACTION_WALLPAPER_CHANGED is broadcast. This method is equivalent to calling setBitmap(android.graphics.Bitmap android.graphics.Rect boolean) and passing null for the visibleCrop rectangle and true for the allowBackup parameter. This method requires the caller to hold the permission Manifest.permission.SET_WALLPAPER . Requires Manifest.permission.SET_WALLPAPER",bitmap Bitmap : The bitmap to be used as the new system wallpaper. |||,void,5,"Provides access to the system wallpaper. With WallpaperManager you can
 get the current wallpaper get the desired dimensions for the wallpaper set
 the wallpaper and more.

   An app can check whether wallpapers are supported for the current user by calling
  isWallpaperSupported()  and whether setting of wallpapers is allowed by calling
  isSetWallpaperAllowed() .","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.os.Bundle: char getChar(String)>,"Returns the value associated with the given key or (char) 0 if
 no mapping of the desired type exists for the given key.",key String : a String |||,char a char value |||,1,A mapping from String keys to various  Parcelable  values.,,,,,,,,
<android.nfc.tech.NfcBarcode: void connect()>,"Enable I/O operations to the tag from this TagTechnology object. May cause RF activity and may block. Must not be called
 from the main application thread. A blocked call will be canceled with IOException by calling close() from another thread. Only one TagTechnology object can be connected to a Tag at a time. Applications must call close() when I/O operations are complete. Requires the Manifest.permission.NFC permission.",,void,-1,"Provides access to NFC-B (ISO 14443-3B) properties and I/O operations on a  Tag .

  Acquire a  NfcB  object using  get(Tag) .
  The primary NFC-B I/O operation is  transceive(byte[]) . Applications must
 implement their own protocol stack on top of  transceive(byte[]) .

  Note:  Methods that perform I/O operations
 require the  Manifest.permission.NFC  permission.","These classes provide access to a tag technology's features which vary by the type
 of tag that is scanned. A scanned tag can support multiple technologies and you can find
 out what they are by calling  getTechList() . For more information on dealing with tag technologies and handling the ones that you care about see
  The Tag Dispatch System .
 The  TagTechnology  interface provides an overview of the
 supported technologies.",,,,,,,
"<android.os.Parcel: void readMap(Map,ClassLoader)>","Please use readBundle(java.lang.ClassLoader) instead (whose data must have
 been written with writeBundle(Bundle) .  Read into an existing Map object
 from the parcel at the current dataPosition().","outVal Map : This value cannot be null . |||
loader ClassLoader : This value may be null . |||",void,1,"Container for a message (data and object references) that can
 be sent through an IBinder.  A Parcel can contain both flattened data
 that will be unflattened on the other side of the IPC (using the various
 methods here for writing specific types or the general
  Parcelable  interface) and references to live  IBinder 
 objects that will result in the other side receiving a proxy IBinder
 connected with the original IBinder in the Parcel.

  Parcel is  not  a general-purpose
 serialization mechanism.  This class (and the corresponding
  Parcelable  API for placing arbitrary objects into a Parcel) is
 designed as a high-performance IPC transport.  As such it is not
 appropriate to place any Parcel data in to persistent storage: changes
 in the underlying implementation of any of the data in the Parcel can
 render older data unreadable. The bulk of the Parcel API revolves around reading and writing data
 of various types.  There are six major classes of such functions available. Primitives The most basic data functions are for writing and reading primitive
 data types:  writeByte(byte)   readByte()   writeDouble(double) 
  readDouble()   writeFloat(float)   readFloat()   writeInt(int) 
  readInt()   writeLong(long)   readLong() 
  writeString(String)   readString() .  Most other
 data operations are built on top of these.  The given data is written and
 read using the endianess of the host CPU. Primitive Arrays There are a variety of methods for reading and writing raw arrays
 of primitive objects which generally result in writing a 4-byte length
 followed by the primitive data items.  The methods for reading can either
 read the data into an existing array or create and return a new array.
 These available types are: writeBooleanArray(boolean[]) 
  readBooleanArray(boolean[])   createBooleanArray() writeByteArray(byte[]) 
  writeByteArray(byte[] int int)   readByteArray(byte[]) 
  createByteArray() writeCharArray(char[])   readCharArray(char[]) 
  createCharArray() writeDoubleArray(double[])   readDoubleArray(double[]) 
  createDoubleArray() writeFloatArray(float[])   readFloatArray(float[]) 
  createFloatArray() writeIntArray(int[])   readIntArray(int[]) 
  createIntArray() writeLongArray(long[])   readLongArray(long[]) 
  createLongArray() writeStringArray(java.lang.String[])   readStringArray(java.lang.String[]) 
  createStringArray() .
  writeSparseBooleanArray(android.util.SparseBooleanArray) 
  readSparseBooleanArray() .
  Parcelables The  Parcelable  protocol provides an extremely efficient (but
 low-level) protocol for objects to write and read themselves from Parcels.
 You can use the direct methods  writeParcelable(android.os.Parcelable int) 
 and  readParcelable(java.lang.ClassLoader)  or
  writeParcelableArray(T[] int)  and
  readParcelableArray(java.lang.ClassLoader)  to write or read.  These
 methods write both the class type and its data to the Parcel allowing
 that class to be reconstructed from the appropriate class loader when
 later reading. There are also some methods that provide a more efficient way to work
 with Parcelables:  writeTypedObject(T int)   writeTypedArray(T[] int) 
  writeTypedList(List )   readTypedObject(Parcelable.Creator ) 
  createTypedArray(Parcelable.Creator )  and  createTypedArrayList(Parcelable.Creator ) .  These methods
 do not write the class information of the original object: instead the
 caller of the read function must know what type to expect and pass in the
 appropriate  Parcelable.Creator  instead to
 properly construct the new object and read its data.  (To more efficient
 write and read a single Parcelable object that is not null you can directly
 call  Parcelable#writeToParcel  and
  Parcelable.Creator#createFromParcel 
 yourself.) Bundles A special type-safe container called  Bundle  is available
 for key/value maps of heterogeneous values.  This has many optimizations
 for improved performance when reading and writing data and its type-safe
 API avoids difficult to debug type errors when finally marshalling the
 data contents into a Parcel.  The methods to use are
  writeBundle(android.os.Bundle)   readBundle()  and
  readBundle(java.lang.ClassLoader) .

  Active Objects An unusual feature of Parcel is the ability to read and write active
 objects.  For these objects the actual contents of the object is not
 written rather a special token referencing the object is written.  When
 reading the object back from the Parcel you do not get a new instance of
 the object but rather a handle that operates on the exact same object that
 was originally written.  There are two forms of active objects available. Binder  objects are a core facility of Android's general cross-process
 communication system.  The  IBinder  interface describes an abstract
 protocol with a Binder object.  Any such interface can be written in to
 a Parcel and upon reading you will receive either the original object
 implementing that interface or a special proxy implementation
 that communicates calls back to the original object.  The methods to use are
  writeStrongBinder(android.os.IBinder) 
  writeStrongInterface(android.os.IInterface)   readStrongBinder() 
  writeBinderArray(android.os.IBinder[])   readBinderArray(android.os.IBinder[]) 
  createBinderArray() 
  writeBinderList(java.util.List)   readBinderList(java.util.List) 
  createBinderArrayList() . FileDescriptor objects representing raw Linux file descriptor identifiers
 can be written and  ParcelFileDescriptor  objects returned to operate
 on the original file descriptor.  The returned file descriptor is a dup
 of the original file descriptor: the object and fd is different but
 operating on the same underlying file stream with the same position etc.
 The methods to use are  writeFileDescriptor(java.io.FileDescriptor) 
  readFileDescriptor() .

  Untyped Containers A final class of methods are for writing and reading standard Java
 containers of arbitrary types.  These all revolve around the
  writeValue(java.lang.Object)  and  readValue(java.lang.ClassLoader)  methods
 which define the types of objects allowed.  The container methods are
  writeArray(java.lang.Object[])   readArray(java.lang.ClassLoader) 
  writeList(java.util.List)   readList(java.util.List java.lang.ClassLoader) 
  readArrayList(java.lang.ClassLoader) 
  writeMap(java.util.Map)   readMap(java.util.Map java.lang.ClassLoader) 
  writeSparseArray(android.util.SparseArray) 
  readSparseArray(java.lang.ClassLoader) .",,,,,,,,
<android.view.Display: String toString()>,"Returns a string representation of the object. In general the toString method returns a string that
 ""textually represents"" this object. The result should
 be a concise but informative representation that is easy for a
 person to read.
 It is recommended that all subclasses override this method. The toString method for class Object returns a string consisting of the name of the class of which the
 object is an instance the at-sign character ` @ ' and
 the unsigned hexadecimal representation of the hash code of the
 object. In other words this method returns a string equal to the
 value of:",,String a string representation of the object. |||,1,"Provides information about the size and density of a logical display.
  
 The display area is described in two different ways.
  The application display area specifies the part of the display that may contain
 an application window excluding the system decorations.  The application display area may
 be smaller than the real display area because the system subtracts the space needed
 for decor elements such as the status bar.  Use the following methods to query the
 application display area:  getSize(Point)   getRectSize(Rect)  and  getMetrics(DisplayMetrics) . The real display area specifies the part of the display that contains content
 including the system decorations.  Even so the real display area may be smaller than the
 physical size of the display if the window manager is emulating a smaller display
 using (adb shell wm size).  Use the following methods to query the
 real display area:  getRealSize(Point)   getRealMetrics(DisplayMetrics) . 
 A logical display does not necessarily represent a particular physical display device
 such as the built-in screen or an external monitor.  The contents of a logical
 display may be presented on one or more physical displays according to the devices
 that are currently attached and whether mirroring has been enabled.",,,,,,,,
<android.view.inputmethod.InputMethodManager: InputMethodSubtype getCurrentInputMethodSubtype()>,"Returns the current input method subtype. This subtype is one of the subtypes in
 the current input method. This method returns null when the current input method doesn't
 have any input method subtype.",,InputMethodSubtype |||,11,"Central system API to the overall input method framework (IMF) architecture
 which arbitrates interaction between applications and the current input method.

  Topics covered here:
  Architecture Overview Applications Input Methods Security Architecture Overview There are three primary parties involved in the input method
 framework (IMF) architecture:  The  input method manager  as expressed by this class
 is the central point of the system that manages interaction between all
 other parts.  It is expressed as the client-side API here which exists
 in each application context and communicates with a global system service
 that manages the interaction across all processes.
   An  input method (IME)  implements a particular
 interaction model allowing the user to generate text.  The system binds
 to the current input method that is in use causing it to be created and run
 and tells it when to hide and show its UI.  Only one IME is running at a time.
   Multiple  client applications  arbitrate with the input
 method manager for input focus and control over the state of the IME.  Only
 one such client is ever active (working with the IME) at a time.
  Applications In most cases applications that are using the standard
  TextView  or its subclasses will have little they need
 to do to work well with soft input methods.  The main things you need to
 be aware of are:  Properly set the  R.attr.inputType  in your editable
 text views so that the input method will have enough context to help the
 user in entering text into them.
   Deal well with losing screen space when the input method is
 displayed.  Ideally an application should handle its window being resized
 smaller but it can rely on the system performing panning of the window
 if needed.  You should set the  R.attr.windowSoftInputMode 
 attribute on your activity or the corresponding values on windows you
 create to help the system determine whether to pan or resize (it will
 try to determine this automatically but may get it wrong).
   You can also control the preferred soft input state (open closed etc)
 for your window using the same  R.attr.windowSoftInputMode 
 attribute.
  More finer-grained control is available through the APIs here to directly
 interact with the IMF and its IME -- either showing or hiding the input
 area letting the user pick an input method etc. For the rare people amongst us writing their own text editors you
 will need to implement  View.onCreateInputConnection(EditorInfo) 
 to return a new instance of your own  InputConnection  interface
 allowing the IME to interact with your editor. Input Methods An input method (IME) is implemented
 as a  Service  typically deriving from
  InputMethodService .  It must provide
 the core  InputMethod  interface though this is normally handled by
  InputMethodService  and implementors will
 only need to deal with the higher-level API there. InputMethodService Security There are a lot of security issues associated with input methods
 since they essentially have freedom to completely drive the UI and monitor
 everything the user enters.  The Android input method framework also allows
 arbitrary third party IMEs so care must be taken to restrict their
 selection and interactions. Here are some key points about the security architecture behind the
 IMF: Only the system is allowed to directly access an IME's
  InputMethod  interface via the
  Manifest.permission.BIND_INPUT_METHOD  permission.  This is
 enforced in the system by not binding to an input method service that does
 not require this permission so the system can guarantee no other untrusted
 clients are accessing the current input method outside of its control. There may be many client processes of the IMF but only one may
 be active at a time.  The inactive clients can not interact with key
 parts of the IMF through the mechanisms described below. Clients of an input method are only given access to its
  InputMethodSession  interface.  One instance of this interface is
 created for each client and only calls from the session associated with
 the active client will be processed by the current IME.  This is enforced
 by  AbstractInputMethodService  for normal
 IMEs but must be explicitly handled by an IME that is customizing the
 raw  InputMethodSession  implementation. Only the active client's  InputConnection  will accept
 operations.  The IMF tells each client process whether it is active and
 the framework enforces that in inactive processes calls on to the current
 InputConnection will be ignored.  This ensures that the current IME can
 only deliver events and text edits to the UI that the user sees as
 being in focus. An IME can never interact with an  InputConnection  while
 the screen is off.  This is enforced by making all clients inactive while
 the screen is off and prevents bad IMEs from driving the UI when the user
 can not be aware of its behavior. A client application can ask that the system let the user pick a
 new IME but can not programmatically switch to one itself.  This avoids
 malicious applications from switching the user to their own IME which
 remains running when the user navigates away to another application.  An
 IME on the other hand  is  allowed to programmatically switch
 the system to another IME since it already has full control of user
 input. The user must explicitly enable a new IME in settings before
 they can switch to it to confirm with the system that they know about it
 and want to make it available for use. PackageManager#FEATURE_INPUT_METHODS PackageManager.hasSystemFeature(String)",,,,,,,,
"<android.content.ContentResolver: int getIsSyncable(Account,String)>",Check if this account/provider is syncable. This method requires the caller to hold the permission Manifest.permission.READ_SYNC_SETTINGS .,"account Account |||
authority String |||",int >0 if it is syncable 0 if not and <0 if the state isn't known yet. |||,5,This class provides applications access to the content model.,"Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
"<android.appwidget.AppWidgetManager: void partiallyUpdateAppWidget(int,RemoteViews)>","Perform an incremental update or command on the widget specified by appWidgetId. This update  differs from updateAppWidget(int android.widget.RemoteViews) in that the RemoteViews
 object which is passed is understood to be an incomplete representation of the widget and
 hence is not cached by the AppWidgetService. Note that because these updates are not cached
 any state that they modify that is not restored by restoreInstanceState will not persist in
 the case that the widgets are restored using the cached version in AppWidgetService.

 Use with RemoteViews#showNext(int)  RemoteViews#showPrevious(int)  RemoteViews#setScrollPosition(int int) and similar commands. It is okay to call this method both inside an ACTION_APPWIDGET_UPDATE broadcast
 and outside of the handler.
 This method will only work when called from the uid that owns the AppWidget provider. This method will be ignored if a widget has not received a full update via updateAppWidget(int[] android.widget.RemoteViews) .","appWidgetId int : The AppWidget instance for which to set the RemoteViews. |||
views RemoteViews : The RemoteViews object containing the incremental update / command. |||",void,11,"Updates AppWidget state; gets information about installed AppWidget providers and other
 AppWidget related state.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
"<android.test.TouchUtils: void dragViewToTop(InstrumentationTestCase,View,int)>",Simulate touching the center of a view and dragging to the top of the screen.,"test InstrumentationTestCase : The test case that is being run |||
v View : The view that should be dragged |||
stepCount int : How many move steps to include in the drag |||",void,3,"Reusable methods for generating touch events. These methods can be used with
 InstrumentationTestCase or ActivityInstrumentationTestCase2 to simulate user interaction with
 the application through a touch screen.",,,,,,,,
<android.content.ContextWrapper: int getWallpaperDesiredMinimumHeight()>,This method is deprecated. Use WallpaperManager.getDesiredMinimumHeight() instead.,,int |||,1,"Proxying implementation of Context that simply delegates all of its calls to
 another Context.  Can be subclassed to modify behavior without changing
 the original Context.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.app.Activity: void onCreateNavigateUpTaskStack(TaskStackBuilder)>,"Define the synthetic task stack that will be generated during Up navigation from
 a different task. The default implementation of this method adds the parent chain of this activity
 as specified in the manifest to the supplied TaskStackBuilder . Applications
 may choose to override this method to construct the desired task stack in a different
 way. This method will be invoked by the default implementation of onNavigateUp() if shouldUpRecreateTask(android.content.Intent) returns true when supplied with the intent
 returned by getParentActivityIntent() . Applications that wish to supply extra Intent parameters to the parent stack defined
 by the manifest should override onPrepareNavigateUpTaskStack(android.app.TaskStackBuilder) .","builder TaskStackBuilder : An empty TaskStackBuilder - the application should add intents representing
the desired task stack |||",void,16,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
"<android.view.DragEvent: void writeToParcel(Parcel,int)>",Creates a Parcel object from this DragEvent object.,"dest Parcel : A Parcel object in which to put the DragEvent object. |||
flags int : Flags to store in the Parcel. |||",void,11,"Represents an event that is sent out by the system at various times during a drag and drop
 operation. It is a data structure that contains several important pieces of data about
 the operation and the underlying data.
  
  View objects that receive a DragEvent call  getAction()  which returns
  an action type that indicates the state of the drag and drop operation. This allows a View
  object to react to a change in state by changing its appearance or performing other actions.
  For example a View can react to the  ACTION_DRAG_ENTERED  action type by
  by changing one or more colors in its displayed image.
  
  During a drag and drop operation the system displays an image that the user drags. This image
  is called a drag shadow. Several action types reflect the position of the drag shadow relative
  to the View receiving the event.
  
  Most methods return valid data only for certain event actions. This is summarized in the
  following table. Each possible  getAction()  value is listed in the first column. The
  other columns indicate which method or methods return valid data for that getAction() value:
  getAction() Value getClipDescription() getLocalState() getX() getY() getClipData() getResult() ACTION_DRAG_STARTED X X X X ACTION_DRAG_ENTERED X X ACTION_DRAG_LOCATION X X X X ACTION_DRAG_EXITED X X ACTION_DROP X X X X X ACTION_DRAG_ENDED X X 
  The  getAction() 
   getLocalState() describeContents() 
   writeToParcel(Parcel int)  and
   toString()  methods always return valid data.",,,,,,,,
<android.appwidget.AppWidgetHost: void startListening()>,"Start receiving onAppWidgetChanged calls for your AppWidgets.  Call this when your activity
 becomes visible i.e. from onStart() in your Activity.",,void,3,"AppWidgetHost provides the interaction with the AppWidget service for apps
 like the home screen that want to embed AppWidgets in their UI.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.content.Intent: CharSequence getCharSequenceArrayExtra(String)>,Retrieve extended data from the intent.,name String : The name of the desired item. |||,"CharSequence[] the value of an item previously added with putExtra()
 or null if no CharSequence array value was found. |||",8,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.widget.Spinner: int getBaseline()>,"Return the offset of the widget's text baseline from the widget's top
 boundary. If this widget does not support baseline alignment this
 method returns -1.",,"int the offset of the baseline within the widget's bounds or -1
         if baseline alignment is not supported |||",1,"A view that displays one child at a time and lets the user pick among them.
 The items in the Spinner come from the  Adapter  associated with
 this view.

  See the  Spinners  guide.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.test.InstrumentationTestRunner: void onStart()>,"Method where the instrumentation thread enters execution.  This allows
 you to run your instrumentation code in a separate thread than the
 application so that it can perform blocking operation such as sendKeySync(KeyEvent) or startActivitySync(Intent) . You will typically want to call finish() when this function is done
 to end your instrumentation.",,void,1,"An  Instrumentation  that runs various types of  TestCase s against
 an Android package (application).",,,,,,,,
<android.widget.PopupWindow: void setContentView(View)>,"Change the popup's content. The content is represented by an instance
 of View . This method has no effect if called when the popup is showing.",contentView View : the new content for the popup |||,void,1,"This class represents a popup window that can be used to display an
 arbitrary view. The popup window is a floating container that appears on top
 of the current activity.
  Animation 
 On all versions of Android popup window enter and exit animations may be
 specified by calling  setAnimationStyle(int)  and passing the
 resource ID for an animation style that defines  windowEnterAnimation 
 and  windowExitAnimation . For example passing
  R.style.Animation_Dialog  will give a scale and alpha
 animation.
 
 A window animation style may also be specified in the popup window's style
 XML via the  popupAnimationStyle 
 attribute.
  
 Starting with API 23 more complex popup window enter and exit transitions
 may be specified by calling either  setEnterTransition(android.transition.Transition) 
 or  setExitTransition(android.transition.Transition)  and passing a   Transition .
 
 Popup enter and exit transitions may also be specified in the popup window's
 style XML via the  popupEnterTransition 
 and  popupExitTransition 
 attributes respectively.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
"<android.app.ActivityOptions: ActivityOptions makeCustomAnimation(Context,int,int)>","Create an ActivityOptions specifying a custom animation to run when
 the activity is displayed.","context Context : Who is defining this.  This is the application that the
animation resources will be loaded from. |||
enterResId int : A resource ID of the animation resource to use for
the incoming activity.  Use 0 for no animation. |||
exitResId int : A resource ID of the animation resource to use for
the outgoing activity.  Use 0 for no animation. |||","ActivityOptions Returns a new ActivityOptions object that you can use to
 supply these options as the options Bundle when starting an activity. |||",16,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
"<android.app.PendingIntent: PendingIntent getActivities(Context,int,Intent,int)>","Like getActivity(android.content.Context int android.content.Intent int) but allows an
 array of Intents to be supplied.  The last Intent in the array is
 taken as the primary key for the PendingIntent like the single Intent
 given to getActivity(android.content.Context int android.content.Intent int) .  Upon sending
 the resulting PendingIntent all of the Intents are started in the same
 way as they would be by passing them to Context#startActivities(Intent[]) . The first intent in the array will be started outside of the context of an
 existing activity so you must use the Intent#FLAG_ACTIVITY_NEW_TASK launch flag in the Intent.  (Activities after
 the first in the array are started in the context of the previous activity
 in the array so FLAG_ACTIVITY_NEW_TASK is not needed nor desired for them.) The last intent in the array represents the key for the
 PendingIntent.  In other words it is the significant element for matching
 (as done with the single intent given to getActivity(android.content.Context int android.content.Intent int) its content will be the subject of replacement by send(android.content.Context int android.content.Intent) and FLAG_UPDATE_CURRENT etc.
 This is because it is the most specific of the supplied intents and the
 UI the user actually sees when the intents are started. For security reasons the Intent objects
 you supply here should almost always be explicit intents that is specify an explicit component to be delivered to through Intent#setClass(android.content.Context Class)","context Context : The Context in which this PendingIntent should start
the activity. |||
requestCode int : Private request code for the sender |||
intents Intent : Array of Intents of the activities to be launched.
This value cannot be null . |||
flags int : May be FLAG_ONE_SHOT  FLAG_NO_CREATE  FLAG_CANCEL_CURRENT  FLAG_UPDATE_CURRENT or any of the flags as supported by Intent#fillIn to control which unspecified parts
of the intent that can be supplied when the actual send happens.
Value is either 0 or a combination of FLAG_ONE_SHOT  FLAG_NO_CREATE  FLAG_CANCEL_CURRENT  FLAG_UPDATE_CURRENT  FLAG_IMMUTABLE  Intent.FILL_IN_ACTION  Intent.FILL_IN_DATA  Intent.FILL_IN_CATEGORIES  Intent.FILL_IN_COMPONENT  Intent.FILL_IN_PACKAGE  Intent.FILL_IN_SOURCE_BOUNDS  Intent.FILL_IN_SELECTOR and Intent.FILL_IN_CLIP_DATA |||","PendingIntent Returns an existing or new PendingIntent matching the given
 parameters.  May return null only if FLAG_NO_CREATE has been
 supplied. |||",11,"A description of an Intent and target action to perform with it.  Instances
 of this class are created with  getActivity(Context int Intent int)   getActivities(Context int Intent[] int) 
  getBroadcast(Context int Intent int)  and  getService(Context int Intent int) ; the returned object can be
 handed to other applications so that they can perform the action you
 described on your behalf at a later time.

  By giving a PendingIntent to another application
 you are granting it the right to perform the operation you have specified
 as if the other application was yourself (with the same permissions and
 identity).  As such you should be careful about how you build the PendingIntent:
 almost always for example the base Intent you supply should have the component
 name explicitly set to one of your own components to ensure it is ultimately
 sent there and nowhere else.

  A PendingIntent itself is simply a reference to a token maintained by
 the system describing the original data used to retrieve it.  This means
 that even if its owning application's process is killed the
 PendingIntent itself will remain usable from other processes that
 have been given it.  If the creating application later re-retrieves the
 same kind of PendingIntent (same operation same Intent action data
 categories and components and same flags) it will receive a PendingIntent
 representing the same token if that is still valid and can thus call
  cancel()  to remove it.

  Because of this behavior it is important to know when two Intents
 are considered to be the same for purposes of retrieving a PendingIntent.
 A common mistake people make is to create multiple PendingIntent objects
 with Intents that only vary in their ""extra"" contents expecting to get
 a different PendingIntent each time.  This does  not  happen.  The
 parts of the Intent that are used for matching are the same ones defined
 by  Intent#filterEquals(Intent) .  If you use two
 Intent objects that are equivalent as per
  Intent#filterEquals(Intent)  then you will get
 the same PendingIntent for both of them.

  There are two typical ways to deal with this.

  If you truly need multiple distinct PendingIntent objects active at
 the same time (such as to use as two notifications that are both shown
 at the same time) then you will need to ensure there is something that
 is different about them to associate them with different PendingIntents.
 This may be any of the Intent attributes considered by
  Intent#filterEquals(Intent)  or different
 request code integers supplied to  getActivity(Context int Intent int)   getActivities(Context int Intent[] int) 
  getBroadcast(Context int Intent int)  or  getService(Context int Intent int) .

  If you only need one PendingIntent active at a time for any of the
 Intents you will use then you can alternatively use the flags
  FLAG_CANCEL_CURRENT  or  FLAG_UPDATE_CURRENT  to either
 cancel or modify whatever current PendingIntent is associated with the
 Intent you are supplying.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
"<android.content.ContextWrapper: void enforceCallingOrSelfUriPermission(Uri,int,String)>","If the calling process of an IPC or you has not been
 granted permission to access a specific URI throw SecurityException .  This is the same as enforceCallingUriPermission(Uri int String) except it grants your own
 permissions if you are not currently processing an IPC.  Use
 with care!","uri Uri : The uri that is being checked. |||
modeFlags int : The access modes to enforce.
Value is either 0 or a combination of Intent.FLAG_GRANT_READ_URI_PERMISSION and Intent.FLAG_GRANT_WRITE_URI_PERMISSION |||
message String : A message to include in the exception if it is thrown. |||",void,1,"Proxying implementation of Context that simply delegates all of its calls to
 another Context.  Can be subclassed to modify behavior without changing
 the original Context.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.app.Dialog: void setTitle(CharSequence)>,Set the title text for this dialog's window.,"title CharSequence : The new text to display in the title.
This value may be null . |||",void,1,"Base class for Dialogs.

  Note: Activities provide a facility to manage the creation saving and
 restoring of dialogs. See  Activity#onCreateDialog(int) 
  Activity#onPrepareDialog(int Dialog) 
  Activity#showDialog(int)  and  Activity#dismissDialog(int) . If
 these methods are used  getOwnerActivity()  will return the Activity
 that managed this dialog.

  Often you will want to have a Dialog display on top of the current
 input method because there is no reason for it to accept text.  You can
 do this by setting the  WindowManager.LayoutParams#FLAG_ALT_FOCUSABLE_IM  window flag (assuming
 your Dialog takes input focus as it the default) with the following code:

  
 getWindow().setFlags(WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM
         WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.content.ContentResolver: SyncInfo getCurrentSync()>,"This method was deprecated
      in API level 15. Since multiple concurrent syncs are now supported you should use getCurrentSyncs() to get the accurate list of current syncs.
 This method returns the first item from the list of current syncs
 or null if there are none. If a sync is active returns the information about it otherwise returns null. This method requires the caller to hold the permission Manifest.permission.READ_SYNC_STATS .",,SyncInfo the SyncInfo for the currently active sync or null if one is not active. |||,8,This class provides applications access to the content model.,"Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.content.Intent: void removeExtra(String)>,Remove extended data from the intent.,name String |||,void,1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.media.AudioManager: void loadSoundEffects()>,"Load Sound effects.
  This method must be called when sound effects are enabled.",,void,1,AudioManager provides access to volume and ringer mode control.,"The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",,,,,,,
"<android.widget.TextView: void setPadding(int,int,int,int)>","Sets the padding. The view may add on the space required to display
 the scrollbars depending on the style and visibility of the scrollbars.
 So the values returned from getPaddingLeft()  getPaddingTop()  getPaddingRight() and getPaddingBottom() may be different
 from the values set in this call.","left int : the left padding in pixels |||
top int : the top padding in pixels |||
right int : the right padding in pixels |||
bottom int : the bottom padding in pixels |||",void,1,"A user interface element that displays text to the user.
 To provide user-editable text see  EditText .
  
 The following code sample shows a typical use with an XML layout
 and code to modify the contents of the text view:
  
 <LinearLayout
      xmlns:android=""http://schemas.android.com/apk/res/android""
      android:layout_width=""match_parent""
      android:layout_height=""match_parent"">
    <TextView
        android:id=""@+id/text_view_id""
        android:layout_height=""wrap_content""
        android:layout_width=""wrap_content""
        android:text=""@string/hello"" />
 </LinearLayout>
  
 This code sample demonstrates how to modify the contents of the text view
 defined in the previous XML layout:
  
 public class MainActivity extends Activity {

    protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_main);
         final TextView helloTextView = (TextView) findViewById(R.id.text_view_id);
         helloTextView.setText(R.string.user_greeting);
     }
 }
  
 To customize the appearance of TextView see  Styles and Themes .
  XML attributes 
 See  TextView Attributes 
  View Attributes","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.widget.ArrayAdapter: void clear()>,Remove all elements from the list.,,void,1,"You can use this adapter to provide views for an  AdapterView 
 Returns a view for each object in a collection of data objects you
 provide and can be used with list-based user interface widgets such as
  ListView  or  Spinner .
  
 By default the array adapter creates a view by calling  Object#toString()  on each
 data object in the collection you provide and places the result in a TextView.
 You may also customize what type of view is used for the data object in the collection.
 To customize what type of view is used for the data object
 override  getView(int android.view.View android.view.ViewGroup) 
 and inflate a view resource.
 For a code example see
 the  
 CustomChoiceList  sample.
  
 For an example of using an array adapter with a ListView see the
  
 Adapter Views  guide.
  
 For an example of using an array adapter with a Spinner see the
  Spinners  guide.
  Note: 
 If you are considering using array adapter with a ListView consider using
  RecyclerView  instead.
 RecyclerView offers similar features with better performance and more flexibility than
 ListView provides.
 See the
  
 Recycler View  guide.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.os.Bundle: SparseArray getSparseParcelableArray(String)>,"Returns the value associated with the given key or null if
 no mapping of the desired type exists for the given key or a null
 value is explicitly associated with the key.","key String : a String or null
This value may be null . |||",SparseArray <T> a SparseArray of T values or null |||,1,A mapping from String keys to various  Parcelable  values.,,,,,,,,
<android.database.sqlite.SQLiteCursor: int getCount()>,Returns the numbers of rows in the cursor.,,int the number of rows in the cursor. |||,1,"A Cursor implementation that exposes results from a query on a
  SQLiteDatabase .

 SQLiteCursor is not internally synchronized so code using a SQLiteCursor from multiple
 threads should perform its own synchronization when using the SQLiteCursor.","If you need to manage data in a private database use the  android.database.sqlite  classes. These classes are used to manage the  Cursor  object returned from a content provider query. Databases
 are usually created and opened with  openOrCreateDatabase(String int SQLiteDatabase.CursorFactory) 
 To make requests through
 content providers you can use the  content.ContentResolver  class.
  All databases are stored on the device in  /data/data/<package_name>/databases",,,,,,,
<android.view.ViewPropertyAnimator: ViewPropertyAnimator scaleXBy(float)>,"This method will cause the View's scaleX property to be animated by the
 specified value. Animations already running on the property will be canceled.",value float : The amount to be animated by as an offset from the current value. |||,ViewPropertyAnimator This object allowing calls to methods in this class to be chained. |||,12,"This class enables automatic and optimized animation of select properties on View objects.
 If only one or two properties on a View object are being animated then using an
  ObjectAnimator  is fine; the property setters called by ObjectAnimator
 are well equipped to do the right thing to set the property and invalidate the view
 appropriately. But if several properties are animated simultaneously or if you just want a
 more convenient syntax to animate a specific property then ViewPropertyAnimator might be
 more well-suited to the task.

  This class may provide better performance for several simultaneous animations because
 it will optimize invalidate calls to take place only once for several properties instead of each
 animated property independently causing its own invalidation. Also the syntax of using this
 class could be easier to use because the caller need only tell the View object which
 property to animate and the value to animate either to or by and this class handles the
 details of configuring the underlying Animator class and starting it. This class is not constructed by the caller but rather by the View whose properties
 it will animate. Calls to  View.animate()  will return a reference
 to the appropriate ViewPropertyAnimator object for that View.",,,,,,,,
<android.app.admin.DeviceAdminInfo: CharSequence loadDescription(PackageManager)>,Load user-visible description associated with this device admin.,"pm PackageManager : Supply a PackageManager used to load the device admin's
resources. |||",CharSequence |||,8,"This class is used to specify meta information of a device administrator
 component.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
"<android.preference.PreferenceActivity: void switchToHeader(String,Bundle)>","When in two-pane mode switch the fragment pane to show the given
 preference fragment.","fragmentName String : The name of the fragment to display. |||
args Bundle : Optional arguments to supply to the fragment. |||",void,11,"This is the base class for an activity to show a hierarchy of preferences
 to the user.  Prior to  Build.VERSION_CODES.HONEYCOMB 
 this class only allowed the display of a single set of preference; this
 functionality should now be found in the new  PreferenceFragment 
 class.  If you are using PreferenceActivity in its old mode the documentation
 there applies to the deprecated APIs here.

  This activity shows one or more headers of preferences each of which
 is associated with a  PreferenceFragment  to display the preferences
 of that header.  The actual layout and display of these associations can
 however vary; currently there are two major approaches it may take:

  On a small screen it may display only the headers as a single list when first launched.
 Selecting one of the header items will only show the PreferenceFragment of that header (on
 Android N and lower a new Activity is launched).
  On a large screen it may display both the headers and current PreferenceFragment together as
 panes. Selecting a header item switches to showing the correct PreferenceFragment for that item.
  Subclasses of PreferenceActivity should implement
  onBuildHeaders(List )  to populate the header list with the desired
 items.  Doing this implicitly switches the class into its new ""headers
 + fragments"" mode rather than the old style of just showing a single
 preferences list.",,,,,,,,
<android.preference.Preference: void saveHierarchyState(Bundle)>,Store this Preference hierarchy's frozen state into the given container.,container Bundle : The Bundle in which to save the instance of this Preference. |||,void,1,"Represents the basic Preference UI building
 block displayed by a  PreferenceActivity  in the form of a
  ListView . This class provides the  View  to be displayed in
 the activity and associates with a  SharedPreferences  to
 store/retrieve the preference data.
  
 When specifying a preference hierarchy in XML each element can point to a
 subclass of  Preference  similar to the view hierarchy and layouts.
  
 This class contains a  key  that will be used as the key into the
  SharedPreferences . It is up to the subclass to decide how to store
 the value.",,,,,,,,
"<android.app.TaskStackBuilder: PendingIntent getPendingIntent(int,int)>",Obtain a PendingIntent for launching the task constructed by this builder so far.,"requestCode int : Private request code for the sender |||
flags int : May be PendingIntent#FLAG_ONE_SHOT  PendingIntent#FLAG_NO_CREATE  PendingIntent#FLAG_CANCEL_CURRENT  PendingIntent#FLAG_UPDATE_CURRENT or any of the flags supported by Intent#fillIn(Intent int) to control which unspecified parts of the
intent that can be supplied when the actual send happens.
Value is either 0 or a combination of PendingIntent.FLAG_ONE_SHOT  PendingIntent.FLAG_NO_CREATE  PendingIntent.FLAG_CANCEL_CURRENT  PendingIntent.FLAG_UPDATE_CURRENT  PendingIntent.FLAG_IMMUTABLE  Intent.FILL_IN_ACTION  Intent.FILL_IN_DATA  Intent.FILL_IN_CATEGORIES  Intent.FILL_IN_COMPONENT  Intent.FILL_IN_PACKAGE  Intent.FILL_IN_SOURCE_BOUNDS  Intent.FILL_IN_SELECTOR and Intent.FILL_IN_CLIP_DATA |||",PendingIntent The obtained PendingIntent |||,16,"Utility class for constructing synthetic back stacks for cross-task navigation
 on Android 3.0 and newer.

  In API level 11 (Android 3.0/Honeycomb) the recommended conventions for
 app navigation using the back key changed. The back key's behavior is local
 to the current task and does not capture navigation across different tasks.
 Navigating across tasks and easily reaching the previous task is accomplished
 through the ""recents"" UI accessible through the software-provided Recents key
 on the navigation or system bar. On devices with the older hardware button configuration
 the recents UI can be accessed with a long press on the Home key. When crossing from one task stack to another post-Android 3.0
 the application should synthesize a back stack/history for the new task so that
 the user may navigate out of the new task and back to the Launcher by repeated
 presses of the back key. Back key presses should not navigate across task stacks. TaskStackBuilder provides a way to obey the correct conventions
 around cross-task navigation.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
"<android.net.sip.SipAudioCall: void makeCall(SipProfile,SipSession,int)>","Initiates an audio call to the specified profile. The attempt will be
 timed out if the call is not established within timeout seconds
 and Listener#onError will be called.","peerProfile SipProfile : the SIP profile to make the call to |||
sipSession SipSession : the SipSession for carrying out the call |||
timeout int : the timeout value in seconds. Default value (defined by
SIP protocol) is used if timeout is zero or negative. |||",void,9,"Handles an Internet audio call over SIP. You can instantiate this class with  SipManager 
 using  SipManager#makeAudioCall  and   SipManager#takeAudioCall .

  Note:  Using this class require the
    Manifest.permission.INTERNET  and
    Manifest.permission.USE_SIP  permissions. In addition  startAudio()  requires the
    Manifest.permission.RECORD_AUDIO 
    Manifest.permission.ACCESS_WIFI_STATE  and
    Manifest.permission.WAKE_LOCK  permissions; and  setSpeakerMode()  requires the
    Manifest.permission.MODIFY_AUDIO_SETTINGS  permission.",,,,,,,,
<android.view.View: void setBackgroundResource(int)>,"Set the background to a given resource. The resource should refer to
 a Drawable object or 0 to remove the background. Related XML Attributes: android:background",resid int : The identifier of the resource. |||,void,1,"This class represents the basic building block for user interface components. A View
 occupies a rectangular area on the screen and is responsible for drawing and
 event handling. View is the base class for  widgets  which are
 used to create interactive UI components (buttons text fields etc.). The
  ViewGroup  subclass is the base class for  layouts  which
 are invisible containers that hold other Views (or other ViewGroups) and define
 their layout properties.",,,,,,,,
<android.app.Activity: int getTaskId()>,"Return the identifier of the task this activity is in.  This identifier
 will remain the same for the lifetime of the activity.",,int Task identifier an opaque integer. |||,1,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
"<android.view.ViewGroup: void removeViewsInLayout(int,int)>","Removes a range of views during layout. This is useful if in your onLayout() method
 you need to remove more views. Note: do not invoke this method from View.draw(android.graphics.Canvas)  View.onDraw(android.graphics.Canvas)  dispatchDraw(android.graphics.Canvas) or any related method.","start int : the index of the first view to remove from the group |||
count int : the number of views to remove from the group |||",void,1,"A  ViewGroup  is a special view that can contain other views
 (called children.) The view group is the base class for layouts and views
 containers. This class also defines the
  ViewGroup.LayoutParams  class which serves as the base
 class for layouts parameters.
  
 Also see  LayoutParams  for layout attributes.",,,,,,,,
<android.widget.TextView: void endBatchEdit()>,,,void,3,"A user interface element that displays text to the user.
 To provide user-editable text see  EditText .
  
 The following code sample shows a typical use with an XML layout
 and code to modify the contents of the text view:
  
 <LinearLayout
      xmlns:android=""http://schemas.android.com/apk/res/android""
      android:layout_width=""match_parent""
      android:layout_height=""match_parent"">
    <TextView
        android:id=""@+id/text_view_id""
        android:layout_height=""wrap_content""
        android:layout_width=""wrap_content""
        android:text=""@string/hello"" />
 </LinearLayout>
  
 This code sample demonstrates how to modify the contents of the text view
 defined in the previous XML layout:
  
 public class MainActivity extends Activity {

    protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_main);
         final TextView helloTextView = (TextView) findViewById(R.id.text_view_id);
         helloTextView.setText(R.string.user_greeting);
     }
 }
  
 To customize the appearance of TextView see  Styles and Themes .
  XML attributes 
 See  TextView Attributes 
  View Attributes","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
"<android.os.Bundle: void putSparseParcelableArray(String,SparseArray)>","Inserts a SparceArray of Parcelable values into the mapping of this
 Bundle replacing any existing value for the given key.  Either key
 or value may be null.","key String : a String or null
This value may be null . |||
value SparseArray : a SparseArray of Parcelable objects or null
This value may be null . |||",void,1,A mapping from String keys to various  Parcelable  values.,,,,,,,,
"<android.widget.Switch: void setSwitchTextAppearance(Context,int)>","Sets the switch text color size style hint color and highlight color
 from the specified TextAppearance resource. Related XML Attributes: android:switchTextAppearance","context Context |||
resid int |||",void,14,"A Switch is a two-state toggle switch widget that can select between two
 options. The user may drag the ""thumb"" back and forth to choose the selected option
 or simply tap to toggle as if it were a checkbox. The  text 
 property controls the text displayed in the label for the switch whereas the
  off  and  on  text
 controls the text on the thumb. Similarly the
  textAppearance  and the related
 setTypeface() methods control the typeface and style of label text whereas the
  switchTextAppearance  and
 the related setSwitchTypeface() methods control that of the thumb.

  SwitchCompat  is a version of
 the Switch widget which runs on devices back to API 7. See the  Toggle Buttons 
 guide.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.view.View: void buildLayer()>,"Forces this view's layer to be created and this view to be rendered
 into its layer. If this view's layer type is set to LAYER_TYPE_NONE invoking this method will have no effect.

 This method can for instance be used to render a view into its layer before
 starting an animation. If this view is complex rendering into the layer
 before starting the animation will avoid skipping frames.",,void,12,"This class represents the basic building block for user interface components. A View
 occupies a rectangular area on the screen and is responsible for drawing and
 event handling. View is the base class for  widgets  which are
 used to create interactive UI components (buttons text fields etc.). The
  ViewGroup  subclass is the base class for  layouts  which
 are invisible containers that hold other Views (or other ViewGroups) and define
 their layout properties.",,,,,,,,
"<android.accounts.AccountAuthenticatorResponse: void onError(int,String)>",,"errorCode int |||
errorMessage String |||",void,5,Object used to communicate responses back to the AccountManager,,,,,,,,
<android.net.sip.SipManager: SipManager newInstance(Context)>,Creates a manager instance. Returns null if SIP API is not supported.,context Context : application context for creating the manager object |||,SipManager the manager instance or null if SIP API is not supported |||,9,"Provides APIs for SIP tasks such as initiating SIP connections and provides access to related
 SIP services. This class is the starting point for any SIP actions. You can acquire an instance
 of it with  newInstance() . The APIs in this class allows you to: Create a  SipSession  to get ready for making calls or listen for incoming calls. See
  createSipSession()  and  getSessionFor() . Initiate and receive generic SIP calls or audio-only SIP calls. Generic SIP calls may
 be video audio or other and are initiated with  open() . Audio-only SIP calls
 should be handled with a  SipAudioCall  which you can acquire with  makeAudioCall()  and  takeAudioCall() . Register and unregister with a SIP service provider with
       register()  and  unregister() . Verify session connectivity with  isOpened()  and
       isRegistered() . Note:  Not all Android-powered devices support VOIP calls using
 SIP. You should always call  isVoipSupported()  to verify that the device supports VOIP calling and  isApiSupported()  to verify that the device supports
 the SIP APIs. Your application must also request the  Manifest.permission.INTERNET  and  Manifest.permission.USE_SIP 
 permissions.",,,,,,,,
"<android.nfc.Tag: void writeToParcel(Parcel,int)>",Flatten this object in to a Parcel.,"dest Parcel : The Parcel in which the object should be written. |||
flags int : Additional flags about how the object should be written.
May be 0 or Parcelable.PARCELABLE_WRITE_RETURN_VALUE .
Value is either 0 or a combination of Parcelable.PARCELABLE_WRITE_RETURN_VALUE and android.os.Parcelable.PARCELABLE_ELIDE_DUPLICATES |||",void,10,"Represents an NFC tag that has been discovered.
  Tag  is an immutable object that represents the state of a NFC tag at
 the time of discovery. It can be used as a handle to  TagTechnology  classes
 to perform advanced operations or directly queried for its ID via  getId()  and the
 set of technologies it contains via  getTechList() . Arrays passed to and
 returned by this class are  not  cloned so be careful not to modify them.
  
 A new tag object is created every time a tag is discovered (comes into range) even
 if it is the same physical tag. If a tag is removed and then returned into range then
 only the most recent tag object can be successfully used to create a  TagTechnology .

  Tag Dispatch Tag NfcAdapter#EXTRA_TAG Intent Context#startActivity The Tag dispatch mechanism was designed to give a high probability of dispatching
 a tag to the correct activity without showing the user an activity chooser dialog.
 This is important for NFC interactions because they are very transient -- if a user has to
 move the Android device to choose an application then the connection will likely be broken.

  1. Foreground activity dispatch NfcAdapter#enableForegroundDispatch NfcAdapter#enableForegroundDispatch 2. NDEF data dispatch NdefRecord NdefMessage Context#startActivity NfcAdapter#ACTION_NDEF_DISCOVERED NfcAdapter#ACTION_NDEF_DISCOVERED NfcAdapter#ACTION_NDEF_DISCOVERED 3. Tag Technology dispatch Context#startActivity NfcAdapter#ACTION_TECH_DISCOVERED TagTechnology android.nfc.tech NfcAdapter#ACTION_TECH_DISCOVERED 4. Fall-back dispatch Context#startActivity NfcAdapter#ACTION_TAG_DISCOVERED NfcAdapter#ACTION_TAG_DISCOVERED NFC Tag Background 
 Tags can have a wide range of capabilities. Simple tags just offer read/write semantics
 and contain some one time
 programmable areas to make read-only. More complex tags offer math operations
 and per-sector access control and authentication. The most sophisticated tags
 contain operating environments allowing complex interactions with the
 code executing on the tag. Use  TagTechnology  classes to access a broad
 range of capabilities available in NFC tags.","Provides access to Near Field Communication (NFC) functionality allowing applications to read
 NDEF message in NFC tags. A ""tag"" may actually be another device that appears as a tag. For more information see the
  Near Field Communication  guide. Here's a summary of the classes: NfcManager This is the high level manager used to obtain this device's  NfcAdapter . You can
 acquire an instance using  getSystemService(Class ) . NfcAdapter This represents the device's NFC adapter which is your entry-point to performing NFC
 operations. You can acquire an instance with  getDefaultAdapter()  or
  getDefaultAdapter(android.content.Context) . NdefMessage Represents an NDEF data message which is the standard format in which ""records""
 carrying data are transmitted between devices and tags. Your application can receive these
 messages from an  ACTION_TAG_DISCOVERED  intent. NdefRecord Represents a record which is delivered in a  NdefMessage  and describes the
 type of data being shared and carries the data itself. Note: 
 Not all Android-powered devices provide NFC functionality.",,,,,,,
<android.hardware.display.DisplayManager: Display getDisplays()>,Gets all currently valid logical displays.,,Display[] An array containing all displays. |||,17,Manages the properties of attached displays.,,,,,,,,
<android.content.res.TypedArray: CharSequence getText(int)>,"Retrieves the styled string value for the attribute at index . If the attribute is not a string this method will attempt to coerce
 it to a string.",index int : Index of attribute to retrieve. |||,"CharSequence CharSequence holding string data. May be styled. Returns null if the attribute is not defined or could not be
         coerced to a string. |||",1,"Container for an array of values that were retrieved with
  Resources.Theme#obtainStyledAttributes(AttributeSet int[] int int) 
 or  Resources#obtainAttributes .  Be
 sure to call  recycle()  when done with them.

 The indices used to retrieve values from this structure correspond to
 the positions of the attributes given to obtainStyledAttributes.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
"<android.content.ContextWrapper: void grantUriPermission(String,Uri,int)>","Grant permission to access a specific Uri to another package regardless
 of whether that package has general permission to access the Uri's
 content provider.  This can be used to grant specific temporary
 permissions typically in response to user interaction (such as the
 user opening an attachment that you would like someone else to
 display). Normally you should use Intent#FLAG_GRANT_READ_URI_PERMISSION or Intent#FLAG_GRANT_WRITE_URI_PERMISSION with the Intent being used to
 start an activity instead of this function directly.  If you use this
 function directly you should be sure to call revokeUriPermission(Uri int) when the target should no longer be allowed
 to access it. To succeed the content provider owning the Uri must have set the grantUriPermissions attribute in its manifest or included the <grant-uri-permissions> tag.","toPackage String : The package you would like to allow to access the Uri. |||
uri Uri : The Uri you would like to grant access to. |||
modeFlags int : The desired access modes.
Value is either 0 or a combination of Intent.FLAG_GRANT_READ_URI_PERMISSION  Intent.FLAG_GRANT_WRITE_URI_PERMISSION  Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION and Intent.FLAG_GRANT_PREFIX_URI_PERMISSION |||",void,1,"Proxying implementation of Context that simply delegates all of its calls to
 another Context.  Can be subclassed to modify behavior without changing
 the original Context.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.os.RecoverySystem: void rebootWipeCache(Context)>,Reboot into the recovery system to wipe the /cache partition.,context Context |||,void,14,"RecoverySystem contains methods for interacting with the Android
 recovery system (the separate partition that can be used to install
 system updates wipe user data etc.)",,,,,,,,
<android.text.style.ImageSpan: Drawable getDrawable()>,"Your subclass must implement this method to provide the bitmap
 to be drawn.  The dimensions of the bitmap must be the same
 from each call to the next.",,Drawable |||,1,"Span that replaces the text it's attached to with a  Drawable  that can be aligned with
 the bottom or with the baseline of the surrounding text. The drawable can be constructed from
 varied sources:
  Bitmap  - see  ImageSpan(android.content.Context android.graphics.Bitmap)  and
  ImageSpan(android.content.Context android.graphics.Bitmap int) Drawable  - see  ImageSpan(android.graphics.drawable.Drawable int) resource id - see  ImageSpan(android.content.Context int int) Uri  - see  ImageSpan(android.content.Context android.net.Uri int) DynamicDrawableSpan#ALIGN_BOTTOM 
 For example an  ImagedSpan  can be used like this:
  
 SpannableString string = new SpannableString(""Bottom: span.\nBaseline: span."");
 // using the default alignment: ALIGN_BOTTOM
 string.setSpan(new ImageSpan(this R.mipmap.ic_launcher) 7 8 Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
 string.setSpan(new ImageSpan(this R.mipmap.ic_launcher DynamicDrawableSpan.ALIGN_BASELINE)
 22 23 Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
  Text with  ImageSpan s aligned bottom and baseline.","Provides classes used to view or change the style of a span of text in a View object.
 The classes with a subclass Standard are passed in to  SpannableString.setSpan()  or  SpannableStringBuilder.setSpan()  to add a new styled span to a string in a View object.",,,,,,,
<android.widget.ProgressBar: void setSecondaryProgress(int)>,"Set the current secondary progress to the specified value. Does not do
 anything if the progress bar is in indeterminate mode.",secondaryProgress int : the new secondary progress between getMin() and getMax() |||,void,1,"A user interface element that indicates the progress of an operation.
 Progress bar supports two modes to represent progress: determinate and indeterminate. For
 a visual overview of the difference between determinate and indeterminate progress modes see
  
 Progress & activity .
 Display progress bars to a user in a non-interruptive way.
 Show the progress bar in your app's user interface or in a notification
 instead of within a dialog.
  Indeterminate Progress 
 Use indeterminate mode for the progress bar when you do not know how long an
 operation will take.
 Indeterminate mode is the default for progress bar and shows a cyclic animation without a
 specific amount of progress indicated.
 The following example shows an indeterminate progress bar:
  
 <ProgressBar
      android:id=""@+id/indeterminateBar""
      android:layout_width=""wrap_content""
      android:layout_height=""wrap_content""
      />
  Determinate Progress 
 Use determinate mode for the progress bar when you want to show that a specific quantity of
 progress has occurred.
 For example the percent remaining of a file being retrieved the amount records in
 a batch written to database or the percent remaining of an audio file that is playing.
  
 To indicate determinate progress you set the style of the progress bar to
  R.style.Widget_ProgressBar_Horizontal  and set the amount of progress.
 The following example shows a determinate progress bar that is 25% complete:
  
 <ProgressBar
      android:id=""@+id/determinateBar""
      style=""@android:style/Widget.ProgressBar.Horizontal""
      android:layout_width=""wrap_content""
      android:layout_height=""wrap_content""
      android:progress=""25""/>
  setProgress(int) incrementProgressBy(int) android:max Other progress bar styles provided by the system include: Widget.ProgressBar.Horizontal Widget.ProgressBar.Small Widget.ProgressBar.Large Widget.ProgressBar.Inverse Widget.ProgressBar.Small.Inverse Widget.ProgressBar.Large.Inverse The ""inverse"" styles provide an inverse color scheme for the spinner which may be necessary
 if your application uses a light colored theme (a white background). XML attributes 
 See  ProgressBar Attributes 
  View Attributes","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
"<android.content.Intent: Intent parseIntent(Resources,XmlPullParser,AttributeSet)>","Parses the ""intent"" element (and its children) from XML and instantiates
 an Intent object.  The given XML parser should be located at the tag
 where parsing should start (often named ""intent"") from which the
 basic action data type and package and class name will be
 retrieved.  The function will then parse in to any child elements
 looking for tags to add categories and to attach extra data
 to the intent.","resources Resources : The Resources to use when inflating resources.
This value cannot be null . |||
parser XmlPullParser : The XML parser pointing at an ""intent"" tag.
This value cannot be null . |||
attrs AttributeSet : The AttributeSet interface for retrieving extended
attribute data at the current parser location. |||","Intent An Intent object matching the XML data.
 This value cannot be null . |||",1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.webkit.WebView: void onPause()>,"Does a best-effort attempt to pause any processing that can be paused
 safely such as animations and geolocation. Note that this call
 does not pause JavaScript. To pause JavaScript globally use pauseTimers() .

 To resume WebView call onResume() .",,void,11,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",,,,,,,
"<android.app.PendingIntent: PendingIntent getActivities(Context,int,Intent,int,Bundle)>","Like getActivity(android.content.Context int android.content.Intent int) but allows an
 array of Intents to be supplied.  The last Intent in the array is
 taken as the primary key for the PendingIntent like the single Intent
 given to getActivity(android.content.Context int android.content.Intent int) .  Upon sending
 the resulting PendingIntent all of the Intents are started in the same
 way as they would be by passing them to Context#startActivities(Intent[]) . The first intent in the array will be started outside of the context of an
 existing activity so you must use the Intent#FLAG_ACTIVITY_NEW_TASK launch flag in the Intent.  (Activities after
 the first in the array are started in the context of the previous activity
 in the array so FLAG_ACTIVITY_NEW_TASK is not needed nor desired for them.) The last intent in the array represents the key for the
 PendingIntent.  In other words it is the significant element for matching
 (as done with the single intent given to getActivity(android.content.Context int android.content.Intent int) its content will be the subject of replacement by send(android.content.Context int android.content.Intent) and FLAG_UPDATE_CURRENT etc.
 This is because it is the most specific of the supplied intents and the
 UI the user actually sees when the intents are started. For security reasons the Intent objects
 you supply here should almost always be explicit intents that is specify an explicit component to be delivered to through Intent#setClass(android.content.Context Class)","context Context : The Context in which this PendingIntent should start
the activity. |||
requestCode int : Private request code for the sender |||
intents Intent : Array of Intents of the activities to be launched.
This value cannot be null . |||
flags int : May be FLAG_ONE_SHOT  FLAG_NO_CREATE  FLAG_CANCEL_CURRENT  FLAG_UPDATE_CURRENT  FLAG_IMMUTABLE or any of the flags as supported by Intent#fillIn to control which unspecified parts
of the intent that can be supplied when the actual send happens.
Value is either 0 or a combination of FLAG_ONE_SHOT  FLAG_NO_CREATE  FLAG_CANCEL_CURRENT  FLAG_UPDATE_CURRENT  FLAG_IMMUTABLE  Intent.FILL_IN_ACTION  Intent.FILL_IN_DATA  Intent.FILL_IN_CATEGORIES  Intent.FILL_IN_COMPONENT  Intent.FILL_IN_PACKAGE  Intent.FILL_IN_SOURCE_BOUNDS  Intent.FILL_IN_SELECTOR and Intent.FILL_IN_CLIP_DATA |||
options Bundle : This value may be null . |||","PendingIntent Returns an existing or new PendingIntent matching the given
 parameters.  May return null only if FLAG_NO_CREATE has been
 supplied. |||",16,"A description of an Intent and target action to perform with it.  Instances
 of this class are created with  getActivity(Context int Intent int)   getActivities(Context int Intent[] int) 
  getBroadcast(Context int Intent int)  and  getService(Context int Intent int) ; the returned object can be
 handed to other applications so that they can perform the action you
 described on your behalf at a later time.

  By giving a PendingIntent to another application
 you are granting it the right to perform the operation you have specified
 as if the other application was yourself (with the same permissions and
 identity).  As such you should be careful about how you build the PendingIntent:
 almost always for example the base Intent you supply should have the component
 name explicitly set to one of your own components to ensure it is ultimately
 sent there and nowhere else.

  A PendingIntent itself is simply a reference to a token maintained by
 the system describing the original data used to retrieve it.  This means
 that even if its owning application's process is killed the
 PendingIntent itself will remain usable from other processes that
 have been given it.  If the creating application later re-retrieves the
 same kind of PendingIntent (same operation same Intent action data
 categories and components and same flags) it will receive a PendingIntent
 representing the same token if that is still valid and can thus call
  cancel()  to remove it.

  Because of this behavior it is important to know when two Intents
 are considered to be the same for purposes of retrieving a PendingIntent.
 A common mistake people make is to create multiple PendingIntent objects
 with Intents that only vary in their ""extra"" contents expecting to get
 a different PendingIntent each time.  This does  not  happen.  The
 parts of the Intent that are used for matching are the same ones defined
 by  Intent#filterEquals(Intent) .  If you use two
 Intent objects that are equivalent as per
  Intent#filterEquals(Intent)  then you will get
 the same PendingIntent for both of them.

  There are two typical ways to deal with this.

  If you truly need multiple distinct PendingIntent objects active at
 the same time (such as to use as two notifications that are both shown
 at the same time) then you will need to ensure there is something that
 is different about them to associate them with different PendingIntents.
 This may be any of the Intent attributes considered by
  Intent#filterEquals(Intent)  or different
 request code integers supplied to  getActivity(Context int Intent int)   getActivities(Context int Intent[] int) 
  getBroadcast(Context int Intent int)  or  getService(Context int Intent int) .

  If you only need one PendingIntent active at a time for any of the
 Intents you will use then you can alternatively use the flags
  FLAG_CANCEL_CURRENT  or  FLAG_UPDATE_CURRENT  to either
 cancel or modify whatever current PendingIntent is associated with the
 Intent you are supplying.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.text.format.DateFormat: DateFormat getDateFormat(Context)>,"Returns a DateFormat object that can format the date
 in short form according to the context's locale.",context Context : the application context |||,DateFormat the DateFormat object that properly formats the date. |||,3,"Utility class for producing strings with formatted date/time.

  Most callers should avoid supplying their own format strings to this
 class'  format  methods and rely on the correctly localized ones
 supplied by the system. This class' factory methods return
 appropriately-localized  DateFormat  instances suitable
 for both formatting and parsing dates. For the canonical documentation
 of format strings see  SimpleDateFormat .

  In cases where the system does not provide a suitable pattern
 this class offers the  getBestDateTimePattern(Locale String)  method.

  The  format  methods in this class implement a subset of Unicode
  UTS #35  patterns.
 The subset currently supported by this class includes the following format characters:
  acdEHhLKkLMmsyz . Up to API level 17 only  adEhkMmszy  were supported.
 Note that this class incorrectly implements  k  as if it were  H  for backwards
 compatibility.

  See  SimpleDateFormat  for more documentation
 about patterns or if you need a more complete or correct implementation.
 Note that the non- format  methods in this class are implemented by
  SimpleDateFormat .","Provides classes used to render or track text and text spans on the screen. You can use these classes to design your own widgets that manage text
 to handle arbitrary text spans for changes or to handle drawing yourself
 for an existing widget. The Span… interfaces and classes are used to create or manage spans of
 text in a View item. You can use these to style the text or background or to
 listen for changes. If creating your own widget extend DynamicLayout to manages
 the actual wrapping and drawing of your text.",,,,,,,
"<android.os.ResultReceiver: void writeToParcel(Parcel,int)>",Flatten this object in to a Parcel.,"out Parcel : The Parcel in which the object should be written. |||
flags int : Additional flags about how the object should be written.
May be 0 or Parcelable.PARCELABLE_WRITE_RETURN_VALUE .
Value is either 0 or a combination of Parcelable.PARCELABLE_WRITE_RETURN_VALUE and android.os.Parcelable.PARCELABLE_ELIDE_DUPLICATES |||",void,3,"Generic interface for receiving a callback result from someone.  Use this
 by creating a subclass and implement  onReceiveResult(int Bundle)  which you can
 then pass to others and send through IPC and receive results they
 supply with  send(int Bundle) .

  Note: the implementation underneath is just a simple wrapper around
 a  Binder  that is used to perform the communication.  This means
 semantically you should treat it as such: this class does not impact process
 lifecycle management (you must be using some higher-level component to tell
 the system that your process needs to continue running) the connection will
 break if your process goes away for any reason etc.",,,,,,,,
"<android.content.ContentResolver: List getPeriodicSyncs(Account,String)>",Get the list of information about the periodic syncs for the given account and authority. This method requires the caller to hold the permission Manifest.permission.READ_SYNC_SETTINGS .,"account Account : the account whose periodic syncs we are querying |||
authority String : the provider whose periodic syncs we are querying |||",List < PeriodicSync > a list of PeriodicSync objects. This list may be empty but will never be null. |||,8,This class provides applications access to the content model.,"Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.widget.BaseExpandableListAdapter: void notifyDataSetInvalidated()>,,,void,1,"Base class for a  ExpandableListAdapter  used to provide data and Views
 from some data to an expandable list view.
  
 Adapters inheriting this class should verify that the base implementations of
  getCombinedChildId(long long)  and  getCombinedGroupId(long) 
 are correct in generating unique IDs from the group/children IDs.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.webkit.WebView: void findAllAsync(String)>,"Finds all instances of find on the page and highlights them
 asynchronously. Notifies any registered FindListener .
 Successive calls to this will cancel any pending searches.","find String : the string to find.
This value cannot be null . |||",void,16,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",,,,,,,
<android.preference.PreferenceFragment: void onStart()>,"Called when the Fragment is visible to the user.  This is generally
 tied to Activity#onStart() of the containing
 Activity's lifecycle. If you override this method you must call through to the
 superclass implementation.",,void,11,"Represents the basic Preference UI building
 block displayed by a  PreferenceActivity  in the form of a
  ListView . This class provides the  View  to be displayed in
 the activity and associates with a  SharedPreferences  to
 store/retrieve the preference data.
  
 When specifying a preference hierarchy in XML each element can point to a
 subclass of  Preference  similar to the view hierarchy and layouts.
  
 This class contains a  key  that will be used as the key into the
  SharedPreferences . It is up to the subclass to decide how to store
 the value.",,,,,,,,
<android.view.View: void setLeft(int)>,"Sets the left position of this view relative to its parent. This method is meant to be called
 by the layout system and should not generally be called otherwise because the property
 may be changed at any time by the layout.",left int : The left of this view in pixels. |||,void,11,"This class represents the basic building block for user interface components. A View
 occupies a rectangular area on the screen and is responsible for drawing and
 event handling. View is the base class for  widgets  which are
 used to create interactive UI components (buttons text fields etc.). The
  ViewGroup  subclass is the base class for  layouts  which
 are invisible containers that hold other Views (or other ViewGroups) and define
 their layout properties.",,,,,,,,
"<android.view.inputmethod.InputConnectionWrapper: CharSequence getTextBeforeCursor(int,int)>","Get n characters of text before the current cursor
 position. This method may fail either if the input connection has
 become invalid (such as its process crashing) or the editor is
 taking too long to respond with the text (it is given a couple
 seconds to return). In either case null is returned. This
 method does not affect the text in the editor in any way nor
 does it affect the selection or composing spans. If GET_TEXT_WITH_STYLES is supplied as flags the
 editor should return a SpannableString with all the spans set on the text. IME authors: please consider this will
 trigger an IPC round-trip that will take some time. Assume this
 method consumes a lot of time. Also please keep in mind the
 Editor may choose to return less characters than requested even
 if they are available for performance reasons. If you are using
 this to get the initial text around the cursor you may consider
 using EditorInfo#getInitialTextBeforeCursor(int int)  EditorInfo#getInitialSelectedText(int) and EditorInfo#getInitialTextAfterCursor(int int) to prevent IPC costs. Editor authors: please be careful of race
 conditions in implementing this call. An IME can make a change
 to the text and use this method right away; you need to make
 sure the returned value is consistent with the result of the
 latest edits. Also you may return less than n characters if performance
 dictates so but keep in mind IMEs are relying on this for many
 functions: you should not for example limit the returned value to
 the current line and specifically do not return 0 characters unless
 the cursor is really at the start of the text.","n int : The expected length of the text. |||
flags int : Supplies additional options controlling how the text is
returned. May be either 0 or InputConnection.GET_TEXT_WITH_STYLES . |||","CharSequence the text before the cursor position; the length of the
 returned text might be less than n . |||",3,Wrapper class for proxying calls to another InputConnection.  Subclass and have fun!,,,,,,,,
"<android.location.LocationManager: void requestSingleUpdate(String,LocationListener,Looper)>","This method was deprecated
      in API level 30. Use getCurrentLocation(java.lang.String android.os.CancellationSignal java.util.concurrent.Executor java.util.function.Consumer) instead as it does not carry a risk of extreme battery drain. Register for a single location update using the named provider and a callback. See requestLocationUpdates(java.lang.String long float android.location.LocationListener android.os.Looper) for
 more detail on how to use this method. Requires Manifest.permission.ACCESS_COARSE_LOCATION or Manifest.permission.ACCESS_FINE_LOCATION","provider String : a provider listed by getAllProviders() This value cannot be null . |||
listener LocationListener : the listener to receive location updates
This value cannot be null . |||
looper Looper : the looper handling listener callbacks or null to use the looper of the
calling thread
This value may be null . |||",void,9,"A data class representing a geographic location.

  A location can consist of a latitude longitude timestamp
 and other information such as bearing altitude and velocity.

  All locations generated by the  LocationManager  are
 guaranteed to have a valid latitude longitude and timestamp
 (both UTC time and elapsed real-time since boot) all other
 parameters are optional.","Contains the framework API classes that define Android location-based and
 	related services. This API is not the recommended method for accessing Android location. 
 The
  Google Location Services API 
 part of Google Play services is the preferred way to add location-awareness to
 your app. It offers a simpler API higher accuracy low-power geofencing and
 more. If you are currently using the android.location API you are strongly
 encouraged to switch to the Google Location Services API as soon as
 possible.
  
 To learn more about the Google Location Services API see the
  Location API overview .",,,,,,,
<android.view.Display: void getRectSize(Rect)>,"This method was deprecated
      in API level 30. Use WindowMetrics#getBounds() to get the dimensions of the application
 window area. Gets the size of the display as a rectangle in pixels.",outSize Rect : A Rect object to receive the size information. |||,void,13,"Provides information about the size and density of a logical display.
  
 The display area is described in two different ways.
  The application display area specifies the part of the display that may contain
 an application window excluding the system decorations.  The application display area may
 be smaller than the real display area because the system subtracts the space needed
 for decor elements such as the status bar.  Use the following methods to query the
 application display area:  getSize(Point)   getRectSize(Rect)  and  getMetrics(DisplayMetrics) . The real display area specifies the part of the display that contains content
 including the system decorations.  Even so the real display area may be smaller than the
 physical size of the display if the window manager is emulating a smaller display
 using (adb shell wm size).  Use the following methods to query the
 real display area:  getRealSize(Point)   getRealMetrics(DisplayMetrics) . 
 A logical display does not necessarily represent a particular physical display device
 such as the built-in screen or an external monitor.  The contents of a logical
 display may be presented on one or more physical displays according to the devices
 that are currently attached and whether mirroring has been enabled.",,,,,,,,
<android.accounts.AccountAuthenticatorActivity: void finish()>,Sends the result or a Constants.ERROR_CODE_CANCELED error if a result isn't present.,,void,5,"Base class for implementing an Activity that is used to help implement an
 AbstractAccountAuthenticator. If the AbstractAccountAuthenticator needs to use an activity
 to handle the request then it can have the activity extend AccountAuthenticatorActivity.
 The AbstractAccountAuthenticator passes in the response to the intent using the following:
  
      intent.putExtra( AccountManager#KEY_ACCOUNT_AUTHENTICATOR_RESPONSE  response);
  setAccountAuthenticatorResult(android.os.Bundle) AccountManager#ERROR_CODE_CANCELED",,,,,,,,
<android.widget.DialerFilter: void clearText()>,Clears both the digits and the filter text.,,void,1,"This widget is a layout that contains several specifically-named child views that
 handle keyboard entry interpreted as standard phone dialpad digits.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.webkit.WebView: void removeJavascriptInterface(String)>,"Removes a previously injected Java object from this WebView. Note that
 the removal will not be reflected in JavaScript until the page is next
 (re)loaded. See addJavascriptInterface(Object String) .","name String : the name used to expose the object in JavaScript
This value cannot be null . |||",void,11,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",,,,,,,
"<android.location.Geocoder: List getFromLocationName(String,int)>","Returns an array of Addresses that are known to describe the
 named location which may be a place name such as ""Dalvik
 Iceland"" an address such as ""1600 Amphitheatre Parkway
 Mountain View CA"" an airport code such as ""SFO"" etc..  The
 returned addresses will be localized for the locale provided to
 this class's constructor. The query will block and returned values will be obtained by means of a network lookup.
 The results are a best guess and are not guaranteed to be meaningful or
 correct. It may be useful to call this method from a thread separate from your
 primary UI thread.","locationName String : a user-supplied description of a location |||
maxResults int : max number of results to return. Smaller numbers (1 to 5) are recommended |||","List < Address > a list of Address objects. Returns null or empty list if no matches were
 found or there is no backend service available. |||",1,"A class for handling geocoding and reverse geocoding.  Geocoding is
 the process of transforming a street address or other description
 of a location into a (latitude longitude) coordinate.  Reverse
 geocoding is the process of transforming a (latitude longitude)
 coordinate into a (partial) address.  The amount of detail in a
 reverse geocoded location description may vary for example one
 might contain the full street address of the closest building while
 another might contain only a city name and postal code.

 The Geocoder class requires a backend service that is not included in
 the core android framework.  The Geocoder query methods will return an
 empty list if there no backend service in the platform.  Use the
 isPresent() method to determine whether a Geocoder implementation
 exists.","Contains the framework API classes that define Android location-based and
 	related services. This API is not the recommended method for accessing Android location. 
 The
  Google Location Services API 
 part of Google Play services is the preferred way to add location-awareness to
 your app. It offers a simpler API higher accuracy low-power geofencing and
 more. If you are currently using the android.location API you are strongly
 encouraged to switch to the Google Location Services API as soon as
 possible.
  
 To learn more about the Google Location Services API see the
  Location API overview .",,,,,,,
"<android.widget.AbsListView: void smoothScrollBy(int,int)>",Smoothly scroll by distance pixels over duration milliseconds.,"distance int : Distance to scroll in pixels. |||
duration int : Duration of the scroll animation in milliseconds. |||",void,8,"Base class that can be used to implement virtualized lists of items. A list does
 not have a spatial definition here. For instance subclasses of this class can
 display the content of the list in a grid in a carousel as stack etc.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.widget.TextView: void setError(CharSequence)>,"Sets the right-hand compound drawable of the TextView to the ""error""
 icon and sets an error message that will be displayed in a popup when
 the TextView has focus.  The icon and error message will be reset to
 null when any key events cause changes to the TextView's text.  If the error is null the error message and icon
 will be cleared.",error CharSequence |||,void,1,"A user interface element that displays text to the user.
 To provide user-editable text see  EditText .
  
 The following code sample shows a typical use with an XML layout
 and code to modify the contents of the text view:
  
 <LinearLayout
      xmlns:android=""http://schemas.android.com/apk/res/android""
      android:layout_width=""match_parent""
      android:layout_height=""match_parent"">
    <TextView
        android:id=""@+id/text_view_id""
        android:layout_height=""wrap_content""
        android:layout_width=""wrap_content""
        android:text=""@string/hello"" />
 </LinearLayout>
  
 This code sample demonstrates how to modify the contents of the text view
 defined in the previous XML layout:
  
 public class MainActivity extends Activity {

    protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_main);
         final TextView helloTextView = (TextView) findViewById(R.id.text_view_id);
         helloTextView.setText(R.string.user_greeting);
     }
 }
  
 To customize the appearance of TextView see  Styles and Themes .
  XML attributes 
 See  TextView Attributes 
  View Attributes","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.media.AudioManager: int getStreamMaxVolume(int)>,Returns the maximum volume index for a particular stream.,streamType int : The stream type whose maximum volume index is returned. |||,int The maximum valid volume index for the stream. |||,1,AudioManager provides access to volume and ringer mode control.,"The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",,,,,,,
<android.widget.RadioGroup: void clearCheck()>,"Clears the selection. When the selection is cleared no radio button
 in this group is selected and getCheckedRadioButtonId() returns
 null.",,void,1,"This class is used to create a multiple-exclusion scope for a set of radio
 buttons. Checking one radio button that belongs to a radio group unchecks
 any previously checked radio button within the same group. Intially all of the radio buttons are unchecked. While it is not possible
 to uncheck a particular radio button the radio group can be cleared to
 remove the checked state. The selection is identified by the unique id of the radio button as defined
 in the XML layout file. XML Attributes See  RadioGroup Attributes 
  LinearLayout Attributes 
  ViewGroup Attributes 
  View Attributes Also see
  LinearLayout.LayoutParams 
 for layout attributes.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.app.ActivityManager: int getLauncherLargeIconSize()>,"Get the preferred launcher icon size. This is used when custom drawables
 are created (e.g. for shortcuts).",,int dimensions of square icons in terms of pixels |||,11,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.widget.RemoteViewsService: IBinder onBind(Intent)>,"Return the communication channel to the service.  May return null if
 clients can not bind to the service.  The returned IBinder is usually for a complex interface
 that has been described using
 aidl . Note that unlike other application components calls on to the
 IBinder interface returned here may not happen on the main thread
 of the process .  More information about the main thread can be found in Processes and
 Threads .","intent Intent : The Intent that was used to bind to this service
as given to Context.bindService .  Note that any extras that were included with
the Intent at that point will not be seen here. |||","IBinder Return an IBinder through which clients can call on to the
         service. |||",11,"A class that describes a view hierarchy that can be displayed in
 another process. The hierarchy is inflated from a layout resource
 file and this class provides some basic operations for modifying
 the content of the inflated hierarchy.

  RemoteViews  is limited to support for the following layouts: AdapterViewFlipper FrameLayout GridLayout GridView LinearLayout ListView RelativeLayout StackView ViewFlipper And the following widgets: AnalogClock Button Chronometer ImageButton ImageView ProgressBar TextClock TextView Descendants of these classes are not supported.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.view.KeyEvent: int getUnicodeChar(int)>,"Gets the Unicode character generated by the specified key and meta
 key state combination. Returns the Unicode character that the specified key would produce
 when the specified meta bits (see MetaKeyKeyListener )
 were active. Returns 0 if the key is not one that is used to type Unicode
 characters. If the return value has bit KeyCharacterMap#COMBINING_ACCENT set the
 key is a ""dead key"" that should be combined with another to
 actually produce a character -- see KeyCharacterMap#getDeadChar --
 after masking with KeyCharacterMap#COMBINING_ACCENT_MASK .",metaState int : The meta key modifier state. |||,int The associated character or combining accent or 0 if none. |||,1,"Object used to report key and button events.
  
 Each key press is described by a sequence of key events.  A key press
 starts with a key event with  ACTION_DOWN .  If the key is held
 sufficiently long that it repeats then the initial down is followed
 additional key events with  ACTION_DOWN  and a non-zero value for
  getRepeatCount() .  The last key event is a  ACTION_UP 
 for the key up.  If the key press is canceled the key up event will have the
  FLAG_CANCELED  flag set.
  
 Key events are generally accompanied by a key code ( getKeyCode() )
 scan code ( getScanCode() ) and meta state ( getMetaState() ).
 Key code constants are defined in this class.  Scan code constants are raw
 device-specific codes obtained from the OS and so are not generally meaningful
 to applications unless interpreted using the  KeyCharacterMap .
 Meta states describe the pressed state of key modifiers
 such as  META_SHIFT_ON  or  META_ALT_ON .
  
 Key codes typically correspond one-to-one with individual keys on an input device.
 Many keys and key combinations serve quite different functions on different
 input devices so care must be taken when interpreting them.  Always use the
  KeyCharacterMap  associated with the input device when mapping keys
 to characters.  Be aware that there may be multiple key input devices active
 at the same time and each will have its own key character map.
  
 As soft input methods can use multiple and inventive ways of inputting text
 there is no guarantee that any key press on a soft keyboard will generate a key
 event: this is left to the IME's discretion and in fact sending such events is
 discouraged.  You should never rely on receiving KeyEvents for any key on a soft
 input method.  In particular the default software keyboard will never send any
 key event to any application targetting Jelly Bean or later and will only send
 events for some presses of the delete and return keys to applications targetting
 Ice Cream Sandwich or earlier.  Be aware that other software input methods may
 never send key events regardless of the version.  Consider using editor actions
 like  EditorInfo.IME_ACTION_DONE  if you need
 specific interaction with the software keyboard as it gives more visibility to
 the user as to how your application will react to key presses.
  
 When interacting with an IME the framework may deliver key events
 with the special action  ACTION_MULTIPLE  that either specifies
 that single repeated key code or a sequence of characters to insert.
  
 In general the framework cannot guarantee that the key events it delivers
 to a view always constitute complete key sequences since some events may be dropped
 or modified by containing views before they are delivered.  The view implementation
 should be prepared to handle  FLAG_CANCELED  and should tolerate anomalous
 situations such as receiving a new  ACTION_DOWN  without first having
 received an  ACTION_UP  for the prior key press.
  
 Refer to  InputDevice  for more information about how different kinds of
 input devices and sources represent keys and buttons.",,,,,,,,
<android.widget.TextView: void setKeyListener(KeyListener)>,"Sets the key listener to be used with this TextView.  This can be null
 to disallow user input.  Note that this method has significant and
 subtle interactions with soft keyboards and other input method:
 see KeyListener#getInputType() for important details.  Calling this method will replace the current
 content type of the text view with the content type returned by the
 key listener. Be warned that if you want a TextView with a key listener or movement
 method not to be focusable or if you want a TextView without a
 key listener or movement method to be focusable you must call View.setFocusable(boolean) again after calling this to get the focusability
 back the way you want it. Related XML Attributes: android:numeric 
android:digits 
android:phoneNumber 
android:inputMethod 
android:capitalize 
android:autoText",input KeyListener |||,void,1,"A user interface element that displays text to the user.
 To provide user-editable text see  EditText .
  
 The following code sample shows a typical use with an XML layout
 and code to modify the contents of the text view:
  
 <LinearLayout
      xmlns:android=""http://schemas.android.com/apk/res/android""
      android:layout_width=""match_parent""
      android:layout_height=""match_parent"">
    <TextView
        android:id=""@+id/text_view_id""
        android:layout_height=""wrap_content""
        android:layout_width=""wrap_content""
        android:text=""@string/hello"" />
 </LinearLayout>
  
 This code sample demonstrates how to modify the contents of the text view
 defined in the previous XML layout:
  
 public class MainActivity extends Activity {

    protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_main);
         final TextView helloTextView = (TextView) findViewById(R.id.text_view_id);
         helloTextView.setText(R.string.user_greeting);
     }
 }
  
 To customize the appearance of TextView see  Styles and Themes .
  XML attributes 
 See  TextView Attributes 
  View Attributes","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
"<android.database.DatabaseUtils: String stringForQuery(SQLiteDatabase,String,String)>","Utility method to run the query on the db and return the value in the
 first column of the first row.","db SQLiteDatabase |||
query String |||
selectionArgs String |||",String |||,1,Static utility methods for dealing with databases and  Cursor s.,"If you need to manage data in a private database use the  android.database.sqlite  classes. These classes are used to manage the  Cursor  object returned from a content provider query. Databases
 are usually created and opened with  openOrCreateDatabase(String int SQLiteDatabase.CursorFactory) 
 To make requests through
 content providers you can use the  content.ContentResolver  class.
  All databases are stored on the device in  /data/data/<package_name>/databases",,,,,,,
"<android.content.Intent: Intent putStringArrayListExtra(String,ArrayList)>","Add extended data to the intent.  The name must include a package
 prefix for example the app com.android.contacts would use names
 like ""com.android.contacts.ShowAll"".","name String : The name of the extra data with package prefix. |||
value ArrayList : The ArrayList data value.
This value may be null . |||","Intent Returns the same Intent object for chaining multiple calls
 into a single statement.

 This value cannot be null . |||",1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.bluetooth.BluetoothAdapter: BluetoothDevice getRemoteDevice(String)>,"Get a BluetoothDevice object for the given Bluetooth hardware
 address. Valid Bluetooth hardware addresses must be upper case in a format
 such as ""00:11:22:33:AA:BB"". The helper checkBluetoothAddress(String) is
 available to validate a Bluetooth address. A BluetoothDevice will always be returned for a valid
 hardware address even if this adapter has never seen that device.",address String : valid Bluetooth MAC address |||,BluetoothDevice |||,5,"Represents the local device Bluetooth adapter. The  BluetoothAdapter 
 lets you perform fundamental Bluetooth tasks such as initiate
 device discovery query a list of bonded (paired) devices
 instantiate a  BluetoothDevice  using a known MAC address and create
 a  BluetoothServerSocket  to listen for connection requests from other
 devices and start a scan for Bluetooth LE devices.

  To get a  BluetoothAdapter  representing the local Bluetooth
 adapter call the  BluetoothManager#getAdapter  function on  BluetoothManager .
 On JELLY_BEAN_MR1 and below you will need to use the static  getDefaultAdapter() 
 method instead.
  
 Fundamentally this is your starting point for all
 Bluetooth actions. Once you have the local adapter you can get a set of
  BluetoothDevice  objects representing all paired devices with
  getBondedDevices() ; start device discovery with
  startDiscovery() ; or create a  BluetoothServerSocket  to
 listen for incoming RFComm connection requests with  listenUsingRfcommWithServiceRecord(java.lang.String java.util.UUID) ; listen for incoming L2CAP Connection-oriented
 Channels (CoC) connection requests with  listenUsingL2capChannel() ; or start a scan for
 Bluetooth LE devices with  startLeScan(android.bluetooth.BluetoothAdapter.LeScanCallback) .
  This class is thread safe. Note: 
 Most methods require the  Manifest.permission.BLUETOOTH 
 permission and some also require the
  Manifest.permission.BLUETOOTH_ADMIN  permission.","Provides classes that manage Bluetooth functionality such as scanning for
 devices connecting with devices and managing data transfer between devices.
 The Bluetooth API supports both ""Classic Bluetooth"" and Bluetooth Low Energy. For more information about Classic Bluetooth see the
  Bluetooth  guide.
 For more information about Bluetooth Low Energy see the
  
 Bluetooth Low Energy  (BLE) guide. The Bluetooth APIs let applications: Scan for other Bluetooth devices (including BLE devices). Query the local Bluetooth adapter for paired Bluetooth devices. Establish RFCOMM channels/sockets. Connect to specified sockets on other devices. Transfer data to and from other devices. Communicate with BLE devices such as proximity sensors heart rate
     monitors fitness devices and so on. Act as a GATT client or a GATT server (BLE). 
 To perform Bluetooth communication using these APIs an application must
 declare the  BLUETOOTH  permission. Some
 additional functionality such as requesting device discovery
 also requires the  BLUETOOTH_ADMIN 
 permission.
  Note: 
 Not all Android-powered devices provide Bluetooth functionality.",,,,,,,
"<android.database.AbstractCursor: void setNotificationUri(ContentResolver,Uri)>",Specifies a content URI to watch for changes.,"cr ContentResolver : The content resolver from the caller's context. |||
notifyUri Uri : The URI to watch for changes. This can be a
specific row URI or a base URI for a whole class of content. |||",void,1,"This is an abstract cursor class that handles a lot of the common code
 that all cursors need to deal with and is provided for convenience reasons.","If you need to manage data in a private database use the  android.database.sqlite  classes. These classes are used to manage the  Cursor  object returned from a content provider query. Databases
 are usually created and opened with  openOrCreateDatabase(String int SQLiteDatabase.CursorFactory) 
 To make requests through
 content providers you can use the  content.ContentResolver  class.
  All databases are stored on the device in  /data/data/<package_name>/databases",,,,,,,
"<android.content.res.ColorStateList: ColorStateList createFromXml(Resources,XmlPullParser)>","This method was deprecated
      in API level 23. Use #createFromXml(Resources XmlPullParser parser Theme) Creates a ColorStateList from an XML document.","r Resources : Resources against which the ColorStateList should be inflated. |||
parser XmlPullParser : Parser for the XML document defining the ColorStateList. |||","ColorStateList A new color state list.

 This value cannot be null . |||",1,"Lets you map  View  state sets to colors.
  ColorStateList s are created from XML resource files defined in the
 ""color"" subdirectory directory of an application's resource directory. The XML file contains
 a single ""selector"" element with a number of ""item"" elements inside. For example:
  
 <selector xmlns:android=""http://schemas.android.com/apk/res/android"">
   <item android:state_focused=""true""
           android:color=""@color/sample_focused"" />
   <item android:state_pressed=""true""
           android:state_enabled=""false""
           android:color=""@color/sample_disabled_pressed"" />
   <item android:state_enabled=""false""
           android:color=""@color/sample_disabled_not_pressed"" />
   <item android:color=""@color/sample_default"" />
 </selector>
  State specs 
 Each item defines a set of state spec and color pairs where the state spec is a series of
 attributes set to either  true  or  false  to represent inclusion or exclusion. If
 an attribute is not specified for an item it may be any value.
  
 For example the following item will be matched whenever the focused state is set; any other
 states may be set or unset:
  
 <item android:state_focused=""true""
         android:color=""@color/sample_focused"" />
  
 Typically a color state list will reference framework-defined state attributes such as
  android:state_focused  or
  android:state_enabled ; however app-defined attributes may
 also be used.
  Note:  The list of state specs will be matched against in the order that they
 appear in the XML file. For this reason more-specific items should be placed earlier in the
 file. An item with no state spec is considered to match any set of states and is generally
 useful as a final item to be used as a default.
  
 If an item with no state spec is placed before other items those items
 will be ignored.

  Item attributes 
 Each item must define an  android:color  attribute which may be
 an HTML-style hex color a reference to a color resource or -- in API 23 and above -- a theme
 attribute that resolves to a color.
  
 Starting with API 23 items may optionally define an  android:alpha 
 attribute to modify the base color's opacity. This attribute takes a either floating-point value
 between 0 and 1 or a theme attribute that resolves as such. The item's overall color is
 calculated by multiplying by the base color's alpha channel by the  alpha  value. For
 example the following item represents the theme's accent color at 50% opacity:
  
 <item android:state_enabled=""false""
         android:color=""?android:attr/colorAccent""
         android:alpha=""0.5"" />
  Developer guide 
 For more information see the guide to
  Color State
 List Resource .","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.view.ViewStub: void setVisibility(int)>,"When visibility is set to View.VISIBLE or View.INVISIBLE  inflate() is invoked and this StubbedView is replaced in its parent
 by the inflated layout resource. After that calls to this function are passed
 through to the inflated view.",visibility int : One of View.VISIBLE  View.INVISIBLE or View.GONE . |||,void,1,"A ViewStub is an invisible zero-sized View that can be used to lazily inflate
 layout resources at runtime.

 When a ViewStub is made visible or when  inflate()   is invoked the layout resource
 is inflated. The ViewStub then replaces itself in its parent with the inflated View or Views.
 Therefore the ViewStub exists in the view hierarchy until  setVisibility(int)  or
  inflate()  is invoked.

 The inflated View is added to the ViewStub's parent with the ViewStub's layout
 parameters. Similarly you can define/override the inflate View's id by using the
 ViewStub's inflatedId property. For instance:

  
     <ViewStub android:id=""@+id/stub""
               android:inflatedId=""@+id/subTree""
               android:layout=""@layout/mySubTree""
               android:layout_width=""120dip""
               android:layout_height=""40dip"" />
  
     ViewStub stub = findViewById(R.id.stub);
     View inflated = stub.inflate();
  inflate()",,,,,,,,
"<android.view.inputmethod.InputMethodInfo: void writeToParcel(Parcel,int)>",Used to package this object into a Parcel .,"dest Parcel : The Parcel to be written. |||
flags int : The flags used for parceling. |||",void,3,"This class is used to specify meta information of an input method.

  It should be defined in an XML resource file with an  <input-method>  element.
 For more information see the guide to
  
 Creating an Input Method .",,,,,,,,
<android.app.WallpaperManager: WallpaperInfo getWallpaperInfo()>,"Returns the information about the wallpaper if the current wallpaper is
 a live wallpaper component. Otherwise if the wallpaper is a static image
 this returns null.",,WallpaperInfo |||,7,"Provides access to the system wallpaper. With WallpaperManager you can
 get the current wallpaper get the desired dimensions for the wallpaper set
 the wallpaper and more.

   An app can check whether wallpapers are supported for the current user by calling
  isWallpaperSupported()  and whether setting of wallpapers is allowed by calling
  isSetWallpaperAllowed() .","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.preference.PreferenceFragment: void addPreferencesFromResource(int)>,"Inflates the given XML resource and adds the preference hierarchy to the current
 preference hierarchy.",preferencesResId int : The XML resource ID to inflate. |||,void,11,"Represents the basic Preference UI building
 block displayed by a  PreferenceActivity  in the form of a
  ListView . This class provides the  View  to be displayed in
 the activity and associates with a  SharedPreferences  to
 store/retrieve the preference data.
  
 When specifying a preference hierarchy in XML each element can point to a
 subclass of  Preference  similar to the view hierarchy and layouts.
  
 This class contains a  key  that will be used as the key into the
  SharedPreferences . It is up to the subclass to decide how to store
 the value.",,,,,,,,
<android.text.format.DateFormat: DateFormat getTimeFormat(Context)>,"Returns a DateFormat object that can format the time according
 to the context's locale and the user's 12-/24-hour clock preference.",context Context : the application context |||,DateFormat the DateFormat object that properly formats the time. |||,3,"Utility class for producing strings with formatted date/time.

  Most callers should avoid supplying their own format strings to this
 class'  format  methods and rely on the correctly localized ones
 supplied by the system. This class' factory methods return
 appropriately-localized  DateFormat  instances suitable
 for both formatting and parsing dates. For the canonical documentation
 of format strings see  SimpleDateFormat .

  In cases where the system does not provide a suitable pattern
 this class offers the  getBestDateTimePattern(Locale String)  method.

  The  format  methods in this class implement a subset of Unicode
  UTS #35  patterns.
 The subset currently supported by this class includes the following format characters:
  acdEHhLKkLMmsyz . Up to API level 17 only  adEhkMmszy  were supported.
 Note that this class incorrectly implements  k  as if it were  H  for backwards
 compatibility.

  See  SimpleDateFormat  for more documentation
 about patterns or if you need a more complete or correct implementation.
 Note that the non- format  methods in this class are implemented by
  SimpleDateFormat .","Provides classes used to render or track text and text spans on the screen. You can use these classes to design your own widgets that manage text
 to handle arbitrary text spans for changes or to handle drawing yourself
 for an existing widget. The Span… interfaces and classes are used to create or manage spans of
 text in a View item. You can use these to style the text or background or to
 listen for changes. If creating your own widget extend DynamicLayout to manages
 the actual wrapping and drawing of your text.",,,,,,,
"<android.webkit.WebView: String getHttpAuthUsernamePassword(String,String)>","This method was deprecated
      in API level 26. Use WebViewDatabase#getHttpAuthUsernamePassword instead Retrieves HTTP authentication credentials for a given host and realm from the WebViewDatabase instance.","host String : the host to which the credentials apply |||
realm String : the realm to which the credentials apply |||","String[] the credentials as a String array if found. The first element
         is the username and the second element is the password. null if
         no credentials are found. |||",1,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",,,,,,,
<android.nfc.tech.NfcBarcode: void close()>,"Disable I/O operations to the tag from this TagTechnology object and release resources. Also causes all blocked I/O operations on other thread to be canceled and
 return with IOException . Requires the Manifest.permission.NFC permission.",,void,-1,"Provides access to NFC-B (ISO 14443-3B) properties and I/O operations on a  Tag .

  Acquire a  NfcB  object using  get(Tag) .
  The primary NFC-B I/O operation is  transceive(byte[]) . Applications must
 implement their own protocol stack on top of  transceive(byte[]) .

  Note:  Methods that perform I/O operations
 require the  Manifest.permission.NFC  permission.","These classes provide access to a tag technology's features which vary by the type
 of tag that is scanned. A scanned tag can support multiple technologies and you can find
 out what they are by calling  getTechList() . For more information on dealing with tag technologies and handling the ones that you care about see
  The Tag Dispatch System .
 The  TagTechnology  interface provides an overview of the
 supported technologies.",,,,,,,
<android.net.sip.SipManager: String getCallId(Intent)>,Gets the call ID from the specified incoming call broadcast intent.,incomingCallIntent Intent : the incoming call broadcast intent |||,String the call ID or null if the intent does not contain it |||,9,"Provides APIs for SIP tasks such as initiating SIP connections and provides access to related
 SIP services. This class is the starting point for any SIP actions. You can acquire an instance
 of it with  newInstance() . The APIs in this class allows you to: Create a  SipSession  to get ready for making calls or listen for incoming calls. See
  createSipSession()  and  getSessionFor() . Initiate and receive generic SIP calls or audio-only SIP calls. Generic SIP calls may
 be video audio or other and are initiated with  open() . Audio-only SIP calls
 should be handled with a  SipAudioCall  which you can acquire with  makeAudioCall()  and  takeAudioCall() . Register and unregister with a SIP service provider with
       register()  and  unregister() . Verify session connectivity with  isOpened()  and
       isRegistered() . Note:  Not all Android-powered devices support VOIP calls using
 SIP. You should always call  isVoipSupported()  to verify that the device supports VOIP calling and  isApiSupported()  to verify that the device supports
 the SIP APIs. Your application must also request the  Manifest.permission.INTERNET  and  Manifest.permission.USE_SIP 
 permissions.",,,,,,,,
"<android.view.textservice.SpellCheckerSession: void getSuggestions(TextInfo,int)>","This method was deprecated
      in API level 16. use SpellCheckerSession#getSentenceSuggestions(TextInfo[] int) instead Get candidate strings for a substring of the specified text.","textInfo TextInfo : text metadata for a spell checker |||
suggestionsLimit int : the maximum number of suggestions that will be returned |||",void,14,"The SpellCheckerSession interface provides the per client functionality of SpellCheckerService.


  Applications In most cases applications that are using the standard
  TextView  or its subclasses will have little they need
 to do to work well with spell checker services.  The main things you need to
 be aware of are:  Properly set the  R.attr.inputType  in your editable
 text views so that the spell checker will have enough context to help the
 user in editing text in them.
  For the rare people amongst us writing client applications that use the spell checker service
 directly you will need to use  getSuggestions(android.view.textservice.TextInfo int)  or
  getSuggestions(android.view.textservice.TextInfo[] int boolean)  for obtaining results from the spell checker
 service by yourself. Security There are a lot of security issues associated with spell checkers
 since they could monitor all the text being sent to them
 through for instance  TextView .
 The Android spell checker framework also allows
 arbitrary third party spell checkers so care must be taken to restrict their
 selection and interactions. Here are some key points about the security architecture behind the
 spell checker framework: Only the system is allowed to directly access a spell checker framework's
  SpellCheckerService  interface via the
  Manifest.permission.BIND_TEXT_SERVICE  permission.  This is
 enforced in the system by not binding to a spell checker service that does
 not require this permission.

  The user must explicitly enable a new spell checker in settings before
 they can be enabled to confirm with the system that they know about it
 and want to make it available for use.",,,,,,,,
"<android.app.admin.DevicePolicyManager: void setPasswordMinimumNumeric(ComponentName,int)>","Called by an application that is administering the device to set the minimum number of
 numerical digits required in the password. After setting this the user will not be able to
 enter a new password that is not at least as restrictive as what has been set. Note that the
 current password will remain until the user has set a new one so the change does not take
 place immediately. To prompt the user for a new password use ACTION_SET_NEW_PASSWORD or ACTION_SET_NEW_PARENT_PROFILE_PASSWORD after
 setting this value. This constraint is only imposed if the administrator has also requested PASSWORD_QUALITY_COMPLEX with setPasswordQuality(ComponentName int) . If an app targeting
 SDK level Build.VERSION_CODES.R and above enforces this constraint without
 settings password quality to PASSWORD_QUALITY_COMPLEX first this method will throw IllegalStateException . The default value is 1. On devices not supporting PackageManager#FEATURE_SECURE_LOCK_SCREEN feature the
 password is always treated as empty. The calling device admin must have requested DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD to be able to call this method; if it has
 not a security exception will be thrown. This method can be called on the DevicePolicyManager instance returned by getParentProfileInstance(android.content.ComponentName) in order to set restrictions on the parent
 profile.","admin ComponentName : Which DeviceAdminReceiver this request is associated with.
This value cannot be null . |||
length int : The new desired minimum number of numerical digits required in the password. A
value of 0 means there is no restriction. |||",void,11,"Public interface for managing policies enforced on a device. Most clients of this class must be
 registered with the system as a  device
 administrator . Additionally a device administrator may be registered as either a profile or
 device owner. A given method is accessible to all device administrators unless the documentation
 for that method specifies that it is restricted to either device or profile owners. Any
 application calling an api may only pass as an argument a device administrator component it
 owns. Otherwise a  SecurityException  will be thrown.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
"<android.view.LayoutInflater: View inflate(XmlPullParser,ViewGroup)>","Inflate a new view hierarchy from the specified xml node. Throws InflateException if there is an error. * Important For performance
 reasons view inflation relies heavily on pre-processing of XML files
 that is done at build time. Therefore it is not currently possible to
 use LayoutInflater with an XmlPullParser over a plain XML file at runtime.","parser XmlPullParser : XML dom node containing the description of the view
hierarchy. |||
root ViewGroup : Optional view to be the parent of the generated hierarchy.
This value may be null . |||","View The root View of the inflated hierarchy. If root was supplied
         this is the root View; otherwise it is the root of the inflated
         XML file. |||",1,"Instantiates a layout XML file into its corresponding  View 
 objects. It is never used directly. Instead use
  Activity.getLayoutInflater()  or
  Context#getSystemService  to retrieve a standard LayoutInflater instance
 that is already hooked up to the current context and correctly configured
 for the device you are running on.

  
 To create a new LayoutInflater with an additional  Factory  for your
 own views you can use  cloneInContext(Context)  to clone an existing
 ViewFactory and then call  setFactory(LayoutInflater.Factory)  on it to include your
 Factory.

  
 For performance reasons view inflation relies heavily on pre-processing of
 XML files that is done at build time. Therefore it is not currently possible
 to use LayoutInflater with an XmlPullParser over a plain XML file at runtime;
 it only works with an XmlPullParser returned from a compiled resource
 (R. something  file.)",,,,,,,,
<android.view.View: void sendAccessibilityEventUnchecked(AccessibilityEvent)>,"This method behaves exactly as sendAccessibilityEvent(int) but
 takes as an argument an empty AccessibilityEvent and does not
 perform a check whether accessibility is enabled. If an AccessibilityDelegate has been specified via calling setAccessibilityDelegate(android.view.View.AccessibilityDelegate) its AccessibilityDelegate#sendAccessibilityEventUnchecked(View AccessibilityEvent) is responsible for handling this call.",event AccessibilityEvent : The event to send. |||,void,4,"This class represents the basic building block for user interface components. A View
 occupies a rectangular area on the screen and is responsible for drawing and
 event handling. View is the base class for  widgets  which are
 used to create interactive UI components (buttons text fields etc.). The
  ViewGroup  subclass is the base class for  layouts  which
 are invisible containers that hold other Views (or other ViewGroups) and define
 their layout properties.",,,,,,,,
<android.content.IntentSender: String getCreatorPackage()>,"Return the package name of the application that created this
 IntentSender that is the identity under which you will actually be
 sending the Intent.  The returned string is supplied by the system so
 that an application can not spoof its package.",,"String The package name of the PendingIntent or null if there is
 none associated with it. |||",17,"A description of an Intent and target action to perform with it.
 The returned object can be
 handed to other applications so that they can perform the action you
 described on your behalf at a later time.

  By giving a IntentSender to another application
 you are granting it the right to perform the operation you have specified
 as if the other application was yourself (with the same permissions and
 identity).  As such you should be careful about how you build the IntentSender:
 often for example the base Intent you supply will have the component
 name explicitly set to one of your own components to ensure it is ultimately
 sent there and nowhere else.

  A IntentSender itself is simply a reference to a token maintained by
 the system describing the original data used to retrieve it.  This means
 that even if its owning application's process is killed the
 IntentSender itself will remain usable from other processes that
 have been given it.  If the creating application later re-retrieves the
 same kind of IntentSender (same operation same Intent action data
 categories and components and same flags) it will receive a IntentSender
 representing the same token if that is still valid.

  Instances of this class can not be made directly but rather must be
 created from an existing  PendingIntent  with
  PendingIntent.getIntentSender() .","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
"<android.view.textservice.SpellCheckerInfo: void writeToParcel(Parcel,int)>",Used to package this object into a Parcel .,"dest Parcel : The Parcel to be written. |||
flags int : The flags used for parceling. |||",void,14,This class is used to specify meta information of a spell checker.,,,,,,,,
"<android.app.Activity: void startActivityFromFragment(Fragment,Intent,int)>","This method was deprecated
      in API level 28. Use androidx.fragment.app.FragmentActivity#startActivityFromFragment(
 androidx.fragment.app.FragmentIntentint) Same as calling startActivityFromFragment(android.app.Fragment android.content.Intent int android.os.Bundle) with no options.","fragment Fragment : The fragment making the call.
This value cannot be null . |||
intent Intent : The intent to start. |||
requestCode int : Reply request code.  < 0 if reply is not requested. |||",void,11,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.media.Ringtone: void play()>,Plays the ringtone.,,void,1,"Ringtone provides a quick method for playing a ringtone notification or
 other similar types of sounds.
  
 For ways of retrieving  Ringtone  objects or to show a ringtone
 picker see  RingtoneManager .","The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",,,,,,,
<android.app.SearchManager: SearchableInfo getSearchableInfo(ComponentName)>,Gets information about a searchable activity.,componentName ComponentName : The activity to get searchable information for. |||,"SearchableInfo Searchable information or null if the activity does not
         exist or is not searchable. |||",8,"This class provides access to the system search services.

  In practice you won't interact with this class directly as search
 services are provided through methods in  Activity 
 and the  ACTION_SEARCH Intent .

  Configuration#UI_MODE_TYPE_WATCH  does not support this system service.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
"<android.content.res.TypedArray: int getInt(int,int)>","Retrieve the integer value for the attribute at index . If the attribute is not an integer this method will attempt to coerce
 it to an integer using Integer#decode(String) .","index int : Index of attribute to retrieve. |||
defValue int : Value to return if the attribute is not defined or
cannot be coerced to an integer. |||","int Integer value of the attribute or defValue if the attribute was
         not defined or could not be coerced to an integer. |||",1,"Container for an array of values that were retrieved with
  Resources.Theme#obtainStyledAttributes(AttributeSet int[] int int) 
 or  Resources#obtainAttributes .  Be
 sure to call  recycle()  when done with them.

 The indices used to retrieve values from this structure correspond to
 the positions of the attributes given to obtainStyledAttributes.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.view.ViewPropertyAnimator: ViewPropertyAnimator x(float)>,"This method will cause the View's x property to be animated to the
 specified value. Animations already running on the property will be canceled.",value float : The value to be animated to. |||,ViewPropertyAnimator This object allowing calls to methods in this class to be chained. |||,12,"This class enables automatic and optimized animation of select properties on View objects.
 If only one or two properties on a View object are being animated then using an
  ObjectAnimator  is fine; the property setters called by ObjectAnimator
 are well equipped to do the right thing to set the property and invalidate the view
 appropriately. But if several properties are animated simultaneously or if you just want a
 more convenient syntax to animate a specific property then ViewPropertyAnimator might be
 more well-suited to the task.

  This class may provide better performance for several simultaneous animations because
 it will optimize invalidate calls to take place only once for several properties instead of each
 animated property independently causing its own invalidation. Also the syntax of using this
 class could be easier to use because the caller need only tell the View object which
 property to animate and the value to animate either to or by and this class handles the
 details of configuring the underlying Animator class and starting it. This class is not constructed by the caller but rather by the View whose properties
 it will animate. Calls to  View.animate()  will return a reference
 to the appropriate ViewPropertyAnimator object for that View.",,,,,,,,
<android.animation.AnimatorSet: void cancel()>,"Cancels the animation. Unlike end()  cancel() causes the animation to
 stop in its tracks sending an Animator.AnimatorListener.onAnimationCancel(Animator) to
 its listeners followed by an Animator.AnimatorListener.onAnimationEnd(Animator) message. This method must be called on the thread that is running the animation. Note that canceling a AnimatorSet also cancels all of the animations that it
 is responsible for.",,void,11,"This class plays a set of  Animator  objects in the specified order. Animations
 can be set up to play together in sequence or after a specified delay.

  There are two different approaches to adding animations to a  AnimatorSet :
 either the  AnimatorSet#playTogether(Animator[])  or
  AnimatorSet#playSequentially(Animator[])  methods can be called to add
 a set of animations all at once or the  AnimatorSet#play(Animator)  can be
 used in conjunction with methods in the  AnimatorSet.Builder 
 class to add animations
 one by one. It is possible to set up a  AnimatorSet  with circular dependencies between
 its animations. For example an animation a1 could be set up to start before animation a2 a2
 before a3 and a3 before a1. The results of this configuration are undefined but will typically
 result in none of the affected animations being played. Because of this (and because
 circular dependencies do not make logical sense anyway) circular dependencies
 should be avoided and the dependency flow of animations should only be in one direction.","These classes provide functionality for the property animation system which allows you
 to animate object properties of any type.  int   float  and hexadecimal
 color values are supported by default. You can animate any other type by telling the system how
 to calculate the values for that given type with a custom  TypeEvaluator .
  For more information see the
  Animation  guide. 
 You can set many different types of interpolators (contained in  android.view.animation )
 specify  keyframes  or group animations to play sequentially
 or simultaneously (with  AnimatorSet ) to further control your animation
 behaviors.",,,,,,,
<android.webkit.WebView: void destroy()>,"Destroys the internal state of this WebView. This method should be called
 after this WebView has been removed from the view system. No other
 methods may be called on this WebView after destroy.",,void,1,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",,,,,,,
"<android.widget.CursorAdapter: View getDropDownView(int,View,ViewGroup)>","Gets a View that displays in the drop down popup
 the data at the specified position in the data set.","position int : index of the item whose view we want. |||
convertView View : the old view to reuse if possible. Note: You should
check that this view is non-null and of an appropriate type before
using. If it is not possible to convert this view to display the
correct data this method can create a new view. |||
parent ViewGroup : the parent that this view will eventually be attached to |||","View a View corresponding to the data at the
         specified position. |||",1,"Adapter that exposes data from a  Cursor  to a
  ListView  widget.
  
 The Cursor must include a column named ""_id"" or this class will not work.
 Additionally using  MergeCursor  with this class will
 not work if the merged Cursors have overlapping values in their ""_id""
 columns.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.content.res.Resources: int getDimensionPixelOffset(int)>,"Retrieve a dimensional for a particular resource ID for use
 as an offset in raw pixels.  This is the same as getDimension(int) except the returned value is converted to
 integer pixels for you.  An offset conversion involves simply
 truncating the base value to an integer.","id int : The desired resource identifier as generated by the aapt
tool. This integer encodes the package type and resource
entry. The value 0 is an invalid identifier. |||","int Resource dimension value multiplied by the appropriate
 metric and truncated to integer pixels. |||",1,"Class for accessing an application's resources.  This sits on top of the
 asset manager of the application (accessible through  getAssets() ) and
 provides a high-level API for getting typed data from the assets.

  The Android resource system keeps track of all non-code assets associated with an
 application. You can use this class to access your application's resources. You can generally
 acquire the  Resources  instance associated with your application
 with  getResources() . The Android SDK tools compile your application's resources into the application binary
 at build time.  To use a resource you must install it correctly in the source tree (inside
 your project's  res/  directory) and build your application.  As part of the build
 process the SDK tools generate symbols for each resource which you can use in your application
 code to access the resources. Using application resources makes it easy to update various characteristics of your
 application without modifying code and—by providing sets of alternative
 resources—enables you to optimize your application for a variety of device configurations
 (such as for different languages and screen sizes). This is an important aspect of developing
 Android applications that are compatible on different types of devices. For more information about using resources see the documentation about  Application Resources .","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
"<android.widget.AbsListView: void onTextChanged(CharSequence,int,int,int)>","For our text watcher that is associated with the text filter. Performs
 the actual filtering as the text changes and takes care of hiding and
 showing the popup displaying the currently entered filter text.","s CharSequence |||
start int |||
before int |||
count int |||",void,1,"Base class that can be used to implement virtualized lists of items. A list does
 not have a spatial definition here. For instance subclasses of this class can
 display the content of the list in a grid in a carousel as stack etc.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.app.admin.DevicePolicyManager: int getMaximumFailedPasswordsForWipe(ComponentName)>,"Retrieve the current maximum number of login attempts that are allowed before the device
 or profile is wiped for a particular admin or all admins that set restrictions on this user
 and its participating profiles. Restrictions on profiles that have a separate challenge are
 not taken into account. This method can be called on the DevicePolicyManager instance
 returned by getParentProfileInstance(android.content.ComponentName) in order to retrieve
 the value for the parent profile. On devices not supporting PackageManager#FEATURE_SECURE_LOCK_SCREEN feature the
 password is always empty and this method returns a default value (0) indicating that the
 policy is not set. Requires the PackageManager#FEATURE_SECURE_LOCK_SCREEN feature which can be detected using PackageManager.hasSystemFeature(String) .","admin ComponentName : The name of the admin component to check or null to aggregate
all admins.
This value may be null . |||",int |||,8,"Public interface for managing policies enforced on a device. Most clients of this class must be
 registered with the system as a  device
 administrator . Additionally a device administrator may be registered as either a profile or
 device owner. A given method is accessible to all device administrators unless the documentation
 for that method specifies that it is restricted to either device or profile owners. Any
 application calling an api may only pass as an argument a device administrator component it
 owns. Otherwise a  SecurityException  will be thrown.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
"<android.os.Parcel: void readList(List,ClassLoader)>","Read into an existing List object from the parcel at the current
 dataPosition() using the given class loader to load any enclosed
 Parcelables.  If it is null the default class loader is used.","outVal List : This value cannot be null . |||
loader ClassLoader : This value may be null . |||",void,1,"Container for a message (data and object references) that can
 be sent through an IBinder.  A Parcel can contain both flattened data
 that will be unflattened on the other side of the IPC (using the various
 methods here for writing specific types or the general
  Parcelable  interface) and references to live  IBinder 
 objects that will result in the other side receiving a proxy IBinder
 connected with the original IBinder in the Parcel.

  Parcel is  not  a general-purpose
 serialization mechanism.  This class (and the corresponding
  Parcelable  API for placing arbitrary objects into a Parcel) is
 designed as a high-performance IPC transport.  As such it is not
 appropriate to place any Parcel data in to persistent storage: changes
 in the underlying implementation of any of the data in the Parcel can
 render older data unreadable. The bulk of the Parcel API revolves around reading and writing data
 of various types.  There are six major classes of such functions available. Primitives The most basic data functions are for writing and reading primitive
 data types:  writeByte(byte)   readByte()   writeDouble(double) 
  readDouble()   writeFloat(float)   readFloat()   writeInt(int) 
  readInt()   writeLong(long)   readLong() 
  writeString(String)   readString() .  Most other
 data operations are built on top of these.  The given data is written and
 read using the endianess of the host CPU. Primitive Arrays There are a variety of methods for reading and writing raw arrays
 of primitive objects which generally result in writing a 4-byte length
 followed by the primitive data items.  The methods for reading can either
 read the data into an existing array or create and return a new array.
 These available types are: writeBooleanArray(boolean[]) 
  readBooleanArray(boolean[])   createBooleanArray() writeByteArray(byte[]) 
  writeByteArray(byte[] int int)   readByteArray(byte[]) 
  createByteArray() writeCharArray(char[])   readCharArray(char[]) 
  createCharArray() writeDoubleArray(double[])   readDoubleArray(double[]) 
  createDoubleArray() writeFloatArray(float[])   readFloatArray(float[]) 
  createFloatArray() writeIntArray(int[])   readIntArray(int[]) 
  createIntArray() writeLongArray(long[])   readLongArray(long[]) 
  createLongArray() writeStringArray(java.lang.String[])   readStringArray(java.lang.String[]) 
  createStringArray() .
  writeSparseBooleanArray(android.util.SparseBooleanArray) 
  readSparseBooleanArray() .
  Parcelables The  Parcelable  protocol provides an extremely efficient (but
 low-level) protocol for objects to write and read themselves from Parcels.
 You can use the direct methods  writeParcelable(android.os.Parcelable int) 
 and  readParcelable(java.lang.ClassLoader)  or
  writeParcelableArray(T[] int)  and
  readParcelableArray(java.lang.ClassLoader)  to write or read.  These
 methods write both the class type and its data to the Parcel allowing
 that class to be reconstructed from the appropriate class loader when
 later reading. There are also some methods that provide a more efficient way to work
 with Parcelables:  writeTypedObject(T int)   writeTypedArray(T[] int) 
  writeTypedList(List )   readTypedObject(Parcelable.Creator ) 
  createTypedArray(Parcelable.Creator )  and  createTypedArrayList(Parcelable.Creator ) .  These methods
 do not write the class information of the original object: instead the
 caller of the read function must know what type to expect and pass in the
 appropriate  Parcelable.Creator  instead to
 properly construct the new object and read its data.  (To more efficient
 write and read a single Parcelable object that is not null you can directly
 call  Parcelable#writeToParcel  and
  Parcelable.Creator#createFromParcel 
 yourself.) Bundles A special type-safe container called  Bundle  is available
 for key/value maps of heterogeneous values.  This has many optimizations
 for improved performance when reading and writing data and its type-safe
 API avoids difficult to debug type errors when finally marshalling the
 data contents into a Parcel.  The methods to use are
  writeBundle(android.os.Bundle)   readBundle()  and
  readBundle(java.lang.ClassLoader) .

  Active Objects An unusual feature of Parcel is the ability to read and write active
 objects.  For these objects the actual contents of the object is not
 written rather a special token referencing the object is written.  When
 reading the object back from the Parcel you do not get a new instance of
 the object but rather a handle that operates on the exact same object that
 was originally written.  There are two forms of active objects available. Binder  objects are a core facility of Android's general cross-process
 communication system.  The  IBinder  interface describes an abstract
 protocol with a Binder object.  Any such interface can be written in to
 a Parcel and upon reading you will receive either the original object
 implementing that interface or a special proxy implementation
 that communicates calls back to the original object.  The methods to use are
  writeStrongBinder(android.os.IBinder) 
  writeStrongInterface(android.os.IInterface)   readStrongBinder() 
  writeBinderArray(android.os.IBinder[])   readBinderArray(android.os.IBinder[]) 
  createBinderArray() 
  writeBinderList(java.util.List)   readBinderList(java.util.List) 
  createBinderArrayList() . FileDescriptor objects representing raw Linux file descriptor identifiers
 can be written and  ParcelFileDescriptor  objects returned to operate
 on the original file descriptor.  The returned file descriptor is a dup
 of the original file descriptor: the object and fd is different but
 operating on the same underlying file stream with the same position etc.
 The methods to use are  writeFileDescriptor(java.io.FileDescriptor) 
  readFileDescriptor() .

  Untyped Containers A final class of methods are for writing and reading standard Java
 containers of arbitrary types.  These all revolve around the
  writeValue(java.lang.Object)  and  readValue(java.lang.ClassLoader)  methods
 which define the types of objects allowed.  The container methods are
  writeArray(java.lang.Object[])   readArray(java.lang.ClassLoader) 
  writeList(java.util.List)   readList(java.util.List java.lang.ClassLoader) 
  readArrayList(java.lang.ClassLoader) 
  writeMap(java.util.Map)   readMap(java.util.Map java.lang.ClassLoader) 
  writeSparseArray(android.util.SparseArray) 
  readSparseArray(java.lang.ClassLoader) .",,,,,,,,
<android.widget.ListPopupWindow: void dismiss()>,Dismiss the popup window.,,void,11,"A ListPopupWindow anchors itself to a host view and displays a
 list of choices.

  ListPopupWindow contains a number of tricky behaviors surrounding
 positioning scrolling parents to fit the dropdown interacting
 sanely with the IME if present and others.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.telephony.TelephonyManager: String getVoiceMailNumber()>,Returns the voice mail number. Return null if it is unavailable. Requires Permission: READ_PHONE_STATE or that the calling app has carrier privileges (see hasCarrierPrivileges() ). Requires Manifest.permission.READ_PHONE_STATE,,String |||,1,"Provides access to information about the telephony services on
 the device. Applications can use the methods in this class to
 determine telephony services and states as well as to access some
 types of subscriber information. Applications can also register
 a listener to receive notification of telephony state changes.
  
 The returned TelephonyManager will use the default subscription for all calls.
 To call an API for a specific subscription use  createForSubscriptionId(int) . e.g.
  
   telephonyManager = defaultSubTelephonyManager.createForSubscriptionId(subId);
  
 Note that access to some telephony information is
 permission-protected. Your application cannot access the protected
 information unless it has the appropriate permissions declared in
 its manifest file. Where permissions apply they are noted in the
 the methods through which you access the protected information.",,,,,,,,
<android.widget.AbsSeekBar: void setMax(int)>,Set the upper range of the progress bar max .,max int : the upper range of this progress bar |||,void,1,AbsSeekBar extends the capabilities of ProgressBar by adding a draggable thumb.,"The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.app.Activity: void setContentView(int)>,"Set the activity content from a layout resource.  The resource will be
 inflated adding all top-level views to the activity.",layoutResID int : Resource ID to be inflated. |||,void,1,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
"<android.text.format.DateFormat: CharSequence format(CharSequence,Date)>","Given a format string and a Date object returns a CharSequence containing
 the requested date.","inFormat CharSequence : the format string as described in DateFormat |||
inDate Date : the date to format |||",CharSequence a CharSequence containing the requested text |||,3,"Utility class for producing strings with formatted date/time.

  Most callers should avoid supplying their own format strings to this
 class'  format  methods and rely on the correctly localized ones
 supplied by the system. This class' factory methods return
 appropriately-localized  DateFormat  instances suitable
 for both formatting and parsing dates. For the canonical documentation
 of format strings see  SimpleDateFormat .

  In cases where the system does not provide a suitable pattern
 this class offers the  getBestDateTimePattern(Locale String)  method.

  The  format  methods in this class implement a subset of Unicode
  UTS #35  patterns.
 The subset currently supported by this class includes the following format characters:
  acdEHhLKkLMmsyz . Up to API level 17 only  adEhkMmszy  were supported.
 Note that this class incorrectly implements  k  as if it were  H  for backwards
 compatibility.

  See  SimpleDateFormat  for more documentation
 about patterns or if you need a more complete or correct implementation.
 Note that the non- format  methods in this class are implemented by
  SimpleDateFormat .","Provides classes used to render or track text and text spans on the screen. You can use these classes to design your own widgets that manage text
 to handle arbitrary text spans for changes or to handle drawing yourself
 for an existing widget. The Span… interfaces and classes are used to create or manage spans of
 text in a View item. You can use these to style the text or background or to
 listen for changes. If creating your own widget extend DynamicLayout to manages
 the actual wrapping and drawing of your text.",,,,,,,
<android.media.RingtoneManager: int getRingtonePosition(Uri)>,Gets the position of a Uri within this RingtoneManager .,ringtoneUri Uri : The Uri to retreive the position of. |||,int The position of the Uri or -1 if it cannot be found. |||,1,"RingtoneManager provides access to ringtones notification and other types
 of sounds. It manages querying the different media providers and combines the
 results into a single cursor. It also provides a  Ringtone  for each
 ringtone. We generically call these sounds ringtones however the
  TYPE_RINGTONE  refers to the type of sounds that are suitable for the
 phone ringer.
  
 To show a ringtone picker to the user use the
  ACTION_RINGTONE_PICKER  intent to launch the picker as a subactivity.","The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",,,,,,,
"<android.app.PendingIntent: PendingIntent getActivity(Context,int,Intent,int,Bundle)>","Retrieve a PendingIntent that will start a new activity like calling Context#startActivity(Intent) .
 Note that the activity will be started outside of the context of an
 existing activity so you must use the Intent#FLAG_ACTIVITY_NEW_TASK launch flag in the Intent. For security reasons the Intent you supply here should almost always be an explicit intent that is specify an explicit component to be delivered to through Intent#setClass(android.content.Context Class)","context Context : The Context in which this PendingIntent should start
the activity. |||
requestCode int : Private request code for the sender |||
intent Intent : Intent of the activity to be launched.
This value cannot be null . |||
flags int : May be FLAG_ONE_SHOT  FLAG_NO_CREATE  FLAG_CANCEL_CURRENT  FLAG_UPDATE_CURRENT or any of the flags as supported by Intent#fillIn to control which unspecified parts
of the intent that can be supplied when the actual send happens.
Value is either 0 or a combination of FLAG_ONE_SHOT  FLAG_NO_CREATE  FLAG_CANCEL_CURRENT  FLAG_UPDATE_CURRENT  FLAG_IMMUTABLE  Intent.FILL_IN_ACTION  Intent.FILL_IN_DATA  Intent.FILL_IN_CATEGORIES  Intent.FILL_IN_COMPONENT  Intent.FILL_IN_PACKAGE  Intent.FILL_IN_SOURCE_BOUNDS  Intent.FILL_IN_SELECTOR and Intent.FILL_IN_CLIP_DATA |||
options Bundle : Additional options for how the Activity should be started.
May be null if there are no options.
This value may be null . |||","PendingIntent Returns an existing or new PendingIntent matching the given
 parameters.  May return null only if FLAG_NO_CREATE has been
 supplied. |||",16,"A description of an Intent and target action to perform with it.  Instances
 of this class are created with  getActivity(Context int Intent int)   getActivities(Context int Intent[] int) 
  getBroadcast(Context int Intent int)  and  getService(Context int Intent int) ; the returned object can be
 handed to other applications so that they can perform the action you
 described on your behalf at a later time.

  By giving a PendingIntent to another application
 you are granting it the right to perform the operation you have specified
 as if the other application was yourself (with the same permissions and
 identity).  As such you should be careful about how you build the PendingIntent:
 almost always for example the base Intent you supply should have the component
 name explicitly set to one of your own components to ensure it is ultimately
 sent there and nowhere else.

  A PendingIntent itself is simply a reference to a token maintained by
 the system describing the original data used to retrieve it.  This means
 that even if its owning application's process is killed the
 PendingIntent itself will remain usable from other processes that
 have been given it.  If the creating application later re-retrieves the
 same kind of PendingIntent (same operation same Intent action data
 categories and components and same flags) it will receive a PendingIntent
 representing the same token if that is still valid and can thus call
  cancel()  to remove it.

  Because of this behavior it is important to know when two Intents
 are considered to be the same for purposes of retrieving a PendingIntent.
 A common mistake people make is to create multiple PendingIntent objects
 with Intents that only vary in their ""extra"" contents expecting to get
 a different PendingIntent each time.  This does  not  happen.  The
 parts of the Intent that are used for matching are the same ones defined
 by  Intent#filterEquals(Intent) .  If you use two
 Intent objects that are equivalent as per
  Intent#filterEquals(Intent)  then you will get
 the same PendingIntent for both of them.

  There are two typical ways to deal with this.

  If you truly need multiple distinct PendingIntent objects active at
 the same time (such as to use as two notifications that are both shown
 at the same time) then you will need to ensure there is something that
 is different about them to associate them with different PendingIntents.
 This may be any of the Intent attributes considered by
  Intent#filterEquals(Intent)  or different
 request code integers supplied to  getActivity(Context int Intent int)   getActivities(Context int Intent[] int) 
  getBroadcast(Context int Intent int)  or  getService(Context int Intent int) .

  If you only need one PendingIntent active at a time for any of the
 Intents you will use then you can alternatively use the flags
  FLAG_CANCEL_CURRENT  or  FLAG_UPDATE_CURRENT  to either
 cancel or modify whatever current PendingIntent is associated with the
 Intent you are supplying.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.app.Instrumentation: void sendKeySync(KeyEvent)>,"Send a key event to the currently focused window/view and wait for it to
 be processed.  Finished at some point after the recipient has returned
 from its event processing though it may not have completely
 finished reacting from the event -- for example if it needs to update
 its display as a result it may still be in the process of doing that.",event KeyEvent : The event to send to the current focus. |||,void,1,"Base class for implementing application instrumentation code.  When running
 with instrumentation turned on this class will be instantiated for you
 before any of the application code allowing you to monitor all of the
 interaction the system has with the application.  An Instrumentation
 implementation is described to the system through an AndroidManifest.xml's
 <instrumentation> tag.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
"<android.view.animation.Animation: void setInterpolator(Context,int)>","Sets the acceleration curve for this animation. The interpolator is loaded as
 a resource from the specified context. Related XML Attributes: android:interpolator","context Context : The application environment |||
resID int : The resource identifier of the interpolator to load |||",void,1,"Abstraction for an Animation that can be applied to Views Surfaces or
 other objects. See the  animation package
 description file .",,,,,,,,
<android.app.LocalActivityManager: void dispatchResume()>,"Called by the container activity in its Activity#onResume so
 that LocalActivityManager can perform the corresponding action on the
 activities it holds.",,void,1,"Helper class for managing multiple running embedded activities in the same
 process. This class is not normally used directly but rather created for
 you as part of the  ActivityGroup  implementation.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
"<android.preference.PreferenceFragment: void onActivityResult(int,int,Intent)>","Receive the result from a previous call to startActivityForResult(android.content.Intent int) .  This follows the
 related Activity API as described there in Activity#onActivityResult(int int Intent) .","requestCode int : The integer request code originally supplied to
startActivityForResult() allowing you to identify who this
result came from. |||
resultCode int : The integer result code returned by the child activity
through its setResult(). |||
data Intent : An Intent which can return result data to the caller
(various data can be attached to Intent ""extras""). |||",void,11,"Represents the basic Preference UI building
 block displayed by a  PreferenceActivity  in the form of a
  ListView . This class provides the  View  to be displayed in
 the activity and associates with a  SharedPreferences  to
 store/retrieve the preference data.
  
 When specifying a preference hierarchy in XML each element can point to a
 subclass of  Preference  similar to the view hierarchy and layouts.
  
 This class contains a  key  that will be used as the key into the
  SharedPreferences . It is up to the subclass to decide how to store
 the value.",,,,,,,,
<android.preference.PreferenceFragment: void onDestroy()>,"Called when the fragment is no longer in use.  This is called
 after onStop() and before onDetach() . If you override this method you must call through to the
 superclass implementation.",,void,11,"Represents the basic Preference UI building
 block displayed by a  PreferenceActivity  in the form of a
  ListView . This class provides the  View  to be displayed in
 the activity and associates with a  SharedPreferences  to
 store/retrieve the preference data.
  
 When specifying a preference hierarchy in XML each element can point to a
 subclass of  Preference  similar to the view hierarchy and layouts.
  
 This class contains a  key  that will be used as the key into the
  SharedPreferences . It is up to the subclass to decide how to store
 the value.",,,,,,,,
"<android.view.LayoutInflater: View createView(String,String,AttributeSet)>","Low-level function for instantiating a view by name. This attempts to
 instantiate a view class of the given name found in this
 LayoutInflater's ClassLoader. To use an explicit Context in the View
 constructor use createView(android.content.Context java.lang.String java.lang.String android.util.AttributeSet) instead. There are two things that can happen in an error case: either the
 exception describing the error will be thrown or a null will be
 returned. You must deal with both possibilities -- the former will happen
 the first time createView() is called for a class of a particular name
 the latter every time there-after for that class name.","name String : The full name of the class to be instantiated. |||
prefix String |||
attrs AttributeSet : The XML attributes supplied for this instance. |||",View View The newly instantiated view or null. |||,1,"Instantiates a layout XML file into its corresponding  View 
 objects. It is never used directly. Instead use
  Activity.getLayoutInflater()  or
  Context#getSystemService  to retrieve a standard LayoutInflater instance
 that is already hooked up to the current context and correctly configured
 for the device you are running on.

  
 To create a new LayoutInflater with an additional  Factory  for your
 own views you can use  cloneInContext(Context)  to clone an existing
 ViewFactory and then call  setFactory(LayoutInflater.Factory)  on it to include your
 Factory.

  
 For performance reasons view inflation relies heavily on pre-processing of
 XML files that is done at build time. Therefore it is not currently possible
 to use LayoutInflater with an XmlPullParser over a plain XML file at runtime;
 it only works with an XmlPullParser returned from a compiled resource
 (R. something  file.)",,,,,,,,
<android.os.Environment: File getExternalStorageDirectory()>,"This method was deprecated
      in API level 29. To improve user privacy direct access to shared/external
             storage devices is deprecated. When an app targets Build.VERSION_CODES.Q the path returned
             from this method is no longer directly accessible to apps.
             Apps can continue to access content stored on shared/external
             storage by migrating to alternatives such as Context#getExternalFilesDir(String)  MediaStore or Intent#ACTION_OPEN_DOCUMENT . Return the primary shared/external storage directory. This directory may
 not currently be accessible if it has been mounted by the user on their
 computer has been removed from the device or some other problem has
 happened. You can determine its current state with getExternalStorageState() . Note: don't be confused by the word ""external"" here. This directory
 can better be thought as media/shared storage. It is a filesystem that
 can hold a relatively large amount of data and that is shared across all
 applications (does not enforce permissions). Traditionally this is an SD
 card but it may also be implemented as built-in storage in a device that
 is distinct from the protected internal storage and can be mounted as a
 filesystem on a computer. On devices with multiple users (as described by UserManager )
 each user has their own isolated shared storage. Applications only have
 access to the shared storage for the user they're running as. In devices with multiple shared/external storage directories this
 directory represents the primary storage that the user will interact
 with. Access to secondary storage is available through Context#getExternalFilesDirs(String)  Context#getExternalCacheDirs() and Context#getExternalMediaDirs() . Applications should not directly use this top-level directory in order
 to avoid polluting the user's root namespace. Any files that are private
 to the application should be placed in a directory returned by Context.getExternalFilesDir which the system will take care of deleting
 if the application is uninstalled. Other shared files should be placed in
 one of the directories returned by getExternalStoragePublicDirectory(String) . Writing to this path requires the Manifest.permission.WRITE_EXTERNAL_STORAGE permission
 and starting in Build.VERSION_CODES.KITKAT read
 access requires the Manifest.permission.READ_EXTERNAL_STORAGE permission
 which is automatically granted if you hold the write permission. Starting in Build.VERSION_CODES.KITKAT if your
 application only needs to store internal data consider using Context#getExternalFilesDir(String)  Context#getExternalCacheDir() or Context#getExternalMediaDirs() which require no permissions to
 read or write. This path may change between platform versions so applications should
 only persist relative paths. Here is an example of typical code to monitor the state of external
 storage:",,File |||,1,Provides access to environment variables.,,,,,,,,
<android.text.Layout: float getLineMax(int)>,"Gets the unsigned horizontal extent of the specified line including
 leading margin indent but excluding trailing whitespace.",line int |||,float |||,1,"A base class that manages text layout in visual elements on
 the screen.
  For text that will be edited use a  DynamicLayout 
 which will be updated as the text changes.
 For text that will not change use a  StaticLayout .","Provides classes used to render or track text and text spans on the screen. You can use these classes to design your own widgets that manage text
 to handle arbitrary text spans for changes or to handle drawing yourself
 for an existing widget. The Span… interfaces and classes are used to create or manage spans of
 text in a View item. You can use these to style the text or background or to
 listen for changes. If creating your own widget extend DynamicLayout to manages
 the actual wrapping and drawing of your text.",,,,,,,
<android.app.ProgressDialog: void setMessage(CharSequence)>,,message CharSequence |||,void,1,"A dialog showing a progress indicator and an optional text message or view.
 Only a text message or a view can be used at the same time.

  The dialog can be made cancelable on back key press. The progress range is 0 to  max .","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.view.ViewPropertyAnimator: ViewPropertyAnimator scaleY(float)>,"This method will cause the View's scaleY property to be animated to the
 specified value. Animations already running on the property will be canceled.",value float : The value to be animated to. |||,ViewPropertyAnimator This object allowing calls to methods in this class to be chained. |||,12,"This class enables automatic and optimized animation of select properties on View objects.
 If only one or two properties on a View object are being animated then using an
  ObjectAnimator  is fine; the property setters called by ObjectAnimator
 are well equipped to do the right thing to set the property and invalidate the view
 appropriately. But if several properties are animated simultaneously or if you just want a
 more convenient syntax to animate a specific property then ViewPropertyAnimator might be
 more well-suited to the task.

  This class may provide better performance for several simultaneous animations because
 it will optimize invalidate calls to take place only once for several properties instead of each
 animated property independently causing its own invalidation. Also the syntax of using this
 class could be easier to use because the caller need only tell the View object which
 property to animate and the value to animate either to or by and this class handles the
 details of configuring the underlying Animator class and starting it. This class is not constructed by the caller but rather by the View whose properties
 it will animate. Calls to  View.animate()  will return a reference
 to the appropriate ViewPropertyAnimator object for that View.",,,,,,,,
<android.view.inputmethod.BaseInputConnection: void setComposingSpans(Spannable)>,,text Spannable |||,void,3,"Base class for implementors of the InputConnection interface taking care
 of most of the common behavior for providing a connection to an Editable.
 Implementors of this class will want to be sure to implement
  getEditable()  to provide access to their own editable object and
 to refer to the documentation in  InputConnection .",,,,,,,,
<android.widget.CursorTreeAdapter: void setGroupCursor(Cursor)>,Sets the group Cursor.,"cursor Cursor : The Cursor to set for the group. If there is an existing cursor
it will be closed. |||",void,1,"An adapter that exposes data from a series of  Cursor s to an
  ExpandableListView  widget. The top-level  Cursor  (that is
 given in the constructor) exposes the groups while subsequent  Cursor s
 returned from  getChildrenCursor(android.database.Cursor)  expose children within a
 particular group. The Cursors must include a column named ""_id"" or this class
 will not work.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.test.InstrumentationTestCase: void sendKeys(String)>,"Sends a series of key events through instrumentation and waits for idle. The sequence
 of keys is a string containing the key names as specified in KeyEvent without the
 KEYCODE_ prefix. For instance: sendKeys(""DPAD_LEFT A B C DPAD_CENTER""). Each key can
 be repeated by using the N* prefix. For instance to send two KEYCODE_DPAD_LEFT use
 the following: sendKeys(""2*DPAD_LEFT"").",keysSequence String : The sequence of keys. |||,void,1,A test case that has access to  Instrumentation .,,,,,,,,
"<android.location.Geocoder: List getFromLocationName(String,int,double,double,double,double)>","Returns an array of Addresses that are known to describe the
 named location which may be a place name such as ""Dalvik
 Iceland"" an address such as ""1600 Amphitheatre Parkway
 Mountain View CA"" an airport code such as ""SFO"" etc..  The
 returned addresses will be localized for the locale provided to
 this class's constructor. You may specify a bounding box for the search results by including
 the Latitude and Longitude of the Lower Left point and Upper Right
 point of the box. The query will block and returned values will be obtained by means of a network lookup.
 The results are a best guess and are not guaranteed to be meaningful or
 correct. It may be useful to call this method from a thread separate from your
 primary UI thread.","locationName String : a user-supplied description of a location |||
maxResults int : max number of addresses to return. Smaller numbers (1 to 5) are recommended |||
lowerLeftLatitude double : the latitude of the lower left corner of the bounding box |||
lowerLeftLongitude double : the longitude of the lower left corner of the bounding box |||
upperRightLatitude double : the latitude of the upper right corner of the bounding box |||
upperRightLongitude double : the longitude of the upper right corner of the bounding box |||","List < Address > a list of Address objects. Returns null or empty list if no matches were
 found or there is no backend service available. |||",1,"A class for handling geocoding and reverse geocoding.  Geocoding is
 the process of transforming a street address or other description
 of a location into a (latitude longitude) coordinate.  Reverse
 geocoding is the process of transforming a (latitude longitude)
 coordinate into a (partial) address.  The amount of detail in a
 reverse geocoded location description may vary for example one
 might contain the full street address of the closest building while
 another might contain only a city name and postal code.

 The Geocoder class requires a backend service that is not included in
 the core android framework.  The Geocoder query methods will return an
 empty list if there no backend service in the platform.  Use the
 isPresent() method to determine whether a Geocoder implementation
 exists.","Contains the framework API classes that define Android location-based and
 	related services. This API is not the recommended method for accessing Android location. 
 The
  Google Location Services API 
 part of Google Play services is the preferred way to add location-awareness to
 your app. It offers a simpler API higher accuracy low-power geofencing and
 more. If you are currently using the android.location API you are strongly
 encouraged to switch to the Google Location Services API as soon as
 possible.
  
 To learn more about the Google Location Services API see the
  Location API overview .",,,,,,,
<android.media.AudioManager: void startBluetoothSco()>,"Start bluetooth SCO audio connection. Requires Permission: Manifest.permission.MODIFY_AUDIO_SETTINGS . This method can be used by applications wanting to send and received audio
 to/from a bluetooth SCO headset while the phone is not in call. As the SCO connection establishment can take several seconds
 applications should not rely on the connection to be available when the method
 returns but instead register to receive the intent ACTION_SCO_AUDIO_STATE_UPDATED and wait for the state to be SCO_AUDIO_STATE_CONNECTED . As the ACTION_SCO_AUDIO_STATE_UPDATED intent is sticky the application can check the SCO
 audio state before calling startBluetoothSco() by reading the intent returned by the receiver
 registration. If the state is already CONNECTED no state change will be received via the
 intent after calling startBluetoothSco(). It is however useful to call startBluetoothSco()
 so that the connection stays active in case the current initiator stops the connection. Unless the connection is already active as described above the state will always
 transition from DISCONNECTED to CONNECTING and then either to CONNECTED if the connection
 succeeds or back to DISCONNECTED if the connection fails (e.g no headset is connected). When finished with the SCO connection or if the establishment fails the application must
 call stopBluetoothSco() to clear the request and turn down the bluetooth connection. Even if a SCO connection is established the following restrictions apply on audio
 output streams so that they can be routed to SCO headset: the stream type must be STREAM_VOICE_CALL 
the format must be mono 
the sampling must be 16kHz or 8kHz 
The following restrictions apply on input streams: the format must be mono 
the sampling must be 8kHz 
Note that the phone application always has the priority on the usage of the SCO
 connection for telephony. If this method is called while the phone is in call
 it will be ignored. Similarly if a call is received or sent while an application
 is using the SCO connection the connection will be lost for the application and NOT
 returned automatically when the call ends. NOTE: up to and including API version Build.VERSION_CODES.JELLY_BEAN_MR1 this method initiates a virtual
 voice call to the bluetooth headset.
 After API version Build.VERSION_CODES.JELLY_BEAN_MR2 only a raw SCO audio
 connection is established.",,void,8,AudioManager provides access to volume and ringer mode control.,"The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",,,,,,,
<android.app.admin.DevicePolicyManager: int getPasswordMinimumLetters(ComponentName)>,"Retrieve the current number of letters required in the password
 for a particular admin or all admins that set restrictions on this user
 and its participating profiles. Restrictions on profiles that have
 a separate challenge are not taken into account.
 This is the same value as set by setPasswordMinimumLetters(android.content.ComponentName int) and only applies when the password quality is PASSWORD_QUALITY_COMPLEX . On devices not supporting PackageManager#FEATURE_SECURE_LOCK_SCREEN feature the
 password is always treated as empty. This method can be called on the DevicePolicyManager instance
 returned by getParentProfileInstance(android.content.ComponentName) in order to retrieve
 restrictions on the parent profile.","admin ComponentName : The name of the admin component to check or null to
aggregate all admins.
This value may be null . |||",int The minimum number of letters required in the password. |||,11,"Public interface for managing policies enforced on a device. Most clients of this class must be
 registered with the system as a  device
 administrator . Additionally a device administrator may be registered as either a profile or
 device owner. A given method is accessible to all device administrators unless the documentation
 for that method specifies that it is restricted to either device or profile owners. Any
 application calling an api may only pass as an argument a device administrator component it
 owns. Otherwise a  SecurityException  will be thrown.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.service.dreams.DreamService: void setContentView(View)>,"Sets a view to be the content view for this Dream.
 Behaves similarly to Activity.setContentView(android.view.View) in an activity
 including using ViewGroup.LayoutParams#MATCH_PARENT as the layout height and width of the view. Note: This requires a window so you should usually call it during onAttachedToWindow() and never earlier (you cannot call it
 during onCreate() ).",view View |||,void,17,"Extend this class to implement a custom dream (available to the user as a ""Daydream"").

  Dreams are interactive screensavers launched when a charging device is idle or docked in a
 desk dock. Dreams provide another modality for apps to express themselves tailored for
 an exhibition/lean-back experience. The  DreamService  lifecycle is as follows: onAttachedToWindow() Use this for initial setup such as calling  setContentView() . onDreamingStarted() Your dream has started so you should begin animations or other behaviors here. onDreamingStopped() Use this to stop the things you started in  onDreamingStarted() . onDetachedFromWindow() Use this to dismantle resources (for example detach from handlers
        and listeners). In addition onCreate and onDestroy (from the Service interface) will also be called but
 initialization and teardown should be done by overriding the hooks above. To be available to the system your  DreamService  should be declared in the
 manifest as follows: 
 <service
     android:name="".MyDream""
     android:exported=""true""
     android:icon=""@drawable/my_icon""
     android:label=""@string/my_dream_label"" >

     <intent-filter>
         <action android:name=""android.service.dreams.DreamService"" />
         <category android:name=""android.intent.category.DEFAULT"" />
     </intent-filter>

     <!-- Point to additional information for this dream (optional) -->
     <meta-data
         android:name=""android.service.dream""
         android:resource=""@xml/my_dream"" />
 </service>
  If specified with the  <meta-data>  element
 additional information for the dream is defined using the
  <dream>  element in a separate XML file.
 Currently the only addtional
 information you can provide is for a settings activity that allows the user to configure
 the dream behavior. For example: res/xml/my_dream.xml 
 <dream xmlns:android=""http://schemas.android.com/apk/res/android""
     android:settingsActivity=""com.example.app/.MyDreamSettingsActivity"" />
  This makes a Settings button available alongside your dream's listing in the
 system settings which when pressed opens the specified activity. To specify your dream layout call  setContentView(View)  typically during the
  onAttachedToWindow()  callback. For example: 
 public class MyDream extends DreamService {

     @Override
     public void onAttachedToWindow() {
         super.onAttachedToWindow();

         // Exit dream upon user touch
         setInteractive(false);
         // Hide system UI
         setFullscreen(true);
         // Set the dream layout
         setContentView(R.layout.dream);
     }
 }
  When targeting api level 21 and above you must declare the service in your manifest file
 with the  Manifest.permission.BIND_DREAM_SERVICE  permission. For example: 
 <service
     android:name="".MyDream""
     android:exported=""true""
     android:icon=""@drawable/my_icon""
     android:label=""@string/my_dream_label""
     android:permission=""android.permission.BIND_DREAM_SERVICE"">
   <intent-filter>
     <action android:name=”android.service.dreams.DreamService” />
     <category android:name=”android.intent.category.DEFAULT” />
   </intent-filter>
 </service>",,,,,,,,
<android.content.Intent: ArrayList getIntegerArrayListExtra(String)>,Retrieve extended data from the intent.,name String : The name of the desired item. |||,"ArrayList < Integer > the value of an item previously added with
 putIntegerArrayListExtra() or null if no
 ArrayList value was found. |||",1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.view.View: void clearFocus()>,"Called when this view wants to give up focus. If focus is cleared onFocusChanged(boolean int android.graphics.Rect) is called. Note: When not in touch-mode the framework will try to give focus
 to the first focusable View from the top after focus is cleared. Hence if this
 View is the first from the top that can take focus then all callbacks
 related to clearing focus will be invoked after which the framework will
 give focus to this view.",,void,1,"This class represents the basic building block for user interface components. A View
 occupies a rectangular area on the screen and is responsible for drawing and
 event handling. View is the base class for  widgets  which are
 used to create interactive UI components (buttons text fields etc.). The
  ViewGroup  subclass is the base class for  layouts  which
 are invisible containers that hold other Views (or other ViewGroups) and define
 their layout properties.",,,,,,,,
<android.location.LocationManager: List getAllProviders()>,"Returns a list of the names of all known location providers. All providers are returned
 including ones that are not permitted to be accessed by the calling activity or are currently
 disabled.",,"List < String > list of provider names
 
 This value cannot be null . |||",1,"A data class representing a geographic location.

  A location can consist of a latitude longitude timestamp
 and other information such as bearing altitude and velocity.

  All locations generated by the  LocationManager  are
 guaranteed to have a valid latitude longitude and timestamp
 (both UTC time and elapsed real-time since boot) all other
 parameters are optional.","Contains the framework API classes that define Android location-based and
 	related services. This API is not the recommended method for accessing Android location. 
 The
  Google Location Services API 
 part of Google Play services is the preferred way to add location-awareness to
 your app. It offers a simpler API higher accuracy low-power geofencing and
 more. If you are currently using the android.location API you are strongly
 encouraged to switch to the Google Location Services API as soon as
 possible.
  
 To learn more about the Google Location Services API see the
  Location API overview .",,,,,,,
<android.database.DataSetObservable: void notifyChanged()>,"Invokes DataSetObserver#onChanged on each observer.
 Called when the contents of the data set have changed.  The recipient
 will obtain the new contents the next time it queries the data set.",,void,1,"A specialization of  Observable  for  DataSetObserver 
 that provides methods for sending notifications to a list of
  DataSetObserver  objects.","If you need to manage data in a private database use the  android.database.sqlite  classes. These classes are used to manage the  Cursor  object returned from a content provider query. Databases
 are usually created and opened with  openOrCreateDatabase(String int SQLiteDatabase.CursorFactory) 
 To make requests through
 content providers you can use the  content.ContentResolver  class.
  All databases are stored on the device in  /data/data/<package_name>/databases",,,,,,,
<android.widget.ShareActionProvider: void onPrepareSubMenu(SubMenu)>,"Called to prepare an associated submenu for the menu item backed by this ActionProvider. if hasSubMenu() returns true this method will be called when the
 menu item is selected to prepare the submenu for presentation to the user. Apps
 may use this to create or alter submenu content right before display.",subMenu SubMenu : Submenu that will be displayed |||,void,14,"This is a provider for a share action. It is responsible for creating views
 that enable data sharing and also to show a sub menu with sharing activities
 if the hosting item is placed on the overflow menu.
  
 Here is how to use the action provider with custom backing file in a  MenuItem :
  
 // In Activity#onCreateOptionsMenu
 public boolean onCreateOptionsMenu(Menu menu) {
     // Get the menu item.
     MenuItem menuItem = menu.findItem(R.id.my_menu_item);
     // Get the provider and hold onto it to set/change the share intent.
     mShareActionProvider = (ShareActionProvider) menuItem.getActionProvider();
     // Set history different from the default before getting the action
     // view since a call to  MenuItem#getActionView()  calls
     //  ActionProvider#onCreateActionView()  which uses the backing file name. Omit this
     // line if using the default share history file is desired.
     mShareActionProvider.setShareHistoryFileName(""custom_share_history.xml"");
     . . .
 }

 // Somewhere in the application.
 public void doShare(Intent shareIntent) {
     // When you want to share set the share intent.
     mShareActionProvider.setShareIntent(shareIntent);
 } Note:  While the sample snippet demonstrates how to use this provider
 in the context of a menu item the use of the provider is not limited to menu items.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
"<android.app.admin.DeviceAdminInfo: void writeToParcel(Parcel,int)>",Used to package this object into a Parcel .,"dest Parcel : The Parcel to be written. |||
flags int : The flags used for parceling. |||",void,8,"This class is used to specify meta information of a device administrator
 component.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.webkit.WebView: SslCertificate getCertificate()>,"Gets the SSL certificate for the main top-level page or null if there is
 no certificate (the site is not secure).",,SslCertificate the SSL certificate for the main top-level page |||,1,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",,,,,,,
"<android.content.ContextWrapper: int checkPermission(String,int,int)>","Determine whether the given permission is allowed for a particular
 process and user ID running in the system.","permission String : The name of the permission being checked.
This value cannot be null . |||
pid int : The process ID being checked against.  Must be > 0. |||
uid int : The user ID being checked against.  A uid of 0 is the root
user which will pass every permission check. |||","int PackageManager#PERMISSION_GRANTED if the given
 pid/uid is allowed that permission or PackageManager#PERMISSION_DENIED if it is not.

 Value is PackageManager.PERMISSION_GRANTED or PackageManager.PERMISSION_DENIED |||",1,"Proxying implementation of Context that simply delegates all of its calls to
 another Context.  Can be subclassed to modify behavior without changing
 the original Context.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.widget.TextView: void getFocusedRect(Rect)>,"When a view has focus and the user navigates away from it the next view is searched for
 starting from the rectangle filled in by this method.

 By default the rectangle is the getDrawingRect(android.graphics.Rect) )
 of the view.  However if your view maintains some idea of internal selection
 such as a cursor or a selected row or column you should override this method and
 fill in a more specific rectangle.",r Rect : The rectangle to fill in in this view's coordinates. |||,void,1,"A user interface element that displays text to the user.
 To provide user-editable text see  EditText .
  
 The following code sample shows a typical use with an XML layout
 and code to modify the contents of the text view:
  
 <LinearLayout
      xmlns:android=""http://schemas.android.com/apk/res/android""
      android:layout_width=""match_parent""
      android:layout_height=""match_parent"">
    <TextView
        android:id=""@+id/text_view_id""
        android:layout_height=""wrap_content""
        android:layout_width=""wrap_content""
        android:text=""@string/hello"" />
 </LinearLayout>
  
 This code sample demonstrates how to modify the contents of the text view
 defined in the previous XML layout:
  
 public class MainActivity extends Activity {

    protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_main);
         final TextView helloTextView = (TextView) findViewById(R.id.text_view_id);
         helloTextView.setText(R.string.user_greeting);
     }
 }
  
 To customize the appearance of TextView see  Styles and Themes .
  XML attributes 
 See  TextView Attributes 
  View Attributes","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.content.res.Resources: float getDimension(int)>,"Retrieve a dimensional for a particular resource ID.  Unit
 conversions are based on the current DisplayMetrics associated
 with the resources.","id int : The desired resource identifier as generated by the aapt
tool. This integer encodes the package type and resource
entry. The value 0 is an invalid identifier. |||",float Resource dimension value multiplied by the appropriate metric to convert to pixels. |||,1,"Class for accessing an application's resources.  This sits on top of the
 asset manager of the application (accessible through  getAssets() ) and
 provides a high-level API for getting typed data from the assets.

  The Android resource system keeps track of all non-code assets associated with an
 application. You can use this class to access your application's resources. You can generally
 acquire the  Resources  instance associated with your application
 with  getResources() . The Android SDK tools compile your application's resources into the application binary
 at build time.  To use a resource you must install it correctly in the source tree (inside
 your project's  res/  directory) and build your application.  As part of the build
 process the SDK tools generate symbols for each resource which you can use in your application
 code to access the resources. Using application resources makes it easy to update various characteristics of your
 application without modifying code and—by providing sets of alternative
 resources—enables you to optimize your application for a variety of device configurations
 (such as for different languages and screen sizes). This is an important aspect of developing
 Android applications that are compatible on different types of devices. For more information about using resources see the documentation about  Application Resources .","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.widget.CompoundButton: void toggle()>,Change the checked state of the view to the inverse of its current state,,void,1,"A button with two states checked and unchecked. When the button is pressed
 or clicked the state changes automatically.
  XML attributes 
 See  CompoundButton Attributes   Button
 Attributes   TextView Attributes   View Attributes","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
"<android.os.Binder: void dump(FileDescriptor,String)>",Implemented to call the more convenient version dump(java.io.FileDescriptor java.io.PrintWriter java.lang.String[]) .,"fd FileDescriptor : This value cannot be null . |||
args String : This value may be null . |||",void,3,"Base class for a remotable object the core part of a lightweight
 remote procedure call mechanism defined by  IBinder .
 This class is an implementation of IBinder that provides
 standard local implementation of such an object.

  Most developers will not implement this class directly instead using the
  aidl  tool to describe the desired
 interface having it generate the appropriate Binder subclass.  You can
 however derive directly from Binder to implement your own custom RPC
 protocol or simply instantiate a raw Binder object directly to use as a
 token that can be shared across processes.

  This class is just a basic IPC primitive; it has no impact on an application's
 lifecycle and is valid only as long as the process that created it continues to run.
 To use this correctly you must be doing so within the context of a top-level
 application component (a  Service   Activity 
 or  ContentProvider ) that lets the system know your process
 should remain running. You must keep in mind the situations in which your process
 could go away and thus require that you later re-create a new Binder and re-attach
 it when the process starts again.  For example if you are using this within an
  Activity  your activity's process may be killed any time the
 activity is not started; if the activity is later re-created you will need to
 create a new Binder and hand it back to the correct place again; you need to be
 aware that your process may be started for another reason (for example to receive
 a broadcast) that will not involve re-creating the activity and thus run its code
 to create a new Binder.",,,,,,,,
<android.widget.TabWidget: void setCurrentTab(int)>,"Sets the current tab. This method is used to bring a tab to the front of the Widget
 and is used to post to the rest of the UI that a different tab
 has been brought to the foreground. Note this is separate from the traditional ""focus"" that is
 employed from the view logic. For instance if we have a list in a tabbed view a user may be
 navigating up and down the list moving the UI focus (orange
 highlighting) through the list items.  The cursor movement does
 not effect the ""selected"" tab though because what is being
 scrolled through is all on the same tab.  The selected tab only
 changes when we navigate between tabs (moving from the list view
 to the next tabbed view in this example). To move both the focus AND the selected tab at once please use focusCurrentTab(int) . Normally the view logic takes care of
 adjusting the focus so unless you're circumventing the UI
 you'll probably just focus your interest here.","index int : the index of the tab that you want to indicate as the
selected tab (tab brought to the front of the widget) |||",void,1,"Displays a list of tab labels representing each page in the parent's tab
 collection.
  
 The container object for this widget is  TabHost .
 When the user selects a tab this object sends a message to the parent
 container TabHost to tell it to switch the displayed page. You typically
 won't use many methods directly on this object. The container TabHost is
 used to add labels add the callback handler and manage callbacks. You
 might call this object to iterate the list of tabs or to tweak the layout
 of the tab list but most methods should be called on the containing TabHost
 object.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
"<android.app.ActivityManager: List getRecentTasks(int,int)>","This method was deprecated
      in API level 21. As of Build.VERSION_CODES.LOLLIPOP this method is
 no longer available to third party applications: the introduction of
 document-centric recents means
 it can leak personal information to the caller.  For backwards compatibility
 it will still return a small subset of its data: at least the caller's
 own tasks (though see getAppTasks() for the correct supported
 way to retrieve that information) and possibly some other tasks
 such as home that are known to not be sensitive. Note: this method is only intended for debugging and presenting
 task management user interfaces .  This should never be used for
 core logic in an application such as deciding between different
 behaviors based on the information found here.  Such uses are not supported and will likely break in the future.  For
 example if multiple applications can be actively running at the
 same time assumptions made about the meaning of the data here for
 purposes of control flow will be incorrect.","maxNum int : The maximum number of entries to return in the list.  The
actual number returned may be smaller depending on how many tasks the
user has started and the maximum number the system can remember. |||
flags int : Information about what to return.  May be any combination
of RECENT_WITH_EXCLUDED and RECENT_IGNORE_UNAVAILABLE . |||","List < ActivityManager.RecentTaskInfo > Returns a list of RecentTaskInfo records describing each of
 the recent tasks. |||",1,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.telephony.PhoneNumberUtils: void formatNanpNumber(Editable)>,"This method was deprecated
      in API level 21. Use link #formatNumber(String phoneNumber String defaultCountryIso) instead Formats a phone number in-place using the NANP formatting rules. Numbers will be formatted
 as: xxxxx
 xxx-xxxx
 xxx-xxx-xxxx
 1-xxx-xxx-xxxx
 +1-xxx-xxx-xxxx",text Editable : the number to be formatted will be modified with the formatting |||,void,1,Various utilities for dealing with phone number strings.,,,,,,,,
<android.content.ContentResolver: void removeStatusChangeListener(Object)>,Remove a previously registered status change listener.,handle Object : the handle that was returned by addStatusChangeListener(int SyncStatusObserver) |||,void,5,This class provides applications access to the content model.,"Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.view.ViewPropertyAnimator: ViewPropertyAnimator translationY(float)>,"This method will cause the View's translationY property to be animated to the
 specified value. Animations already running on the property will be canceled.",value float : The value to be animated to. |||,ViewPropertyAnimator This object allowing calls to methods in this class to be chained. |||,12,"This class enables automatic and optimized animation of select properties on View objects.
 If only one or two properties on a View object are being animated then using an
  ObjectAnimator  is fine; the property setters called by ObjectAnimator
 are well equipped to do the right thing to set the property and invalidate the view
 appropriately. But if several properties are animated simultaneously or if you just want a
 more convenient syntax to animate a specific property then ViewPropertyAnimator might be
 more well-suited to the task.

  This class may provide better performance for several simultaneous animations because
 it will optimize invalidate calls to take place only once for several properties instead of each
 animated property independently causing its own invalidation. Also the syntax of using this
 class could be easier to use because the caller need only tell the View object which
 property to animate and the value to animate either to or by and this class handles the
 details of configuring the underlying Animator class and starting it. This class is not constructed by the caller but rather by the View whose properties
 it will animate. Calls to  View.animate()  will return a reference
 to the appropriate ViewPropertyAnimator object for that View.",,,,,,,,
"<android.net.SSLCertificateSocketFactory: Socket createSocket(String,int)>","Creates a socket and connects it to the specified remote host
 at the specified remote port.  This socket is configured using
 the socket options established for this factory. If there is a security manager its checkConnect method is called with the host address and port as its arguments. This could result in a SecurityException. By default this method returns a connected socket and verifies the peer's
 certificate hostname after connecting using the HostnameVerifier obtained from HttpsURLConnection.getDefaultHostnameVerifier() ; if this instance was created with getInsecure(int android.net.SSLSessionCache) it returns a socket that is not connected instead.","host String : the server host name with which to connect or null for the loopback address. |||
port int : the server port |||",Socket the Socket |||,1,"SSLSocketFactory implementation with several extra features:

  Timeout specification for SSL handshake operations
  Hostname verification in most cases (see WARNINGs below)
  Optional SSL session caching with  SSLSessionCache Optionally bypass all SSL certificate checks
  createSocket() Socket#connect(java.net.SocketAddress int) The recommended way to verify the server's identity is to use
  HttpsURLConnection#getDefaultHostnameVerifier()  to get a
  HostnameVerifier  to verify the certificate hostname.

  Warning : Some methods on this class return connected sockets and some return
 unconnected sockets.  For the methods that return connected sockets setting
 connection- or handshake-related properties on those sockets will have no effect.

  On development devices ""setprop socket.relaxsslcheck yes"" bypasses all
 SSL certificate and hostname checks for testing purposes.  This setting
 requires root access.",,,,,,,,
<android.content.res.Resources: Movie getMovie(int)>,"This method was deprecated
      in API level 29. Prefer AnimatedImageDrawable . Return a movie object associated with the particular resource ID.","id int : The desired resource identifier as generated by the aapt
tool. This integer encodes the package type and resource
entry. The value 0 is an invalid identifier. |||",Movie |||,1,"Class for accessing an application's resources.  This sits on top of the
 asset manager of the application (accessible through  getAssets() ) and
 provides a high-level API for getting typed data from the assets.

  The Android resource system keeps track of all non-code assets associated with an
 application. You can use this class to access your application's resources. You can generally
 acquire the  Resources  instance associated with your application
 with  getResources() . The Android SDK tools compile your application's resources into the application binary
 at build time.  To use a resource you must install it correctly in the source tree (inside
 your project's  res/  directory) and build your application.  As part of the build
 process the SDK tools generate symbols for each resource which you can use in your application
 code to access the resources. Using application resources makes it easy to update various characteristics of your
 application without modifying code and—by providing sets of alternative
 resources—enables you to optimize your application for a variety of device configurations
 (such as for different languages and screen sizes). This is an important aspect of developing
 Android applications that are compatible on different types of devices. For more information about using resources see the documentation about  Application Resources .","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.app.admin.DevicePolicyManager: void lockNow()>,"Make the device lock immediately as if the lock screen timeout has expired at the point of
 this call. This method secures the device in response to an urgent situation such as a lost or stolen
 device. After this method is called the device must be unlocked using strong authentication
 (PIN pattern or password). This API is intended for use only by device admins. From version Build.VERSION_CODES.R onwards the caller must either have
 the LOCK_DEVICE permission or the device must have the device admin feature; if neither is
 true then the method will return without completing any action. Before version Build.VERSION_CODES.R the device needed the device admin feature
 regardless of the caller's permissions. The calling device admin must have requested DeviceAdminInfo#USES_POLICY_FORCE_LOCK to be able to call this method; if it has not a security exception will be thrown. If there's no lock type set this method forces the device to go to sleep but doesn't lock
 the device. Device admins who find the device in this state can lock an otherwise-insecure
 device by first calling resetPassword(String int) to set the password and then lock the device. This method can be called on the DevicePolicyManager instance returned by getParentProfileInstance(android.content.ComponentName) in order to lock the parent profile. Equivalent to calling lockNow(int) with no flags.",,void,8,"Public interface for managing policies enforced on a device. Most clients of this class must be
 registered with the system as a  device
 administrator . Additionally a device administrator may be registered as either a profile or
 device owner. A given method is accessible to all device administrators unless the documentation
 for that method specifies that it is restricted to either device or profile owners. Any
 application calling an api may only pass as an argument a device administrator component it
 owns. Otherwise a  SecurityException  will be thrown.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.view.inputmethod.BaseInputConnection: void removeComposingSpans(Spannable)>,,text Spannable |||,void,3,"Base class for implementors of the InputConnection interface taking care
 of most of the common behavior for providing a connection to an Editable.
 Implementors of this class will want to be sure to implement
  getEditable()  to provide access to their own editable object and
 to refer to the documentation in  InputConnection .",,,,,,,,
<android.inputmethodservice.InputMethodService: void showStatusIcon(int)>,,iconResId int |||,void,3,"InputMethodService provides a standard implementation of an InputMethod
 which final implementations can derive from and customize.  See the
 base class  AbstractInputMethodService  and the  InputMethod 
 interface for more information on the basics of writing input methods.

  In addition to the normal Service lifecycle methods this class
 introduces some new specific callbacks that most subclasses will want
 to make use of: onInitializeInterface()  for user-interface initialization
 in particular to deal with configuration changes while the service is
 running.
  onBindInput()  to find out about switching to a new client.
  onStartInput(EditorInfo boolean)  to deal with an input session starting with
 the client.
  onCreateInputView()   onCreateCandidatesView() 
 and  onCreateExtractTextView()  for non-demand generation of the UI.
  onStartInputView(android.view.inputmethod.EditorInfo boolean)  to deal with input
 starting within the input area of the IME.
  An input method has significant discretion in how it goes about its
 work: the  InputMethodService  provides
 a basic framework for standard UI elements (input view candidates view
 and running in fullscreen mode) but it is up to a particular implementor
 to decide how to use them.  For example one input method could implement
 an input area with a keyboard another could allow the user to draw text
 while a third could have no input area (and thus not be visible to the
 user) but instead listen to audio and perform text to speech conversion. In the implementation provided here all of these elements are placed
 together in a single window managed by the InputMethodService.  It will
 execute callbacks as it needs information about them and provides APIs for
 programmatic control over them.  They layout of these elements is explicitly
 defined: The soft input view if available is placed at the bottom of the
 screen.
  The candidates view if currently shown is placed above the soft
 input view.
  If not running fullscreen the application is moved or resized to be
 above these views; if running fullscreen the window will completely cover
 the application and its top part will contain the extract text of what is
 currently being edited by the application.
  Soft Input View Central to most input methods is the soft input view.  This is where most
 user interaction occurs: pressing on soft keys drawing characters or
 however else your input method wants to generate text.  Most implementations
 will simply have their own view doing all of this work and return a new
 instance of it when  onCreateInputView()  is called.  At that point
 as long as the input view is visible you will see user interaction in
 that view and can call back on the InputMethodService to interact with the
 application as appropriate. There are some situations where you want to decide whether or not your
 soft input view should be shown to the user.  This is done by implementing
 the  onEvaluateInputViewShown()  to return true or false based on
 whether it should be shown in the current environment.  If any of your
 state has changed that may impact this call
  updateInputViewShown()  to have it re-evaluated.  The default
 implementation always shows the input view unless there is a hard
 keyboard available which is the appropriate behavior for most input
 methods. Candidates View Often while the user is generating raw text an input method wants to
 provide them with a list of possible interpretations of that text that can
 be selected for use.  This is accomplished with the candidates view and
 like the soft input view you implement  onCreateCandidatesView() 
 to instantiate your own view implementing your candidates UI. Management of the candidates view is a little different than the input
 view because the candidates view tends to be more transient being shown
 only when there are possible candidates for the current text being entered
 by the user.  To control whether the candidates view is shown you use
  setCandidatesViewShown(boolean) .  Note that because the candidate
 view tends to be shown and hidden a lot it does not impact the application
 UI in the same way as the soft input view: it will never cause application
 windows to resize only cause them to be panned if needed for the user to
 see the current focus. Fullscreen Mode Sometimes your input method UI is too large to integrate with the
 application UI so you just want to take over the screen.  This is
 accomplished by switching to full-screen mode causing the input method
 window to fill the entire screen and add its own ""extracted text"" editor
 showing the user the text that is being typed.  Unlike the other UI elements
 there is a standard implementation for the extract editor that you should
 not need to change.  The editor is placed at the top of the IME above the
 input and candidates views. Similar to the input view you control whether the IME is running in
 fullscreen mode by implementing  onEvaluateFullscreenMode() 
 to return true or false based on
 whether it should be fullscreen in the current environment.  If any of your
 state has changed that may impact this call
  updateFullscreenMode()  to have it re-evaluated.  The default
 implementation selects fullscreen mode when the screen is in a landscape
 orientation which is appropriate behavior for most input methods that have
 a significant input area. When in fullscreen mode you have some special requirements because the
 user can not see the application UI.  In particular you should implement
  onDisplayCompletions(android.view.inputmethod.CompletionInfo[])  to show completions
 generated by your application typically in your candidates view like you
 would normally show candidates.


  Generating Text The key part of an IME is of course generating text for the application.
 This is done through calls to the
  InputConnection  interface to the
 application which can be retrieved from  getCurrentInputConnection() .
 This interface allows you to generate raw key events or if the target
 supports it directly edit in strings of candidates and committed text. Information about what the target is expected and supports can be found
 through the  EditorInfo  class which is
 retrieved with  getCurrentInputEditorInfo()  method.  The most
 important part of this is  EditorInfo.inputType ; in particular if this is
  EditorInfo.TYPE_NULL 
 then the target does not support complex edits and you need to only deliver
 raw key events to it.  An input method will also want to look at other
 values here to for example detect password mode auto complete text views
 phone number entry etc. When the user switches between input targets you will receive calls to
  onFinishInput()  and  onStartInput(android.view.inputmethod.EditorInfo boolean) .
 You can use these to reset and initialize your input state for the current
 target.  For example you will often want to clear any input state and
 update a soft keyboard to be appropriate for the new inputType.",,,,,,,,
<android.app.Activity: void setSecondaryProgress(int)>,"This method was deprecated
      in API level 24. No longer supported starting in API 21. Sets the secondary progress for the progress bar in the title. This
 progress is drawn between the primary progress (set via setProgress(int) and the background. It can be ideal for media
 scenarios such as showing the buffering progress while the default
 progress shows the play progress. In order for the progress bar to be shown the feature must be requested
 via requestWindowFeature(int) .","secondaryProgress int : The secondary progress for the progress bar. Valid ranges are from
0 to 10000 (both inclusive). |||",void,1,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
"<android.test.TouchUtils: int dragViewBy(InstrumentationTestCase,View,int,int,int)>","This method was deprecated
      in API level 15. ActivityInstrumentationTestCase is deprecated in favor of ActivityInstrumentationTestCase2 which provides more options for
 configuring the Activity under test Simulate touching a view and dragging it by the specified amount.","test InstrumentationTestCase : The test case that is being run |||
v View : The view that should be dragged |||
gravity int : Which part of the view to use for the initial down event. A combination of
(TOP CENTER_VERTICAL BOTTOM) and (LEFT CENTER_HORIZONTAL RIGHT) |||
deltaX int : Amount to drag horizontally in pixels |||
deltaY int : Amount to drag vertically in pixels |||",int distance in pixels covered by the drag |||,3,"Reusable methods for generating touch events. These methods can be used with
 InstrumentationTestCase or ActivityInstrumentationTestCase2 to simulate user interaction with
 the application through a touch screen.",,,,,,,,
<android.nfc.tech.NdefFormatable: void formatReadOnly(NdefMessage)>,"Formats a tag as NDEF write a NdefMessage and make read-only. This is a multi-step process an IOException is thrown
 if any one step fails. The card is left in a read-only state if this method returns successfully. This is an I/O operation and will block until complete. It must
 not be called from the main application thread. A blocked call will be canceled with IOException if close() is called from another thread. Requires the Manifest.permission.NFC permission.",firstMessage NdefMessage : the NDEF message to write after formatting |||,void,10,"Provide access to NDEF format operations on a  Tag .

  Acquire a  NdefFormatable  object using  get(Tag) .

  Android devices with NFC must only enumerate and implement this
 class for tags for which it can format to NDEF.

  Unfortunately the procedures to convert unformated tags to NDEF formatted
 tags are not specified by NFC Forum and are not generally well-known. So
 there is no mandatory set of tags for which all Android devices with NFC
 must support  NdefFormatable .

  Note:  Methods that perform I/O operations
 require the  Manifest.permission.NFC  permission.","These classes provide access to a tag technology's features which vary by the type
 of tag that is scanned. A scanned tag can support multiple technologies and you can find
 out what they are by calling  getTechList() . For more information on dealing with tag technologies and handling the ones that you care about see
  The Tag Dispatch System .
 The  TagTechnology  interface provides an overview of the
 supported technologies.",,,,,,,
<android.widget.CalendarView: void setFirstDayOfWeek(int)>,Sets the first day of week. Related XML Attributes: android:firstDayOfWeek,firstDayOfWeek int : The first day of the week conforming to the CalendarView APIs. |||,void,11,"This class is a calendar widget for displaying and selecting dates. The
 range of dates supported by this calendar is configurable.
  
 The exact appearance and interaction model of this widget may vary between
 OS versions and themes (e.g. Holo versus Material) but in general a user
 can select a date by tapping on it and can scroll or fling the calendar to a
 desired date.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.app.Activity: void unregisterForContextMenu(View)>,Prevents a context menu to be shown for the given view. This method will remove the OnCreateContextMenuListener on the view.,view View : The view that should stop showing a context menu. |||,void,1,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.widget.AlphabetIndexer: void onInvalidated()>,"This method is called when the entire data becomes invalid
 most likely through a call to Cursor#deactivate() or Cursor#close() on a Cursor .",,void,3,"A helper class for adapters that implement the SectionIndexer interface.
 If the items in the adapter are sorted by simple alphabet-based sorting then
 this class provides a way to do fast indexing of large lists using binary search.
 It caches the indices that have been determined through the binary search and also
 invalidates the cache if changes occur in the cursor.
  setCursor(Cursor) getPositionForSection(int)","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.app.LauncherActivity: void setTitle(int)>,"Change the title associated with this activity.  If this is a
 top-level activity the title for its window will change.  If it
 is an embedded activity the parent can do whatever it wants
 with it.",titleId int |||,void,1,"Displays a list of all activities which can be performed
 for a given intent. Launches when clicked.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
"<android.view.View: void layout(int,int,int,int)>","Assign a size and position to a view and all of its
 descendants This is the second phase of the layout mechanism.
 (The first is measuring). In this phase each parent calls
 layout on all of its children to position them.
 This is typically done using the child measurements
 that were stored in the measure pass(). Derived classes should not override this method.
 Derived classes with children should override
 onLayout. In that method they should
 call layout on each of their children.","l int : Left position relative to parent |||
t int : Top position relative to parent |||
r int : Right position relative to parent |||
b int : Bottom position relative to parent |||",void,1,"This class represents the basic building block for user interface components. A View
 occupies a rectangular area on the screen and is responsible for drawing and
 event handling. View is the base class for  widgets  which are
 used to create interactive UI components (buttons text fields etc.). The
  ViewGroup  subclass is the base class for  layouts  which
 are invisible containers that hold other Views (or other ViewGroups) and define
 their layout properties.",,,,,,,,
"<android.content.Intent: char getCharExtra(String,char)>",Retrieve extended data from the intent.,"name String : The name of the desired item. |||
defaultValue char : the value to be returned if no value of the desired
type is stored with the given name. |||","char the value of an item previously added with putExtra()
 or the default value if none was found. |||",1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.app.Fragment: void unregisterForContextMenu(View)>,"Prevents a context menu to be shown for the given view. This method will
 remove the OnCreateContextMenuListener on the view.",view View : The view that should stop showing a context menu. |||,void,11,"A Fragment is a piece of an application's user interface or behavior
 that can be placed in an  Activity .  Interaction with fragments
 is done through  FragmentManager  which can be obtained via
  Activity#getFragmentManager()  and
  Fragment#getFragmentManager() .

  The Fragment class can be used many ways to achieve a wide variety of
 results. In its core it represents a particular operation or interface
 that is running within a larger  Activity .  A Fragment is closely
 tied to the Activity it is in and can not be used apart from one.  Though
 Fragment defines its own lifecycle that lifecycle is dependent on its
 activity: if the activity is stopped no fragments inside of it can be
 started; when the activity is destroyed all fragments will be destroyed.

  All subclasses of Fragment must include a public no-argument constructor.
 The framework will often re-instantiate a fragment class when needed
 in particular during state restore and needs to be able to find this
 constructor to instantiate it.  If the no-argument constructor is not
 available a runtime exception will occur in some cases during state
 restore.

  Topics covered here:
  Older Platforms Lifecycle Layout Back Stack","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.content.ContextWrapper: void unbindService(ServiceConnection)>,"Disconnect from an application service.  You will no longer receive
 calls as the service is restarted and the service is now allowed to
 stop at any time.","conn ServiceConnection : The connection interface previously supplied to
bindService().  This parameter must not be null.
This value cannot be null . |||",void,1,"Proxying implementation of Context that simply delegates all of its calls to
 another Context.  Can be subclassed to modify behavior without changing
 the original Context.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.service.dreams.DreamService: void setContentView(int)>,"Inflates a layout resource and set it to be the content view for this Dream.
 Behaves similarly to Activity.setContentView(int) . Note: Requires a window do not call before onAttachedToWindow()",layoutResID int : Resource ID to be inflated. |||,void,17,"Extend this class to implement a custom dream (available to the user as a ""Daydream"").

  Dreams are interactive screensavers launched when a charging device is idle or docked in a
 desk dock. Dreams provide another modality for apps to express themselves tailored for
 an exhibition/lean-back experience. The  DreamService  lifecycle is as follows: onAttachedToWindow() Use this for initial setup such as calling  setContentView() . onDreamingStarted() Your dream has started so you should begin animations or other behaviors here. onDreamingStopped() Use this to stop the things you started in  onDreamingStarted() . onDetachedFromWindow() Use this to dismantle resources (for example detach from handlers
        and listeners). In addition onCreate and onDestroy (from the Service interface) will also be called but
 initialization and teardown should be done by overriding the hooks above. To be available to the system your  DreamService  should be declared in the
 manifest as follows: 
 <service
     android:name="".MyDream""
     android:exported=""true""
     android:icon=""@drawable/my_icon""
     android:label=""@string/my_dream_label"" >

     <intent-filter>
         <action android:name=""android.service.dreams.DreamService"" />
         <category android:name=""android.intent.category.DEFAULT"" />
     </intent-filter>

     <!-- Point to additional information for this dream (optional) -->
     <meta-data
         android:name=""android.service.dream""
         android:resource=""@xml/my_dream"" />
 </service>
  If specified with the  <meta-data>  element
 additional information for the dream is defined using the
  <dream>  element in a separate XML file.
 Currently the only addtional
 information you can provide is for a settings activity that allows the user to configure
 the dream behavior. For example: res/xml/my_dream.xml 
 <dream xmlns:android=""http://schemas.android.com/apk/res/android""
     android:settingsActivity=""com.example.app/.MyDreamSettingsActivity"" />
  This makes a Settings button available alongside your dream's listing in the
 system settings which when pressed opens the specified activity. To specify your dream layout call  setContentView(View)  typically during the
  onAttachedToWindow()  callback. For example: 
 public class MyDream extends DreamService {

     @Override
     public void onAttachedToWindow() {
         super.onAttachedToWindow();

         // Exit dream upon user touch
         setInteractive(false);
         // Hide system UI
         setFullscreen(true);
         // Set the dream layout
         setContentView(R.layout.dream);
     }
 }
  When targeting api level 21 and above you must declare the service in your manifest file
 with the  Manifest.permission.BIND_DREAM_SERVICE  permission. For example: 
 <service
     android:name="".MyDream""
     android:exported=""true""
     android:icon=""@drawable/my_icon""
     android:label=""@string/my_dream_label""
     android:permission=""android.permission.BIND_DREAM_SERVICE"">
   <intent-filter>
     <action android:name=”android.service.dreams.DreamService” />
     <category android:name=”android.intent.category.DEFAULT” />
   </intent-filter>
 </service>",,,,,,,,
<android.database.DatabaseUtils: void readExceptionWithFileNotFoundExceptionFromParcel(Parcel)>,,reply Parcel |||,void,1,Static utility methods for dealing with databases and  Cursor s.,"If you need to manage data in a private database use the  android.database.sqlite  classes. These classes are used to manage the  Cursor  object returned from a content provider query. Databases
 are usually created and opened with  openOrCreateDatabase(String int SQLiteDatabase.CursorFactory) 
 To make requests through
 content providers you can use the  content.ContentResolver  class.
  All databases are stored on the device in  /data/data/<package_name>/databases",,,,,,,
<android.webkit.WebView: void clearFormData()>,"Removes the autocomplete popup from the currently focused form field if
 present. Note this only affects the display of the autocomplete popup
 it does not remove any saved form data from this WebView's store. To do
 that use WebViewDatabase#clearFormData .",,void,1,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",,,,,,,
<android.widget.ArrayAdapter: void notifyDataSetChanged()>,"Notifies the attached observers that the underlying data has been changed
 and any View reflecting the data set should refresh itself.",,void,1,"You can use this adapter to provide views for an  AdapterView 
 Returns a view for each object in a collection of data objects you
 provide and can be used with list-based user interface widgets such as
  ListView  or  Spinner .
  
 By default the array adapter creates a view by calling  Object#toString()  on each
 data object in the collection you provide and places the result in a TextView.
 You may also customize what type of view is used for the data object in the collection.
 To customize what type of view is used for the data object
 override  getView(int android.view.View android.view.ViewGroup) 
 and inflate a view resource.
 For a code example see
 the  
 CustomChoiceList  sample.
  
 For an example of using an array adapter with a ListView see the
  
 Adapter Views  guide.
  
 For an example of using an array adapter with a Spinner see the
  Spinners  guide.
  Note: 
 If you are considering using array adapter with a ListView consider using
  RecyclerView  instead.
 RecyclerView offers similar features with better performance and more flexibility than
 ListView provides.
 See the
  
 Recycler View  guide.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.nfc.tech.NfcB: NfcB get(Tag)>,"Get an instance of NfcB for the given tag. Returns null if NfcB was not enumerated in Tag#getTechList .
 This indicates the tag does not support NFC-B. Does not cause any RF activity and does not block.",tag Tag : an NFC-B compatible tag |||,NfcB NFC-B object |||,10,"Provides access to NFC-B (ISO 14443-3B) properties and I/O operations on a  Tag .

  Acquire a  NfcB  object using  get(Tag) .
  The primary NFC-B I/O operation is  transceive(byte[]) . Applications must
 implement their own protocol stack on top of  transceive(byte[]) .

  Note:  Methods that perform I/O operations
 require the  Manifest.permission.NFC  permission.","These classes provide access to a tag technology's features which vary by the type
 of tag that is scanned. A scanned tag can support multiple technologies and you can find
 out what they are by calling  getTechList() . For more information on dealing with tag technologies and handling the ones that you care about see
  The Tag Dispatch System .
 The  TagTechnology  interface provides an overview of the
 supported technologies.",,,,,,,
<android.view.View: void setContentDescription(CharSequence)>,"Sets the View 's content description. A content description briefly describes the view and is primarily used
 for accessibility support to determine how a view should be presented to
 the user. In the case of a view with no textual representation such as ImageButton a useful content description
 explains what the view does. For example an image button with a phone
 icon that is used to place a call may use ""Call"" as its content
 description. An image of a floppy disk that is used to save a file may
 use ""Save"". Related XML Attributes: android:contentDescription",contentDescription CharSequence : The content description. |||,void,4,"This class represents the basic building block for user interface components. A View
 occupies a rectangular area on the screen and is responsible for drawing and
 event handling. View is the base class for  widgets  which are
 used to create interactive UI components (buttons text fields etc.). The
  ViewGroup  subclass is the base class for  layouts  which
 are invisible containers that hold other Views (or other ViewGroups) and define
 their layout properties.",,,,,,,,
<android.service.dreams.DreamService: IBinder onBind(Intent)>,"Return the communication channel to the service.  May return null if
 clients can not bind to the service.  The returned IBinder is usually for a complex interface
 that has been described using
 aidl . Note that unlike other application components calls on to the
 IBinder interface returned here may not happen on the main thread
 of the process .  More information about the main thread can be found in Processes and
 Threads .","intent Intent : The Intent that was used to bind to this service
as given to Context.bindService .  Note that any extras that were included with
the Intent at that point will not be seen here. |||","IBinder Return an IBinder through which clients can call on to the
         service. |||",17,"Extend this class to implement a custom dream (available to the user as a ""Daydream"").

  Dreams are interactive screensavers launched when a charging device is idle or docked in a
 desk dock. Dreams provide another modality for apps to express themselves tailored for
 an exhibition/lean-back experience. The  DreamService  lifecycle is as follows: onAttachedToWindow() Use this for initial setup such as calling  setContentView() . onDreamingStarted() Your dream has started so you should begin animations or other behaviors here. onDreamingStopped() Use this to stop the things you started in  onDreamingStarted() . onDetachedFromWindow() Use this to dismantle resources (for example detach from handlers
        and listeners). In addition onCreate and onDestroy (from the Service interface) will also be called but
 initialization and teardown should be done by overriding the hooks above. To be available to the system your  DreamService  should be declared in the
 manifest as follows: 
 <service
     android:name="".MyDream""
     android:exported=""true""
     android:icon=""@drawable/my_icon""
     android:label=""@string/my_dream_label"" >

     <intent-filter>
         <action android:name=""android.service.dreams.DreamService"" />
         <category android:name=""android.intent.category.DEFAULT"" />
     </intent-filter>

     <!-- Point to additional information for this dream (optional) -->
     <meta-data
         android:name=""android.service.dream""
         android:resource=""@xml/my_dream"" />
 </service>
  If specified with the  <meta-data>  element
 additional information for the dream is defined using the
  <dream>  element in a separate XML file.
 Currently the only addtional
 information you can provide is for a settings activity that allows the user to configure
 the dream behavior. For example: res/xml/my_dream.xml 
 <dream xmlns:android=""http://schemas.android.com/apk/res/android""
     android:settingsActivity=""com.example.app/.MyDreamSettingsActivity"" />
  This makes a Settings button available alongside your dream's listing in the
 system settings which when pressed opens the specified activity. To specify your dream layout call  setContentView(View)  typically during the
  onAttachedToWindow()  callback. For example: 
 public class MyDream extends DreamService {

     @Override
     public void onAttachedToWindow() {
         super.onAttachedToWindow();

         // Exit dream upon user touch
         setInteractive(false);
         // Hide system UI
         setFullscreen(true);
         // Set the dream layout
         setContentView(R.layout.dream);
     }
 }
  When targeting api level 21 and above you must declare the service in your manifest file
 with the  Manifest.permission.BIND_DREAM_SERVICE  permission. For example: 
 <service
     android:name="".MyDream""
     android:exported=""true""
     android:icon=""@drawable/my_icon""
     android:label=""@string/my_dream_label""
     android:permission=""android.permission.BIND_DREAM_SERVICE"">
   <intent-filter>
     <action android:name=”android.service.dreams.DreamService” />
     <category android:name=”android.intent.category.DEFAULT” />
   </intent-filter>
 </service>",,,,,,,,
<android.view.ViewPropertyAnimator: ViewPropertyAnimator yBy(float)>,"This method will cause the View's y property to be animated by the
 specified value. Animations already running on the property will be canceled.",value float : The amount to be animated by as an offset from the current value. |||,ViewPropertyAnimator This object allowing calls to methods in this class to be chained. |||,12,"This class enables automatic and optimized animation of select properties on View objects.
 If only one or two properties on a View object are being animated then using an
  ObjectAnimator  is fine; the property setters called by ObjectAnimator
 are well equipped to do the right thing to set the property and invalidate the view
 appropriately. But if several properties are animated simultaneously or if you just want a
 more convenient syntax to animate a specific property then ViewPropertyAnimator might be
 more well-suited to the task.

  This class may provide better performance for several simultaneous animations because
 it will optimize invalidate calls to take place only once for several properties instead of each
 animated property independently causing its own invalidation. Also the syntax of using this
 class could be easier to use because the caller need only tell the View object which
 property to animate and the value to animate either to or by and this class handles the
 details of configuring the underlying Animator class and starting it. This class is not constructed by the caller but rather by the View whose properties
 it will animate. Calls to  View.animate()  will return a reference
 to the appropriate ViewPropertyAnimator object for that View.",,,,,,,,
<android.database.sqlite.SQLiteStatement: ParcelFileDescriptor simpleQueryForBlobFileDescriptor()>,Executes a statement that returns a 1 by 1 table with a blob value.,,ParcelFileDescriptor A read-only file descriptor for a copy of the blob value or null if the value is null or could not be read for some reason. |||,11,"Represents a statement that can be executed against a database.  The statement
 cannot return multiple rows or columns but single value (1 x 1) result sets
 are supported.
  
 This class is not thread-safe.","If you need to manage data in a private database use the  android.database.sqlite  classes. These classes are used to manage the  Cursor  object returned from a content provider query. Databases
 are usually created and opened with  openOrCreateDatabase(String int SQLiteDatabase.CursorFactory) 
 To make requests through
 content providers you can use the  content.ContentResolver  class.
  All databases are stored on the device in  /data/data/<package_name>/databases",,,,,,,
<android.net.Proxy: String getHost(Context)>,"This method was deprecated
      in API level 15. Use standard java vm proxy values to find the host port
         and exclusion list.  This call ignores the exclusion list. Return the proxy host set by the user.",ctx Context : A Context used to get the settings for the proxy host. |||,"String String containing the host name. If the user did not set a host
         name it returns the default host. A null value means that no
         host is to be used. |||",1,"A convenience class for accessing the user and default proxy
 settings.",,,,,,,,
<android.app.DialogFragment: void onStart()>,"Called when the Fragment is visible to the user.  This is generally
 tied to Activity#onStart() of the containing
 Activity's lifecycle. If you override this method you must call through to the
 superclass implementation.",,void,11,"Base class for Dialogs.

  Note: Activities provide a facility to manage the creation saving and
 restoring of dialogs. See  Activity#onCreateDialog(int) 
  Activity#onPrepareDialog(int Dialog) 
  Activity#showDialog(int)  and  Activity#dismissDialog(int) . If
 these methods are used  getOwnerActivity()  will return the Activity
 that managed this dialog.

  Often you will want to have a Dialog display on top of the current
 input method because there is no reason for it to accept text.  You can
 do this by setting the  WindowManager.LayoutParams#FLAG_ALT_FOCUSABLE_IM  window flag (assuming
 your Dialog takes input focus as it the default) with the following code:

  
 getWindow().setFlags(WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM
         WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.view.Display: String getName()>,Gets the name of the display. Note that some displays may be renamed by the user.,,String The display's name. |||,17,"Provides information about the size and density of a logical display.
  
 The display area is described in two different ways.
  The application display area specifies the part of the display that may contain
 an application window excluding the system decorations.  The application display area may
 be smaller than the real display area because the system subtracts the space needed
 for decor elements such as the status bar.  Use the following methods to query the
 application display area:  getSize(Point)   getRectSize(Rect)  and  getMetrics(DisplayMetrics) . The real display area specifies the part of the display that contains content
 including the system decorations.  Even so the real display area may be smaller than the
 physical size of the display if the window manager is emulating a smaller display
 using (adb shell wm size).  Use the following methods to query the
 real display area:  getRealSize(Point)   getRealMetrics(DisplayMetrics) . 
 A logical display does not necessarily represent a particular physical display device
 such as the built-in screen or an external monitor.  The contents of a logical
 display may be presented on one or more physical displays according to the devices
 that are currently attached and whether mirroring has been enabled.",,,,,,,,
<android.app.WallpaperInfo: Drawable loadIcon(PackageManager)>,Load the user-displayed icon for this wallpaper.,"pm PackageManager : Supply a PackageManager used to load the wallpaper's
resources. |||",Drawable |||,7,This class is used to specify meta information of a wallpaper service.,"Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.os.Bundle: float getFloatArray(String)>,"Returns the value associated with the given key or null if
 no mapping of the desired type exists for the given key or a null
 value is explicitly associated with the key.","key String : a String or null
This value may be null . |||",float[] a float[] value or null |||,1,A mapping from String keys to various  Parcelable  values.,,,,,,,,
<android.view.Display: void getRealSize(Point)>,"Gets the real size of the display without subtracting any window decor or
 applying any compatibility scale factors. The size is adjusted based on the current rotation of the display. The real size may be smaller than the physical size of the screen when the
 window manager is emulating a smaller display (using adb shell wm size).",outSize Point : Set to the real size of the display. |||,void,17,"Provides information about the size and density of a logical display.
  
 The display area is described in two different ways.
  The application display area specifies the part of the display that may contain
 an application window excluding the system decorations.  The application display area may
 be smaller than the real display area because the system subtracts the space needed
 for decor elements such as the status bar.  Use the following methods to query the
 application display area:  getSize(Point)   getRectSize(Rect)  and  getMetrics(DisplayMetrics) . The real display area specifies the part of the display that contains content
 including the system decorations.  Even so the real display area may be smaller than the
 physical size of the display if the window manager is emulating a smaller display
 using (adb shell wm size).  Use the following methods to query the
 real display area:  getRealSize(Point)   getRealMetrics(DisplayMetrics) . 
 A logical display does not necessarily represent a particular physical display device
 such as the built-in screen or an external monitor.  The contents of a logical
 display may be presented on one or more physical displays according to the devices
 that are currently attached and whether mirroring has been enabled.",,,,,,,,
"<android.view.PointerIcon: PointerIcon getSystemIcon(Context,int)>","Gets a system pointer icon for the given type.
 If typeis not recognized returns the default pointer icon.","context Context : The context.
This value cannot be null . |||
type int : The pointer icon type. |||",PointerIcon The pointer icon. |||,24,"Represents an icon that can be used as a mouse pointer.
  
 Pointer icons can be provided either by the system using system types
 or by applications using bitmaps or application resources.",,,,,,,,
<android.content.res.Resources: int getColor(int)>,"This method was deprecated
      in API level 23. Use getColor(int android.content.res.Resources.Theme) instead. Returns a color integer associated with a particular resource ID. If the
 resource holds a complex ColorStateList then the default color
 from the set is returned.","id int : The desired resource identifier as generated by the aapt
tool. This integer encodes the package type and resource
entry. The value 0 is an invalid identifier. |||",int A single color value in the form 0xAARRGGBB. |||,1,"Class for accessing an application's resources.  This sits on top of the
 asset manager of the application (accessible through  getAssets() ) and
 provides a high-level API for getting typed data from the assets.

  The Android resource system keeps track of all non-code assets associated with an
 application. You can use this class to access your application's resources. You can generally
 acquire the  Resources  instance associated with your application
 with  getResources() . The Android SDK tools compile your application's resources into the application binary
 at build time.  To use a resource you must install it correctly in the source tree (inside
 your project's  res/  directory) and build your application.  As part of the build
 process the SDK tools generate symbols for each resource which you can use in your application
 code to access the resources. Using application resources makes it easy to update various characteristics of your
 application without modifying code and—by providing sets of alternative
 resources—enables you to optimize your application for a variety of device configurations
 (such as for different languages and screen sizes). This is an important aspect of developing
 Android applications that are compatible on different types of devices. For more information about using resources see the documentation about  Application Resources .","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
"<android.app.admin.DevicePolicyManager: void setPasswordMinimumNonLetter(ComponentName,int)>","Called by an application that is administering the device to set the minimum number of
 non-letter characters (numerical digits or symbols) required in the password. After setting
 this the user will not be able to enter a new password that is not at least as restrictive
 as what has been set. Note that the current password will remain until the user has set a new
 one so the change does not take place immediately. To prompt the user for a new password
 use ACTION_SET_NEW_PASSWORD or ACTION_SET_NEW_PARENT_PROFILE_PASSWORD after
 setting this value. This constraint is only imposed if the administrator has also requested PASSWORD_QUALITY_COMPLEX with setPasswordQuality(ComponentName int) . If an app targeting
 SDK level Build.VERSION_CODES.R and above enforces this constraint without
 settings password quality to PASSWORD_QUALITY_COMPLEX first this method will throw IllegalStateException . The default value is 0. On devices not supporting PackageManager#FEATURE_SECURE_LOCK_SCREEN feature the
 password is always treated as empty. The calling device admin must have requested DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD to be able to call this method; if it has
 not a security exception will be thrown. This method can be called on the DevicePolicyManager instance returned by getParentProfileInstance(android.content.ComponentName) in order to set restrictions on the parent
 profile.","admin ComponentName : Which DeviceAdminReceiver this request is associated with.
This value cannot be null . |||
length int : The new desired minimum number of letters required in the password. A value of
0 means there is no restriction. |||",void,11,"Public interface for managing policies enforced on a device. Most clients of this class must be
 registered with the system as a  device
 administrator . Additionally a device administrator may be registered as either a profile or
 device owner. A given method is accessible to all device administrators unless the documentation
 for that method specifies that it is restricted to either device or profile owners. Any
 application calling an api may only pass as an argument a device administrator component it
 owns. Otherwise a  SecurityException  will be thrown.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.os.HandlerThread: void run()>,"If this thread was constructed using a separate Runnable run object then that Runnable object's run method is called;
 otherwise this method does nothing and returns. Subclasses of Thread should override this method.",,void,1,"A  Thread  that has a  Looper .
 The  Looper  can then be used to create  Handler s.
  
 Note that just like with a regular  Thread   Thread.start()  must still be called.",,,,,,,,
"<android.content.res.Resources: Drawable getDrawableForDensity(int,int)>","This method was deprecated
      in API level 22. Use getDrawableForDensity(int int android.content.res.Resources.Theme) instead. Return a drawable object associated with a particular resource ID for the
 given screen density in DPI. This will set the drawable's density to be
 the device's density multiplied by the ratio of actual drawable density
 to requested density. This allows the drawable to be scaled up to the
 correct size if needed. Various types of objects will be returned
 depending on the underlying resource -- for example a solid color PNG
 image scalable image etc. The Drawable API hides these implementation
 details. Note: To obtain a themed drawable use Context.getDrawable(int) or getDrawableForDensity(int int android.content.res.Resources.Theme) passing the desired
 theme.","id int : The desired resource identifier as generated by the aapt tool.
This integer encodes the package type and resource entry.
The value 0 is an invalid identifier. |||
density int : the desired screen density indicated by the resource as
found in DisplayMetrics . A value of 0 means to use the
density returned from getConfiguration() .
This is equivalent to calling getDrawable(int) . |||","Drawable Drawable An object that can be used to draw this resource.
 This value may be null . |||",15,"Class for accessing an application's resources.  This sits on top of the
 asset manager of the application (accessible through  getAssets() ) and
 provides a high-level API for getting typed data from the assets.

  The Android resource system keeps track of all non-code assets associated with an
 application. You can use this class to access your application's resources. You can generally
 acquire the  Resources  instance associated with your application
 with  getResources() . The Android SDK tools compile your application's resources into the application binary
 at build time.  To use a resource you must install it correctly in the source tree (inside
 your project's  res/  directory) and build your application.  As part of the build
 process the SDK tools generate symbols for each resource which you can use in your application
 code to access the resources. Using application resources makes it easy to update various characteristics of your
 application without modifying code and—by providing sets of alternative
 resources—enables you to optimize your application for a variety of device configurations
 (such as for different languages and screen sizes). This is an important aspect of developing
 Android applications that are compatible on different types of devices. For more information about using resources see the documentation about  Application Resources .","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.net.sip.SipSession: void register(int)>,"Performs registration to the server specified by the associated local
 profile. The session listener is called back upon success or failure of
 registration. The method is only valid to call when the session state is
 in State#READY_TO_CALL .",duration int : duration in second before the registration expires |||,void,9,"Represents a SIP session that is associated with a SIP dialog or a standalone
 transaction not within a dialog.
  You can get a  SipSession  from  SipManager  with  SipManager#createSipSession  (when initiating calls) or  SipManager#getSessionFor  (when receiving calls).",,,,,,,,
"<android.view.inputmethod.InputConnectionWrapper: ExtractedText getExtractedText(ExtractedTextRequest,int)>","Retrieve the current text in the input connection's editor and
 monitor for any changes to it. This function returns with the
 current text and optionally the input connection can send
 updates to the input method when its text changes. This method may fail either if the input connection has
 become invalid (such as its process crashing) or the client is
 taking too long to respond with the text (it is given a couple
 seconds to return). In either case null is returned. Editor authors: as a general rule try to comply with the
 fields in request for how many chars to return
 but if performance or convenience dictates otherwise please
 feel free to do what is most appropriate for your case. Also
 if the GET_EXTRACTED_TEXT_MONITOR flag is set you should be
 calling InputMethodManager#updateExtractedText(View int ExtractedText) whenever you call InputMethodManager#updateSelection(View int int int int) .","request ExtractedTextRequest : Description of how the text should be returned. ExtractedTextRequest |||
flags int : Additional options to control the client either 0 or InputConnection.GET_EXTRACTED_TEXT_MONITOR . |||","ExtractedText an ExtractedText object describing the state of the text view and containing the
 extracted text itself or null if the input connection is no
 longer valid of the editor can't comply with the request for
 some reason. |||",3,Wrapper class for proxying calls to another InputConnection.  Subclass and have fun!,,,,,,,,
<android.content.ContentResolver: void validateSyncExtrasBundle(Bundle)>,"Check that only values of the following types are in the Bundle: Integer 
Long 
Boolean 
Float 
Double 
String 
Account 
null",extras Bundle : the Bundle to check |||,void,1,This class provides applications access to the content model.,"Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.preference.PreferenceFragment: void onSaveInstanceState(Bundle)>,"Called to ask the fragment to save its current dynamic state so it
 can later be reconstructed in a new instance of its process is
 restarted.  If a new instance of the fragment later needs to be
 created the data you place in the Bundle here will be available
 in the Bundle given to onCreate(android.os.Bundle)  onCreateView(android.view.LayoutInflater android.view.ViewGroup android.os.Bundle) and onActivityCreated(android.os.Bundle) . This corresponds to Activity#onSaveInstanceState(Bundle) and most of the discussion there
 applies here as well.  Note however: this method may be called
 at any time before onDestroy() .  There are many situations
 where a fragment may be mostly torn down (such as when placed on the
 back stack with no UI showing) but its state will not be saved until
 its owning activity actually needs to save its state.",outState Bundle : Bundle in which to place your saved state. |||,void,11,"Represents the basic Preference UI building
 block displayed by a  PreferenceActivity  in the form of a
  ListView . This class provides the  View  to be displayed in
 the activity and associates with a  SharedPreferences  to
 store/retrieve the preference data.
  
 When specifying a preference hierarchy in XML each element can point to a
 subclass of  Preference  similar to the view hierarchy and layouts.
  
 This class contains a  key  that will be used as the key into the
  SharedPreferences . It is up to the subclass to decide how to store
 the value.",,,,,,,,
"<android.net.sip.SipManager: void setRegistrationListener(String,SipRegistrationListener)>","Sets the listener to listen to registration events. No effect if the
 profile has not been opened to receive calls (see open(android.net.sip.SipProfile android.app.PendingIntent android.net.sip.SipRegistrationListener) ).","localProfileUri String : the URI of the profile |||
listener SipRegistrationListener : to listen to registration events; can be null |||",void,9,"Provides APIs for SIP tasks such as initiating SIP connections and provides access to related
 SIP services. This class is the starting point for any SIP actions. You can acquire an instance
 of it with  newInstance() . The APIs in this class allows you to: Create a  SipSession  to get ready for making calls or listen for incoming calls. See
  createSipSession()  and  getSessionFor() . Initiate and receive generic SIP calls or audio-only SIP calls. Generic SIP calls may
 be video audio or other and are initiated with  open() . Audio-only SIP calls
 should be handled with a  SipAudioCall  which you can acquire with  makeAudioCall()  and  takeAudioCall() . Register and unregister with a SIP service provider with
       register()  and  unregister() . Verify session connectivity with  isOpened()  and
       isRegistered() . Note:  Not all Android-powered devices support VOIP calls using
 SIP. You should always call  isVoipSupported()  to verify that the device supports VOIP calling and  isApiSupported()  to verify that the device supports
 the SIP APIs. Your application must also request the  Manifest.permission.INTERNET  and  Manifest.permission.USE_SIP 
 permissions.",,,,,,,,
<android.app.LauncherActivity: void setTitle(CharSequence)>,"Change the title associated with this activity.  If this is a
 top-level activity the title for its window will change.  If it
 is an embedded activity the parent can do whatever it wants
 with it.",title CharSequence |||,void,1,"Displays a list of all activities which can be performed
 for a given intent. Launches when clicked.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.bluetooth.BluetoothDevice: BluetoothSocket createInsecureRfcommSocketToServiceRecord(UUID)>,"Create an RFCOMM BluetoothSocket socket ready to start an insecure
 outgoing connection to this remote device using SDP lookup of uuid. The communication channel will not have an authenticated link key
 i.e it will be subject to man-in-the-middle attacks. For Bluetooth 2.1
 devices the link key will be encrypted as encryption is mandatory.
 For legacy devices (pre Bluetooth 2.1 devices) the link key will
 be not be encrypted. Use createRfcommSocketToServiceRecord(UUID) if an
 encrypted and authenticated communication channel is desired. This is designed to be used with BluetoothAdapter#listenUsingInsecureRfcommWithServiceRecord for peer-peer
 Bluetooth applications. Use BluetoothSocket#connect to initiate the outgoing
 connection. This will also perform an SDP lookup of the given uuid to
 determine which channel to connect to. The remote device will be authenticated and communication on this
 socket will be encrypted. Hint: If you are connecting to a Bluetooth serial board then try
 using the well-known SPP UUID 00001101-0000-1000-8000-00805F9B34FB.
 However if you are connecting to an Android peer then please generate
 your own unique UUID. Requires Manifest.permission.BLUETOOTH",uuid UUID : service record uuid to lookup RFCOMM channel |||,BluetoothSocket a RFCOMM BluetoothServerSocket ready for an outgoing connection |||,10,"Represents a remote Bluetooth device. A  BluetoothDevice  lets you
 create a connection with the respective device or query information about
 it such as the name address class and bonding state.

  This class is really just a thin wrapper for a Bluetooth hardware
 address. Objects of this class are immutable. Operations on this class
 are performed on the remote Bluetooth hardware address using the
  BluetoothAdapter  that was used to create this  BluetoothDevice .

  To get a  BluetoothDevice  use
  BluetoothAdapter#getRemoteDevice(String)  to create one representing a device
 of a known MAC address (which you can get through device discovery with
  BluetoothAdapter ) or get one from the set of bonded devices
 returned by  BluetoothAdapter#getBondedDevices() . You can then open a
  BluetoothSocket  for communication with the remote device using
  createRfcommSocketToServiceRecord(java.util.UUID)  over Bluetooth BR/EDR or using
  createL2capChannel(int)  over Bluetooth LE.

  Note: 
 Requires the  Manifest.permission.BLUETOOTH  permission.","Provides classes that manage Bluetooth functionality such as scanning for
 devices connecting with devices and managing data transfer between devices.
 The Bluetooth API supports both ""Classic Bluetooth"" and Bluetooth Low Energy. For more information about Classic Bluetooth see the
  Bluetooth  guide.
 For more information about Bluetooth Low Energy see the
  
 Bluetooth Low Energy  (BLE) guide. The Bluetooth APIs let applications: Scan for other Bluetooth devices (including BLE devices). Query the local Bluetooth adapter for paired Bluetooth devices. Establish RFCOMM channels/sockets. Connect to specified sockets on other devices. Transfer data to and from other devices. Communicate with BLE devices such as proximity sensors heart rate
     monitors fitness devices and so on. Act as a GATT client or a GATT server (BLE). 
 To perform Bluetooth communication using these APIs an application must
 declare the  BLUETOOTH  permission. Some
 additional functionality such as requesting device discovery
 also requires the  BLUETOOTH_ADMIN 
 permission.
  Note: 
 Not all Android-powered devices provide Bluetooth functionality.",,,,,,,
<android.widget.SearchView: void setQueryHint(CharSequence)>,"Sets the hint text to display in the query text field. This overrides
 any hint specified in the SearchableInfo . This value may be specified as an empty string to prevent any query hint
 from being displayed. Related XML Attributes: android:queryHint","hint CharSequence : the hint text to display or null to clear
This value may be null . |||",void,11,"A widget that provides a user interface for the user to enter a search query and submit a request
 to a search provider. Shows a list of query suggestions or results if available and allows the
 user to pick a suggestion or result to launch into.

  
 When the SearchView is used in an ActionBar as an action view for a collapsible menu item it
 needs to be set to iconified by default using  setIconifiedByDefault(true) . This is the default so nothing needs to be done.
  
 If you want the search field to always be visible then call setIconifiedByDefault(false).","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.content.Intent: byte getByteArrayExtra(String)>,Retrieve extended data from the intent.,name String : The name of the desired item. |||,"byte[] the value of an item previously added with putExtra()
 or null if no byte array value was found. |||",1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.webkit.WebView: void invokeZoomPicker()>,"Invokes the graphical zoom picker widget for this WebView. This will
 result in the zoom widget appearing on the screen to control the zoom
 level of this WebView.",,void,1,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",,,,,,,
<android.view.View: void setDrawingCacheQuality(int)>,"This method was deprecated
      in API level 28. The view drawing cache was largely made obsolete with the introduction of
 hardware-accelerated rendering in API 11. With hardware-acceleration intermediate cache
 layers are largely unnecessary and can easily result in a net loss in performance due to the
 cost of creating and updating the layer. In the rare cases where caching layers are useful
 such as for alpha animations setLayerType(int android.graphics.Paint) handles this with hardware
 rendering. For software-rendered snapshots of a small part of the View hierarchy or
 individual Views it is recommended to create a Canvas from either a Bitmap or Picture and call draw(android.graphics.Canvas) on the View. However these
 software-rendered usages are discouraged and have compatibility issues with hardware-only
 rendering features such as Config.HARDWARE bitmaps real-time shadows and outline clipping. For screenshots of the UI for feedback
 reports or unit testing the PixelCopy API is recommended. Set the drawing cache quality of this view. This value is used only when the
 drawing cache is enabled Related XML Attributes: android:drawingCacheQuality",quality int : One of DRAWING_CACHE_QUALITY_AUTO  DRAWING_CACHE_QUALITY_LOW or DRAWING_CACHE_QUALITY_HIGH Value is DRAWING_CACHE_QUALITY_LOW  DRAWING_CACHE_QUALITY_HIGH or DRAWING_CACHE_QUALITY_AUTO |||,void,1,"This class represents the basic building block for user interface components. A View
 occupies a rectangular area on the screen and is responsible for drawing and
 event handling. View is the base class for  widgets  which are
 used to create interactive UI components (buttons text fields etc.). The
  ViewGroup  subclass is the base class for  layouts  which
 are invisible containers that hold other Views (or other ViewGroups) and define
 their layout properties.",,,,,,,,
<android.nfc.tech.MifareUltralight: void setTimeout(int)>,"Set the transceive(byte[]) timeout in milliseconds. The timeout only applies to transceive(byte[]) on this object
 and is reset to a default value when close() is called. Setting a longer timeout may be useful when performing
 transactions that require a long processing time on the tag
 such as key generation. Requires the Manifest.permission.NFC permission.",timeout int : timeout value in milliseconds |||,void,14,"Provides access to MIFARE Ultralight properties and I/O operations on a  Tag .

  Acquire a  MifareUltralight  object using  get(Tag) .

  MIFARE Ultralight compatible tags have 4 byte pages  PAGE_SIZE .
 The primary operations on an Ultralight tag are  readPages(int)  and
  writePage(int byte[]) .

  The original MIFARE Ultralight consists of a 64 byte EEPROM. The first
 4 pages are for the OTP area manufacturer data and locking bits. They are
 readable and some bits are writable. The final 12 pages are the user
 read/write area. For more information see the NXP data sheet MF0ICU1.

  The MIFARE Ultralight C consists of a 192 byte EEPROM. The first 4 pages
 are for OTP manufacturer data and locking bits. The next 36 pages are the
 user read/write area. The next 4 pages are additional locking bits counters
 and authentication configuration and are readable. The final 4 pages are for
 the authentication key and are not readable. For more information see the
 NXP data sheet MF0ICU2.

  Implementation of this class on a Android NFC device is optional.
 If it is not implemented then
  MifareUltralight  will never be enumerated in  Tag#getTechList .
 If it is enumerated then all  MifareUltralight  I/O operations will be supported.
 In either case  NfcA  will also be enumerated on the tag
 because all MIFARE Ultralight tags are also  NfcA  tags.

  Note:  Methods that perform I/O operations
 require the  Manifest.permission.NFC  permission.","These classes provide access to a tag technology's features which vary by the type
 of tag that is scanned. A scanned tag can support multiple technologies and you can find
 out what they are by calling  getTechList() . For more information on dealing with tag technologies and handling the ones that you care about see
  The Tag Dispatch System .
 The  TagTechnology  interface provides an overview of the
 supported technologies.",,,,,,,
<android.database.sqlite.SQLiteDatabase: void beginTransaction()>,"Begins a transaction in EXCLUSIVE mode. Transactions can be nested.
 When the outer transaction is ended all of
 the work done in that transaction and all of the nested transactions will be committed or
 rolled back. The changes will be rolled back if any transaction is ended without being
 marked as clean (by calling setTransactionSuccessful). Otherwise they will be committed. Here is the standard idiom for transactions:",,void,1,"Exposes methods to manage a SQLite database.

  
 SQLiteDatabase has methods to create delete execute SQL commands and
 perform other common database management tasks.
  
 See the Notepad sample application in the SDK for an example of creating
 and managing a database.
  
 Database names must be unique within an application not across all applications.
  Localized Collation - ORDER BY 
 In addition to SQLite's default  BINARY  collator Android supplies
 two more  LOCALIZED  which changes with the system's current locale
 and  UNICODE  which is the Unicode Collation Algorithm and not tailored
 to the current locale.","If you need to manage data in a private database use the  android.database.sqlite  classes. These classes are used to manage the  Cursor  object returned from a content provider query. Databases
 are usually created and opened with  openOrCreateDatabase(String int SQLiteDatabase.CursorFactory) 
 To make requests through
 content providers you can use the  content.ContentResolver  class.
  All databases are stored on the device in  /data/data/<package_name>/databases",,,,,,,
<android.widget.Switch: void setThumbResource(int)>,"Set the drawable used for the switch ""thumb"" - the piece that the user
 can physically touch and drag along the track. Related XML Attributes: android:thumb",resId int : Resource ID of a thumb drawable |||,void,16,"A Switch is a two-state toggle switch widget that can select between two
 options. The user may drag the ""thumb"" back and forth to choose the selected option
 or simply tap to toggle as if it were a checkbox. The  text 
 property controls the text displayed in the label for the switch whereas the
  off  and  on  text
 controls the text on the thumb. Similarly the
  textAppearance  and the related
 setTypeface() methods control the typeface and style of label text whereas the
  switchTextAppearance  and
 the related setSwitchTypeface() methods control that of the thumb.

  SwitchCompat  is a version of
 the Switch widget which runs on devices back to API 7. See the  Toggle Buttons 
 guide.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.app.Activity: void finishActivity(int)>,Force finish another activity that you had previously started with startActivityForResult(Intent int) .,"requestCode int : The request code of the activity that you had
given to startActivityForResult().  If there are multiple
activities started with this request code they
will all be finished. |||",void,1,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
"<android.test.TouchUtils: void scrollToBottom(InstrumentationTestCase,Activity,ViewGroup)>",Scroll a ViewGroup to the bottom by repeatedly calling dragQuarterScreenUp(android.test.InstrumentationTestCase android.app.Activity),"test InstrumentationTestCase : The test case that is being run |||
activity Activity : The activity that is in the foreground of the test case |||
v ViewGroup : The ViewGroup that should be dragged |||",void,3,"Reusable methods for generating touch events. These methods can be used with
 InstrumentationTestCase or ActivityInstrumentationTestCase2 to simulate user interaction with
 the application through a touch screen.",,,,,,,,
<android.app.backup.BackupManager: void dataChanged(String)>,"Convenience method for callers who need to indicate that some other package
 needs a backup pass.  This can be useful in the case of groups of packages
 that share a uid. This method requires that the application hold the ""android.permission.BACKUP""
 permission if the package named in the argument does not run under the same uid
 as the caller.",packageName String : The package name identifying the application to back up. |||,void,8,"The interface through which an application interacts with the Android backup service to
 request backup and restore operations.
 Applications instantiate it using the constructor and issue calls through that instance.
  
 When an application has made changes to data which should be backed up a
 call to  dataChanged()  will notify the backup service. The system
 will then schedule a backup operation to occur in the near future. Repeated
 calls to  dataChanged()  have no further effect until the backup
 operation actually occurs.
  
 A backup or restore operation for your application begins when the system launches the
  BackupAgent  subclass you've declared in your manifest. See the
 documentation for  BackupAgent  for a detailed description
 of how the operation then proceeds.
  
 Several attributes affecting the operation of the backup and restore mechanism
 can be set on the  <application> 
 tag in your application's AndroidManifest.xml file.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
"<android.database.sqlite.SQLiteQueryBuilder: Cursor query(SQLiteDatabase,String,String,String,String,String,String)>","Perform a query by combining all current settings and the
 information passed into this method.","db SQLiteDatabase : the database to query on |||
projectionIn String : A list of which columns to return. Passing
null will return all columns which is discouraged to prevent
reading data from storage that isn't going to be used. |||
selection String : A filter declaring which rows to return
formatted as an SQL WHERE clause (excluding the WHERE itself). Passing null will return all rows for the given URL. |||
selectionArgs String : You may include ?s in selection which
will be replaced by the values from selectionArgs in order
that they appear in the selection. The values will be bound
as Strings. |||
groupBy String : A filter declaring how to group rows formatted
as an SQL GROUP BY clause (excluding the GROUP BY itself). Passing null will cause the rows to not be grouped. |||
having String : A filter declare which row groups to include in
the cursor if row grouping is being used formatted as an
SQL HAVING clause (excluding the HAVING itself).  Passing
null will cause all row groups to be included and is
required when row grouping is not being used. |||
sortOrder String : How to order the rows formatted as an SQL ORDER BY clause (excluding the ORDER BY itself). Passing null
will use the default sort order which may be unordered. |||",Cursor a cursor over the result set |||,1,"This is a convenience class that helps build SQL queries to be sent to
  SQLiteDatabase  objects.","If you need to manage data in a private database use the  android.database.sqlite  classes. These classes are used to manage the  Cursor  object returned from a content provider query. Databases
 are usually created and opened with  openOrCreateDatabase(String int SQLiteDatabase.CursorFactory) 
 To make requests through
 content providers you can use the  content.ContentResolver  class.
  All databases are stored on the device in  /data/data/<package_name>/databases",,,,,,,
<android.content.ContextWrapper: void sendBroadcast(Intent)>,"Broadcast the given intent to all interested BroadcastReceivers.  This
 call is asynchronous; it returns immediately and you will continue
 executing while the receivers are run.  No results are propagated from
 receivers and receivers can not abort the broadcast. If you want
 to allow receivers to propagate results or abort the broadcast you must
 send an ordered broadcast using sendOrderedBroadcast(android.content.Intent java.lang.String) . See BroadcastReceiver for more information on Intent broadcasts.","intent Intent : The Intent to broadcast; all receivers matching this
Intent will receive the broadcast. |||",void,1,"Proxying implementation of Context that simply delegates all of its calls to
 another Context.  Can be subclassed to modify behavior without changing
 the original Context.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.view.ViewPropertyAnimator: ViewPropertyAnimator alpha(float)>,"This method will cause the View's alpha property to be animated to the
 specified value. Animations already running on the property will be canceled.",value float : The value to be animated to. |||,ViewPropertyAnimator This object allowing calls to methods in this class to be chained. |||,12,"This class enables automatic and optimized animation of select properties on View objects.
 If only one or two properties on a View object are being animated then using an
  ObjectAnimator  is fine; the property setters called by ObjectAnimator
 are well equipped to do the right thing to set the property and invalidate the view
 appropriately. But if several properties are animated simultaneously or if you just want a
 more convenient syntax to animate a specific property then ViewPropertyAnimator might be
 more well-suited to the task.

  This class may provide better performance for several simultaneous animations because
 it will optimize invalidate calls to take place only once for several properties instead of each
 animated property independently causing its own invalidation. Also the syntax of using this
 class could be easier to use because the caller need only tell the View object which
 property to animate and the value to animate either to or by and this class handles the
 details of configuring the underlying Animator class and starting it. This class is not constructed by the caller but rather by the View whose properties
 it will animate. Calls to  View.animate()  will return a reference
 to the appropriate ViewPropertyAnimator object for that View.",,,,,,,,
<android.appwidget.AppWidgetHost: void deleteAllHosts()>,"Remove all records about all hosts for your package. Call this when initializing your database as it might be because of a data wipe. 
Call this to have the AppWidget manager release all resources associated with your
   host.  Any future calls about this host will cause the records to be re-allocated.",,void,3,"AppWidgetHost provides the interaction with the AppWidget service for apps
 like the home screen that want to embed AppWidgets in their UI.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
