Unnamed: 0.1,Description,Parameters,Return,ApiLevel,ClassDescription,PackageDescription,sensitive data?,shared resource?,sensitive shared resource?,produces sensitive data from shared resource?,writes sensitive data to shared resource?,Source?,Sink?
<android.app.Instrumentation: void sendTrackballEventSync(MotionEvent)>,"Dispatch a trackball event. Finished at some point after the recipient has
 returned from its event processing though it may not have
 completely finished reacting from the event -- for example if it needs
 to update its display as a result it may still be in the process of
 doing that.",event MotionEvent : A motion event describing the trackball action.  (As noted in MotionEvent#obtain(long long int float float int) be sure to use SystemClock#uptimeMillis() as the timebase. |||,void,1,"Base class for implementing application instrumentation code.  When running
 with instrumentation turned on this class will be instantiated for you
 before any of the application code allowing you to monitor all of the
 interaction the system has with the application.  An Instrumentation
 implementation is described to the system through an AndroidManifest.xml's
 <instrumentation> tag.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.widget.AlphabetIndexer: void onChanged()>,"This method is called when the entire data set has changed
 most likely through a call to Cursor#requery() on a Cursor .",,void,3,"A helper class for adapters that implement the SectionIndexer interface.
 If the items in the adapter are sorted by simple alphabet-based sorting then
 this class provides a way to do fast indexing of large lists using binary search.
 It caches the indices that have been determined through the binary search and also
 invalidates the cache if changes occur in the cursor.
  setCursor(Cursor) getPositionForSection(int)","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.inputmethodservice.InputMethodService: void onDestroy()>,"Called by the system to notify a Service that it is no longer used and is being removed.  The
 service should clean up any resources it holds (threads registered
 receivers etc) at this point.  Upon return there will be no more calls
 in to this Service object and it is effectively dead.  Do not call this method directly.",,void,3,"InputMethodService provides a standard implementation of an InputMethod
 which final implementations can derive from and customize.  See the
 base class  AbstractInputMethodService  and the  InputMethod 
 interface for more information on the basics of writing input methods.

  In addition to the normal Service lifecycle methods this class
 introduces some new specific callbacks that most subclasses will want
 to make use of: onInitializeInterface()  for user-interface initialization
 in particular to deal with configuration changes while the service is
 running.
  onBindInput()  to find out about switching to a new client.
  onStartInput(EditorInfo boolean)  to deal with an input session starting with
 the client.
  onCreateInputView()   onCreateCandidatesView() 
 and  onCreateExtractTextView()  for non-demand generation of the UI.
  onStartInputView(android.view.inputmethod.EditorInfo boolean)  to deal with input
 starting within the input area of the IME.
  An input method has significant discretion in how it goes about its
 work: the  InputMethodService  provides
 a basic framework for standard UI elements (input view candidates view
 and running in fullscreen mode) but it is up to a particular implementor
 to decide how to use them.  For example one input method could implement
 an input area with a keyboard another could allow the user to draw text
 while a third could have no input area (and thus not be visible to the
 user) but instead listen to audio and perform text to speech conversion. In the implementation provided here all of these elements are placed
 together in a single window managed by the InputMethodService.  It will
 execute callbacks as it needs information about them and provides APIs for
 programmatic control over them.  They layout of these elements is explicitly
 defined: The soft input view if available is placed at the bottom of the
 screen.
  The candidates view if currently shown is placed above the soft
 input view.
  If not running fullscreen the application is moved or resized to be
 above these views; if running fullscreen the window will completely cover
 the application and its top part will contain the extract text of what is
 currently being edited by the application.
  Soft Input View Central to most input methods is the soft input view.  This is where most
 user interaction occurs: pressing on soft keys drawing characters or
 however else your input method wants to generate text.  Most implementations
 will simply have their own view doing all of this work and return a new
 instance of it when  onCreateInputView()  is called.  At that point
 as long as the input view is visible you will see user interaction in
 that view and can call back on the InputMethodService to interact with the
 application as appropriate. There are some situations where you want to decide whether or not your
 soft input view should be shown to the user.  This is done by implementing
 the  onEvaluateInputViewShown()  to return true or false based on
 whether it should be shown in the current environment.  If any of your
 state has changed that may impact this call
  updateInputViewShown()  to have it re-evaluated.  The default
 implementation always shows the input view unless there is a hard
 keyboard available which is the appropriate behavior for most input
 methods. Candidates View Often while the user is generating raw text an input method wants to
 provide them with a list of possible interpretations of that text that can
 be selected for use.  This is accomplished with the candidates view and
 like the soft input view you implement  onCreateCandidatesView() 
 to instantiate your own view implementing your candidates UI. Management of the candidates view is a little different than the input
 view because the candidates view tends to be more transient being shown
 only when there are possible candidates for the current text being entered
 by the user.  To control whether the candidates view is shown you use
  setCandidatesViewShown(boolean) .  Note that because the candidate
 view tends to be shown and hidden a lot it does not impact the application
 UI in the same way as the soft input view: it will never cause application
 windows to resize only cause them to be panned if needed for the user to
 see the current focus. Fullscreen Mode Sometimes your input method UI is too large to integrate with the
 application UI so you just want to take over the screen.  This is
 accomplished by switching to full-screen mode causing the input method
 window to fill the entire screen and add its own ""extracted text"" editor
 showing the user the text that is being typed.  Unlike the other UI elements
 there is a standard implementation for the extract editor that you should
 not need to change.  The editor is placed at the top of the IME above the
 input and candidates views. Similar to the input view you control whether the IME is running in
 fullscreen mode by implementing  onEvaluateFullscreenMode() 
 to return true or false based on
 whether it should be fullscreen in the current environment.  If any of your
 state has changed that may impact this call
  updateFullscreenMode()  to have it re-evaluated.  The default
 implementation selects fullscreen mode when the screen is in a landscape
 orientation which is appropriate behavior for most input methods that have
 a significant input area. When in fullscreen mode you have some special requirements because the
 user can not see the application UI.  In particular you should implement
  onDisplayCompletions(android.view.inputmethod.CompletionInfo[])  to show completions
 generated by your application typically in your candidates view like you
 would normally show candidates.


  Generating Text The key part of an IME is of course generating text for the application.
 This is done through calls to the
  InputConnection  interface to the
 application which can be retrieved from  getCurrentInputConnection() .
 This interface allows you to generate raw key events or if the target
 supports it directly edit in strings of candidates and committed text. Information about what the target is expected and supports can be found
 through the  EditorInfo  class which is
 retrieved with  getCurrentInputEditorInfo()  method.  The most
 important part of this is  EditorInfo.inputType ; in particular if this is
  EditorInfo.TYPE_NULL 
 then the target does not support complex edits and you need to only deliver
 raw key events to it.  An input method will also want to look at other
 values here to for example detect password mode auto complete text views
 phone number entry etc. When the user switches between input targets you will receive calls to
  onFinishInput()  and  onStartInput(android.view.inputmethod.EditorInfo boolean) .
 You can use these to reset and initialize your input state for the current
 target.  For example you will often want to clear any input state and
 update a soft keyboard to be appropriate for the new inputType.",,,,,,,,
<android.webkit.WebView: WebBackForwardList copyBackForwardList()>,"Gets the WebBackForwardList for this WebView. This contains the
 back/forward list for use in querying each item in the history stack.
 This is a copy of the private WebBackForwardList so it contains only a
 snapshot of the current state. Multiple calls to this method may return
 different objects. The object returned from this method will not be
 updated to reflect any new state.",,WebBackForwardList This value will never be null . |||,1,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",,,,,,,
<android.app.Activity: void setRequestedOrientation(int)>,"Change the desired orientation of this activity.  If the activity
 is currently in the foreground or otherwise impacting the screen
 orientation the screen will immediately be changed (possibly causing
 the activity to be restarted). Otherwise this will be used the next
 time the activity is visible.","requestedOrientation int : An orientation constant as used in ActivityInfo#screenOrientation .
Value is android.content.pm.ActivityInfo.SCREEN_ORIENTATION_UNSET ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED  ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE  ActivityInfo.SCREEN_ORIENTATION_PORTRAIT  ActivityInfo.SCREEN_ORIENTATION_USER  ActivityInfo.SCREEN_ORIENTATION_BEHIND  ActivityInfo.SCREEN_ORIENTATION_SENSOR  ActivityInfo.SCREEN_ORIENTATION_NOSENSOR  ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE  ActivityInfo.SCREEN_ORIENTATION_SENSOR_PORTRAIT  ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE  ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT  ActivityInfo.SCREEN_ORIENTATION_FULL_SENSOR  ActivityInfo.SCREEN_ORIENTATION_USER_LANDSCAPE  ActivityInfo.SCREEN_ORIENTATION_USER_PORTRAIT  ActivityInfo.SCREEN_ORIENTATION_FULL_USER or ActivityInfo.SCREEN_ORIENTATION_LOCKED |||",void,1,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.app.ActivityManager: List getRunningAppProcesses()>,"Returns a list of application processes that are running on the device. Note: this method is only intended for debugging or building
 a user-facing process management UI.",,"List < ActivityManager.RunningAppProcessInfo > Returns a list of RunningAppProcessInfo records or null if there are no
 running processes (it will not return an empty list).  This list ordering is not
 specified. |||",3,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.app.Instrumentation: void callActivityOnStart(Activity)>,Perform calling of an activity's Activity#onStart method.  The default implementation simply calls through to that method.,activity Activity : The activity being started. |||,void,1,"Base class for implementing application instrumentation code.  When running
 with instrumentation turned on this class will be instantiated for you
 before any of the application code allowing you to monitor all of the
 interaction the system has with the application.  An Instrumentation
 implementation is described to the system through an AndroidManifest.xml's
 <instrumentation> tag.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.location.LocationManager: void removeUpdates(LocationListener)>,"Removes location updates for the specified LocationListener . Following this call
 the listener will no longer receive location updates. Requires Manifest.permission.ACCESS_COARSE_LOCATION or Manifest.permission.ACCESS_FINE_LOCATION","listener LocationListener : listener that no longer needs location updates
This value must never be null . |||",void,1,"A data class representing a geographic location.

  A location can consist of a latitude longitude timestamp
 and other information such as bearing altitude and velocity.

  All locations generated by the  LocationManager  are
 guaranteed to have a valid latitude longitude and timestamp
 (both UTC time and elapsed real-time since boot) all other
 parameters are optional.","Contains the framework API classes that define Android location-based and
 	related services. This API is not the recommended method for accessing Android location. 
 The
  Google Location Services API 
 part of Google Play services is the preferred way to add location-awareness to
 your app. It offers a simpler API higher accuracy low-power geofencing and
 more. If you are currently using the android.location API you are strongly
 encouraged to switch to the Google Location Services API as soon as
 possible.
  
 To learn more about the Google Location Services API see the
  Location API overview .",,,,,,,
"<android.widget.PopupWindow: void update(View,int,int)>","Updates the position and the dimension of the popup window. Calling this function also updates the window with the current popup
 state as described for update() .","anchor View : the popup's anchor view |||
width int : the new width in pixels must be >= 0 or -1 to ignore |||
height int : the new height in pixels must be >= 0 or -1 to ignore |||",void,1,"This class represents a popup window that can be used to display an
 arbitrary view. The popup window is a floating container that appears on top
 of the current activity.
  Animation 
 On all versions of Android popup window enter and exit animations may be
 specified by calling  setAnimationStyle(int)  and passing the
 resource ID for an animation style that defines  windowEnterAnimation 
 and  windowExitAnimation . For example passing
  R.style.Animation_Dialog  will give a scale and alpha
 animation.
 
 A window animation style may also be specified in the popup window's style
 XML via the  popupAnimationStyle 
 attribute.
  
 Starting with API 23 more complex popup window enter and exit transitions
 may be specified by calling either  setEnterTransition(android.transition.Transition) 
 or  setExitTransition(android.transition.Transition)  and passing a   Transition .
 
 Popup enter and exit transitions may also be specified in the popup window's
 style XML via the  popupEnterTransition 
 and  popupExitTransition 
 attributes respectively.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
"<android.os.Bundle: void putFloatArray(String,float)>","Inserts a float array value into the mapping of this Bundle replacing
 any existing value for the given key.  Either key or value may be null.","key String : a String or null
This value may be null . |||
value float : a float array object or null
This value may be null . |||",void,1,A mapping from String keys to various  Parcelable  values.,,,,,,,,
<android.text.SpannedString: SpannedString valueOf(CharSequence)>,,source CharSequence |||,SpannedString |||,1,"This is the class for text whose content and markup are immutable.
 For mutable markup see  SpannableString ; for mutable text
 see  SpannableStringBuilder .","Provides classes used to render or track text and text spans on the screen. You can use these classes to design your own widgets that manage text
 to handle arbitrary text spans for changes or to handle drawing yourself
 for an existing widget. The Span… interfaces and classes are used to create or manage spans of
 text in a View item. You can use these to style the text or background or to
 listen for changes. If creating your own widget extend DynamicLayout to manages
 the actual wrapping and drawing of your text.",,,,,,,
"<android.speech.tts.TextToSpeech: int speak(String,int,HashMap)>","This method was deprecated
      in API level 21. As of API level 21 replaced by speak(java.lang.CharSequence int android.os.Bundle java.lang.String) . Speaks the string using the specified queuing strategy and speech parameters.
 This method is asynchronous i.e. the method just adds the request to the queue of TTS
 requests and then returns. The synthesis might not have finished (or even started!) at the
 time when this method returns. In order to reliably detect errors during synthesis
 we recommend setting an utterance progress listener (see setOnUtteranceProgressListener(UtteranceProgressListener) ) and using the Engine#KEY_PARAM_UTTERANCE_ID parameter.","text String : The string of text to be spoken. No longer than getMaxSpeechInputLength() characters. |||
queueMode int : The queuing strategy to use QUEUE_ADD or QUEUE_FLUSH . |||
params HashMap : Parameters for the request. Can be null.
Supported parameter names: Engine#KEY_PARAM_STREAM  Engine#KEY_PARAM_UTTERANCE_ID  Engine#KEY_PARAM_VOLUME  Engine#KEY_PARAM_PAN .
Engine specific parameters may be passed in but the parameter keys
must be prefixed by the name of the engine they are intended for. For example
the keys ""com.svox.pico_foo"" and ""com.svox.pico:bar"" will be passed to the
engine named ""com.svox.pico"" if it is being used. |||",int ERROR or SUCCESS of queuing the speak operation. |||,4,"Synthesizes speech from text for immediate playback or to create a sound file.
  A TextToSpeech instance can only be used to synthesize text once it has completed its
 initialization. Implement the  TextToSpeech.OnInitListener  to be
 notified of the completion of the initialization. 
 When you are done using the TextToSpeech instance call the  shutdown()  method
 to release the native resources used by the TextToSpeech engine.",,,,,,,,
<android.content.Intent: ComponentName resolveActivity(PackageManager)>,"Return the Activity component that should be used to handle this intent.
 The appropriate component is determined based on the information in the
 intent evaluated as follows: If getComponent() returns an explicit class that is returned
 without any further consideration. The activity must handle the Intent#CATEGORY_DEFAULT Intent
 category to be considered. If getAction() is non-NULL the activity must handle this
 action. If resolveType(ContentResolver) returns non-NULL the activity must handle
 this type. If addCategory(String) has added any categories the activity must
 handle ALL of the categories specified. If getPackage() is non-NULL only activity components in
 that application package will be considered. If there are no activities that satisfy all of these conditions a
 null string is returned. If multiple activities are found to satisfy the intent the one with
 the highest priority will be used.  If there are multiple activities
 with the same priority the system will either pick the best activity
 based on user preference or resolve to a system class that will allow
 the user to pick an activity and forward from there. This method is implemented simply by calling PackageManager#resolveActivity with the ""defaultOnly"" parameter
 true. This API is called for you as part of starting an activity from an
 intent.  You do not normally need to call it yourself.","pm PackageManager : The package manager with which to resolve the Intent.
This value must never be null . |||","ComponentName Name of the component implementing an activity that can
         display the intent. |||",1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",,,,,,,
<android.speech.RecognitionService: void onDestroy()>,"Called by the system to notify a Service that it is no longer used and is being removed.  The
 service should clean up any resources it holds (threads registered
 receivers etc) at this point.  Upon return there will be no more calls
 in to this Service object and it is effectively dead.  Do not call this method directly.",,void,8,"This class provides a base class for recognition service implementations. This class should be
 extended only in case you wish to implement a new speech recognizer. Please note that the
 implementation of this service is stateless.",,,,,,,,
<android.widget.AutoCompleteTextView: void dismissDropDown()>,Closes the drop down if present on screen.,,void,1,"An editable text view that shows completion suggestions automatically
 while the user is typing. The list of suggestions is displayed in a drop
 down menu from which the user can choose an item to replace the content
 of the edit box with. The drop down can be dismissed at any time by pressing the back key or
 if no item is selected in the drop down by pressing the enter/dpad center
 key. The list of suggestions is obtained from a data adapter and appears
 only after a given number of characters defined by
  the threshold . The following code snippet shows how to create a text view which suggests
 various countries names while the user is typing: 
 public class CountriesActivity extends Activity {
     protected void onCreate(Bundle icicle) {
         super.onCreate(icicle);
         setContentView(R.layout.countries);

         ArrayAdapter<String> adapter = new ArrayAdapter<String>(this
                 android.R.layout.simple_dropdown_item_1line COUNTRIES);
         AutoCompleteTextView textView = (AutoCompleteTextView)
                 findViewById(R.id.countries_list);
         textView.setAdapter(adapter);
     }

     private static final String[] COUNTRIES = new String[] {
         ""Belgium"" ""France"" ""Italy"" ""Germany"" ""Spain""
     };
 }
  See the  Text Fields 
 guide.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.webkit.WebSettings: String getDefaultUserAgent(Context)>,"Returns the default User-Agent used by a WebView.
 An instance of WebView could use a different User-Agent if a call
 is made to WebSettings#setUserAgentString(String) .",context Context : a Context object used to access application assets |||,String |||,17,"Manages settings state for a WebView. When a WebView is first created it
 obtains a set of default settings. These default settings will be returned
 from any getter call. A  WebSettings  object obtained from
  WebView#getSettings()  is tied to the life of the WebView. If a WebView has
 been destroyed any method call on  WebSettings  will throw an
  IllegalStateException .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",,,,,,,
"<android.text.SpannableStringBuilder: CharSequence subSequence(int,int)>","Return a new CharSequence containing a copy of the specified
 range of this buffer including the overlapping spans.","start int : the start index inclusive |||
end int : the end index exclusive |||",CharSequence the specified subsequence |||,1,"This is the class for text whose content is immutable but to which
 markup objects can be attached and detached.
 For mutable text see  SpannableStringBuilder .","Provides classes used to render or track text and text spans on the screen. You can use these classes to design your own widgets that manage text
 to handle arbitrary text spans for changes or to handle drawing yourself
 for an existing widget. The Span… interfaces and classes are used to create or manage spans of
 text in a View item. You can use these to style the text or background or to
 listen for changes. If creating your own widget extend DynamicLayout to manages
 the actual wrapping and drawing of your text.",,,,,,,
"<android.text.SpannableStringBuilder: SpannableStringBuilder insert(int,CharSequence,int,int)>",Convenience for replace(where where text start end),"where int |||
tb CharSequence |||
start int |||
end int |||",SpannableStringBuilder |||,1,"This is the class for text whose content is immutable but to which
 markup objects can be attached and detached.
 For mutable text see  SpannableStringBuilder .","Provides classes used to render or track text and text spans on the screen. You can use these classes to design your own widgets that manage text
 to handle arbitrary text spans for changes or to handle drawing yourself
 for an existing widget. The Span… interfaces and classes are used to create or manage spans of
 text in a View item. You can use these to style the text or background or to
 listen for changes. If creating your own widget extend DynamicLayout to manages
 the actual wrapping and drawing of your text.",,,,,,,
<android.widget.ViewAnimator: void removeViewInLayout(View)>,"Removes a view during layout. This is useful if in your onLayout() method
 you need to remove more views. Note: do not invoke this method from View.draw(android.graphics.Canvas)  View.onDraw(android.graphics.Canvas)  dispatchDraw(android.graphics.Canvas) or any related method.",view View : the view to remove from the group |||,void,1,"Base class for a  FrameLayout  container that will perform animations
 when switching between its views.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,,,,,
<android.media.CameraProfile: int getJpegEncodingQualityParameter(int)>,"Returns a pre-defined still image capture (jpeg) quality level
 used for the given quality level in the Camera application for
 the first back-facing camera on the device. If the device has no
 back-facing camera this returns 0.",quality int : The target quality level |||,int |||,8,"The CameraProfile class is used to retrieve the pre-defined still image
 capture (jpeg) quality levels (0-100) used for low medium and high
 quality settings in the Camera application.","The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",,,,,,,
<android.bluetooth.BluetoothHealth: List getConnectedDevices()>,"Get connected devices for the health profile. Return the set of devices which are in state BluetoothProfile.STATE_CONNECTED Requires Manifest.permission.BLUETOOTH permission.

 This is not specific to any application configuration but represents the connection
 state of the local Bluetooth adapter for this profile. This can be used
 by applications like status bar which would just like to know the state of the
 local adapter.",,List < BluetoothDevice > List of devices. The list will be empty on error. |||,14,"Public API for Bluetooth Health Profile.

  BluetoothHealth is a proxy object for controlling the Bluetooth
 Service via IPC.

   How to connect to a health device which is acting in the source role.
   Use  BluetoothAdapter#getProfileProxy  to get
 the BluetoothHealth proxy object.   Create an  BluetoothHealth  callback and call
  registerSinkAppConfiguration(String int BluetoothHealthCallback)  to register an application
 configuration   Pair with the remote device. This currently needs to be done manually
 from Bluetooth Settings   Connect to a health device using  connectChannelToSource(BluetoothDevice BluetoothHealthAppConfiguration) . Some
 devices will connect the channel automatically. The  BluetoothHealth 
 callback will inform the application of channel state change.   Use the file descriptor provided with a connected channel to read and
 write data to the health channel.   The received data needs to be interpreted using a health manager which
 implements the IEEE 11073-xxxxx specifications.
   When done close the health channel by calling  disconnectChannel(BluetoothDevice BluetoothHealthAppConfiguration int) 
 and unregister the application configuration calling
  unregisterAppConfiguration(BluetoothHealthAppConfiguration)","Provides classes that manage Bluetooth functionality such as scanning for
 devices connecting with devices and managing data transfer between devices.
 The Bluetooth API supports both ""Classic Bluetooth"" and Bluetooth Low Energy. For more information about Classic Bluetooth see the
  Bluetooth  guide.
 For more information about Bluetooth Low Energy see the
  
 Bluetooth Low Energy  (BLE) guide. The Bluetooth APIs let applications: Scan for other Bluetooth devices (including BLE devices). Query the local Bluetooth adapter for paired Bluetooth devices. Establish RFCOMM channels/sockets. Connect to specified sockets on other devices. Transfer data to and from other devices. Communicate with BLE devices such as proximity sensors heart rate
     monitors fitness devices and so on. Act as a GATT client or a GATT server (BLE). 
 To perform Bluetooth communication using these APIs an application must
 declare the  BLUETOOTH  permission. Some
 additional functionality such as requesting device discovery
 also requires the  BLUETOOTH_ADMIN 
 permission.
  Note: 
 Not all Android-powered devices provide Bluetooth functionality.",,,,,,,
"<android.app.Instrumentation: void callActivityOnSaveInstanceState(Activity,Bundle)>",Perform calling of an activity's Activity#onSaveInstanceState method.  The default implementation simply calls through to that method.,"activity Activity : The activity being saved.
This value must never be null . |||
outState Bundle : The bundle to pass to the call.
This value must never be null . |||",void,1,"Base class for implementing application instrumentation code.  When running
 with instrumentation turned on this class will be instantiated for you
 before any of the application code allowing you to monitor all of the
 interaction the system has with the application.  An Instrumentation
 implementation is described to the system through an AndroidManifest.xml's
 <instrumentation> tag.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",,,,,,,
<android.telephony.PhoneNumberUtils: void formatJapaneseNumber(Editable)>,"This method was deprecated
      in API level 21. Use link #formatNumber(String phoneNumber String defaultCountryIso) instead Formats a phone number in-place using the Japanese formatting rules.
 Numbers will be formatted as: 03-xxxx-xxxx
 090-xxxx-xxxx
 0120-xxx-xxx
 +81-3-xxxx-xxxx
 +81-90-xxxx-xxxx","text Editable : the number to be formatted will be modified with
the formatting |||",void,3,Various utilities for dealing with phone number strings.,,,,,,,,
<android.preference.Preference: SharedPreferences getSharedPreferences()>,"Returns the SharedPreferences where this Preference can read its
 value(s). Usually it's easier to use one of the helper read methods: getPersistedBoolean(boolean)  getPersistedFloat(float)  getPersistedInt(int)  getPersistedLong(long)  getPersistedString(java.lang.String) . To save values see getEditor() . In some cases writes to the getEditor() will not be committed
 right away and hence not show up in the returned SharedPreferences this is intended behavior to improve
 performance.",,"SharedPreferences the SharedPreferences where this Preference reads its value(s). If
         this preference isn't attached to a Preference hierarchy or if
         a PreferenceDataStore has been set this method returns null . |||",1,"Represents the basic Preference UI building
 block displayed by a  PreferenceActivity  in the form of a
  ListView . This class provides the  View  to be displayed in
 the activity and associates with a  SharedPreferences  to
 store/retrieve the preference data.
  
 When specifying a preference hierarchy in XML each element can point to a
 subclass of  Preference  similar to the view hierarchy and layouts.
  
 This class contains a  key  that will be used as the key into the
  SharedPreferences . It is up to the subclass to decide how to store
 the value.",,,,,,,,
<android.view.accessibility.AccessibilityManager: void sendAccessibilityEvent(AccessibilityEvent)>,Sends an AccessibilityEvent .,event AccessibilityEvent : The event to send. |||,void,4,"System level service that serves as an event dispatch for  AccessibilityEvent s
 and provides facilities for querying the accessibility state of the system.
 Accessibility events are generated when something notable happens in the user interface
 for example an  Activity  starts the focus or selection of a
  View  changes etc. Parties interested in handling accessibility
 events implement and register an accessibility service which extends
  AccessibilityService .",,,,,,,,
<android.webkit.WebView: void onResume()>,Resumes a WebView after a previous call to onPause() .,,void,11,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",,,,,,,
