,Description,Parameters,Return,ApiLevel,ClassDescription,PackageDescription,sensitive data?,shared resource?,sensitive shared resource?,produces sensitive data from shared resource?,writes sensitive data to shared resource?,Source?,Sink?,Needs Clarification
<android.app.MediaRouteButton: void onAttachedToWindow()>,"This is called when the view is attached to a window.  At this point it
 has a Surface and will start drawing.  Note that this function is
 guaranteed to be called before onDraw(android.graphics.Canvas) however it may be called any time before the first onDraw -- including
 before or after onMeasure(int int) . If you override this method you must call through to the
 superclass implementation.",,void,16,,"Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
<android.net.ConnectivityManager: NetworkInfo getAllNetworkInfo()>,"This method was deprecated
      in API level 23. This method does not support multiple connected networks
             of the same type. Use getAllNetworks() and getNetworkInfo(android.net.Network) instead. Returns connection status information about all network
 types supported by the device. Requires Manifest.permission.ACCESS_NETWORK_STATE",,"NetworkInfo[] an array of NetworkInfo objects.  Check each NetworkInfo#getType for which type each applies.

 This value will never be null . |||",1,"Class that answers queries about the state of network connectivity. It also
 notifies applications when network connectivity changes.
  
 The primary responsibilities of this class are to:
  Monitor network connections (Wi-Fi GPRS UMTS etc.) Send broadcast intents when network connectivity changes Attempt to ""fail over"" to another network when connectivity to a network
 is lost Provide an API that allows applications to query the coarse-grained or fine-grained
 state of the available networks Provide an API that allows applications to request and select networks for their data
 traffic",,network info,network ,1,yes,no,SOURCE,no,Yes. What did we decide with regards to info ABOUT the network  
"<android.os.Bundle: void putFloat(String,float)>","Inserts a float value into the mapping of this Bundle replacing
 any existing value for the given key.","key String : a String or null
This value may be null . |||
value float : a float |||",void,1,A mapping from String keys to various  Parcelable  values.,,uncategorized,no,0,no,no,no,no,
"<android.accounts.AccountManager: AccountManagerFuture confirmCredentials(Account,Bundle,Activity,AccountManagerCallback,Handler)>"," Confirms that the user knows the password for an account to make extra
 sure they are the owner of the account.  The user-entered password can
 be supplied directly otherwise the authenticator for this account type
 prompts the user with the appropriate interface.  This method is
 intended for applications which want extra assurance; for example the
 phone lock screen uses this to let the user unlock the phone with an
 account password if they forget the lock pattern. If the user-entered password matches a saved password for this
 account the request is considered valid; otherwise the authenticator
 verifies the password (usually by contacting the server). This method may be called from any thread but the returned AccountManagerFuture must not be used on the main thread. NOTE: If targeting your app to work on API level 22 and before
 MANAGE_ACCOUNTS permission is needed for those platforms. See docs
 for this function in API level 22. Requires android.Manifest.permission.MANAGE_ACCOUNTS","account Account : The account to confirm password knowledge for |||
options Bundle : Authenticator-specific options for the request;
if the KEY_PASSWORD string field is present the
authenticator may use it directly rather than prompting the user;
may be null or empty |||
activity Activity : The Activity context to use for launching a new
authenticator-defined sub-Activity to prompt the user to enter a
password; used only to call startActivity(); if null the prompt
will not be launched directly but the necessary Intent will be returned to the caller instead |||
callback AccountManagerCallback : Callback to invoke when the request completes
null for no callback |||
handler Handler : Handler identifying the callback thread
null for the main thread |||","AccountManagerFuture < Bundle > An AccountManagerFuture which resolves to a Bundle
     with these fields if activity or password was supplied and
     the account was successfully verified: KEY_ACCOUNT_NAME - the name of the account verified KEY_ACCOUNT_TYPE - the type of the account KEY_BOOLEAN_RESULT - true to indicate success If no activity or password was specified the returned Bundle contains KEY_INTENT with the Intent needed to launch the
 password prompt. Also the returning Bundle may contain KEY_LAST_AUTHENTICATED_TIME indicating the last time the
 credential was validated/created.

 If an error occurred AccountManagerFuture#getResult() throws: AuthenticatorException if the authenticator failed to respond OperationCanceledException if the operation was canceled for
      any reason including the user canceling the password prompt IOException if the authenticator experienced an I/O problem
      verifying the password usually because of network trouble |||",5,"This class provides access to a centralized registry of the user's
 online accounts.  The user enters credentials (username and password) once
 per account granting applications access to online resources with
 ""one-click"" approval.

  Different online services have different ways of handling accounts and
 authentication so the account manager uses pluggable  authenticator 
 modules for different  account types .  Authenticators (which may be
 written by third parties) handle the actual details of validating account
 credentials and storing account information.  For example Google Facebook
 and Microsoft Exchange each have their own authenticator.

  Many servers support some notion of an  authentication token 
 which can be used to authenticate a request to the server without sending
 the user's actual password.  (Auth tokens are normally created with a
 separate request which does include the user's credentials.)  AccountManager
 can generate auth tokens for applications so the application doesn't need to
 handle passwords directly.  Auth tokens are normally reusable and cached by
 AccountManager but must be refreshed periodically.  It's the responsibility
 of applications to  invalidate  auth tokens when they stop working so
 the AccountManager knows it needs to regenerate them.

  Applications accessing a server normally go through these steps:

  Get an instance of AccountManager using  get(android.content.Context) .

  List the available accounts using  getAccountsByType(String)  or
  getAccountsByTypeAndFeatures(String String[] AccountManagerCallback  Handler) .  Normally applications will only
 be interested in accounts with one particular  type  which
 identifies the authenticator.  Account  features  are used to
 identify particular account subtypes and capabilities.  Both the account
 type and features are authenticator-specific strings and must be known by
 the application in coordination with its preferred authenticators.

  Select one or more of the available accounts possibly by asking the
 user for their preference.  If no suitable accounts are available
  addAccount(String String String[] Bundle Activity AccountManagerCallback  Handler)  may be called to prompt the user to create an
 account of the appropriate type.

  Important:  If the application is using a previously remembered
 account selection it must make sure the account is still in the list
 of accounts returned by  getAccountsByType(String) .  Requesting an auth token
 for an account no longer on the device results in an undefined failure.

  Request an auth token for the selected account(s) using one of the
  getAuthToken(Account String Bundle Activity AccountManagerCallback  Handler)  methods or related helpers.  Refer to the description
 of each method for exact usage and error handling details.

  Make the request using the auth token.  The form of the auth token
 the format of the request and the protocol used are all specific to the
 service you are accessing.  The application may use whatever network and
 protocol libraries are useful.

  Important:  If the request fails with an authentication error
 it could be that a cached auth token is stale and no longer honored by
 the server.  The application must call  invalidateAuthToken(String String)  to remove
 the token from the cache otherwise requests will continue failing!  After
 invalidating the auth token immediately go back to the ""Request an auth
 token"" step above.  If the process fails the second time then it can be
 treated as a ""genuine"" authentication failure and the user notified or other
 appropriate actions taken.
  Some AccountManager methods may need to interact with the user to
 prompt for credentials present options or ask the user to add an account.
 The caller may choose whether to allow AccountManager to directly launch the
 necessary user interface and wait for the user or to return an Intent which
 the caller may use to launch the interface or (in some cases) to install a
 notification which the user can select at any time to launch the interface.
 To have AccountManager launch the interface directly the caller must supply
 the current foreground  Activity  context.

  Many AccountManager methods take  AccountManagerCallback  and
  Handler  as parameters.  These methods return immediately and
 run asynchronously. If a callback is provided then
  AccountManagerCallback#run  will be invoked on the Handler's
 thread when the request completes successfully or not.
 The result is retrieved by calling  AccountManagerFuture#getResult() 
 on the  AccountManagerFuture  returned by the method (and also passed
 to the callback).  This method waits for the operation to complete (if
 necessary) and either returns the result or throws an exception if an error
 occurred during the operation.  To make the request synchronously call
  AccountManagerFuture#getResult()  immediately on receiving the
 future from the method; no callback need be supplied.

  Requests which may block including
  AccountManagerFuture#getResult()  must never be called on
 the application's main event thread.  These operations throw
  IllegalStateException  if they are used on the main thread.",,no,no,0,no,no,no,no,"Seems maybe sensitive, but Im not sure"
"<android.app.Activity: void startActivityForResult(Intent,int)>",Same as calling startActivityForResult(android.content.Intent int android.os.Bundle) with no options.,"intent Intent : The intent to start. |||
requestCode int : If >= 0 this code will be returned in
onActivityResult() when the activity exits. |||",void,1,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
<android.service.dreams.DreamService: void onDestroy()>,"Called by the system to notify a Service that it is no longer used and is being removed.  The
 service should clean up any resources it holds (threads registered
 receivers etc) at this point.  Upon return there will be no more calls
 in to this Service object and it is effectively dead.  Do not call this method directly.",,void,17,"Extend this class to implement a custom dream (available to the user as a ""Daydream"").

  Dreams are interactive screensavers launched when a charging device is idle or docked in a
 desk dock. Dreams provide another modality for apps to express themselves tailored for
 an exhibition/lean-back experience. The  DreamService  lifecycle is as follows: onAttachedToWindow() Use this for initial setup such as calling  setContentView() . onDreamingStarted() Your dream has started so you should  begin animations or other behaviors here. onDreamingStopped() Use this to stop the things you started in  onDreamingStarted() . onDetachedFromWindow() Use this to dismantle resources (for example detach from handlers
        and listeners). In addition onCreate and onDestroy (from the Service interface) will also be called but
 initialization and teardown should be done by overriding the hooks above. To be available to the system your  DreamService  should be declared in the
 manifest as follows: 
 <service
     android:name="".MyDream""
     android:exported=""true""
     android:icon=""@drawable/my_icon""
     android:label=""@string/my_dream_label"" >

     <intent-filter>
         <action android:name=""android.service.dreams.DreamService"" />
         <category android:name=""android.intent.category.DEFAULT"" />
     </intent-filter>

     <!-- Point to additional information for this dream (optional) -->
     <meta-data
         android:name=""android.service.dream""
         android:resource=""@xml/my_dream"" />
 </service>
  If specified with the  <meta-data>  element
 additional information for the dream is defined using the
  <dream>  element in a separate XML file.
 Currently the only addtional
 information you can provide is for a settings activity that allows the user to configure
 the dream behavior. For example: res/xml/my_dream.xml 
 <dream xmlns:android=""http://schemas.android.com/apk/res/android""
     android:settingsActivity=""com.example.app/.MyDreamSettingsActivity"" />
  This makes a Settings button available alongside your dream's listing in the
 system settings which when pressed opens the specified activity. To specify your dream layout call  setContentView(View)  typically during the
  onAttachedToWindow()  callback. For example: 
 public class MyDream extends DreamService {

     @Override
     public void onAttachedToWindow() {
         super.onAttachedToWindow();

         // Exit dream upon user touch
         setInteractive(false);
         // Hide system UI
         setFullscreen(true);
         // Set the dream layout
         setContentView(R.layout.dream);
     }
 }
  When targeting api level 21 and above you must declare the service in your manifest file
 with the  Manifest.permission.BIND_DREAM_SERVICE  permission. For example: 
 <service
     android:name="".MyDream""
     android:exported=""true""
     android:icon=""@drawable/my_icon""
     android:label=""@string/my_dream_label""
     android:permission=""android.permission.BIND_DREAM_SERVICE"">
   <intent-filter>
     <action android:name=”android.service.dreams.DreamService” />
     <category android:name=”android.intent.category.DEFAULT” />
   </intent-filter>
 </service>",,no,no,0,no,no,no,no,
<android.widget.RatingBar: void setMax(int)>,Set the upper range of the progress bar max .,max int : the upper range of this progress bar |||,void,1,"A RatingBar is an extension of SeekBar and ProgressBar that shows a rating in
 stars. The user can touch/drag or use arrow keys to set the rating when using
 the default size RatingBar. The smaller RatingBar style (
  R.attr.ratingBarStyleSmall ) and the larger indicator-only
 style ( R.attr.ratingBarStyleIndicator ) do not support user
 interaction and should only be used as indicators.
  
 When using a RatingBar that supports user interaction placing widgets to the
 left or right of the RatingBar is discouraged.
  
 The number of stars set (via  setNumStars(int)  or in an XML layout)
 will be shown when the layout width is set to wrap content (if another layout
 width is set the results may be unpredictable).
  
 The secondary progress should not be modified by the client as it is used
 internally as the background for a fractionally filled star.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,no,0,no,no,no,no,
<android.view.inputmethod.InputMethodInfo: CharSequence loadLabel(PackageManager)>,Load the user-displayed label for this input method.,"pm PackageManager : Supply a PackageManager used to load the input method's
resources. |||",CharSequence |||,3,"This class is used to specify meta information of an input method.

  It should be defined in an XML resource file with an  <input-method>  element.
 For more information see the guide to
  
 Creating an Input Method .",,no,no,0,no,no,no,no,
<android.content.ClipboardManager: ClipData getPrimaryClip()>,Returns the current primary clip on the clipboard. If the application is not the default IME or does not have input focus this return null .,,ClipData |||,11,"Interface to the clipboard service for placing and retrieving text in
 the global clipboard.

  
 The ClipboardManager API itself is very simple: it consists of methods
 to atomically get and set the current primary clipboard data.  That data
 is expressed as a  ClipData  object which defines the protocol
 for data exchange between applications.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",yes?,clipboard,1,yes,no,SOURCE,no,Is the clipboard sensitive?
"<android.test.TouchUtils: int dragViewToY(InstrumentationTestCase,View,int,int)>",Simulate touching a view and dragging it to a specified location. Only moves vertically.,"test InstrumentationTestCase : The test case that is being run |||
v View : The view that should be dragged |||
gravity int : Which part of the view to use for the initial down event. A combination of
(TOP CENTER_VERTICAL BOTTOM) and (LEFT CENTER_HORIZONTAL RIGHT) |||
toY int : Final location of the view after dragging |||",int distance in pixels covered by the drag |||,3,"Reusable methods for generating touch events. These methods can be used with
 InstrumentationTestCase or ActivityInstrumentationTestCase2 to simulate user interaction with
 the application through a touch screen.",,no,UI,0,no,no,no,no,
<android.bluetooth.BluetoothAdapter: int getScanMode()>,"Get the current Bluetooth scan mode of the local Bluetooth adapter. The Bluetooth scan mode determines if the local adapter is
 connectable and/or discoverable from remote Bluetooth devices. Possible values are: SCAN_MODE_NONE  SCAN_MODE_CONNECTABLE  SCAN_MODE_CONNECTABLE_DISCOVERABLE . If Bluetooth state is not STATE_ON this API
 will return SCAN_MODE_NONE . After turning on Bluetooth
 wait for ACTION_STATE_CHANGED with STATE_ON to get the updated value. Requires Manifest.permission.BLUETOOTH",,"int scan mode
 
 Value is SCAN_MODE_NONE  SCAN_MODE_CONNECTABLE or SCAN_MODE_CONNECTABLE_DISCOVERABLE |||",5,"Represents the local device Bluetooth adapter. The  BluetoothAdapter 
 lets you perform fundamental Bluetooth tasks such as initiate
 device discovery query a list of bonded (paired) devices
 instantiate a  BluetoothDevice  using a known MAC address and create
 a  BluetoothServerSocket  to listen for connection requests from other
 devices and start a scan for Bluetooth LE devices.

  To get a  BluetoothAdapter  representing the local Bluetooth
 adapter call the  BluetoothManager#getAdapter  function on  BluetoothManager .
 On JELLY_BEAN_MR1 and below you will need to use the static  getDefaultAdapter() 
 method instead.
  
 Fundamentally this is your starting point for all
 Bluetooth actions. Once you have the local adapter you can get a set of
  BluetoothDevice  objects representing all paired devices with
  getBondedDevices() ; start device discovery with
  startDiscovery() ; or create a  BluetoothServerSocket  to
 listen for incoming RFComm connection requests with  listenUsingRfcommWithServiceRecord(java.lang.String java.util.UUID) ; listen for incoming L2CAP Connection-oriented
 Channels (CoC) connection requests with  listenUsingL2capChannel() ; or start a scan for
 Bluetooth LE devices with  startLeScan(android.bluetooth.BluetoothAdapter.LeScanCallback) .
  This class is thread safe. Note: 
 Most methods require the  Manifest.permission.BLUETOOTH 
 permission and some also require the
  Manifest.permission.BLUETOOTH_ADMIN  permission.","Provides classes that manage Bluetooth functionality such as scanning for
 devices connecting with devices and managing data transfer between devices.
 The Bluetooth API supports both ""Classic Bluetooth"" and Bluetooth Low Energy. For more information about Classic Bluetooth see the
  Bluetooth  guide.
 For more information about Bluetooth Low Energy see the
  
 Bluetooth Low Energy  (BLE) guide. The Bluetooth APIs let applications: Scan for other Bluetooth devices (including BLE devices). Query the local Bluetooth adapter for paired Bluetooth devices. Establish RFCOMM channels/sockets. Connect to specified sockets on other devices. Transfer data to and from other devices. Communicate with BLE devices such as proximity sensors heart rate
     monitors fitness devices and so on. Act as a GATT client or a GATT server (BLE). 
 To perform Bluetooth communication using these APIs an application must
 declare the  BLUETOOTH  permission. Some
 additional functionality such as requesting device discovery
 also requires the  BLUETOOTH_ADMIN 
 permission.
  Note: 
 Not all Android-powered devices provide Bluetooth functionality.",bluetoothmetadat?,bluetooth,1,yes?,no,SOURCE,no,Is metadata like this sensitive
"<android.test.ProviderTestCase: ContentResolver newResolverWithContentProviderFromSql(Context,Class,String,String,int,String)>",,"targetContext Context |||
providerClass Class |||
authority String |||
databaseName String |||
databaseVersion int |||
sql String |||",ContentResolver |||,1,"If you would like to test a single content provider with an
  InstrumentationTestCase  this provides some of the boiler plate in  setUp()  and
  tearDown() .",,uncategorized,database,1,yes?,no,no,no,"Seems like a source, but its uncategorized sensitive data. Is any data from any database sensitive?"
<android.content.Intent: float getFloatArrayExtra(String)>,Retrieve extended data from the intent.,name String : The name of the desired item. |||,"float[] the value of an item previously added with putExtra()
 or null if no float array value was found. |||",1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,Are intents inherently sensitive? Could feasibly have sensitive info in it I think
<android.os.UserManager: int getUserCount()>,Return the number of users currently created on the device. This API is not for use by third-party apps. It requires the MANAGE_USERS permission.,,int |||,17,"Manages users and user details on a multi-user system. There are two major categories of
 users: fully customizable users with their own login and managed profiles that share a workspace
 with a related user.
  
 Users are different from accounts which are managed by
  AccountManager . Each user can have their own set of accounts.
  
 See  DevicePolicyManager#ACTION_PROVISION_MANAGED_PROFILE  for more on managed profiles.",,account info,sim card?,1,yes,no,SOURCE,no,Not sure about account category.
"<android.text.SpannableStringBuilder: void setSpan(Object,int,int,int)>","Mark the specified range of text with the specified object.
 The flags determine how the span will behave when text is
 inserted at the start or end of the span's range.","what Object |||
start int |||
end int |||
flags int |||",void,1,"This is the class for text whose content is immutable but to which
 markup objects can be attached and detached.
 For mutable text see  SpannableStringBuilder .","Provides classes used to render or track text and text spans on the screen. You can use these classes to design your own widgets that manage text
 to handle arbitrary text spans for changes or to handle drawing yourself
 for an existing widget. The Span… interfaces and classes are used to create or manage spans of
 text in a View item. You can use these to style the text or background or to
 listen for changes. If creating your own widget extend DynamicLayout to manages
 the actual wrapping and drawing of your text.",no,UI,0,no,no,no,no,
<android.view.accessibility.AccessibilityRecord: AccessibilityNodeInfo getSource()>,"Gets the AccessibilityNodeInfo of the event source. Note: It is a client responsibility to recycle the received info
   by calling AccessibilityNodeInfo#recycle() to avoid creating of multiple instances.",,AccessibilityNodeInfo The info of the source. |||,14,"Represents a record in an  AccessibilityEvent  and contains information
 about state change of its source  View . When a view fires
 an accessibility event it requests from its parent to dispatch the
 constructed event. The parent may optionally append a record for itself
 for providing more context to
  AccessibilityService s. Hence
 accessibility services can facilitate additional accessibility records
 to enhance feedback.
  
 Once the accessibility event containing a record is dispatched the record is
 made immutable and calling a state mutation method generates an error.
  Note:  Not all properties are applicable to all accessibility
 event types. For detailed information please refer to  AccessibilityEvent .","The classes in this package are used to represent screen content and changes to it
   as well as APIs for querying the global accessibility state of the system.
  AccessibilityEvent s are sent by the system when
   something notable happens in the user interface. For example when a
    Button  is clicked a  View  is focused etc.
  AccessibilityRecord  contains information
   about state change of its source  View . When a view fires
   an accessibility event it requests from its parent to dispatch the
   constructed event. The parent may optionally append a record for itself for
   providing more context to  AccessibilityService s.
   Hence accessibility services can facilitate additional accessibility records
   to enhance feedback.
  AccessibilityNodeInfo  represents a node of the
   window content as well as actions that can be requested from its source. From the point
   of view of an  AccessibilityService  a window content is
   presented as tree of accessibility node info which may or may not map one-to-one
   to the view hierarchy. In other words a custom view is free to report itself as
   a tree of accessibility node info.
  AccessibilityManager  is a system level service that
   serves as an event dispatch for   AccessibilityEvent s
   and provides facilities for querying the accessibility state of the system. Accessibility
   events are generated when something notable happens in the user interface for example an
    Activity  starts the focus or selection of a  View 
   changes etc. Parties interested in handling accessibility events implement and register an
   accessibility service which extends  AccessibilityService .",no?,UI,1,no,no,no,no,Not sure about this one. Is accessability info sensitive?
<android.os.Bundle: byte getByte(String)>,"Returns the value associated with the given key or (byte) 0 if
 no mapping of the desired type exists for the given key.",key String : a String |||,byte a byte value |||,1,A mapping from String keys to various  Parcelable  values.,,no,no,0,no,no,no,no,
<android.app.ActivityManager: List getRunningTasks(int)>,"This method was deprecated
      in API level 21. As of Build.VERSION_CODES.LOLLIPOP this method
 is no longer available to third party
 applications: the introduction of document-centric recents means
 it can leak person information to the caller.  For backwards compatibility
 it will still return a small subset of its data: at least the caller's
 own tasks and possibly some other tasks
 such as home that are known to not be sensitive. Return a list of the tasks that are currently running with
 the most recent being first and older ones after in order.  Note that
 ""running"" does not mean any of the task's code is currently loaded or
 activity -- the task may have been frozen by the system so that it
 can be restarted in its previous state when next brought to the
 foreground. Note: this method is only intended for debugging and presenting
 task management user interfaces .  This should never be used for
 core logic in an application such as deciding between different
 behaviors based on the information found here.  Such uses are not supported and will likely break in the future.  For
 example if multiple applications can be actively running at the
 same time assumptions made about the meaning of the data here for
 purposes of control flow will be incorrect.","maxNum int : The maximum number of entries to return in the list.  The
actual number returned may be smaller depending on how many tasks the
user has started. |||","List < ActivityManager.RunningTaskInfo > Returns a list of RunningTaskInfo records describing each of
 the running tasks. |||",1,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,"The docs (with one grammar error) clearly say this method leaks personal info. However, I don't see how it fits into our scheme"
"<android.app.Activity: void startIntentSender(IntentSender,Intent,int,int,int)>",Same as calling startIntentSender(android.content.IntentSender android.content.Intent int int int android.os.Bundle) with no options.,"intent IntentSender : The IntentSender to launch. |||
fillInIntent Intent : If non-null this will be provided as the
intent parameter to IntentSender#sendIntent .
This value may be null . |||
flagsMask int : Intent flags in the original IntentSender that you
would like to change. |||
flagsValues int : Desired values for any bits set in flagsMask |||
extraFlags int : Always set to 0. |||",void,5,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
<android.app.WallpaperManager: Drawable getDrawable()>,"Retrieve the current system wallpaper; if
 no wallpaper is set the system built-in static wallpaper is returned.
 This is returned as an
 abstract Drawable that you can install in a View to display whatever
 wallpaper the user has currently set. This method can return null if there is no system wallpaper available if
 wallpapers are not supported in the current user or if the calling app is not
 permitted to access the system wallpaper.",,"Drawable Returns a Drawable object that will draw the system wallpaper
     or null if no system wallpaper exists or if the calling application
     is not able to access the wallpaper. |||",5,"Provides access to the system wallpaper. With WallpaperManager you can
 get the current wallpaper get the desired dimensions for the wallpaper set
 the wallpaper and more.

   An app can check whether wallpapers are supported for the current user by calling
  isWallpaperSupported()  and whether setting of wallpapers is allowed by calling
  isSetWallpaperAllowed() .","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,UI,0,no,no,no,no,
"<android.widget.CursorTreeAdapter: void setChildrenCursor(int,Cursor)>","Sets the children Cursor for a particular group. If there is an existing cursor
 it will be closed. This is useful when asynchronously querying to prevent blocking the UI.","groupPosition int : The group whose children are being set via this Cursor. |||
childrenCursor Cursor : The Cursor that contains the children of the group. |||",void,1,"An adapter that exposes data from a series of  Cursor s to an
  ExpandableListView  widget. The top-level  Cursor  (that is
 given in the constructor) exposes the groups while subsequent  Cursor s
 returned from  getChildrenCursor(android.database.Cursor)  expose children within a
 particular group. The Cursors must include a column named ""_id"" or this class
 will not work.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,UI,0,no,no,no,no,
"<android.content.ContentResolver: Bundle call(Uri,String,String,Bundle)>","Call a provider-defined method.  This can be used to implement
 read or write interfaces which are cheaper than using a Cursor and/or
 do not fit into the traditional table model.","uri Uri : This value must never be null . |||
method String : provider-defined method name to call.  Opaque to
framework but must be non-null.
This value must never be null . |||
arg String : provider-defined String argument.  May be null.
This value may be null . |||
extras Bundle : provider-defined Bundle argument.  May be null.
This value may be null . |||","Bundle a result Bundle possibly null.  Will be null if the ContentProvider
   does not implement call. |||",11,This class provides applications access to the content model.,"Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no ,database,1,no,no,no,no,ContentResolvers are returned from queries to ContentProviders (aka databases). What is sensitive in this chain?
"<android.content.Intent: Intent putExtra(String,byte)>", ,"name String : The name of the extra data with package prefix. |||
value byte : The byte data value. |||","Intent Returns the same Intent object for chaining multiple calls
 into a single statement.

 This value will never be null . |||",1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,
<android.app.Activity: void finishFromChild(Activity)>,"This method was deprecated
      in API level R. Use finish() instead. This is called when a child activity of this one calls its finish() method.  The default implementation simply calls
 finish() on this activity (the parent) finishing the entire group.",child Activity : The activity making the call. |||,void,1,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
<android.speech.tts.TextToSpeech: int stop()>,"Interrupts the current utterance (whether played or rendered to file) and discards other
 utterances in the queue.",,int ERROR or SUCCESS . |||,4,"Synthesizes speech from text for immediate playback or to create a sound file.
  A TextToSpeech instance can only be used to synthesize text once it has completed its
 initialization. Implement the  TextToSpeech.OnInitListener  to be
 notified of the completion of the initialization. 
 When you are done using the TextToSpeech instance call the  shutdown()  method
 to release the native resources used by the TextToSpeech engine.",,no,possibly file info,0,no,no,no,no,OFF TOPIC: is the user's speech sensitive?
<android.webkit.WebView: Bitmap getFavicon()>,"Gets the favicon for the current page. This is the favicon of the current
 page until WebViewClient.onReceivedIcon is called.",,"Bitmap the favicon for the current page or null if the page doesn't
 have one or if no page has been loaded |||",1,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",no,UI,0,no,no,no,no,
<android.view.View: void onStartTemporaryDetach()>,"This is called when a container is going to temporarily detach a child with ViewGroup#detachViewFromParent(View) .
 It will either be followed by onFinishTemporaryDetach() or onDetachedFromWindow() when the container is done.",,void,3,"This class represents the basic building block for user interface components. A View
 occupies a rectangular area on the screen and is responsible for drawing and
 event handling. View is the base class for  widgets  which are
 used to create interactive UI components (buttons text fields etc.). The
  ViewGroup  subclass is the base class for  layouts  which
 are invisible containers that hold other Views (or other ViewGroups) and define
 their layout properties.",,no,no,0,no,no,no,no,
<android.widget.Toast: void setText(CharSequence)>,Update the text in a Toast that was previously created using one of the makeText() methods.,s CharSequence : The new text for the Toast. |||,void,1,"A toast is a view containing a quick little message for the user.  The toast class
 helps you create and show those.
  
 When the view is shown to the user appears as a floating view over the
 application.  It will never receive focus.  The user will probably be in the
 middle of typing something else.  The idea is to be as unobtrusive as
 possible while still showing the user the information you want them to see.
 Two examples are the volume control and the brief message saying that your
 settings have been saved.
  
 The easiest way to use this class is to call one of the static methods that constructs
 everything you need and returns a new Toast object.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",uncategorized,yes,1,no,yes,no,SINK,Is sending text to the UI really sensitive? 
"<android.accounts.AccountManager: void setAuthToken(Account,String,String)>","Adds an auth token to the AccountManager cache for an account.
 If the account does not exist then this call has no effect.
 Replaces any previous auth token for this account and auth token type.
 Intended for use by the authenticator not directly by applications. It is safe to call this method from the main thread. This method requires the caller to have a signature match with the
 authenticator that manages the specified account. NOTE: If targeting your app to work on API level 22 and before
 AUTHENTICATE_ACCOUNTS permission and same UID as account's authenticator
 is needed for those platforms. See docs for this function in API level 22. Requires android.Manifest.permission.AUTHENTICATE_ACCOUNTS","account Account : The account to set an auth token for |||
authTokenType String : The type of the auth token see {#getAuthToken} |||
authToken String : The auth token to add to the cache |||",void,5,"This class provides access to a centralized registry of the user's
 online accounts.  The user enters credentials (username and password) once
 per account granting applications access to online resources with
 ""one-click"" approval.

  Different online services have different ways of handling accounts and
 authentication so the account manager uses pluggable  authenticator 
 modules for different  account types .  Authenticators (which may be
 written by third parties) handle the actual details of validating account
 credentials and storing account information.  For example Google Facebook
 and Microsoft Exchange each have their own authenticator.

  Many servers support some notion of an  authentication token 
 which can be used to authenticate a request to the server without sending
 the user's actual password.  (Auth tokens are normally created with a
 separate request which does include the user's credentials.)  AccountManager
 can generate auth tokens for applications so the application doesn't need to
 handle passwords directly.  Auth tokens are normally reusable and cached by
 AccountManager but must be refreshed periodically.  It's the responsibility
 of applications to  invalidate  auth tokens when they stop working so
  the AccountManager knows it needs to regenerate them.

  Applications accessing a server normally go through these steps:

  Get an instance of AccountManager using  get(android.content.Context) .

  List the available accounts using  getAccountsByType(String)  or
  getAccountsByTypeAndFeatures(String String[] AccountManagerCallback  Handler) .  Normally applications will only
 be interested in accounts with one particular  type  which
 identifies the authenticator.  Account  features  are used to
 identify particular account subtypes and capabilities.  Both the account
 type and features are authenticator-specific strings and must be known by
 the application in coordination with its preferred authenticators.

  Select one or more of the available accounts possibly by asking the
 user for their preference.  If no suitable accounts are available
  addAccount(String String String[] Bundle Activity AccountManagerCallback  Handler)  may be called to prompt the user to create an
 account of the appropriate type.

  Important:  If the application is using a previously remembered
 account selection it must make sure the account is still in the list
 of accounts returned by  getAccountsByType(String) .  Requesting an auth token
 for an account no longer on the device results in an undefined failure.

  Request an auth token for the selected account(s) using one of the
  getAuthToken(Account String Bundle Activity AccountManagerCallback  Handler)  methods or related helpers.  Refer to the description
 of each method for exact usage and error handling details.

  Make the request using the auth token.  The form of the auth token
 the format of the request and the protocol used are all specific to the
 service you are accessing.  The application may use whatever network and
 protocol libraries are useful.

  Important:  If the request fails with an authentication error
 it could be that a cached auth token is stale and no longer honored by
 the server.  The application must call  invalidateAuthToken(String String)  to remove
 the token from the cache otherwise requests will continue failing!  After
 invalidating the auth token immediately go back to the ""Request an auth
 token"" step above.  If the process fails the second time then it can be
 treated as a ""genuine"" authentication failure and the user notified or other
 appropriate actions taken.
  Some AccountManager methods may need to interact with the user to
 prompt for credentials present options or ask the user to add an account.
 The caller may choose whether to allow AccountManager to directly launch the
 necessary user interface and wait for the user or to return an Intent which
 the caller may use to launch the interface or (in some cases) to install a
 notification which the user can select at any time to launch the interface.
 To have AccountManager launch the interface directly the caller must supply
 the current foreground  Activity  context.

  Many AccountManager methods take  AccountManagerCallback  and
  Handler  as parameters.  These methods return immediately and
 run asynchronously. If a callback is provided then
  AccountManagerCallback#run  will be invoked on the Handler's
 thread when the request completes successfully or not.
 The result is retrieved by calling  AccountManagerFuture#getResult() 
 on the  AccountManagerFuture  returned by the method (and also passed
 to the callback).  This method waits for the operation to complete (if
 necessary) and either returns the result or throws an exception if an error
 occurred during the operation.  To make the request synchronously call
  AccountManagerFuture#getResult()  immediately on receiving the
 future from the method; no callback need be supplied.

  Requests which may block including
  AccountManagerFuture#getResult()  must never be called on
 the application's main event thread.  These operations throw
  IllegalStateException  if they are used on the main thread.",,no,no,0,no,no,no,no,this seems sensitive
<android.widget.TextClock: void setTimeZone(String)>,"Sets the specified time zone to use in this clock. When the time zone
 is set through this method system time zone changes (when the user
 sets the time zone in settings for instance) will be ignored. Related XML Attributes: android:timeZone","timeZone String : The desired time zone's ID as specified in TimeZone or null to user the time zone specified by the user
(system time zone) |||",void,17,"TextClock  can display the current date and/or time as
 a formatted string. This view honors the 24-hour format system setting. As such it is
 possible and recommended to provide two different formatting patterns:
 one to display the date/time in 24-hour mode and one to display the
 date/time in 12-hour mode. Most callers will want to use the defaults
 though which will be appropriate for the user's locale. It is possible to determine whether the system is currently in
 24-hour mode by calling  is24HourModeEnabled() . The rules used by this widget to decide how to format the date and
 time are the following: In 24-hour mode:
          Use the value returned by  getFormat24Hour()  when non-null Otherwise use the value returned by  getFormat12Hour()  when non-null Otherwise use a default value appropriate for the user's locale such as  h:mm a In 12-hour mode:
          Use the value returned by  getFormat12Hour()  when non-null Otherwise use the value returned by  getFormat24Hour()  when non-null Otherwise use a default value appropriate for the user's locale such as  HH:mm The  CharSequence  instances used as formatting patterns when calling either
  setFormat24Hour(java.lang.CharSequence)  or  setFormat12Hour(java.lang.CharSequence)  can
 contain styling information. To do so use a  Spanned  object.
 Note that if you customize these strings it is your responsibility to supply strings
 appropriate for formatting dates and/or times in the user's locale.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,no,0,no,no,no,no,Is the clock a shared resource? Cause this takes an 'uncategorized' sensitive parameter
"<android.view.FocusFinder: View findNextFocusFromRect(ViewGroup,Rect,int)>","Find the next view to take focus in root's descendants searching from
 a particular rectangle in root's coordinates.","root ViewGroup : Contains focusedRect. Cannot be null. |||
focusedRect Rect : The starting point of the search. |||
direction int : Direction to look. |||",View The next focusable view or null if none exists. |||,1,"The algorithm used for finding the next focusable view in a given direction
 from a view that currently has focus.",,no,UI,0,no,no,no,no,
<android.view.View: void setScrollBarDefaultDelayBeforeFade(int)>,Define the delay before scrollbars fade. Related XML Attributes: android:scrollbarDefaultDelayBeforeFade,scrollBarDefaultDelayBeforeFade int : - the delay before scrollbars fade |||,void,16,"This class represents the basic building block for user interface components. A View
 occupies a rectangular area on the screen and is responsible for drawing and
 event handling. View is the base class for  widgets  which are
 used to create interactive UI components (buttons text fields etc.). The
  ViewGroup  subclass is the base class for  layouts  which
 are invisible containers that hold other Views (or other ViewGroups) and define
 their layout properties.",,no,no,0,no,no,no,no,
"<android.telephony.PhoneNumberUtils: String getNumberFromIntent(Intent,Context)>",Extracts the phone number from an Intent.,"intent Intent : the intent to get the number of |||
context Context : a context to use for database access |||",String the phone number that would be called by the intent or null if the number cannot be found. |||,1,Various utilities for dealing with phone number strings.,,Contacts,no,0,yes,no,no,no, 
<android.appwidget.AppWidgetHost: int allocateAppWidgetId()>,Get a appWidgetId for a host in the calling process.,,int a appWidgetId |||,3,"AppWidgetHost provides the interaction with the AppWidget service for apps
 like the home screen that want to embed AppWidgets in their UI.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
<android.preference.PreferenceActivity: void addPreferencesFromIntent(Intent)>,"This method was deprecated
      in API level 15. This function is not relevant for a modern fragment-based
 PreferenceActivity. Adds preferences from activities that match the given Intent .",intent Intent : The Intent to query activities. |||,void,1,"This is the base class for an activity to show a hierarchy of preferences
 to the user.  Prior to  Build.VERSION_CODES.HONEYCOMB 
 this class only allowed the display of a single set of preference; this
 functionality should now be found in the new  PreferenceFragment 
 class.  If you are using PreferenceActivity in its old mode the documentation
 there applies to the deprecated APIs here.

  This activity shows one or more headers of preferences each of which
 is associated with a  PreferenceFragment  to display the preferences
 of that header.  The actual layout and display of these associations can
 however vary; currently there are two major approaches it may take:

  On a small screen it may display only the headers as a single list when first launched.
 Selecting one of the header items will only show the PreferenceFragment of that header (on
 Android N and lower a new Activity is launched).
  On a large screen it may display both the headers and current PreferenceFragment together as
 panes. Selecting a header item switches to showing the correct PreferenceFragment for that item.
  Subclasses of PreferenceActivity should implement
  onBuildHeaders(List )  to populate the header list with the desired
 items.  Doing this implicitly switches the class into its new ""headers
 + fragments"" mode rather than the old style of just showing a single
 preferences list.",,no,no,0,no,no,no,no,Are preferences sensitive data? And are settings a shared resource? I think I've seen apps on my phone know setting for other apps
<android.widget.HorizontalScrollView: void fling(int)>,Fling the scroll view,"velocityX int : The initial velocity in the X direction. Positive
numbers mean that the finger/cursor is moving down the screen
which means we want to scroll towards the left. |||",void,3,"Layout container for a view hierarchy that can be scrolled by the user
 allowing it to be larger than the physical display.  A HorizontalScrollView
 is a  FrameLayout  meaning you should place one child in it
 containing the entire contents to scroll; this child may itself be a layout
 manager with a complex hierarchy of objects.  A child that is often used
 is a  LinearLayout  in a horizontal orientation presenting a horizontal
 array of top-level items that the user can scroll through.

  The  TextView  class also
 takes care of its own scrolling so does not require a HorizontalScrollView but
 using the two together is possible to achieve the effect of a text view
 within a larger container.

  HorizontalScrollView only supports horizontal scrolling. For vertical scrolling
 use either  ScrollView  or  ListView .","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,no,0,no,no,no,no,
<android.nfc.tech.NfcV: void close()>,"Disable I/O operations to the tag from this TagTechnology object and release resources. Also causes all blocked I/O operations on other thread to be canceled and
 return with IOException . Requires the Manifest.permission.NFC permission.",,void,-1,"Provides access to NFC-V (ISO 15693) properties and I/O operations on a  Tag .

  Acquire a  NfcV  object using  get(Tag) .
  The primary NFC-V I/O operation is  transceive(byte[]) . Applications must
 implement their own protocol stack on top of  transceive(byte[]) .

  Note:  Methods that perform I/O operations
 require the  Manifest.permission.NFC  permission.","These classes provide access to a tag technology's features which vary by the type
 of tag that is scanned. A scanned tag can support multiple technologies and you can find
 out what they are by calling  getTechList() . For more information on dealing with tag technologies and handling the ones that you care about see
  The Tag Dispatch System .
 The  TagTechnology  interface provides an overview of the
 supported technologies.",no,nfc,0,no,no,no,no,
"<android.app.PendingIntent: void send(Context,int,Intent)>","Perform the operation associated with this PendingIntent allowing the
 caller to specify information about the Intent to use.","context Context : The Context of the caller. |||
code int : Result code to supply back to the PendingIntent's target. |||
intent Intent : Additional Intent data.  See Intent#fillIn for information on how this is applied to the
original Intent. If flag FLAG_IMMUTABLE was set when this
pending intent was created this argument will be ignored.
This value may be null . |||",void,1,"A description of an Intent and target action to perform with it.  Instances
 of this class are created with  getActivity(Context int Intent int)   getActivities(Context int Intent[] int) 
  getBroadcast(Context int Intent int)  and  getService(Context int Intent int) ; the returned object can be
 handed to other applications so that they can perform the action you
 described on your behalf at a later time.

  By giving a PendingIntent to another application
 you are granting it the right to perform the operation you have specified
 as if the other application was yourself (with the same permissions and
 identity).  As such you should be careful about how you build the PendingIntent:
 almost always for example the base Intent you supply should have the component
 name explicitly set to one of your own components to ensure it is ultimately
 sent there and nowhere else.

  A PendingIntent itself is simply a reference to a token maintained by
 the system describing the original data used to retrieve it.  This means
 that even if its owning application's process is killed the
 PendingIntent itself will remain usable from other processes that
 have been given it.  If the creating application later re-retrieves the
 same kind of PendingIntent (same operation same Intent action data
 categories and components and same flags) it will receive a PendingIntent
 representing the same token if that is still valid and can thus call
  cancel()  to remove it.

  Because of this behavior it is important to know when two Intents
 are considered to be the same for purposes of retrieving a PendingIntent.
 A common mistake people make is to create multiple PendingIntent objects
 with Intents that only vary in their ""extra"" contents expecting to get
 a different PendingIntent each time.  This does  not  happen.  The
 parts of the Intent that are used for matching are the same ones defined
 by  Intent#filterEquals(Intent) .  If you use two
 Intent objects that are equivalent as per
  Intent#filterEquals(Intent)  then you will get
 the same PendingIntent for both of them.

  There are two typical ways to deal with this.

  If you truly need multiple distinct PendingIntent objects active at
 the same time (such as to use as two notifications that are both shown
 at the same time) then you will need to ensure there is something that
 is different about them to associate them with different PendingIntents.
 This may be any of the Intent attributes considered by
  Intent#filterEquals(Intent)  or different
 request code integers supplied to  getActivity(Context int Intent int)   getActivities(Context int Intent[] int) 
  getBroadcast(Context int Intent int)  or  getService(Context int Intent int) .

  If you only need one PendingIntent active at a time for any of the
 Intents you will use then you can alternatively use the flags
  FLAG_CANCEL_CURRENT  or  FLAG_UPDATE_CURRENT  to either
 cancel or modify whatever current PendingIntent is associated with the
 Intent you are supplying.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
<android.speech.tts.TextToSpeech: List getEngines()>,Gets a list of all installed TTS engines.,,List < TextToSpeech.EngineInfo > A list of engine info objects. The list can be empty but never null . |||,14,"Synthesizes speech from text for immediate playback or to create a sound file.
  A TextToSpeech instance can only be used to synthesize text once it has completed its
 initialization. Implement the  TextToSpeech.OnInitListener  to be
 notified of the completion of the initialization. 
 When you are done using the TextToSpeech instance call the  shutdown()  method
 to release the native resources used by the TextToSpeech engine.",,no,assumed,0,no,no,no,no,
"<android.content.Intent: Intent putExtra(String,long)>","Add extended data to the intent.  The name must include a package
 prefix for example the app com.android.contacts would use names
 like ""com.android.contacts.ShowAll"".","name String : The name of the extra data with package prefix. |||
value long : The byte array data value.
This value may be null . |||","Intent Returns the same Intent object for chaining multiple calls
 into a single statement.

 This value will never be null . |||",1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",uncategorized,yes?,1,no,yes,no,SINK,Intents are shared resource? They get sent to other apps right?
"<android.content.ContextWrapper: void enforceCallingOrSelfPermission(String,String)>","If neither you nor the calling process of an IPC you are
 handling has been granted a particular permission throw a SecurityException .  This is the same as enforceCallingPermission(String String) except it grants your own
 permissions if you are not currently processing an IPC.  Use
 with care!","permission String : The name of the permission being checked.
This value must never be null . |||
message String : A message to include in the exception if it is thrown.
This value may be null . |||",void,1,"Proxying implementation of Context that simply delegates all of its calls to
 another Context.  Can be subclassed to modify behavior without changing
 the original Context.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,package description for android.content was informative for how to handle Intents
<android.drm.DrmManagerClient: int checkRightsStatus(Uri)>,Check whether the given content has valid rights.,uri Uri : URI of the rights-protected content. |||,int An int representing the DrmStore.RightsStatus of the content. |||,11,"The main programming interface for the DRM framework. An application must instantiate this class
 to access DRM agents through the DRM framework.","Provides classes for managing DRM content and determining the capabilities of DRM plugins
 (agents). Common uses of the DRM API include: Determining which DRM plug-ins (agents) are installed on a device. Retrieving information about specific plug-ins such as the MIME types and file suffixes
   they support. Registering a user or a device with an online DRM service. Retrieving license constraints for rights-protected content. Checking whether a user has the proper rights to play or use rights-protected
   content. Associating rights-protected content with its license so you can use the
    MediaPlayer  API to play the content.",no,no,0,no,no,no,no,
<android.content.Intent: String toUri(int)>,"Convert this Intent into a  String holding a URI representation of it.
 The returned URI string has been properly URI encoded so it can be
 used with Uri#parse .  The URI contains the
 Intent's data as the base URI with an additional fragment describing
 the action categories type flags package component and extras. You can convert the returned string back to an Intent with getIntent(String) .","flags int : Additional operating flags.
Value is either 0 or a combination of URI_ALLOW_UNSAFE  URI_ANDROID_APP_SCHEME and URI_INTENT_SCHEME |||","String Returns a URI encoding URI string describing the entire contents
 of the Intent. |||",4,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",uncategorized,no,0,no,no,no,no,
<android.view.Display: int getWidth()>,"This method was deprecated
      in API level 15. Use WindowMetrics#getSize() instead.",,int |||,1,"Provides information about the size and density of a logical display.
  
 The display area is described in two different ways.
  The application display area specifies the part of the display that may contain
 an application window excluding the system decorations.  The application display area may
 be smaller than the real display area because the system subtracts the space needed
 for decor elements such as the status bar.  Use the following methods to query the
 application display area:  getSize(Point)   getRectSize(Rect)  and  getMetrics(DisplayMetrics) . The real display area specifies the part of the display that contains content
 including the system decorations.  Even so the real display area may be smaller than the
 physical size of the display if the window manager is emulating a smaller display
 using (adb shell wm size).  Use the following methods to query the
 real display area:  getRealSize(Point)   getRealMetrics(DisplayMetrics) . 
 A logical display does not necessarily represent a particular physical display device
 such as the built-in screen or an external monitor.  The contents of a logical
 display may be presented on one or more physical displays according to the devices
 that are currently attached and whether mirroring has been enabled.",,no,UI,0,no,no,no,no,
<android.database.sqlite.SQLiteDatabase: int getVersion()>,Gets the database version.,,int the database version |||,1,"Exposes methods to manage a SQLite database.

  
 SQLiteDatabase has methods to create delete execute SQL commands and
 perform other common database management tasks.
  
 See the Notepad sample application in the SDK for an example of creating
 and managing a database.
  
 Database names must be unique within an application not across all applications.
  Localized Collation - ORDER BY 
 In addition to SQLite's default  BINARY  collator Android supplies
 two more  LOCALIZED  which changes with the system's current locale
 and  UNICODE  which is the Unicode Collation Algorithm and not tailored
 to the current locale.","If you need to manage data in a private database use the  android.database.sqlite  classes. These classes are used to manage the  Cursor  object returned from a content provider query. Databases
 are usually created and opened with  openOrCreateDatabase(String int SQLiteDatabase.CursorFactory) 
 To make requests through
 content providers you can use the  content.ContentResolver  class.
  All databases are stored on the device in  /data/data/<package_name>/databases",metadata?,database,1,yes,no,SOURCE,no,Metadata sensitive for all shared resources?
<android.app.WallpaperManager: int getDesiredMinimumWidth()>,"Returns the desired minimum width for the wallpaper. Callers of setBitmap(android.graphics.Bitmap) or setStream(java.io.InputStream) should check this value
 beforehand to make sure the supplied wallpaper respects the desired
 minimum width.

 If the returned value is <= 0 the caller should use the width of
 the default display instead.",,"int The desired minimum width for the wallpaper. This value should
 be honored by applications that set the wallpaper but it is not
 mandatory. |||",5,"Provides access to the system wallpaper. With WallpaperManager you can
 get the current wallpaper get the desired dimensions for the wallpaper set
 the wallpaper and more.

   An app can check whether wallpapers are supported for the current user by calling
  isWallpaperSupported()  and whether setting of wallpapers is allowed by calling
  isSetWallpaperAllowed() .","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
"<android.accounts.AccountManager: AccountManagerFuture getAccountsByTypeAndFeatures(String,String,AccountManagerCallback,Handler)>","Lists all accounts of a type which have certain features. The account type identifies the
 authenticator (see getAccountsByType(String) ). Account features are authenticator-specific
 string tokens identifying boolean account properties (see hasFeatures(Account String[] AccountManagerCallback Handler) ). Unlike getAccountsByType(String) this method calls the authenticator which may contact the
 server or do other work to check account features so the method returns an AccountManagerFuture . This method may be called from any thread but the returned AccountManagerFuture must
 not be used on the main thread. Caller targeting API level Build.VERSION_CODES.O and above will get list
 of accounts made visible to it by user
 (see newChooseAccountIntent(android.accounts.Account java.util.List java.lang.String[] java.lang.String java.lang.String java.lang.String[] android.os.Bundle) ) or AbstractAcccountAuthenticator
 using setAccountVisibility(Account String int) . Manifest.permission.GET_ACCOUNTS permission is not used. Caller targeting API level below Build.VERSION_CODES.O that have not been
 granted the Manifest.permission.GET_ACCOUNTS permission will only see those
 accounts managed by AbstractAccountAuthenticators whose signature matches the client. NOTE: If targeting your app to work on API level Build.VERSION_CODES.LOLLIPOP_MR1 and before Manifest.permission.GET_ACCOUNTS permission is
 needed for those platforms irrespective of uid or signature match. See docs for this
 function in API level Build.VERSION_CODES.LOLLIPOP_MR1 .","type String : The type of accounts to return must not be null |||
features String : An array of the account features to require may be null or empty * |||
callback AccountManagerCallback : Callback to invoke when the request completes null for no callback |||
handler Handler : Handler identifying the callback thread null for the main thread |||","AccountManagerFuture < Account[] > An AccountManagerFuture which resolves to an array of Account one
         per account of the specified type which matches the requested features. |||",5,"This class provides access to a centralized registry of the user's
 online accounts.  The user enters credentials (username and password) once
 per account granting applications access to online resources with
 ""one-click"" approval.

  Different online services have different ways of handling accounts and
 authentication so the account manager uses pluggable  authenticator 
 modules for different  account types .  Authenticators (which may be
 written by third parties) handle the actual details of validating account
 credentials and storing account information.  For example Google Facebook
 and Microsoft Exchange each have their own authenticator.

  Many servers support some notion of an  authentication token 
 which can be used to authenticate a request to the server without sending
 the user's actual password.  (Auth tokens are normally created with a
 separate request which does include the user's credentials.)  AccountManager
 can generate auth tokens for applications so the application doesn't need to
 handle passwords directly.  Auth tokens are normally reusable and cached by
 AccountManager but must be refreshed periodically.  It's the responsibility
 of applications to  invalidate  auth tokens when they stop working so
 the AccountManager knows it needs to regenerate them.

  Applications accessing a server normally go through these steps:

  Get an instance of AccountManager using  get(android.content.Context) .

  List the available accounts using  getAccountsByType(String)  or
  getAccountsByTypeAndFeatures(String String[] AccountManagerCallback  Handler) .  Normally applications will only
 be interested in accounts with one particular  type  which
 identifies the authenticator.  Account  features  are used to
 identify particular account subtypes and capabilities.  Both the account
 type and features are authenticator-specific strings and must be known by
 the application in coordination with its preferred authenticators.

  Select one or more of the available accounts possibly by asking the
 user for their preference.  If no suitable accounts are available
  addAccount(String String String[] Bundle Activity AccountManagerCallback  Handler)  may be called to prompt the user to create an
 account of the appropriate type.

  Important:  If the application is using a previously remembered
 account selection it must make sure the account is still in the list
 of accounts returned by  getAccountsByType(String) .  Requesting an auth token
 for an account no longer on the device results in an undefined failure.

  Request an auth token for the selected account(s) using one of the
  getAuthToken(Account String Bundle Activity AccountManagerCallback  Handler)  methods or related helpers.  Refer to the description
 of each method for exact usage and error handling details.

  Make the request using the auth token.  The form of the auth token
 the format of the request and the protocol used are all specific to the
 service you are accessing.  The application may use whatever network and
 protocol libraries are useful.

  Important:  If the request fails with an authentication error
 it could be that a cached auth token is stale and no longer honored by
 the server.  The application must call  invalidateAuthToken(String String)  to remove
 the token from the cache otherwise requests will continue failing!  After
 invalidating the auth token immediately go back to the ""Request an auth
 token"" step above.  If the process fails the second time then it can be
 treated as a ""genuine"" authentication failure and the user notified or other
 appropriate actions taken.
  Some AccountManager methods may need to interact with the user to
 prompt for credentials present options or ask the user to add an account.
 The caller may choose whether to allow AccountManager to directly launch the
 necessary user interface and wait for the user or to return an Intent which
 the caller may use to launch the interface or (in some cases) to install a
 notification which the user can select at any time to launch the interface.
 To have AccountManager launch the interface directly the caller must supply
 the current foreground  Activity  context.

  Many AccountManager methods take  AccountManagerCallback  and
  Handler  as parameters.  These methods return immediately and
 run asynchronously. If a callback is provided then
  AccountManagerCallback#run  will be invoked on the Handler's
 thread when the request completes successfully or not.
 The result is retrieved by calling  AccountManagerFuture#getResult() 
 on the  AccountManagerFuture  returned by the method (and also passed
 to the callback).  This method waits for the operation to complete (if
 necessary) and either returns the result or throws an exception if an error
 occurred during the operation.  To make the request synchronously call
  AccountManagerFuture#getResult()  immediately on receiving the
 future from the method; no callback need be supplied.

  Requests which may block including
  AccountManagerFuture#getResult()  must never be called on
 the application's main event thread.  These operations throw
  IllegalStateException  if they are used on the main thread.",,account info,file data,1,yes,no,SOURCE,no,
<android.view.ViewGroup: void dispatchWindowVisibilityChanged(int)>,"Dispatch a window visibility change down the view hierarchy.
 ViewGroups should override to route to their children.","visibility int : The new visibility of the window.
Value is View.VISIBLE  View.INVISIBLE or View.GONE |||",void,1,"A  ViewGroup  is a special view that can contain other views
 (called children.) The view group is the base class for layouts and views
 containers. This class also defines the
  ViewGroup.LayoutParams  class which serves as the base
 class for layouts parameters.
  
 Also see  LayoutParams  for layout attributes.",,no,UI,0,no,no,no,no,
<android.view.ViewGroup: void removeViewInLayout(View)>,"Removes a view during layout. This is useful if in your onLayout() method
 you need to remove more views. Note: do not invoke this method from View.draw(android.graphics.Canvas)  View.onDraw(android.graphics.Canvas)  dispatchDraw(android.graphics.Canvas) or any related method.",view View : the view to remove from the group |||,void,1,"A  ViewGroup  is a special view that can contain other views
 (called children.) The view group is the base class for layouts and views
 containers. This class also defines the
  ViewGroup.LayoutParams  class which serves as the base
 class for layouts parameters.
  
 Also see  LayoutParams  for layout attributes.",,no,UI,0,no,no,no,no,
"<android.widget.RemoteViews: View apply(Context,ViewGroup)>","Inflates the view hierarchy represented by this object and applies
 all of the actions. Caller beware: this may throw","context Context : Default context to use |||
parent ViewGroup : Parent that the resulting view hierarchy will be attached to. This method
does not attach the hierarchy. The caller should do so when appropriate. |||",View The inflated view hierarchy |||,1,"A class that describes a view hierarchy that can be displayed in
 another process. The hierarchy is inflated from a layout resource
 file and this class provides some basic operations for modifying
 the content of the inflated hierarchy.

  RemoteViews  is limited to support for the following layouts: AdapterViewFlipper FrameLayout GridLayout GridView LinearLayout ListView RelativeLayout StackView ViewFlipper And the following widgets: AnalogClock Button Chronometer ImageButton ImageView ProgressBar TextClock TextView Descendants of these classes are not supported.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,UI,0,no,no,no,no,
"<android.hardware.SensorManager: void unregisterListener(SensorListener,int)>","This method was deprecated
      in API level 15. This method is deprecated use SensorManager#unregisterListener(SensorEventListener Sensor) instead. Unregisters a listener for the sensors with which it is registered.","listener SensorListener : a SensorListener object |||
sensors int : a bit masks of the sensors to unregister from |||",void,1,"SensorManager lets you access the device's  sensors .
  
 Always make sure to disable sensors you don't need especially when your
 activity is paused. Failing to do so can drain the battery in just a few
 hours. Note that the system will  not  disable sensors automatically when
 the screen turns off.
  
 Note: Don't use this mechanism with a Trigger Sensor have a look
 at  TriggerEventListener .  Sensor#TYPE_SIGNIFICANT_MOTION 
 is an example of a trigger sensor.
  
 public class SensorActivity extends Activity implements SensorEventListener {
     private final SensorManager mSensorManager;
     private final Sensor mAccelerometer;

     public SensorActivity() {
         mSensorManager = (SensorManager)getSystemService(SENSOR_SERVICE);
         mAccelerometer = mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
     }

     protected void onResume() {
         super.onResume();
         mSensorManager.registerListener(this mAccelerometer SensorManager.SENSOR_DELAY_NORMAL);
     }

     protected void onPause() {
         super.onPause();
         mSensorManager.unregisterListener(this);
     }

     public void onAccuracyChanged(Sensor sensor int accuracy) {
     }

     public void onSensorChanged(SensorEvent event) {
     }
 }","Provides support for hardware features such as the camera and other sensors. Be aware that
 not all Android-powered devices support all hardware features so you should declare hardware
 that your application requires using the  <uses-feature>  manifest element.",no,Sensors,0,no,no,no,no,
"<android.os.Bundle: void putShortArray(String,short)>","Inserts a short array value into the mapping of this Bundle replacing
 any existing value for the given key.  Either key or value may be null.","key String : a String or null
This value may be null . |||
value short : a short array object or null
This value may be null . |||",void,1,A mapping from String keys to various  Parcelable  values.,,no,no,0,no,no,no,no,
<android.nfc.tech.NfcA: int getTimeout()>,Get the current transceive(byte[]) timeout in milliseconds. Requires the Manifest.permission.NFC permission.,,int timeout value in milliseconds |||,14,"Provides access to NFC-A (ISO 14443-3A) properties and I/O operations on a  Tag .

  Acquire a  NfcA  object using  get(Tag) .
  The primary NFC-A I/O operation is  transceive(byte[]) . Applications must
 implement their own protocol stack on top of  transceive(byte[]) .

  Note:  Methods that perform I/O operations
 require the  Manifest.permission.NFC  permission.","These classes provide access to a tag technology's features which vary by the type
 of tag that is scanned. A scanned tag can support multiple technologies and you can find
 out what they are by calling  getTechList() . For more information on dealing with tag technologies and handling the ones that you care about see
  The Tag Dispatch System .
 The  TagTechnology  interface provides an overview of the
 supported technologies.",metadata?,nfc,1,yes,no,SOURCE,no,
"<android.widget.RemoteViews: void reapply(Context,View)>",Applies all of the actions to the provided view. Caller beware: this may throw,"context Context |||
v View : The view to apply the actions to.  This should be the result of
the apply(android.content.Context android.view.ViewGroup) call. |||",void,1,"A class that describes a view hierarchy that can be displayed in
 another process. The hierarchy is inflated from a layout resource
 file and this class provides some basic operations for modifying
 the content of the inflated hierarchy.

  RemoteViews  is limited to support for the following layouts: AdapterViewFlipper FrameLayout GridLayout GridView LinearLayout ListView RelativeLayout StackView ViewFlipper And the following widgets: AnalogClock Button Chronometer ImageButton ImageView ProgressBar TextClock TextView Descendants of these classes are not supported.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",uncategorized,IPC,1,no,no,no,no,Do we consider IPC a shared resource?
"<android.telephony.gsm.SmsManager: void sendTextMessage(String,String,String,PendingIntent,PendingIntent)>","This method was deprecated
      in API level 4. Use android.telephony.SmsManager. Send a text based SMS.","destinationAddress String : the address to send the message to |||
scAddress String : is the service center address or null to use
the current default SMSC |||
text String : the body of the message to send |||
sentIntent PendingIntent : if not NULL this PendingIntent is
broadcast when the message is successfully sent or failed.
The result code will be Activity.RESULT_OK for success
or one of these errors: RESULT_ERROR_GENERIC_FAILURE RESULT_ERROR_RADIO_OFF RESULT_ERROR_NULL_PDU .
The per-application based SMS control checks sentIntent. If sentIntent
is NULL the caller will be checked against all unknown applications
which cause smaller number of SMS to be sent in checking period. |||
deliveryIntent PendingIntent : if not NULL this PendingIntent is
broadcast when the message is delivered to the recipient.  The
raw pdu of the status report is in the extended data (""pdu""). |||",void,1,"Manages SMS operations such as sending data text and pdu SMS messages.
 Get this object by calling the static method SmsManager.getDefault().",,uncategorized,sms,1,no,yes,no,SINK,
"<android.util.Log: int wtf(String,String)>","What a Terrible Failure: Report a condition that should never happen.
 The error will always be logged at level ASSERT with the call stack.
 Depending on system configuration a report may be added to the DropBoxManager and/or the process may be terminated
 immediately with an error dialog.","tag String : Used to identify the source of a log message.
This value may be null . |||
msg String : The message you would like logged.
This value may be null . |||",int |||,8,"API for sending log output.

  Generally you should use the  Log.v()   Log.d() 
  Log.i()   Log.w()  and  Log.e()  methods to write logs.
 You can then  view the logs in logcat .

  The order in terms of verbosity from least to most is
 ERROR WARN INFO DEBUG VERBOSE.  Verbose should never be compiled
 into an application except during development.  Debug logs are compiled
 in but stripped at runtime.  Error warning and info logs are always kept.

  Tip:  A good convention is to declare a  TAG  constant
 in your class:

  private static final String TAG = ""MyActivity""; Tip:  Don't forget that when you make a call like
  Log.v(TAG ""index="" + i);",,uncategorized,file data,1,no,yes,no,SINK,
"<android.os.Bundle: void putShort(String,short)>","Inserts a short value into the mapping of this Bundle replacing
 any existing value for the given key.","key String : a String or null
This value may be null . |||
value short : a short |||",void,1,A mapping from String keys to various  Parcelable  values.,,no,no,0,no,no,no,no,
<android.webkit.WebView: void setInitialScale(int)>,"Sets the initial scale for this WebView. 0 means default.
 The behavior for the default scale depends on the state of WebSettings#getUseWideViewPort() and WebSettings#getLoadWithOverviewMode() .
 If the content fits into the WebView control by width then
 the zoom is set to 100%. For wide content the behavior
 depends on the state of WebSettings#getLoadWithOverviewMode() .
 If its value is true the content will be zoomed out to be fit
 by width into the WebView control otherwise not.

 If initial scale is greater than 0 WebView starts with this value
 as initial scale.
 Please note that unlike the scale properties in the viewport meta tag
 this method doesn't take the screen density into account.",scaleInPercent int : the initial scale in percent |||,void,1,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",no,no,0,no,no,no,no,
<android.bluetooth.BluetoothDevice: BluetoothClass getBluetoothClass()>,Get the Bluetooth class of the remote device. Requires Manifest.permission.BLUETOOTH,,BluetoothClass Bluetooth class object or null on error |||,5,"Represents a remote Bluetooth device. A  BluetoothDevice  lets you
 create a connection with the respective device or query information about
 it such as the name address class and bonding state.

  This class is really just a thin wrapper for a Bluetooth hardware
 address. Objects of this class are immutable. Operations on this class
 are performed on the remote Bluetooth hardware address using the
  BluetoothAdapter  that was used to create this  BluetoothDevice .

  To get a  BluetoothDevice  use
  BluetoothAdapter#getRemoteDevice(String)  to create one representing a device
 of a known MAC address (which you can get through device discovery with
  BluetoothAdapter ) or get one from the set of bonded devices
 returned by  BluetoothAdapter#getBondedDevices() . You can then open a
  BluetoothSocket  for communication with the remote device using
  createRfcommSocketToServiceRecord(java.util.UUID)  over Bluetooth BR/EDR or using
  createL2capChannel(int)  over Bluetooth LE.

  Note: 
 Requires the  Manifest.permission.BLUETOOTH  permission.","Provides classes that manage Bluetooth functionality such as scanning for
 devices connecting with devices and managing data transfer between devices.
 The Bluetooth API supports both ""Classic Bluetooth"" and Bluetooth Low Energy. For more information about Classic Bluetooth see the
  Bluetooth  guide.
 For more information about Bluetooth Low Energy see the
  
 Bluetooth Low Energy  (BLE) guide. The Bluetooth APIs let applications: Scan for other Bluetooth devices (including BLE devices). Query the local Bluetooth adapter for paired Bluetooth devices. Establish RFCOMM channels/sockets. Connect to specified sockets on other devices. Transfer data to and from other devices. Communicate with BLE devices such as proximity sensors heart rate
     monitors fitness devices and so on. Act as a GATT client or a GATT server (BLE). 
 To perform Bluetooth communication using these APIs an application must
 declare the  BLUETOOTH  permission. Some
 additional functionality such as requesting device discovery
 also requires the  BLUETOOTH_ADMIN 
 permission.
  Note: 
 Not all Android-powered devices provide Bluetooth functionality.",metadata?,bluetooth,1,yes,no,SOURCE,no,"Again, metadata about more than just images?"
<android.database.sqlite.SQLiteOpenHelper: SQLiteDatabase getWritableDatabase()>,"Create and/or open a database that will be used for reading and writing.
 The first time this is called the database will be opened and onCreate(SQLiteDatabase)  onUpgrade(SQLiteDatabase int int) and/or onOpen(SQLiteDatabase) will be
 called. Once opened successfully the database is cached so you can
 call this method every time you need to write to the database.
 (Make sure to call close() when you no longer need the database.)
 Errors such as bad permissions or a full disk may cause this method
 to fail but future attempts may succeed if the problem is fixed. Database upgrade may take a long time you
 should not call this method from the application main thread including
 from ContentProvider.onCreate() .",,SQLiteDatabase a read/write database object valid until close() is called |||,1,"A helper class to manage database creation and version management.

  You create a subclass implementing  onCreate(SQLiteDatabase)   onUpgrade(SQLiteDatabase int int)  and
 optionally  onOpen(SQLiteDatabase)  and this class takes care of opening the database
 if it exists creating it if it does not and upgrading it as necessary.
 Transactions are used to make sure the database is always in a sensible state.

  This class makes it easy for  ContentProvider 
 implementations to defer opening and upgrading the database until first use
 to avoid blocking application startup with long-running database upgrades.

  For an example see the NotePadProvider class in the NotePad sample application
 in the  samples/  directory of the SDK. Note:  this class assumes
 monotonically increasing version numbers for upgrades. Note:  the  AutoCloseable  interface was
 first added in the  Build.VERSION_CODES.Q  release.","If you need to manage data in a private database use the  android.database.sqlite  classes. These classes are used to manage the  Cursor  object returned from a content provider query. Databases
 are usually created and opened with  openOrCreateDatabase(String int SQLiteDatabase.CursorFactory) 
 To make requests through
 content providers you can use the  content.ContentResolver  class.
  All databases are stored on the device in  /data/data/<package_name>/databases",file data,database,1,yeas,no,SOURCE,no,this gets the whole database
"<android.telephony.PhoneNumberUtils: void formatNumber(Editable,int)>","This method was deprecated
      in API level 21. Use link #formatNumber(String phoneNumber String defaultCountryIso) instead Formats a phone number in-place. Currently FORMAT_JAPAN and FORMAT_NANP is supported as a second argument.","text Editable : The number to be formatted will be modified with the formatting |||
defaultFormattingType int : The default formatting rules to apply if the number does
not begin with +[country_code] |||",void,1,Various utilities for dealing with phone number strings.,,phone number,no,0,no,no,no,no,
<android.view.ViewConfiguration: int getLongPressTimeout()>,,,"int the duration in milliseconds before a press turns into
 a long press |||",1,Contains methods to standard constants used in the UI for timeouts sizes and distances.,,no,no,0,no,no,no,no,
<android.view.View: void dispatchStartTemporaryDetach()>,"Dispatch onStartTemporaryDetach() to this View and its direct children if this is
 a container View. If you override this method you must call through to the
 superclass implementation.",,void,24,"This class represents the basic building block for user interface components. A View
 occupies a rectangular area on the screen and is responsible for drawing and
 event handling. View is the base class for  widgets  which are
 used to create interactive UI components (buttons text fields etc.). The
  ViewGroup  subclass is the base class for  layouts  which
 are invisible containers that hold other Views (or other ViewGroups) and define
 their layout properties.",,no,no,0,no,on,no,no,
"<android.app.ActivityOptions: ActivityOptions makeThumbnailScaleUpAnimation(View,Bitmap,int,int)>","Create an ActivityOptions specifying an animation where a thumbnail
 is scaled from a given position to the new activity window that is
 being started. If the Intent this is being used with has not set its Intent.setSourceBounds those bounds will be filled in for you based on the initial
 thumbnail location and size provided here.","source View : The View that this thumbnail is animating from.  This
defines the coordinate space for startX and startY . |||
thumbnail Bitmap : The bitmap that will be shown as the initial thumbnail
of the animation. |||
startX int : The x starting location of the bitmap relative to source . |||
startY int : The y starting location of the bitmap relative to source . |||","ActivityOptions Returns a new ActivityOptions object that you can use to
 supply these options as the options Bundle when starting an activity. |||",16,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,UI,0,no,no,no,no,
<android.telephony.PhoneNumberFormattingTextWatcher: void afterTextChanged(Editable)>,"This method is called to notify you that somewhere within s the text has been changed.
 It is legitimate to make further changes to s from
 this callback but be careful not to get yourself into an infinite
 loop because any changes you make will cause this method to be
 called again recursively.
 (You are not told where the change took place because other
 afterTextChanged() methods may already have made other changes
 and invalidated the offsets.  But if you need to know here
 you can use Spannable#setSpan in onTextChanged(CharSequence int int int) to mark your place and then look up from here where the span
 ended up.",s Editable |||,void,1,"Watches a  TextView  and if a phone number is entered
 will format it.
  
 Stop formatting when the user
  Inputs non-dialable characters Removes the separator in the middle of string. 
 The formatting will be restarted once the text is cleared.",,no,UI,0,no,no,no,no,
<android.webkit.WebView: void setCertificate(SslCertificate)>,"This method was deprecated
      in API level 17. Calling this function has no useful effect and will be
 ignored in future releases. Sets the SSL certificate for the main top-level page.",certificate SslCertificate |||,void,1,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",no,no,0,no,no,no,no,
<android.view.textservice.SpellCheckerSession: void cancel()>,Cancel pending and running spell check tasks,,void,15,"The SpellCheckerSession interface provides the per client functionality of SpellCheckerService.


  Applications In most cases applications that are using the standard
  TextView  or its subclasses will have little they need
 to do to work well with spell checker services.  The main things you need to
 be aware of are:  Properly set the  R.attr.inputType  in your editable
 text views so that the spell checker will have enough context to help the
 user in editing text in them.
  For the rare people amongst us writing client applications that use the spell checker service
 directly you will need to use  getSuggestions(android.view.textservice.TextInfo int)  or
  getSuggestions(android.view.textservice.TextInfo[] int boolean)  for obtaining results from the spell checker
 service by yourself. Security There are a lot of security issues associated with spell checkers
 since they could monitor all the text being sent to them
 through for instance  TextView .
 The Android spell checker framework also allows
 arbitrary third party spell checkers so care must be taken to restrict their
 selection and interactions. Here are some key points about the security architecture behind the
 spell checker framework: Only the system is allowed to directly access a spell checker framework's
  SpellCheckerService  interface via the
  Manifest.permission.BIND_TEXT_SERVICE  permission.  This is
 enforced in the system by not binding to a spell checker service that does
 not require this permission.

  The user must explicitly enable a new spell checker in settings before
 they can be enabled to confirm with the system that they know about it
 and want to make it available for use.",,no,no,0,no,no,no,no,
"<android.app.Activity: void startIntentSender(IntentSender,Intent,int,int,int,Bundle)>","Like startActivity(android.content.Intent android.os.Bundle) but taking a IntentSender
 to start; see startIntentSenderForResult(android.content.IntentSender int android.content.Intent int int int android.os.Bundle) for more information.","intent IntentSender : The IntentSender to launch. |||
fillInIntent Intent : If non-null this will be provided as the
intent parameter to IntentSender#sendIntent .
This value may be null . |||
flagsMask int : Intent flags in the original IntentSender that you
would like to change. |||
flagsValues int : Desired values for any bits set in flagsMask |||
extraFlags int : Always set to 0. |||
options Bundle : Additional options for how the Activity should be started.
See Context.startActivity(Intent Bundle) Context.startActivity(Intent Bundle)} for more details.  If options
have also been supplied by the IntentSender options given here will
override any that conflict with those given by the IntentSender. |||",void,16,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",IPC data (Intent),IPC,1,no,yes,no,SINK,****IPC and Intent
"<android.widget.Toast: Toast makeText(Context,CharSequence,int)>",Make a standard toast that just contains text.,"context Context : The context to use.  Usually your Application or Activity object. |||
text CharSequence : The text to show.  Can be formatted text. |||
duration int : How long to display the message.  Either LENGTH_SHORT or LENGTH_LONG Value is LENGTH_SHORT or LENGTH_LONG |||",Toast |||,1,"A toast is a view containing a quick little message for the user.  The toast class
 helps you create and show those.
  
 When the view is shown to the user appears as a floating view over the
 application.  It will never receive focus.  The user will probably be in the
 middle of typing something else.  The idea is to be as unobtrusive as
 possible while still showing the user the information you want them to see.
 Two examples are the volume control and the brief message saying that your
 settings have been saved.
  
 The easiest way to use this class is to call one of the static methods that constructs
 everything you need and returns a new Toast object.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",uncategorized,UI,1,no,yes,no,SINK,text to screen a sink?
<android.view.InputDevice: InputDevice getDevice(int)>,Gets information about the input device with the specified id.,id int : The device id. |||,InputDevice The input device or null if not found. |||,9,"Describes the capabilities of a particular input device.
  
 Each input device may support multiple classes of input.  For example a multi-function
 keyboard may compose the capabilities of a standard keyboard together with a track pad mouse
 or other pointing device.
  
 Some input devices present multiple distinguishable sources of input.
 Applications can query the framework about the characteristics of each distinct source.
  
 As a further wrinkle different kinds of input sources uses different coordinate systems
 to describe motion events.  Refer to the comments on the input source constants for
 the appropriate interpretation.",,metadata?,external device?,1,yes,no,SOURCE,no,Not sure about this one 
"<android.app.LocalActivityManager: Window startActivity(String,Intent)>","Start a new activity running in the group.  Every activity you start
 must have a unique string ID associated with it -- this is used to keep
 track of the activity so that if you later call startActivity() again
 on it the same activity object will be retained. When there had previously been an activity started under this id
 it may either be destroyed and a new one started or the current
 one re-used based on these conditions in order: If the Intent maps to a different activity component than is
 currently running the current activity is finished and a new one
 started. 
If the current activity uses a non-multiple launch mode (such
 as singleTop) or the Intent has the Intent#FLAG_ACTIVITY_SINGLE_TOP flag set then the current
 activity will remain running and its Activity#onNewIntent(Intent) method
 called. 
If the new Intent is the same (excluding extras) as the previous
 one and the new Intent does not have the Intent#FLAG_ACTIVITY_CLEAR_TOP set then the current activity
 will remain running as-is. 
Otherwise the current activity will be finished and a new
 one started. 
If the given Intent can not be resolved to an available Activity
 this method throws ActivityNotFoundException . Warning: There is an issue where if the Intent does not
 include an explicit component we can restore the state for a different
 activity class than was previously running when the state was saved (if
 the set of available activities changes between those points).","id String : Unique identifier of the activity to be started |||
intent Intent : The Intent describing the activity to be started |||","Window Returns the window of the activity.  The caller needs to take
 care of adding this window to a view hierarchy and likewise dealing
 with removing the old window if the activity has changed. |||",1,"Helper class for managing multiple running embedded activities in the same
 process. This class is not normally used directly but rather created for
 you as part of the  ActivityGroup  implementation.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",IPC data (Intent),no,0,no,no,no,no,
"<android.content.ContextWrapper: int checkCallingUriPermission(Uri,int)>","Determine whether the calling process and user ID has been
 granted permission to access a specific URI.  This is basically
 the same as calling checkUriPermission(android.net.Uri int int int) with the pid and uid returned by Binder.getCallingPid() and Binder.getCallingUid() .  One important difference is
 that if you are not currently processing an IPC this function
 will always fail.","uri Uri : The uri that is being checked. |||
modeFlags int : The access modes to check.
Value is either 0 or a combination of Intent.FLAG_GRANT_READ_URI_PERMISSION and Intent.FLAG_GRANT_WRITE_URI_PERMISSION |||","int PackageManager#PERMISSION_GRANTED if the caller
 is allowed to access that uri or PackageManager#PERMISSION_DENIED if it is not.

 Value is PackageManager.PERMISSION_GRANTED or PackageManager.PERMISSION_DENIED |||",1,"Proxying implementation of Context that simply delegates all of its calls to
 another Context.  Can be subclassed to modify behavior without changing
 the original Context.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,
<android.service.dreams.DreamService: void onCreate()>,Called when this Dream is constructed.,,void,17,"Extend this class to implement a custom dream (available to the user as a ""Daydream"").

  Dreams are interactive screensavers launched when a charging device is idle or docked in a
 desk dock. Dreams provide another modality for apps to express themselves tailored for
 an exhibition/lean-back experience. The  DreamService  lifecycle is as follows: onAttachedToWindow() Use this for initial setup such as calling  setContentView() . onDreamingStarted() Your dream has started so you should begin animations or other behaviors here. onDreamingStopped() Use this to stop the things you started in  onDreamingStarted() . onDetachedFromWindow() Use this to dismantle resources (for example detach from handlers
        and listeners). In addition onCreate and onDestroy (from the Service interface) will also be called but
 initialization and teardown should be done by overriding the hooks above. To be available to the system your  DreamService  should be declared in the
 manifest as follows: 
 <service
     android:name="".MyDream""
     android:exported=""true""
     android:icon=""@drawable/my_icon""
     android:label=""@string/my_dream_label"" >

     <intent-filter>
         <action android:name=""android.service.dreams.DreamService"" />
         <category android:name=""android.intent.category.DEFAULT"" />
     </intent-filter>

     <!-- Point to additional information for this dream (optional) -->
     <meta-data
         android:name=""android.service.dream""
         android:resource=""@xml/my_dream"" />
 </service>
  If specified with the  <meta-data>  element
 additional information for the dream is defined using the
  <dream>  element in a separate XML file.
 Currently the only addtional
 information you can provide is for a settings activity that allows the user to configure
 the dream behavior. For example: res/xml/my_dream.xml 
 <dream xmlns:android=""http://schemas.android.com/apk/res/android""
     android:settingsActivity=""com.example.app/.MyDreamSettingsActivity"" />
  This makes a Settings button available alongside your dream's listing in the
 system settings which when pressed opens the specified activity. To specify your dream layout call  setContentView(View)  typically during the
  onAttachedToWindow()  callback. For example: 
 public class MyDream extends DreamService {

     @Override
     public void onAttachedToWindow() {
         super.onAttachedToWindow();

         // Exit dream upon user touch
         setInteractive(false);
         // Hide system UI
         setFullscreen(true);
         // Set the dream layout
         setContentView(R.layout.dream);
     }
 }
  When targeting api level 21 and above you must declare the service in your manifest file
 with the  Manifest.permission.BIND_DREAM_SERVICE  permission. For example: 
 <service
     android:name="".MyDream""
     android:exported=""true""
     android:icon=""@drawable/my_icon""
     android:label=""@string/my_dream_label""
     android:permission=""android.permission.BIND_DREAM_SERVICE"">
   <intent-filter>
     <action android:name=”android.service.dreams.DreamService” />
     <category android:name=”android.intent.category.DEFAULT” />
   </intent-filter>
 </service>",,no,no,0,no,no,no,no,
<android.widget.Chronometer: void start()>,"Start counting up.  This does not affect the base as set from setBase(long) just
 the view display.

 Chronometer works by regularly scheduling messages to the handler even when the
 Widget is not visible.  To make sure resource leaks do not occur the user should
 make sure that each start() call has a reciprocal call to stop() .",,void,1,"Class that implements a simple timer.
  
 You can give it a start time in the  SystemClock#elapsedRealtime  timebase
 and it counts up from that or if you don't give it a base time it will use the
 time at which you call  start() .

  The timer can also count downward towards the base time by
 setting  setCountDown(boolean)  to true.

   By default it will display the current
 timer value in the form ""MM:SS"" or ""H:MM:SS"" or you can use  setFormat(String) 
 to format the timer value into an arbitrary string.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,no,0,no,no,no,no,
<android.speech.tts.TextToSpeech: int isLanguageAvailable(Locale)>,Checks if the specified language as represented by the Locale is available and supported.,loc Locale : The Locale describing the language to be used. |||,int Code indicating the support status for the locale. See LANG_AVAILABLE  LANG_COUNTRY_AVAILABLE  LANG_COUNTRY_VAR_AVAILABLE  LANG_MISSING_DATA and LANG_NOT_SUPPORTED . |||,4,"Synthesizes speech from text for immediate playback or to create a sound file.
  A TextToSpeech instance can only be used to synthesize text once it has completed its
 initialization. Implement the  TextToSpeech.OnInitListener  to be
 notified of the completion of the initialization. 
 When you are done using the TextToSpeech instance call the  shutdown()  method
 to release the native resources used by the TextToSpeech engine.",,no,no,0,no,no,no,no,
"<android.text.BoringLayout: void draw(Canvas,Path,Paint,int)>","Draw this Layout on the specified canvas with the highlight path drawn
 between the background and the text.","c Canvas : the canvas |||
highlight Path : the path of the highlight or cursor; can be null |||
highlightpaint Paint : the paint for the highlight |||
cursorOffset int : the amount to temporarily translate the
canvas while rendering the highlight |||",void,1,"A BoringLayout is a very simple Layout implementation for text that
 fits on a single line and is all left-to-right characters.
 You will probably never want to make one of these yourself;
 if you do be sure to call  isBoring(CharSequence TextPaint)  first to make sure
 the text meets the criteria.
  This class is used by widgets to control text layout. You should not need
 to use this class directly unless you are implementing your own widget
 or custom display object in which case
 you are encouraged to use a Layout instead of calling
  Canvas.drawText()  directly.","Provides classes used to render or track text and text spans on the screen. You can use these classes to design your own widgets that manage text
 to handle arbitrary text spans for changes or to handle drawing yourself
 for an existing widget. The Span… interfaces and classes are used to create or manage spans of
 text in a View item. You can use these to style the text or background or to
 listen for changes. If creating your own widget extend DynamicLayout to manages
 the actual wrapping and drawing of your text.",,,0,,,no,no,is a bitmap 'uncategorized' sensitive data?
<android.widget.ListPopupWindow: void setPromptView(View)>,"Set a view to act as a user prompt for this popup window. Where the prompt view will appear
 is controlled by setPromptPosition(int) .","prompt View : View to use as an informational prompt.
This value may be null . |||",void,11,"A ListPopupWindow anchors itself to a host view and displays a
 list of choices.

  ListPopupWindow contains a number of tricky behaviors surrounding
 positioning scrolling parents to fit the dropdown interacting
 sanely with the IME if present and others.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",,,0,,,no,no,I don't know how to deal with this now
"<android.content.pm.ResolveInfo: void writeToParcel(Parcel,int)>",Flatten this object in to a Parcel.,"dest Parcel : The Parcel in which the object should be written. |||
parcelableFlags int : Additional flags about how the object should be written.
May be 0 or Parcelable.PARCELABLE_WRITE_RETURN_VALUE .
Value is either 0 or a combination of Parcelable.PARCELABLE_WRITE_RETURN_VALUE and android.os.Parcelable.PARCELABLE_ELIDE_DUPLICATES |||",void,1,"Information that is returned from resolving an intent
 against an IntentFilter. This partially corresponds to
 information collected from the AndroidManifest.xml's
 <intent> tags.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,IPC,0,no,no,no,no,"I think this is a source, bc it writes to a parameter"
<android.os.Bundle: Serializable getSerializable(String)>,"Returns the value associated with the given key or null if
 no mapping of the desired type exists for the given key or a null
 value is explicitly associated with the key.","key String : a String or null
This value may be null . |||",Serializable a Serializable value or null |||,1,A mapping from String keys to various  Parcelable  values.,,IPC data (Bundle),no,0,no,no,no,no,
<android.database.sqlite.SQLiteDatabase: void setLocale(Locale)>,"Sets the locale for this database.  Does nothing if this database has
 the NO_LOCALIZED_COLLATORS flag set or was opened read only.",locale Locale : The new locale. |||,void,1,"Exposes methods to manage a SQLite database.

  
 SQLiteDatabase has methods to create delete execute SQL commands and
 perform other common database management tasks.
  
 See the Notepad sample application in the SDK for an example of creating
 and managing a database.
  
 Database names must be unique within an application not across all applications.
  Localized Collation - ORDER BY 
 In addition to SQLite's default  BINARY  collator Android supplies
 two more  LOCALIZED  which changes with the system's current locale
 and  UNICODE  which is the Unicode Collation Algorithm and not tailored
 to the current locale.","If you need to manage data in a private database use the  android.database.sqlite  classes. These classes are used to manage the  Cursor  object returned from a content provider query. Databases
 are usually created and opened with  openOrCreateDatabase(String int SQLiteDatabase.CursorFactory) 
 To make requests through
 content providers you can use the  content.ContentResolver  class.
  All databases are stored on the device in  /data/data/<package_name>/databases",location information,database,1,no,yes,no,SINK,
<android.net.wifi.WifiManager: List getScanResults()>,Return the results of the latest access point scan.,,"List < ScanResult > the list of access points found in the most recent scan. An app must hold ACCESS_FINE_LOCATION permission
 in order to get valid results. |||",1,"This class provides the primary API for managing all aspects of Wi-Fi
 connectivity.
  
 On releases before  Build.VERSION_CODES.N  this object
 should only be obtained from an  Context#getApplicationContext()  and not from any other derived context to avoid memory
 leaks within the calling process.
  
 It deals with several categories of items:
  The list of configured networks. The list can be viewed and updated and
 attributes of individual entries can be modified. The currently active Wi-Fi network if any. Connectivity can be
 established or torn down and dynamic information about the state of the
 network can be queried. Results of access point scans containing enough information to make
 decisions about what access point to connect to. It defines the names of various Intent actions that are broadcast upon
 any sort of change in Wi-Fi state.
  
 This is the API to use when performing Wi-Fi specific operations. To perform
 operations that pertain to network connectivity at an abstract level use
  ConnectivityManager .","Provides classes to manage Wi-Fi functionality on the device. The Wi-Fi APIs provide a means by which applications can communicate
 with the lower-level wireless stack that provides Wi-Fi network access. Almost all
 information from the device supplicant is available including the connected network's
 link speed IP address negotiation state and more plus information about other
 networks that are available. Some other API features include the ability to
 scan add save terminate and initiate Wi-Fi connections. Some APIs may require the following user permissions: ACCESS_WIFI_STATE CHANGE_WIFI_STATE CHANGE_WIFI_MULTICAST_STATE Note:  Not all Android-powered devices provide Wi-Fi functionality.
 If your application uses Wi-Fi declare so with a  <uses-feature> 
 element in the manifest file: 
 <manifest ...>
     <uses-feature android:name=""android.hardware.wifi"" />
     ...
 </manifest>",network info,network ,1,yes ,no,SOURCE,no,
<android.net.sip.SipSession: SipProfile getPeerProfile()>,"Gets the SIP profile that this session is connected to. Only available
 when the session is associated with a SIP dialog.",,SipProfile the SIP profile that this session is connected to |||,9,"Represents a SIP session that is associated with a SIP dialog or a standalone
 transaction not within a dialog.
  You can get a  SipSession  from  SipManager  with  SipManager#createSipSession  (when initiating calls) or  SipManager#getSessionFor  (when receiving calls).",,network info,network ,1,yes,no,SOURCE,no,
<android.widget.SlidingDrawer: void open()>,Opens the drawer immediately.,,void,3,"SlidingDrawer hides content out of the screen and allows the user to drag a handle
 to bring the content on screen. SlidingDrawer can be used vertically or horizontally.

 A special widget composed of two children views: the handle that the users drags
 and the content attached to the handle and dragged with it.

 SlidingDrawer should be used as an overlay inside layouts. This means SlidingDrawer
 should only be used inside of a FrameLayout or a RelativeLayout for instance. The
 size of the SlidingDrawer defines how much space the content will occupy once slid
 out so SlidingDrawer should usually use match_parent for both its dimensions.

 Inside an XML layout SlidingDrawer must define the id of the handle and of the
 content:

  
 <SlidingDrawer
     android:id=""@+id/drawer""
     android:layout_width=""match_parent""
     android:layout_height=""match_parent""

     android:handle=""@+id/handle""
     android:content=""@+id/content"">

     <ImageView
         android:id=""@id/handle""
         android:layout_width=""88dip""
         android:layout_height=""44dip"" />

     <GridView
         android:id=""@id/content""
         android:layout_width=""match_parent""
         android:layout_height=""match_parent"" />

 </SlidingDrawer>","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,UI,0,no,no,no,no,
<android.content.res.Resources: String getString(int)>,"Return the string value associated with a particular resource ID.  It
 will be stripped of any styled text information.","id int : The desired resource identifier as generated by the aapt
tool. This integer encodes the package type and resource
entry. The value 0 is an invalid identifier. |||","String String The string data associated with the resource
         stripped of styled text information.
 
 This value will never be null . |||",1,"Class for accessing an application's resources.  This sits on top of the
 asset manager of the application (accessible through  getAssets() ) and
 provides a high-level API for getting typed data from the assets.

  The Android resource system keeps track of all non-code assets associated with an
 application. You can use this class to access your application's resources. You can generally
 acquire the  Resources  instance associated with your application
 with  getResources() . The Android SDK tools compile your application's resources into the application binary
 at build time.  To use a resource you must install it correctly in the source tree (inside
 your project's  res/  directory) and build your application.  As part of the build
 process the SDK tools generate symbols for each resource which you can use in your application
 code to access the resources. Using application resources makes it easy to update various characteristics of your
 application without modifying code and—by providing sets of alternative
 resources—enables you to optimize your application for a variety of device configurations
 (such as for different languages and screen sizes). This is an important aspect of developing
 Android applications that are compatible on different types of devices. For more information about using resources see the documentation about  Application Resources .","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,
<android.widget.MediaController: void onFinishInflate()>,"Finalize inflating a view from XML.  This is called as the last phase
 of inflation after all child views have been added. Even if the subclass overrides onFinishInflate they should always be
 sure to call the super method so that we get called. If you override this method you must call through to the
 superclass implementation.",,void,1,"A view containing controls for a MediaPlayer. Typically contains the
 buttons like ""Play/Pause"" ""Rewind"" ""Fast Forward"" and a progress
 slider. It takes care of synchronizing the controls with the state
 of the MediaPlayer.
  
 The way to use this class is to instantiate it programmatically.
 The MediaController will create a default set of controls
 and put them in a window floating above your application. Specifically
 the controls will float above the view specified with setAnchorView().
 The window will disappear if left idle for three seconds and reappear
 when the user touches the anchor view.
  
 Functions like show() and hide() have no effect when MediaController
 is created in an xml layout.

 MediaController will hide and
 show the buttons according to these rules:
   The ""previous"" and ""next"" buttons are hidden until setPrevNextListeners()
   has been called
   The ""previous"" and ""next"" buttons are visible but disabled if
   setPrevNextListeners() was called with null listeners
   The ""rewind"" and ""fastforward"" buttons are shown unless requested
   otherwise by using the MediaController(Context boolean) constructor
   with the boolean set to false","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,UI,0,no,no,no,no,
<android.content.ContextWrapper: void clearWallpaper()>,This method is deprecated. Use WallpaperManager.clear() instead. This method requires the caller to hold the permission Manifest.permission.SET_WALLPAPER .,,void,1,"Proxying implementation of Context that simply delegates all of its calls to
 another Context.  Can be subclassed to modify behavior without changing
 the original Context.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,UI,0,no,no,no,no,
<android.accessibilityservice.AccessibilityService: IBinder onBind(Intent)>,"Implement to return the implementation of the internal accessibility
 service interface.","intent Intent : The Intent that was used to bind to this service
as given to Context.bindService .  Note that any extras that were included with
the Intent at that point will not be seen here. |||","IBinder Return an IBinder through which clients can call on to the
         service. |||",4,"Accessibility services should only be used to assist users with disabilities in using
 Android devices and apps. They run in the background and receive callbacks by the system
 when  AccessibilityEvent s are fired. Such events denote some state transition
 in the user interface for example the focus has changed a button has been clicked
 etc. Such a service can optionally request the capability for querying the content
 of the active window. Development of an accessibility service requires extending this
 class and implementing its abstract methods.","The classes in this package are used for development of accessibility service that
   provide alternative or augmented feedback to the user.
  
   An  AccessibilityService  runs in the background and
   receives callbacks by the system when  AccessibilityEvent s
   are fired. Such events denote some state transition in the user interface for example the
   focus has changed a button has been clicked etc. Such a service can optionally request the
   capability for querying the content of the active window. Development of an accessibility
   service requires extends this class and implements its abstract methods.
  
   An  AccessibilityServiceInfo  describes an
    AccessibilityService . The system notifies an
   AccessibilityService for  AccessibilityEvent s
   according to the information encapsulated in this class.",uncategorized,IPC,1,no,no,no,no,Ibinder?
<android.database.sqlite.SQLiteDatabase: void setVersion(int)>,Sets the database version.,version int : the new database version |||,void,1,"Exposes methods to manage a SQLite database.

  
 SQLiteDatabase has methods to create delete execute SQL commands and
 perform other common database management tasks.
  
 See the Notepad sample application in the SDK for an example of creating
 and managing a database.
  
 Database names must be unique within an application not across all applications.
  Localized Collation - ORDER BY 
 In addition to SQLite's default  BINARY  collator Android supplies
 two more  LOCALIZED  which changes with the system's current locale
 and  UNICODE  which is the Unicode Collation Algorithm and not tailored
 to the current locale.","If you need to manage data in a private database use the  android.database.sqlite  classes. These classes are used to manage the  Cursor  object returned from a content provider query. Databases
 are usually created and opened with  openOrCreateDatabase(String int SQLiteDatabase.CursorFactory) 
 To make requests through
 content providers you can use the  content.ContentResolver  class.
  All databases are stored on the device in  /data/data/<package_name>/databases",no,database,0,no,no,no,no,
"<android.widget.TextView: void setPaddingRelative(int,int,int,int)>","Sets the relative padding. The view may add on the space required to display
 the scrollbars depending on the style and visibility of the scrollbars.
 So the values returned from getPaddingStart()  getPaddingTop()  getPaddingEnd() and getPaddingBottom() may be different
 from the values set in this call.","start int : the start padding in pixels |||
top int : the top padding in pixels |||
end int : the end padding in pixels |||
bottom int : the bottom padding in pixels |||",void,16,"A user interface element that displays text to the user.
 To provide user-editable text see  EditText .
  
 The following code sample shows a typical use with an XML layout
 and code to modify the contents of the text view:
  
 <LinearLayout
      xmlns:android=""http://schemas.android.com/apk/res/android""
      android:layout_width=""match_parent""
      android:layout_height=""match_parent"">
    <TextView
        android:id=""@+id/text_view_id""
        android:layout_height=""wrap_content""
        android:layout_width=""wrap_content""
        android:text=""@string/hello"" />
 </LinearLayout>
  
 This code sample demonstrates how to modify the contents of the text view
 defined in the previous XML layout:
  
 public class MainActivity extends Activity {

    protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_main);
         final TextView helloTextView = (TextView) findViewById(R.id.text_view_id);
         helloTextView.setText(R.string.user_greeting);
     }
 }
  
 To customize the appearance of TextView see  Styles and Themes .
  XML attributes 
 See  TextView Attributes 
  View Attributes","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,UI,0,no,no,no,no,
<android.widget.TabWidget: void setRightStripDrawable(int)>,"Sets the drawable to use as the right part of the strip below the tab
 indicators. Related XML Attributes: android:tabStripRight","resId int : the resource identifier of the drawable to use as the right
strip drawable |||",void,8,"Displays a list of tab labels representing each page in the parent's tab
 collection.
  
 The container object for this widget is  TabHost .
 When the user selects a tab this object sends a message to the parent
 container TabHost to tell it to switch the displayed page. You typically
 won't use many methods directly on this object. The container TabHost is
 used to add labels add the callback handler and manage callbacks. You
 might call this object to iterate the list of tabs or to tweak the layout
 of the tab list but most methods should be called on the containing TabHost
 object.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,UI,0,no,no,no,no,
"<android.net.wifi.p2p.WifiP2pConfig: void writeToParcel(Parcel,int)>",Implement the Parcelable interface,"dest Parcel : The Parcel in which the object should be written. |||
flags int : Additional flags about how the object should be written.
May be 0 or Parcelable.PARCELABLE_WRITE_RETURN_VALUE .
Value is either 0 or a combination of Parcelable.PARCELABLE_WRITE_RETURN_VALUE and android.os.Parcelable.PARCELABLE_ELIDE_DUPLICATES |||",void,14,A class representing a Wi-Fi P2p configuration for setting up a connection,"Provides classes to create peer-to-peer (P2P) connections with Wi-Fi Direct. Using these APIs you can discover and connect to other devices when each
 device supports Wi-Fi Direct then communicate over a speedy connection across distances much longer
 than a Bluetooth connection. The primary class you need to work with is  WifiP2pManager  which you can acquire by calling  getSystemService(WIFI_P2P_SERVICE) . The  WifiP2pManager  includes APIs that allow you to: Initialize your application for P2P connections by calling  initialize() Discover nearby devices by calling  discoverPeers() Start a P2P connection by calling  connect() And more Several other interfaces and classes are necessary as well such as: The  WifiP2pManager.ActionListener  interface allows you to receive
 callbacks when an operation such as discovering peers or connecting to them succeeds or fails. WifiP2pManager.PeerListListener  interface allows you to receive
 information about discovered peers. The callback provides a  WifiP2pDeviceList  from which you can retrieve a  WifiP2pDevice  object for each device within range and get information such as
 the device name address device type the WPS configurations the device supports and more. The  WifiP2pManager.GroupInfoListener  interface allows you to
 receive information about a P2P group. The callback provides a  WifiP2pGroup  object which provides group information such as the owner the
 network name and passphrase. WifiP2pManager.ConnectionInfoListener  interface allows you to
 receive information about the current connection. The callback provides a  WifiP2pInfo  object which has information such as whether a group has been
 formed and who is the group owner. In order to use the Wi-Fi P2P APIs your app must request the following user permissions: ACCESS_WIFI_STATE CHANGE_WIFI_STATE INTERNET  (although your app doesn’t technically connect
 to the Internet communicating to Wi-Fi Direct peers with standard java sockets requires Internet
 permission). For example code see the  Wi-Fi
 Direct Demo  sample application. Note:  Not all Android-powered devices support Wi-Fi
 Direct. If your application uses Wi-Fi Direct declare so with a  <uses-feature> 
 element in the manifest file: 
 <manifest ...>
     <uses-feature android:name=""android.hardware.wifi.direct"" />
     ...
 </manifest>",IPC,network ,1,no,yes,no,SINK,
<android.view.ViewPropertyAnimator: ViewPropertyAnimator rotationXBy(float)>,"This method will cause the View's rotationX property to be animated by the
 specified value. Animations already running on the property will be canceled.",value float : The amount to be animated by as an offset from the current value. |||,ViewPropertyAnimator This object allowing calls to methods in this class to be chained. |||,12,"This class enables automatic and optimized animation of select properties on View objects.
 If only one or two properties on a View object are being animated then using an
  ObjectAnimator  is fine; the property setters called by ObjectAnimator
 are well equipped to do the right thing to set the property and invalidate the view
 appropriately. But if several properties are animated simultaneously or if you just want a
 more convenient syntax to animate a specific property then ViewPropertyAnimator might be
 more well-suited to the task.

  This class may provide better performance for several simultaneous animations because
 it will optimize invalidate calls to take place only once for several properties instead of each
 animated property independently causing its own invalidation. Also the syntax of using this
 class could be easier to use because the caller need only tell the View object which
 property to animate and the value to animate either to or by and this class handles the
 details of configuring the underlying Animator class and starting it. This class is not constructed by the caller but rather by the View whose properties
 it will animate. Calls to  View.animate()  will return a reference
 to the appropriate ViewPropertyAnimator object for that View.",,no,UI,0,no,no,no,no,
<android.widget.CalendarView: void setSelectedDateVerticalBar(int)>,"This method was deprecated
      in API level 23. No longer used by Material-style CalendarView. Sets the drawable for the vertical bar shown at the beginning and at
 the end of the selected date. Related XML Attributes: android:selectedDateVerticalBar",resourceId int : The vertical bar drawable resource id. |||,void,16,"This class is a calendar widget for displaying and selecting dates. The
 range of dates supported by this calendar is configurable.
  
 The exact appearance and interaction model of this widget may vary between
 OS versions and themes (e.g. Holo versus Material) but in general a user
 can select a date by tapping on it and can scroll or fling the calendar to a
 desired date.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,UI,0,no,no,no,no,
<android.nfc.tech.NfcV: NfcV get(Tag)>,"Get an instance of NfcV for the given tag. Returns null if NfcV was not enumerated in Tag#getTechList .
 This indicates the tag does not support NFC-V. Does not cause any RF activity and does not block.",tag Tag : an NFC-V compatible tag |||,NfcV NFC-V object |||,10,"Provides access to NFC-V (ISO 15693) properties and I/O operations on a  Tag .

  Acquire a  NfcV  object using  get(Tag) .
  The primary NFC-V I/O operation is  transceive(byte[]) . Applications must
 implement their own protocol stack on top of  transceive(byte[]) .

  Note:  Methods that perform I/O operations
 require the  Manifest.permission.NFC  permission.","These classes provide access to a tag technology's features which vary by the type
 of tag that is scanned. A scanned tag can support multiple technologies and you can find
 out what they are by calling  getTechList() . For more information on dealing with tag technologies and handling the ones that you care about see
  The Tag Dispatch System .
 The  TagTechnology  interface provides an overview of the
 supported technologies.",nfc,nfc,1,yes,no,SOURCE,no,
<android.preference.ListPreference: void setEntryValues(int)>,,entryValuesResId int : The entry values array as a resource. |||,void,1,"A  Preference  that displays a list of entries as
 a dialog.
  
 This preference will store a string into the SharedPreferences. This string will be the value
 from the  setEntryValues(java.lang.CharSequence[])  array.",,no,settings,0,no,no,no,no,
"<android.net.sip.SipManager: void open(SipProfile,PendingIntent,SipRegistrationListener)>","Opens the profile for making calls and/or receiving generic SIP calls. The caller may
 make subsequent calls through makeAudioCall(SipProfile SipProfile SipAudioCall.Listener int) . If the
 auto-registration option is enabled in the profile the SIP service
 will register the profile to the corresponding SIP provider periodically
 in order to receive calls from the provider. When the SIP service
 receives a new call it will send out an intent with the provided action
 string. The intent contains a call ID extra and an offer session
 description string extra. Use getCallId(Intent) and getOfferSessionDescription(Intent) to retrieve those extras.","localProfile SipProfile : the SIP profile to receive incoming calls for |||
incomingCallPendingIntent PendingIntent : When an incoming call is received the
SIP service will call PendingIntent#send(Context int Intent) to send back the
intent to the caller with INCOMING_CALL_RESULT_CODE as the
result code and the intent to fill in the call ID and session
description information. It cannot be null. |||
listener SipRegistrationListener : to listen to registration events; can be null |||",void,9,"Provides APIs for SIP tasks such as initiating SIP connections and provides access to related
 SIP services. This class is the starting point for any SIP actions. You can acquire an instance
 of it with  newInstance() . The APIs in this class allows you to: Create a  SipSession  to get ready for making calls or listen for incoming calls. See
  createSipSession()  and  getSessionFor() . Initiate and receive generic SIP calls or audio-only SIP calls. Generic SIP calls may
 be video audio or other and are initiated with  open() . Audio-only SIP calls
 should be handled with a  SipAudioCall  which you can acquire with  makeAudioCall()  and  takeAudioCall() . Register and unregister with a SIP service provider with
       register()  and  unregister() . Verify session connectivity with  isOpened()  and
       isRegistered() . Note:  Not all Android-powered devices support VOIP calls using
 SIP. You should always call  isVoipSupported()  to verify that the device supports VOIP calling and  isApiSupported()  to verify that the device supports
 the SIP APIs. Your application must also request the  Manifest.permission.INTERNET  and  Manifest.permission.USE_SIP 
 permissions.",,IPC,SIP,1,no,no,no,no,good example case
<android.content.res.TypedArray: CharSequence getTextArray(int)>,"Retrieve the CharSequence[] for the attribute at index .
 This gets the resource ID of the selected attribute and uses Resources#getTextArray of the owning
 Resources object to retrieve its String[]. This method will throw an exception if the attribute is defined but is
 not a text array resource.",index int : Index of attribute to retrieve. |||,"CharSequence[] CharSequence[] for the attribute or null if not
         defined. |||",1,"Container for an array of values that were retrieved with
  Resources.Theme#obtainStyledAttributes(AttributeSet int[] int int) 
 or  Resources#obtainAttributes .  Be
 sure to call  recycle()  when done with them.

 The indices used to retrieve values from this structure correspond to
 the positions of the attributes given to obtainStyledAttributes.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,
<android.app.WallpaperManager: void setStream(InputStream)>,"Change the current system wallpaper to a specific byte stream.  The
 give InputStream is copied into persistent storage and will now be
 used as the wallpaper.  Currently it must be either a JPEG or PNG
 image.  On success the intent Intent#ACTION_WALLPAPER_CHANGED is broadcast. This method is equivalent to calling setStream(java.io.InputStream android.graphics.Rect boolean) and passing null for the visibleCrop rectangle and true for the allowBackup parameter. This method requires the caller to hold the permission Manifest.permission.SET_WALLPAPER . Requires Manifest.permission.SET_WALLPAPER","bitmapData InputStream : A stream containing the raw data to install as a wallpaper.  This
data can be in any format handled by BitmapRegionDecoder . |||",void,5,"Provides access to the system wallpaper. With WallpaperManager you can
 get the current wallpaper get the desired dimensions for the wallpaper set
 the wallpaper and more.

   An app can check whether wallpapers are supported for the current user by calling
  isWallpaperSupported()  and whether setting of wallpapers is allowed by calling
  isSetWallpaperAllowed() .","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",uncategorized,UI,1,no,yes,no,SINK,
"<android.accounts.AccountManager: void invalidateAuthToken(String,String)>","Removes an auth token from the AccountManager's cache.  Does nothing if
 the auth token is not currently in the cache.  Applications must call this
 method when the auth token is found to have expired or otherwise become
 invalid for authenticating requests.  The AccountManager does not validate
 or expire cached auth tokens otherwise. It is safe to call this method from the main thread. NOTE: If targeting your app to work on API level 22 and before
 MANAGE_ACCOUNTS or USE_CREDENTIALS permission is needed for those
 platforms. See docs for this function in API level 22. Requires android.Manifest.permission.MANAGE_ACCOUNTS or android.Manifest.permission.USE_CREDENTIALS","accountType String : The account type of the auth token to invalidate must not be null |||
authToken String : The auth token to invalidate may be null |||",void,5,"This class provides access to a centralized registry of the user's
 online accounts.  The user enters credentials (username and password) once
 per account granting applications access to online resources with
 ""one-click"" approval.

  Different online services have different ways of handling accounts and
 authentication so the account manager uses pluggable  authenticator 
 modules for different  account types .  Authenticators (which may be
 written by third parties) handle the actual details of validating account
 credentials and storing account information.  For example Google Facebook
 and Microsoft Exchange each have their own authenticator.

  Many servers support some notion of an  authentication token 
 which can be used to authenticate a request to the server without sending
 the user's actual password.  (Auth tokens are normally created with a
 separate request which does include the user's credentials.)  AccountManager
 can generate auth tokens for applications so the application doesn't need to
 handle passwords directly.  Auth tokens are normally reusable and cached by
 AccountManager but must be refreshed periodically.  It's the responsibility
 of applications to  invalidate  auth tokens when they stop working so
 the AccountManager knows it needs to regenerate them.

  Applications accessing a server normally go through these steps:

  Get an instance of AccountManager using  get(android.content.Context) .

  List the available accounts using  getAccountsByType(String)  or
  getAccountsByTypeAndFeatures(String String[] AccountManagerCallback  Handler) .  Normally applications will only
 be interested in accounts with one particular  type  which
 identifies the authenticator.  Account  features  are used to
 identify particular account subtypes and capabilities.  Both the account
 type and features are authenticator-specific strings and must be known by
 the application in coordination with its preferred authenticators.

  Select one or more of the available accounts possibly by asking the
 user for their preference.  If no suitable accounts are available
  addAccount(String String String[] Bundle Activity AccountManagerCallback  Handler)  may be called to prompt the user to create an
 account of the appropriate type.

  Important:  If the application is using a previously remembered
 account selection it must make sure the account is still in the list
 of accounts returned by  getAccountsByType(String) .  Requesting an auth token
 for an account no longer on the device results in an undefined failure.

  Request an auth token for the selected account(s) using one of the
  getAuthToken(Account String Bundle Activity AccountManagerCallback  Handler)  methods or related helpers.  Refer to the description
 of each method for exact usage and error handling details.

  Make the request using the auth token.  The form of the auth token
 the format of the request and the protocol used are all specific to the
 service you are accessing.  The application may use whatever network and
 protocol libraries are useful.

  Important:  If the request fails with an authentication error
 it could be that a cached auth token is stale and no longer honored by
 the server.  The application must call  invalidateAuthToken(String String)  to remove
 the token from the cache otherwise requests will continue failing!  After
 invalidating the auth token immediately go back to the ""Request an auth
 token"" step above.  If the process fails the second time then it can be
 treated as a ""genuine"" authentication failure and the user notified or other
 appropriate actions taken.
  Some AccountManager methods may need to interact with the user to
 prompt for credentials present options or ask the user to add an account.
 The caller may choose whether to allow AccountManager to directly launch the
 necessary user interface and wait for the user or to return an Intent which
 the caller may use to launch the interface or (in some cases) to install a
 notification which the user can select at any time to launch the interface.
 To have AccountManager launch the interface directly the caller must supply
 the current foreground  Activity  context.

  Many AccountManager methods take  AccountManagerCallback  and
  Handler  as parameters.  These methods return immediately and
 run asynchronously. If a callback is provided then
  AccountManagerCallback#run  will be invoked on the Handler's
 thread when the request completes successfully or not.
 The result is retrieved by calling  AccountManagerFuture#getResult() 
 on the  AccountManagerFuture  returned by the method (and also passed
 to the callback).  This method waits for the operation to complete (if
 necessary) and either returns the result or throws an exception if an error
 occurred during the operation.  To make the request synchronously call
  AccountManagerFuture#getResult()  immediately on receiving the
 future from the method; no callback need be supplied.

  Requests which may block including
  AccountManagerFuture#getResult()  must never be called on
 the application's main event thread.  These operations throw
  IllegalStateException  if they are used on the main thread.",,No,ACCOUNT,0,no,no,no,no,
"<android.app.Activity: void startActivityForResult(Intent,int,Bundle)>","Launch an activity for which you would like a result when it finished.
 When this activity exits your
 onActivityResult() method will be called with the given requestCode.
 Using a negative requestCode is the same as calling startActivity(Intent) (the activity is not launched as a sub-activity). Note that this method should only be used with Intent protocols
 that are defined to return a result.  In other protocols (such as Intent#ACTION_MAIN or Intent#ACTION_VIEW ) you may
 not get the result when you expect.  For example if the activity you
 are launching uses Intent#FLAG_ACTIVITY_NEW_TASK it will not
 run in your task and thus you will immediately receive a cancel result. As a special case if you call startActivityForResult() with a requestCode
 >= 0 during the initial onCreate(Bundle savedInstanceState)/onResume() of your
 activity then your window will not be displayed until a result is
 returned back from the started activity.  This is to avoid visible
 flickering when redirecting to another activity. This method throws ActivityNotFoundException if there was no Activity found to run the given Intent.","intent Intent : The intent to start. |||
requestCode int : If >= 0 this code will be returned in
onActivityResult() when the activity exits. |||
options Bundle : Additional options for how the Activity should be started.
See Context.startActivity(Intent Bundle) Context.startActivity(Intent Bundle)} for more details.
This value may be null . |||",void,16,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",IPC,IPC,1,no,yes,no,SINK,
<android.widget.CheckedTextView: void setCheckMarkDrawable(int)>,Sets the check mark to the drawable with the specified resource ID. When this view is checked the drawable's state set will include R.attr.state_checked . Related XML Attributes: android:checkMark,"resId int : the resource identifier of drawable to use as the check
mark |||",void,1,"An extension to  TextView  that supports the  Checkable 
 interface and displays.
  
 This is useful when used in a  ListView  where
 the  setChoiceMode  has
 been set to something other than
  CHOICE_MODE_NONE .","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",uncategorized,UI,1,no,no,no,no,
<android.app.ActivityManager: void killBackgroundProcesses(String)>,"Have the system immediately kill all background processes associated
 with the given package.  This is the same as the kernel killing those
 processes to reclaim memory; the system will take care of restarting
 these processes in the future as needed. Requires Manifest.permission.KILL_BACKGROUND_PROCESSES","packageName String : The name of the package whose processes are to
be killed. |||",void,8,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",uncategorized,IPC,1,no,no,no,no,
"<android.os.Bundle: void putParcelableArray(String,Parcelable)>","Inserts an array of Parcelable values into the mapping of this Bundle
 replacing any existing value for the given key.  Either key or value may
 be null.","key String : a String or null
This value may be null . |||
value Parcelable : an array of Parcelable objects or null
This value may be null . |||",void,1,A mapping from String keys to various  Parcelable  values.,,no,no,0,no,no,no,no,
<android.content.AsyncQueryHandler: void handleMessage(Message)>,Subclasses must implement this to receive messages.,msg Message : This value must never be null . |||,void,1,"A helper class to help make handling asynchronous  ContentResolver 
 queries easier.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",uncategorized,database,1,no,no ,no,SINK,How to handle abstract methods?
<android.content.ContentProviderClient: ContentProviderResult applyBatch(ArrayList)>,See ContentProvider#applyBatch,operations ArrayList : This value must never be null . |||,ContentProviderResult[] This value will never be null . |||,5,"Content providers are one of the primary building blocks of Android applications providing
 content to applications. They encapsulate data and provide it to applications through the single
  ContentResolver  interface. A content provider is only required if you need to share
 data between multiple applications. For example the contacts data is used by multiple
 applications and must be stored in a content provider. If you don't need to share data amongst
 multiple applications you can use a database directly via
  SQLiteDatabase .

  When a request is made via
 a  ContentResolver  the system inspects the authority of the given URI and passes the
 request to the content provider registered with the authority. The content provider can interpret
 the rest of the URI however it wants. The  UriMatcher  class is helpful for parsing
 URIs. The primary methods that need to be implemented are:
  onCreate()  which is called to initialize the provider query(Uri String[] Bundle CancellationSignal)  which returns data to the caller insert(Uri ContentValues)  which inserts new data into the content provider update(Uri ContentValues String String[])  which updates existing data in the content provider delete(Uri String String[])  which deletes data from the content provider getType(Uri)  which returns the MIME type of data in the content provider Requests to  ContentResolver  are automatically forwarded to the appropriate
 ContentProvider instance so subclasses don't have to worry about the details of
 cross-process calls.b ","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",uncategorized,database,1,yes,no,no,no,
<android.bluetooth.BluetoothA2dp: List getDevicesMatchingConnectionStates(int)>,"Get a list of devices that match any of the given connection
 states. If none of the devices match any of the given states
 an empty list will be returned. Requires Manifest.permission.BLUETOOTH",states int : Array of states. States can be one of BluetoothProfile.STATE_CONNECTED  BluetoothProfile.STATE_CONNECTING  BluetoothProfile.STATE_DISCONNECTED  BluetoothProfile.STATE_DISCONNECTING  |||,List < BluetoothDevice > List of devices. The list will be empty on error. |||,11,"This class provides the public APIs to control the Bluetooth A2DP
 profile.

  BluetoothA2dp is a proxy object for controlling the Bluetooth A2DP
 Service via IPC. Use  BluetoothAdapter#getProfileProxy  to get
 the BluetoothA2dp proxy object.

   Android only supports one connected Bluetooth A2dp device at a time.
 Each method is protected with its appropriate permission.","Provides classes that manage Bluetooth functionality such as scanning for
 devices connecting with devices and managing data transfer between devices.
 The Bluetooth API supports both ""Classic Bluetooth"" and Bluetooth Low Energy. For more information about Classic Bluetooth see the
  Bluetooth  guide.
 For more information about Bluetooth Low Energy see the
  
 Bluetooth Low Energy  (BLE) guide. The Bluetooth APIs let applications: Scan for other Bluetooth devices (including BLE devices). Query the local Bluetooth adapter for paired Bluetooth devices. Establish RFCOMM channels/sockets. Connect to specified sockets on other devices. Transfer data to and from other devices. Communicate with BLE devices such as proximity sensors heart rate
     monitors fitness devices and so on. Act as a GATT client or a GATT server (BLE). 
 To perform Bluetooth communication using these APIs an application must
 declare the  BLUETOOTH  permission. Some
 additional functionality such as requesting device discovery
 also requires the  BLUETOOTH_ADMIN 
 permission.
  Note: 
 Not all Android-powered devices provide Bluetooth functionality.",bluetooth,bluetooth,1,,,no,no,Returning the shared resource is sensitive data?
<android.app.admin.DeviceAdminInfo: CharSequence loadLabel(PackageManager)>,Load the user-displayed label for this device admin.,"pm PackageManager : Supply a PackageManager used to load the device admin's
resources. |||",CharSequence |||,8,"This class is used to specify meta information of a device administrator
 component.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,not sure
<android.bluetooth.BluetoothHealth: List getDevicesMatchingConnectionStates(int)>,"Get a list of devices that match any of the given connection
 states. If none of the devices match any of the given states
 an empty list will be returned. Requires Manifest.permission.BLUETOOTH permission.
 This is not specific to any application configuration but represents the connection
 state of the local Bluetooth adapter for this profile. This can be used
 by applications like status bar which would just like to know the state of the
 local adapter.",states int : Array of states. States can be one of BluetoothProfile.STATE_CONNECTED  BluetoothProfile.STATE_CONNECTING  BluetoothProfile.STATE_DISCONNECTED  BluetoothProfile.STATE_DISCONNECTING  |||,List < BluetoothDevice > List of devices. The list will be empty on error. |||,14,"Public API for Bluetooth Health Profile.

  BluetoothHealth is a proxy object for controlling the Bluetooth
 Service via IPC.

   How to connect to a health device which is acting in the source role.
   Use  BluetoothAdapter#getProfileProxy  to get
 the BluetoothHealth proxy object.   Create an  BluetoothHealth  callback and call
  registerSinkAppConfiguration(String int BluetoothHealthCallback)  to register an application
 configuration   Pair with the remote device. This currently needs to be done manually
 from Bluetooth Settings   Connect to a health device using  connectChannelToSource(BluetoothDevice BluetoothHealthAppConfiguration) . Some
 devices will connect the channel automatically. The  BluetoothHealth 
 callback will inform the application of channel state change.   Use the file descriptor provided with a connected channel to read and
 write data to the health channel.   The received data needs to be interpreted using a health manager which
 implements the IEEE 11073-xxxxx specifications.
   When done close the health channel by calling  disconnectChannel(BluetoothDevice BluetoothHealthAppConfiguration int) 
 and unregister the application configuration calling
  unregisterAppConfiguration(BluetoothHealthAppConfiguration)","Provides classes that manage Bluetooth functionality such as scanning for
 devices connecting with devices and managing data transfer between devices.
 The Bluetooth API supports both ""Classic Bluetooth"" and Bluetooth Low Energy. For more information about Classic Bluetooth see the
  Bluetooth  guide.
 For more information about Bluetooth Low Energy see the
  
 Bluetooth Low Energy  (BLE) guide. The Bluetooth APIs let applications: Scan for other Bluetooth devices (including BLE devices). Query the local Bluetooth adapter for paired Bluetooth devices. Establish RFCOMM channels/sockets. Connect to specified sockets on other devices. Transfer data to and from other devices. Communicate with BLE devices such as proximity sensors heart rate
     monitors fitness devices and so on. Act as a GATT client or a GATT server (BLE). 
 To perform Bluetooth communication using these APIs an application must
 declare the  BLUETOOTH  permission. Some
 additional functionality such as requesting device discovery
 also requires the  BLUETOOTH_ADMIN 
 permission.
  Note: 
 Not all Android-powered devices provide Bluetooth functionality.",bluetooth,bluetooth,,yes,no,no,no,not sure
<android.location.LocationManager: Location getLastKnownLocation(String)>,"Gets the last known location from the given provider or null if there is no last known
 location. The returned location may be quite old in some circumstances so the age of the
 location should always be checked. This will never activate sensors to compute a new location and will only ever return a
 cached location. See also getCurrentLocation(java.lang.String android.os.CancellationSignal java.util.concurrent.Executor java.util.function.Consumer) which
 will always attempt to return a current location but will potentially use additional power
 in the course of the attempt as compared to this method. Requires Manifest.permission.ACCESS_COARSE_LOCATION or Manifest.permission.ACCESS_FINE_LOCATION",provider String : a provider listed by getAllProviders() This value must never be null . |||,Location the last known location for the given provider or null if not available |||,1,"A data class representing a geographic location.

  A location can consist of a latitude longitude timestamp
 and other information such as bearing altitude and velocity.

  All locations generated by the  LocationManager  are
 guaranteed to have a valid latitude longitude and timestamp
 (both UTC time and elapsed real-time since boot) all other
 parameters are optional.","Contains the framework API classes that define Android location-based and
 	related services. This API is not the recommended method for accessing Android location. 
 The
  Google Location Services API 
 part of Google Play services is the preferred way to add location-awareness to
 your app. It offers a simpler API higher accuracy low-power geofencing and
 more. If you are currently using the android.location API you are strongly
 encouraged to switch to the Google Location Services API as soon as
 possible.
  
 To learn more about the Google Location Services API see the
  Location API overview .",location information,Sensors,1,yes,no,SOURCE,no,good example case
<android.view.ViewPropertyAnimator: ViewPropertyAnimator alphaBy(float)>,"This method will cause the View's alpha property to be animated by the
 specified value. Animations already running on the property will be canceled.",value float : The amount to be animated by as an offset from the current value. |||,ViewPropertyAnimator This object allowing calls to methods in this class to be chained. |||,12,"This class enables automatic and optimized animation of select properties on View objects.
 If only one or two properties on a View object are being animated then using an
  ObjectAnimator  is fine; the property setters called by ObjectAnimator
 are well equipped to do the right thing to set the property and invalidate the view
 appropriately. But if several properties are animated simultaneously or if you just want a
 more convenient syntax to animate a specific property then ViewPropertyAnimator might be
 more well-suited to the task.

  This class may provide better performance for several simultaneous animations because
  it will optimize invalidate calls to take place only once for several properties instead of each
 animated property independently causing its own invalidation. Also the syntax of using this
 class could be easier to use because the caller need only tell the View object which
 property to animate and the value to animate either to or by and this class handles the
 details of configuring the underlying Animator class and starting it. This class is not constructed by the caller but rather by the View whose properties
 it will animate. Calls to  View.animate()  will return a reference
 to the appropriate ViewPropertyAnimator object for that View.",,uncategorized,UI,1,no,yes,no,SINK,
<android.app.Activity: ActionBar getActionBar()>,Retrieve a reference to this activity's ActionBar.,,ActionBar The Activity's ActionBar or null if it does not have one. |||,11,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,UI,0,no,no,no,no,
<android.drm.DrmManagerClient: void release()>,"This method was deprecated
      in API level 24. replaced by close() .",,void,16,"The main programming interface for the DRM framework. An application must instantiate this class
 to access DRM agents through the DRM framework.","Provides classes for managing DRM content and determining the capabilities of DRM plugins
 (agents). Common uses of the DRM API include: Determining which DRM plug-ins (agents) are installed on a device. Retrieving information about specific plug-ins such as the MIME types and file suffixes
   they support. Registering a user or a device with an online DRM service. Retrieving license constraints for rights-protected content. Checking whether a user has the proper rights to play or use rights-protected
   content. Associating rights-protected content with its license so you can use the
    MediaPlayer  API to play the content.",no,no,0,no,no,no,no,
<android.app.ActivityManager: PendingIntent getRunningServiceControlPanel(ComponentName)>,"Returns a PendingIntent you can start to show a control panel for the
 given running service.  If the service does not have a control panel
 null is returned.",service ComponentName |||,PendingIntent |||,5,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,not sure 
<android.app.WallpaperManager: Drawable peekFastDrawable()>,"Like getFastDrawable() but if there is no wallpaper set
 a null pointer is returned. Requires Manifest.permission.READ_EXTERNAL_STORAGE",,"Drawable Returns an optimized Drawable object that will draw the
 wallpaper or a null pointer if these is none. |||",5,"Provides access to the system wallpaper. With WallpaperManager you can
 get the current wallpaper get the desired dimensions for the wallpaper set
 the wallpaper and more.

   An app can check whether wallpapers are supported for the current user by calling
  isWallpaperSupported()  and whether setting of wallpapers is allowed by calling
  isSetWallpaperAllowed() .","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",image data,UI,1,yes,no,SOURCE,no,
"<android.widget.TextView: int getOffsetForPosition(float,float)>","Get the character offset closest to the specified absolute position. A typical use case is to
 pass the result of MotionEvent#getX() and MotionEvent#getY() to this method.","x float : The horizontal absolute position of a point on screen |||
y float : The vertical absolute position of a point on screen |||","int the character offset for the character whose position is closest to the specified
  position. Returns -1 if there is no layout. |||",14,"A user interface element that displays text to the user.
 To provide user-editable text see  EditText .
  
 The following code sample shows a typical use with an XML layout
 and code to modify the contents of the text view:
  
 <LinearLayout
      xmlns:android=""http://schemas.android.com/apk/res/android""
      android:layout_width=""match_parent""
      android:layout_height=""match_parent"">
    <TextView
        android:id=""@+id/text_view_id""
        android:layout_height=""wrap_content""
        android:layout_width=""wrap_content""
        android:text=""@string/hello"" />
 </LinearLayout>
  
 This code sample demonstrates how to modify the contents of the text view
 defined in the previous XML layout:
  
 public class MainActivity extends Activity {

    protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_main);
         final TextView helloTextView = (TextView) findViewById(R.id.text_view_id);
         helloTextView.setText(R.string.user_greeting);
     }
 }
  
 To customize the appearance of TextView see  Styles and Themes .
  XML attributes 
 See  TextView Attributes 
  View Attributes","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,UI,0,no,no,no,no,
<android.widget.TextView: void setExtractedText(ExtractedText)>,"Apply to this text view the given extracted text as previously
 returned by extractText(android.view.inputmethod.ExtractedTextRequest android.view.inputmethod.ExtractedText) .",text ExtractedText |||,void,3,"A user interface element that displays text to the user.
 To provide user-editable text see  EditText .
  
 The following code sample shows a typical use with an XML layout
 and code to modify the contents of the text view:
  
 <LinearLayout
      xmlns:android=""http://schemas.android.com/apk/res/android""
      android:layout_width=""match_parent""
      android:layout_height=""match_parent"">
    <TextView
        android:id=""@+id/text_view_id""
        android:layout_height=""wrap_content""
        android:layout_width=""wrap_content""
        android:text=""@string/hello"" />
 </LinearLayout>
  
 This code sample demonstrates how to modify the contents of the text view
 defined in the previous XML layout:
  
 public class MainActivity extends Activity {

    protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_main);
         final TextView helloTextView = (TextView) findViewById(R.id.text_view_id);
         helloTextView.setText(R.string.user_greeting);
     }
 }
  
 To customize the appearance of TextView see  Styles and Themes .
  XML attributes 
 See  TextView Attributes 
  View Attributes","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",uncategorized,UI,1,no,yes,no,SINK,
<android.widget.ArrayAdapter: void addAll(Collection)>,Adds the specified Collection at the end of the array.,"collection Collection : The Collection to add at the end of the array.
This value must never be null . |||",void,11,"You can use this adapter to provide views for an  AdapterView 
 Returns a view for each object in a collection of data objects you
 provide and can be used with list-based user interface widgets such as
  ListView  or  Spinner .
  
 By default the array adapter creates a view by calling  Object#toString()  on each
 data object in the collection you provide and places the result in a TextView.
 You may also customize what type of view is used for the data object in the collection.
 To customize what type of view is used for the data object
 override  getView(int android.view.View android.view.ViewGroup) 
 and inflate a view resource.
 For a code example see
 the  
 CustomChoiceList  sample.
  
 For an example of using an array adapter with a ListView see the
  
 Adapter Views  guide.
  
 For an example of using an array adapter with a Spinner see the
  Spinners  guide.
  Note: 
 If you are considering using array adapter with a ListView consider using
  RecyclerView  instead.
 RecyclerView offers similar features with better performance and more flexibility than
 ListView provides.
 See the
  
 Recycler View  guide.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,no,0,no,no,no,no,
<android.widget.NumberPicker: void setValue(int)>,"Set the current value for the number picker. If the argument is less than the NumberPicker#getMinValue() and NumberPicker#getWrapSelectorWheel() is false the
 current value is set to the NumberPicker#getMinValue() value. If the argument is less than the NumberPicker#getMinValue() and NumberPicker#getWrapSelectorWheel() is true the
 current value is set to the NumberPicker#getMaxValue() value. If the argument is more than the NumberPicker#getMaxValue() and NumberPicker#getWrapSelectorWheel() is false the
 current value is set to the NumberPicker#getMaxValue() value. If the argument is more than the NumberPicker#getMaxValue() and NumberPicker#getWrapSelectorWheel() is true the
 current value is set to the NumberPicker#getMinValue() value.",value int : The current value. |||,void,11,"A widget that enables the user to select a number from a predefined range.
 There are two flavors of this widget and which one is presented to the user
 depends on the current theme.
  
 If the current theme is derived from  R.style.Theme  the widget
 presents the current value as an editable input field with an increment button
 above and a decrement button below. Long pressing the buttons allows for a quick
 change of the current value. Tapping on the input field allows to type in
 a desired value.
  
 If the current theme is derived from  R.style.Theme_Holo  or
  R.style.Theme_Holo_Light  the widget presents the current
 value as an editable input field with a lesser value above and a greater
 value below. Tapping on the lesser or greater value selects it by animating
 the number axis up or down to make the chosen value current. Flinging up
 or down allows for multiple increments or decrements of the current value.
 Long pressing on the lesser and greater values also allows for a quick change
 of the current value. Tapping on the current value allows to type in a
 desired value.
  
 If the current theme is derived from  R.style.Theme_Material 
 the widget presents the current value as a scrolling vertical selector with
 the selected value in the center and the previous and following numbers above
 and below separated by a divider. The value is changed by flinging vertically.
 The thickness of the divider can be changed by using the
  R.attr.selectionDividerHeight  attribute and the color of the
 divider can be changed by using the
  R.attr.colorControlNormal  attribute.
  
 For an example of using this widget see  TimePicker .","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,no,0,no,no,no,no,
"<android.view.textservice.SpellCheckerSubtype: CharSequence getDisplayName(Context,String,ApplicationInfo)>",,"context Context : Context will be used for getting Locale and PackageManager. |||
packageName String : The package name of the spell checker |||
appInfo ApplicationInfo : The application info of the spell checker |||","CharSequence a display name for this subtype. The string resource of the label (mSubtypeNameResId)
 can have only one %s in it. If there is the %s part will be replaced with the locale's
 display name by the formatter. If there is not this method simply returns the string
 specified by mSubtypeNameResId. If mSubtypeNameResId is not specified (== 0) it's up to the
 framework to generate an appropriate display name. |||",14,"This class is used to specify meta information of a subtype contained in a spell checker.
 Subtype can describe locale (e.g. en_US fr_FR...) used for settings.",,no,no,0,no,no,no,no,
"<android.location.LocationManager: void requestSingleUpdate(Criteria,LocationListener,Looper)>","This method was deprecated
      in API level R. Use getCurrentLocation(java.lang.String android.os.CancellationSignal java.util.concurrent.Executor java.util.function.Consumer) instead as it does not carry a risk of extreme battery drain. Register for a single location update using a Criteria and a callback. See requestLocationUpdates(long float android.location.Criteria android.app.PendingIntent) for more detail
 on how to use this method. Requires Manifest.permission.ACCESS_COARSE_LOCATION or Manifest.permission.ACCESS_FINE_LOCATION","criteria Criteria : contains parameters to choose the appropriate provider for location updates
This value must never be null . |||
listener LocationListener : the listener to receive location updates
This value must never be null . |||
looper Looper : the looper handling listener callbacks or null to use the looper of the
calling thread
This value may be null . |||",void,9,"A data class representing a geographic location.

  A location can consist of a latitude longitude timestamp
 and other information such as bearing altitude and velocity.

  All locations generated by the  LocationManager  are
 guaranteed to have a valid latitude longitude and timestamp
 (both UTC time and elapsed real-time since boot) all other
 parameters are optional.","Contains the framework API classes that define Android location-based and
 	related services. This API is not the recommended method for accessing Android location. 
 The
  Google Location Services API 
 part of Google Play services is the preferred way to add location-awareness to
 your app. It offers a simpler API higher accuracy low-power geofencing and
 more. If you are currently using the android.location API you are strongly
 encouraged to switch to the Google Location Services API as soon as
 possible.
  
 To learn more about the Google Location Services API see the
  Location API overview .",location information,Sensors,1,yes,no,SOURCE,no,example of source with no return value
<android.text.method.CharacterPickerDialog: void onClick(View)>,Handles clicks on the Cancel button.,v View : The view that was clicked. |||,void,1,Dialog for choosing accented characters related to a base character.,"Provides classes that monitor or modify keypad input. You can use these classes to modify the type of keypad entry
 for your application or decipher the keypresses entered for your specific
 entry method. For example: 
 // Set the text to password display style:
 EditText txtView = (EditText)findViewById(R.id.text);
 txtView.setTransformationMethod(PasswordTransformationMethod.getInstance());

 //Set the input style to numbers rather than qwerty keyboard style.
 txtView.setInputMethod(DigitsInputMethod.getInstance());

 // Find out whether the caps lock is on.
 // 0 is no 1 is yes 2 is caps lock on.
 int active = MultiTapInputMethod.getCapsActive(txtView.getText());",no,no,0,no,no,no,no,
"<android.webkit.WebView: void postUrl(String,byte)>","Loads the URL with postData using ""POST"" method into this WebView. If url
 is not a network URL it will be loaded with loadUrl(java.lang.String) instead ignoring the postData param.","url String : the URL of the resource to load
This value must never be null . |||
postData byte : the data will be passed to ""POST"" request which must be
be ""application/x-www-form-urlencoded"" encoded.
This value must never be null . |||",void,5,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",no,UI,0,no,no,no,no,
<android.app.Activity: MenuInflater getMenuInflater()>,Returns a MenuInflater with this context.,,MenuInflater This value will never be null . |||,1,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
<android.widget.TimePicker: void setCurrentHour(Integer)>,"This method was deprecated
      in API level 23. Use setHour(int) Sets the currently selected hour using 24-hour time.","currentHour Integer : the hour to set in the range (0-23)
This value must never be null . |||",void,1,"A widget for selecting the time of day in either 24-hour or AM/PM mode.
  
 For a dialog using this view see  TimePickerDialog . See
 the  Pickers 
 guide for more information.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,no,0,no,no,no,no,
<android.app.NotificationManager: void cancelAll()>,"Cancel all previously shown notifications. See cancel(int) for the
 detailed behavior.",,void,1,"A class that represents how a persistent notification is to be presented to
 the user using the  NotificationManager .

  The  Notification.Builder  has been added to make it
 easier to construct Notifications.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,UI,0,no,no,no,no,
<android.view.View: void setImportantForAccessibility(int)>,"Sets how to determine whether this view is important for accessibility
 which is if it fires accessibility events and if it is reported to
 accessibility services that query the screen. Related XML Attributes: android:importantForAccessibility",mode int : How to determine whether this view is important for accessibility. |||,void,16,"This class represents the basic building block for user interface components. A View
 occupies a rectangular area on the screen and is responsible for drawing and
 event handling. View is the base class for  widgets  which are
 used to create interactive UI components (buttons text fields etc.). The
  ViewGroup  subclass is the base class for  layouts  which
 are invisible containers that hold other Views (or other ViewGroups) and define
 their layout properties.",,,,0,,,no,no,
"<android.content.Intent: Intent putExtra(String,long)>","Add extended data to the intent.  The name must include a package
 prefix for example the app com.android.contacts would use names
 like ""com.android.contacts.ShowAll"".","name String : The name of the extra data with package prefix. |||
value long : The long data value. |||","Intent Returns the same Intent object for chaining multiple calls
 into a single statement.

 This value will never be null . |||",1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,
<android.text.SpannableStringBuilder: void clearSpans()>,Removes all spans from the Editable as if by calling Spannable.removeSpan(Object) on each of them.,,void,1,"This is the class for text whose content is immutable but to which
 markup objects can be attached and detached.
 For mutable text see  SpannableStringBuilder .","Provides classes used to render or track text and text spans on the screen. You can use these classes to design your own widgets that manage text
 to handle arbitrary text spans for changes or to handle drawing yourself
 for an existing widget. The Span… interfaces and classes are used to create or manage spans of
 text in a View item. You can use these to style the text or background or to
 listen for changes. If creating your own widget extend DynamicLayout to manages
 the actual wrapping and drawing of your text.",no,no,0,no,no,no,no,
"<android.text.method.PasswordTransformationMethod: void onTextChanged(CharSequence,int,int,int)>","This method is called to notify you that within s the count characters beginning at start have just replaced old text that had length before .
 It is an error to attempt to make changes to s from
 this callback.","s CharSequence |||
start int |||
before int |||
count int |||",void,1,,"Provides classes that monitor or modify keypad input. You can use these classes to modify the type of keypad entry
 for your application or decipher the keypresses entered for your specific
 entry method. For example: 
 // Set the text to password display style:
 EditText txtView = (EditText)findViewById(R.id.text);
 txtView.setTransformationMethod(PasswordTransformationMethod.getInstance());

 //Set the input style to numbers rather than qwerty keyboard style.
 txtView.setInputMethod(DigitsInputMethod.getInstance());

 // Find out whether the caps lock is on.
 // 0 is no 1 is yes 2 is caps lock on.
 int active = MultiTapInputMethod.getCapsActive(txtView.getText());",password,callback,1,no,yes,no,SINK,not sure. 
"<android.widget.SimpleAdapter: View getView(int,View,ViewGroup)>","Get a View that displays the data at the specified position in the data set. You can either
 create a View manually or inflate it from an XML layout file. When the View is inflated the
 parent View (GridView ListView...) will apply default layout parameters unless you use LayoutInflater.inflate(int android.view.ViewGroup boolean) to specify a root view and to prevent attachment to the root.","position int : The position of the item within the adapter's data set of the item whose view
we want. |||
convertView View : The old view to reuse if possible. Note: You should check that this view
is non-null and of an appropriate type before using. If it is not possible to convert
this view to display the correct data this method can create a new view.
Heterogeneous lists can specify their number of view types so that this View is
always of the right type (see BaseAdapter.getViewTypeCount() and BaseAdapter.getItemViewType(int) ). |||
parent ViewGroup : The parent that this view will eventually be attached to |||",View A View corresponding to the data at the specified position. |||,1,"An easy adapter to map static data to views defined in an XML file. You can specify the data
 backing the list as an ArrayList of Maps. Each entry in the ArrayList corresponds to one row
 in the list. The Maps contain the data for each row. You also specify an XML file that
 defines the views used to display the row and a mapping from keys in the Map to specific
 views.

 Binding data to views occurs in two phases. First if a
  SimpleAdapter.ViewBinder  is available
  ViewBinder#setViewValue(android.view.View Object String) 
 is invoked. If the returned value is true binding has occurred.
 If the returned value is false the following views are then tried in order:
   A view that implements Checkable (e.g. CheckBox).  The expected bind value is a boolean.
   TextView.  The expected bind value is a string and  setViewText(android.widget.TextView java.lang.String) 
 is invoked.
   ImageView. The expected bind value is a resource id or a string and
  setViewImage(android.widget.ImageView int)  or  setViewImage(android.widget.ImageView java.lang.String)  is invoked.
  IllegalStateException","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,no,0,no,no,no,no,
<android.speech.tts.TextToSpeech: Locale getLanguage()>,"This method was deprecated
      in API level 21. As of API level 21 please use getVoice().getLocale() ( getVoice() ). Returns a Locale instance describing the language currently being used for synthesis
 requests sent to the TextToSpeech engine.

 In Android 4.2 and before (API <= 17) this function returns the language that is currently
 being used by the TTS engine. That is the last language set by this or any other
 client by a TextToSpeech#setLanguage call to the same engine.

 In Android versions after 4.2 this function returns the language that is currently being
 used for the synthesis requests sent from this client. That is the last language set
 by a TextToSpeech#setLanguage call on this instance.

 If a voice is set (by setVoice(android.speech.tts.Voice) ) getLanguage will return the language of
 the currently set voice.

 Please note that the Locale object returned by this method is NOT a valid Locale object. Its
 language field contains a three-letter ISO 639-2/T code (where a proper Locale would use
 a two-letter ISO 639-1 code) and the country field contains a three-letter ISO 3166 country
 code (where a proper Locale would use a two-letter ISO 3166-1 code).",,"Locale language country (if any) and variant (if any) used by the client stored in a
     Locale instance or null on error. |||",4,"Synthesizes speech from text for immediate playback or to create a sound file.
  A TextToSpeech instance can only be used to synthesize text once it has completed its
 initialization. Implement the  TextToSpeech.OnInitListener  to be
 notified of the completion of the initialization. 
 When you are done using the TextToSpeech instance call the  shutdown()  method
 to release the native resources used by the TextToSpeech engine.",,no,no,0,no,no,no,no,
"<android.content.res.TypedArray: float getFloat(int,float)>","Retrieve the float value for the attribute at index . If the attribute is not a float or an integer this method will attempt
 to coerce it to a float using Float#parseFloat(String) .","index int : Index of attribute to retrieve. |||
defValue float |||","float Attribute float value or defValue if the attribute was
         not defined or could not be coerced to a float. |||",1,"Container for an array of values that were retrieved with
  Resources.Theme#obtainStyledAttributes(AttributeSet int[] int int) 
 or  Resources#obtainAttributes .  Be
 sure to call  recycle()  when done with them.

 The indices used to retrieve values from this structure correspond to
 the positions of the attributes given to obtainStyledAttributes.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,
<android.os.StrictMode: void noteSlowCall(String)>,For code to note that it's slow. This is a no-op unless the current thread's StrictMode.ThreadPolicy has StrictMode.ThreadPolicy.Builder.detectCustomSlowCalls() enabled.,name String : a short string for the exception stack trace that's built if when this fires. |||,void,11,"StrictMode is a developer tool which detects things you might be doing by accident and brings
 them to your attention so you can fix them.

  StrictMode is most commonly used to catch accidental disk or network access on the
 application's main thread where UI operations are received and animations take place. Keeping
 disk and network operations off the main thread makes for much smoother more responsive
 applications. By keeping your application's main thread responsive you also prevent  ANR dialogs  from being shown to
 users.

  Note that even though an Android device's disk is often on flash memory many
 devices run a filesystem on top of that memory with very limited concurrency. It's often the case
 that almost all disk accesses are fast but may in individual cases be dramatically slower when
 certain I/O is happening in the background from other processes. If possible it's best to assume
 that such things are not fast.

  Example code to enable from early in your  Application   Activity  or other application component's  Application.onCreate() 
 method:

  
 public void onCreate() {
     if (DEVELOPER_MODE) {
         StrictMode.setThreadPolicy(new  ThreadPolicy.Builder ()
                 .detectDiskReads()
                 .detectDiskWrites()
                 .detectNetwork()   // or .detectAll() for all detectable problems
                 .penaltyLog()
                 .build());
         StrictMode.setVmPolicy(new  VmPolicy.Builder ()
                 .detectLeakedSqlLiteObjects()
                 .detectLeakedClosableObjects()
                 .penaltyLog()
                 .penaltyDeath()
                 .build());
     }
     super.onCreate();
 }
  You can decide what should happen when a violation is detected. For example using  StrictMode.ThreadPolicy.Builder.penaltyLog()  you can watch the output of  adb logcat  while you
 use your application to see the violations as they happen.

  If you find violations that you feel are problematic there are a variety of tools to help
 solve them: threads  Handler   AsyncTask   IntentService  etc. But don't feel compelled to fix everything that StrictMode
 finds. In particular many cases of disk access are often necessary during the normal activity
 lifecycle. Use StrictMode to find things you did by accident. Network requests on the UI thread
 are almost always a problem though.

  StrictMode is not a security mechanism and is not guaranteed to find all disk or
 network accesses. While it does propagate its state across process boundaries when doing  Binder  calls it's still ultimately a best effort mechanism. Notably disk or network
 access from JNI calls won't necessarily trigger it. Future versions of Android may catch more (or
 fewer) operations so you should never leave StrictMode enabled in applications distributed on
 Google Play.",,no,no,0,no,no,no,no,
<android.accounts.AccountManager: String getPassword(Account)>,"Gets the saved password associated with the account. This is intended for authenticators and
 related code; applications should get an auth token instead. It is safe to call this method from the main thread. This method requires the caller to have a signature match with the authenticator that owns
 the specified account. NOTE: If targeting your app to work on API level Build.VERSION_CODES.LOLLIPOP_MR1 and before AUTHENTICATE_ACCOUNTS
 permission is needed for those platforms. See docs for this function in API level Build.VERSION_CODES.LOLLIPOP_MR1 . Requires android.Manifest.permission.AUTHENTICATE_ACCOUNTS",account Account : The account to query for a password. Must not be null . |||,String The account's password null if none or if the account doesn't exist |||,5,"This class provides access to a centralized registry of the user's
 online accounts.  The user enters credentials (username and password) once
 per account granting applications access to online resources with
 ""one-click"" approval.

  Different online services have different ways of handling accounts and
 authentication so the account manager uses pluggable  authenticator 
 modules for different  account types .  Authenticators (which may be
 written by third parties) handle the actual details of validating account
 credentials and storing account information.  For example Google Facebook
 and Microsoft Exchange each have their own authenticator.

  Many servers support some notion of an  authentication token 
 which can be used to authenticate a request to the server without sending
 the user's actual password.  (Auth tokens are normally created with a
 separate request which does include the user's credentials.)  AccountManager
 can generate auth tokens for applications so the application doesn't need to
 handle passwords directly.  Auth tokens are normally reusable and cached by
 AccountManager but must be refreshed periodically.  It's the responsibility
 of applications to  invalidate  auth tokens when they stop working so
 the AccountManager knows it needs to regenerate them.

  Applications accessing a server normally go through these steps:

  Get an instance of AccountManager using  get(android.content.Context) .

  List the available accounts using  getAccountsByType(String)  or
  getAccountsByTypeAndFeatures(String String[] AccountManagerCallback  Handler) .  Normally applications will only
 be interested in accounts with one particular  type  which
 identifies the authenticator.  Account  features  are used to
 identify particular account subtypes and capabilities.  Both the account
 type and features are authenticator-specific strings and must be known by
 the application in coordination with its preferred authenticators.

  Select one or more of the available accounts possibly by asking the
 user for their preference.  If no suitable accounts are available
  addAccount(String String String[] Bundle Activity AccountManagerCallback  Handler)  may be called to prompt the user to create an
 account of the appropriate type.

  Important:  If the application is using a previously remembered
 account selection it must make sure the account is still in the list
 of accounts returned by  getAccountsByType(String) .  Requesting an auth token
 for an account no longer on the device results in an undefined failure.

  Request an auth token for the selected account(s) using one of the
  getAuthToken(Account String Bundle Activity AccountManagerCallback  Handler)  methods or related helpers.  Refer to the description
 of each method for exact usage and error handling details.

  Make the request using the auth token.  The form of the auth token
 the format of the request and the protocol used are all specific to the
 service you are accessing.  The application may use whatever network and
 protocol libraries are useful.

  Important:  If the request fails with an authentication error
 it could be that a cached auth token is stale and no longer honored by
 the server.  The application must call  invalidateAuthToken(String String)  to remove
 the token from the cache otherwise requests will continue failing!  After
 invalidating the auth token immediately go back to the ""Request an auth
 token"" step above.  If the process fails the second time then it can be
 treated as a ""genuine"" authentication failure and the user notified or other
 appropriate actions taken.
  Some AccountManager methods may need to interact with the user to
 prompt for credentials present options or ask the user to add an account.
 The caller may choose whether to allow AccountManager to directly launch the
 necessary user interface and wait for the user or to return an Intent which
 the caller may use to launch the interface or (in some cases) to install a
 notification which the user can select at any time to launch the interface.
 To have AccountManager launch the interface directly the caller must supply
 the current foreground  Activity  context.

  Many AccountManager methods take  AccountManagerCallback  and
  Handler  as parameters.  These methods return immediately and
 run asynchronously. If a callback is provided then
  AccountManagerCallback#run  will be invoked on the Handler's
 thread when the request completes successfully or not.
 The result is retrieved by calling  AccountManagerFuture#getResult() 
 on the  AccountManagerFuture  returned by the method (and also passed
 to the callback).  This method waits for the operation to complete (if
 necessary) and either returns the result or throws an exception if an error
 occurred during the operation.  To make the request synchronously call
  AccountManagerFuture#getResult()  immediately on receiving the
 future from the method; no callback need be supplied.

  Requests which may block including
  AccountManagerFuture#getResult()  must never be called on
 the application's main event thread.  These operations throw
  IllegalStateException  if they are used on the main thread.",,password,password file ,1,no,potentially,no,SINK,
<android.app.UiModeManager: int getNightMode()>,"Returns the currently configured night mode. May be one of: MODE_NIGHT_NO 
MODE_NIGHT_YES 
MODE_NIGHT_AUTO 
MODE_NIGHT_CUSTOM 
-1 on error",,"int the current night mode or -1 on error
 Value is MODE_NIGHT_AUTO  MODE_NIGHT_CUSTOM  MODE_NIGHT_NO or MODE_NIGHT_YES |||",8,"This class provides access to the system uimode services.  These services
 allow applications to control UI modes of the device.
 It provides functionality to disable the car mode and it gives access to the
 night mode settings.

  These facilities are built on top of the underlying
  Intent.ACTION_DOCK_EVENT  broadcasts that are sent when the user
 physical places the device into and out of a dock.  When that happens
 the UiModeManager switches the system  Configuration 
 to the appropriate UI mode sends broadcasts about the mode switch and
 starts the corresponding mode activity if appropriate.  See the
 broadcasts  ACTION_ENTER_CAR_MODE  and
  ACTION_ENTER_DESK_MODE  for more information.

  In addition the user may manually switch the system to car mode without
 physically being in a dock.  While in car mode -- whether by manual action
 from the user or being physically placed in a dock -- a notification is
 displayed allowing the user to exit dock mode.  Thus the dock mode
 represented here may be different than the current state of the underlying
 dock event broadcast.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
<android.nfc.tech.NfcF: int getTimeout()>,Get the current transceive(byte[]) timeout in milliseconds. Requires the Manifest.permission.NFC permission.,,int timeout value in milliseconds |||,14,"Provides access to NFC-F (JIS 6319-4) properties and I/O operations on a  Tag .

  Acquire a  NfcF  object using  get(Tag) .
  The primary NFC-F I/O operation is  transceive(byte[]) . Applications must
 implement their own protocol stack on top of  transceive(byte[]) .

  Note:  Methods that perform I/O operations
 require the  Manifest.permission.NFC  permission.","These classes provide access to a tag technology's features which vary by the type
 of tag that is scanned. A scanned tag can support multiple technologies and you can find
 out what they are by calling  getTechList() . For more information on dealing with tag technologies and handling the ones that you care about see
  The Tag Dispatch System .
 The  TagTechnology  interface provides an overview of the
 supported technologies.",nfc metadata,nfc,1,yes,no,SOURCE,no,
<android.accessibilityservice.AccessibilityServiceInfo: String loadDescription(PackageManager)>,The localized description of the accessibility service. Statically set from AccessibilityService#SERVICE_META_DATA .,packageManager PackageManager |||,String The localized description. |||,16,"This class describes an  AccessibilityService . The system notifies an
  AccessibilityService  for  AccessibilityEvent s
 according to the information encapsulated in this class.","The classes in this package are used for development of accessibility service that
   provide alternative or augmented feedback to the user.
  
   An  AccessibilityService  runs in the background and
   receives callbacks by the system when  AccessibilityEvent s
   are fired. Such events denote some state transition in the user interface for example the
   focus has changed a button has been clicked etc. Such a service can optionally request the
   capability for querying the content of the active window. Development of an accessibility
   service requires extends this class and implements its abstract methods.
  
   An  AccessibilityServiceInfo  describes an
    AccessibilityService . The system notifies an
   AccessibilityService for  AccessibilityEvent s
   according to the information encapsulated in this class.",no,no,0,no,no,no,no,
<android.app.Service: void stopSelf()>,"Stop the service if it was previously started.  This is the same as
 calling Context.stopService(Intent) for this particular service.",,void,1,"A Service is an application component representing either an application's desire
 to perform a longer-running operation while not interacting with the user
 or to supply functionality for other applications to use.  Each service
 class must have a corresponding
  <service> 
 declaration in its package's  AndroidManifest.xml .  Services
 can be started with
  Context.startService()  and
  Context.bindService() .

  Note that services like other application objects run in the main
 thread of their hosting process.  This means that if your service is going
 to do any CPU intensive (such as MP3 playback) or blocking (such as
 networking) operations it should spawn its own thread in which to do that
 work.  More information on this can be found in
  Processes and
 Threads .  The  IntentService  class is available
 as a standard implementation of Service that has its own thread where it
 schedules its work to be done. Topics covered here:
  What is a Service? Service Lifecycle Permissions Process Lifecycle Local Service Sample Remote Messenger Service Sample","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
"<android.webkit.WebView: void loadDataWithBaseURL(String,String,String,String,String)>","Loads the given data into this WebView using baseUrl as the base URL for
 the content. The base URL is used both to resolve relative URLs and when
 applying JavaScript's same origin policy. The historyUrl is used for the
 history entry. The mimeType parameter specifies the format of the data.
 If WebView can't handle the specified MIME type it will download the data.
 If null defaults to 'text/html'. Note that content specified in this way can access local device files
 (via 'file' scheme URLs) only if baseUrl specifies a scheme other than
 'http' 'https' 'ftp' 'ftps' 'about' or 'javascript'. If the base URL uses the data scheme this method is equivalent to
 calling loadData() and the
 historyUrl is ignored and the data will be treated as part of a data: URL
 including the requirement that the content be URL-encoded or base64 encoded.
 If the base URL uses any other scheme then the data will be loaded into
 the WebView as a plain string (i.e. not part of a data URL) and any URL-encoded
 entities in the string will not be decoded. Note that the baseUrl is sent in the 'Referer' HTTP header when
 requesting subresources (images etc.) of the page loaded using this method. If a valid HTTP or HTTPS base URL is not specified in baseUrl then
 content loaded using this method will have a window.origin value
 of ""null"" . This must not be considered to be a trusted origin
 by the application or by any JavaScript code running inside the WebView
 (for example event sources in DOM event handlers or web messages)
 because malicious content can also create frames with a null origin. If
 you need to identify the main frame's origin in a trustworthy way you
 should use a valid HTTP or HTTPS base URL to set the origin.","baseUrl String : the URL to use as the page's base URL. If null defaults to
'about:blank'.
This value may be null . |||
data String : a String of data in the given encoding
This value must never be null . |||
mimeType String : the MIME type of the data e.g. 'text/html'.
This value may be null . |||
encoding String : the encoding of the data
This value may be null . |||
historyUrl String : the URL to use as the history entry. If null defaults
to 'about:blank'. If non-null this must be a valid URL.
This value may be null . |||",void,1,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",data from network ,network ,1,no,no,no,no,
<android.database.AbstractCursor: void deactivate()>,"Deactivates the Cursor making all calls on it fail until requery() is called.
 Inactive Cursors use fewer resources than active Cursors.
 Calling requery() will make the cursor active again.",,void,1,"This is an abstract cursor class that handles a lot of the common code
 that all cursors need to deal with and is provided for convenience reasons.","If you need to manage data in a private database use the  android.database.sqlite  classes. These classes are used to manage the  Cursor  object returned from a content provider query. Databases
 are usually created and opened with  openOrCreateDatabase(String int SQLiteDatabase.CursorFactory) 
 To make requests through
 content providers you can use the  content.ContentResolver  class.
  All databases are stored on the device in  /data/data/<package_name>/databases",no,no,0,no,no,no,no,
<android.view.ViewGroup: void removeAllViewsInLayout()>,"Called by a ViewGroup subclass to remove child views from itself
 when it must first know its size on screen before it can calculate how many
 child views it will render. An example is a Gallery or a ListView which
 may ""have"" 50 children but actually only render the number of children
 that can currently fit inside the object on screen. Do not call
 this method unless you are extending ViewGroup and understand the
 view measuring and layout pipeline. Note: do not invoke this method from View.draw(android.graphics.Canvas)  View.onDraw(android.graphics.Canvas)  dispatchDraw(android.graphics.Canvas) or any related method.",,void,1,"A  ViewGroup  is a special view that can contain other views
 (called children.) The view group is the base class for layouts and views
 containers. This class also defines the
  ViewGroup.LayoutParams  class which serves as the base
 class for layouts parameters.
  
 Also see  LayoutParams  for layout attributes.",,no,no,0,no,no,no,no,
<android.app.Activity: void finishAffinity()>,"Finish this activity as well as all activities immediately below it
 in the current task that have the same affinity.  This is typically
 used when an application can be launched on to another task (such as
 from an ACTION_VIEW of a content type it understands) and the user
 has used the up navigation to switch out of the current task and in
 to its own task.  In this case if the user has navigated down into
 any other activities of the second application all of those should
 be removed from the original task as part of the task switch. Note that this finish does not allow you to deliver results
 to the previous activity and an exception will be thrown if you are trying
 to do so.",,void,16,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
<android.view.ViewPropertyAnimator: ViewPropertyAnimator scaleX(float)>,"This method will cause the View's scaleX property to be animated to the
 specified value. Animations already running on the property will be canceled.",value float : The value to be animated to. |||,ViewPropertyAnimator This object allowing calls to methods in this class to be chained. |||,12,"This class enables automatic and optimized animation of select properties on View objects.
 If only one or two properties on a View object are being animated then using an
  ObjectAnimator  is fine; the property setters called by ObjectAnimator
 are well equipped to do the right thing to set the property and invalidate the view
 appropriately. But if several properties are animated simultaneously or if you just want a
 more convenient syntax to animate a specific property then ViewPropertyAnimator might be
 more well-suited to the task.

  This class may provide better performance for several simultaneous animations because
 it will optimize invalidate calls to take place only once for several properties instead of each
 animated property independently causing its own invalidation. Also the syntax of using this
 class could be easier to use because the caller need only tell the View object which
 property to animate and the value to animate either to or by and this class handles the
 details of configuring the underlying Animator class and starting it. This class is not constructed by the caller but rather by the View whose properties
 it will animate. Calls to  View.animate()  will return a reference
 to the appropriate ViewPropertyAnimator object for that View.",,no,UI,0,no,no,no,no,
"<android.app.WallpaperManager: void setWallpaperOffsets(IBinder,float,float)>","Set the display position of the current wallpaper within any larger space when
 that wallpaper is visible behind the given window.  The X and Y offsets
 are floating point numbers ranging from 0 to 1 representing where the
 wallpaper should be positioned within the screen space.  These only
 make sense when the wallpaper is larger than the display.","windowToken IBinder : The window who these offsets should be associated
with as returned by View.getWindowToken() . |||
xOffset float : The offset along the X dimension from 0 to 1. |||
yOffset float : The offset along the Y dimension from 0 to 1. |||",void,5,"Provides access to the system wallpaper. With WallpaperManager you can
 get the current wallpaper get the desired dimensions for the wallpaper set
 the wallpaper and more.

   An app can check whether wallpapers are supported for the current user by calling
  isWallpaperSupported()  and whether setting of wallpapers is allowed by calling
  isSetWallpaperAllowed() .","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,UI,0,no,no,no,no,
<android.database.sqlite.SQLiteClosable: void releaseReference()>,"Releases a reference to the object closing the object if the last reference
 was released.",,void,1,"An object created from a SQLiteDatabase that can be closed.

 This class implements a primitive reference counting scheme for database objects.","If you need to manage data in a private database use the  android.database.sqlite  classes. These classes are used to manage the  Cursor  object returned from a content provider query. Databases
 are usually created and opened with  openOrCreateDatabase(String int SQLiteDatabase.CursorFactory) 
 To make requests through
 content providers you can use the  content.ContentResolver  class.
  All databases are stored on the device in  /data/data/<package_name>/databases",no,database,0,no,no,no,no,
<android.content.ContextWrapper: void sendStickyBroadcast(Intent)>,"This method is deprecated. Sticky broadcasts should not be used.  They provide no security (anyone
 can access them) no protection (anyone can modify them) and many other problems.
 The recommended pattern is to use a non-sticky broadcast to report that something has changed with another mechanism for apps to retrieve the current value whenever
 desired. Perform a sendBroadcast(android.content.Intent) that is ""sticky"" meaning the
 Intent you are sending stays around after the broadcast is complete
 so that others can quickly retrieve that data through the return
 value of registerReceiver(android.content.BroadcastReceiver android.content.IntentFilter) .  In
 all other ways this behaves the same as sendBroadcast(android.content.Intent) . Requires Manifest.permission.BROADCAST_STICKY","intent Intent : The Intent to broadcast; all receivers matching this
Intent will receive the broadcast and the Intent will be held to
be re-broadcast to future receivers. |||",void,1,"Proxying implementation of Context that simply delegates all of its calls to
 another Context.  Can be subclassed to modify behavior without changing
 the original Context.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",IPC,IPC,1,no,yes,no,SINK,
"<android.content.Context: String getString(int,Object)>","Returns a localized formatted string from the application's package's
 default string table substituting the format arguments as defined in Formatter and String.format(String Object...) .","resId int : Resource id for the format string |||
formatArgs Object : The format arguments that will be used for
substitution. |||","String The string data associated with the resource formatted and
         stripped of styled text information.
 
 This value will never be null . |||",1,"Interface to global information about an application environment.  This is
 an abstract class whose implementation is provided by
 the Android system.  It
 allows access to application-specific resources and classes as well as
 up-calls for application-level operations such as launching activities
 broadcasting and receiving intents etc.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,
<android.app.Activity: void startActivities(Intent)>,"Same as startActivities(android.content.Intent[] android.os.Bundle) with no options
 specified.",intents Intent : The intents to start. |||,void,11,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",IPC,IPC,1,no,yes?,no,SINK,
<android.util.EventLog: int getTagCode(String)>,Get the event type tag code associated with an event name.,name String : of event to look up |||,int the tag code or -1 if no tag has that name |||,8,"Access to the system diagnostic event record.  System diagnostic events are
 used to record certain system-level events (such as garbage collection
 activity manager state system watchdogs and other low level activity)
 which may be automatically collected and analyzed during system development.

  This is  not  the main ""logcat"" debugging log ( Log )!
 These diagnostic events are for system integrators not application authors.

  Events use integer tag codes corresponding to /system/etc/event-log-tags.
 They carry a payload of one or more int long or String values.  The
 event-log-tags file defines the payload contents for each type code.",,no,no,0,no,no,no,no,
"<android.appwidget.AppWidgetManager: void notifyAppWidgetViewDataChanged(int,int)>","Notifies the specified collection view in all the specified AppWidget instances
 to invalidate their data.","appWidgetIds int : The AppWidget instances to notify of view data changes. |||
viewId int : The collection view id. |||",void,11,"Updates AppWidget state; gets information about installed AppWidget providers and other
 AppWidget related state.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no ,no,no,
"<android.accounts.AccountManager: void setUserData(Account,String,String)>","Sets one userdata key for an account. Intended by use for the
 authenticator to stash state for itself not directly by applications.
 The meaning of the keys and values is up to the authenticator. It is safe to call this method from the main thread. This method requires the caller to have a signature match with the
 authenticator that manages the specified account. NOTE: If targeting your app to work on API level 22 and before
 AUTHENTICATE_ACCOUNTS permission and same UID as account's authenticator
 is needed for those platforms. See docs for this function in API level 22. Requires android.Manifest.permission.AUTHENTICATE_ACCOUNTS","account Account : Account whose user data is to be set. Must not be null . |||
key String : String user data key to set.  Must not be null |||
value String : String value to set null to clear this user data key |||",void,5,"This class provides access to a centralized registry of the user's
 online accounts.  The user enters credentials (username and password) once
 per account granting applications access to online resources with
 ""one-click"" approval.

  Different online services have different ways of handling accounts and
 authentication so the account manager uses pluggable  authenticator 
 modules for different  account types .  Authenticators (which may be
 written by third parties) handle the actual details of validating account
 credentials and storing account information.  For example Google Facebook
 and Microsoft Exchange each have their own authenticator.

  Many servers support some notion of an  authentication token 
 which can be used to authenticate a request to the server without sending
 the user's actual password.  (Auth tokens are normally created with a
 separate request which does include the user's credentials.)  AccountManager
 can generate auth tokens for applications so the application doesn't need to
 handle passwords directly.  Auth tokens are normally reusable and cached by
 AccountManager but must be refreshed periodically.  It's the responsibility
 of applications to  invalidate  auth tokens when they stop working so
 the AccountManager knows it needs to regenerate them.

  Applications accessing a server normally go through these steps:

  Get an instance of AccountManager using  get(android.content.Context) .

  List the available accounts using  getAccountsByType(String)  or
  getAccountsByTypeAndFeatures(String String[] AccountManagerCallback  Handler) .  Normally applications will only
 be interested in accounts with one particular  type  which
 identifies the authenticator.  Account  features  are used to
 identify particular account subtypes and capabilities.  Both the account
 type and features are authenticator-specific strings and must be known by
 the application in coordination with its preferred authenticators.

  Select one or more of the available accounts possibly by asking the
 user for their preference.  If no suitable accounts are available
  addAccount(String String String[] Bundle Activity AccountManagerCallback  Handler)  may be called to prompt the user to create an
 account of the appropriate type.

  Important:  If the application is using a previously remembered
 account selection it must make sure the account is still in the list
 of accounts returned by  getAccountsByType(String) .  Requesting an auth token
 for an account no longer on the device results in an undefined failure.

  Request an auth token for the selected account(s) using one of the
  getAuthToken(Account String Bundle Activity AccountManagerCallback  Handler)  methods or related helpers.  Refer to the description
 of each method for exact usage and error handling details.

  Make the request using the auth token.  The form of the auth token
 the format of the request and the protocol used are all specific to the
 service you are accessing.  The application may use whatever network and
 protocol libraries are useful.

  Important:  If the request fails with an authentication error
 it could be that a cached auth token is stale and no longer honored by
 the server.  The application must call  invalidateAuthToken(String String)  to remove
 the token from the cache otherwise requests will continue failing!  After
 invalidating the auth token immediately go back to the ""Request an auth
 token"" step above.  If the process fails the second time then it can be
 treated as a ""genuine"" authentication failure and the user notified or other
 appropriate actions taken.
  Some AccountManager methods may need to interact with the user to
 prompt for credentials present options or ask the user to add an account.
 The caller may choose whether to allow AccountManager to directly launch the
 necessary user interface and wait for the user or to return an Intent which
 the caller may use to launch the interface or (in some cases) to install a
 notification which the user can select at any time to launch the interface.
 To have AccountManager launch the interface directly the caller must supply
 the current foreground  Activity  context.

  Many AccountManager methods take  AccountManagerCallback  and
  Handler  as parameters.  These methods return immediately and
 run asynchronously. If a callback is provided then
  AccountManagerCallback#run  will be invoked on the Handler's
 thread when the request completes successfully or not.
 The result is retrieved by calling  AccountManagerFuture#getResult() 
 on the  AccountManagerFuture  returned by the method (and also passed
 to the callback).  This method waits for the operation to complete (if
 necessary) and either returns the result or throws an exception if an error
 occurred during the operation.  To make the request synchronously call
  AccountManagerFuture#getResult()  immediately on receiving the
 future from the method; no callback need be supplied.

  Requests which may block including
  AccountManagerFuture#getResult()  must never be called on
 the application's main event thread.  These operations throw
  IllegalStateException  if they are used on the main thread.",,no,no,0,no,no,no,no,
<android.bluetooth.BluetoothHeadset: List getDevicesMatchingConnectionStates(int)>,"Get a list of devices that match any of the given connection
 states. If none of the devices match any of the given states
 an empty list will be returned. Requires Manifest.permission.BLUETOOTH",states int : Array of states. States can be one of BluetoothProfile.STATE_CONNECTED  BluetoothProfile.STATE_CONNECTING  BluetoothProfile.STATE_DISCONNECTED  BluetoothProfile.STATE_DISCONNECTING  |||,List < BluetoothDevice > List of devices. The list will be empty on error. |||,11,"Public API for controlling the Bluetooth Headset Service. This includes both
 Bluetooth Headset and Handsfree (v1.5) profiles.

  BluetoothHeadset is a proxy object for controlling the Bluetooth Headset
 Service via IPC.

   Use  BluetoothAdapter#getProfileProxy  to get
 the BluetoothHeadset proxy object. Use
  BluetoothAdapter#closeProfileProxy  to close the service connection.

   Android only supports one connected Bluetooth Headset at a time.
 Each method is protected with its appropriate permission.","Provides classes that manage Bluetooth functionality such as scanning for
 devices connecting with devices and managing data transfer between devices.
 The Bluetooth API supports both ""Classic Bluetooth"" and Bluetooth Low Energy. For more information about Classic Bluetooth see the
  Bluetooth  guide.
 For more information about Bluetooth Low Energy see the
  
 Bluetooth Low Energy  (BLE) guide. The Bluetooth APIs let applications: Scan for other Bluetooth devices (including BLE devices). Query the local Bluetooth adapter for paired Bluetooth devices. Establish RFCOMM channels/sockets. Connect to specified sockets on other devices. Transfer data to and from other devices. Communicate with BLE devices such as proximity sensors heart rate
     monitors fitness devices and so on. Act as a GATT client or a GATT server (BLE). 
 To perform Bluetooth communication using these APIs an application must
 declare the  BLUETOOTH  permission. Some
 additional functionality such as requesting device discovery
 also requires the  BLUETOOTH_ADMIN 
 permission.
  Note: 
 Not all Android-powered devices provide Bluetooth functionality.",bluetooth,bluetooth,1,yes,no,SOURCE,no,
"<android.text.method.PasswordTransformationMethod: CharSequence getTransformation(CharSequence,View)>","Returns a CharSequence that is a transformation of the source text --
 for example replacing each character with a dot in a password field.
 Beware that the returned text must be exactly the same length as
 the source text and that if the source text is Editable the returned
 text must mirror it dynamically instead of doing a one-time copy.
 The method should not return null unless source is null .","source CharSequence |||
view View |||",CharSequence |||,1,,"Provides classes that monitor or modify keypad input. You can use these classes to modify the type of keypad entry
 for your application or decipher the keypresses entered for your specific
 entry method. For example: 
 // Set the text to password display style:
 EditText txtView = (EditText)findViewById(R.id.text);
 txtView.setTransformationMethod(PasswordTransformationMethod.getInstance());

 //Set the input style to numbers rather than qwerty keyboard style.
 txtView.setInputMethod(DigitsInputMethod.getInstance());

 // Find out whether the caps lock is on.
 // 0 is no 1 is yes 2 is caps lock on.
 int active = MultiTapInputMethod.getCapsActive(txtView.getText());",password,callback,1,no,yes,no,SINK,
<android.view.View: View focusSearch(int)>,"Find the nearest view in the specified direction that can take focus.
 This does not actually give focus to that view.","direction int : One of FOCUS_UP FOCUS_DOWN FOCUS_LEFT and FOCUS_RIGHT
Value is FOCUS_LEFT  FOCUS_UP  FOCUS_RIGHT or FOCUS_DOWN |||","View The nearest focusable in the specified direction or null if none
         can be found. |||",1,"This class represents the basic building block for user interface components. A View
 occupies a rectangular area on the screen and is responsible for drawing and
 event handling. View is the base class for  widgets  which are
 used to create interactive UI components (buttons text fields etc.). The
  ViewGroup  subclass is the base class for  layouts  which
 are invisible containers that hold other Views (or other ViewGroups) and define
 their layout properties.",,no,UI,0,no,no,no,no,
"<android.content.Intent: Intent putExtra(String,char)>","Add extended data to the intent.  The name must include a package
 prefix for example the app com.android.contacts would use names
 like ""com.android.contacts.ShowAll"".","name String : The name of the extra data with package prefix. |||
value char : The char data value. |||","Intent Returns the same Intent object for chaining multiple calls
 into a single statement.

 This value will never be null . |||",1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",IPC,no,0,no,no,no,no,
<android.widget.ImageSwitcher: void setImageURI(Uri)>,"Sets a new image on the ImageSwitcher with the given Uri.
 This will set that image on the next ImageView in the switcher and will
 then switch to that view.",uri Uri : the Uri of an image |||,void,1,"ViewSwitcher  that switches between two ImageViews when a new
 image is set on it. The views added to an ImageSwitcher must all be
  ImageView .","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",image data,UI,1,no,yes,no,SINK,
<android.nfc.tech.IsoDep: void setTimeout(int)>,"Set the timeout of transceive(byte[]) in milliseconds. The timeout only applies to ISO-DEP transceive(byte[]) and is
 reset to a default value when close() is called. Setting a longer timeout may be useful when performing
 transactions that require a long processing time on the tag
 such as key generation. Requires the Manifest.permission.NFC permission.",timeout int : timeout value in milliseconds |||,void,10,"Provides access to ISO-DEP (ISO 14443-4) properties and I/O operations on a  Tag .

  Acquire an  IsoDep  object using  get(Tag) .
  The primary ISO-DEP I/O operation is  transceive(byte[]) . Applications must
 implement their own protocol stack on top of  transceive(byte[]) .
  Tags that enumerate the  IsoDep  technology in  Tag#getTechList 
 will also enumerate
  NfcA  or  NfcB  (since IsoDep builds on top of either of these).

  Note:  Methods that perform I/O operations
 require the  Manifest.permission.NFC  permission.","These classes provide access to a tag technology's features which vary by the type
 of tag that is scanned. A scanned tag can support multiple technologies and you can find
 out what they are by calling  getTechList() . For more information on dealing with tag technologies and handling the ones that you care about see
  The Tag Dispatch System .
 The  TagTechnology  interface provides an overview of the
 supported technologies.",no,nfc,0,no,no,no,no,
"<android.database.sqlite.SQLiteQueryBuilder: Cursor query(SQLiteDatabase,String,String,String,String,String,String,String,CancellationSignal)>","Perform a query by combining all current settings and the
 information passed into this method.","db SQLiteDatabase : the database to query on |||
projectionIn String : A list of which columns to return. Passing
null will return all columns which is discouraged to prevent
reading data from storage that isn't going to be used. |||
selection String : A filter declaring which rows to return
formatted as an SQL WHERE clause (excluding the WHERE itself). Passing null will return all rows for the given URL. |||
selectionArgs String : You may include ?s in selection which
will be replaced by the values from selectionArgs in order
that they appear in the selection. The values will be bound
as Strings. |||
groupBy String : A filter declaring how to group rows formatted
as an SQL GROUP BY clause (excluding the GROUP BY itself). Passing null will cause the rows to not be grouped. |||
having String : A filter declare which row groups to include in
the cursor if row grouping is being used formatted as an
SQL HAVING clause (excluding the HAVING itself).  Passing
null will cause all row groups to be included and is
required when row grouping is not being used. |||
sortOrder String : How to order the rows formatted as an SQL ORDER BY clause (excluding the ORDER BY itself). Passing null
will use the default sort order which may be unordered. |||
limit String : Limits the number of rows returned by the query
formatted as LIMIT clause. Passing null denotes no LIMIT clause. |||
cancellationSignal CancellationSignal : A signal to cancel the operation in progress or null if none.
If the operation is canceled then OperationCanceledException will be thrown
when the query is executed. |||",Cursor a cursor over the result set |||,16,"This is a convenience class that helps build SQL queries to be sent to
  SQLiteDatabase  objects.","If you need to manage data in a private database use the  android.database.sqlite  classes. These classes are used to manage the  Cursor  object returned from a content provider query. Databases
 are usually created and opened with  openOrCreateDatabase(String int SQLiteDatabase.CursorFactory) 
 To make requests through
 content providers you can use the  content.ContentResolver  class.
  All databases are stored on the device in  /data/data/<package_name>/databases",database,database,1,no,no,no,no,
"<android.telephony.TelephonyManager: void listen(PhoneStateListener,int)>","Registers a listener object to receive notification of changes
 in specified telephony states. To register a listener pass a PhoneStateListener and specify at least one telephony
 state of interest in the events argument.

 At registration and when a specified telephony state changes the telephony manager invokes
 the appropriate callback method on the listener object and passes the current (updated)
 values. To un-register a listener pass the listener object and set the events argument to PhoneStateListener#LISTEN_NONE (0).

 If this TelephonyManager object has been created with createForSubscriptionId(int) applies to the given subId. Otherwise applies to SubscriptionManager#getDefaultSubscriptionId() . To listen events for multiple subIds
 pass a separate listener object to each TelephonyManager object created with createForSubscriptionId(int) .

 Note: if you call this method while in the middle of a binder transaction you must call Binder.clearCallingIdentity() before calling this method. A SecurityException will be thrown otherwise.","listener PhoneStateListener : The PhoneStateListener object to register
(or unregister) |||
events int : The telephony state(s) of interest to the listener
as a bitwise-OR combination of PhoneStateListener LISTEN_ flags. |||",void,1,"Provides access to information about the telephony services on
 the device. Applications can use the methods in this class to
 determine telephony services and states as well as to access some
 types of subscriber information. Applications can also register
 a listener to receive notification of telephony state changes.
  
 The returned TelephonyManager will use the default subscription for all calls.
 To call an API for a specific subscription use  createForSubscriptionId(int) . e.g.
  
   telephonyManager = defaultSubTelephonyManager.createForSubscriptionId(subId);
  
 Note that access to some telephony information is
 permission-protected. Your application cannot access the protected
 information unless it has the appropriate permissions declared in
 its manifest file. Where permissions apply they are noted in the
 the methods through which you access the protected information.",,phone call,callback,1,no,yes,no,SINK,
<android.content.Intent: char getCharArrayExtra(String)>,Retrieve extended data from the intent.,name String : The name of the desired item. |||,"char[] the value of an item previously added with putExtra()
 or null if no char array value was found. |||",1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,
<android.preference.PreferenceManager: PreferenceScreen createPreferenceScreen(Context)>,,context Context |||,PreferenceScreen |||,1,"Used to help create  Preference  hierarchies
 from activities or XML.
  
 In most cases clients should use
  PreferenceActivity#addPreferencesFromIntent  or
  PreferenceActivity#addPreferencesFromResource(int) .",,no ,no,0,no,no,no,no,
<android.os.Messenger: void send(Message)>,Send a Message to this Messenger's Handler.,message Message : The Message to send.  Usually retrieved through Message#obtain() . |||,void,1,"Reference to a Handler which others can use to send messages to it.
 This allows for the implementation of message-based communication across
 processes by creating a Messenger pointing to a Handler in one process
 and handing that Messenger to another process.

  Note: the implementation underneath is just a simple wrapper around
 a  Binder  that is used to perform the communication.  This means
 semantically you should treat it as such: this class does not impact process
 lifecycle management (you must be using some higher-level component to tell
 the system that your process needs to continue running) the connection will
 break if your process goes away for any reason etc.",,uncategorized,IPC,1,no,yes,no,SINK,
"<android.test.TouchUtils: void longClickView(InstrumentationTestCase,View)>",Simulate touching the center of a view holding until it is a long press and then releasing.,"test InstrumentationTestCase : The test case that is being run |||
v View : The view that should be clicked |||",void,3,"Reusable methods for generating touch events. These methods can be used with
 InstrumentationTestCase or ActivityInstrumentationTestCase2 to simulate user interaction with
 the application through a touch screen.",,no,UI,0,no,no,no,no,
<android.view.accessibility.AccessibilityEvent: void initFromParcel(Parcel)>,Creates a new instance from a Parcel .,parcel Parcel : A parcel containing the state of a AccessibilityEvent . |||,void,4,"This class represents accessibility events that are sent by the system when
 something notable happens in the user interface. For example when a
  Button  is clicked a  View  is focused etc.
  
 An accessibility event is fired by an individual view which populates the event with
 data for its state and requests from its parent to send the event to interested
 parties. The parent can optionally modify or even block the event based on its broader
 understanding of the user interface's context.
  
 The main purpose of an accessibility event is to communicate changes in the UI to an
  AccessibilityService . The service may then inspect
 if needed the user interface by examining the View hierarchy as represented by a tree of
  AccessibilityNodeInfo s (snapshot of a View state)
 which can be used for exploring the window content. Note that the privilege for accessing
 an event's source thus the window content has to be explicitly requested. For more
 details refer to  AccessibilityService . If an
 accessibility service has not requested to retrieve the window content the event will
 not contain reference to its source. Also for events of type
  TYPE_NOTIFICATION_STATE_CHANGED  the source is never available.
  
 This class represents various semantically different accessibility event
 types. Each event type has an associated set of related properties. In other
 words each event type is characterized via a subset of the properties exposed
 by this class. For each event type there is a corresponding constant defined
 in this class. Follows a specification of the event types and their associated properties:",,no,no,0,no,no,no,no,
<android.net.sip.SipManager: void close(String)>,"Closes the specified profile to not make/receive calls. All the resources
 that were allocated to the profile are also released.",localProfileUri String : the URI of the profile to close |||,void,9,"Provides APIs for SIP tasks such as initiating SIP connections and provides access to related
 SIP services. This class is the starting point for any SIP actions. You can acquire an instance
 of it with  newInstance() . The APIs in this class allows you to: Create a  SipSession  to get ready for making calls or listen for incoming calls. See
  createSipSession()  and  getSessionFor() . Initiate and receive generic SIP calls or audio-only SIP calls. Generic SIP calls may
 be video audio or other and are initiated with  open() . Audio-only SIP calls
 should be handled with a  SipAudioCall  which you can acquire with  makeAudioCall()  and  takeAudioCall() . Register and unregister with a SIP service provider with
       register()  and  unregister() . Verify session connectivity with  isOpened()  and
       isRegistered() . Note:  Not all Android-powered devices support VOIP calls using
 SIP. You should always call  isVoipSupported()  to verify that the device supports VOIP calling and  isApiSupported()  to verify that the device supports
 the SIP APIs. Your application must also request the  Manifest.permission.INTERNET  and  Manifest.permission.USE_SIP 
 permissions.",,no,no,0,no,no,no,no,
"<android.database.DatabaseUtils: String stringForQuery(SQLiteStatement,String)>","Utility method to run the pre-compiled query and return the value in the
 first column of the first row.","prog SQLiteStatement |||
selectionArgs String |||",String |||,1,Static utility methods for dealing with databases and  Cursor s.,"If you need to manage data in a private database use the  android.database.sqlite  classes. These classes are used to manage the  Cursor  object returned from a content provider query. Databases
 are usually created and opened with  openOrCreateDatabase(String int SQLiteDatabase.CursorFactory) 
 To make requests through
 content providers you can use the  content.ContentResolver  class.
  All databases are stored on the device in  /data/data/<package_name>/databases",database,database,1,yes,no,SOURCE,no,
<android.widget.AbsListView: void onRestoreInstanceState(Parcelable)>,"Hook allowing a view to re-apply a representation of its internal state that had previously
 been generated by onSaveInstanceState() . This function will never be called with a
 null state. If you override this method you must call through to the
 superclass implementation.",state Parcelable : The frozen state that had previously been returned by onSaveInstanceState() . |||,void,1,"Base class that can be used to implement virtualized lists of items. A list does
 not have a spatial definition here. For instance subclasses of this class can
 display the content of the list in a grid in a carousel as stack etc.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,UI,0,no,no,no,no,
"<android.bluetooth.BluetoothHealth: ParcelFileDescriptor getMainChannelFd(BluetoothDevice,BluetoothHealthAppConfiguration)>","This method was deprecated
      in API level 29. Health Device Profile (HDP) and MCAP protocol are no longer used. New
 apps should use Bluetooth Low Energy based solutions such as BluetoothGatt  BluetoothAdapter#listenUsingL2capChannel() or BluetoothDevice#createL2capChannel(int) Get the file descriptor of the main channel associated with the remote device
 and application configuration. Requires Manifest.permission.BLUETOOTH permission. Its the responsibility of the caller to close the ParcelFileDescriptor
 when done.","device BluetoothDevice : The remote Bluetooth health device |||
config BluetoothHealthAppConfiguration : The application configuration |||",ParcelFileDescriptor null on failure ParcelFileDescriptor on success. |||,14,"Public API for Bluetooth Health Profile.

  BluetoothHealth is a proxy object for controlling the Bluetooth
 Service via IPC.

   How to connect to a health device which is acting in the source role.
   Use  BluetoothAdapter#getProfileProxy  to get
 the BluetoothHealth proxy object.   Create an  BluetoothHealth  callback and call
  registerSinkAppConfiguration(String int BluetoothHealthCallback)  to register an application
 configuration   Pair with the remote device. This currently needs to be done manually
 from Bluetooth Settings   Connect to a health device using  connectChannelToSource(BluetoothDevice BluetoothHealthAppConfiguration) . Some
 devices will connect the channel automatically. The  BluetoothHealth 
 callback will inform the application of channel state change.   Use the file descriptor provided with a connected channel to read and
 write data to the health channel.   The received data needs to be interpreted using a health manager which
 implements the IEEE 11073-xxxxx specifications.
   When done close the health channel by calling  disconnectChannel(BluetoothDevice BluetoothHealthAppConfiguration int) 
 and unregister the application configuration calling
  unregisterAppConfiguration(BluetoothHealthAppConfiguration)","Provides classes that manage Bluetooth functionality such as scanning for
 devices connecting with devices and managing data transfer between devices.
 The Bluetooth API supports both ""Classic Bluetooth"" and Bluetooth Low Energy. For more information about Classic Bluetooth see the
  Bluetooth  guide.
 For more information about Bluetooth Low Energy see the
  
 Bluetooth Low Energy  (BLE) guide. The Bluetooth APIs let applications: Scan for other Bluetooth devices (including BLE devices). Query the local Bluetooth adapter for paired Bluetooth devices. Establish RFCOMM channels/sockets. Connect to specified sockets on other devices. Transfer data to and from other devices. Communicate with BLE devices such as proximity sensors heart rate
     monitors fitness devices and so on. Act as a GATT client or a GATT server (BLE). 
 To perform Bluetooth communication using these APIs an application must
 declare the  BLUETOOTH  permission. Some
 additional functionality such as requesting device discovery
 also requires the  BLUETOOTH_ADMIN 
 permission.
  Note: 
 Not all Android-powered devices provide Bluetooth functionality.",bluetooth,bluetooth,1,yes,no,SOURCE,no,
<android.content.ClipboardManager: ClipDescription getPrimaryClipDescription()>,"Returns a description of the current primary clip on the clipboard
 but not a copy of its data. If the application is not the default IME or does not have input focus this return null .",,ClipDescription |||,11,"Interface to the clipboard service for placing and retrieving text in
 the global clipboard.

  
 The ClipboardManager API itself is very simple: it consists of methods
 to atomically get and set the current primary clipboard data.  That data
 is expressed as a  ClipData  object which defines the protocol
 for data exchange between applications.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",uncategorized,clipboard,1,yes,no,no,no,
<android.inputmethodservice.KeyboardView: void closing()>,,,void,3,"A view that renders a virtual  Keyboard . It handles rendering of keys and
 detecting key presses and touch movements.",,no,no,0,no,no,no,no,
<android.widget.CursorTreeAdapter: void notifyDataSetChanged()>,,,void,1,"An adapter that exposes data from a series of  Cursor s to an
  ExpandableListView  widget. The top-level  Cursor  (that is
 given in the constructor) exposes the groups while subsequent  Cursor s
 returned from  getChildrenCursor(android.database.Cursor)  expose children within a
 particular group. The Cursors must include a column named ""_id"" or this class
 will not work.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,no,0,no,no,no,no,
<android.os.Environment: File getExternalStoragePublicDirectory(String)>,"This method was deprecated
      in API level 29. To improve user privacy direct access to shared/external
             storage devices is deprecated. When an app targets Build.VERSION_CODES.Q the path returned
             from this method is no longer directly accessible to apps.
             Apps can continue to access content stored on shared/external
             storage by migrating to alternatives such as Context#getExternalFilesDir(String)  MediaStore or Intent#ACTION_OPEN_DOCUMENT . Get a top-level shared/external storage directory for placing files of a
 particular type. This is where the user will typically place and manage
 their own files so you should be careful about what you put here to
 ensure you don't erase their files or get in the way of their own
 organization. On devices with multiple users (as described by UserManager )
 each user has their own isolated shared storage. Applications only have
 access to the shared storage for the user they're running as. Here is an example of typical code to manipulate a picture on the public
 shared storage:",type String : The type of storage directory to return. Should be one of DIRECTORY_MUSIC  DIRECTORY_PODCASTS  DIRECTORY_RINGTONES  DIRECTORY_ALARMS  DIRECTORY_NOTIFICATIONS  DIRECTORY_PICTURES  DIRECTORY_MOVIES  DIRECTORY_DOWNLOADS  DIRECTORY_DCIM or DIRECTORY_DOCUMENTS . May not be null. |||,"File Returns the File path for the directory. Note that this directory
         may not yet exist so you must make sure it exists before using
         it such as with File#mkdirs . |||",8,Provides access to environment variables.,,Lots of things,file data,1,yes,no,SOURCE,no,
<android.preference.MultiSelectListPreference: void setEntryValues(int)>,,entryValuesResId int : The entry values array as a resource. |||,void,11,"A  Preference  that displays a list of entries as
 a dialog.
  
 This preference will store a set of strings into the SharedPreferences.
 This set will contain one or more values from the
  setEntryValues(java.lang.CharSequence[])  array.",,no,no,0,no,no,no,no,
"<android.text.Layout: float getDesiredWidth(CharSequence,int,int,TextPaint)>","Return how wide a layout must be in order to display the specified text slice with one
 line per paragraph. As of O Uses TextDirectionHeuristics#FIRSTSTRONG_LTR as the default text direction heuristics. In
 the earlier versions uses TextDirectionHeuristics#LTR as the default.","source CharSequence |||
start int |||
end int |||
paint TextPaint |||",float |||,1,"A base class that manages text layout in visual elements on
 the screen.
  For text that will be edited use a  DynamicLayout 
 which will be updated as the text changes.
 For text that will not change use a  StaticLayout .","Provides classes used to render or track text and text spans on the screen. You can use these classes to design your own widgets that manage text
 to handle arbitrary text spans for changes or to handle drawing yourself
 for an existing widget. The Span… interfaces and classes are used to create or manage spans of
 text in a View item. You can use these to style the text or background or to
 listen for changes. If creating your own widget extend DynamicLayout to manages
 the actual wrapping and drawing of your text.",no,no,0,no,no,no,no,
<android.widget.AutoCompleteTextView: void performCompletion()>,"Performs the text completion by converting the selected item from
 the drop down list into a string replacing the text box's content with
 this string and finally dismissing the drop down menu.",,void,1,"An editable text view that shows completion suggestions automatically
 while the user is typing. The list of suggestions is displayed in a drop
 down menu from which the user can choose an item to replace the content
 of the edit box with. The drop down can be dismissed at any time by pressing the back key or
 if no item is selected in the drop down by pressing the enter/dpad center
 key. The list of suggestions is obtained from a data adapter and appears
 only after a given number of characters defined by
  the threshold . The following code snippet shows how to create a text view which suggests
 various countries names while the user is typing: 
 public class CountriesActivity extends Activity {
     protected void onCreate(Bundle icicle) {
         super.onCreate(icicle);
         setContentView(R.layout.countries);

         ArrayAdapter<String> adapter = new ArrayAdapter<String>(this
                 android.R.layout.simple_dropdown_item_1line COUNTRIES);
         AutoCompleteTextView textView = (AutoCompleteTextView)
                 findViewById(R.id.countries_list);
         textView.setAdapter(adapter);
     }

     private static final String[] COUNTRIES = new String[] {
         ""Belgium"" ""France"" ""Italy"" ""Germany"" ""Spain""
     };
 }
  See the  Text Fields 
 guide.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,no,0,no,no,no,no,
"<android.widget.PopupWindow: void showAtLocation(View,int,int,int)>","Display the content view in a popup window at the specified location. If the popup window
 cannot fit on screen it will be clipped. See WindowManager.LayoutParams for more information on how gravity and the x and y parameters are related. Specifying
 a gravity of Gravity.NO_GRAVITY is similar to specifying Gravity.LEFT | Gravity.TOP .","parent View : a parent view to get the View.getWindowToken() token from |||
gravity int : the gravity which controls the placement of the popup window |||
x int : the popup's x location offset |||
y int : the popup's y location offset |||",void,1,"This class represents a popup window that can be used to display an
 arbitrary view. The popup window is a floating container that appears on top
 of the current activity.
  Animation 
 On all versions of Android popup window enter and exit animations may be
 specified by calling  setAnimationStyle(int)  and passing the
 resource ID for an animation style that defines  windowEnterAnimation 
 and  windowExitAnimation . For example passing
  R.style.Animation_Dialog  will give a scale and alpha
 animation.
 
 A window animation style may also be specified in the popup window's style
 XML via the  popupAnimationStyle 
 attribute.
  
 Starting with API 23 more complex popup window enter and exit transitions
 may be specified by calling either  setEnterTransition(android.transition.Transition) 
 or  setExitTransition(android.transition.Transition)  and passing a   Transition .
 
 Popup enter and exit transitions may also be specified in the popup window's
 style XML via the  popupEnterTransition 
 and  popupExitTransition 
 attributes respectively.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",uncategorized,UI,1,no,yes,no,SINK,
"<android.widget.EditText: void setSelection(int,int)>",Convenience for Selection#setSelection(Spannable int int) .,"start int |||
stop int |||",void,1,"A user interface element for entering and modifying text.
 When you define an edit text widget you must specify the
  R.styleable.TextView_inputType 
 attribute. For example for plain text input set inputType to ""text"":
  
 <EditText
     android:id=""@+id/plain_text_input""
     android:layout_height=""wrap_content""
     android:layout_width=""match_parent""
     android:inputType=""text""/> 
 See the  Text Fields 
 guide for examples of other
  R.styleable.TextView_inputType  settings.
  You also can receive callbacks as a user changes text by
 adding a  TextWatcher  to the edit text.
 This is useful when you want to add auto-save functionality as changes are made
 or validate the format of user input for example.
 You add a text watcher using the  TextView#addTextChangedListener  method.
  
 This widget does not support auto-sizing text.
  XML attributes 
 See  EditText Attributes 
  TextView Attributes 
  View Attributes","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,no,0,no,no,no,no,
<android.os.Bundle: short getShort(String)>,"Returns the value associated with the given key or (short) 0 if
 no mapping of the desired type exists for the given key.",key String : a String |||,short a short value |||,1,A mapping from String keys to various  Parcelable  values.,,IPC,no,0,no,no,no,no,
"<android.content.ContentResolver: Cursor query(Uri,String,String,String,String,CancellationSignal)>","Query the given URI returning a Cursor over the result set
 with optional support for cancellation. For best performance the caller should follow these guidelines: Provide an explicit projection to prevent
 reading data from storage that aren't going to be used. 
Use question mark parameter markers such as 'phone=?' instead of
 explicit values in the selection parameter so that queries
 that differ only by those values will be recognized as the same
 for caching purposes.","uri Uri : The URI using the content:// scheme for the content to
retrieve.
This value must never be null . |||
projection String : A list of which columns to return. Passing null will
return all columns which is inefficient.
This value may be null . |||
selection String : A filter declaring which rows to return formatted as an
SQL WHERE clause (excluding the WHERE itself). Passing null will
return all rows for the given URI.
This value may be null . |||
selectionArgs String : You may include ?s in selection which will be
replaced by the values from selectionArgs in the order that they
appear in the selection. The values will be bound as Strings.
This value may be null . |||
sortOrder String : How to order the rows formatted as an SQL ORDER BY
clause (excluding the ORDER BY itself). Passing null will use the
default sort order which may be unordered.
This value may be null . |||
cancellationSignal CancellationSignal : A signal to cancel the operation in progress or null if none.
If the operation is canceled then OperationCanceledException will be thrown
when the query is executed.
This value may be null . |||",Cursor A Cursor object which is positioned before the first entry. May return null if the underlying content provider returns null or if it crashes. |||,16,This class provides applications access to the content model.,"Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",database data,database,1,yes,no,SOURCE,no,
<android.hardware.display.DisplayManager: Display getDisplay(int)>,"Gets information about a logical display.

 The display metrics may be adjusted to provide compatibility
 for legacy applications.",displayId int : The logical display id. |||,Display The display object or null if there is no valid display with the given id. |||,17,Manages the properties of attached displays.,,no,UI,0,no,no,no,no,
<android.app.backup.BackupManager: int requestRestore(RestoreObserver)>,"This method was deprecated
      in API level 28. Applications shouldn't request a restore operation using this method. In Android
 P and later this method is a no-op. Restore the calling application from backup. The data will be restored from the
 current backup dataset if the application has stored data there or from
 the dataset used during the last full device setup operation if the current
 backup dataset has no matching data.  If no backup data exists for this application
 in either source a non-zero value is returned. If this method returns zero (meaning success) the OS attempts to retrieve a backed-up
 dataset from the remote transport instantiate the application's backup agent and pass the
 dataset to the agent's onRestore() method. Unlike other restore operations this method doesn't terminate the
 application after the restore. The application continues running to receive the RestoreObserver callbacks on the observer argument. Full backups use an Application base class while key-value backups use the
 application subclass declared in the AndroidManifest.xml <application> tag.","observer RestoreObserver : The RestoreObserver to receive callbacks during the restore
operation. This must not be null. |||",int Zero on success; nonzero on error. |||,8,"The interface through which an application interacts with the Android backup service to
 request backup and restore operations.
 Applications instantiate it using the constructor and issue calls through that instance.
  
 When an application has made changes to data which should be backed up a
 call to  dataChanged()  will notify the backup service. The system
 will then schedule a backup operation to occur in the near future. Repeated
 calls to  dataChanged()  have no further effect until the backup
 operation actually occurs.
  
 A backup or restore operation for your application begins when the system launches the
  BackupAgent  subclass you've declared in your manifest. See the
 documentation for  BackupAgent  for a detailed description
 of how the operation then proceeds.
  
 Several attributes affecting the operation of the backup and restore mechanism
 can be set on the  <application> 
 tag in your application's AndroidManifest.xml file.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,file data,0,no,no,no,no,
"<android.app.admin.DevicePolicyManager: void setMaximumFailedPasswordsForWipe(ComponentName,int)>","Setting this to a value greater than zero enables a built-in policy that will perform a
 device or profile wipe after too many incorrect device-unlock passwords have been entered.
 This built-in policy combines watching for failed passwords and wiping the device and
 requires that you request both DeviceAdminInfo#USES_POLICY_WATCH_LOGIN and DeviceAdminInfo#USES_POLICY_WIPE_DATA }. When this policy is set by a device owner profile owner of an organization-owned device or
 an admin on the primary user the device will be factory reset after too many incorrect
 password attempts. When set by a profile owner or an admin on a secondary user or a managed
 profile only the corresponding user or profile will be wiped. To implement any other policy (e.g. wiping data for a particular application only erasing or
 revoking credentials or reporting the failure to a server) you should implement DeviceAdminReceiver#onPasswordFailed(Context android.content.Intent) instead. Do not
 use this API because if the maximum count is reached the device or profile will be wiped
 immediately and your callback will not be invoked. This method can be called on the DevicePolicyManager instance returned by getParentProfileInstance(android.content.ComponentName) in order to set a value on the parent
 profile. On devices not supporting PackageManager#FEATURE_SECURE_LOCK_SCREEN feature the
 password is always empty and this method has no effect - i.e. the policy is not set. Requires the PackageManager#FEATURE_SECURE_LOCK_SCREEN feature which can be detected using PackageManager.hasSystemFeature(String) .","admin ComponentName : Which DeviceAdminReceiver this request is associated with.
This value must never be null . |||
num int : The number of failed password attempts at which point the device or profile will
be wiped. |||",void,8,"Public interface for managing policies enforced on a device. Most clients of this class must be
 registered with the system as a  device
 administrator . Additionally a device administrator may be registered as either a profile or
 device owner. A given method is accessible to all device administrators unless the documentation
 for that method specifies that it is restricted to either device or profile owners. Any
 application calling an api may only pass as an argument a device administrator component it
 owns. Otherwise a  SecurityException  will be thrown.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
<android.hardware.input.InputManager: InputDevice getInputDevice(int)>,Gets information about the input device with the specified id.,id int : The device id. |||,InputDevice The input device or null if not found. |||,16,Provides information about input devices and available key layouts.,,,,0,,,no,no,
<android.os.Bundle: ArrayList getCharSequenceArrayList(String)>,"Returns the value associated with the given key or null if
 no mapping of the desired type exists for the given key or a null
 value is explicitly associated with the key.","key String : a String or null
This value may be null . |||",ArrayList < CharSequence > an ArrayList value or null |||,8,A mapping from String keys to various  Parcelable  values.,,IPC,no,0,no,no,no,no,
<android.app.Fragment: void onStart()>,"Called when the Fragment is visible to the user.  This is generally
 tied to Activity#onStart() of the containing
 Activity's lifecycle. If you override this method you must call through to the
 superclass implementation.",,void,11,"A Fragment is a piece of an application's user interface or behavior
 that can be placed in an  Activity .  Interaction with fragments
 is done through  FragmentManager  which can be obtained via
  Activity#getFragmentManager()  and
  Fragment#getFragmentManager() .

  The Fragment class can be used many ways to achieve a wide variety of
 results. In its core it represents a particular operation or interface
 that is running within a larger  Activity .  A Fragment is closely
 tied to the Activity it is in and can not be used apart from one.  Though
 Fragment defines its own lifecycle that lifecycle is dependent on its
 activity: if the activity is stopped no fragments inside of it can be
 started; when the activity is destroyed all fragments will be destroyed.

  All subclasses of Fragment must include a public no-argument constructor.
 The framework will often re-instantiate a fragment class when needed
 in particular during state restore and needs to be able to find this
 constructor to instantiate it.  If the no-argument constructor is not
 available a runtime exception will occur in some cases during state
 restore.

  Topics covered here:
  Older Platforms Lifecycle Layout Back Stack","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
<android.widget.SlidingDrawer: void toggle()>,Toggles the drawer open and close. Takes effect immediately.,,void,3,"SlidingDrawer hides content out of the screen and allows the user to drag a handle
 to bring the content on screen. SlidingDrawer can be used vertically or horizontally.

 A special widget composed of two children views: the handle that the users drags
 and the content attached to the handle and dragged with it.

 SlidingDrawer should be used as an overlay inside layouts. This means SlidingDrawer
 should only be used inside of a FrameLayout or a RelativeLayout for instance. The
 size of the SlidingDrawer defines how much space the content will occupy once slid
 out so SlidingDrawer should usually use match_parent for both its dimensions.

 Inside an XML layout SlidingDrawer must define the id of the handle and of the
 content:

  
 <SlidingDrawer
     android:id=""@+id/drawer""
     android:layout_width=""match_parent""
     android:layout_height=""match_parent""

     android:handle=""@+id/handle""
     android:content=""@+id/content"">

     <ImageView
         android:id=""@id/handle""
         android:layout_width=""88dip""
         android:layout_height=""44dip"" />

     <GridView
         android:id=""@id/content""
         android:layout_width=""match_parent""
         android:layout_height=""match_parent"" />

 </SlidingDrawer>","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,no,0,no,no,no,no,
<android.app.ProgressDialog: void setMax(int)>,Sets the maximum allowed progress value.,max int |||,void,1,"A dialog showing a progress indicator and an optional text message or view.
 Only a text message or a view can be used at the same time.

  The dialog can be made cancelable on back key press. The progress range is 0 to  max .","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
"<android.content.ContentResolver: int update(Uri,ContentValues,String,String)>","Update row(s) in a content URI.

 If the content provider supports transactions the update will be atomic.","uri Uri : The URI to modify.
This value must never be null . |||
values ContentValues : The new field values. The key is the column name for the field.
A null value will remove an existing field value.
This value may be null . |||
where String : A filter to apply to rows before updating formatted as an SQL WHERE clause
(excluding the WHERE itself).
This value may be null . |||
selectionArgs String : This value may be null . |||",int the number of rows updated. |||,1,This class provides applications access to the content model.,"Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",database data,database,1,no,yes,no,SINK,
<android.app.admin.DevicePolicyManager: List getActiveAdmins()>,"Return a list of all currently active device administrators' component
 names.  If there are no administrators null may be
 returned.",,List < ComponentName > |||,8,"Public interface for managing policies enforced on a device. Most clients of this class must be
 registered with the system as a  device
 administrator . Additionally a device administrator may be registered as either a profile or
 device owner. A given method is accessible to all device administrators unless the documentation
 for that method specifies that it is restricted to either device or profile owners. Any
 application calling an api may only pass as an argument a device administrator component it
 owns. Otherwise a  SecurityException  will be thrown.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",admin info,admin storage file,1,yes,no,SOURCE,no,
<android.telephony.TelephonyManager: int getDataState()>,"Returns a constant indicating the current data connection state
 (cellular).",,int |||,1,"Provides access to information about the telephony services on
 the device. Applications can use the methods in this class to
 determine telephony services and states as well as to access some
 types of subscriber information. Applications can also register
 a listener to receive notification of telephony state changes.
  
 The returned TelephonyManager will use the default subscription for all calls.
 To call an API for a specific subscription use  createForSubscriptionId(int) . e.g.
  
   telephonyManager = defaultSubTelephonyManager.createForSubscriptionId(subId);
  
 Note that access to some telephony information is
 permission-protected. Your application cannot access the protected
 information unless it has the appropriate permissions declared in
 its manifest file. Where permissions apply they are noted in the
 the methods through which you access the protected information.",,phone metadata,phone,1,yes,no,SOURCE,no,example of sensitive constant
"<android.graphics.drawable.Drawable: void inflate(Resources,XmlPullParser,AttributeSet)>",Inflate this Drawable from an XML resource. Does not apply a theme.,"r Resources : This value must never be null . |||
parser XmlPullParser : This value must never be null . |||
attrs AttributeSet : This value must never be null . |||",void,1,"A Drawable is a general abstraction for ""something that can be drawn.""  Most
 often you will deal with Drawable as the type of resource retrieved for
 drawing things to the screen; the Drawable class provides a generic API for
 dealing with an underlying visual resource that may take a variety of forms.
 Unlike a  View  a Drawable does not have any facility to
 receive events or otherwise interact with the user.

  In addition to simple drawing Drawable provides a number of generic
 mechanisms for its client to interact with what is being drawn:

   The  setBounds(Rect)  method  must  be called to tell the
     Drawable where it is drawn and how large it should be.  All Drawables
     should respect the requested size often simply by scaling their
     imagery.  A client can find the preferred size for some Drawables with
     the  getIntrinsicHeight()  and  getIntrinsicWidth()  methods.

       The  getPadding(Rect)  method can return from some Drawables
     information about how to frame content that is placed inside of them.
     For example a Drawable that is intended to be the frame for a button
     widget would need to return padding that correctly places the label
     inside of itself.

       The  setState(int[])  method allows the client to tell the Drawable
     in which state it is to be drawn such as ""focused"" ""selected"" etc.
     Some drawables may modify their imagery based on the selected state.

       The  setLevel(int)  method allows the client to supply a single
     continuous controller that can modify the Drawable is displayed such as
     a battery level or progress level.  Some drawables may modify their
     imagery based on the current level.

       A Drawable can perform animations by calling back to its client
     through the  Callback  interface.  All clients should support this
     interface (via  setCallback(Drawable.Callback) ) so that animations will work.  A
     simple way to do this is through the system facilities such as
      View.setBackground(Drawable)  and
      ImageView .
  Bitmap : the simplest Drawable a PNG or JPEG image.
      Nine Patch : an extension to the PNG format allows it to
     specify information about how to stretch it and place things inside of
     it.
      Vector : a drawable defined in an XML file as a set of points
     lines and curves along with its associated color information. This type
     of drawable can be scaled without loss of display quality.
      Shape : contains simple drawing commands instead of a raw
     bitmap allowing it to resize better in some cases.
      Layers : a compound drawable which draws multiple underlying
     drawables on top of each other.
      States : a compound drawable that selects one of a set of
     drawables based on its state.
      Levels : a compound drawable that selects one of a set of
     drawables based on its level.
      Scale : a compound drawable with a single child drawable
     whose overall size is modified based on the current level.
  Custom drawables 
 All versions of Android allow the Drawable class to be extended and used at
 run time in place of framework-provided drawable classes. Starting in
  API 24  custom drawables classes
 may also be used in XML.
  Note:  Custom drawable classes are only accessible from
 within your application package. Other applications will not be able to load
 them.
  
 At a minimum custom drawable classes must implement the abstract methods on
 Drawable and should override the  Drawable#draw(Canvas)  method to
 draw content.
  
 Custom drawables classes may be used in XML in multiple ways:
  
         Using the fully-qualified class name as the XML element name. For
         this method the custom drawable class must be a public top-level
         class.
  
 <com.myapp.MyCustomDrawable xmlns:android=""http://schemas.android.com/apk/res/android""
     android:color=""#ffff0000"" />
  
         Using  drawable  as the XML element name and specifying the
         fully-qualified class name from the  class  attribute. This
         method may be used for both public top-level classes and public
         static inner classes.
  
 <drawable xmlns:android=""http://schemas.android.com/apk/res/android""
     class=""com.myapp.MyTopLevelClass$InnerCustomDrawable""
     android:color=""#ffff0000"" />",,no,UI,0,no,no,no,no,app resource is not mutable at runtime so I don't think it's an uncategorized sensitive data type
<android.app.Activity: Object getSystemService(String)>,"Return the handle to a system-level service by name. The class of the
 returned object varies by the requested name. Currently available names
 are: Note:  System services obtained via this API may be closely associated with
 the Context in which they are obtained from.  In general do not share the
 service objects between various different contexts (Activities Applications
 Services Providers etc.) Note: Instant apps for which PackageManager#isInstantApp() returns true
 don't have access to the following system services: DEVICE_POLICY_SERVICE  FINGERPRINT_SERVICE  KEYGUARD_SERVICE  SHORTCUT_SERVICE  USB_SERVICE  WALLPAPER_SERVICE  WIFI_P2P_SERVICE  WIFI_SERVICE  WIFI_AWARE_SERVICE . For these services this method will
 return null .  Generally if you are running as an instant app you should always
 check whether the result of this method is null . Note: When implementing this method keep in mind that new services can be added on newer
 Android releases so if you're looking for just the explicit names mentioned above make sure
 to return null when you don't recognize the name — if you throw a RuntimeException exception instead you're app might break on new Android releases.","name String : Value is Context.POWER_SERVICE  Context.WINDOW_SERVICE  Context.LAYOUT_INFLATER_SERVICE  Context.ACCOUNT_SERVICE  Context.ACTIVITY_SERVICE  Context.ALARM_SERVICE  Context.NOTIFICATION_SERVICE  Context.ACCESSIBILITY_SERVICE  Context.CAPTIONING_SERVICE  Context.KEYGUARD_SERVICE  Context.LOCATION_SERVICE  Context.SEARCH_SERVICE  Context.SENSOR_SERVICE android.content.Context.SENSOR_PRIVACY_SERVICE Context.STORAGE_SERVICE  Context.STORAGE_STATS_SERVICE  Context.WALLPAPER_SERVICE android.content.Context.TIME_ZONE_RULES_MANAGER_SERVICE Context.VIBRATOR_SERVICE  Context.CONNECTIVITY_SERVICE  Context.IPSEC_SERVICE  Context.VPN_MANAGEMENT_SERVICE android.content.Context.TEST_NETWORK_SERVICE Context.NETWORK_STATS_SERVICE  Context.WIFI_SERVICE  Context.WIFI_AWARE_SERVICE  Context.WIFI_P2P_SERVICE android.content.Context.WIFI_SCANNING_SERVICE Context.WIFI_RTT_RANGING_SERVICE  Context.NSD_SERVICE  Context.AUDIO_SERVICE android.content.Context.AUTH_SERVICE Context.FINGERPRINT_SERVICE  Context.BIOMETRIC_SERVICE  Context.MEDIA_ROUTER_SERVICE  Context.TELEPHONY_SERVICE  Context.TELEPHONY_SUBSCRIPTION_SERVICE  Context.CARRIER_CONFIG_SERVICE  Context.EUICC_SERVICE  Context.MMS_SERVICE  Context.TELECOM_SERVICE  Context.CLIPBOARD_SERVICE  Context.INPUT_METHOD_SERVICE  Context.TEXT_SERVICES_MANAGER_SERVICE  Context.TEXT_CLASSIFICATION_SERVICE  Context.APPWIDGET_SERVICE android.content.Context.ROLLBACK_SERVICE Context.DROPBOX_SERVICE  Context.DEVICE_POLICY_SERVICE  Context.UI_MODE_SERVICE  Context.DOWNLOAD_SERVICE  Context.NFC_SERVICE  Context.BLUETOOTH_SERVICE  Context.USB_SERVICE  Context.LAUNCHER_APPS_SERVICE  Context.INPUT_SERVICE  Context.DISPLAY_SERVICE  Context.USER_SERVICE  Context.RESTRICTIONS_SERVICE  Context.APP_OPS_SERVICE  Context.ROLE_SERVICE  Context.CAMERA_SERVICE  Context.PRINT_SERVICE  Context.CONSUMER_IR_SERVICE  Context.TV_INPUT_SERVICE  Context.USAGE_STATS_SERVICE  Context.MEDIA_SESSION_SERVICE  Context.BATTERY_SERVICE  Context.JOB_SCHEDULER_SERVICE  Context.MEDIA_PROJECTION_SERVICE  Context.MIDI_SERVICE android.content.Context.RADIO_SERVICE Context.HARDWARE_PROPERTIES_SERVICE  Context.SHORTCUT_SERVICE  Context.SYSTEM_HEALTH_SERVICE  Context.COMPANION_DEVICE_SERVICE  Context.CROSS_PROFILE_APPS_SERVICE android.content.Context.PERMISSION_SERVICE or android.content.Context.LIGHTS_SERVICE
This value must never be null . |||",Object The service or null if the name does not exist. |||,1,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",IPC,IPC,1,yes,no,SOURCE,no,
<android.os.CountDownTimer: CountDownTimer start()>,Start the countdown.,,CountDownTimer |||,1,"Schedule a countdown until a time in the future with
 regular notifications on intervals along the way.

 Example of showing a 30 second countdown in a text field:

  
 new CountDownTimer(30000 1000) {

     public void onTick(long millisUntilFinished) {
         mTextField.setText(""seconds remaining: "" + millisUntilFinished / 1000);
     }

     public void onFinish() {
         mTextField.setText(""done!"");
     }
  }.start();
  onTick(long) onTick(long) onTick(long)",,no,no,0,no,no,no,no,
<android.speech.tts.TextToSpeech: int setEngineByPackageName(String)>,"This method was deprecated
      in API level 15. This doesn't inform callers when the TTS engine has been
        initialized. TextToSpeech(android.content.Context android.speech.tts.TextToSpeech.OnInitListener java.lang.String) can be used with the appropriate engine name. Also there is no
        guarantee that the engine specified will be loaded. If it isn't
        installed or disabled the user / system wide defaults will apply. Sets the TTS engine to use.","enginePackageName String : The package name for the synthesis engine (e.g. ""com.svox.pico"") |||",int ERROR or SUCCESS . |||,8,"Synthesizes speech from text for immediate playback or to create a sound file.
  A TextToSpeech instance can only be used to synthesize text once it has completed its
 initialization. Implement the  TextToSpeech.OnInitListener  to be
 notified of the completion of the initialization. 
 When you are done using the TextToSpeech instance call the  shutdown()  method
 to release the native resources used by the TextToSpeech engine.",,no,no,0,no,no,no,no,
<android.os.Bundle: CharSequence getCharSequence(String)>,"Returns the value associated with the given key or null if
 no mapping of the desired type exists for the given key or a null
 value is explicitly associated with the key.","key String : a String or null
This value may be null . |||",CharSequence a CharSequence value or null |||,1,A mapping from String keys to various  Parcelable  values.,,IPC,no,0,no,no,no,no,
"<android.content.Intent: Intent putExtra(String,boolean)>","Add extended data to the intent.  The name must include a package
 prefix for example the app com.android.contacts would use names
 like ""com.android.contacts.ShowAll"".","name String : The name of the extra data with package prefix. |||
value boolean : The boolean data value. |||","Intent Returns the same Intent object for chaining multiple calls
 into a single statement.

 This value will never be null . |||",1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",IPC,no,0,no,no,no,no,
<android.view.animation.AnimationUtils: Animation makeInChildBottomAnimation(Context)>,"Make an animation for objects becoming visible. Uses a slide up and fade
 effect.",c Context : Context for loading resources |||,Animation The new animation |||,1,"Abstraction for an Animation that can be applied to Views Surfaces or
 other objects. See the  animation package
 description file .",,no,no,0,no,no,no,no,
<android.view.Window: void setBackgroundDrawableResource(int)>,"Change the background of this window to a Drawable resource. Setting the
 background to null will make the window be opaque. To make the window
 transparent you can use an empty drawable (for instance a ColorDrawable
 with the color 0 or the system drawable android:drawable/empty.)","resId int : The resource identifier of a drawable resource which will
be installed as the new background. |||",void,1,"Abstract base class for a top-level window look and behavior policy.  An
 instance of this class should be used as the top-level view added to the
 window manager. It provides standard UI policies such as a background title
 area default key processing etc.

  The only existing implementation of this abstract class is
 android.view.PhoneWindow which you should instantiate when needing a
 Window.",,no,UI,0,no,no,no,no,
<android.net.wifi.WifiManager: List getConfiguredNetworks()>,"This method was deprecated
      in API level 29. a) See WifiNetworkSpecifier.Builder#build() for new
 mechanism to trigger connection to a Wi-Fi network.
 b) See addNetworkSuggestions(java.util.List)  removeNetworkSuggestions(java.util.List) for new API to add Wi-Fi networks for consideration
 when auto-connecting to wifi. Compatibility Note: For applications targeting Build.VERSION_CODES.Q or above this API will always fail and return an
 empty list. Deprecation Exemptions: Device Owner (DO) Profile Owner (PO) and system apps will have access to the full list. 
Callers with Carrier privilege will receive a restricted list only containing
 configurations which they created. 
Return a list of all the networks configured for the current foreground
 user.

 Not all fields of WifiConfiguration are returned. Only the following
 fields are filled in: networkId 
SSID 
BSSID 
priority 
allowedProtocols 
allowedKeyManagement 
allowedAuthAlgorithms 
allowedPairwiseCiphers 
allowedGroupCiphers 
status",,"List < WifiConfiguration > a list of network configurations in the form of a list
 of WifiConfiguration objects. |||",1,"This class provides the primary API for managing all aspects of Wi-Fi
 connectivity.
  
 On releases before  Build.VERSION_CODES.N  this object
 should only be obtained from an  Context#getApplicationContext()  and not from any other derived context to avoid memory
 leaks within the calling process.
  
 It deals with several categories of items:
  The list of configured networks. The list can be viewed and updated and
 attributes of individual entries can be modified. The currently active Wi-Fi network if any. Connectivity can be
 established or torn down and dynamic information about the state of the
 network can be queried. Results of access point scans containing enough information to make
 decisions about what access point to connect to. It defines the names of various Intent actions that are broadcast upon
 any sort of change in Wi-Fi state.
  
 This is the API to use when performing Wi-Fi specific operations. To perform
 operations that pertain to network connectivity at an abstract level use
  ConnectivityManager .","Provides classes to manage Wi-Fi functionality on the device. The Wi-Fi APIs provide a means by which applications can communicate
 with the lower-level wireless stack that provides Wi-Fi network access. Almost all
 information from the device supplicant is available including the connected network's
 link speed IP address negotiation state and more plus information about other
 networks that are available. Some other API features include the ability to
 scan add save terminate and initiate Wi-Fi connections. Some APIs may require the following user permissions: ACCESS_WIFI_STATE CHANGE_WIFI_STATE CHANGE_WIFI_MULTICAST_STATE Note:  Not all Android-powered devices provide Wi-Fi functionality.
 If your application uses Wi-Fi declare so with a  <uses-feature> 
 element in the manifest file: 
 <manifest ...>
     <uses-feature android:name=""android.hardware.wifi"" />
     ...
 </manifest>",network info,network ,1,yes,no,SOURCE,no,
<android.content.ContextWrapper: void startActivities(Intent)>,"Same as startActivities(android.content.Intent[] android.os.Bundle) with no options
 specified.",intents Intent : An array of Intents to be started. |||,void,11,"Proxying implementation of Context that simply delegates all of its calls to
 another Context.  Can be subclassed to modify behavior without changing
 the original Context.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",IPC,IPC,1,no,yes,no,SINK,
<android.content.pm.PackageItemInfo: Drawable loadIcon(PackageManager)>,"Retrieve the current graphical icon associated with this item.  This
 will call back on the given PackageManager to load the icon from
 the application.","pm PackageManager : A PackageManager from which the icon can be loaded; usually
the PackageManager from which you originally retrieved this item. |||","Drawable Returns a Drawable containing the item's icon.  If the
 item does not have an icon the item's default icon is returned
 such as the default activity icon. |||",1,"Base class containing information common to all package items held by
 the package manager.  This provides a very common basic set of attributes:
 a label icon and meta-data.  This class is not intended
 to be used by itself; it is simply here to share common definitions
 between all items returned by the package manager.  As such it does not
 itself implement Parcelable but does provide convenience methods to assist
 in the implementation of Parcelable in subclasses.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,
"<android.app.Instrumentation: Activity newActivity(Class,Context,IBinder,Application,Intent,ActivityInfo,CharSequence,Activity,String,Object)>","Perform instantiation of an Activity object.  This method is intended for use with
 unit tests such as android.test.ActivityUnitTestCase.  The activity will be useable
 locally but will be missing some of the linkages necessary for use within the system.","clazz Class : The Class of the desired Activity |||
context Context : The base context for the activity to use |||
token IBinder : The token for this activity to communicate with |||
application Application : The application object (if any) |||
intent Intent : The intent that started this Activity |||
info ActivityInfo : ActivityInfo from the manifest |||
title CharSequence : The title typically retrieved from the ActivityInfo record |||
parent Activity : The parent Activity (if any) |||
id String : The embedded Id (if any) |||
lastNonConfigurationInstance Object : Arbitrary object that will be
available via Activity#getLastNonConfigurationInstance() . |||",Activity Returns the instantiated activity |||,1,"Base class for implementing application instrumentation code.  When running
 with instrumentation turned on this class will be instantiated for you
 before any of the application code allowing you to monitor all of the
 interaction the system has with the application.  An Instrumentation
 implementation is described to the system through an AndroidManifest.xml's
 <instrumentation> tag.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
"<android.os.Bundle: short getShort(String,short)>","Returns the value associated with the given key or defaultValue if
 no mapping of the desired type exists for the given key.","key String : a String |||
defaultValue short : Value to return if key does not exist |||",short a short value |||,1,A mapping from String keys to various  Parcelable  values.,,IPC,no,0,no,no,no,no,
<android.app.TaskStackBuilder: TaskStackBuilder addParentStack(ComponentName)>,"Add the activity parent chain as specified by the parentActivityName attribute of the activity
 (or activity-alias) element in the application's manifest to the task stack builder.","sourceActivityName ComponentName : Must specify an Activity component. All parents of
this activity will be added |||",TaskStackBuilder This TaskStackBuilder for method chaining |||,16,"Utility class for constructing synthetic back stacks for cross-task navigation
 on Android 3.0 and newer.

  In API level 11 (Android 3.0/Honeycomb) the recommended conventions for
 app navigation using the back key changed. The back key's behavior is local
 to the current task and does not capture navigation across different tasks.
 Navigating across tasks and easily reaching the previous task is accomplished
 through the ""recents"" UI accessible through the software-provided Recents key
 on the navigation or system bar. On devices with the older hardware button configuration
 the recents UI can be accessed with a long press on the Home key. When crossing from one task stack to another post-Android 3.0
 the application should synthesize a back stack/history for the new task so that
 the user may navigate out of the new task and back to the Launcher by repeated
 presses of the back key. Back key presses should not navigate across task stacks. TaskStackBuilder provides a way to obey the correct conventions
 around cross-task navigation.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
<android.widget.AdapterViewAnimator: void onRestoreInstanceState(Parcelable)>,"Hook allowing a view to re-apply a representation of its internal state that had previously
 been generated by onSaveInstanceState() . This function will never be called with a
 null state. If you override this method you must call through to the
 superclass implementation.",state Parcelable : The frozen state that had previously been returned by onSaveInstanceState() . |||,void,11,"An AdapterView is a view whose children are determined by an  Adapter .

  
 See  ListView   GridView   Spinner  and
       Gallery  for commonly used subclasses of AdapterView.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",IPC,no,0,no,no,no,no,
<android.text.format.DateFormat: char getDateFormatOrder(Context)>,"Gets the current date format stored as a char array. Returns a 3 element
 array containing the day ( 'd' ) month ( 'M' ) and year ( 'y' ))
 in the order specified by the user's format preference.  Note that this order is only appropriate for all-numeric dates; spelled-out (MEDIUM and LONG)
 dates will generally contain other punctuation spaces or words
 not just the day month and year and not necessarily in the same
 order returned here.",context Context |||,char[] |||,3,"Utility class for producing strings with formatted date/time.

  Most callers should avoid supplying their own format strings to this
 class'  format  methods and rely on the correctly localized ones
 supplied by the system. This class' factory methods return
 appropriately-localized  DateFormat  instances suitable
 for both formatting and parsing dates. For the canonical documentation
 of format strings see  SimpleDateFormat .

  In cases where the system does not provide a suitable pattern
 this class offers the  getBestDateTimePattern(Locale String)  method.

  The  format  methods in this class implement a subset of Unicode
  UTS #35  patterns.
 The subset currently supported by this class includes the following format characters:
  acdEHhLKkLMmsyz . Up to API level 17 only  adEhkMmszy  were supported.
 Note that this class incorrectly implements  k  as if it were  H  for backwards
 compatibility.

  See  SimpleDateFormat  for more documentation
 about patterns or if you need a more complete or correct implementation.
 Note that the non- format  methods in this class are implemented by
  SimpleDateFormat .","Provides classes used to render or track text and text spans on the screen. You can use these classes to design your own widgets that manage text
 to handle arbitrary text spans for changes or to handle drawing yourself
 for an existing widget. The Span… interfaces and classes are used to create or manage spans of
 text in a View item. You can use these to style the text or background or to
 listen for changes. If creating your own widget extend DynamicLayout to manages
 the actual wrapping and drawing of your text.",no,no,0,no,no,no,no,
<android.text.Layout: float getLineRight(int)>,"Get the rightmost position that should be exposed for horizontal
 scrolling on the specified line.",line int |||,float |||,1,"A base class that manages text layout in visual elements on
 the screen.
  For text that will be edited use a  DynamicLayout 
 which will be updated as the text changes.
 For text that will not change use a  StaticLayout .","Provides classes used to render or track text and text spans on the screen. You can use these classes to design your own widgets that manage text
 to handle arbitrary text spans for changes or to handle drawing yourself
 for an existing widget. The Span… interfaces and classes are used to create or manage spans of
 text in a View item. You can use these to style the text or background or to
 listen for changes. If creating your own widget extend DynamicLayout to manages
 the actual wrapping and drawing of your text.",no,UI,0,no,no,no,no,
<android.widget.VideoView: void suspend()>,,,void,8,"Displays a video file.  The VideoView class
 can load images from various sources (such as resources or content
 providers) takes care of computing its measurement from the video so that
 it can be used in any layout manager and provides various display options
 such as scaling and tinting. Note: VideoView does not retain its full state when going into the
 background.   In particular it does not restore the current play state
 play position selected tracks or any subtitle tracks added via
  addSubtitleSource() .  Applications should
 save and restore these on their own in
  Activity.onSaveInstanceState(Bundle)  and
  Activity.onRestoreInstanceState(Bundle) . 
 Also note that the audio session id (from  getAudioSessionId() ) may
 change from its previously returned value when the VideoView is restored.
  
 By default VideoView requests audio focus with  AudioManager#AUDIOFOCUS_GAIN . Use
  setAudioFocusRequest(int)  to change this behavior.
  
 The default  AudioAttributes  used during playback have a usage of
  AudioAttributes#USAGE_MEDIA  and a content type of
  AudioAttributes#CONTENT_TYPE_MOVIE  use  setAudioAttributes(android.media.AudioAttributes)  to
 modify them.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,no,0,no,no,no,no,
"<android.widget.TextView: void setError(CharSequence,Drawable)>","Sets the right-hand compound drawable of the TextView to the specified
 icon and sets an error message that will be displayed in a popup when
 the TextView has focus.  The icon and error message will be reset to
 null when any key events cause changes to the TextView's text.  The
 drawable must already have had Drawable#setBounds set on it.
 If the error is null the error message will
 be cleared (and you should provide a null icon as well).","error CharSequence |||
icon Drawable |||",void,1,"A user interface element that displays text to the user.
 To provide user-editable text see  EditText .
  
 The following code sample shows a typical use with an XML layout
 and code to modify the contents of the text view:
  
 <LinearLayout
      xmlns:android=""http://schemas.android.com/apk/res/android""
      android:layout_width=""match_parent""
      android:layout_height=""match_parent"">
    <TextView
        android:id=""@+id/text_view_id""
        android:layout_height=""wrap_content""
        android:layout_width=""wrap_content""
        android:text=""@string/hello"" />
 </LinearLayout>
  
 This code sample demonstrates how to modify the contents of the text view
 defined in the previous XML layout:
  
 public class MainActivity extends Activity {

    protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_main);
         final TextView helloTextView = (TextView) findViewById(R.id.text_view_id);
         helloTextView.setText(R.string.user_greeting);
     }
 }
  
 To customize the appearance of TextView see  Styles and Themes .
  XML attributes 
 See  TextView Attributes 
  View Attributes","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",uncategorized,UI,1,no,yes,no,SINK,
<android.accounts.AccountManager: AuthenticatorDescription getAuthenticatorTypes()>,Lists the currently registered authenticators. It is safe to call this method from the main thread. No permission is required to call this method.,,"AuthenticatorDescription[] An array of AuthenticatorDescription for every
     authenticator known to the AccountManager service.  Empty (never
     null) if no authenticators are known. |||",5,"This class provides access to a centralized registry of the user's
 online accounts.  The user enters credentials (username and password) once
 per account granting applications access to online resources with
 ""one-click"" approval.

  Different online services have different ways of handling accounts and
 authentication so the account manager uses pluggable  authenticator 
 modules for different  account types .  Authenticators (which may be
 written by third parties) handle the actual details of validating account
 credentials and storing account information.  For example Google Facebook
 and Microsoft Exchange each have their own authenticator.

  Many servers support some notion of an  authentication token 
 which can be used to authenticate a request to the server without sending
 the user's actual password.  (Auth tokens are normally created with a
 separate request which does include the user's credentials.)  AccountManager
 can generate auth tokens for applications so the application doesn't need to
 handle passwords directly.  Auth tokens are normally reusable and cached by
 AccountManager but must be refreshed periodically.  It's the responsibility
 of applications to  invalidate  auth tokens when they stop working so
 the AccountManager knows it needs to regenerate them.

  Applications accessing a server normally go through these steps:

  Get an instance of AccountManager using  get(android.content.Context) .

  List the available accounts using  getAccountsByType(String)  or
  getAccountsByTypeAndFeatures(String String[] AccountManagerCallback  Handler) .  Normally applications will only
 be interested in accounts with one particular  type  which
 identifies the authenticator.  Account  features  are used to
 identify particular account subtypes and capabilities.  Both the account
 type and features are authenticator-specific strings and must be known by
 the application in coordination with its preferred authenticators.

  Select one or more of the available accounts possibly by asking the
 user for their preference.  If no suitable accounts are available
  addAccount(String String String[] Bundle Activity AccountManagerCallback  Handler)  may be called to prompt the user to create an
 account of the appropriate type.

  Important:  If the application is using a previously remembered
 account selection it must make sure the account is still in the list
 of accounts returned by  getAccountsByType(String) .  Requesting an auth token
 for an account no longer on the device results in an undefined failure.

  Request an auth token for the selected account(s) using one of the
  getAuthToken(Account String Bundle Activity AccountManagerCallback  Handler)  methods or related helpers.  Refer to the description
 of each method for exact usage and error handling details.

  Make the request using the auth token.  The form of the auth token
 the format of the request and the protocol used are all specific to the
 service you are accessing.  The application may use whatever network and
 protocol libraries are useful.

  Important:  If the request fails with an authentication error
 it could be that a cached auth token is stale and no longer honored by
 the server.  The application must call  invalidateAuthToken(String String)  to remove
 the token from the cache otherwise requests will continue failing!  After
 invalidating the auth token immediately go back to the ""Request an auth
 token"" step above.  If the process fails the second time then it can be
 treated as a ""genuine"" authentication failure and the user notified or other
 appropriate actions taken.
  Some AccountManager methods may need to interact with the user to
 prompt for credentials present options or ask the user to add an account.
 The caller may choose whether to allow AccountManager to directly launch the
 necessary user interface and wait for the user or to return an Intent which
 the caller may use to launch the interface or (in some cases) to install a
 notification which the user can select at any time to launch the interface.
 To have AccountManager launch the interface directly the caller must supply
 the current foreground  Activity  context.

  Many AccountManager methods take  AccountManagerCallback  and
  Handler  as parameters.  These methods return immediately and
 run asynchronously. If a callback is provided then
  AccountManagerCallback#run  will be invoked on the Handler's
 thread when the request completes successfully or not.
 The result is retrieved by calling  AccountManagerFuture#getResult() 
 on the  AccountManagerFuture  returned by the method (and also passed
 to the callback).  This method waits for the operation to complete (if
 necessary) and either returns the result or throws an exception if an error
 occurred during the operation.  To make the request synchronously call
  AccountManagerFuture#getResult()  immediately on receiving the
 future from the method; no callback need be supplied.

  Requests which may block including
  AccountManagerFuture#getResult()  must never be called on
 the application's main event thread.  These operations throw
  IllegalStateException  if they are used on the main thread.",,account info,account info storage file,1,yes,no,SOURCE,no,
"<android.view.animation.AnimationUtils: Animation loadAnimation(Context,int)>",Loads an Animation object from a resource,"context Context : Application context used to access resources |||
id int : The resource id of the animation to load |||",Animation The animation object referenced by the specified id |||,1,"Abstraction for an Animation that can be applied to Views Surfaces or
 other objects. See the  animation package
 description file .",,no,UI,0,no,no,no,no,
"<android.os.DropBoxManager: void addText(String,String)>","Stores human-readable text.  The data may be discarded eventually (or even
 immediately) if space is limited or ignored entirely if the tag has been
 blocked (see isTagEnabled(String) ).","tag String : describing the type of entry being stored |||
data String : value to store |||",void,8,"Enqueues chunks of data (from various sources -- applic ation crashes kernel
 log records etc.).  The queue is size bounded and will drop old data if the
 enqueued data exceeds the maximum size.  You can think of this as a
 persistent system-wide blob-oriented ""logcat"".

  DropBoxManager entries are not sent anywhere directly but other system
 services and debugging tools may scan and upload entries for processing.",,uncategorized,IPC,1,no,yes,no,SINK,
<android.view.ViewGroup: void dispatchSystemUiVisibilityChanged(int)>,"This method is deprecated. Use WindowInsets#isVisible(int) to find out about system bar visibilities
 by setting a OnApplyWindowInsetsListener on this view. Dispatch callbacks to setOnSystemUiVisibilityChangeListener(View.OnSystemUiVisibilityChangeListener) down
 the view hierarchy.",visible int |||,void,11,"A  ViewGroup  is a special view that can contain other views
 (called children.) The view group is the base class for layouts and views
 containers. This class also defines the
  ViewGroup.LayoutParams  class which serves as the base
 class for layouts parameters.
  
 Also see  LayoutParams  for layout attributes.",,no,callback,0,no,no,no,no,
"<android.nfc.NfcAdapter: void setNdefPushMessage(NdefMessage,Activity,Activity)>","This method was deprecated
      in API level 29. this feature is deprecated. File sharing can work using other technology like
 Bluetooth. Set a static NdefMessage to send using Android Beam (TM). This method may be called at any time before Activity#onDestroy but the NDEF message is only made available for NDEF push when the
 specified activity(s) are in resumed (foreground) state. The recommended
 approach is to call this method during your Activity's Activity#onCreate - see sample
 code below. This method does not immediately perform any I/O or blocking work
 so is safe to call on your main thread. Only one NDEF message can be pushed by the currently resumed activity.
 If both setNdefPushMessage(NdefMessage Activity Activity...) and setNdefPushMessageCallback(NfcAdapter.CreateNdefMessageCallback Activity Activity...) are set then
 the callback will take priority. If neither setNdefPushMessage(NdefMessage Activity Activity...) or setNdefPushMessageCallback(NfcAdapter.CreateNdefMessageCallback Activity Activity...) have been called for your activity then
 the Android OS may choose to send a default NDEF message on your behalf
 such as a URI for your application. If setNdefPushMessage(NdefMessage Activity Activity...) is called with a null NDEF message
 and/or setNdefPushMessageCallback(NfcAdapter.CreateNdefMessageCallback Activity Activity...) is called with a null callback
 then NDEF push will be completely disabled for the specified activity(s).
 This also disables any default NDEF message the Android OS would have
 otherwise sent on your behalf for those activity(s). If you want to prevent the Android OS from sending default NDEF
 messages completely (for all activities) you can include a <meta-data> element inside the <application> element of your AndroidManifest.xml file like this: The API allows for multiple activities to be specified at a time
 but it is strongly recommended to just register one at a time
 and to do so during the activity's Activity#onCreate . For example: If your Activity wants to dynamically generate an NDEF message
 then set a callback using setNdefPushMessageCallback(NfcAdapter.CreateNdefMessageCallback Activity Activity...) instead
 of a static message. Do not pass in an Activity that has already been through Activity#onDestroy . This is guaranteed if you call this API
 during Activity#onCreate . For sending large content such as pictures and songs
 consider using setBeamPushUris(Uri[] Activity) which switches to alternate transports
 such as Bluetooth to achieve a fast transfer rate. Requires the Manifest.permission.NFC permission.","message NdefMessage : NDEF message to push over NFC or null to disable |||
activity Activity : activity for which the NDEF message will be pushed |||
activities Activity : optional additional activities however we strongly recommend
to only register one at a time and to do so in that activity's Activity#onCreate |||",void,14,"Represents the local NFC adapter.
  
 Use the helper  getDefaultAdapter(android.content.Context)  to get the default NFC
 adapter for this Android device.","Provides access to Near Field Communication (NFC) functionality allowing applications to read
 NDEF message in NFC tags. A ""tag"" may actually be another device that appears as a tag. For more information see the
  Near Field Communication  guide. Here's a summary of the classes: NfcManager This is the high level manager used to obtain this device's  NfcAdapter . You can
 acquire an instance using  getSystemService(Class ) . NfcAdapter This represents the device's NFC adapter which is your entry-point to performing NFC
 operations. You can acquire an instance with  getDefaultAdapter()  or
  getDefaultAdapter(android.content.Context) . NdefMessage Represents an NDEF data message which is the standard format in which ""records""
 carrying data are transmitted between devices and tags. Your application can receive these
 messages from an  ACTION_TAG_DISCOVERED  intent. NdefRecord Represents a record which is delivered in a  NdefMessage  and describes the
 type of data being shared and carries the data itself. Note: 
 Not all Android-powered devices provide NFC functionality.",uncategorized,nfc,1,no,yes,no,SINK,
<android.nfc.tech.MifareClassic: MifareClassic get(Tag)>,"Get an instance of MifareClassic for the given tag. Does not cause any RF activity and does not block. Returns null if MifareClassic was not enumerated in Tag#getTechList .
 This indicates the tag is not MIFARE Classic compatible or this Android
 device does not support MIFARE Classic.",tag Tag : an MIFARE Classic compatible tag |||,MifareClassic MIFARE Classic object |||,10,"Provides access to MIFARE Classic properties and I/O operations on a  Tag .

  Acquire a  MifareClassic  object using  get(Tag) .

  MIFARE Classic is also known as MIFARE Standard.
  MIFARE Classic tags are divided into sectors and each sector is sub-divided into
 blocks. Block size is always 16 bytes ( BLOCK_SIZE . Sector size varies.
  MIFARE Classic Mini are 320 bytes ( SIZE_MINI ) with 5 sectors each of 4 blocks.
  MIFARE Classic 1k are 1024 bytes ( SIZE_1K ) with 16 sectors each of 4 blocks.
  MIFARE Classic 2k are 2048 bytes ( SIZE_2K ) with 32 sectors each of 4 blocks.
  MIFARE Classic 4k are 4096 bytes ( SIZE_4K ). The first 32 sectors contain 4 blocks
 and the last 8 sectors contain 16 blocks.
  MIFARE Classic tags require authentication on a per-sector basis before any
 other I/O operations on that sector can be performed. There are two keys per sector
 and ACL bits determine what I/O operations are allowed on that sector after
 authenticating with a key.  and
 .

  Three well-known authentication keys are defined in this class:
  KEY_DEFAULT   KEY_MIFARE_APPLICATION_DIRECTORY 
  KEY_NFC_FORUM .
  KEY_DEFAULT  is the default factory key for MIFARE Classic.
  KEY_MIFARE_APPLICATION_DIRECTORY  is the well-known key for
 MIFARE Classic cards that have been formatted according to the
 MIFARE Application Directory (MAD) specification.
  KEY_NFC_FORUM  is the well-known key for MIFARE Classic cards that
 have been formatted according to the NXP specification for NDEF on MIFARE Classic.

  Implementation of this class on a Android NFC device is optional.
 If it is not implemented then
  MifareClassic  will never be enumerated in  Tag#getTechList .
 If it is enumerated then all  MifareClassic  I/O operations will be supported
 and  Ndef#MIFARE_CLASSIC  NDEF tags will also be supported. In either case
  NfcA  will also be enumerated on the tag because all MIFARE Classic tags are also
  NfcA .

  Note:  Methods that perform I/O operations
 require the  Manifest.permission.NFC  permission.","These classes provide access to a tag technology's features which vary by the type
 of tag that is scanned. A scanned tag can support multiple technologies and you can find
 out what they are by calling  getTechList() . For more information on dealing with tag technologies and handling the ones that you care about see
  The Tag Dispatch System .
 The  TagTechnology  interface provides an overview of the
 supported technologies.",nfc metadata,nfc,1,yes,no,SOURCE,no,
"<android.content.res.Resources: String getString(int,Object)>","Return the string value associated with a particular resource ID
 substituting the format arguments as defined in Formatter and String.format(String Object...) . It will be stripped of any styled text
 information.","id int : The desired resource identifier as generated by the aapt
tool. This integer encodes the package type and resource
entry. The value 0 is an invalid identifier. |||
formatArgs Object : The format arguments that will be used for substitution. |||","String String The string data associated with the resource
         stripped of styled text information.
 
 This value will never be null . |||",1,"Class for accessing an application's resources.  This sits on top of the
 asset manager of the application (accessible through  getAssets() ) and
 provides a high-level API for getting typed data from the assets.

  The Android resource system keeps track of all non-code assets associated with an
 application. You can use this class to access your application's resources. You can generally
 acquire the  Resources  instance associated with your application
 with  getResources() . The Android SDK tools compile your application's resources into the application binary
 at build time.  To use a resource you must install it correctly in the source tree (inside
 your project's  res/  directory) and build your application.  As part of the build
 process the SDK tools generate symbols for each resource which you can use in your application
 code to access the resources. Using application resources makes it easy to update various characteristics of your
 application without modifying code and—by providing sets of alternative
 resources—enables you to optimize your application for a variety of device configurations
 (such as for different languages and screen sizes). This is an important aspect of developing
 Android applications that are compatible on different types of devices. For more information about using resources see the documentation about  Application Resources .","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,
<android.text.method.MetaKeyKeyListener: void adjustMetaAfterKeypress(Spannable)>,"Call this method after you handle a keypress so that the meta
 state will be reset to unshifted (if it is not still down)
 or primed to be reset to unshifted (once it is released).",content Spannable |||,void,1,"This base class encapsulates the behavior for tracking the state of
 meta keys such as SHIFT ALT and SYM as well as the pseudo-meta state of selecting text.
  
 Key listeners that care about meta state should inherit from this class;
 you should not instantiate this class directly in a client.
  
 This class provides two mechanisms for tracking meta state that can be used
 together or independently.
  Methods such as  handleKeyDown(long int android.view.KeyEvent)  and
  getMetaState(long)  operate on a meta key state bit mask. Methods such as  onKeyDown(android.view.View android.text.Editable int android.view.KeyEvent)  and
  getMetaState(java.lang.CharSequence int)  operate on meta key state flags stored
 as spans in an  Editable  text buffer.  The spans only describe the current
 meta key state of the text editor; they do not carry any positional information. 
 The behavior of this class varies according to the keyboard capabilities
 described by the  KeyCharacterMap  of the keyboard device such as
 the  KeyCharacterMap#getModifierBehavior() .
  MetaKeyKeyListener  implements chorded and toggled key modifiers.
 When key modifiers are toggled into a latched or locked state the state
 of the modifier is stored in the  Editable  text buffer or in a
 meta state integer managed by the client.  These latched or locked modifiers
 should be considered to be held  in addition to  those that the
 keyboard already reported as being pressed in  KeyEvent#getMetaState() .
 In other words the  MetaKeyKeyListener  augments the meta state
 provided by the keyboard; it does not replace it.  This distinction is important
 to ensure that meta keys not handled by  MetaKeyKeyListener  such as
  KeyEvent#KEYCODE_CAPS_LOCK  or  KeyEvent#KEYCODE_NUM_LOCK  are
 taken into consideration.
  
 To ensure correct meta key behavior the following pattern should be used
 when mapping key codes to characters:
  
 private char getUnicodeChar(TextKeyListener listener KeyEvent event Editable textBuffer) {
     // Use the combined meta states from the event and the key listener.
     int metaState = event.getMetaState() | listener.getMetaState(textBuffer);
     return event.getUnicodeChar(metaState);
 }","Provides classes that monitor or modify keypad input. You can use these classes to modify the type of keypad entry
 for your application or decipher the keypresses entered for your specific
 entry method. For example: 
 // Set the text to password display style:
 EditText txtView = (EditText)findViewById(R.id.text);
 txtView.setTransformationMethod(PasswordTransformationMethod.getInstance());

 //Set the input style to numbers rather than qwerty keyboard style.
 txtView.setInputMethod(DigitsInputMethod.getInstance());

 // Find out whether the caps lock is on.
 // 0 is no 1 is yes 2 is caps lock on.
 int active = MultiTapInputMethod.getCapsActive(txtView.getText());",,,0,,,no,no,
<android.view.View: void sendAccessibilityEvent(int)>,"Sends an accessibility event of the given type. If accessibility is
 not enabled this method has no effect. The default implementation calls onInitializeAccessibilityEvent(android.view.accessibility.AccessibilityEvent) first
 to populate information about the event source (this View) then calls dispatchPopulateAccessibilityEvent(android.view.accessibility.AccessibilityEvent) to
 populate the text content of the event source including its descendants
 and last calls ViewParent#requestSendAccessibilityEvent(View AccessibilityEvent) on its parent to request sending of the event to interested parties. If an AccessibilityDelegate has been specified via calling setAccessibilityDelegate(android.view.View.AccessibilityDelegate) its AccessibilityDelegate#sendAccessibilityEvent(View int) is
 responsible for handling this call.",eventType int : The type of the event to send as defined by several types from AccessibilityEvent such as AccessibilityEvent.TYPE_VIEW_CLICKED or AccessibilityEvent.TYPE_VIEW_HOVER_ENTER . |||,void,4,"This class represents the basic building block for user interface components. A View
 occupies a rectangular area on the screen and is responsible for drawing and
 event handling. View is the base class for  widgets  which are
 used to create interactive UI components (buttons text fields etc.). The
  ViewGroup  subclass is the base class for  layouts  which
 are invisible containers that hold other Views (or other ViewGroups) and define
 their layout properties.",,,,0,,,no,no,
"<android.view.ViewGroup: void addView(View,int,int)>","Adds a child view with this ViewGroup's default layout parameters and the
 specified width and height. Note: do not invoke this method from View.draw(android.graphics.Canvas)  View.onDraw(android.graphics.Canvas)  dispatchDraw(android.graphics.Canvas) or any related method.","child View : the child view to add |||
width int |||
height int |||",void,1,"A  ViewGroup  is a special view that can contain other views
 (called children.) The view group is the base class for layouts and views
 containers. This class also defines the
  ViewGroup.LayoutParams  class which serves as the base
 class for layouts parameters.
  
 Also see  LayoutParams  for layout attributes.",,no,no,0,no,no,no,no,
"<android.app.ActivityManager: void moveTaskToFront(int,int)>",Equivalent to calling moveTaskToFront(int int android.os.Bundle) with a null options argument. Requires Manifest.permission.REORDER_TASKS,"taskId int : The identifier of the task to be moved as found in RunningTaskInfo or RecentTaskInfo . |||
flags int : Additional operational flags.
Value is either 0 or a combination of MOVE_TASK_WITH_HOME and MOVE_TASK_NO_USER_ACTION |||",void,11,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
"<android.app.Activity: void startIntentSenderFromChild(Activity,IntentSender,int,Intent,int,int,int)>","This method was deprecated
      in API level R. Use startIntentSenderForResult(android.content.IntentSender int android.content.Intent int int int) instead. Same as calling startIntentSenderFromChild(android.app.Activity android.content.IntentSender int android.content.Intent int int int android.os.Bundle) with no options.","child Activity |||
intent IntentSender |||
requestCode int |||
fillInIntent Intent |||
flagsMask int |||
flagsValues int |||
extraFlags int |||",void,5,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",IPC,IPC,1,no,yes,no,SINK,
<android.text.Layout: float getPrimaryHorizontal(int)>,"Get the primary horizontal position for the specified text offset.
 This is the location where a new character would be inserted in
 the paragraph's primary direction.",offset int |||,float |||,1,"A base class that manages text layout in visual elements on
 the screen.
  For text that will be edited use a  DynamicLayout 
 which will be updated as the text changes.
 For text that will not change use a  StaticLayout .","Provides classes used to render or track text and text spans on the screen. You can use these classes to design your own widgets that manage text
 to handle arbitrary text spans for changes or to handle drawing yourself
 for an existing widget. The Span… interfaces and classes are used to create or manage spans of
 text in a View item. You can use these to style the text or background or to
 listen for changes. If creating your own widget extend DynamicLayout to manages
 the actual wrapping and drawing of your text.",no,no,0,no,no,no,no,
"<android.content.pm.ServiceInfo: void writeToParcel(Parcel,int)>",,"dest Parcel |||
parcelableFlags int |||",void,1,"Information you can retrieve about a particular application
 service. This corresponds to information collected from the
 AndroidManifest.xml's <service> tags.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",IPC,no,0,no,no,no,no,
"<android.widget.ViewAnimator: void setInAnimation(Context,int)>",Specifies the animation used to animate a View that enters the screen.,"context Context : The application's environment. |||
resourceID int : The resource id of the animation. |||",void,1,"Base class for a  FrameLayout  container that will perform animations
 when switching between its views.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,UI,0,no,no,no,no,
"<android.app.TaskStackBuilder: PendingIntent getPendingIntent(int,int,Bundle)>",Obtain a PendingIntent for launching the task constructed by this builder so far.,"requestCode int : Private request code for the sender |||
flags int : May be PendingIntent#FLAG_ONE_SHOT  PendingIntent#FLAG_NO_CREATE  PendingIntent#FLAG_CANCEL_CURRENT  PendingIntent#FLAG_UPDATE_CURRENT or any of the flags supported by Intent#fillIn(Intent int) to control which unspecified parts of the
intent that can be supplied when the actual send happens.
Value is either 0 or a combination of PendingIntent.FLAG_ONE_SHOT  PendingIntent.FLAG_NO_CREATE  PendingIntent.FLAG_CANCEL_CURRENT  PendingIntent.FLAG_UPDATE_CURRENT  PendingIntent.FLAG_IMMUTABLE  Intent.FILL_IN_ACTION  Intent.FILL_IN_DATA  Intent.FILL_IN_CATEGORIES  Intent.FILL_IN_COMPONENT  Intent.FILL_IN_PACKAGE  Intent.FILL_IN_SOURCE_BOUNDS  Intent.FILL_IN_SELECTOR and Intent.FILL_IN_CLIP_DATA |||
options Bundle : Additional options for how the Activity should be started.
See Context.startActivity(Intent Bundle) Context.startActivity(Intent Bundle)} for more details. |||",PendingIntent The obtained PendingIntent |||,16,"Utility class for constructing synthetic back stacks for cross-task navigation
 on Android 3.0 and newer.

  In API level 11 (Android 3.0/Honeycomb) the recommended conventions for
 app navigation using the back key changed. The back key's behavior is local
 to the current task and does not capture navigation across different tasks.
 Navigating across tasks and easily reaching the previous task is accomplished
 through the ""recents"" UI accessible through the software-provided Recents key
 on the navigation or system bar. On devices with the older hardware button configuration
 the recents UI can be accessed with a long press on the Home key. When crossing from one task stack to another post-Android 3.0
 the application should synthesize a back stack/history for the new task so that
 the user may navigate out of the new task and back to the Launcher by repeated
 presses of the back key. Back key presses should not navigate across task stacks. TaskStackBuilder provides a way to obey the correct conventions
 around cross-task navigation.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",IPC,no,0,no,no,no,no,
<android.app.Activity: String getCallingPackage()>,"Return the name of the package that invoked this activity.  This is who
 the data in setResult() will be sent to.  You can
 use this information to validate that the recipient is allowed to
 receive the data. Note: if the calling activity is not expecting a result (that is it
 did not use the startActivityForResult(Intent int) form that includes a request code) then the calling package will be
 null. Note: prior to Build.VERSION_CODES.JELLY_BEAN_MR2 the result from this method was unstable.  If the process hosting the calling
 package was no longer running it would return null instead of the proper package
 name.  You can use getCallingActivity() and retrieve the package name
 from that instead.",,"String The package of the activity that will receive your
         reply or null if none. |||",1,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,Maybe IPC data if called from different app?
"<android.appwidget.AppWidgetHostView: Rect getDefaultPaddingForWidget(Context,ComponentName,Rect)>","As of ICE_CREAM_SANDWICH we are automatically adding padding to widgets targeting
 ICE_CREAM_SANDWICH and higher. The new widget design guidelines strongly recommend
 that widget developers do not add extra padding to their widgets. This will help
 achieve consistency among widgets.

 Note: this method is only needed by developers of AppWidgetHosts. The method is provided in
 order for the AppWidgetHost to account for the automatic padding when computing the number
 of cells to allocate to a particular widget.","context Context : the current context |||
component ComponentName : the component name of the widget |||
padding Rect : Rect in which to place the output if null a new Rect will be allocated and
returned |||",Rect default padding for this widget in pixels |||,15,"Provides the glue to show AppWidget views. This class offers automatic animation
 between updates and will try recycling old views for each incoming
  RemoteViews .","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
"<android.content.Intent: Intent putExtra(String,float)>","Add extended data to the intent.  The name must include a package
 prefix for example the app com.android.contacts would use names
 like ""com.android.contacts.ShowAll"".","name String : The name of the extra data with package prefix. |||
value float : The float data value. |||","Intent Returns the same Intent object for chaining multiple calls
 into a single statement.

 This value will never be null . |||",1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",IPC,no,0,no,no,no,no,
"<android.content.Intent: int getIntExtra(String,int)>",Retrieve extended data from the intent.,"name String : The name of the desired item. |||
defaultValue int : the value to be returned if no value of the desired
type is stored with the given name. |||","int the value of an item previously added with putExtra()
 or the default value if none was found. |||",1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",IPC,no,0,no,no,no,no,
"<android.app.admin.DevicePolicyManager: void setPasswordMinimumLowerCase(ComponentName,int)>","Called by an application that is administering the device to set the minimum number of lower
 case letters required in the password. After setting this the user will not be able to enter
 a new password that is not at least as restrictive as what has been set. Note that the
 current password will remain until the user has set a new one so the change does not take
 place immediately. To prompt the user for a new password use ACTION_SET_NEW_PASSWORD or ACTION_SET_NEW_PARENT_PROFILE_PASSWORD after
 setting this value. This constraint is only imposed if the administrator has also requested PASSWORD_QUALITY_COMPLEX with setPasswordQuality(ComponentName int) . If an app targeting
 SDK level Build.VERSION_CODES.R and above enforces this constraint without
 settings password quality to PASSWORD_QUALITY_COMPLEX first this method will throw IllegalStateException . The default value is 0. On devices not supporting PackageManager#FEATURE_SECURE_LOCK_SCREEN feature the
 password is always treated as empty. The calling device admin must have requested DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD to be able to call this method; if it has
 not a security exception will be thrown. This method can be called on the DevicePolicyManager instance returned by getParentProfileInstance(android.content.ComponentName) in order to set restrictions on the parent
 profile.","admin ComponentName : Which DeviceAdminReceiver this request is associated with.
This value must never be null . |||
length int : The new desired minimum number of lower case letters required in the password.
A value of 0 means there is no restriction. |||",void,11,"Public interface for managing policies enforced on a device. Most clients of this class must be
 registered with the system as a  device
 administrator . Additionally a device administrator may be registered as either a profile or
 device owner. A given method is accessible to all device administrators unless the documentation
 for that method specifies that it is restricted to either device or profile owners. Any
 application calling an api may only pass as an argument a device administrator component it
 owns. Otherwise a  SecurityException  will be thrown.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",password data,no,0,no,no,no,no,
<android.widget.RadioButton: void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo)>,"Initializes an AccessibilityNodeInfo with information about this view.
 The base implementation sets: AccessibilityNodeInfo#setParent(View)  
AccessibilityNodeInfo#setBoundsInParent(Rect)  
AccessibilityNodeInfo#setBoundsInScreen(Rect)  
AccessibilityNodeInfo#setPackageName(CharSequence)  
AccessibilityNodeInfo#setClassName(CharSequence)  
AccessibilityNodeInfo#setContentDescription(CharSequence)  
AccessibilityNodeInfo#setEnabled(boolean)  
AccessibilityNodeInfo#setClickable(boolean)  
AccessibilityNodeInfo#setFocusable(boolean)  
AccessibilityNodeInfo#setFocused(boolean)  
AccessibilityNodeInfo#setLongClickable(boolean)  
AccessibilityNodeInfo#setSelected(boolean)  
AccessibilityNodeInfo#setContextClickable(boolean) 
Subclasses should override this method call the super implementation
 and set additional attributes. If an AccessibilityDelegate has been specified via calling setAccessibilityDelegate(android.view.View.AccessibilityDelegate) its AccessibilityDelegate#onInitializeAccessibilityNodeInfo(View AccessibilityNodeInfo) is responsible for handling this call.",info AccessibilityNodeInfo : The instance to initialize. |||,void,14,"A radio button is a two-states button that can be either checked or
 unchecked. When the radio button is unchecked the user can press or click it
 to check it. However contrary to a  CheckBox  a radio
 button cannot be unchecked by the user once checked.
  
 Radio buttons are normally used together in a
  RadioGroup . When several radio buttons live inside
 a radio group checking one radio button unchecks all the others. See the  Radio Buttons 
 guide. XML attributes 
 See  CompoundButton Attributes 
  Button Attributes 
  TextView Attributes 
  View Attributes","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,no,0,no,no,no,no,
<android.widget.TextView: void setTransformationMethod(TransformationMethod)>,"Sets the transformation that is applied to the text that this
 TextView is displaying. Related XML Attributes: android:password 
android:singleLine",method TransformationMethod |||,void,1,"A user interface element that displays text to the user.
 To provide user-editable text see  EditText .
  
 The following code sample shows a typical use with an XML layout
 and code to modify the contents of the text view:
  
 <LinearLayout
      xmlns:android=""http://schemas.android.com/apk/res/android""
      android:layout_width=""match_parent""
      android:layout_height=""match_parent"">
    <TextView
        android:id=""@+id/text_view_id""
        android:layout_height=""wrap_content""
        android:layout_width=""wrap_content""
        android:text=""@string/hello"" />
 </LinearLayout>
  
 This code sample demonstrates how to modify the contents of the text view
 defined in the previous XML layout:
  
 public class MainActivity extends Activity {

    protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_main);
         final TextView helloTextView = (TextView) findViewById(R.id.text_view_id);
         helloTextView.setText(R.string.user_greeting);
     }
 }
  
 To customize the appearance of TextView see  Styles and Themes .
  XML attributes 
 See  TextView Attributes 
  View Attributes","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",uncategorized,UI,1,no,yes,no,SINK,TransformationMethod contains callbacks that could feasibly leak data to UI
<android.widget.TextView: void setInputExtras(int)>,"Set the extra input data of the text which is the EditorInfo#extras Bundle that will be filled in when creating an input connection.  The
 given integer is the resource identifier of an XML resource holding an <input-extras> XML tree. Related XML Attributes: android:editorExtras",xmlResId int |||,void,3,"A user interface element that displays text to the user.
 To provide user-editable text see  EditText .
  
 The following code sample shows a typical use with an XML layout
 and code to modify the contents of the text view:
  
 <LinearLayout
      xmlns:android=""http://schemas.android.com/apk/res/android""
      android:layout_width=""match_parent""
      android:layout_height=""match_parent"">
    <TextView
        android:id=""@+id/text_view_id""
        android:layout_height=""wrap_content""
        android:layout_width=""wrap_content""
        android:text=""@string/hello"" />
 </LinearLayout>
  
 This code sample demonstrates how to modify the contents of the text view
 defined in the previous XML layout:
  
 public class MainActivity extends Activity {

    protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_main);
         final TextView helloTextView = (TextView) findViewById(R.id.text_view_id);
         helloTextView.setText(R.string.user_greeting);
     }
 }
  
 To customize the appearance of TextView see  Styles and Themes .
  XML attributes 
 See  TextView Attributes 
  View Attributes","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,UI,0,no,no,no,no,
<android.app.Activity: void setDefaultKeyMode(int)>,"Select the default key handling for this activity.  This controls what
 will happen to key events that are not otherwise handled.  The default
 mode ( DEFAULT_KEYS_DISABLE ) will simply drop them on the
 floor. Other modes allow you to launch the dialer
 ( DEFAULT_KEYS_DIALER ) execute a shortcut in your options
 menu without requiring the menu key be held down
 ( DEFAULT_KEYS_SHORTCUT ) or launch a search ( DEFAULT_KEYS_SEARCH_LOCAL and DEFAULT_KEYS_SEARCH_GLOBAL ). Note that the mode selected here does not impact the default
 handling of system keys such as the ""back"" and ""menu"" keys and your
 activity and its views always get a first chance to receive and handle
 all application keys.","mode int : The desired default key mode constant.
Value is DEFAULT_KEYS_DISABLE  DEFAULT_KEYS_DIALER  DEFAULT_KEYS_SHORTCUT  DEFAULT_KEYS_SEARCH_LOCAL or DEFAULT_KEYS_SEARCH_GLOBAL |||",void,1,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
<android.hardware.SensorManager: void unregisterListener(SensorListener)>,"This method was deprecated
      in API level 15. This method is deprecated use SensorManager#unregisterListener(SensorEventListener) instead. Unregisters a listener for all sensors.",listener SensorListener : a SensorListener object |||,void,1,"SensorManager lets you access the device's  sensors .
  
 Always make sure to disable sensors you don't need especially when your
 activity is paused. Failing to do so can drain the battery in just a few
 hours. Note that the system will  not  disable sensors automatically when
 the screen turns off.
  
 Note: Don't use this mechanism with a Trigger Sensor have a look
 at  TriggerEventListener .  Sensor#TYPE_SIGNIFICANT_MOTION 
 is an example of a trigger sensor.
  
 public class SensorActivity extends Activity implements SensorEventListener {
     private final SensorManager mSensorManager;
     private final Sensor mAccelerometer;

     public SensorActivity() {
         mSensorManager = (SensorManager)getSystemService(SENSOR_SERVICE);
         mAccelerometer = mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
     }

     protected void onResume() {
         super.onResume();
         mSensorManager.registerListener(this mAccelerometer SensorManager.SENSOR_DELAY_NORMAL);
     }

     protected void onPause() {
         super.onPause();
         mSensorManager.unregisterListener(this);
     }

     public void onAccuracyChanged(Sensor sensor int accuracy) {
     }

     public void onSensorChanged(SensorEvent event) {
     }
 }","Provides support for hardware features such as the camera and other sensors. Be aware that
 not all Android-powered devices support all hardware features so you should declare hardware
 that your application requires using the  <uses-feature>  manifest element.",no,no,0,no,no,no,no,
<android.provider.SearchRecentSuggestions: void clearHistory()>,"Completely delete the history.  Use this call to implement a ""clear history"" UI.

 Any application that implements search suggestions based on previous actions (such as
 recent queries page/items viewed etc.) should provide a way for the user to clear the
 history.  This gives the user a measure of privacy if they do not wish for their recent
 searches to be replayed by other users of the device (via suggestions).",,void,1,"This is a utility class providing access to
  SearchRecentSuggestionsProvider .

  Unlike some utility classes this one must be instantiated and properly initialized so that
 it can be configured to operate with the search suggestions provider that you have created.

  Typically you will do this in your searchable activity each time you receive an incoming
  ACTION_SEARCH  Intent.  The code to record each
 incoming query is as follows:
  
      SearchSuggestions suggestions = new SearchSuggestions(this
              MySuggestionsProvider.AUTHORITY MySuggestionsProvider.MODE);
      suggestions.saveRecentQuery(queryString null);
  For a working example see SearchSuggestionSampleProvider and SearchQueryResults in
 samples/ApiDemos/app.","Provides convenience classes to access the content providers supplied by
 Android. Android ships with a number of content providers that store common data such
 as contact informations calendar information and media files. These classes
 provide simplified methods of adding or retrieving data from these content
 providers. For information about how to use a content provider see the  Content Providers  developer
 guide.",no,no,0,no,no,no,no,
<android.database.sqlite.SQLiteOpenHelper: SQLiteDatabase getReadableDatabase()>,"Create and/or open a database.  This will be the same object returned by getWritableDatabase() unless some problem such as a full disk
 requires the database to be opened read-only.  In that case a read-only
 database object will be returned.  If the problem is fixed a future call
 to getWritableDatabase() may succeed in which case the read-only
 database object will be closed and the read/write object will be returned
 in the future. Like getWritableDatabase() this method may
 take a long time to return so you should not call it from the
 application main thread including from ContentProvider.onCreate() .",,SQLiteDatabase a database object valid until getWritableDatabase() or close() is called. |||,1,"A helper class to manage database creation and version management.

  You create a subclass implementing  onCreate(SQLiteDatabase)   onUpgrade(SQLiteDatabase int int)  and
 optionally  onOpen(SQLiteDatabase)  and this class takes care of opening the database
 if it exists creating it if it does not and upgrading it as necessary.
 Transactions are used to make sure the database is always in a sensible state.

  This class makes it easy for  ContentProvider 
 implementations to defer opening and upgrading the database until first use
 to avoid blocking application startup with long-running database upgrades.

  For an example see the NotePadProvider class in the NotePad sample application
 in the  samples/  directory of the SDK. Note:  this class assumes
 monotonically increasing version numbers for upgrades. Note:  the  AutoCloseable  interface was
 first added in the  Build.VERSION_CODES.Q  release.","If you need to manage data in a private database use the  android.database.sqlite  classes. These classes are used to manage the  Cursor  object returned from a content provider query. Databases
 are usually created and opened with  openOrCreateDatabase(String int SQLiteDatabase.CursorFactory) 
 To make requests through
 content providers you can use the  content.ContentResolver  class.
  All databases are stored on the device in  /data/data/<package_name>/databases",database data,database,1,yes,no,SOURCE,no,
"<android.content.Intent: Intent putExtra(String,short)>","Add extended data to the intent.  The name must include a package
 prefix for example the app com.android.contacts would use names
 like ""com.android.contacts.ShowAll"".","name String : The name of the extra data with package prefix. |||
value short : The short data value. |||","Intent Returns the same Intent object for chaining multiple calls
 into a single statement.

 This value will never be null . |||",1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",IPC,no,0,no,no,no,no,
<android.view.inputmethod.InputMethodManager: List getEnabledInputMethodList()>,Returns the list of enabled input methods. On multi user environment this API returns a result for the calling process user.,,List < InputMethodInfo > List of InputMethodInfo . |||,3,"Central system API to the overall input method framework (IMF) architecture
 which arbitrates interaction between applications and the current input method.

  Topics covered here:
  Architecture Overview Applications Input Methods Security Architecture Overview There are three primary parties involved in the input method
 framework (IMF) architecture:  The  input method manager  as expressed by this class
 is the central point of the system that manages interaction between all
 other parts.  It is expressed as the client-side API here which exists
 in each application context and communicates with a global system service
 that manages the interaction across all processes.
   An  input method (IME)  implements a particular
 interaction model allowing the user to generate text.  The system binds
 to the current input method that is in use causing it to be created and run
 and tells it when to hide and show its UI.  Only one IME is running at a time.
   Multiple  client applications  arbitrate with the input
 method manager for input focus and control over the state of the IME.  Only
 one such client is ever active (working with the IME) at a time.
  Applications In most cases applications that are using the standard
  TextView  or its subclasses will have little they need
 to do to work well with soft input methods.  The main things you need to
 be aware of are:  Properly set the  R.attr.inputType  in your editable
 text views so that the input method will have enough context to help the
 user in entering text into them.
   Deal well with losing screen space when the input method is
 displayed.  Ideally an application should handle its window being resized
 smaller but it can rely on the system performing panning of the window
 if needed.  You should set the  R.attr.windowSoftInputMode 
 attribute on your activity or the corresponding values on windows you
 create to help the system determine whether to pan or resize (it will
 try to determine this automatically but may get it wrong).
   You can also control the preferred soft input state (open closed etc)
 for your window using the same  R.attr.windowSoftInputMode 
 attribute.
  More finer-grained control is available through the APIs here to directly
 interact with the IMF and its IME -- either showing or hiding the input
 area letting the user pick an input method etc. For the rare people amongst us writing their own text editors you
 will need to implement  View.onCreateInputConnection(EditorInfo) 
 to return a new instance of your own  InputConnection  interface
 allowing the IME to interact with your editor. Input Methods An input method (IME) is implemented
 as a  Service  typically deriving from
  InputMethodService .  It must provide
 the core  InputMethod  interface though this is normally handled by
  InputMethodService  and implementors will
 only need to deal with the higher-level API there. InputMethodService Security There are a lot of security issues associated with input methods
 since they essentially have freedom to completely drive the UI and monitor
 everything the user enters.  The Android input method framework also allows
 arbitrary third party IMEs so care must be taken to restrict their
 selection and interactions. Here are some key points about the security architecture behind the
 IMF: Only the system is allowed to directly access an IME's
  InputMethod  interface via the
  Manifest.permission.BIND_INPUT_METHOD  permission.  This is
 enforced in the system by not binding to an input method service that does
 not require this permission so the system can guarantee no other untrusted
 clients are accessing the current input method outside of its control. There may be many client processes of the IMF but only one may
 be active at a time.  The inactive clients can not interact with key
 parts of the IMF through the mechanisms described below. Clients of an input method are only given access to its
  InputMethodSession  interface.  One instance of this interface is
 created for each client and only calls from the session associated with
 the active client will be processed by the current IME.  This is enforced
 by  AbstractInputMethodService  for normal
 IMEs but must be explicitly handled by an IME that is customizing the
 raw  InputMethodSession  implementation. Only the active client's  InputConnection  will accept
 operations.  The IMF tells each client process whether it is active and
 the framework enforces that in inactive processes calls on to the current
 InputConnection will be ignored.  This ensures that the current IME can
 only deliver events and text edits to the UI that the user sees as
 being in focus. An IME can never interact with an  InputConnection  while
 the screen is off.  This is enforced by making all clients inactive while
 the screen is off and prevents bad IMEs from driving the UI when the user
 can not be aware of its behavior. A client application can ask that the system let the user pick a
 new IME but can not programmatically switch to one itself.  This avoids
 malicious applications from switching the user to their own IME which
 remains running when the user navigates away to another application.  An
 IME on the other hand  is  allowed to programmatically switch
 the system to another IME since it already has full control of user
 input. The user must explicitly enable a new IME in settings before
 they can switch to it to confirm with the system that they know about it
 and want to make it available for use. PackageManager#FEATURE_INPUT_METHODS PackageManager.hasSystemFeature(String)",,,,0,,,no,no,
<android.test.ActivityInstrumentationTestCase: void testActivityTestCaseSetUpProperly()>,,,void,1,"This class provides functional testing of a single activity.  The activity under test will
 be created using the system infrastructure (by calling InstrumentationTestCase.launchActivity())
 and you will then be able to manipulate your Activity directly.  Most of the work is handled
 automatically here by  setUp()  and  tearDown() .

  If you prefer an isolated unit test see  ActivityUnitTestCase .",,no,no,0,no,no,no,no,
<android.location.LocationManager: void removeProximityAlert(PendingIntent)>,"Removes the proximity alert with the given PendingIntent. Before API version 17 this method could be used with Manifest.permission.ACCESS_FINE_LOCATION or Manifest.permission.ACCESS_COARSE_LOCATION .
 From API version 17 and onwards this method requires Manifest.permission.ACCESS_FINE_LOCATION permission. Requires Manifest.permission.ACCESS_COARSE_LOCATION or Manifest.permission.ACCESS_FINE_LOCATION","intent PendingIntent : the PendingIntent that no longer needs to be notified of
proximity alerts
This value must never be null . |||",void,1,"A data class representing a geographic location.

  A location can consist of a latitude longitude timestamp
 and other information such as bearing altitude and velocity.

  All locations generated by the  LocationManager  are
 guaranteed to have a valid latitude longitude and timestamp
 (both UTC time and elapsed real-time since boot) all other
 parameters are optional.","Contains the framework API classes that define Android location-based and
 	related services. This API is not the recommended method for accessing Android location. 
 The
  Google Location Services API 
 part of Google Play services is the preferred way to add location-awareness to
 your app. It offers a simpler API higher accuracy low-power geofencing and
 more. If you are currently using the android.location API you are strongly
 encouraged to switch to the Google Location Services API as soon as
 possible.
  
 To learn more about the Google Location Services API see the
  Location API overview .",IPC,location,1,no,no,no,no,
<android.preference.PreferenceFragment: void onDestroyView()>,"Called when the view previously created by onCreateView(LayoutInflater ViewGroup Bundle) has
 been detached from the fragment.  The next time the fragment needs
 to be displayed a new view will be created.  This is called
 after onStop() and before onDestroy() .  It is called regardless of whether onCreateView(LayoutInflater ViewGroup Bundle) returned a
 non-null view.  Internally it is called after the view's state has
 been saved but before it has been removed from its parent. If you override this method you must call through to the
 superclass implementation.",,void,11,"Represents the basic Preference UI building
 block displayed by a  PreferenceActivity  in the form of a
  ListView . This class provides the  View  to be displayed in
 the activity and associates with a  SharedPreferences  to
 store/retrieve the preference data.
  
 When specifying a preference hierarchy in XML each element can point to a
 subclass of  Preference  similar to the view hierarchy and layouts.
  
 This class contains a  key  that will be used as the key into the
  SharedPreferences . It is up to the subclass to decide how to store
 the value.",,no,UI,0,no,no,no,no,
"<android.media.MediaScannerConnection: void onServiceConnected(ComponentName,IBinder)>",Part of the ServiceConnection interface.  Do not call.,"className ComponentName : The concrete component name of the service that has
been connected. |||
service IBinder : The IBinder of the Service's communication channel
which you can now make calls on. |||",void,1,"MediaScannerConnection provides a way for applications to pass a
 newly created or downloaded media file to the media scanner service.
 The media scanner service will read metadata from the file and add
 the file to the media content provider.
 The MediaScannerConnectionClient provides an interface for the
 media scanner service to return the Uri for a newly scanned file
 to the client of the MediaScannerConnection class.","The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",IPC,IPC,1,no,yes,no,SINK,
<android.app.DialogFragment: void onDestroyView()>,Remove dialog.,,void,11,"Base class for Dialogs.

  Note: Activities provide a facility to manage the creation saving and
 restoring of dialogs. See  Activity#onCreateDialog(int) 
  Activity#onPrepareDialog(int Dialog) 
  Activity#showDialog(int)  and  Activity#dismissDialog(int) . If
 these methods are used  getOwnerActivity()  will return the Activity
 that managed this dialog.

  Often you will want to have a Dialog display on top of the current
 input method because there is no reason for it to accept text.  You can
 do this by setting the  WindowManager.LayoutParams#FLAG_ALT_FOCUSABLE_IM  window flag (assuming
 your Dialog takes input focus as it the default) with the following code:

  
 getWindow().setFlags(WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM
         WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
<android.content.res.TypedArray: String getString(int)>,"Retrieves the string value for the attribute at index . If the attribute is not a string this method will attempt to coerce
 it to a string.",index int : Index of attribute to retrieve. |||,"String String holding string data. Any styling information is removed.
         Returns null if the attribute is not defined or could
         not be coerced to a string. |||",1,"Container for an array of values that were retrieved with
  Resources.Theme#obtainStyledAttributes(AttributeSet int[] int int) 
 or  Resources#obtainAttributes .  Be
 sure to call  recycle()  when done with them.

 The indices used to retrieve values from this structure correspond to
 the positions of the attributes given to obtainStyledAttributes.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,
<android.app.UiModeManager: void enableCarMode(int)>,"Force device into car mode like it had been placed in the car dock.
 This will cause the device to switch to the car home UI as part of
 the mode switch.",flags int : Must be 0. |||,void,8,"This class provides access to the system uimode services.  These services
 allow applications to control UI modes of the device.
 It provides functionality to disable the car mode and it gives access to the
 night mode settings.

  These facilities are built on top of the underlying
  Intent.ACTION_DOCK_EVENT  broadcasts that are sent when the user
 physical places the device into and out of a dock.  When that happens
 the UiModeManager switches the system  Configuration 
 to the appropriate UI mode sends broadcasts about the mode switch and
 starts the corresponding mode activity if appropriate.  See the
 broadcasts  ACTION_ENTER_CAR_MODE  and
  ACTION_ENTER_DESK_MODE  for more information.

  In addition the user may manually switch the system to car mode without
 physically being in a dock.  While in car mode -- whether by manual action
 from the user or being physically placed in a dock -- a notification is
 displayed allowing the user to exit dock mode.  Thus the dock mode
 represented here may be different than the current state of the underlying
 dock event broadcast.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,UI,0,no,no,no,no,
<android.widget.AdapterViewAnimator: void setAdapter(Adapter)>,"Sets the adapter that provides the data and the views to represent the data
 in this widget.",adapter Adapter : The adapter to use to create this view's content. |||,void,11,"An AdapterView is a view whose children are determined by an  Adapter .

  
 See  ListView   GridView   Spinner  and
       Gallery  for commonly used subclasses of AdapterView.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",uncategorized,UI,1,no,yes,no,SINK,not sure
<android.os.Handler: void dispatchMessage(Message)>,Handle system messages here.,msg Message : This value must never be null . |||,void,1,"A Handler allows you to send and process  Message  and Runnable
 objects associated with a thread's  MessageQueue .  Each Handler
 instance is associated with a single thread and that thread's message
 queue.  When you create a new Handler it is bound to the thread /
 message queue of the thread that is creating it -- from that point on
 it will deliver messages and runnables to that message queue and execute
 them as they come out of the message queue.

  There are two main uses for a Handler: (1) to schedule messages and
 runnables to be executed at some point in the future; and (2) to enqueue
 an action to be performed on a different thread than your own.

  Scheduling messages is accomplished with the
  post(Runnable)   postAtTime(java.lang.Runnable long) 
  postDelayed(Runnable Object long)   sendEmptyMessage(int) 
  sendMessage(Message)   sendMessageAtTime(Message long)  and
  sendMessageDelayed(Message long)  methods.  The  post  versions allow
 you to enqueue Runnable objects to be called by the message queue when
 they are received; the  sendMessage  versions allow you to enqueue
 a  Message  object containing a bundle of data that will be
 processed by the Handler's  handleMessage(Message)  method (requiring that
 you implement a subclass of Handler).

  When posting or sending to a Handler you can either
 allow the item to be processed as soon as the message queue is ready
 to do so or specify a delay before it gets processed or absolute time for
 it to be processed.  The latter two allow you to implement timeouts
 ticks and other timing-based behavior.

  When a
 process is created for your application its main thread is dedicated to
 running a message queue that takes care of managing the top-level
 application objects (activities broadcast receivers etc) and any windows
 they create.  You can create your own threads and communicate back with
 the main application thread through a Handler.  This is done by calling
 the same  post  or  sendMessage  methods as before but from
 your new thread.  The given Runnable or Message will then be scheduled
 in the Handler's message queue and processed when appropriate.",,system?,callback,1,no,yes,no,SINK,
<android.content.Intent: int getIntArrayExtra(String)>,Retrieve extended data from the intent.,name String : The name of the desired item. |||,"int[] the value of an item previously added with putExtra()
 or null if no int array value was found. |||",1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",IPC,no,0,no,no,no,no,
<android.widget.DialerFilter: void setLettersWatcher(TextWatcher)>,,watcher TextWatcher |||,void,1,"This widget is a layout that contains several specifically-named child views that
 handle keyboard entry interpreted as standard phone dialpad digits.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",keyboard,callback,1,no,yes,no,SINK,
<android.webkit.WebView: void goBack()>,Goes back in the history of this WebView.,,void,1,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",no,no,0,no,no,no,no,
"<android.accounts.AccountManager: AccountManagerFuture getAuthTokenByFeatures(String,String,String,Activity,Bundle,Bundle,AccountManagerCallback,Handler)>","This convenience helper combines the functionality of getAccountsByTypeAndFeatures(String String[] AccountManagerCallback Handler)  getAuthToken(Account String Bundle Activity AccountManagerCallback Handler) and addAccount(String String String[] Bundle Activity AccountManagerCallback Handler) . This method gets a list of the accounts matching specific type and feature set which are
 visible to the caller (see getAccountsByType(String) for details);
 if there is exactly one already visible account it is used; if there are some
 accounts for which user grant visibility the user is prompted to pick one; if there are
 none the user is prompted to add one. Finally an auth token is acquired for the chosen
 account. This method may be called from any thread but the returned AccountManagerFuture must
 not be used on the main thread. NOTE: If targeting your app to work on API level 22 and before MANAGE_ACCOUNTS
 permission is needed for those platforms. See docs for this function in API level 22. Requires android.Manifest.permission.MANAGE_ACCOUNTS","accountType String : The account type required (see getAccountsByType(String) ) must not be
null |||
authTokenType String : The desired auth token type (see getAuthToken(Account String Bundle Activity AccountManagerCallback Handler) ) must not be
null |||
features String : Required features for the account (see getAccountsByTypeAndFeatures(String String[] AccountManagerCallback Handler) ) may be null or empty |||
activity Activity : The Activity context to use for launching new sub-Activities to
prompt to add an account select an account and/or enter a password as necessary;
used only to call startActivity(); should not be null |||
addAccountOptions Bundle : Authenticator-specific options to use for adding new accounts; may
be null or empty |||
getAuthTokenOptions Bundle : Authenticator-specific options to use for getting auth tokens; may
be null or empty |||
callback AccountManagerCallback : Callback to invoke when the request completes null for no callback |||
handler Handler : Handler identifying the callback thread null for the main thread |||","AccountManagerFuture < Bundle > An AccountManagerFuture which resolves to a Bundle with at least the
         following fields: KEY_ACCOUNT_NAME - the name of the account KEY_ACCOUNT_TYPE - the type of the account KEY_AUTHTOKEN - the auth token you wanted If an error occurred AccountManagerFuture#getResult() throws: AuthenticatorException if no authenticator was registered for this
         account type or the authenticator failed to respond OperationCanceledException if the operation was canceled for any reason
         including the user canceling any operation IOException if the authenticator experienced an I/O problem updating
         settings usually because of network trouble |||",5,"This class provides access to a centralized registry of the user's
 online accounts.  The user enters credentials (username and password) once
 per account granting applications access to online resources with
 ""one-click"" approval.

  Different online services have different ways of handling accounts and
 authentication so the account manager uses pluggable  authenticator 
 modules for different  account types .  Authenticators (which may be
 written by third parties) handle the actual details of validating account
 credentials and storing account information.  For example Google Facebook
 and Microsoft Exchange each have their own authenticator.

  Many servers support some notion of an  authentication token 
 which can be used to authenticate a request to the server without sending
 the user's actual password.  (Auth tokens are normally created with a
 separate request which does include the user's credentials.)  AccountManager
 can generate auth tokens for applications so the application doesn't need to
 handle passwords directly.  Auth tokens are normally reusable and cached by
 AccountManager but must be refreshed periodically.  It's the responsibility
 of applications to  invalidate  auth tokens when they stop working so
 the AccountManager knows it needs to regenerate them.

  Applications accessing a server normally go through these steps:

  Get an instance of AccountManager using  get(android.content.Context) .

  List the available accounts using  getAccountsByType(String)  or
  getAccountsByTypeAndFeatures(String String[] AccountManagerCallback  Handler) .  Normally applications will only
 be interested in accounts with one particular  type  which
 identifies the authenticator.  Account  features  are used to
 identify particular account subtypes and capabilities.  Both the account
 type and features are authenticator-specific strings and must be known by
 the application in coordination with its preferred authenticators.

  Select one or more of the available accounts possibly by asking the
 user for their preference.  If no suitable accounts are available
  addAccount(String String String[] Bundle Activity AccountManagerCallback  Handler)  may be called to prompt the user to create an
 account of the appropriate type.

  Important:  If the application is using a previously remembered
 account selection it must make sure the account is still in the list
 of accounts returned by  getAccountsByType(String) .  Requesting an auth token
 for an account no longer on the device results in an undefined failure.

  Request an auth token for the selected account(s) using one of the
  getAuthToken(Account String Bundle Activity AccountManagerCallback  Handler)  methods or related helpers.  Refer to the description
 of each method for exact usage and error handling details.

  Make the request using the auth token.  The form of the auth token
 the format of the request and the protocol used are all specific to the
 service you are accessing.  The application may use whatever network and
 protocol libraries are useful.

  Important:  If the request fails with an authentication error
 it could be that a cached auth token is stale and no longer honored by
 the server.  The application must call  invalidateAuthToken(String String)  to remove
 the token from the cache otherwise requests will continue failing!  After
 invalidating the auth token immediately go back to the ""Request an auth
 token"" step above.  If the process fails the second time then it can be
 treated as a ""genuine"" authentication failure and the user notified or other
 appropriate actions taken.
  Some AccountManager methods may need to interact with the user to
 prompt for credentials present options or ask the user to add an account.
 The caller may choose whether to allow AccountManager to directly launch the
 necessary user interface and wait for the user or to return an Intent which
 the caller may use to launch the interface or (in some cases) to install a
 notification which the user can select at any time to launch the interface.
 To have AccountManager launch the interface directly the caller must supply
 the current foreground  Activity  context.

  Many AccountManager methods take  AccountManagerCallback  and
  Handler  as parameters.  These methods return immediately and
 run asynchronously. If a callback is provided then
  AccountManagerCallback#run  will be invoked on the Handler's
 thread when the request completes successfully or not.
 The result is retrieved by calling  AccountManagerFuture#getResult() 
 on the  AccountManagerFuture  returned by the method (and also passed
 to the callback).  This method waits for the operation to complete (if
 necessary) and either returns the result or throws an exception if an error
 occurred during the operation.  To make the request synchronously call
  AccountManagerFuture#getResult()  immediately on receiving the
 future from the method; no callback need be supplied.

  Requests which may block including
  AccountManagerFuture#getResult()  must never be called on
 the application's main event thread.  These operations throw
  IllegalStateException  if they are used on the main thread.",,account info,account info storage file,1,yes,no,SOURCE,no,
<android.app.UiModeManager: int getCurrentModeType()>,Return the current running mode type.  May be one of Configuration#UI_MODE_TYPE_NORMAL  Configuration#UI_MODE_TYPE_DESK  Configuration#UI_MODE_TYPE_CAR  Configuration#UI_MODE_TYPE_TELEVISION  Configuration#UI_MODE_TYPE_APPLIANCE  Configuration#UI_MODE_TYPE_WATCH or Configuration#UI_MODE_TYPE_VR_HEADSET .,,int |||,8,"This class provides access to the system uimode services.  These services
 allow applications to control UI modes of the device.
 It provides functionality to disable the car mode and it gives access to the
 night mode settings.

  These facilities are built on top of the underlying
  Intent.ACTION_DOCK_EVENT  broadcasts that are sent when the user
 physical places the device into and out of a dock.  When that happens
 the UiModeManager switches the system  Configuration 
 to the appropriate UI mode sends broadcasts about the mode switch and
 starts the corresponding mode activity if appropriate.  See the
 broadcasts  ACTION_ENTER_CAR_MODE  and
  ACTION_ENTER_DESK_MODE  for more information.

  In addition the user may manually switch the system to car mode without
 physically being in a dock.  While in car mode -- whether by manual action
 from the user or being physically placed in a dock -- a notification is
 displayed allowing the user to exit dock mode.  Thus the dock mode
 represented here may be different than the current state of the underlying
 dock event broadcast.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",UI metadata,UI,1,yes,no,SOURCE,no,
<android.widget.AbsListView: void getFocusedRect(Rect)>,"When a view has focus and the user navigates away from it the next view is searched for
 starting from the rectangle filled in by this method.

 By default the rectangle is the getDrawingRect(android.graphics.Rect) )
 of the view.  However if your view maintains some idea of internal selection
 such as a cursor or a selected row or column you should override this method and
 fill in a more specific rectangle.",r Rect : The rectangle to fill in in this view's coordinates. |||,void,1,"Base class that can be used to implement virtualized lists of items. A list does
 not have a spatial definition here. For instance subclasses of this class can
 display the content of the list in a grid in a carousel as stack etc.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,UI,0,no,no,no,no,not sure
<android.app.ListFragment: void setEmptyText(CharSequence)>,"The default content for a ListFragment has a TextView that can
 be shown when the list is empty.  If you would like to have it
 shown call this method to supply the text it should use.",text CharSequence |||,void,11,"A fragment that displays a list of items by binding to a data source such as
 an array or Cursor and exposes event handlers when the user selects an item.
  
 ListFragment hosts a  ListView  object that can
 be bound to different data sources typically either an array or a Cursor
 holding query results. Binding screen layout and row layout are discussed
 in the following sections.
  Screen Layout 
 ListFragment has a default layout that consists of a single list view.
 However if you desire you can customize the fragment layout by returning
 your own view hierarchy from  onCreateView(LayoutInflater ViewGroup Bundle) .
 To do this your view hierarchy  must  contain a ListView object with the
 id ""@android:id/list"" (or  R.id.list  if it's in code)
  
 Optionally your view hierarchy can contain another view object of any type to
 display when the list view is empty. This ""empty list"" notifier must have an
 id ""android:empty"". Note that when an empty view is present the list view
 will be hidden when there is no data to display.
  
 The following code demonstrates an (ugly) custom list layout. It has a list
 with a green background and an alternate red ""no data"" message.
  
 <?xml version=""1.0"" encoding=""utf-8""?>
 <LinearLayout xmlns:android=""http://schemas.android.com/apk/res/android""
         android:orientation=""vertical""
         android:layout_width=""match_parent""
         android:layout_height=""match_parent""
         android:paddingLeft=""8dp""
         android:paddingRight=""8dp"">

     <ListView android:id=""@id/android:list""
               android:layout_width=""match_parent""
               android:layout_height=""match_parent""
               android:background=""#00FF00""
               android:layout_weight=""1""
               android:drawSelectorOnTop=""false""/>

     <TextView android:id=""@id/android:empty""
               android:layout_width=""match_parent""
               android:layout_height=""match_parent""
               android:background=""#FF0000""
               android:text=""No data""/>
 </LinearLayout>
  Row Layout 
 You can specify the layout of individual rows in the list. You do this by
 specifying a layout resource in the ListAdapter object hosted by the fragment
 (the ListAdapter binds the ListView to the data; more on this later).
  
 A ListAdapter constructor takes a parameter that specifies a layout resource
 for each row. It also has two additional parameters that let you specify
 which data field to associate with which object in the row layout resource.
 These two parameters are typically parallel arrays.
  
 Android provides some standard row layout resources. These are in the
  R.layout  class and have names such as simple_list_item_1
 simple_list_item_2 and two_line_list_item. The following layout XML is the
 source for the resource two_line_list_item which displays two data
 fieldsone above the other for each list row.
  
 <?xml version=""1.0"" encoding=""utf-8""?>
 <LinearLayout xmlns:android=""http://schemas.android.com/apk/res/android""
     android:layout_width=""match_parent""
     android:layout_height=""wrap_content""
     android:orientation=""vertical"">

     <TextView android:id=""@+id/text1""
         android:textSize=""16sp""
         android:textStyle=""bold""
         android:layout_width=""match_parent""
         android:layout_height=""wrap_content""/>

     <TextView android:id=""@+id/text2""
         android:textSize=""16sp""
         android:layout_width=""match_parent""
         android:layout_height=""wrap_content""/>
 </LinearLayout>
  
 You must identify the data bound to each TextView object in this layout. The
 syntax for this is discussed in the next section.
  Binding to Data 
 You bind the ListFragment's ListView object to data using a class that
 implements the  ListAdapter  interface.
 Android provides two standard list adapters:
  SimpleAdapter  for static data (Maps)
 and  SimpleCursorAdapter  for Cursor
 query results.
  
 You  must  use
  ListFragment.setListAdapter()  to
 associate the list with an adapter.  Do not directly call
  ListView#setAdapter(ListAdapter)  or else
 important initialization will be skipped.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",uncategorized,UI,1,no,yes,no,SINK,
<android.content.ContentResolver: ContentProviderClient acquireUnstableContentProviderClient(String)>,"Like acquireContentProviderClient(java.lang.String) but for use when you do
 not trust the stability of the target content provider.  This turns off
 the mechanism in the platform clean up processes that are dependent on
 a content provider if that content provider's process goes away.  Normally
 you can safely assume that once you have acquired a provider you can freely
 use it as needed and it won't disappear even if your process is in the
 background.  If using this method you need to take care to deal with any
 failures when communicating with the provider and be sure to close it
 so that it can be re-opened later.  In particular catching a DeadObjectException from the calls there will let you
 know that the content provider has gone away; at that point the current
 ContentProviderClient object is invalid and you should release it.  You
 can acquire a new one if you would like to try to restart the provider
 and perform new operations on it.",name String : This value must never be null . |||,ContentProviderClient This value may be null . |||,16,This class provides applications access to the content model.,"Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",database data,database,1,yes,no,SOURCE,no,
<android.webkit.WebView: void clearSslPreferences()>,"Clears the SSL preferences table stored in response to proceeding with
 SSL certificate errors.",,void,1,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",no,no,0,no,no,no,no,
<android.bluetooth.BluetoothA2dp: int getConnectionState(BluetoothDevice)>,Get the current connection state of the profile Requires Manifest.permission.BLUETOOTH,device BluetoothDevice : Remote bluetooth device. |||,int Value is BluetoothProfile.STATE_DISCONNECTED  BluetoothProfile.STATE_CONNECTING  BluetoothProfile.STATE_CONNECTED or BluetoothProfile.STATE_DISCONNECTING |||,11,"This class provides the public APIs to control the Bluetooth A2DP
 profile.

  BluetoothA2dp is a proxy object for controlling the Bluetooth A2DP
 Service via IPC. Use  BluetoothAdapter#getProfileProxy  to get
 the BluetoothA2dp proxy object.

   Android only supports one connected Bluetooth A2dp device at a time.
 Each method is protected with its appropriate permission.","Provides classes that manage Bluetooth functionality such as scanning for
 devices connecting with devices and managing data transfer between devices.
 The Bluetooth API supports both ""Classic Bluetooth"" and Bluetooth Low Energy. For more information about Classic Bluetooth see the
  Bluetooth  guide.
 For more information about Bluetooth Low Energy see the
  
 Bluetooth Low Energy  (BLE) guide. The Bluetooth APIs let applications: Scan for other Bluetooth devices (including BLE devices). Query the local Bluetooth adapter for paired Bluetooth devices. Establish RFCOMM channels/sockets. Connect to specified sockets on other devices. Transfer data to and from other devices. Communicate with BLE devices such as proximity sensors heart rate
     monitors fitness devices and so on. Act as a GATT client or a GATT server (BLE). 
 To perform Bluetooth communication using these APIs an application must
 declare the  BLUETOOTH  permission. Some
 additional functionality such as requesting device discovery
 also requires the  BLUETOOTH_ADMIN 
 permission.
  Note: 
 Not all Android-powered devices provide Bluetooth functionality.",bluetooth metadata,bluetooth,1,yes,no,SOURCE,no,
"<android.text.SpannableStringBuilder: SpannableStringBuilder replace(int,int,CharSequence)>",Convenience for replace(st en text 0 text.length()),"start int |||
end int |||
tb CharSequence |||",SpannableStringBuilder |||,1,"This is the class for text whose content is immutable but to which
 markup objects can be attached and detached.
 For mutable text see  SpannableStringBuilder .","Provides classes used to render or track text and text spans on the screen. You can use these classes to design your own widgets that manage text
 to handle arbitrary text spans for changes or to handle drawing yourself
 for an existing widget. The Span… interfaces and classes are used to create or manage spans of
 text in a View item. You can use these to style the text or background or to
 listen for changes. If creating your own widget extend DynamicLayout to manages
 the actual wrapping and drawing of your text.",no,no,0,no,no,no,no,
<android.view.accessibility.AccessibilityManager: void interrupt()>,Requests feedback interruption from all accessibility services.,,void,4,"System level service that serves as an event dispatch for  AccessibilityEvent s
 and provides facilities for querying the accessibility state of the system.
 Accessibility events are generated when something notable happens in the user interface
 for example an  Activity  starts the focus or selection of a
  View  changes etc. Parties interested in handling accessibility
 events implement and register an accessibility service which extends
  AccessibilityService .",,no,no,0,no,no,no,no,
<android.widget.CompoundButton: void onRestoreInstanceState(Parcelable)>,"Hook allowing a view to re-apply a representation of its internal state that had previously
 been generated by onSaveInstanceState() . This function will never be called with a
 null state. If you override this method you must call through to the
 superclass implementation.",state Parcelable : The frozen state that had previously been returned by onSaveInstanceState() . |||,void,1,"A button with two states checked and unchecked. When the button is pressed
 or clicked the state changes automatically.
  XML attributes 
 See  CompoundButton Attributes   Button
 Attributes   TextView Attributes   View Attributes","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,no,0,no,no,no,no,
"<android.renderscript.Allocation: Allocation createFromBitmapResource(RenderScript,Resources,int)>","Creates a non-mipmapped Allocation to use as a graphics texture from the Bitmap referenced by resource ID. With target API version 18 or greater this allocation will be created
 with USAGE_SCRIPT and USAGE_GRAPHICS_TEXTURE . With
 target API version 17 or lower this allocation will be created with USAGE_GRAPHICS_TEXTURE .","rs RenderScript : Context to which the allocation will belong. |||
res Resources : application resources |||
id int : resource id to load the data from |||",Allocation Allocation containing resource data |||,11,"This class provides the primary method through which data is passed to
 and from RenderScript kernels.  An Allocation provides the backing store for
 a given  Type .   An Allocation also contains a set of usage flags that denote how the
 Allocation could be used. For example an Allocation may have usage flags
 specifying that it can be used from a script as well as input to a  Sampler . A developer must synchronize across these
 different usages using  syncAll(int)  in
 order to ensure that different users of the Allocation have a consistent view
 of memory. For example in the case where an Allocation is used as the output
 of one kernel and as Sampler input in a later kernel a developer must call
  syncAll(Allocation.USAGE_SCRIPT)  prior to launching the
 second kernel to ensure correctness.

  An Allocation can be populated with the  copyFrom(Bitmap)  routines. For
 more complex Element types the  copyFromUnchecked(byte[])  methods can be
 used to copy from byte arrays or similar constructs.","RenderScript provides support for high-performance computation across heterogeneous processors. For more information see the
  RenderScript  developer guide.",no,no,0,no,no,no,no,
"<android.content.Intent: Intent putExtra(String,char)>","Add extended data to the intent.  The name must include a package
 prefix for example the app com.android.contacts would use names
 like ""com.android.contacts.ShowAll"".","name String : The name of the extra data with package prefix. |||
value char : The char array data value.
This value may be null . |||","Intent Returns the same Intent object for chaining multiple calls
 into a single statement.

 This value will never be null . |||",1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",IPC,no,0,no,no,no,no,
"<android.app.NotificationManager: void cancel(String,int)>","Cancels a previously posted notification. If the notification does not currently represent a Service#startForeground(int Notification) it will be
  removed from the UI and live notification listeners will be informed so they can remove the notification from their UIs.","tag String : This value may be null . |||
id int |||",void,5,"A class that represents how a persistent notification is to be presented to
 the user using the  NotificationManager .

  The  Notification.Builder  has been added to make it
 easier to construct Notifications.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getChild(int)>,"Get the child at given index. Note: It is a client responsibility to recycle the
     received info by calling AccessibilityNodeInfo#recycle() to avoid creating of multiple instances.",index int : The child index. |||,AccessibilityNodeInfo The child node. |||,14,"This class represents a node of the window content as well as actions that
 can be requested from its source. From the point of view of an
  AccessibilityService  a window's content is
 presented as a tree of accessibility node infos which may or may not map one-to-one
 to the view hierarchy. In other words a custom view is free to report itself as
 a tree of accessibility node info.
  
 Once an accessibility node info is delivered to an accessibility service it is
 made immutable and calling a state mutation method generates an error.
  
 Please refer to  AccessibilityService  for
 details about how to obtain a handle to window content as a tree of accessibility
 node info as well as details about the security model.",,no,no,0,no,no,no,no,
<android.webkit.WebView: float getScale()>,"This method was deprecated
      in API level 17. This method is prone to inaccuracy due to race conditions
 between the web rendering and UI threads; prefer WebViewClient#onScaleChanged . Gets the current scale of this WebView.",,float the current scale |||,1,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",no,network ,0,no,no,no,no,
"<android.content.Intent: Intent putExtra(String,char)>","Add extended data to the intent.  The name must include a package
 prefix for example the app com.android.contacts would use names
 like ""com.android.contacts.ShowAll"".","name String : The name of the extra data with package prefix. |||
value char : The char array data value.
This value may be null . |||","Intent Returns the same Intent object for chaining multiple calls
 into a single statement.

 This value will never be null . |||",1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,
<android.view.KeyEvent: int getUnicodeChar()>,"Gets the Unicode character generated by the specified key and meta
 key state combination. Returns the Unicode character that the specified key would produce
 when the specified meta bits (see MetaKeyKeyListener )
 were active. Returns 0 if the key is not one that is used to type Unicode
 characters. If the return value has bit KeyCharacterMap#COMBINING_ACCENT set the
 key is a ""dead key"" that should be combined with another to
 actually produce a character -- see KeyCharacterMap#getDeadChar --
 after masking with KeyCharacterMap#COMBINING_ACCENT_MASK .",,int The associated character or combining accent or 0 if none. |||,1,"Object used to report key and button events.
  
 Each key press is described by a sequence of key events.  A key press
 starts with a key event with  ACTION_DOWN .  If the key is held
 sufficiently long that it repeats then the initial down is followed
 additional key events with  ACTION_DOWN  and a non-zero value for
  getRepeatCount() .  The last key event is a  ACTION_UP 
 for the key up.  If the key press is canceled the key up event will have the
  FLAG_CANCELED  flag set.
  
 Key events are generally accompanied by a key code ( getKeyCode() )
 scan code ( getScanCode() ) and meta state ( getMetaState() ).
 Key code constants are defined in this class.  Scan code constants are raw
 device-specific codes obtained from the OS and so are not generally meaningful
 to applications unless interpreted using the  KeyCharacterMap .
 Meta states describe the pressed state of key modifiers
 such as  META_SHIFT_ON  or  META_ALT_ON .
  
 Key codes typically correspond one-to-one with individual keys on an input device.
 Many keys and key combinations serve quite different functions on different
 input devices so care must be taken when interpreting them.  Always use the
  KeyCharacterMap  associated with the input device when mapping keys
 to characters.  Be aware that there may be multiple key input devices active
 at the same time and each will have its own key character map.
  
 As soft input methods can use multiple and inventive ways of inputting text
 there is no guarantee that any key press on a soft keyboard will generate a key
 event: this is left to the IME's discretion and in fact sending such events is
 discouraged.  You should never rely on receiving KeyEvents for any key on a soft
 input method.  In particular the default software keyboard will never send any
 key event to any application targetting Jelly Bean or later and will only send
 events for some presses of the delete and return keys to applications targetting
 Ice Cream Sandwich or earlier.  Be aware that other software input methods may
 never send key events regardless of the version.  Consider using editor actions
 like  EditorInfo.IME_ACTION_DONE  if you need
 specific interaction with the software keyboard as it gives more visibility to
 the user as to how your application will react to key presses.
  
 When interacting with an IME the framework may deliver key events
 with the special action  ACTION_MULTIPLE  that either specifies
 that single repeated key code or a sequence of characters to insert.
  
 In general the framework cannot guarantee that the key events it delivers
 to a view always constitute complete key sequences since some events may be dropped
 or modified by containing views before they are delivered.  The view implementation
 should be prepared to handle  FLAG_CANCELED  and should tolerate anomalous
 situations such as receiving a new  ACTION_DOWN  without first having
 received an  ACTION_UP  for the prior key press.
  
 Refer to  InputDevice  for more information about how different kinds of
 input devices and sources represent keys and buttons.",,keyboard data,keyboard,1,yes,no,SOURCE,no,
<android.app.ProgressDialog: void incrementProgressBy(int)>,Increments the current progress value.,"diff int : the amount by which the current progress will be incremented
up to getMax() |||",void,1,"A dialog showing a progress indicator and an optional text message or view.
 Only a text message or a view can be used at the same time.

  The dialog can be made cancelable on back key press. The progress range is 0 to  max .","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,UI,0,no,no,no,no,
"<android.content.Intent: Intent putCharSequenceArrayListExtra(String,ArrayList)>","Add extended data to the intent.  The name must include a package
 prefix for example the app com.android.contacts would use names
 like ""com.android.contacts.ShowAll"".","name String : The name of the extra data with package prefix. |||
value ArrayList : The ArrayList data value.
This value may be null . |||","Intent Returns the same Intent object for chaining multiple calls
 into a single statement.

 This value will never be null . |||",8,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,
"<android.accounts.AccountManager: AccountManagerFuture getAuthTokenByFeatures(String,String,String,Activity,Bundle,Bundle,AccountManagerCallback,Handler)>","This convenience helper combines the functionality of getAccountsByTypeAndFeatures(String String[] AccountManagerCallback Handler)  getAuthToken(Account String Bundle Activity AccountManagerCallback Handler) and addAccount(String String String[] Bundle Activity AccountManagerCallback Handler) . This method gets a list of the accounts matching specific type and feature set which are
 visible to the caller (see getAccountsByType(String) for details);
 if there is exactly one already visible account it is used; if there are some
 accounts for which user grant visibility the user is prompted to pick one; if there are
 none the user is prompted to add one. Finally an auth token is acquired for the chosen
 account. This method may be called from any thread but the returned AccountManagerFuture must
 not be used on the main thread. NOTE: If targeting your app to work on API level 22 and before MANAGE_ACCOUNTS
 permission is needed for those platforms. See docs for this function in API level 22. Requires android.Manifest.permission.MANAGE_ACCOUNTS","accountType String : The account type required (see getAccountsByType(String) ) must not be
null |||
authTokenType String : The desired auth token type (see getAuthToken(Account String Bundle Activity AccountManagerCallback Handler) ) must not be
null |||
features String : Required features for the account (see getAccountsByTypeAndFeatures(String String[] AccountManagerCallback Handler) ) may be null or empty |||
activity Activity : The Activity context to use for launching new sub-Activities to
prompt to add an account select an account and/or enter a password as necessary;
used only to call startActivity(); should not be null |||
addAccountOptions Bundle : Authenticator-specific options to use for adding new accounts; may
be null or empty |||
getAuthTokenOptions Bundle : Authenticator-specific options to use for getting auth tokens; may
be null or empty |||
callback AccountManagerCallback : Callback to invoke when the request completes null for no callback |||
handler Handler : Handler identifying the callback thread null for the main thread |||","AccountManagerFuture < Bundle > An AccountManagerFuture which resolves to a Bundle with at least the
         following fields: KEY_ACCOUNT_NAME - the name of the account KEY_ACCOUNT_TYPE - the type of the account KEY_AUTHTOKEN - the auth token you wanted If an error occurred AccountManagerFuture#getResult() throws: AuthenticatorException if no authenticator was registered for this
         account type or the authenticator failed to respond OperationCanceledException if the operation was canceled for any reason
         including the user canceling any operation IOException if the authenticator experienced an I/O problem updating
         settings usually because of network trouble |||",5,"This class provides access to a centralized registry of the user's
 online accounts.  The user enters credentials (username and password) once
 per account granting applications access to online resources with
 ""one-click"" approval.

  Different online services have different ways of handling accounts and
 authentication so the account manager uses pluggable  authenticator 
 modules for different  account types .  Authenticators (which may be
 written by third parties) handle the actual details of validating account
 credentials and storing account information.  For example Google Facebook
 and Microsoft Exchange each have their own authenticator.

  Many servers support some notion of an  authentication token 
 which can be used to authenticate a request to the server without sending
 the user's actual password.  (Auth tokens are normally created with a
 separate request which does include the user's credentials.)  AccountManager
 can generate auth tokens for applications so the application doesn't need to
 handle passwords directly.  Auth tokens are normally reusable and cached by
 AccountManager but must be refreshed periodically.  It's the responsibility
 of applications to  invalidate  auth tokens when they stop working so
 the AccountManager knows it needs to regenerate them.

  Applications accessing a server normally go through these steps:

  Get an instance of AccountManager using  get(android.content.Context) .

  List the available accounts using  getAccountsByType(String)  or
  getAccountsByTypeAndFeatures(String String[] AccountManagerCallback  Handler) .  Normally applications will only
 be interested in accounts with one particular  type  which
 identifies the authenticator.  Account  features  are used to
 identify particular account subtypes and capabilities.  Both the account
 type and features are authenticator-specific strings and must be known by
 the application in coordination with its preferred authenticators.

  Select one or more of the available accounts possibly by asking the
 user for their preference.  If no suitable accounts are available
  addAccount(String String String[] Bundle Activity AccountManagerCallback  Handler)  may be called to prompt the user to create an
 account of the appropriate type.

  Important:  If the application is using a previously remembered
 account selection it must make sure the account is still in the list
 of accounts returned by  getAccountsByType(String) .  Requesting an auth token
 for an account no longer on the device results in an undefined failure.

  Request an auth token for the selected account(s) using one of the
  getAuthToken(Account String Bundle Activity AccountManagerCallback  Handler)  methods or related helpers.  Refer to the description
 of each method for exact usage and error handling details.

  Make the request using the auth token.  The form of the auth token
 the format of the request and the protocol used are all specific to the
 service you are accessing.  The application may use whatever network and
 protocol libraries are useful.

  Important:  If the request fails with an authentication error
 it could be that a cached auth token is stale and no longer honored by
 the server.  The application must call  invalidateAuthToken(String String)  to remove
 the token from the cache otherwise requests will continue failing!  After
 invalidating the auth token immediately go back to the ""Request an auth
 token"" step above.  If the process fails the second time then it can be
 treated as a ""genuine"" authentication failure and the user notified or other
 appropriate actions taken.
  Some AccountManager methods may need to interact with the user to
 prompt for credentials present options or ask the user to add an account.
 The caller may choose whether to allow AccountManager to directly launch the
 necessary user interface and wait for the user or to return an Intent which
 the caller may use to launch the interface or (in some cases) to install a
 notification which the user can select at any time to launch the interface.
 To have AccountManager launch the interface directly the caller must supply
 the current foreground  Activity  context.

  Many AccountManager methods take  AccountManagerCallback  and
  Handler  as parameters.  These methods return immediately and
 run asynchronously. If a callback is provided then
  AccountManagerCallback#run  will be invoked on the Handler's
 thread when the request completes successfully or not.
 The result is retrieved by calling  AccountManagerFuture#getResult() 
 on the  AccountManagerFuture  returned by the method (and also passed
 to the callback).  This method waits for the operation to complete (if
 necessary) and either returns the result or throws an exception if an error
 occurred during the operation.  To make the request synchronously call
  AccountManagerFuture#getResult()  immediately on receiving the
 future from the method; no callback need be supplied.

  Requests which may block including
  AccountManagerFuture#getResult()  must never be called on
 the application's main event thread.  These operations throw
  IllegalStateException  if they are used on the main thread.",,account info,account info storage file,1,yes,no,SOURCE,no,
<android.view.animation.Animation: void cancel()>,"Cancel the animation. Cancelling an animation invokes the animation
 listener if set to notify the end of the animation.

 If you cancel an animation manually you must call reset() before starting the animation again.",,void,8,"Abstraction for an Animation that can be applied to Views Surfaces or
 other objects. See the  animation package
 description file .",,no,no,0,no,no,no,no,
"<android.content.ContextWrapper: void sendOrderedBroadcast(Intent,String)>","Broadcast the given intent to all interested BroadcastReceivers delivering
 them one at a time to allow more preferred receivers to consume the
 broadcast before it is delivered to less preferred receivers.  This
 call is asynchronous; it returns immediately and you will continue
 executing while the receivers are run. See BroadcastReceiver for more information on Intent broadcasts.","intent Intent : The Intent to broadcast; all receivers matching this
Intent will receive the broadcast. |||
receiverPermission String : (optional) String naming a permissions that
a receiver must hold in order to receive your broadcast.
If null no permission is required.
This value may be null . |||",void,1,"Proxying implementation of Context that simply delegates all of its calls to
 another Context.  Can be subclassed to modify behavior without changing
 the original Context.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",IPC,IPC,1,no,yes,no,SINK,
<android.appwidget.AppWidgetManager: List getInstalledProviders()>,Return a list of the AppWidget providers that are currently installed.,,List < AppWidgetProviderInfo > |||,3,"Updates AppWidget state; gets information about installed AppWidget providers and other
 AppWidget related state.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
<android.widget.CursorTreeAdapter: void changeCursor(Cursor)>,,cursor Cursor |||,void,1,"An adapter that exposes data from a series of  Cursor s to an
  ExpandableListView  widget. The top-level  Cursor  (that is
 given in the constructor) exposes the groups while subsequent  Cursor s
 returned from  getChildrenCursor(android.database.Cursor)  expose children within a
 particular group. The Cursors must include a column named ""_id"" or this class
 will not work.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,no,0,no,no,no,no,
<android.app.Dialog: void setContentView(int)>,"Set the screen content from a layout resource.  The resource will be
 inflated adding all top-level views to the screen.",layoutResID int : Resource ID to be inflated. |||,void,1,"Base class for Dialogs.

  Note: Activities provide a facility to manage the creation saving and
 restoring of dialogs. See  Activity#onCreateDialog(int) 
  Activity#onPrepareDialog(int Dialog) 
  Activity#showDialog(int)  and  Activity#dismissDialog(int) . If
 these methods are used  getOwnerActivity()  will return the Activity
 that managed this dialog.

  Often you will want to have a Dialog display on top of the current
 input method because there is no reason for it to accept text.  You can
 do this by setting the  WindowManager.LayoutParams#FLAG_ALT_FOCUSABLE_IM  window flag (assuming
 your Dialog takes input focus as it the default) with the following code:

  
 getWindow().setFlags(WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM
         WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,UI,0,no,no,no,no,
"<android.content.Intent: Intent putExtra(String,boolean)>","Add extended data to the intent.  The name must include a package
 prefix for example the app com.android.contacts would use names
 like ""com.android.contacts.ShowAll"".","name String : The name of the extra data with package prefix. |||
value boolean : The boolean array data value.
This value may be null . |||","Intent Returns the same Intent object for chaining multiple calls
 into a single statement.

 This value will never be null . |||",1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",IPC,no,0,no,no,no,no,
<android.view.Display: void getMetrics(DisplayMetrics)>,"This method was deprecated
      in API level R. Use WindowMetrics#getSize() to get the dimensions of the application
 window area and Configuration#densityDpi to get the current density. Gets display metrics that describe the size and density of this display.
 The size returned by this method does not necessarily represent the
 actual raw size (native resolution) of the display. 1. The returned size may be adjusted to exclude certain system decor elements
 that are always visible. 2. It may be scaled to provide compatibility with older applications that
 were originally designed for smaller displays. 3. It can be different depending on the WindowManager to which the display belongs. - If requested from non-Activity context (e.g. Application context via (WindowManager) getApplicationContext().getSystemService(Context.WINDOW_SERVICE) )
 metrics will report the size of the entire display based on current rotation and with
 subtracted system decoration areas. - If requested from activity (either using getWindowManager() or (WindowManager) getSystemService(Context.WINDOW_SERVICE) ) resulting metrics will
 correspond to current app window metrics. In this case the size can be smaller than physical
 size in multi-window mode.",outMetrics DisplayMetrics : A DisplayMetrics object to receive the metrics. |||,void,1,"Provides information about the size and density of a logical display.
  
 The display area is described in two different ways.
  The application display area specifies the part of the display that may contain
 an application window excluding the system decorations.  The application display area may
 be smaller than the real display area because the system subtracts the space needed
 for decor elements such as the status bar.  Use the following methods to query the
 application display area:  getSize(Point)   getRectSize(Rect)  and  getMetrics(DisplayMetrics) . The real display area specifies the part of the display that contains content
 including the system decorations.  Even so the real display area may be smaller than the
 physical size of the display if the window manager is emulating a smaller display
 using (adb shell wm size).  Use the following methods to query the
 real display area:  getRealSize(Point)   getRealMetrics(DisplayMetrics) . 
 A logical display does not necessarily represent a particular physical display device
 such as the built-in screen or an external monitor.  The contents of a logical
 display may be presented on one or more physical displays according to the devices
 that are currently attached and whether mirroring has been enabled.",,UI metadata,UI,1,yes,no,SOURCE,no,
<android.app.AlertDialog: void setIcon(int)>,Set resId to 0 if you don't want an icon.,"resId int : the resourceId of the drawable to use as the icon or 0
if you don't want an icon. |||",void,1,"A subclass of Dialog that can display one two or three buttons. If you only want to
 display a String in this dialog box use the setMessage() method.  If you
 want to display a more complex view look up the FrameLayout called ""custom""
 and add your view to it:

  
 FrameLayout fl = findViewById(android.R.id.custom);
 fl.addView(myView new LayoutParams(MATCH_PARENT WRAP_CONTENT));
  The AlertDialog class takes care of automatically setting
  WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM  for you based on whether
 any views in the dialog return true from  View#onCheckIsTextEditor() .  Generally you want this set for a Dialog
 without text editors so that it will be placed on top of the current
 input method UI.  You can modify this behavior by forcing the flag to your
 desired mode after calling  onCreate(Bundle) .","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
<android.os.Bundle: void remove(String)>,Removes any entry with the given key from the mapping of this Bundle.,key String : a String key |||,void,1,A mapping from String keys to various  Parcelable  values.,,no,no,0,no,no,no,no,
<android.content.ContextWrapper: int getWallpaperDesiredMinimumWidth()>,This method is deprecated. Use WallpaperManager.getDesiredMinimumWidth() instead.,,int |||,1,"Proxying implementation of Context that simply delegates all of its calls to
 another Context.  Can be subclassed to modify behavior without changing
 the original Context.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",UI metadata,UI,1,no,yes,no,SINK,
<android.content.res.Resources: int getInteger(int)>,Return an integer associated with a particular resource ID.,"id int : The desired resource identifier as generated by the aapt
tool. This integer encodes the package type and resource
entry. The value 0 is an invalid identifier. |||",int Returns the integer value contained in the resource. |||,1,"Class for accessing an application's resources.  This sits on top of the
 asset manager of the application (accessible through  getAssets() ) and
 provides a high-level API for getting typed data from the assets.

  The Android resource system keeps track of all non-code assets associated with an
 application. You can use this class to access your application's resources. You can generally
 acquire the  Resources  instance associated with your application
 with  getResources() . The Android SDK tools compile your application's resources into the application binary
 at build time.  To use a resource you must install it correctly in the source tree (inside
 your project's  res/  directory) and build your application.  As part of the build
 process the SDK tools generate symbols for each resource which you can use in your application
 code to access the resources. Using application resources makes it easy to update various characteristics of your
 application without modifying code and—by providing sets of alternative
 resources—enables you to optimize your application for a variety of device configurations
 (such as for different languages and screen sizes). This is an important aspect of developing
 Android applications that are compatible on different types of devices. For more information about using resources see the documentation about  Application Resources .","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,
"<android.text.method.DigitsKeyListener: CharSequence filter(CharSequence,int,int,Spanned,int,int)>","This method is called when the buffer is going to replace the
 range dstart … dend of dest with the new text from the range start … end of source .  Return the CharSequence that you would
 like to have placed there instead including an empty string
 if appropriate or null to accept the original
 replacement.  Be careful to not to reject 0-length replacements
 as this is what happens when you delete text.  Also beware that
 you should not attempt to make any changes to dest from this method; you may only examine it for context.

 Note: If source is an instance of Spanned or Spannable the span objects in the source should be
 copied into the filtered result (i.e. the non-null return value). TextUtils#copySpansFrom can be used for convenience if the
 span boundary indices would be remaining identical relative to the source.","source CharSequence |||
start int |||
end int |||
dest Spanned |||
dstart int |||
dend int |||",CharSequence |||,1,"For digits-only text entry
  KeyListener","Provides classes that monitor or modify keypad input. You can use these classes to modify the type of keypad entry
 for your application or decipher the keypresses entered for your specific
 entry method. For example: 
 // Set the text to password display style:
 EditText txtView = (EditText)findViewById(R.id.text);
 txtView.setTransformationMethod(PasswordTransformationMethod.getInstance());

 //Set the input style to numbers rather than qwerty keyboard style.
 txtView.setInputMethod(DigitsInputMethod.getInstance());

 // Find out whether the caps lock is on.
 // 0 is no 1 is yes 2 is caps lock on.
 int active = MultiTapInputMethod.getCapsActive(txtView.getText());",uncategorized,UI,1,yes,no,no,no,
"<android.view.Window: void setWindowManager(WindowManager,IBinder,String)>","Set the window manager for use by this Window to for example
 display panels.  This is not used for displaying the
 Window itself -- that must be done by the client.","wm WindowManager : The window manager for adding new windows. |||
appToken IBinder |||
appName String |||",void,1,"Abstract base class for a top-level window look and behavior policy.  An
 instance of this class should be used as the top-level view added to the
 window manager. It provides standard UI policies such as a background title
 area default key processing etc.

  The only existing implementation of this abstract class is
 android.view.PhoneWindow which you should instantiate when needing a
 Window.",,no,UI,0,no,no,no,no,
<android.app.Dialog: void onBackPressed()>,"Called when the dialog has detected the user's press of the back
 key.  The default implementation simply cancels the dialog (only if
 it is cancelable) but you can override this to do whatever you want.",,void,5,"Base class for Dialogs.

  Note: Activities provide a facility to manage the creation saving and
 restoring of dialogs. See  Activity#onCreateDialog(int) 
  Activity#onPrepareDialog(int Dialog) 
  Activity#showDialog(int)  and  Activity#dismissDialog(int) . If
 these methods are used  getOwnerActivity()  will return the Activity
 that managed this dialog.

  Often you will want to have a Dialog display on top of the current
 input method because there is no reason for it to accept text.  You can
 do this by setting the  WindowManager.LayoutParams#FLAG_ALT_FOCUSABLE_IM  window flag (assuming
 your Dialog takes input focus as it the default) with the following code:

  
 getWindow().setFlags(WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM
         WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,UI,0,no,no,no,no,
"<android.content.Intent: Intent putExtra(String,int)>","Add extended data to the intent.  The name must include a package
 prefix for example the app com.android.contacts would use names
 like ""com.android.contacts.ShowAll"".","name String : The name of the extra data with package prefix. |||
value int : The int array data value.
This value may be null . |||","Intent Returns the same Intent object for chaining multiple calls
 into a single statement.

 This value will never be null . |||",1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",IPC,no,0,no,no,no,no,
<android.os.Parcel: HashMap readHashMap(ClassLoader)>,"Please use readBundle(java.lang.ClassLoader) instead (whose data must have
 been written with writeBundle(Bundle) .  Read and return a new HashMap
 object from the parcel at the current dataPosition() using the given
 class loader to load any enclosed Parcelables.  Returns null if
 the previously written map object was null.",loader ClassLoader : This value may be null . |||,HashMap |||,1,"Container for a message (data and object references) that can
 be sent through an IBinder.  A Parcel can contain both flattened data
 that will be unflattened on the other side of the IPC (using the various
 methods here for writing specific types or the general
  Parcelable  interface) and references to live  IBinder 
 objects that will result in the other side receiving a proxy IBinder
 connected with the original IBinder in the Parcel.

  Parcel is  not  a general-purpose
 serialization mechanism.  This class (and the corresponding
  Parcelable  API for placing arbitrary objects into a Parcel) is
 designed as a high-performance IPC transport.  As such it is not
 appropriate to place any Parcel data in to persistent storage: changes
 in the underlying implementation of any of the data in the Parcel can
 render older data unreadable. The bulk of the Parcel API revolves around reading and writing data
 of various types.  There are six major classes of such functions available. Primitives The most basic data functions are for writing and reading primitive
 data types:  writeByte(byte)   readByte()   writeDouble(double) 
  readDouble()   writeFloat(float)   readFloat()   writeInt(int) 
  readInt()   writeLong(long)   readLong() 
  writeString(String)   readString() .  Most other
 data operations are built on top of these.  The given data is written and
 read using the endianess of the host CPU. Primitive Arrays There are a variety of methods for reading and writing raw arrays
 of primitive objects which generally result in writing a 4-byte length
 followed by the primitive data items.  The methods for reading can either
 read the data into an existing array or create and return a new array.
 These available types are: writeBooleanArray(boolean[]) 
  readBooleanArray(boolean[])   createBooleanArray() writeByteArray(byte[]) 
  writeByteArray(byte[] int int)   readByteArray(byte[]) 
  createByteArray() writeCharArray(char[])   readCharArray(char[]) 
  createCharArray() writeDoubleArray(double[])   readDoubleArray(double[]) 
  createDoubleArray() writeFloatArray(float[])   readFloatArray(float[]) 
  createFloatArray() writeIntArray(int[])   readIntArray(int[]) 
  createIntArray() writeLongArray(long[])   readLongArray(long[]) 
  createLongArray() writeStringArray(java.lang.String[])   readStringArray(java.lang.String[]) 
  createStringArray() .
  writeSparseBooleanArray(android.util.SparseBooleanArray) 
  readSparseBooleanArray() .
  Parcelables The  Parcelable  protocol provides an extremely efficient (but
 low-level) protocol for objects to write and read themselves from Parcels.
 You can use the direct methods  writeParcelable(android.os.Parcelable int) 
 and  readParcelable(java.lang.ClassLoader)  or
  writeParcelableArray(T[] int)  and
  readParcelableArray(java.lang.ClassLoader)  to write or read.  These
 methods write both the class type and its data to the Parcel allowing
 that class to be reconstructed from the appropriate class loader when
 later reading. There are also some methods that provide a more efficient way to work
 with Parcelables:  writeTypedObject(T int)   writeTypedArray(T[] int) 
  writeTypedList(List )   readTypedObject(Parcelable.Creator ) 
  createTypedArray(Parcelable.Creator )  and  createTypedArrayList(Parcelable.Creator ) .  These methods
 do not write the class information of the original object: instead the
 caller of the read function must know what type to expect and pass in the
 appropriate  Parcelable.Creator  instead to
 properly construct the new object and read its data.  (To more efficient
 write and read a single Parcelable object that is not null you can directly
 call  Parcelable#writeToParcel  and
  Parcelable.Creator#createFromParcel 
 yourself.) Bundles A special type-safe container called  Bundle  is available
 for key/value maps of heterogeneous values.  This has many optimizations
 for improved performance when reading and writing data and its type-safe
 API avoids difficult to debug type errors when finally marshalling the
 data contents into a Parcel.  The methods to use are
  writeBundle(android.os.Bundle)   readBundle()  and
  readBundle(java.lang.ClassLoader) .

  Active Objects An unusual feature of Parcel is the ability to read and write active
 objects.  For these objects the actual contents of the object is not
 written rather a special token referencing the object is written.  When
 reading the object back from the Parcel you do not get a new instance of
 the object but rather a handle that operates on the exact same object that
 was originally written.  There are two forms of active objects available. Binder  objects are a core facility of Android's general cross-process
 communication system.  The  IBinder  interface describes an abstract
 protocol with a Binder object.  Any such interface can be written in to
 a Parcel and upon reading you will receive either the original object
 implementing that interface or a special proxy implementation
 that communicates calls back to the original object.  The methods to use are
  writeStrongBinder(android.os.IBinder) 
  writeStrongInterface(android.os.IInterface)   readStrongBinder() 
  writeBinderArray(android.os.IBinder[])   readBinderArray(android.os.IBinder[]) 
  createBinderArray() 
  writeBinderList(java.util.List)   readBinderList(java.util.List) 
  createBinderArrayList() . FileDescriptor objects representing raw Linux file descriptor identifiers
 can be written and  ParcelFileDescriptor  objects returned to operate
 on the original file descriptor.  The returned file descriptor is a dup
 of the original file descriptor: the object and fd is different but
 operating on the same underlying file stream with the same position etc.
 The methods to use are  writeFileDescriptor(java.io.FileDescriptor) 
  readFileDescriptor() .

  Untyped Containers A final class of methods are for writing and reading standard Java
 containers of arbitrary types.  These all revolve around the
  writeValue(java.lang.Object)  and  readValue(java.lang.ClassLoader)  methods
 which define the types of objects allowed.  The container methods are
  writeArray(java.lang.Object[])   readArray(java.lang.ClassLoader) 
  writeList(java.util.List)   readList(java.util.List java.lang.ClassLoader) 
  readArrayList(java.lang.ClassLoader) 
  writeMap(java.util.Map)   readMap(java.util.Map java.lang.ClassLoader) 
  writeSparseArray(android.util.SparseArray) 
  readSparseArray(java.lang.ClassLoader) .",,IPC,no,0,no,no,no,no,
<android.hardware.input.InputManager: int getInputDeviceIds()>,Gets the ids of all input devices in the system.,,int[] The input device ids. |||,16,Provides information about input devices and available key layouts.,,input metadata,input device,1,yes,no,SOURCE,no,
<android.text.SpannableStringBuilder: SpannableStringBuilder append(char)>,Convenience for append(String.valueOf(text)).,text char : The character to append |||,SpannableStringBuilder A reference to this Appendable |||,1,"This is the class for text whose content is immutable but to which
 markup objects can be attached and detached.
 For mutable text see  SpannableStringBuilder .","Provides classes used to render or track text and text spans on the screen. You can use these classes to design your own widgets that manage text
 to handle arbitrary text spans for changes or to handle drawing yourself
 for an existing widget. The Span… interfaces and classes are used to create or manage spans of
 text in a View item. You can use these to style the text or background or to
 listen for changes. If creating your own widget extend DynamicLayout to manages
 the actual wrapping and drawing of your text.",no,no,0,no,no,no,no,
<android.view.KeyEvent: char getMatch(char)>,"Gets the first character in the character array that can be generated
 by the specified key code. This is a convenience function that returns the same value as getMatch(chars 0) .",chars char : The array of matching characters to consider. |||,char The matching associated character or 0 if none. |||,1,"Object used to report key and button events.
  
 Each key press is described by a sequence of key events.  A key press
 starts with a key event with  ACTION_DOWN .  If the key is held
 sufficiently long that it repeats then the initial down is followed
 additional key events with  ACTION_DOWN  and a non-zero value for
  getRepeatCount() .  The last key event is a  ACTION_UP 
 for the key up.  If the key press is canceled the key up event will have the
  FLAG_CANCELED  flag set.
  
 Key events are generally accompanied by a key code ( getKeyCode() )
 scan code ( getScanCode() ) and meta state ( getMetaState() ).
 Key code constants are defined in this class.  Scan code constants are raw
 device-specific codes obtained from the OS and so are not generally meaningful
 to applications unless interpreted using the  KeyCharacterMap .
 Meta states describe the pressed state of key modifiers
 such as  META_SHIFT_ON  or  META_ALT_ON .
  
 Key codes typically correspond one-to-one with individual keys on an input device.
 Many keys and key combinations serve quite different functions on different
 input devices so care must be taken when interpreting them.  Always use the
  KeyCharacterMap  associated with the input device when mapping keys
 to characters.  Be aware that there may be multiple key input devices active
 at the same time and each will have its own key character map.
  
 As soft input methods can use multiple and inventive ways of inputting text
 there is no guarantee that any key press on a soft keyboard will generate a key
 event: this is left to the IME's discretion and in fact sending such events is
 discouraged.  You should never rely on receiving KeyEvents for any key on a soft
 input method.  In particular the default software keyboard will never send any
 key event to any application targetting Jelly Bean or later and will only send
 events for some presses of the delete and return keys to applications targetting
 Ice Cream Sandwich or earlier.  Be aware that other software input methods may
 never send key events regardless of the version.  Consider using editor actions
 like  EditorInfo.IME_ACTION_DONE  if you need
 specific interaction with the software keyboard as it gives more visibility to
 the user as to how your application will react to key presses.
  
 When interacting with an IME the framework may deliver key events
 with the special action  ACTION_MULTIPLE  that either specifies
 that single repeated key code or a sequence of characters to insert.
  
 In general the framework cannot guarantee that the key events it delivers
 to a view always constitute complete key sequences since some events may be dropped
 or modified by containing views before they are delivered.  The view implementation
 should be prepared to handle  FLAG_CANCELED  and should tolerate anomalous
 situations such as receiving a new  ACTION_DOWN  without first having
 received an  ACTION_UP  for the prior key press.
  
 Refer to  InputDevice  for more information about how different kinds of
 input devices and sources represent keys and buttons.",,input data,keyboard,1,yes,no,SOURCE,no,
<android.accessibilityservice.AccessibilityService: void setServiceInfo(AccessibilityServiceInfo)>,"Sets the AccessibilityServiceInfo that describes this service. Note: You can call this method any time but the info will be picked up after
       the system has bound to this service and when this method is called thereafter.",info AccessibilityServiceInfo : The info. |||,void,4,"Accessibility services should only be used to assist users with disabilities in using
 Android devices and apps. They run in the background and receive callbacks by the system
 when  AccessibilityEvent s are fired. Such events denote some state transition
 in the user interface for example the focus has changed a button has been clicked
 etc. Such a service can optionally request the capability for querying the content
 of the active window. Development of an accessibility service requires extending this
 class and implementing its abstract methods.","The classes in this package are used for development of accessibility service that
   provide alternative or augmented feedback to the user.
  
   An  AccessibilityService  runs in the background and
   receives callbacks by the system when  AccessibilityEvent s
   are fired. Such events denote some state transition in the user interface for example the
   focus has changed a button has been clicked etc. Such a service can optionally request the
   capability for querying the content of the active window. Development of an accessibility
   service requires extends this class and implements its abstract methods.
  
   An  AccessibilityServiceInfo  describes an
    AccessibilityService . The system notifies an
   AccessibilityService for  AccessibilityEvent s
   according to the information encapsulated in this class.",no,no,0,no,no,no,no,
"<android.content.Intent: Intent parseUri(String,int)>","Create an intent from a URI.  This URI may encode the action
 category and other intent fields if it was returned by toUri(int) .  If the Intent was not generate by toUri() its data
 will be the entire URI and its action will be ACTION_VIEW. The URI given here must not be relative -- that is it must include
 the scheme and full path.","uri String : The URI to turn into an Intent. |||
flags int : Additional processing flags.
Value is either 0 or a combination of URI_ALLOW_UNSAFE  URI_ANDROID_APP_SCHEME and URI_INTENT_SCHEME |||",Intent Intent The newly created Intent object. |||,4,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",IPC,no,0,no,no,no,no,
"<android.net.sip.SipAudioCall: void attachCall(SipSession,String)>",Attaches an incoming call to this call object.,"session SipSession : the session that receives the incoming call |||
sessionDescription String : the session description of the incoming call |||",void,9,"Handles an Internet audio call over SIP. You can instantiate this class with  SipManager 
 using  SipManager#makeAudioCall  and   SipManager#takeAudioCall .

  Note:  Using this class require the
    Manifest.permission.INTERNET  and
    Manifest.permission.USE_SIP  permissions. In addition  startAudio()  requires the
    Manifest.permission.RECORD_AUDIO 
    Manifest.permission.ACCESS_WIFI_STATE  and
    Manifest.permission.WAKE_LOCK  permissions; and  setSpeakerMode()  requires the
    Manifest.permission.MODIFY_AUDIO_SETTINGS  permission.",,phone data,phone,1,no,yes,no,SINK,
<android.content.ContextWrapper: void unregisterReceiver(BroadcastReceiver)>,"Unregister a previously registered BroadcastReceiver. All filters that have been registered for this BroadcastReceiver will be
 removed.",receiver BroadcastReceiver : The BroadcastReceiver to unregister. |||,void,1,"Proxying implementation of Context that simply delegates all of its calls to
 another Context.  Can be subclassed to modify behavior without changing
 the original Context.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",IPC,no,0,no,no,no,no,
<android.app.admin.DevicePolicyManager: int getPasswordMinimumLowerCase(ComponentName)>,"Retrieve the current number of lower case letters required in the password
 for a particular admin or all admins that set restrictions on this user
 and its participating profiles. Restrictions on profiles that have
 a separate challenge are not taken into account.
 This is the same value as set by setPasswordMinimumLowerCase(android.content.ComponentName int) and only applies when the password quality is PASSWORD_QUALITY_COMPLEX . On devices not supporting PackageManager#FEATURE_SECURE_LOCK_SCREEN feature the
 password is always treated as empty. This method can be called on the DevicePolicyManager instance
 returned by getParentProfileInstance(android.content.ComponentName) in order to retrieve
 restrictions on the parent profile.","admin ComponentName : The name of the admin component to check or null to
aggregate all admins.
This value may be null . |||","int The minimum number of lower case letters required in the
         password. |||",11,"Public interface for managing policies enforced on a device. Most clients of this class must be
 registered with the system as a  device
 administrator . Additionally a device administrator may be registered as either a profile or
 device owner. A given method is accessible to all device administrators unless the documentation
 for that method specifies that it is restricted to either device or profile owners. Any
 application calling an api may only pass as an argument a device administrator component it
 owns. Otherwise a  SecurityException  will be thrown.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",password metadata,passwor,1,yes,no,SOURCE,no,
<android.nfc.tech.NfcF: void connect()>,"Enable I/O operations to the tag from this TagTechnology object. May cause RF activity and may block. Must not be called
 from the main application thread. A blocked call will be canceled with IOException by calling close() from another thread. Only one TagTechnology object can be connected to a Tag at a time. Applications must call close() when I/O operations are complete. Requires the Manifest.permission.NFC permission.",,void,-1,"Provides access to NFC-F (JIS 6319-4) properties and I/O operations on a  Tag .

  Acquire a  NfcF  object using  get(Tag) .
  The primary NFC-F I/O operation is  transceive(byte[]) . Applications must
 implement their own protocol stack on top of  transceive(byte[]) .

  Note:  Methods that perform I/O operations
 require the  Manifest.permission.NFC  permission.","These classes provide access to a tag technology's features which vary by the type
 of tag that is scanned. A scanned tag can support multiple technologies and you can find
 out what they are by calling  getTechList() . For more information on dealing with tag technologies and handling the ones that you care about see
  The Tag Dispatch System .
 The  TagTechnology  interface provides an overview of the
 supported technologies.",no,nfc,0,no,no,no,no,
<android.speech.tts.TextToSpeech: void shutdown()>,"Releases the resources used by the TextToSpeech engine.
 It is good practice for instance to call this method in the onDestroy() method of an Activity
 so the TextToSpeech engine can be cleanly stopped.",,void,4,"Synthesizes speech from text for immediate playback or to create a sound file.
  A TextToSpeech instance can only be used to synthesize text once it has completed its
 initialization. Implement the  TextToSpeech.OnInitListener  to be
 notified of the completion of the initialization. 
 When you are done using the TextToSpeech instance call the  shutdown()  method
 to release the native resources used by the TextToSpeech engine.",,no,no,0,no,no,no,no,
<android.text.method.TextKeyListener: void release()>,,,void,1,"This is the key listener for typing normal text.  It delegates to
 other key listeners appropriate to the current keyboard and language.
  KeyListener","Provides classes that monitor or modify keypad input. You can use these classes to modify the type of keypad entry
 for your application or decipher the keypresses entered for your specific
 entry method. For example: 
 // Set the text to password display style:
 EditText txtView = (EditText)findViewById(R.id.text);
 txtView.setTransformationMethod(PasswordTransformationMethod.getInstance());

 //Set the input style to numbers rather than qwerty keyboard style.
 txtView.setInputMethod(DigitsInputMethod.getInstance());

 // Find out whether the caps lock is on.
 // 0 is no 1 is yes 2 is caps lock on.
 int active = MultiTapInputMethod.getCapsActive(txtView.getText());",no,input device,0,no,no,no,no,
<android.nfc.tech.MifareUltralight: int getTimeout()>,Get the current transceive(byte[]) timeout in milliseconds. Requires the Manifest.permission.NFC permission.,,int timeout value in milliseconds |||,14,"Provides access to MIFARE Ultralight properties and I/O operations on a  Tag .

  Acquire a  MifareUltralight  object using  get(Tag) .

  MIFARE Ultralight compatible tags have 4 byte pages  PAGE_SIZE .
 The primary operations on an Ultralight tag are  readPages(int)  and
  writePage(int byte[]) .

  The original MIFARE Ultralight consists of a 64 byte EEPROM. The first
 4 pages are for the OTP area manufacturer data and locking bits. They are
 readable and some bits are writable. The final 12 pages are the user
 read/write area. For more information see the NXP data sheet MF0ICU1.

  The MIFARE Ultralight C consists of a 192 byte EEPROM. The first 4 pages
 are for OTP manufacturer data and locking bits. The next 36 pages are the
 user read/write area. The next 4 pages are additional locking bits counters
 and authentication configuration and are readable. The final 4 pages are for
 the authentication key and are not readable. For more information see the
 NXP data sheet MF0ICU2.

  Implementation of this class on a Android NFC device is optional.
 If it is not implemented then
  MifareUltralight  will never be enumerated in  Tag#getTechList .
 If it is enumerated then all  MifareUltralight  I/O operations will be supported.
 In either case  NfcA  will also be enumerated on the tag
 because all MIFARE Ultralight tags are also  NfcA  tags.

  Note:  Methods that perform I/O operations
 require the  Manifest.permission.NFC  permission.","These classes provide access to a tag technology's features which vary by the type
 of tag that is scanned. A scanned tag can support multiple technologies and you can find
 out what they are by calling  getTechList() . For more information on dealing with tag technologies and handling the ones that you care about see
  The Tag Dispatch System .
 The  TagTechnology  interface provides an overview of the
 supported technologies.",nfc metadata,nfc,1,yes,no,SOURCE,no,
<android.view.ViewPropertyAnimator: ViewPropertyAnimator translationXBy(float)>,"This method will cause the View's translationX property to be animated by the
 specified value. Animations already running on the property will be canceled.",value float : The amount to be animated by as an offset from the current value. |||,ViewPropertyAnimator This object allowing calls to methods in this class to be chained. |||,12,"This class enables automatic and optimized animation of select properties on View objects.
 If only one or two properties on a View object are being animated then using an
  ObjectAnimator  is fine; the property setters called by ObjectAnimator
 are well equipped to do the right thing to set the property and invalidate the view
 appropriately. But if several properties are animated simultaneously or if you just want a
 more convenient syntax to animate a specific property then ViewPropertyAnimator might be
 more well-suited to the task.

  This class may provide better performance for several simultaneous animations because
 it will optimize invalidate calls to take place only once for several properties instead of each
 animated property independently causing its own invalidation. Also the syntax of using this
 class could be easier to use because the caller need only tell the View object which
 property to animate and the value to animate either to or by and this class handles the
 details of configuring the underlying Animator class and starting it. This class is not constructed by the caller but rather by the View whose properties
 it will animate. Calls to  View.animate()  will return a reference
 to the appropriate ViewPropertyAnimator object for that View.",,no,UI,0,no,no,no,no,
<android.view.textservice.SpellCheckerInfo: CharSequence loadLabel(PackageManager)>,Load the user-displayed label for this spell checker.,pm PackageManager : Supply a PackageManager used to load the spell checker's resources. |||,CharSequence |||,14,This class is used to specify meta information of a spell checker.,,no,no,0,no,no,no,no,
<android.os.Parcel: void readException()>,"Special function for reading an exception result from the header of
 a parcel to be used after receiving the result of a transaction.  This
 will throw the exception for you if it had been written to the Parcel
 otherwise return and let you read the normal result data from the Parcel.",,void,1,"Container for a message (data and object references) that can
 be sent through an IBinder.  A Parcel can contain both flattened data
 that will be unflattened on the other side of the IPC (using the various
 methods here for writing specific types or the general
  Parcelable  interface) and references to live  IBinder 
 objects that will result in the other side receiving a proxy IBinder
 connected with the original IBinder in the Parcel.

  Parcel is  not  a general-purpose
 serialization mechanism.  This class (and the corresponding
  Parcelable  API for placing arbitrary objects into a Parcel) is
 designed as a high-performance IPC transport.  As such it is not
 appropriate to place any Parcel data in to persistent storage: changes
 in the underlying implementation of any of the data in the Parcel can
 render older data unreadable. The bulk of the Parcel API revolves around reading and writing data
 of various types.  There are six major classes of such functions available. Primitives The most basic data functions are for writing and reading primitive
 data types:  writeByte(byte)   readByte()   writeDouble(double) 
  readDouble()   writeFloat(float)   readFloat()   writeInt(int) 
  readInt()   writeLong(long)   readLong() 
  writeString(String)   readString() .  Most other
 data operations are built on top of these.  The given data is written and
 read using the endianess of the host CPU. Primitive Arrays There are a variety of methods for reading and writing raw arrays
 of primitive objects which generally result in writing a 4-byte length
 followed by the primitive data items.  The methods for reading can either
 read the data into an existing array or create and return a new array.
 These available types are: writeBooleanArray(boolean[]) 
  readBooleanArray(boolean[])   createBooleanArray() writeByteArray(byte[]) 
  writeByteArray(byte[] int int)   readByteArray(byte[]) 
  createByteArray() writeCharArray(char[])   readCharArray(char[]) 
  createCharArray() writeDoubleArray(double[])   readDoubleArray(double[]) 
  createDoubleArray() writeFloatArray(float[])   readFloatArray(float[]) 
  createFloatArray() writeIntArray(int[])   readIntArray(int[]) 
  createIntArray() writeLongArray(long[])   readLongArray(long[]) 
  createLongArray() writeStringArray(java.lang.String[])   readStringArray(java.lang.String[]) 
  createStringArray() .
  writeSparseBooleanArray(android.util.SparseBooleanArray) 
  readSparseBooleanArray() .
  Parcelables The  Parcelable  protocol provides an extremely efficient (but
 low-level) protocol for objects to write and read themselves from Parcels.
 You can use the direct methods  writeParcelable(android.os.Parcelable int) 
 and  readParcelable(java.lang.ClassLoader)  or
  writeParcelableArray(T[] int)  and
  readParcelableArray(java.lang.ClassLoader)  to write or read.  These
 methods write both the class type and its data to the Parcel allowing
 that class to be reconstructed from the appropriate class loader when
 later reading. There are also some methods that provide a more efficient way to work
 with Parcelables:  writeTypedObject(T int)   writeTypedArray(T[] int) 
  writeTypedList(List )   readTypedObject(Parcelable.Creator ) 
  createTypedArray(Parcelable.Creator )  and  createTypedArrayList(Parcelable.Creator ) .  These methods
 do not write the class information of the original object: instead the
 caller of the read function must know what type to expect and pass in the
 appropriate  Parcelable.Creator  instead to
 properly construct the new object and read its data.  (To more efficient
 write and read a single Parcelable object that is not null you can directly
 call  Parcelable#writeToParcel  and
  Parcelable.Creator#createFromParcel 
 yourself.) Bundles A special type-safe container called  Bundle  is available
 for key/value maps of heterogeneous values.  This has many optimizations
 for improved performance when reading and writing data and its type-safe
 API avoids difficult to debug type errors when finally marshalling the
 data contents into a Parcel.  The methods to use are
  writeBundle(android.os.Bundle)   readBundle()  and
  readBundle(java.lang.ClassLoader) .

  Active Objects An unusual feature of Parcel is the ability to read and write active
 objects.  For these objects the actual contents of the object is not
 written rather a special token referencing the object is written.  When
 reading the object back from the Parcel you do not get a new instance of
 the object but rather a handle that operates on the exact same object that
 was originally written.  There are two forms of active objects available. Binder  objects are a core facility of Android's general cross-process
 communication system.  The  IBinder  interface describes an abstract
 protocol with a Binder object.  Any such interface can be written in to
 a Parcel and upon reading you will receive either the original object
 implementing that interface or a special proxy implementation
 that communicates calls back to the original object.  The methods to use are
  writeStrongBinder(android.os.IBinder) 
  writeStrongInterface(android.os.IInterface)   readStrongBinder() 
  writeBinderArray(android.os.IBinder[])   readBinderArray(android.os.IBinder[]) 
  createBinderArray() 
  writeBinderList(java.util.List)   readBinderList(java.util.List) 
  createBinderArrayList() . FileDescriptor objects representing raw Linux file descriptor identifiers
 can be written and  ParcelFileDescriptor  objects returned to operate
 on the original file descriptor.  The returned file descriptor is a dup
 of the original file descriptor: the object and fd is different but
 operating on the same underlying file stream with the same position etc.
 The methods to use are  writeFileDescriptor(java.io.FileDescriptor) 
  readFileDescriptor() .

  Untyped Containers A final class of methods are for writing and reading standard Java
 containers of arbitrary types.  These all revolve around the
  writeValue(java.lang.Object)  and  readValue(java.lang.ClassLoader)  methods
 which define the types of objects allowed.  The container methods are
  writeArray(java.lang.Object[])   readArray(java.lang.ClassLoader) 
  writeList(java.util.List)   readList(java.util.List java.lang.ClassLoader) 
  readArrayList(java.lang.ClassLoader) 
  writeMap(java.util.Map)   readMap(java.util.Map java.lang.ClassLoader) 
  writeSparseArray(android.util.SparseArray) 
  readSparseArray(java.lang.ClassLoader) .",,IPC,no,0,no,no,no,no,
<android.content.ClipboardManager: void setText(CharSequence)>,"This method is deprecated. Use setPrimaryClip(android.content.ClipData) instead.  This
 creates a ClippedItem holding the given text and sets it as the
 primary clip.  It has no label or icon. Sets the contents of the clipboard to the specified text.",text CharSequence |||,void,11,"Interface to the clipboard service for placing and retrieving text in
 the global clipboard.

  
 The ClipboardManager API itself is very simple: it consists of methods
 to atomically get and set the current primary clipboard data.  That data
 is expressed as a  ClipData  object which defines the protocol
 for data exchange between applications.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",uncategorized,clipboard,1,no,yes,no,SINK,
<android.bluetooth.BluetoothSocket: void connect()>,"Attempt to connect to a remote device. This method will block until a connection is made or the connection
 fails. If this method returns without an exception then this socket
 is now connected. Creating new connections to
 remote Bluetooth devices should not be attempted while device discovery
 is in progress. Device discovery is a heavyweight procedure on the
 Bluetooth adapter and will significantly slow a device connection.
 Use BluetoothAdapter#cancelDiscovery() to cancel an ongoing
 discovery. Discovery is not managed by the Activity
 but is run as a system service so an application should always call BluetoothAdapter#cancelDiscovery() even if it
 did not directly request a discovery just to be sure. close() can be used to abort this call from another thread.",,void,5,"A connected or connecting Bluetooth socket.

  The interface for Bluetooth Sockets is similar to that of TCP sockets:
  Socket  and  ServerSocket . On the server
 side use a  BluetoothServerSocket  to create a listening server
 socket. When a connection is accepted by the  BluetoothServerSocket 
 it will return a new  BluetoothSocket  to manage the connection.
 On the client side use a single  BluetoothSocket  to both initiate
 an outgoing connection and to manage the connection.

  The most common type of Bluetooth socket is RFCOMM which is the type
 supported by the Android APIs. RFCOMM is a connection-oriented streaming
 transport over Bluetooth. It is also known as the Serial Port Profile (SPP).

  To create a  BluetoothSocket  for connecting to a known device use
  BluetoothDevice#createRfcommSocketToServiceRecord .
 Then call  connect()  to attempt a connection to the remote device.
 This call will block until a connection is established or the connection
 fails.

  To create a  BluetoothSocket  as a server (or ""host"") see the
  BluetoothServerSocket  documentation.

  Once the socket is connected whether initiated as a client or accepted
 as a server open the IO streams by calling  getInputStream()  and
  getOutputStream()  in order to retrieve  InputStream 
 and  OutputStream  objects respectively which are
 automatically connected to the socket.

  BluetoothSocket  is thread
 safe. In particular  close()  will always immediately abort ongoing
 operations and close the socket.

  Note: 
 Requires the  Manifest.permission.BLUETOOTH  permission.","Provides classes that manage Bluetooth functionality such as scanning for
 devices connecting with devices and managing data transfer between devices.
 The Bluetooth API supports both ""Classic Bluetooth"" and Bluetooth Low Energy. For more information about Classic Bluetooth see the
  Bluetooth  guide.
 For more information about Bluetooth Low Energy see the
  
 Bluetooth Low Energy  (BLE) guide. The Bluetooth APIs let applications: Scan for other Bluetooth devices (including BLE devices). Query the local Bluetooth adapter for paired Bluetooth devices. Establish RFCOMM channels/sockets. Connect to specified sockets on other devices. Transfer data to and from other devices. Communicate with BLE devices such as proximity sensors heart rate
     monitors fitness devices and so on. Act as a GATT client or a GATT server (BLE). 
 To perform Bluetooth communication using these APIs an application must
 declare the  BLUETOOTH  permission. Some
 additional functionality such as requesting device discovery
 also requires the  BLUETOOTH_ADMIN 
 permission.
  Note: 
 Not all Android-powered devices provide Bluetooth functionality.",no,no,0,no,no,no,no,
<android.widget.PopupMenu: void show()>,Show the menu popup anchored to the view specified during construction.,,void,11,"A PopupMenu displays a  Menu  in a modal popup window anchored to a
  View . The popup will appear below the anchor view if there is room
 or above it if there is not. If the IME is visible the popup will not
 overlap it until it is touched. Touching outside of the popup will dismiss
 it.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,no,0,no,no,no,no,
"<android.os.Bundle: void putCharArray(String,char)>","Inserts a char array value into the mapping of this Bundle replacing
 any existing value for the given key.  Either key or value may be null.","key String : a String or null
This value may be null . |||
value char : a char array object or null
This value may be null . |||",void,1,A mapping from String keys to various  Parcelable  values.,,IPC,no,0,no,no,no,no,
<android.widget.Spinner: void setPopupBackgroundResource(int)>,"Set the background drawable for the spinner's popup window of choices.
 Only valid in MODE_DROPDOWN ; this method is a no-op in other modes. Related XML Attributes: android:popupBackground",resId int : Resource ID of a background drawable |||,void,16,"A view that displays one child at a time and lets the user pick among them.
 The items in the Spinner come from the  Adapter  associated with
 this view.

  See the  Spinners  guide.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,UI,0,no,no,no,no,
<android.widget.TextView: void setTextScaleX(float)>,"Sets the horizontal scale factor for text. The default value
 is 1.0. Values greater than 1.0 stretch the text wider.
 Values less than 1.0 make the text narrower. By default this value is 1.0. Related XML Attributes: android:textScaleX",size float : The horizontal scale factor. |||,void,1,"A user interface element that displays text to the user.
 To provide user-editable text see  EditText .
  
 The following code sample shows a typical use with an XML layout
 and code to modify the contents of the text view:
  
 <LinearLayout
      xmlns:android=""http://schemas.android.com/apk/res/android""
      android:layout_width=""match_parent""
      android:layout_height=""match_parent"">
    <TextView
        android:id=""@+id/text_view_id""
        android:layout_height=""wrap_content""
        android:layout_width=""wrap_content""
        android:text=""@string/hello"" />
 </LinearLayout>
  
 This code sample demonstrates how to modify the contents of the text view
 defined in the previous XML layout:
  
 public class MainActivity extends Activity {

    protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_main);
         final TextView helloTextView = (TextView) findViewById(R.id.text_view_id);
         helloTextView.setText(R.string.user_greeting);
     }
 }
  
 To customize the appearance of TextView see  Styles and Themes .
  XML attributes 
 See  TextView Attributes 
  View Attributes","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,UI,0,no,no,no,no,
<android.media.AudioManager: void unloadSoundEffects()>,"Unload Sound effects.
  This method can be called to free some memory when
  sound effects are disabled.",,void,1,AudioManager provides access to volume and ringer mode control.,"The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",no,no,0,no,no,no,no,
<android.net.SSLCertificateSocketFactory: String getDefaultCipherSuites()>,"Returns the list of cipher suites which are enabled by default.
 Unless a different list is enabled handshaking on an SSL connection
 will use one of these cipher suites.  The minimum quality of service
 for these defaults requires confidentiality protection and server
 authentication (that is no anonymous cipher suites).",,String[] array of the cipher suites enabled by default |||,1,"SSLSocketFactory implementation with several extra features:

  Timeout specification for SSL handshake operations
  Hostname verification in most cases (see WARNINGs below)
  Optional SSL session caching with  SSLSessionCache Optionally bypass all SSL certificate checks
  createSocket() Socket#connect(java.net.SocketAddress int) The recommended way to verify the server's identity is to use
  HttpsURLConnection#getDefaultHostnameVerifier()  to get a
  HostnameVerifier  to verify the certificate hostname.

  Warning : Some methods on this class return connected sockets and some return
 unconnected sockets.  For the methods that return connected sockets setting
 connection- or handshake-related properties on those sockets will have no effect.

  On development devices ""setprop socket.relaxsslcheck yes"" bypasses all
 SSL certificate and hostname checks for testing purposes.  This setting
 requires root access.",,network info,network ,1,yes,no,SOURCE,no,
<android.view.Display: float getRefreshRate()>,Gets the refresh rate of this display in frames per second.,,float |||,1,"Provides information about the size and density of a logical display.
  
 The display area is described in two different ways.
  The application display area specifies the part of the display that may contain
 an application window excluding the system decorations.  The application display area may
 be smaller than the real display area because the system subtracts the space needed
 for decor elements such as the status bar.  Use the following methods to query the
 application display area:  getSize(Point)   getRectSize(Rect)  and  getMetrics(DisplayMetrics) . The real display area specifies the part of the display that contains content
 including the system decorations.  Even so the real display area may be smaller than the
 physical size of the display if the window manager is emulating a smaller display
 using (adb shell wm size).  Use the following methods to query the
 real display area:  getRealSize(Point)   getRealMetrics(DisplayMetrics) . 
 A logical display does not necessarily represent a particular physical display device
 such as the built-in screen or an external monitor.  The contents of a logical
 display may be presented on one or more physical displays according to the devices
 that are currently attached and whether mirroring has been enabled.",,UI metadata,UI,1,yes,no,SOURCE,no,
<android.test.AndroidTestRunner: void runTest(TestResult)>,,testResult TestResult |||,void,1,,,no,no,0,no,no,no,no,
<android.location.LocationManager: void clearTestProviderStatus(String)>,"This method was deprecated
      in API level 29. This method has no effect. This method has no effect as provider status has been deprecated and is no longer supported.",provider String : This value must never be null . |||,void,3,"A data class representing a geographic location.

  A location can consist of a latitude longitude timestamp
 and other information such as bearing altitude and velocity.

  All locations generated by the  LocationManager  are
 guaranteed to have a valid latitude longitude and timestamp
 (both UTC time and elapsed real-time since boot) all other
 parameters are optional.","Contains the framework API classes that define Android location-based and
 	related services. This API is not the recommended method for accessing Android location. 
 The
  Google Location Services API 
 part of Google Play services is the preferred way to add location-awareness to
 your app. It offers a simpler API higher accuracy low-power geofencing and
 more. If you are currently using the android.location API you are strongly
 encouraged to switch to the Google Location Services API as soon as
 possible.
  
 To learn more about the Google Location Services API see the
  Location API overview .",no,no,0,no,no,no,no,
"<android.content.res.AssetFileDescriptor: void writeToParcel(Parcel,int)>",Flatten this object in to a Parcel.,"out Parcel : The Parcel in which the object should be written. |||
flags int : Additional flags about how the object should be written.
May be 0 or Parcelable.PARCELABLE_WRITE_RETURN_VALUE .
Value is either 0 or a combination of Parcelable.PARCELABLE_WRITE_RETURN_VALUE and android.os.Parcelable.PARCELABLE_ELIDE_DUPLICATES |||",void,3,"File descriptor of an entry in the AssetManager.  This provides your own
 opened FileDescriptor that can be used to read the data as well as the
 offset and length of that entry's data in the file.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",IPC,no,0,no,no,no,no,
<android.widget.CursorTreeAdapter: void notifyDataSetInvalidated()>,,,void,1,"An adapter that exposes data from a series of  Cursor s to an
  ExpandableListView  widget. The top-level  Cursor  (that is
 given in the constructor) exposes the groups while subsequent  Cursor s
 returned from  getChildrenCursor(android.database.Cursor)  expose children within a
 particular group. The Cursors must include a column named ""_id"" or this class
 will not work.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,no,0,no,no,no,no,
<android.location.LocationManager: void removeUpdates(PendingIntent)>,"Removes location updates for the specified PendingIntent . Following this call the
 PendingIntent will no longer receive location updates.","pendingIntent PendingIntent : pending intent that no longer needs location updates
This value must never be null . |||",void,3,"A data class representing a geographic location.

  A location can consist of a latitude longitude timestamp
 and other information such as bearing altitude and velocity.

  All locations generated by the  LocationManager  are
 guaranteed to have a valid latitude longitude and timestamp
 (both UTC time and elapsed real-time since boot) all other
 parameters are optional.","Contains the framework API classes that define Android location-based and
 	related services. This API is not the recommended method for accessing Android location. 
 The
  Google Location Services API 
 part of Google Play services is the preferred way to add location-awareness to
 your app. It offers a simpler API higher accuracy low-power geofencing and
 more. If you are currently using the android.location API you are strongly
 encouraged to switch to the Google Location Services API as soon as
 possible.
  
 To learn more about the Google Location Services API see the
  Location API overview .",IPC,location,1,no,no,no,no,
"<android.os.Parcel: void writeParcelable(Parcelable,int)>","Flatten the name of the class of the Parcelable and its contents
 into the parcel.","p Parcelable : The Parcelable object to be written.
This value may be null . |||
parcelableFlags int : Contextual flags as per Parcelable#writeToParcel(Parcel int) . |||",void,1,"Container for a message (data and object references) that can
 be sent through an IBinder.  A Parcel can contain both flattened data
 that will be unflattened on the other side of the IPC (using the various
 methods here for writing specific types or the general
  Parcelable  interface) and references to live  IBinder 
 objects that will result in the other side receiving a proxy IBinder
 connected with the original IBinder in the Parcel.

  Parcel is  not  a general-purpose
 serialization mechanism.  This class (and the corresponding
  Parcelable  API for placing arbitrary objects into a Parcel) is
 designed as a high-performance IPC transport.  As such it is not
 appropriate to place any Parcel data in to persistent storage: changes
 in the underlying implementation of any of the data in the Parcel can
 render older data unreadable. The bulk of the Parcel API revolves around reading and writing data
 of various types.  There are six major classes of such functions available. Primitives The most basic data functions are for writing and reading primitive
 data types:  writeByte(byte)   readByte()   writeDouble(double) 
  readDouble()   writeFloat(float)   readFloat()   writeInt(int) 
  readInt()   writeLong(long)   readLong() 
  writeString(String)   readString() .  Most other
 data operations are built on top of these.  The given data is written and
 read using the endianess of the host CPU. Primitive Arrays There are a variety of methods for reading and writing raw arrays
 of primitive objects which generally result in writing a 4-byte length
 followed by the primitive data items.  The methods for reading can either
 read the data into an existing array or create and return a new array.
 These available types are: writeBooleanArray(boolean[]) 
  readBooleanArray(boolean[])   createBooleanArray() writeByteArray(byte[]) 
  writeByteArray(byte[] int int)   readByteArray(byte[]) 
  createByteArray() writeCharArray(char[])   readCharArray(char[]) 
  createCharArray() writeDoubleArray(double[])   readDoubleArray(double[]) 
  createDoubleArray() writeFloatArray(float[])   readFloatArray(float[]) 
  createFloatArray() writeIntArray(int[])   readIntArray(int[]) 
  createIntArray() writeLongArray(long[])   readLongArray(long[]) 
  createLongArray() writeStringArray(java.lang.String[])   readStringArray(java.lang.String[]) 
  createStringArray() .
  writeSparseBooleanArray(android.util.SparseBooleanArray) 
  readSparseBooleanArray() .
  Parcelables The  Parcelable  protocol provides an extremely efficient (but
 low-level) protocol for objects to write and read themselves from Parcels.
 You can use the direct methods  writeParcelable(android.os.Parcelable int) 
 and  readParcelable(java.lang.ClassLoader)  or
  writeParcelableArray(T[] int)  and
  readParcelableArray(java.lang.ClassLoader)  to write or read.  These
 methods write both the class type and its data to the Parcel allowing
 that class to be reconstructed from the appropriate class loader when
 later reading. There are also some methods that provide a more efficient way to work
 with Parcelables:  writeTypedObject(T int)   writeTypedArray(T[] int) 
  writeTypedList(List )   readTypedObject(Parcelable.Creator ) 
  createTypedArray(Parcelable.Creator )  and  createTypedArrayList(Parcelable.Creator ) .  These methods
 do not write the class information of the original object: instead the
 caller of the read function must know what type to expect and pass in the
 appropriate  Parcelable.Creator  instead to
 properly construct the new object and read its data.  (To more efficient
 write and read a single Parcelable object that is not null you can directly
 call  Parcelable#writeToParcel  and
  Parcelable.Creator#createFromParcel 
 yourself.) Bundles A special type-safe container called  Bundle  is available
 for key/value maps of heterogeneous values.  This has many optimizations
 for improved performance when reading and writing data and its type-safe
 API avoids difficult to debug type errors when finally marshalling the
 data contents into a Parcel.  The methods to use are
  writeBundle(android.os.Bundle)   readBundle()  and
  readBundle(java.lang.ClassLoader) .

  Active Objects An unusual feature of Parcel is the ability to read and write active
 objects.  For these objects the actual contents of the object is not
 written rather a special token referencing the object is written.  When
 reading the object back from the Parcel you do not get a new instance of
 the object but rather a handle that operates on the exact same object that
 was originally written.  There are two forms of active objects available. Binder  objects are a core facility of Android's general cross-process
 communication system.  The  IBinder  interface describes an abstract
 protocol with a Binder object.  Any such interface can be written in to
 a Parcel and upon reading you will receive either the original object
 implementing that interface or a special proxy implementation
 that communicates calls back to the original object.  The methods to use are
  writeStrongBinder(android.os.IBinder) 
  writeStrongInterface(android.os.IInterface)   readStrongBinder() 
  writeBinderArray(android.os.IBinder[])   readBinderArray(android.os.IBinder[]) 
  createBinderArray() 
  writeBinderList(java.util.List)   readBinderList(java.util.List) 
  createBinderArrayList() . FileDescriptor objects representing raw Linux file descriptor identifiers
 can be written and  ParcelFileDescriptor  objects returned to operate
 on the original file descriptor.  The returned file descriptor is a dup
 of the original file descriptor: the object and fd is different but
 operating on the same underlying file stream with the same position etc.
 The methods to use are  writeFileDescriptor(java.io.FileDescriptor) 
  readFileDescriptor() .

  Untyped Containers A final class of methods are for writing and reading standard Java
 containers of arbitrary types.  These all revolve around the
  writeValue(java.lang.Object)  and  readValue(java.lang.ClassLoader)  methods
 which define the types of objects allowed.  The container methods are
  writeArray(java.lang.Object[])   readArray(java.lang.ClassLoader) 
  writeList(java.util.List)   readList(java.util.List java.lang.ClassLoader) 
  readArrayList(java.lang.ClassLoader) 
  writeMap(java.util.Map)   readMap(java.util.Map java.lang.ClassLoader) 
  writeSparseArray(android.util.SparseArray) 
  readSparseArray(java.lang.ClassLoader) .",,IPC,no,0,no,no,no,no,
"<android.widget.TextView: void setLineSpacing(float,float)>","Sets line spacing for this TextView.  Each line other than the last line will have its height
 multiplied by mult and have add added to it. Related XML Attributes: android:lineSpacingExtra 
android:lineSpacingMultiplier","add float : The value in pixels that should be added to each line other than the last line.
This will be applied after the multiplier |||
mult float : The value by which each line height other than the last line will be multiplied
by |||",void,1,"A user interface element that displays text to the user.
 To provide user-editable text see  EditText .
  
 The following code sample shows a typical use with an XML layout
 and code to modify the contents of the text view:
  
 <LinearLayout
      xmlns:android=""http://schemas.android.com/apk/res/android""
      android:layout_width=""match_parent""
      android:layout_height=""match_parent"">
    <TextView
        android:id=""@+id/text_view_id""
        android:layout_height=""wrap_content""
        android:layout_width=""wrap_content""
        android:text=""@string/hello"" />
 </LinearLayout>
  
 This code sample demonstrates how to modify the contents of the text view
 defined in the previous XML layout:
  
 public class MainActivity extends Activity {

    protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_main);
         final TextView helloTextView = (TextView) findViewById(R.id.text_view_id);
         helloTextView.setText(R.string.user_greeting);
     }
 }
  
 To customize the appearance of TextView see  Styles and Themes .
  XML attributes 
 See  TextView Attributes 
  View Attributes","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,UI,0,no,no,no,no,
<android.os.Parcel: ArrayList readArrayList(ClassLoader)>,"Read and return a new ArrayList object from the parcel at the current
 dataPosition().  Returns null if the previously written list object was
 null.  The given class loader will be used to load any enclosed
 Parcelables.",loader ClassLoader : This value may be null . |||,ArrayList |||,1,"Container for a message (data and object references) that can
 be sent through an IBinder.  A Parcel can contain both flattened data
 that will be unflattened on the other side of the IPC (using the various
 methods here for writing specific types or the general
  Parcelable  interface) and references to live  IBinder 
 objects that will result in the other side receiving a proxy IBinder
 connected with the original IBinder in the Parcel.

  Parcel is  not  a general-purpose
 serialization mechanism.  This class (and the corresponding
  Parcelable  API for placing arbitrary objects into a Parcel) is
 designed as a high-performance IPC transport.  As such it is not
 appropriate to place any Parcel data in to persistent storage: changes
 in the underlying implementation of any of the data in the Parcel can
 render older data unreadable. The bulk of the Parcel API revolves around reading and writing data
 of various types.  There are six major classes of such functions available. Primitives The most basic data functions are for writing and reading primitive
 data types:  writeByte(byte)   readByte()   writeDouble(double) 
  readDouble()   writeFloat(float)   readFloat()   writeInt(int) 
  readInt()   writeLong(long)   readLong() 
  writeString(String)   readString() .  Most other
 data operations are built on top of these.  The given data is written and
 read using the endianess of the host CPU. Primitive Arrays There are a variety of methods for reading and writing raw arrays
 of primitive objects which generally result in writing a 4-byte length
 followed by the primitive data items.  The methods for reading can either
 read the data into an existing array or create and return a new array.
 These available types are: writeBooleanArray(boolean[]) 
  readBooleanArray(boolean[])   createBooleanArray() writeByteArray(byte[]) 
  writeByteArray(byte[] int int)   readByteArray(byte[]) 
  createByteArray() writeCharArray(char[])   readCharArray(char[]) 
  createCharArray() writeDoubleArray(double[])   readDoubleArray(double[]) 
  createDoubleArray() writeFloatArray(float[])   readFloatArray(float[]) 
  createFloatArray() writeIntArray(int[])   readIntArray(int[]) 
  createIntArray() writeLongArray(long[])   readLongArray(long[]) 
  createLongArray() writeStringArray(java.lang.String[])   readStringArray(java.lang.String[]) 
  createStringArray() .
  writeSparseBooleanArray(android.util.SparseBooleanArray) 
  readSparseBooleanArray() .
  Parcelables The  Parcelable  protocol provides an extremely efficient (but
 low-level) protocol for objects to write and read themselves from Parcels.
 You can use the direct methods  writeParcelable(android.os.Parcelable int) 
 and  readParcelable(java.lang.ClassLoader)  or
  writeParcelableArray(T[] int)  and
  readParcelableArray(java.lang.ClassLoader)  to write or read.  These
 methods write both the class type and its data to the Parcel allowing
 that class to be reconstructed from the appropriate class loader when
 later reading. There are also some methods that provide a more efficient way to work
 with Parcelables:  writeTypedObject(T int)   writeTypedArray(T[] int) 
  writeTypedList(List )   readTypedObject(Parcelable.Creator ) 
  createTypedArray(Parcelable.Creator )  and  createTypedArrayList(Parcelable.Creator ) .  These methods
 do not write the class information of the original object: instead the
 caller of the read function must know what type to expect and pass in the
 appropriate  Parcelable.Creator  instead to
 properly construct the new object and read its data.  (To more efficient
 write and read a single Parcelable object that is not null you can directly
 call  Parcelable#writeToParcel  and
  Parcelable.Creator#createFromParcel 
 yourself.) Bundles A special type-safe container called  Bundle  is available
 for key/value maps of heterogeneous values.  This has many optimizations
 for improved performance when reading and writing data and its type-safe
 API avoids difficult to debug type errors when finally marshalling the
 data contents into a Parcel.  The methods to use are
  writeBundle(android.os.Bundle)   readBundle()  and
  readBundle(java.lang.ClassLoader) .

  Active Objects An unusual feature of Parcel is the ability to read and write active
 objects.  For these objects the actual contents of the object is not
 written rather a special token referencing the object is written.  When
 reading the object back from the Parcel you do not get a new instance of
 the object but rather a handle that operates on the exact same object that
 was originally written.  There are two forms of active objects available. Binder  objects are a core facility of Android's general cross-process
 communication system.  The  IBinder  interface describes an abstract
 protocol with a Binder object.  Any such interface can be written in to
 a Parcel and upon reading you will receive either the original object
 implementing that interface or a special proxy implementation
 that communicates calls back to the original object.  The methods to use are
  writeStrongBinder(android.os.IBinder) 
  writeStrongInterface(android.os.IInterface)   readStrongBinder() 
  writeBinderArray(android.os.IBinder[])   readBinderArray(android.os.IBinder[]) 
  createBinderArray() 
  writeBinderList(java.util.List)   readBinderList(java.util.List) 
  createBinderArrayList() . FileDescriptor objects representing raw Linux file descriptor identifiers
 can be written and  ParcelFileDescriptor  objects returned to operate
 on the original file descriptor.  The returned file descriptor is a dup
 of the original file descriptor: the object and fd is different but
 operating on the same underlying file stream with the same position etc.
 The methods to use are  writeFileDescriptor(java.io.FileDescriptor) 
  readFileDescriptor() .

  Untyped Containers A final class of methods are for writing and reading standard Java
 containers of arbitrary types.  These all revolve around the
  writeValue(java.lang.Object)  and  readValue(java.lang.ClassLoader)  methods
 which define the types of objects allowed.  The container methods are
  writeArray(java.lang.Object[])   readArray(java.lang.ClassLoader) 
  writeList(java.util.List)   readList(java.util.List java.lang.ClassLoader) 
  readArrayList(java.lang.ClassLoader) 
  writeMap(java.util.Map)   readMap(java.util.Map java.lang.ClassLoader) 
  writeSparseArray(android.util.SparseArray) 
  readSparseArray(java.lang.ClassLoader) .",,no,no,0,no,no,no,no,
<android.preference.PreferenceGroup: void addItemFromInflater(Preference)>,Called by the inflater to add an item to this group.,preference Preference |||,void,1,"A container for multiple
  Preference  objects. It is a base class for  Preference objects that are
 parents such as  PreferenceCategory  and  PreferenceScreen .",,no,no,0,no,no,no,no,
<android.view.KeyEvent: KeyCharacterMap getKeyCharacterMap()>,Gets the KeyCharacterMap associated with the keyboard device.,,KeyCharacterMap The associated key character map. |||,11,"Object used to report key and button events.
  
 Each key press is described by a sequence of key events.  A key press
 starts with a key event with  ACTION_DOWN .  If the key is held
 sufficiently long that it repeats then the initial down is followed
 additional key events with  ACTION_DOWN  and a non-zero value for
  getRepeatCount() .  The last key event is a  ACTION_UP 
 for the key up.  If the key press is canceled the key up event will have the
  FLAG_CANCELED  flag set.
  
 Key events are generally accompanied by a key code ( getKeyCode() )
 scan code ( getScanCode() ) and meta state ( getMetaState() ).
 Key code constants are defined in this class.  Scan code constants are raw
 device-specific codes obtained from the OS and so are not generally meaningful
 to applications unless interpreted using the  KeyCharacterMap .
 Meta states describe the pressed state of key modifiers
 such as  META_SHIFT_ON  or  META_ALT_ON .
  
 Key codes typically correspond one-to-one with individual keys on an input device.
 Many keys and key combinations serve quite different functions on different
 input devices so care must be taken when interpreting them.  Always use the
  KeyCharacterMap  associated with the input device when mapping keys
 to characters.  Be aware that there may be multiple key input devices active
 at the same time and each will have its own key character map.
  
 As soft input methods can use multiple and inventive ways of inputting text
 there is no guarantee that any key press on a soft keyboard will generate a key
 event: this is left to the IME's discretion and in fact sending such events is
 discouraged.  You should never rely on receiving KeyEvents for any key on a soft
 input method.  In particular the default software keyboard will never send any
 key event to any application targetting Jelly Bean or later and will only send
 events for some presses of the delete and return keys to applications targetting
 Ice Cream Sandwich or earlier.  Be aware that other software input methods may
 never send key events regardless of the version.  Consider using editor actions
 like  EditorInfo.IME_ACTION_DONE  if you need
 specific interaction with the software keyboard as it gives more visibility to
 the user as to how your application will react to key presses.
  
 When interacting with an IME the framework may deliver key events
 with the special action  ACTION_MULTIPLE  that either specifies
 that single repeated key code or a sequence of characters to insert.
  
 In general the framework cannot guarantee that the key events it delivers
 to a view always constitute complete key sequences since some events may be dropped
 or modified by containing views before they are delivered.  The view implementation
 should be prepared to handle  FLAG_CANCELED  and should tolerate anomalous
 situations such as receiving a new  ACTION_DOWN  without first having
 received an  ACTION_UP  for the prior key press.
  
 Refer to  InputDevice  for more information about how different kinds of
 input devices and sources represent keys and buttons.",,no,keyboard,0,no,no,no,no,
<android.view.textservice.SpellCheckerInfo: Drawable loadIcon(PackageManager)>,Load the user-displayed icon for this spell checker.,pm PackageManager : Supply a PackageManager used to load the spell checker's resources. |||,Drawable |||,14,This class is used to specify meta information of a spell checker.,,no,no,0,no,no,no,no,
<android.net.wifi.WifiManager: int updateNetwork(WifiConfiguration)>,"This method was deprecated
      in API level 29. a) See WifiNetworkSpecifier.Builder#build() for new
 mechanism to trigger connection to a Wi-Fi network.
 b) See addNetworkSuggestions(java.util.List)  removeNetworkSuggestions(java.util.List) for new API to add Wi-Fi networks for consideration
 when auto-connecting to wifi. Compatibility Note: For applications targeting Build.VERSION_CODES.Q or above this API will always fail and return -1 . Deprecation Exemptions: Device Owner (DO) Profile Owner (PO) and system apps. 
Update the network description of an existing configured network.","config WifiConfiguration : the set of variables that describe the configuration
contained in a WifiConfiguration object. It may
be sparse so that only the items that are being changed
are non- null . The networkId field
must be set to the ID of the existing network being updated.
If the WifiConfiguration has an Http Proxy set
the calling app must be System or be provisioned as the Profile or Device Owner. |||","int Returns the networkId of the supplied WifiConfiguration on success. Returns -1 on failure including when the networkId field of the WifiConfiguration does not refer to an
         existing network. |||",1,"This class provides the primary API for managing all aspects of Wi-Fi
 connectivity.
  
 On releases before  Build.VERSION_CODES.N  this object
 should only be obtained from an  Context#getApplicationContext()  and not from any other derived context to avoid memory
 leaks within the calling process.
  
 It deals with several categories of items:
  The list of configured networks. The list can be viewed and updated and
 attributes of individual entries can be modified. The currently active Wi-Fi network if any. Connectivity can be
 established or torn down and dynamic information about the state of the
 network can be queried. Results of access point scans containing enough information to make
 decisions about what access point to connect to. It defines the names of various Intent actions that are broadcast upon
 any sort of change in Wi-Fi state.
  
 This is the API to use when performing Wi-Fi specific operations. To perform
 operations that pertain to network connectivity at an abstract level use
  ConnectivityManager .","Provides classes to manage Wi-Fi functionality on the device. The Wi-Fi APIs provide a means by which applications can communicate
 with the lower-level wireless stack that provides Wi-Fi network access. Almost all
 information from the device supplicant is available including the connected network's
 link speed IP address negotiation state and more plus information about other
 networks that are available. Some other API features include the ability to
 scan add save terminate and initiate Wi-Fi connections. Some APIs may require the following user permissions: ACCESS_WIFI_STATE CHANGE_WIFI_STATE CHANGE_WIFI_MULTICAST_STATE Note:  Not all Android-powered devices provide Wi-Fi functionality.
 If your application uses Wi-Fi declare so with a  <uses-feature> 
 element in the manifest file: 
 <manifest ...>
     <uses-feature android:name=""android.hardware.wifi"" />
     ...
 </manifest>",network info,network ,1,yes,no,SOURCE,no,
<android.view.KeyEvent: char getNumber()>,"Gets the number or symbol associated with the key. The character value is returned not the numeric value.
 If the key is not a number but is a symbol the symbol is retuned. This method is intended to to support dial pads and other numeric or
 symbolic entry on keyboards where certain keys serve dual function
 as alphabetic and symbolic keys.  This method returns the number
 or symbol associated with the key independent of whether the user
 has pressed the required modifier. For example on one particular keyboard the keys on the top QWERTY row generate
 numbers when ALT is pressed such that ALT-Q maps to '1'.  So for that keyboard
 when getNumber() is called with KeyEvent#KEYCODE_Q it returns '1'
 so that the user can type numbers without pressing ALT when it makes sense.",,char The associated numeric or symbolic character or 0 if none. |||,1,"Object used to report key and button events.
  
 Each key press is described by a sequence of key events.  A key press
 starts with a key event with  ACTION_DOWN .  If the key is held
 sufficiently long that it repeats then the initial down is followed
 additional key events with  ACTION_DOWN  and a non-zero value for
  getRepeatCount() .  The last key event is a  ACTION_UP 
 for the key up.  If the key press is canceled the key up event will have the
  FLAG_CANCELED  flag set.
  
 Key events are generally accompanied by a key code ( getKeyCode() )
 scan code ( getScanCode() ) and meta state ( getMetaState() ).
 Key code constants are defined in this class.  Scan code constants are raw
 device-specific codes obtained from the OS and so are not generally meaningful
 to applications unless interpreted using the  KeyCharacterMap .
 Meta states describe the pressed state of key modifiers
 such as  META_SHIFT_ON  or  META_ALT_ON .
  
 Key codes typically correspond one-to-one with individual keys on an input device.
 Many keys and key combinations serve quite different functions on different
 input devices so care must be taken when interpreting them.  Always use the
  KeyCharacterMap  associated with the input device when mapping keys
 to characters.  Be aware that there may be multiple key input devices active
 at the same time and each will have its own key character map.
  
 As soft input methods can use multiple and inventive ways of inputting text
 there is no guarantee that any key press on a soft keyboard will generate a key
 event: this is left to the IME's discretion and in fact sending such events is
 discouraged.  You should never rely on receiving KeyEvents for any key on a soft
 input method.  In particular the default software keyboard will never send any
 key event to any application targetting Jelly Bean or later and will only send
 events for some presses of the delete and return keys to applications targetting
 Ice Cream Sandwich or earlier.  Be aware that other software input methods may
 never send key events regardless of the version.  Consider using editor actions
 like  EditorInfo.IME_ACTION_DONE  if you need
 specific interaction with the software keyboard as it gives more visibility to
 the user as to how your application will react to key presses.
  
 When interacting with an IME the framework may deliver key events
 with the special action  ACTION_MULTIPLE  that either specifies
 that single repeated key code or a sequence of characters to insert.
  
 In general the framework cannot guarantee that the key events it delivers
 to a view always constitute complete key sequences since some events may be dropped
 or modified by containing views before they are delivered.  The view implementation
 should be prepared to handle  FLAG_CANCELED  and should tolerate anomalous
 situations such as receiving a new  ACTION_DOWN  without first having
 received an  ACTION_UP  for the prior key press.
  
 Refer to  InputDevice  for more information about how different kinds of
 input devices and sources represent keys and buttons.",,keyboard data,keyboard,1,yes,no,SOURCE,no,
<android.widget.VideoView: void pause()>,,,void,1,"Displays a video file.  The VideoView class
 can load images from various sources (such as resources or content
 providers) takes care of computing its measurement from the video so that
 it can be used in any layout manager and provides various display options
 such as scaling and tinting. Note: VideoView does not retain its full state when going into the
 background.   In particular it does not restore the current play state
 play position selected tracks or any subtitle tracks added via
  addSubtitleSource() .  Applications should
 save and restore these on their own in
  Activity.onSaveInstanceState(Bundle)  and
  Activity.onRestoreInstanceState(Bundle) . 
 Also note that the audio session id (from  getAudioSessionId() ) may
 change from its previously returned value when the VideoView is restored.
  
 By default VideoView requests audio focus with  AudioManager#AUDIOFOCUS_GAIN . Use
  setAudioFocusRequest(int)  to change this behavior.
  
 The default  AudioAttributes  used during playback have a usage of
  AudioAttributes#USAGE_MEDIA  and a content type of
  AudioAttributes#CONTENT_TYPE_MOVIE  use  setAudioAttributes(android.media.AudioAttributes)  to
 modify them.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,no,0,no,no,no,no,
<android.app.Activity: void onConfigurationChanged(Configuration)>,"Called by the system when the device configuration changes while your
 activity is running.  Note that this will only be called if
 you have selected configurations you would like to handle with the R.attr.configChanges attribute in your manifest.  If
 any configuration change occurs that is not selected to be reported
 by that attribute then instead of reporting it the system will stop
 and restart the activity (to have it launched with the new
 configuration). At the time that this function has been called your Resources
 object will have been updated to return resource values matching the
 new configuration.","newConfig Configuration : The new device configuration.
This value must never be null . |||",void,1,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,callback,0,no,no,no,no,
<android.inputmethodservice.InputMethodService: void onExtractedTextClicked()>,"This is called when the user has clicked on the extracted text view
 when running in fullscreen mode.  The default implementation hides
 the candidates view when this happens but only if the extracted text
 editor has a vertical scroll bar because its text doesn't fit.
 Re-implement this to provide whatever behavior you want.",,void,3,"InputMethodService provides a standard implementation of an InputMethod
 which final implementations can derive from and customize.  See the
 base class  AbstractInputMethodService  and the  InputMethod 
 interface for more information on the basics of writing input methods.

  In addition to the normal Service lifecycle methods this class
 introduces some new specific callbacks that most subclasses will want
 to make use of: onInitializeInterface()  for user-interface initialization
 in particular to deal with configuration changes while the service is
 running.
  onBindInput()  to find out about switching to a new client.
  onStartInput(EditorInfo boolean)  to deal with an input session starting with
 the client.
  onCreateInputView()   onCreateCandidatesView() 
 and  onCreateExtractTextView()  for non-demand generation of the UI.
  onStartInputView(android.view.inputmethod.EditorInfo boolean)  to deal with input
 starting within the input area of the IME.
  An input method has significant discretion in how it goes about its
 work: the  InputMethodService  provides
 a basic framework for standard UI elements (input view candidates view
 and running in fullscreen mode) but it is up to a particular implementor
 to decide how to use them.  For example one input method could implement
 an input area with a keyboard another could allow the user to draw text
 while a third could have no input area (and thus not be visible to the
 user) but instead listen to audio and perform text to speech conversion. In the implementation provided here all of these elements are placed
 together in a single window managed by the InputMethodService.  It will
 execute callbacks as it needs information about them and provides APIs for
 programmatic control over them.  They layout of these elements is explicitly
 defined: The soft input view if available is placed at the bottom of the
 screen.
  The candidates view if currently shown is placed above the soft
 input view.
  If not running fullscreen the application is moved or resized to be
 above these views; if running fullscreen the window will completely cover
 the application and its top part will contain the extract text of what is
 currently being edited by the application.
  Soft Input View Central to most input methods is the soft input view.  This is where most
 user interaction occurs: pressing on soft keys drawing characters or
 however else your input method wants to generate text.  Most implementations
 will simply have their own view doing all of this work and return a new
 instance of it when  onCreateInputView()  is called.  At that point
 as long as the input view is visible you will see user interaction in
 that view and can call back on the InputMethodService to interact with the
 application as appropriate. There are some situations where you want to decide whether or not your
 soft input view should be shown to the user.  This is done by implementing
 the  onEvaluateInputViewShown()  to return true or false based on
 whether it should be shown in the current environment.  If any of your
 state has changed that may impact this call
  updateInputViewShown()  to have it re-evaluated.  The default
 implementation always shows the input view unless there is a hard
 keyboard available which is the appropriate behavior for most input
 methods. Candidates View Often while the user is generating raw text an input method wants to
 provide them with a list of possible interpretations of that text that can
 be selected for use.  This is accomplished with the candidates view and
 like the soft input view you implement  onCreateCandidatesView() 
 to instantiate your own view implementing your candidates UI. Management of the candidates view is a little different than the input
 view because the candidates view tends to be more transient being shown
 only when there are possible candidates for the current text being entered
 by the user.  To control whether the candidates view is shown you use
  setCandidatesViewShown(boolean) .  Note that because the candidate
 view tends to be shown and hidden a lot it does not impact the application
 UI in the same way as the soft input view: it will never cause application
 windows to resize only cause them to be panned if needed for the user to
 see the current focus. Fullscreen Mode Sometimes your input method UI is too large to integrate with the
 application UI so you just want to take over the screen.  This is
 accomplished by switching to full-screen mode causing the input method
 window to fill the entire screen and add its own ""extracted text"" editor
 showing the user the text that is being typed.  Unlike the other UI elements
 there is a standard implementation for the extract editor that you should
 not need to change.  The editor is placed at the top of the IME above the
 input and candidates views. Similar to the input view you control whether the IME is running in
 fullscreen mode by implementing  onEvaluateFullscreenMode() 
 to return true or false based on
 whether it should be fullscreen in the current environment.  If any of your
 state has changed that may impact this call
  updateFullscreenMode()  to have it re-evaluated.  The default
 implementation selects fullscreen mode when the screen is in a landscape
 orientation which is appropriate behavior for most input methods that have
 a significant input area. When in fullscreen mode you have some special requirements because the
 user can not see the application UI.  In particular you should implement
  onDisplayCompletions(android.view.inputmethod.CompletionInfo[])  to show completions
 generated by your application typically in your candidates view like you
 would normally show candidates.


  Generating Text The key part of an IME is of course generating text for the application.
 This is done through calls to the
  InputConnection  interface to the
 application which can be retrieved from  getCurrentInputConnection() .
 This interface allows you to generate raw key events or if the target
 supports it directly edit in strings of candidates and committed text. Information about what the target is expected and supports can be found
 through the  EditorInfo  class which is
 retrieved with  getCurrentInputEditorInfo()  method.  The most
 important part of this is  EditorInfo.inputType ; in particular if this is
  EditorInfo.TYPE_NULL 
 then the target does not support complex edits and you need to only deliver
 raw key events to it.  An input method will also want to look at other
 values here to for example detect password mode auto complete text views
 phone number entry etc. When the user switches between input targets you will receive calls to
  onFinishInput()  and  onStartInput(android.view.inputmethod.EditorInfo boolean) .
 You can use these to reset and initialize your input state for the current
 target.  For example you will often want to clear any input state and
 update a soft keyboard to be appropriate for the new inputType.",,UI data,callback,1,no,no,no,no,
<android.app.DialogFragment: void onSaveInstanceState(Bundle)>,"Called to ask the fragment to save its current dynamic state so it
 can later be reconstructed in a new instance of its process is
 restarted.  If a new instance of the fragment later needs to be
 created the data you place in the Bundle here will be available
 in the Bundle given to onCreate(android.os.Bundle)  onCreateView(android.view.LayoutInflater android.view.ViewGroup android.os.Bundle) and onActivityCreated(android.os.Bundle) . This corresponds to Activity#onSaveInstanceState(Bundle) and most of the discussion there
 applies here as well.  Note however: this method may be called
 at any time before onDestroy() .  There are many situations
 where a fragment may be mostly torn down (such as when placed on the
 back stack with no UI showing) but its state will not be saved until
 its owning activity actually needs to save its state.",outState Bundle : Bundle in which to place your saved state. |||,void,11,"Base class for Dialogs.

  Note: Activities provide a facility to manage the creation saving and
 restoring of dialogs. See  Activity#onCreateDialog(int) 
  Activity#onPrepareDialog(int Dialog) 
  Activity#showDialog(int)  and  Activity#dismissDialog(int) . If
 these methods are used  getOwnerActivity()  will return the Activity
 that managed this dialog.

  Often you will want to have a Dialog display on top of the current
 input method because there is no reason for it to accept text.  You can
 do this by setting the  WindowManager.LayoutParams#FLAG_ALT_FOCUSABLE_IM  window flag (assuming
 your Dialog takes input focus as it the default) with the following code:

  
 getWindow().setFlags(WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM
         WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
<android.app.WallpaperInfo: Drawable loadThumbnail(PackageManager)>,Load the thumbnail image for this wallpaper.,"pm PackageManager : Supply a PackageManager used to load the wallpaper's
resources. |||",Drawable |||,7,This class is used to specify meta information of a wallpaper service.,"Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",image,UI,1,no,sink,no,SINK,
<android.view.View: void setTop(int)>,"Sets the top position of this view relative to its parent. This method is meant to be called
 by the layout system and should not generally be called otherwise because the property
 may be changed at any time by the layout.",top int : The top of this view in pixels. |||,void,11,"This class represents the basic building block for user interface components. A View
 occupies a rectangular area on the screen and is responsible for drawing and
 event handling. View is the base class for  widgets  which are
 used to create interactive UI components (buttons text fields etc.). The
  ViewGroup  subclass is the base class for  layouts  which
 are invisible containers that hold other Views (or other ViewGroups) and define
 their layout properties.",,no,UI,0,no,no,no,no,
<android.app.ProgressDialog: void setSecondaryProgress(int)>,Sets the secondary progress.,secondaryProgress int : the current secondary progress a value between 0 and getMax() |||,void,1,"A dialog showing a progress indicator and an optional text message or view.
 Only a text message or a view can be used at the same time.

  The dialog can be made cancelable on back key press. The progress range is 0 to  max .","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
<android.webkit.WebView: void reload()>,Reloads the current URL.,,void,1,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",no,no,0,no,no,no,no,
"<android.os.Bundle: CharSequence getCharSequence(String,CharSequence)>","Returns the value associated with the given key or defaultValue if
 no mapping of the desired type exists for the given key or if a null
 value is explicitly associatd with the given key.","key String : a String or null
This value may be null . |||
defaultValue CharSequence : Value to return if key does not exist or if a null
value is associated with the given key. |||","CharSequence the CharSequence value associated with the given key or defaultValue
     if no valid CharSequence object is currently mapped to that key. |||",12,A mapping from String keys to various  Parcelable  values.,,IPC,no,0,no,no,no,no,
<android.database.sqlite.SQLiteDatabase: void endTransaction()>,"End a transaction. See beginTransaction for notes about how to use this and when transactions
 are committed and rolled back.",,void,1,"Exposes methods to manage a SQLite database.

  
 SQLiteDatabase has methods to create delete execute SQL commands and
 perform other common database management tasks.
  
 See the Notepad sample application in the SDK for an example of creating
 and managing a database.
  
 Database names must be unique within an application not across all applications.
  Localized Collation - ORDER BY 
 In addition to SQLite's default  BINARY  collator Android supplies
 two more  LOCALIZED  which changes with the system's current locale
 and  UNICODE  which is the Unicode Collation Algorithm and not tailored
 to the current locale.","If you need to manage data in a private database use the  android.database.sqlite  classes. These classes are used to manage the  Cursor  object returned from a content provider query. Databases
 are usually created and opened with  openOrCreateDatabase(String int SQLiteDatabase.CursorFactory) 
 To make requests through
 content providers you can use the  content.ContentResolver  class.
  All databases are stored on the device in  /data/data/<package_name>/databases",no,database,0,no,no,no,no,
"<android.content.ContentProviderClient: String getStreamTypes(Uri,String)>",See ContentProvider#getStreamTypes,"url Uri : This value must never be null . |||
mimeTypeFilter String : This value must never be null . |||",String[] This value may be null . |||,11,"Content providers are one of the primary building blocks of Android applications providing
 content to applications. They encapsulate data and provide it to applications through the single
  ContentResolver  interface. A content provider is only required if you need to share
 data between multiple applications. For example the contacts data is used by multiple
 applications and must be stored in a content provider. If you don't need to share data amongst
 multiple applications you can use a database directly via
  SQLiteDatabase .

  When a request is made via
 a  ContentResolver  the system inspects the authority of the given URI and passes the
 request to the content provider registered with the authority. The content provider can interpret
 the rest of the URI however it wants. The  UriMatcher  class is helpful for parsing
 URIs. The primary methods that need to be implemented are:
  onCreate()  which is called to initialize the provider query(Uri String[] Bundle CancellationSignal)  which returns data to the caller insert(Uri ContentValues)  which inserts new data into the content provider update(Uri ContentValues String String[])  which updates existing data in the content provider delete(Uri String String[])  which deletes data from the content provider getType(Uri)  which returns the MIME type of data in the content provider Requests to  ContentResolver  are automatically forwarded to the appropriate
 ContentProvider instance so subclasses don't have to worry about the details of
 cross-process calls.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",database metadata,database,1,yes,no,SOURCE,no,
<android.app.PendingIntent: String getCreatorPackage()>,"Return the package name of the application that created this
 PendingIntent that is the identity under which you will actually be
 sending the Intent.  The returned string is supplied by the system so
 that an application can not spoof its package. Be careful about how you use this.  All this tells you is
 who created the PendingIntent.  It does not tell you who
 handed the PendingIntent to you: that is PendingIntent objects are intended to be
 passed between applications so the PendingIntent you receive from an application
 could actually be one it received from another application meaning the result
 you get here will identify the original application.  Because of this you should
 only use this information to identify who you expect to be interacting with
 through a send() call not who gave you the PendingIntent.",,"String The package name of the PendingIntent or null if there is
 none associated with it. |||",17,"A description of an Intent and target action to perform with it.  Instances
 of this class are created with  getActivity(Context int Intent int)   getActivities(Context int Intent[] int) 
  getBroadcast(Context int Intent int)  and  getService(Context int Intent int) ; the returned object can be
 handed to other applications so that they can perform the action you
 described on your behalf at a later time.

  By giving a PendingIntent to another application
 you are granting it the right to perform the operation you have specified
 as if the other application was yourself (with the same permissions and
 identity).  As such you should be careful about how you build the PendingIntent:
 almost always for example the base Intent you supply should have the component
 name explicitly set to one of your own components to ensure it is ultimately
 sent there and nowhere else.

  A PendingIntent itself is simply a reference to a token maintained by
 the system describing the original data used to retrieve it.  This means
 that even if its owning application's process is killed the
 PendingIntent itself will remain usable from other processes that
 have been given it.  If the creating application later re-retrieves the
 same kind of PendingIntent (same operation same Intent action data
 categories and components and same flags) it will receive a PendingIntent
 representing the same token if that is still valid and can thus call
  cancel()  to remove it.

  Because of this behavior it is important to know when two Intents
 are considered to be the same for purposes of retrieving a PendingIntent.
 A common mistake people make is to create multiple PendingIntent objects
 with Intents that only vary in their ""extra"" contents expecting to get
 a different PendingIntent each time.  This does  not  happen.  The
 parts of the Intent that are used for matching are the same ones defined
 by  Intent#filterEquals(Intent) .  If you use two
 Intent objects that are equivalent as per
  Intent#filterEquals(Intent)  then you will get
 the same PendingIntent for both of them.

  There are two typical ways to deal with this.

  If you truly need multiple distinct PendingIntent objects active at
 the same time (such as to use as two notifications that are both shown
 at the same time) then you will need to ensure there is something that
 is different about them to associate them with different PendingIntents.
 This may be any of the Intent attributes considered by
  Intent#filterEquals(Intent)  or different
 request code integers supplied to  getActivity(Context int Intent int)   getActivities(Context int Intent[] int) 
  getBroadcast(Context int Intent int)  or  getService(Context int Intent int) .

  If you only need one PendingIntent active at a time for any of the
 Intents you will use then you can alternatively use the flags
  FLAG_CANCEL_CURRENT  or  FLAG_UPDATE_CURRENT  to either
 cancel or modify whatever current PendingIntent is associated with the
 Intent you are supplying.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",IPC,no,0,no,no,no,no,
"<android.view.inputmethod.InputMethodSubtype: CharSequence getDisplayName(Context,String,ApplicationInfo)>","Returns a display name for this subtype. If subtypeNameResId is specified (!= 0) text generated from that resource will
 be returned. The localized string resource of the label should be capitalized for inclusion
 in UI lists. The string resource may contain at most one %s . If present the %s will be replaced with the display name of the subtype locale in the user's locale. If subtypeNameResId is not specified (== 0) the framework returns the display name
 of the subtype locale as capitalized for use in UI lists in the user's locale.","context Context : Context will be used for getting Locale and PackageManager . |||
packageName String : The package name of the input method. |||
appInfo ApplicationInfo : The ApplicationInfo of the input method. |||","CharSequence a display name for this subtype.
 
 This value will never be null . |||",14,"This class is used to specify meta information of a subtype contained in an input method editor
 (IME). Subtype can describe locale (e.g. en_US fr_FR...) and mode (e.g. voice keyboard...)
 and is used for IME switch and settings. The input method subtype allows the system to bring up
 the specified subtype of the designated IME directly.

  It should be defined in an XML resource file of the input method with the
  <subtype>  element which resides within an  <input-method>  element.
 For more information see the guide to
  
 Creating an Input Method .",,no,no,0,no,no,no,no,
"<android.content.ContextWrapper: void startActivity(Intent,Bundle)>","Launch a new activity.  You will not receive any information about when
 the activity exits. Note that if this method is being called from outside of an Activity Context then the Intent must include
 the Intent#FLAG_ACTIVITY_NEW_TASK launch flag.  This is because
 without being started from an existing Activity there is no existing
 task in which to place the new activity and thus it needs to be placed
 in its own separate task. This method throws ActivityNotFoundException if there was no Activity found to run the given Intent.","intent Intent : The description of the activity to start. |||
options Bundle : Additional options for how the Activity should be started.
May be null if there are no options.  See ActivityOptions for how to build the Bundle supplied here; there are no supported definitions
for building it manually.
This value may be null . |||",void,16,"Proxying implementation of Context that simply delegates all of its calls to
 another Context.  Can be subclassed to modify behavior without changing
 the original Context.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",uncategorized,IPC,1,no,yes,no,SINK,
"<android.appwidget.AppWidgetManager: void updateAppWidgetOptions(int,Bundle)>","Update the extras for a given widget instance. The extras can be used to embed additional information about this widget to be accessed
 by the associated widget's AppWidgetProvider.","appWidgetId int : The AppWidget instances for which to set the RemoteViews. |||
options Bundle : The options to associate with this widget |||",void,16,"Updates AppWidget state; gets information about installed AppWidget providers and other
 AppWidget related state.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,UI,0,no,no,no,no,
"<android.media.MediaMetadataRetriever: void setDataSource(Context,Uri)>","Sets the data source as a content Uri. Call this method before
 the rest of the methods in this class. This method may be time-consuming.","context Context : the Context to use when resolving the Uri |||
uri Uri : the Content URI of the data you want to play |||",void,10,Contains metadata about an item such as the title artist etc.,"The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",no,no,0,no,no,no,no,
<android.widget.ImageView: void setImageResource(int)>,"Sets a drawable as the content of this ImageView. This does Bitmap reading and decoding on the UI
 thread which can cause a latency hiccup.  If that's a concern
 consider using setImageDrawable(android.graphics.drawable.Drawable) or setImageBitmap(android.graphics.Bitmap) and BitmapFactory instead. Related XML Attributes: android:src",resId int : the resource identifier of the drawable |||,void,1,"Displays image resources for example  Bitmap 
 or  Drawable  resources.
 ImageView is also commonly used to
  apply tints to an image  and
 handle  image scaling .

  
 The following XML snippet is a common example of using an ImageView to display an image resource:
  
 <LinearLayout
     xmlns:android=""http://schemas.android.com/apk/res/android""
     android:layout_width=""match_parent""
     android:layout_height=""match_parent"">
     <ImageView
         android:layout_width=""wrap_content""
         android:layout_height=""wrap_content""
         android:src=""@drawable/my_image""
         android:contentDescription=""@string/my_image_description""
         />
 </LinearLayout>
  
 To learn more about Drawables see:  Drawable Resources .
 To learn more about working with Bitmaps see:  Handling Bitmaps .","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,UI,0,no,no,no,no,
"<android.media.RingtoneManager: Ringtone getRingtone(Context,Uri)>","Returns a Ringtone for a given sound URI. If the given URI cannot be opened for any reason this method will
 attempt to fallback on another sound. If it cannot find any it will
 return null.","context Context : A context used to query. |||
ringtoneUri Uri : The Uri of a sound or ringtone. |||",Ringtone A Ringtone for the given URI or null. |||,1,"RingtoneManager provides access to ringtones notification and other types
 of sounds. It manages querying the different media providers and combines the
 results into a single cursor. It also provides a  Ringtone  for each
 ringtone. We generically call these sounds ringtones however the
  TYPE_RINGTONE  refers to the type of sounds that are suitable for the
 phone ringer.
  
 To show a ringtone picker to the user use the
  ACTION_RINGTONE_PICKER  intent to launch the picker as a subactivity.","The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",preferences,preference storage file,1,yes,no,SOURCE,no,
"<android.app.Activity: void startIntentSenderFromChild(Activity,IntentSender,int,Intent,int,int,int,Bundle)>","This method was deprecated
      in API level R. Use startIntentSenderForResult(android.content.IntentSender int android.content.Intent int int int android.os.Bundle) instead. Like startActivityFromChild(android.app.Activity android.content.Intent int) but
 taking a IntentSender; see startIntentSenderForResult(android.content.IntentSender int android.content.Intent int int int) for more information.","child Activity |||
intent IntentSender |||
requestCode int |||
fillInIntent Intent |||
flagsMask int |||
flagsValues int |||
extraFlags int |||
options Bundle : This value may be null . |||",void,16,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",IPC,IPC,1,no,yes,no,SINK,
<android.widget.Toast: void setText(int)>,Update the text in a Toast that was previously created using one of the makeText() methods.,resId int : The new text for the Toast. |||,void,1,"A toast is a view containing a quick little message for the user.  The toast class
 helps you create and show those.
  
 When the view is shown to the user appears as a floating view over the
 application.  It will never receive focus.  The user will probably be in the
 middle of typing something else.  The idea is to be as unobtrusive as
 possible while still showing the user the information you want them to see.
 Two examples are the volume control and the brief message saying that your
 settings have been saved.
  
 The easiest way to use this class is to call one of the static methods that constructs
 everything you need and returns a new Toast object.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,UI,0,no,no,no,no,
"<android.app.Dialog: void setFeatureDrawable(int,Drawable)>",Convenience for calling Window.setFeatureDrawable(int Drawable) .,"featureId int |||
drawable Drawable : This value may be null . |||",void,1,"Base class for Dialogs.

  Note: Activities provide a facility to manage the creation saving and
 restoring of dialogs. See  Activity#onCreateDialog(int) 
  Activity#onPrepareDialog(int Dialog) 
  Activity#showDialog(int)  and  Activity#dismissDialog(int) . If
 these methods are used  getOwnerActivity()  will return the Activity
 that managed this dialog.

  Often you will want to have a Dialog display on top of the current
 input method because there is no reason for it to accept text.  You can
 do this by setting the  WindowManager.LayoutParams#FLAG_ALT_FOCUSABLE_IM  window flag (assuming
 your Dialog takes input focus as it the default) with the following code:

  
 getWindow().setFlags(WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM
         WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
<android.webkit.WebView: Picture capturePicture()>,"This method was deprecated
      in API level 19. Use onDraw(Canvas) to obtain a bitmap snapshot of the WebView or saveWebArchive(String) to save the content to a file. Gets a new picture that captures the current contents of this WebView.
 The picture is of the entire document being displayed and is not
 limited to the area currently displayed by this WebView. Also the
 picture is a static copy and is unaffected by later changes to the
 content being displayed. Note that due to internal changes for API levels between Build.VERSION_CODES.HONEYCOMB and Build.VERSION_CODES.ICE_CREAM_SANDWICH inclusive the
 picture does not include fixed position elements or scrollable divs. Note that from Build.VERSION_CODES.JELLY_BEAN_MR1 the returned picture
 should only be drawn into bitmap-backed Canvas - using any other type of Canvas will involve
 additional conversion at a cost in memory and performance.",,Picture a picture that captures the current contents of this WebView |||,1,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",image,camera,1,yes,no,SOURCE,no,
<android.view.ViewPropertyAnimator: void cancel()>,Cancels all property animations that are currently running or pending.,,void,14,"This class enables automatic and optimized animation of select properties on View objects.
 If only one or two properties on a View object are being animated then using an
  ObjectAnimator  is fine; the property setters called by ObjectAnimator
 are well equipped to do the right thing to set the property and invalidate the view
 appropriately. But if several properties are animated simultaneously or if you just want a
 more convenient syntax to animate a specific property then ViewPropertyAnimator might be
 more well-suited to the task.

  This class may provide better performance for several simultaneous animations because
 it will optimize invalidate calls to take place only once for several properties instead of each
 animated property independently causing its own invalidation. Also the syntax of using this
 class could be easier to use because the caller need only tell the View object which
 property to animate and the value to animate either to or by and this class handles the
 details of configuring the underlying Animator class and starting it. This class is not constructed by the caller but rather by the View whose properties
 it will animate. Calls to  View.animate()  will return a reference
 to the appropriate ViewPropertyAnimator object for that View.",,no,no,0,no,no,no,no,
"<android.widget.TextView: void setTextSize(int,float)>",Set the default text size to a given unit and value. See TypedValue for the possible dimension units. Note: if this TextView has the auto-size feature enabled than this function is no-op. Related XML Attributes: android:textSize,"unit int : The desired dimension unit. |||
size float : The desired size in the given units. |||",void,1,"A user interface element that displays text to the user.
 To provide user-editable text see  EditText .
  
 The following code sample shows a typical use with an XML layout
 and code to modify the contents of the text view:
  
 <LinearLayout
      xmlns:android=""http://schemas.android.com/apk/res/android""
      android:layout_width=""match_parent""
      android:layout_height=""match_parent"">
    <TextView
        android:id=""@+id/text_view_id""
        android:layout_height=""wrap_content""
        android:layout_width=""wrap_content""
        android:text=""@string/hello"" />
 </LinearLayout>
  
 This code sample demonstrates how to modify the contents of the text view
 defined in the previous XML layout:
  
 public class MainActivity extends Activity {

    protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_main);
         final TextView helloTextView = (TextView) findViewById(R.id.text_view_id);
         helloTextView.setText(R.string.user_greeting);
     }
 }
  
 To customize the appearance of TextView see  Styles and Themes .
  XML attributes 
 See  TextView Attributes 
  View Attributes","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,UI,0,no,no,no,no,
"<android.view.textservice.SentenceSuggestionsInfo: void writeToParcel(Parcel,int)>",Used to package this object into a Parcel .,"dest Parcel : The Parcel to be written. |||
flags int : The flags used for parceling. |||",void,16,"This class contains a metadata of suggestions returned from a text service
 (e.g.  SpellCheckerService ).
 The text service uses this class to return the suggestions
 for a sentence. See  SuggestionsInfo  which is used for suggestions for a word.
 This class extends the functionality of  SuggestionsInfo  as far as this class enables
 you to put multiple  SuggestionsInfo s on a sentence with the offsets and the lengths
 of all  SuggestionsInfo s.",,IPC,no,0,no,no,no,no,
"<android.database.sqlite.SQLiteDatabase: int updateWithOnConflict(String,ContentValues,String,String,int)>",Convenience method for updating rows in the database.,"table String : the table to update in |||
values ContentValues : a map from column names to new column values. null is a
valid value that will be translated to NULL. |||
whereClause String : the optional WHERE clause to apply when updating.
Passing null will update all rows. |||
whereArgs String : You may include ?s in the where clause which
will be replaced by the values from whereArgs. The values
will be bound as Strings. |||
conflictAlgorithm int : for update conflict resolver |||",int the number of rows affected |||,8,"Exposes methods to manage a SQLite database.

  
 SQLiteDatabase has methods to create delete execute SQL commands and
 perform other common database management tasks.
  
 See the Notepad sample application in the SDK for an example of creating
 and managing a database.
  
 Database names must be unique within an application not across all applications.
  Localized Collation - ORDER BY 
 In addition to SQLite's default  BINARY  collator Android supplies
 two more  LOCALIZED  which changes with the system's current locale
 and  UNICODE  which is the Unicode Collation Algorithm and not tailored
 to the current locale.","If you need to manage data in a private database use the  android.database.sqlite  classes. These classes are used to manage the  Cursor  object returned from a content provider query. Databases
 are usually created and opened with  openOrCreateDatabase(String int SQLiteDatabase.CursorFactory) 
 To make requests through
 content providers you can use the  content.ContentResolver  class.
  All databases are stored on the device in  /data/data/<package_name>/databases",database data,database,1,no,yes,no,SINK,
<android.net.TrafficStats: void incrementOperationCount(int)>,"Increment count of network operations performed under the accounting tag
 currently active on the calling thread. This can be used to derive
 bytes-per-operation.",operationCount int : Number of operations to increment count by. |||,void,14,"Class that provides network traffic statistics. These statistics include
 bytes transmitted and received and network packets transmitted and received
 over all interfaces over the mobile interface and on a per-UID basis.
  
 These statistics may not be available on all platforms. If the statistics are
 not supported by this device  UNSUPPORTED  will be returned.
  
 Note that the statistics returned by this class reset and start from zero
 after every reboot. To access more robust historical network statistics data
 use  NetworkStatsManager  instead.",,no,network ,0,no, no,no,no,
"<android.telephony.SmsMessage: SmsMessage createFromPdu(byte,String)>","Create an SmsMessage from a raw PDU with the specified message format. The
 message format is passed in the Telephony.Sms.Intents.SMS_RECEIVED_ACTION as the format String extra and will be either ""3gpp"" for GSM/UMTS/LTE messages in 3GPP format
 or ""3gpp2"" for CDMA/LTE messages in 3GPP2 format.","pdu byte : the message PDU from the Telephony.Sms.Intents.SMS_RECEIVED_ACTION intent |||
format String : the format extra from the Telephony.Sms.Intents.SMS_RECEIVED_ACTION intent |||",SmsMessage |||,23,A Short Message Service message.,,sms message,no,0,no,no,no,no,
<android.inputmethodservice.KeyboardView: void onDraw(Canvas)>,Implement this to do your drawing.,canvas Canvas : the canvas on which the background will be drawn |||,void,3,"A view that renders a virtual  Keyboard . It handles rendering of keys and
 detecting key presses and touch movements.",,uncategorized,UI,1,no,no,no,no,
<android.widget.TextSwitcher: void setCurrentText(CharSequence)>,"Sets the text of the text view that is currently showing.  This does
 not perform the animations.",text CharSequence : the new text to display |||,void,1,"Specialized  ViewSwitcher  that contains
 only children of type  TextView .

 A TextSwitcher is useful to animate a label on screen. Whenever
  setText(java.lang.CharSequence)  is called TextSwitcher animates the current text
 out and animates the new text in.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",uncategorized,UI,1,no,no,no,no,
<android.widget.AutoCompleteTextView: void showDropDown()>,Displays the drop down on screen.,,void,1,"An editable text view that shows completion suggestions automatically
 while the user is typing. The list of suggestions is displayed in a drop
 down menu from which the user can choose an item to replace the content
 of the edit box with. The drop down can be dismissed at any time by pressing the back key or
 if no item is selected in the drop down by pressing the enter/dpad center
 key. The list of suggestions is obtained from a data adapter and appears
 only after a given number of characters defined by
  the threshold . The following code snippet shows how to create a text view which suggests
 various countries names while the user is typing: 
 public class CountriesActivity extends Activity {
     protected void onCreate(Bundle icicle) {
         super.onCreate(icicle);
         setContentView(R.layout.countries);

         ArrayAdapter<String> adapter = new ArrayAdapter<String>(this
                 android.R.layout.simple_dropdown_item_1line COUNTRIES);
         AutoCompleteTextView textView = (AutoCompleteTextView)
                 findViewById(R.id.countries_list);
         textView.setAdapter(adapter);
     }

     private static final String[] COUNTRIES = new String[] {
         ""Belgium"" ""France"" ""Italy"" ""Germany"" ""Spain""
     };
 }
  See the  Text Fields 
 guide.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,no,0,no,no,no,no,
"<android.text.TextUtils: void copySpansFrom(Spanned,int,int,Class,Spannable,int)>","Copies the spans from the region start...end in source to the region destoff...destoff+end-start in dest .
 Spans in source that begin before start or end after end but overlap this range are trimmed
 as if they began at start or ended at end .","source Spanned |||
start int |||
end int |||
kind Class |||
dest Spannable |||
destoff int |||",void,1,,"Provides classes used to render or track text and text spans on the screen. You can use these classes to design your own widgets that manage text
 to handle arbitrary text spans for changes or to handle drawing yourself
 for an existing widget. The Span… interfaces and classes are used to create or manage spans of
 text in a View item. You can use these to style the text or background or to
 listen for changes. If creating your own widget extend DynamicLayout to manages
 the actual wrapping and drawing of your text.",no,no,0,no,no,no,no,
<android.widget.ListPopupWindow: void show()>,"Show the popup list. If the list is already showing this method
 will recalculate the popup's size and position.",,void,11,"A ListPopupWindow anchors itself to a host view and displays a
 list of choices.

  ListPopupWindow contains a number of tricky behaviors surrounding
 positioning scrolling parents to fit the dropdown interacting
 sanely with the IME if present and others.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,no,0,no,no,no,no,
<android.app.WallpaperManager: void setResource(int)>,"Change the current system wallpaper to the bitmap in the given resource.
 The resource is opened as a raw data stream and copied into the
 wallpaper; it must be a valid PNG or JPEG image.  On success the intent Intent#ACTION_WALLPAPER_CHANGED is broadcast. This method requires the caller to hold the permission Manifest.permission.SET_WALLPAPER . Requires Manifest.permission.SET_WALLPAPER",resid int : The resource ID of the bitmap to be used as the wallpaper image |||,void,5,"Provides access to the system wallpaper. With WallpaperManager you can
 get the current wallpaper get the desired dimensions for the wallpaper set
 the wallpaper and more.

   An app can check whether wallpapers are supported for the current user by calling
  isWallpaperSupported()  and whether setting of wallpapers is allowed by calling
  isSetWallpaperAllowed() .","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
<android.preference.SwitchPreference: void setSwitchTextOn(int)>,"Set the text displayed on the switch widget in the on state.
 This should be a very short string; one word if possible.",resId int : The text as a string resource ID |||,void,14,"A  Preference  that provides a two-state toggleable option.
  
 This preference will store a boolean into the SharedPreferences.",,no,no,0,no,no,no,no,
<android.app.Instrumentation: void callActivityOnPause(Activity)>,"Perform calling of an activity's Activity#onPause method.  The
 default implementation simply calls through to that method.",activity Activity : The activity being paused. |||,void,1,"Base class for implementing application instrumentation code.  When running
 with instrumentation turned on this class will be instantiated for you
 before any of the application code allowing you to monitor all of the
 interaction the system has with the application.  An Instrumentation
 implementation is described to the system through an AndroidManifest.xml's
 <instrumentation> tag.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",IPC,IPC,1,no,yes,no,SINK,
<android.widget.TextView: void setSingleLine()>,"Sets the properties of this field (lines horizontally scrolling
 transformation method) to be for a single-line input. Related XML Attributes: android:singleLine",,void,1,"A user interface element that displays text to the user.
 To provide user-editable text see  EditText .
  
 The following code sample shows a typical use with an XML layout
 and code to modify the contents of the text view:
  
 <LinearLayout
      xmlns:android=""http://schemas.android.com/apk/res/android""
      android:layout_width=""match_parent""
      android:layout_height=""match_parent"">
    <TextView
        android:id=""@+id/text_view_id""
        android:layout_height=""wrap_content""
        android:layout_width=""wrap_content""
        android:text=""@string/hello"" />
 </LinearLayout>
  
 This code sample demonstrates how to modify the contents of the text view
 defined in the previous XML layout:
  
 public class MainActivity extends Activity {

    protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_main);
         final TextView helloTextView = (TextView) findViewById(R.id.text_view_id);
         helloTextView.setText(R.string.user_greeting);
     }
 }
  
 To customize the appearance of TextView see  Styles and Themes .
  XML attributes 
 See  TextView Attributes 
  View Attributes","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,no,0,no,no,no,no,
"<android.content.Intent: byte getByteExtra(String,byte)>",Retrieve extended data from the intent.,"name String : The name of the desired item. |||
defaultValue byte : the value to be returned if no value of the desired
type is stored with the given name. |||","byte the value of an item previously added with putExtra()
 or the default value if none was found. |||",1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",IPC,no,0,no,no,no,no,
"<android.content.Intent: Intent putExtra(String,CharSequence)>","Add extended data to the intent.  The name must include a package
 prefix for example the app com.android.contacts would use names
 like ""com.android.contacts.ShowAll"".","name String : The name of the extra data with package prefix. |||
value CharSequence : The CharSequence array data value.
This value may be null . |||","Intent Returns the same Intent object for chaining multiple calls
 into a single statement.

 This value will never be null . |||",8,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",IPC,no,0,no,no,no,no,
<android.os.Bundle: CharSequence getCharSequenceArray(String)>,"Returns the value associated with the given key or null if
 no mapping of the desired type exists for the given key or a null
 value is explicitly associated with the key.","key String : a String or null
This value may be null . |||",CharSequence[] a CharSequence[] value or null |||,8,A mapping from String keys to various  Parcelable  values.,,IPC,no,0,no,no,no,no,
<android.app.AlertDialog: void setTitle(CharSequence)>,Set the title text for this dialog's window.,"title CharSequence : The new text to display in the title.
This value may be null . |||",void,1,"A subclass of Dialog that can display one two or three buttons. If you only want to
 display a String in this dialog box use the setMessage() method.  If you
 want to display a more complex view look up the FrameLayout called ""custom""
 and add your view to it:

  
 FrameLayout fl = findViewById(android.R.id.custom);
 fl.addView(myView new LayoutParams(MATCH_PARENT WRAP_CONTENT));
  The AlertDialog class takes care of automatically setting
  WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM  for you based on whether
 any views in the dialog return true from  View#onCheckIsTextEditor() .  Generally you want this set for a Dialog
 without text editors so that it will be placed on top of the current
 input method UI.  You can modify this behavior by forcing the flag to your
 desired mode after calling  onCreate(Bundle) .","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",uncategorized,UI,1,no,no,no,no,
"<android.media.AudioManager: void playSoundEffect(int,float)>",Plays a sound effect (Key clicks lid open/close...),"effectType int : The type of sound effect. One of FX_KEY_CLICK  FX_FOCUS_NAVIGATION_UP  FX_FOCUS_NAVIGATION_DOWN  FX_FOCUS_NAVIGATION_LEFT  FX_FOCUS_NAVIGATION_RIGHT  FX_KEYPRESS_STANDARD  FX_KEYPRESS_SPACEBAR  FX_KEYPRESS_DELETE  FX_KEYPRESS_RETURN  FX_KEYPRESS_INVALID  |||
volume float : Sound effect volume.
The volume value is a raw scalar so UI controls should be scaled logarithmically.
If a volume of -1 is specified the AudioManager.STREAM_MUSIC stream volume minus 3dB will be used.
NOTE: This version is for applications that have their own
settings panel for enabling and controlling volume. |||",void,3,AudioManager provides access to volume and ringer mode control.,"The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",no,no,0,no,no,no,no,
<android.content.Intent: String resolveType(Context)>,"Return the MIME data type of this intent.  If the type field is
 explicitly set that is simply returned.  Otherwise if the data is set
 the type of that data is returned.  If neither fields are set a null is
 returned.",context Context : This value must never be null . |||,String The MIME type of this intent. |||,1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",IPC,no,0,no,no,no,no,
<android.view.View: void onPopulateAccessibilityEvent(AccessibilityEvent)>,"Called from dispatchPopulateAccessibilityEvent(android.view.accessibility.AccessibilityEvent) giving a chance to this View to populate the accessibility event with its
 text content. While this method is free to modify event
 attributes other than text content doing so should normally be performed in onInitializeAccessibilityEvent(android.view.accessibility.AccessibilityEvent) . Example: Adding formatted date string to an accessibility event in addition
          to the text added by the super implementation: If an AccessibilityDelegate has been specified via calling setAccessibilityDelegate(android.view.View.AccessibilityDelegate) its AccessibilityDelegate#onPopulateAccessibilityEvent(View AccessibilityEvent) is responsible for handling this call. Note: Always call the super implementation before adding
 information to the event in case the default implementation has basic information to add.",event AccessibilityEvent : The accessibility event which to populate. |||,void,14,"This class represents the basic building block for user interface components. A View
 occupies a rectangular area on the screen and is responsible for drawing and
 event handling. View is the base class for  widgets  which are
 used to create interactive UI components (buttons text fields etc.). The
  ViewGroup  subclass is the base class for  layouts  which
 are invisible containers that hold other Views (or other ViewGroups) and define
 their layout properties.",,no,no,0,no,no,no,no,
<android.speech.tts.TextToSpeech: Set getFeatures(Locale)>,"This method was deprecated
      in API level 21. As of API level 21 please use voices. In order to query features of the voice
 call getVoices() to retrieve the list of available voices and Voice#getFeatures() to retrieve the set of features. Queries the engine for the set of features it supports for a given locale.
 Features can either be framework defined e.g. TextToSpeech.Engine#KEY_FEATURE_NETWORK_SYNTHESIS or engine specific.
 Engine specific keys must be prefixed by the name of the engine they
 are intended for. These keys can be used as parameters to TextToSpeech#speak(String int java.util.HashMap) and TextToSpeech#synthesizeToFile(String java.util.HashMap String) .

 Features values are strings and their values must meet restrictions described in their
 documentation.",locale Locale : The locale to query features for. |||,Set < String > Set instance. May return null on error. |||,15,"Synthesizes speech from text for immediate playback or to create a sound file.
  A TextToSpeech instance can only be used to synthesize text once it has completed its
 initialization. Implement the  TextToSpeech.OnInitListener  to be
 notified of the completion of the initialization. 
 When you are done using the TextToSpeech instance call the  shutdown()  method
 to release the native resources used by the TextToSpeech engine.",,no,no,0,no,no,no,no,
<android.bluetooth.BluetoothHeadset: List getConnectedDevices()>,Get connected devices for this specific profile. Return the set of devices which are in state STATE_CONNECTED Requires Manifest.permission.BLUETOOTH,,List < BluetoothDevice > List of devices. The list will be empty on error. |||,11,"Public API for controlling the Bluetooth Headset Service. This includes both
 Bluetooth Headset and Handsfree (v1.5) profiles.

  BluetoothHeadset is a proxy object for controlling the Bluetooth Headset
 Service via IPC.

   Use  BluetoothAdapter#getProfileProxy  to get
 the BluetoothHeadset proxy object. Use
  BluetoothAdapter#closeProfileProxy  to close the service connection.

   Android only supports one connected Bluetooth Headset at a time.
 Each method is protected with its appropriate permission.","Provides classes that manage Bluetooth functionality such as scanning for
 devices connecting with devices and managing data transfer between devices.
 The Bluetooth API supports both ""Classic Bluetooth"" and Bluetooth Low Energy. For more information about Classic Bluetooth see the
  Bluetooth  guide.
 For more information about Bluetooth Low Energy see the
  
 Bluetooth Low Energy  (BLE) guide. The Bluetooth APIs let applications: Scan for other Bluetooth devices (including BLE devices). Query the local Bluetooth adapter for paired Bluetooth devices. Establish RFCOMM channels/sockets. Connect to specified sockets on other devices. Transfer data to and from other devices. Communicate with BLE devices such as proximity sensors heart rate
     monitors fitness devices and so on. Act as a GATT client or a GATT server (BLE). 
 To perform Bluetooth communication using these APIs an application must
 declare the  BLUETOOTH  permission. Some
 additional functionality such as requesting device discovery
 also requires the  BLUETOOTH_ADMIN 
 permission.
  Note: 
 Not all Android-powered devices provide Bluetooth functionality.",bluetooth metadata,bluetooth,1,yes,no,SOURCE,no,
"<android.widget.PopupWindow: void update(View,int,int,int,int)>","Updates the position and the dimension of the popup window. Width and height can be set to -1 to update location only. Calling this
 function also updates the window with the current popup state as
 described for update() . If the view later scrolls to move anchor to a different
 location the popup will be moved correspondingly.","anchor View : the popup's anchor view |||
xoff int : x offset from the view's left edge |||
yoff int : y offset from the view's bottom edge |||
width int : the new width in pixels must be >= 0 or -1 to ignore |||
height int : the new height in pixels must be >= 0 or -1 to ignore |||",void,1,"This class represents a popup window that can be used to display an
 arbitrary view. The popup window is a floating container that appears on top
 of the current activity.
  Animation 
 On all versions of Android popup window enter and exit animations may be
 specified by calling  setAnimationStyle(int)  and passing the
 resource ID for an animation style that defines  windowEnterAnimation 
 and  windowExitAnimation . For example passing
  R.style.Animation_Dialog  will give a scale and alpha
 animation.
 
 A window animation style may also be specified in the popup window's style
 XML via the  popupAnimationStyle 
 attribute.
  
 Starting with API 23 more complex popup window enter and exit transitions
 may be specified by calling either  setEnterTransition(android.transition.Transition) 
 or  setExitTransition(android.transition.Transition)  and passing a   Transition .
 
 Popup enter and exit transitions may also be specified in the popup window's
 style XML via the  popupEnterTransition 
 and  popupExitTransition 
 attributes respectively.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",uncategorized,UI,1,no,yes,no,SINK,
<android.app.ActivityOptions: void update(ActivityOptions)>,"Update the current values in this ActivityOptions from those supplied
 in otherOptions .  Any values
 defined in otherOptions replace those in the base options.",otherOptions ActivityOptions |||,void,16,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
<android.view.textservice.SpellCheckerSession: void close()>,"Finish this session and allow TextServicesManagerService to disconnect the bound spell
 checker.",,void,14,"The SpellCheckerSession interface provides the per client functionality of SpellCheckerService.


  Applications In most cases applications that are using the standard
  TextView  or its subclasses will have little they need
 to do to work well with spell checker services.  The main things you need to
 be aware of are:  Properly set the  R.attr.inputType  in your editable
 text views so that the spell checker will have enough context to help the
 user in editing text in them.
  For the rare people amongst us writing client applications that use the spell checker service
 directly you will need to use  getSuggestions(android.view.textservice.TextInfo int)  or
  getSuggestions(android.view.textservice.TextInfo[] int boolean)  for obtaining results from the spell checker
 service by yourself. Security There are a lot of security issues associated with spell checkers
 since they could monitor all the text being sent to them
 through for instance  TextView .
 The Android spell checker framework also allows
 arbitrary third party spell checkers so care must be taken to restrict their
 selection and interactions. Here are some key points about the security architecture behind the
 spell checker framework: Only the system is allowed to directly access a spell checker framework's
  SpellCheckerService  interface via the
  Manifest.permission.BIND_TEXT_SERVICE  permission.  This is
 enforced in the system by not binding to a spell checker service that does
 not require this permission.

  The user must explicitly enable a new spell checker in settings before
 they can be enabled to confirm with the system that they know about it
 and want to make it available for use.",,no,no,0,no,no,no,no,
"<android.content.ContentResolver: String getStreamTypes(Uri,String)>","Query for the possible MIME types for the representations the given
 content URL can be returned when opened as as stream with openTypedAssetFileDescriptor(Uri String Bundle) .  Note that the types here are
 not necessarily a superset of the type returned by getType(Uri) --
 many content providers cannot return a raw stream for the structured
 data that they contain.","url Uri : A Uri identifying content (either a list or specific type)
using the content:// scheme.
This value must never be null . |||
mimeTypeFilter String : The desired MIME type.  This may be a pattern
such as */* to query for all available MIME types that match the
pattern.
This value must never be null . |||","String[] Returns an array of MIME type strings for all available
 data streams that match the given mimeTypeFilter.  If there are none
 null is returned. |||",11,This class provides applications access to the content model.,"Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",database metadata,database,1,yes,no,SOURCE,no,
"<android.test.InstrumentationTestSuite: void runTest(Test,TestResult)>",,"test Test |||
result TestResult |||",void,1,"A  TestSuite  that injects  Instrumentation  into
  InstrumentationTestCase  before running them.",,no,no,0,no,no,no,no,
"<android.accounts.AccountManager: AccountManagerFuture addAccount(String,String,String,Bundle,Activity,AccountManagerCallback,Handler)>","Asks the user to add an account of a specified type.  The authenticator
 for this account type processes this request with the appropriate user
 interface.  If the user does elect to create a new account the account
 name is returned. This method may be called from any thread but the returned AccountManagerFuture must not be used on the main thread. NOTE: If targeting your app to work on API level 22 and before
 MANAGE_ACCOUNTS permission is needed for those platforms. See docs for
 this function in API level 22. Requires android.Manifest.permission.MANAGE_ACCOUNTS","accountType String : The type of account to add; must not be null |||
authTokenType String : The type of auth token (see getAuthToken(Account String Bundle Activity AccountManagerCallback Handler) )
this account will need to be able to generate null for none |||
requiredFeatures String : The features (see hasFeatures(Account String[] AccountManagerCallback Handler) ) this
account must have null for none |||
addAccountOptions Bundle : Authenticator-specific options for the request
may be null or empty |||
activity Activity : The Activity context to use for launching a new
authenticator-defined sub-Activity to prompt the user to create an
account; used only to call startActivity(); if null the prompt
will not be launched directly but the necessary Intent will be returned to the caller instead |||
callback AccountManagerCallback : Callback to invoke when the request completes
null for no callback |||
handler Handler : Handler identifying the callback thread
null for the main thread |||","AccountManagerFuture < Bundle > An AccountManagerFuture which resolves to a Bundle with
     these fields if activity was specified and an account was created: KEY_ACCOUNT_NAME - the name of the account created KEY_ACCOUNT_TYPE - the type of the account If no activity was specified the returned Bundle contains only KEY_INTENT with the Intent needed to launch the
 actual account creation process.  If an error occurred AccountManagerFuture#getResult() throws: AuthenticatorException if no authenticator was registered for
      this account type or the authenticator failed to respond OperationCanceledException if the operation was canceled for
      any reason including the user canceling the creation process or adding accounts
      (of this type) has been disabled by policy IOException if the authenticator experienced an I/O problem
      creating a new account usually because of network trouble |||",5,"This class provides access to a centralized registry of the user's
 online accounts.  The user enters credentials (username and password) once
 per account granting applications access to online resources with
 ""one-click"" approval.

  Different online services have different ways of handling accounts and
 authentication so the account manager uses pluggable  authenticator 
 modules for different  account types .  Authenticators (which may be
 written by third parties) handle the actual details of validating account
 credentials and storing account information.  For example Google Facebook
 and Microsoft Exchange each have their own authenticator.

  Many servers support some notion of an  authentication token 
 which can be used to authenticate a request to the server without sending
 the user's actual password.  (Auth tokens are normally created with a
 separate request which does include the user's credentials.)  AccountManager
 can generate auth tokens for applications so the application doesn't need to
 handle passwords directly.  Auth tokens are normally reusable and cached by
 AccountManager but must be refreshed periodically.  It's the responsibility
 of applications to  invalidate  auth tokens when they stop working so
 the AccountManager knows it needs to regenerate them.

  Applications accessing a server normally go through these steps:

  Get an instance of AccountManager using  get(android.content.Context) .

  List the available accounts using  getAccountsByType(String)  or
  getAccountsByTypeAndFeatures(String String[] AccountManagerCallback  Handler) .  Normally applications will only
 be interested in accounts with one particular  type  which
 identifies the authenticator.  Account  features  are used to
 identify particular account subtypes and capabilities.  Both the account
 type and features are authenticator-specific strings and must be known by
 the application in coordination with its preferred authenticators.

  Select one or more of the available accounts possibly by asking the
 user for their preference.  If no suitable accounts are available
  addAccount(String String String[] Bundle Activity AccountManagerCallback  Handler)  may be called to prompt the user to create an
 account of the appropriate type.

  Important:  If the application is using a previously remembered
 account selection it must make sure the account is still in the list
 of accounts returned by  getAccountsByType(String) .  Requesting an auth token
 for an account no longer on the device results in an undefined failure.

  Request an auth token for the selected account(s) using one of the
  getAuthToken(Account String Bundle Activity AccountManagerCallback  Handler)  methods or related helpers.  Refer to the description
 of each method for exact usage and error handling details.

  Make the request using the auth token.  The form of the auth token
 the format of the request and the protocol used are all specific to the
 service you are accessing.  The application may use whatever network and
 protocol libraries are useful.

  Important:  If the request fails with an authentication error
 it could be that a cached auth token is stale and no longer honored by
 the server.  The application must call  invalidateAuthToken(String String)  to remove
 the token from the cache otherwise requests will continue failing!  After
 invalidating the auth token immediately go back to the ""Request an auth
 token"" step above.  If the process fails the second time then it can be
 treated as a ""genuine"" authentication failure and the user notified or other
 appropriate actions taken.
  Some AccountManager methods may need to interact with the user to
 prompt for credentials present options or ask the user to add an account.
 The caller may choose whether to allow AccountManager to directly launch the
 necessary user interface and wait for the user or to return an Intent which
 the caller may use to launch the interface or (in some cases) to install a
 notification which the user can select at any time to launch the interface.
 To have AccountManager launch the interface directly the caller must supply
 the current foreground  Activity  context.

  Many AccountManager methods take  AccountManagerCallback  and
  Handler  as parameters.  These methods return immediately and
 run asynchronously. If a callback is provided then
  AccountManagerCallback#run  will be invoked on the Handler's
 thread when the request completes successfully or not.
 The result is retrieved by calling  AccountManagerFuture#getResult() 
 on the  AccountManagerFuture  returned by the method (and also passed
 to the callback).  This method waits for the operation to complete (if
 necessary) and either returns the result or throws an exception if an error
 occurred during the operation.  To make the request synchronously call
  AccountManagerFuture#getResult()  immediately on receiving the
 future from the method; no callback need be supplied.

  Requests which may block including
  AccountManagerFuture#getResult()  must never be called on
 the application's main event thread.  These operations throw
  IllegalStateException  if they are used on the main thread.",,no,account info storage file,0,no,no,no,no,
"<android.text.Selection: void extendSelection(Spannable,int)>",Move the selection edge to offset index .,"text Spannable |||
index int |||",void,1,"Utility class for manipulating cursors and selections in CharSequences.
 A cursor is a selection where the start and end are at the same offset.","Provides classes used to render or track text and text spans on the screen. You can use these classes to design your own widgets that manage text
 to handle arbitrary text spans for changes or to handle drawing yourself
 for an existing widget. The Span… interfaces and classes are used to create or manage spans of
 text in a View item. You can use these to style the text or background or to
 listen for changes. If creating your own widget extend DynamicLayout to manages
 the actual wrapping and drawing of your text.",no,UI,0,no,no,no,no,
<android.app.DatePickerDialog: void onRestoreInstanceState(Bundle)>,"Restore the state of the dialog from a previously saved bundle.

 The default implementation restores the state of the dialog's view
 hierarchy that was saved in the default implementation of onSaveInstanceState() so be sure to call through to super when overriding unless you want to
 do all restoring of state yourself.","savedInstanceState Bundle : The state of the dialog previously saved by onSaveInstanceState() .
This value must never be null . |||",void,1,"A simple dialog containing an  DatePicker .
  
 See the  Pickers 
 guide.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
<android.os.Bundle: Parcelable getParcelableArray(String)>,"Returns the value associated with the given key or null if
 no mapping of the desired type exists for the given key or a null
 value is explicitly associated with the key. Note: if the expected value is not a class provided by the Android platform
 you must call setClassLoader(java.lang.ClassLoader) with the proper ClassLoader first.
 Otherwise this method might throw an exception or return null .",key String : a String or null This value may be null . |||,Parcelable[] a Parcelable[] value or null |||,1,A mapping from String keys to various  Parcelable  values.,,IPC,no,0,no,no,no,no,
"<android.content.ContentResolver: ContentProviderResult applyBatch(String,ArrayList)>","Applies each of the ContentProviderOperation objects and returns an array
 of their results. Passes through OperationApplicationException which may be thrown
 by the call to ContentProviderOperation#apply .
 If all the applications succeed then a ContentProviderResult array with the
 same number of elements as the operations will be returned. It is implementation-specific
 how many if any operations will have been successfully applied if a call to
 apply results in a OperationApplicationException .","authority String : the authority of the ContentProvider to which this batch should be applied
This value must never be null . |||
operations ArrayList : the operations to apply
This value must never be null . |||","ContentProviderResult[] the results of the applications
 This value will never be null . |||",5,This class provides applications access to the content model.,"Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",database data,database,1,yes,no,SOURCE,no,
<android.content.Context: CharSequence getText(int)>,"Return a localized styled CharSequence from the application's package's
 default string table.",resId int : Resource id for the CharSequence text |||,CharSequence This value will never be null . |||,1,"Interface to global information about an application environment.  This is
 an abstract class whose implementation is provided by
 the Android system.  It
 allows access to application-specific resources and classes as well as
 up-calls for application-level operations such as launching activities
 broadcasting and receiving intents etc.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,
<android.app.Fragment: String getString(int)>,"Return a localized string from the application's package's
 default string table.",resId int : Resource id for the string |||,String |||,11,"A Fragment is a piece of an application's user interface or behavior
 that can be placed in an  Activity .  Interaction with fragments
 is done through  FragmentManager  which can be obtained via
  Activity#getFragmentManager()  and
  Fragment#getFragmentManager() .

  The Fragment class can be used many ways to achieve a wide variety of
 results. In its core it represents a particular operation or interface
 that is running within a larger  Activity .  A Fragment is closely
 tied to the Activity it is in and can not be used apart from one.  Though
 Fragment defines its own lifecycle that lifecycle is dependent on its
 activity: if the activity is stopped no fragments inside of it can be
 started; when the activity is destroyed all fragments will be destroyed.

  All subclasses of Fragment must include a public no-argument constructor.
 The framework will often re-instantiate a fragment class when needed
 in particular during state restore and needs to be able to find this
 constructor to instantiate it.  If the no-argument constructor is not
 available a runtime exception will occur in some cases during state
 restore.

  Topics covered here:
  Older Platforms Lifecycle Layout Back Stack","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
"<android.content.Intent: Intent putExtra(String,byte)>","Add extended data to the intent.  The name must include a package
 prefix for example the app com.android.contacts would use names
 like ""com.android.contacts.ShowAll"".","name String : The name of the extra data with package prefix. |||
value byte : The byte array data value.
This value may be null . |||","Intent Returns the same Intent object for chaining multiple calls
 into a single statement.

 This value will never be null . |||",1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,
"<android.content.ContentResolver: void requestSync(Account,String,Bundle)>","Start an asynchronous sync operation. If you want to monitor the progress
 of the sync you may register a SyncObserver. Only values of the following
 types may be used in the extras bundle: Integer 
Long 
Boolean 
Float 
Double 
String 
Account 
null","account Account : which account should be synced |||
authority String : which authority should be synced |||
extras Bundle : any extras to pass to the SyncAdapter. |||",void,5,This class provides applications access to the content model.,"Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,database,0,no,no,no,no,
"<android.webkit.WebViewClient: void onUnhandledKeyEvent(WebView,KeyEvent)>","Notify the host application that a key was not handled by the WebView.
 Except system keys WebView always consumes the keys in the normal flow
 or if shouldOverrideKeyEvent(WebView KeyEvent) returns true . This is called asynchronously
 from where the key is dispatched. It gives the host application a chance
 to handle the unhandled key events.","view WebView : The WebView that is initiating the callback. |||
event KeyEvent : The key event. |||",void,1,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",no,no,0,no,no,no,no,
"<android.media.MediaPlayer: void addTimedTextSource(Context,Uri,String)>","Adds an external timed text source file (Uri).

 Currently supported format is SubRip with the file extension .srt case insensitive.
 Note that a single external timed text source may contain multiple tracks in it.
 One can find the total number of available tracks using getTrackInfo() to see what
 additional tracks become available after this method call.","context Context : the Context to use when resolving the Uri |||
uri Uri : the Content URI of the data you want to play |||
mimeType String : The mime type of the file. Must be one of the mime types listed above. |||",void,16,"MediaPlayer class can be used to control playback
 of audio/video files and streams. An example on how to use the methods in
 this class can be found in  VideoView .

  Topics covered here are:
  State Diagram Valid and Invalid States Permissions Register informational and error callbacks","The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",no,media,0,no,no,no,no,
"<android.widget.SimpleAdapter: View getDropDownView(int,View,ViewGroup)>","Gets a View that displays in the drop down popup
 the data at the specified position in the data set.","position int : index of the item whose view we want. |||
convertView View : the old view to reuse if possible. Note: You should
check that this view is non-null and of an appropriate type before
using. If it is not possible to convert this view to display the
correct data this method can create a new view. |||
parent ViewGroup : the parent that this view will eventually be attached to |||","View a View corresponding to the data at the
         specified position. |||",1,"An easy adapter to map static data to views defined in an XML file. You can specify the data
 backing the list as an ArrayList of Maps. Each entry in the ArrayList corresponds to one row
 in the list. The Maps contain the data for each row. You also specify an XML file that
 defines the views used to display the row and a mapping from keys in the Map to specific
 views.

 Binding data to views occurs in two phases. First if a
  SimpleAdapter.ViewBinder  is available
  ViewBinder#setViewValue(android.view.View Object String) 
 is invoked. If the returned value is true binding has occurred.
 If the returned value is false the following views are then tried in order:
   A view that implements Checkable (e.g. CheckBox).  The expected bind value is a boolean.
   TextView.  The expected bind value is a string and  setViewText(android.widget.TextView java.lang.String) 
 is invoked.
   ImageView. The expected bind value is a resource id or a string and
  setViewImage(android.widget.ImageView int)  or  setViewImage(android.widget.ImageView java.lang.String)  is invoked.
  IllegalStateException","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",uncategorized,UI,1,no,no,no,no,
<android.content.res.Resources: CharSequence getTextArray(int)>,Return the styled text array associated with a particular resource ID.,"id int : The desired resource identifier as generated by the aapt
tool. This integer encodes the package type and resource
entry. The value 0 is an invalid identifier. |||","CharSequence[] The styled text array associated with the resource.
 
 This value will never be null . |||",1,"Class for accessing an application's resources.  This sits on top of the
 asset manager of the application (accessible through  getAssets() ) and
 provides a high-level API for getting typed data from the assets.

  The Android resource system keeps track of all non-code assets associated with an
 application. You can use this class to access your application's resources. You can generally
 acquire the  Resources  instance associated with your application
 with  getResources() . The Android SDK tools compile your application's resources into the application binary
 at build time.  To use a resource you must install it correctly in the source tree (inside
 your project's  res/  directory) and build your application.  As part of the build
 process the SDK tools generate symbols for each resource which you can use in your application
 code to access the resources. Using application resources makes it easy to update various characteristics of your
 application without modifying code and—by providing sets of alternative
 resources—enables you to optimize your application for a variety of device configurations
 (such as for different languages and screen sizes). This is an important aspect of developing
 Android applications that are compatible on different types of devices. For more information about using resources see the documentation about  Application Resources .","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,
<android.preference.Preference: void setIcon(int)>,Sets the icon for this Preference with a resource ID.,iconResId int : the icon as a resource ID |||,void,11,"Represents the basic Preference UI building
 block displayed by a  PreferenceActivity  in the form of a
  ListView . This class provides the  View  to be displayed in
 the activity and associates with a  SharedPreferences  to
 store/retrieve the preference data.
  
 When specifying a preference hierarchy in XML each element can point to a
 subclass of  Preference  similar to the view hierarchy and layouts.
  
 This class contains a  key  that will be used as the key into the
  SharedPreferences . It is up to the subclass to decide how to store
 the value.",,no,no,0,no,no,no,no,
<android.widget.ImageView: void setImageURI(Uri)>,"Sets the content of this ImageView to the specified Uri.
 Note that you use this method to load images from a local Uri only. This does Bitmap reading and decoding on the UI
 thread which can cause a latency hiccup.  If that's a concern
 consider using setImageDrawable(android.graphics.drawable.Drawable) or setImageBitmap(android.graphics.Bitmap) and BitmapFactory instead. On devices running SDK < 24 this method will fail to
 apply correct density scaling to images loaded from ContentResolver#SCHEME_CONTENT and ContentResolver#SCHEME_FILE schemes. Applications running
 on devices with SDK >= 24 MUST specify the targetSdkVersion in their manifest as 24 or above for density
 scaling to be applied to images loaded from these schemes.","uri Uri : the Uri of an image or null to clear the content
This value may be null . |||",void,1,"Displays image resources for example  Bitmap 
 or  Drawable  resources.
 ImageView is also commonly used to
  apply tints to an image  and
 handle  image scaling .

  
 The following XML snippet is a common example of using an ImageView to display an image resource:
  
 <LinearLayout
     xmlns:android=""http://schemas.android.com/apk/res/android""
     android:layout_width=""match_parent""
     android:layout_height=""match_parent"">
     <ImageView
         android:layout_width=""wrap_content""
         android:layout_height=""wrap_content""
         android:src=""@drawable/my_image""
         android:contentDescription=""@string/my_image_description""
         />
 </LinearLayout>
  
 To learn more about Drawables see:  Drawable Resources .
 To learn more about working with Bitmaps see:  Handling Bitmaps .","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",image,UI,1,no,yes,no,SINK,
<android.content.pm.PermissionInfo: CharSequence loadDescription(PackageManager)>,"Retrieve the textual description of this permission.  This
 will call back on the given PackageManager to load the description from
 the application.","pm PackageManager : A PackageManager from which the label can be loaded; usually
the PackageManager from which you originally retrieved this item.
This value must never be null . |||","CharSequence Returns a CharSequence containing the permission's description.
 If there is no description null is returned. |||",1,"Information you can retrieve about a particular security permission
 known to the system.  This corresponds to information collected from the
 AndroidManifest.xml's <permission> tags.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,
<android.nfc.tech.NfcB: void close()>,"Disable I/O operations to the tag from this TagTechnology object and release resources. Also causes all blocked I/O operations on other thread to be canceled and
 return with IOException . Requires the Manifest.permission.NFC permission.",,void,-1,"Provides access to NFC-B (ISO 14443-3B) properties and I/O operations on a  Tag .

  Acquire a  NfcB  object using  get(Tag) .
  The primary NFC-B I/O operation is  transceive(byte[]) . Applications must
 implement their own protocol stack on top of  transceive(byte[]) .

  Note:  Methods that perform I/O operations
 require the  Manifest.permission.NFC  permission.","These classes provide access to a tag technology's features which vary by the type
 of tag that is scanned. A scanned tag can support multiple technologies and you can find
 out what they are by calling  getTechList() . For more information on dealing with tag technologies and handling the ones that you care about see
  The Tag Dispatch System .
 The  TagTechnology  interface provides an overview of the
 supported technologies.",no,no,0,no,no,no,no,
"<android.content.ContentProviderClient: AssetFileDescriptor openTypedAssetFileDescriptor(Uri,String,Bundle)>",See ContentProvider#openTypedAssetFile,"uri Uri : This value must never be null . |||
mimeType String : This value must never be null . |||
opts Bundle : This value may be null . |||",AssetFileDescriptor This value may be null . |||,11,"Content providers are one of the primary building blocks of Android applications providing
 content to applications. They encapsulate data and provide it to applications through the single
  ContentResolver  interface. A content provider is only required if you need to share
 data between multiple applications. For example the contacts data is used by multiple
 applications and must be stored in a content provider. If you don't need to share data amongst
 multiple applications you can use a database directly via
  SQLiteDatabase .

  When a request is made via
 a  ContentResolver  the system inspects the authority of the given URI and passes the
 request to the content provider registered with the authority. The content provider can interpret
 the rest of the URI however it wants. The  UriMatcher  class is helpful for parsing
 URIs. The primary methods that need to be implemented are:
  onCreate()  which is called to initialize the provider query(Uri String[] Bundle CancellationSignal)  which returns data to the caller insert(Uri ContentValues)  which inserts new data into the content provider update(Uri ContentValues String String[])  which updates existing data in the content provider delete(Uri String String[])  which deletes data from the content provider getType(Uri)  which returns the MIME type of data in the content provider Requests to  ContentResolver  are automatically forwarded to the appropriate
 ContentProvider instance so subclasses don't have to worry about the details of
 cross-process calls.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",database metadata,database,1,yes,no,SOURCE,no,
<android.widget.ProgressBar: void incrementProgressBy(int)>,Increase the progress bar's progress by the specified amount.,diff int : the amount by which the progress must be increased |||,void,1,"A user interface element that indicates the progress of an operation.
 Progress bar supports two modes to represent progress: determinate and indeterminate. For
 a visual overview of the difference between determinate and indeterminate progress modes see
  
 Progress & activity .
 Display progress bars to a user in a non-interruptive way.
 Show the progress bar in your app's user interface or in a notification
 instead of within a dialog.
  Indeterminate Progress 
 Use indeterminate mode for the progress bar when you do not know how long an
 operation will take.
 Indeterminate mode is the default for progress bar and shows a cyclic animation without a
 specific amount of progress indicated.
 The following example shows an indeterminate progress bar:
  
 <ProgressBar
      android:id=""@+id/indeterminateBar""
      android:layout_width=""wrap_content""
      android:layout_height=""wrap_content""
      />
  Determinate Progress 
 Use determinate mode for the progress bar when you want to show that a specific quantity of
 progress has occurred.
 For example the percent remaining of a file being retrieved the amount records in
 a batch written to database or the percent remaining of an audio file that is playing.
  
 To indicate determinate progress you set the style of the progress bar to
  R.style.Widget_ProgressBar_Horizontal  and set the amount of progress.
 The following example shows a determinate progress bar that is 25% complete:
  
 <ProgressBar
      android:id=""@+id/determinateBar""
      style=""@android:style/Widget.ProgressBar.Horizontal""
      android:layout_width=""wrap_content""
      android:layout_height=""wrap_content""
      android:progress=""25""/>
  setProgress(int) incrementProgressBy(int) android:max Other progress bar styles provided by the system include: Widget.ProgressBar.Horizontal Widget.ProgressBar.Small Widget.ProgressBar.Large Widget.ProgressBar.Inverse Widget.ProgressBar.Small.Inverse Widget.ProgressBar.Large.Inverse The ""inverse"" styles provide an inverse color scheme for the spinner which may be necessary
 if your application uses a light colored theme (a white background). XML attributes 
 See  ProgressBar Attributes 
  View Attributes","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,UI,0,no,no,no,no,
"<android.content.SearchRecentSuggestionsProvider: Uri insert(Uri,ContentValues)>","This method is provided for use by the ContentResolver.  Do not override or directly
 call from your own code.","uri Uri : The content:// URI of the insertion request.
This value must never be null . |||
values ContentValues : A set of column_name/value pairs to add to the database.
This value may be null . |||","Uri The URI for the newly inserted item.
 
 This value may be null . |||",1,"This superclass can be used to create a simple search suggestions provider for your application.
 It creates suggestions (as the user types) based on recent queries and/or recent views.

  In order to use this class you must do the following.

  Implement and test query search as described in  SearchManager .  (This
 provider will send any suggested queries via the standard
  ACTION_SEARCH  Intent which you'll already
 support once you have implemented and tested basic searchability.) Create a Content Provider within your application by extending
  SearchRecentSuggestionsProvider .  The class you create will be
 very simple - typically it will have only a constructor.  But the constructor has a very
 important responsibility:  When it calls  setupSuggestions(java.lang.String int)  it
  configures  the provider to match the requirements of your searchable activity. Create a manifest entry describing your provider.  Typically this would be as simple
 as adding the following lines:
  
     <!-- Content provider for search suggestions -->
     <provider android:name=""YourSuggestionProviderClass""
               android:authorities=""your.suggestion.authority"" /> Please note that you  do not  instantiate this content provider directly from within
 your code.  This is done automatically by the system Content Resolver when the search dialog
 looks for suggestions. In order for the Content Resolver to do this you must update your searchable activity's
 XML configuration file with information about your content provider.  The following additions
 are usually sufficient:
  
     android:searchSuggestAuthority=""your.suggestion.authority""
     android:searchSuggestSelection="" ? "" In your searchable activities capture any user-generated queries and record them
 for future searches by calling  SearchRecentSuggestions.saveRecentQuery() .","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,
<android.telephony.TelephonyManager: CellLocation getCellLocation()>,"This method was deprecated
      in API level 26. use getAllCellInfo() instead which returns a superset of this API. Returns the current location of the device. If there is only one radio in the device and that radio has an LTE connection
 this method will return null. The implementation must not to try add LTE
 identifiers into the existing cdma/gsm classes. Requires Manifest.permission.ACCESS_FINE_LOCATION",,CellLocation Current location of the device or null if not available. |||,1,"Provides access to information about the telephony services on
 the device. Applications can use the methods in this class to
 determine telephony services and states as well as to access some
 types of subscriber information. Applications can also register
 a listener to receive notification of telephony state changes.
  
 The returned TelephonyManager will use the default subscription for all calls.
 To call an API for a specific subscription use  createForSubscriptionId(int) . e.g.
  
   telephonyManager = defaultSubTelephonyManager.createForSubscriptionId(subId);
  
 Note that access to some telephony information is
 permission-protected. Your application cannot access the protected
 information unless it has the appropriate permissions declared in
 its manifest file. Where permissions apply they are noted in the
 the methods through which you access the protected information.",,location,sensors,1,yes,no,SOURCE,no,
<android.nfc.tech.Ndef: void connect()>,"Enable I/O operations to the tag from this TagTechnology object. May cause RF activity and may block. Must not be called
 from the main application thread. A blocked call will be canceled with IOException by calling close() from another thread. Only one TagTechnology object can be connected to a Tag at a time. Applications must call close() when I/O operations are complete. Requires the Manifest.permission.NFC permission.",,void,-1,"Provides access to NDEF content and operations on a  Tag .

  Acquire a  Ndef  object using  get(Tag) .

  NDEF is an NFC Forum data format. The data formats are implemented in
  NdefMessage  and
  NdefRecord . This class provides methods to
 retrieve and modify the  NdefMessage 
 on a tag.

  There are currently four NFC Forum standardized tag types that can be
 formatted to contain NDEF data.
  NFC Forum Type 1 Tag ( NFC_FORUM_TYPE_1 ) such as the Innovision Topaz
  NFC Forum Type 2 Tag ( NFC_FORUM_TYPE_2 ) such as the NXP MIFARE Ultralight
  NFC Forum Type 3 Tag ( NFC_FORUM_TYPE_3 ) such as Sony Felica
  NFC Forum Type 4 Tag ( NFC_FORUM_TYPE_4 ) such as NXP MIFARE Desfire
  Ndef Some vendors have their own well defined specifications for storing NDEF data
 on tags that do not fall into the above categories. Android devices with NFC
 should enumerate and implement  Ndef  under these vendor specifications
 where possible but it is not mandatory.  getType()  returns a String
 describing this specification for example  MIFARE_CLASSIC  is
  com.nxp.ndef.mifareclassic .

  Android devices that support MIFARE Classic must also correctly
 implement  Ndef  on MIFARE Classic tags formatted to NDEF.

  For guaranteed compatibility across all Android devices with NFC it is
 recommended to use NFC Forum Types 1-4 in new deployments of NFC tags
 with NDEF payload. Vendor NDEF formats will not work on all Android devices.

  Note:  Methods that perform I/O operations
 require the  Manifest.permission.NFC  permission.","These classes provide access to a tag technology's features which vary by the type
 of tag that is scanned. A scanned tag can support multiple technologies and you can find
 out what they are by calling  getTechList() . For more information on dealing with tag technologies and handling the ones that you care about see
  The Tag Dispatch System .
 The  TagTechnology  interface provides an overview of the
 supported technologies.",no,nfc,0,no,no,no,no,
<android.media.Ringtone: void setStreamType(int)>,"This method was deprecated
      in API level 21. use setAudioAttributes(android.media.AudioAttributes) Sets the stream type where this ringtone will be played.",streamType int : The stream see AudioManager . |||,void,1,"Ringtone provides a quick method for playing a ringtone notification or
 other similar types of sounds.
  
 For ways of retrieving  Ringtone  objects or to show a ringtone
 picker see  RingtoneManager .","The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",no,no,0,no,no,no,no,
"<android.net.wifi.p2p.WifiP2pDeviceList: void writeToParcel(Parcel,int)>",Implement the Parcelable interface,"dest Parcel : The Parcel in which the object should be written. |||
flags int : Additional flags about how the object should be written.
May be 0 or Parcelable.PARCELABLE_WRITE_RETURN_VALUE .
Value is either 0 or a combination of Parcelable.PARCELABLE_WRITE_RETURN_VALUE and android.os.Parcelable.PARCELABLE_ELIDE_DUPLICATES |||",void,14,"A class representing a Wi-Fi P2p device list.

 Note that the operations are not thread safe.","Provides classes to create peer-to-peer (P2P) connections with Wi-Fi Direct. Using these APIs you can discover and connect to other devices when each
 device supports Wi-Fi Direct then communicate over a speedy connection across distances much longer
 than a Bluetooth connection. The primary class you need to work with is  WifiP2pManager  which you can acquire by calling  getSystemService(WIFI_P2P_SERVICE) . The  WifiP2pManager  includes APIs that allow you to: Initialize your application for P2P connections by calling  initialize() Discover nearby devices by calling  discoverPeers() Start a P2P connection by calling  connect() And more Several other interfaces and classes are necessary as well such as: The  WifiP2pManager.ActionListener  interface allows you to receive
 callbacks when an operation such as discovering peers or connecting to them succeeds or fails. WifiP2pManager.PeerListListener  interface allows you to receive
 information about discovered peers. The callback provides a  WifiP2pDeviceList  from which you can retrieve a  WifiP2pDevice  object for each device within range and get information such as
 the device name address device type the WPS configurations the device supports and more. The  WifiP2pManager.GroupInfoListener  interface allows you to
 receive information about a P2P group. The callback provides a  WifiP2pGroup  object which provides group information such as the owner the
 network name and passphrase. WifiP2pManager.ConnectionInfoListener  interface allows you to
 receive information about the current connection. The callback provides a  WifiP2pInfo  object which has information such as whether a group has been
 formed and who is the group owner. In order to use the Wi-Fi P2P APIs your app must request the following user permissions: ACCESS_WIFI_STATE CHANGE_WIFI_STATE INTERNET  (although your app doesn’t technically connect
 to the Internet communicating to Wi-Fi Direct peers with standard java sockets requires Internet
 permission). For example code see the  Wi-Fi
 Direct Demo  sample application. Note:  Not all Android-powered devices support Wi-Fi
 Direct. If your application uses Wi-Fi Direct declare so with a  <uses-feature> 
 element in the manifest file: 
 <manifest ...>
     <uses-feature android:name=""android.hardware.wifi.direct"" />
     ...
 </manifest>",no,no,0,no,no,no,no,
<android.webkit.WebView: void freeMemory()>,"This method was deprecated
      in API level 19. Memory caches are automatically dropped when no longer needed and in response
             to system memory pressure. Informs this WebView that memory is low so that it can free any available
 memory.",,void,7,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",no,no,0,no,no,no,no,
<android.app.Instrumentation: void callActivityOnStop(Activity)>,Perform calling of an activity's Activity#onStop method.  The default implementation simply calls through to that method.,activity Activity : The activity being stopped. |||,void,1,"Base class for implementing application instrumentation code.  When running
 with instrumentation turned on this class will be instantiated for you
 before any of the application code allowing you to monitor all of the
 interaction the system has with the application.  An Instrumentation
 implementation is described to the system through an AndroidManifest.xml's
 <instrumentation> tag.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
"<android.content.pm.PermissionInfo: void writeToParcel(Parcel,int)>",,"dest Parcel |||
parcelableFlags int |||",void,1,"Information you can retrieve about a particular security permission
 known to the system.  This corresponds to information collected from the
 AndroidManifest.xml's <permission> tags.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,
"<android.content.Intent: Intent putExtra(String,short)>","Add extended data to the intent.  The name must include a package
 prefix for example the app com.android.contacts would use names
 like ""com.android.contacts.ShowAll"".","name String : The name of the extra data with package prefix. |||
value short : The short data value. |||","Intent Returns the same Intent object for chaining multiple calls
 into a single statement.

 This value will never be null . |||",1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,
<android.database.sqlite.SQLiteDatabase: List getAttachedDbs()>,"Returns list of full pathnames of all attached databases including the main database
 by executing 'pragma database_list' on the database.",,"List < Pair < String  String >> ArrayList of pairs of (database name database file path) or null if the database
 is not open. |||",11,"Exposes methods to manage a SQLite database.

  
 SQLiteDatabase has methods to create delete execute SQL commands and
 perform other common database management tasks.
  
 See the Notepad sample application in the SDK for an example of creating
 and managing a database.
  
 Database names must be unique within an application not across all applications.
  Localized Collation - ORDER BY 
 In addition to SQLite's default  BINARY  collator Android supplies
 two more  LOCALIZED  which changes with the system's current locale
 and  UNICODE  which is the Unicode Collation Algorithm and not tailored
 to the current locale.","If you need to manage data in a private database use the  android.database.sqlite  classes. These classes are used to manage the  Cursor  object returned from a content provider query. Databases
 are usually created and opened with  openOrCreateDatabase(String int SQLiteDatabase.CursorFactory) 
 To make requests through
 content providers you can use the  content.ContentResolver  class.
  All databases are stored on the device in  /data/data/<package_name>/databases",database metadata,database,1,yes,no,SOURCE,no,
"<android.content.ContextWrapper: void sendOrderedBroadcast(Intent,String,BroadcastReceiver,Handler,int,String,Bundle)>","Version of sendBroadcast(android.content.Intent) that allows you to
 receive data back from the broadcast.  This is accomplished by
 supplying your own BroadcastReceiver when calling which will be
 treated as a final receiver at the end of the broadcast -- its BroadcastReceiver#onReceive method will be called with
 the result values collected from the other receivers.  The broadcast will
 be serialized in the same way as calling sendOrderedBroadcast(android.content.Intent java.lang.String) . Like sendBroadcast(android.content.Intent) this method is
 asynchronous; it will return before
 resultReceiver.onReceive() is called. See BroadcastReceiver for more information on Intent broadcasts.","intent Intent : The Intent to broadcast; all receivers matching this
Intent will receive the broadcast.
This value must never be null . |||
receiverPermission String : String naming a permissions that
a receiver must hold in order to receive your broadcast.
If null no permission is required.
This value may be null . |||
resultReceiver BroadcastReceiver : Your own BroadcastReceiver to treat as the final
receiver of the broadcast.
This value may be null . |||
scheduler Handler : A custom Handler with which to schedule the
resultReceiver callback; if null it will be
scheduled in the Context's main thread.
This value may be null . |||
initialCode int : An initial value for the result code.  Often
Activity.RESULT_OK. |||
initialData String : An initial value for the result data.  Often
null.
This value may be null . |||
initialExtras Bundle : An initial value for the result extras.  Often
null.
This value may be null . |||",void,1,"Proxying implementation of Context that simply delegates all of its calls to
 another Context.  Can be subclassed to modify behavior without changing
 the original Context.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",IPC,IPC,1,no,yes,no,SINK,
<android.app.NotificationManager: void cancel(int)>,"Cancels a previously posted notification. If the notification does not currently represent a Service#startForeground(int Notification) it will be
  removed from the UI and live notification listeners will be informed so they can remove the notification from their UIs.",id int |||,void,1,"A class that represents how a persistent notification is to be presented to
 the user using the  NotificationManager .

  The  Notification.Builder  has been added to make it
 easier to construct Notifications.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
"<android.media.AudioManager: void setStreamVolume(int,int,int)>","Sets the volume index for a particular stream. This method has no effect if the device implements a fixed volume policy
 as indicated by isVolumeFixed() . From N onward volume adjustments that would toggle Do Not Disturb are not allowed unless
 the app has been granted Do Not Disturb Access.
 See NotificationManager#isNotificationPolicyAccessGranted() .","streamType int : The stream whose volume index should be set. |||
index int : The volume index to set. See getStreamMaxVolume(int) for the largest valid value. |||
flags int : One or more flags. |||",void,1,AudioManager provides access to volume and ringer mode control.,"The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",no,media,0,no,no,no,no,
<android.widget.BaseAdapter: void notifyDataSetChanged()>,"Notifies the attached observers that the underlying data has been changed
 and any View reflecting the data set should refresh itself.",,void,1,"Common base class of common implementation for an  Adapter  that can be
 used in both  ListView  (by implementing the specialized
  ListAdapter  interface) and  Spinner  (by implementing the
 specialized  SpinnerAdapter  interface).","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,no,0,no,no,no,no,
<android.view.inputmethod.InputMethodManager: void viewClicked(View)>,"This method was deprecated
      in API level 29. The semantics of this method can never be defined well for composite View that works as a giant ""Canvas"" which can host its own UI hierarchy and sub focus
             state. WebView is a good example. Application / IME
             developers should not rely on this method. Notify the event when the user tapped or clicked the text view.",view View : View which is being clicked. |||,void,14,"Central system API to the overall input method framework (IMF) architecture
 which arbitrates interaction between applications and the current input method.

  Topics covered here:
  Architecture Overview Applications Input Methods Security Architecture Overview There are three primary parties involved in the input method
 framework (IMF) architecture:  The  input method manager  as expressed by this class
 is the central point of the system that manages interaction between all
 other parts.  It is expressed as the client-side API here which exists
 in each application context and communicates with a global system service
 that manages the interaction across all processes.
   An  input method (IME)  implements a particular
 interaction model allowing the user to generate text.  The system binds
 to the current input method that is in use causing it to be created and run
 and tells it when to hide and show its UI.  Only one IME is running at a time.
   Multiple  client applications  arbitrate with the input
 method manager for input focus and control over the state of the IME.  Only
 one such client is ever active (working with the IME) at a time.
  Applications In most cases applications that are using the standard
  TextView  or its subclasses will have little they need
 to do to work well with soft input methods.  The main things you need to
 be aware of are:  Properly set the  R.attr.inputType  in your editable
 text views so that the input method will have enough context to help the
 user in entering text into them.
   Deal well with losing screen space when the input method is
 displayed.  Ideally an application should handle its window being resized
 smaller but it can rely on the system performing panning of the window
 if needed.  You should set the  R.attr.windowSoftInputMode 
 attribute on your activity or the corresponding values on windows you
 create to help the system determine whether to pan or resize (it will
 try to determine this automatically but may get it wrong).
   You can also control the preferred soft input state (open closed etc)
 for your window using the same  R.attr.windowSoftInputMode 
 attribute.
  More finer-grained control is available through the APIs here to directly
 interact with the IMF and its IME -- either showing or hiding the input
 area letting the user pick an input method etc. For the rare people amongst us writing their own text editors you
 will need to implement  View.onCreateInputConnection(EditorInfo) 
 to return a new instance of your own  InputConnection  interface
 allowing the IME to interact with your editor. Input Methods An input method (IME) is implemented
 as a  Service  typically deriving from
  InputMethodService .  It must provide
 the core  InputMethod  interface though this is normally handled by
  InputMethodService  and implementors will
 only need to deal with the higher-level API there. InputMethodService Security There are a lot of security issues associated with input methods
 since they essentially have freedom to completely drive the UI and monitor
 everything the user enters.  The Android input method framework also allows
 arbitrary third party IMEs so care must be taken to restrict their
 selection and interactions. Here are some key points about the security architecture behind the
 IMF: Only the system is allowed to directly access an IME's
  InputMethod  interface via the
  Manifest.permission.BIND_INPUT_METHOD  permission.  This is
 enforced in the system by not binding to an input method service that does
 not require this permission so the system can guarantee no other untrusted
 clients are accessing the current input method outside of its control. There may be many client processes of the IMF but only one may
 be active at a time.  The inactive clients can not interact with key
 parts of the IMF through the mechanisms described below. Clients of an input method are only given access to its
  InputMethodSession  interface.  One instance of this interface is
 created for each client and only calls from the session associated with
 the active client will be processed by the current IME.  This is enforced
 by  AbstractInputMethodService  for normal
 IMEs but must be explicitly handled by an IME that is customizing the
 raw  InputMethodSession  implementation. Only the active client's  InputConnection  will accept
 operations.  The IMF tells each client process whether it is active and
 the framework enforces that in inactive processes calls on to the current
 InputConnection will be ignored.  This ensures that the current IME can
 only deliver events and text edits to the UI that the user sees as
 being in focus. An IME can never interact with an  InputConnection  while
 the screen is off.  This is enforced by making all clients inactive while
 the screen is off and prevents bad IMEs from driving the UI when the user
 can not be aware of its behavior. A client application can ask that the system let the user pick a
 new IME but can not programmatically switch to one itself.  This avoids
 malicious applications from switching the user to their own IME which
 remains running when the user navigates away to another application.  An
 IME on the other hand  is  allowed to programmatically switch
 the system to another IME since it already has full control of user
 input. The user must explicitly enable a new IME in settings before
 they can switch to it to confirm with the system that they know about it
 and want to make it available for use. PackageManager#FEATURE_INPUT_METHODS PackageManager.hasSystemFeature(String)",,no,no,0,no,no,no,no,
"<android.content.ContentResolver: ParcelFileDescriptor openFileDescriptor(Uri,String)>","Open a raw file descriptor to access data under a URI.  This
 is like openAssetFileDescriptor(android.net.Uri java.lang.String) but uses the
 underlying ContentProvider#openFile ContentProvider.openFile()} method so will not work with
 providers that return sub-sections of files.  If at all possible
 you should use openAssetFileDescriptor(android.net.Uri java.lang.String) .  You
 will receive a FileNotFoundException exception if the provider returns a
 sub-section of a file. content ( SCHEME_CONTENT ) 
file ( SCHEME_FILE ) 
See openAssetFileDescriptor(android.net.Uri java.lang.String) for more information
 on these schemes. If opening with the exclusive ""r"" or ""w"" modes the returned
 ParcelFileDescriptor could be a pipe or socket pair to enable streaming
 of data. Opening with the ""rw"" mode implies a file on disk that supports
 seeking. If possible always use an exclusive mode to give the underlying ContentProvider the most flexibility. If you are writing a file and need to communicate an error to the
 provider use ParcelFileDescriptor#closeWithError(String) .","uri Uri : The desired URI to open.
This value must never be null . |||
mode String : The file mode to use as per ContentProvider#openFile .
This value must never be null . |||","ParcelFileDescriptor Returns a new ParcelFileDescriptor pointing to the file.  You
 own this descriptor and are responsible for closing it when done.
 This value may be null . |||",1,This class provides applications access to the content model.,"Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",file data,file,1,yes,no,SOURCE,no,
<android.hardware.usb.UsbManager: ParcelFileDescriptor openAccessory(UsbAccessory)>,"Opens a file descriptor for reading and writing data to the USB accessory. If data is read from the InputStream created from this file descriptor all
 data of a USB transfer should be read at once. If only a partial request is read the rest of
 the transfer is dropped. Requires the PackageManager#FEATURE_USB_ACCESSORY feature which can be detected using PackageManager.hasSystemFeature(String) .",accessory UsbAccessory : the USB accessory to open |||,ParcelFileDescriptor file descriptor or null if the accessory could not be opened. |||,12,"This class allows you to access the state of USB and communicate with USB devices.
 Currently only host mode is supported in the public API.","Provides support to communicate with USB hardware peripherals that are connected to
 Android-powered devices. For more information see the
  USB  guide. Use  UsbManager  to access the state of the USB and to
 communicate with connected hardware peripherals. Use  UsbDevice  to
 communicate with the hardware peripheral if the Android-powered device is acting as the USB host.
 Use  UsbAccessory  if the peripheral is acting as the USB host.",usb data,usb,1,yes,no,SOURCE,no,
"<android.os.Bundle: float getFloat(String,float)>","Returns the value associated with the given key or defaultValue if
 no mapping of the desired type exists for the given key.","key String : a String |||
defaultValue float : Value to return if key does not exist |||",float a float value |||,1,A mapping from String keys to various  Parcelable  values.,,no,no,0,no,no,no,no,
<android.media.MediaPlayer: void stop()>,Stops playback after playback has been started or paused.,,void,1,"MediaPlayer class can be used to control playback
 of audio/video files and streams. An example on how to use the methods in
 this class can be found in  VideoView .

  Topics covered here are:
  State Diagram Valid and Invalid States Permissions Register informational and error callbacks","The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",no,no,0,no,no,no,no,
"<android.content.Intent: Intent createChooser(Intent,CharSequence)>","Convenience function for creating a ACTION_CHOOSER Intent. Builds a new ACTION_CHOOSER Intent that wraps the given
 target intent also optionally supplying a title.  If the target
 intent has specified FLAG_GRANT_READ_URI_PERMISSION or FLAG_GRANT_WRITE_URI_PERMISSION then these flags will also be
 set in the returned chooser intent with its ClipData set appropriately:
 either a direct reflection of getClipData() if that is non-null
 or a new ClipData built from getData() .","target Intent : The Intent that the user will be selecting an activity
to perform. |||
title CharSequence : Optional title that will be displayed in the chooser
only when the target action is not ACTION_SEND or ACTION_SEND_MULTIPLE. |||","Intent Return a new Intent object that you can hand to Context#startActivity(Intent) and
 related methods. |||",1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,
<android.app.Activity: void closeOptionsMenu()>,"Progammatically closes the options menu. If the options menu is already
 closed this method does nothing.",,void,1,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
<android.view.LayoutInflater: LayoutInflater from(Context)>,Obtains the LayoutInflater from the given context.,context Context |||,LayoutInflater |||,1,"Instantiates a layout XML file into its corresponding  View 
 objects. It is never used directly. Instead use
  Activity.getLayoutInflater()  or
  Context#getSystemService  to retrieve a standard LayoutInflater instance
 that is already hooked up to the current context and correctly configured
 for the device you are running on.

  
 To create a new LayoutInflater with an additional  Factory  for your
 own views you can use  cloneInContext(Context)  to clone an existing
 ViewFactory and then call  setFactory(LayoutInflater.Factory)  on it to include your
 Factory.

  
 For performance reasons view inflation relies heavily on pre-processing of
 XML files that is done at build time. Therefore it is not currently possible
 to use LayoutInflater with an XmlPullParser over a plain XML file at runtime;
 it only works with an XmlPullParser returned from a compiled resource
 (R. something  file.)",,no,no,0,no,no,no,no,
<android.app.DialogFragment: Dialog onCreateDialog(Bundle)>,"Override to build your own custom Dialog container.  This is typically
 used to show an AlertDialog instead of a generic Dialog; when doing so Fragment.onCreateView(android.view.LayoutInflater android.view.ViewGroup android.os.Bundle) does not need
 to be implemented since the AlertDialog takes care of its own content. This method will be called after onCreate(android.os.Bundle) and
 before Fragment.onCreateView(android.view.LayoutInflater android.view.ViewGroup android.os.Bundle) .  The
 default implementation simply instantiates and returns a Dialog class. Note: DialogFragment own the Dialog#setOnCancelListener and Dialog#setOnDismissListener callbacks.  You must not set them yourself. To find out about these events override onCancel(android.content.DialogInterface) and onDismiss(android.content.DialogInterface) .","savedInstanceState Bundle : The last saved instance state of the Fragment
or null if this is a freshly created Fragment. |||",Dialog Return a new Dialog instance to be displayed by the Fragment. |||,11,"Base class for Dialogs.

  Note: Activities provide a facility to manage the creation saving and
 restoring of dialogs. See  Activity#onCreateDialog(int) 
  Activity#onPrepareDialog(int Dialog) 
  Activity#showDialog(int)  and  Activity#dismissDialog(int) . If
 these methods are used  getOwnerActivity()  will return the Activity
 that managed this dialog.

  Often you will want to have a Dialog display on top of the current
 input method because there is no reason for it to accept text.  You can
 do this by setting the  WindowManager.LayoutParams#FLAG_ALT_FOCUSABLE_IM  window flag (assuming
 your Dialog takes input focus as it the default) with the following code:

  
 getWindow().setFlags(WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM
         WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",uncategorized,UI,1,no,yes,no,SINK,
<android.hardware.usb.UsbManager: UsbAccessory getAccessoryList()>,"Returns a list of currently attached USB accessories.
 (in the current implementation there can be at most one) Requires the PackageManager#FEATURE_USB_ACCESSORY feature which can be detected using PackageManager.hasSystemFeature(String) .",,UsbAccessory[] list of USB accessories or null if none are attached. |||,12,"This class allows you to access the state of USB and communicate with USB devices.
 Currently only host mode is supported in the public API.","Provides support to communicate with USB hardware peripherals that are connected to
 Android-powered devices. For more information see the
  USB  guide. Use  UsbManager  to access the state of the USB and to
 communicate with connected hardware peripherals. Use  UsbDevice  to
 communicate with the hardware peripheral if the Android-powered device is acting as the USB host.
 Use  UsbAccessory  if the peripheral is acting as the USB host.",usb metadata,usb,1,yes,no,SOURCE,no,
"<android.app.Dialog: void setFeatureDrawableAlpha(int,int)>",Convenience for calling Window.setFeatureDrawableAlpha(int int) .,"featureId int |||
alpha int |||",void,1,"Base class for Dialogs.

  Note: Activities provide a facility to manage the creation saving and
 restoring of dialogs. See  Activity#onCreateDialog(int) 
  Activity#onPrepareDialog(int Dialog) 
  Activity#showDialog(int)  and  Activity#dismissDialog(int) . If
 these methods are used  getOwnerActivity()  will return the Activity
 that managed this dialog.

  Often you will want to have a Dialog display on top of the current
 input method because there is no reason for it to accept text.  You can
 do this by setting the  WindowManager.LayoutParams#FLAG_ALT_FOCUSABLE_IM  window flag (assuming
 your Dialog takes input focus as it the default) with the following code:

  
 getWindow().setFlags(WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM
         WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,UI,0,no,no,no,no,
"<android.nfc.NfcAdapter: void setNdefPushMessage(NdefMessage,Activity,Activity)>","This method was deprecated
      in API level 29. this feature is deprecated. File sharing can work using other technology like
 Bluetooth. Set a static NdefMessage to send using Android Beam (TM). This method may be called at any time before Activity#onDestroy but the NDEF message is only made available for NDEF push when the
 specified activity(s) are in resumed (foreground) state. The recommended
 approach is to call this method during your Activity's Activity#onCreate - see sample
 code below. This method does not immediately perform any I/O or blocking work
 so is safe to call on your main thread. Only one NDEF message can be pushed by the currently resumed activity.
 If both setNdefPushMessage(NdefMessage Activity Activity...) and setNdefPushMessageCallback(NfcAdapter.CreateNdefMessageCallback Activity Activity...) are set then
 the callback will take priority. If neither setNdefPushMessage(NdefMessage Activity Activity...) or setNdefPushMessageCallback(NfcAdapter.CreateNdefMessageCallback Activity Activity...) have been called for your activity then
 the Android OS may choose to send a default NDEF message on your behalf
 such as a URI for your application. If setNdefPushMessage(NdefMessage Activity Activity...) is called with a null NDEF message
 and/or setNdefPushMessageCallback(NfcAdapter.CreateNdefMessageCallback Activity Activity...) is called with a null callback
 then NDEF push will be completely disabled for the specified activity(s).
 This also disables any default NDEF message the Android OS would have
 otherwise sent on your behalf for those activity(s). If you want to prevent the Android OS from sending default NDEF
 messages completely (for all activities) you can include a <meta-data> element inside the <application> element of your AndroidManifest.xml file like this: The API allows for multiple activities to be specified at a time
 but it is strongly recommended to just register one at a time
 and to do so during the activity's Activity#onCreate . For example: If your Activity wants to dynamically generate an NDEF message
 then set a callback using setNdefPushMessageCallback(NfcAdapter.CreateNdefMessageCallback Activity Activity...) instead
 of a static message. Do not pass in an Activity that has already been through Activity#onDestroy . This is guaranteed if you call this API
 during Activity#onCreate . For sending large content such as pictures and songs
 consider using setBeamPushUris(Uri[] Activity) which switches to alternate transports
 such as Bluetooth to achieve a fast transfer rate. Requires the Manifest.permission.NFC permission.","message NdefMessage : NDEF message to push over NFC or null to disable |||
activity Activity : activity for which the NDEF message will be pushed |||
activities Activity : optional additional activities however we strongly recommend
to only register one at a time and to do so in that activity's Activity#onCreate |||",void,14,"Represents the local NFC adapter.
  
 Use the helper  getDefaultAdapter(android.content.Context)  to get the default NFC
 adapter for this Android device.","Provides access to Near Field Communication (NFC) functionality allowing applications to read
 NDEF message in NFC tags. A ""tag"" may actually be another device that appears as a tag. For more information see the
  Near Field Communication  guide. Here's a summary of the classes: NfcManager This is the high level manager used to obtain this device's  NfcAdapter . You can
 acquire an instance using  getSystemService(Class ) . NfcAdapter This represents the device's NFC adapter which is your entry-point to performing NFC
 operations. You can acquire an instance with  getDefaultAdapter()  or
  getDefaultAdapter(android.content.Context) . NdefMessage Represents an NDEF data message which is the standard format in which ""records""
 carrying data are transmitted between devices and tags. Your application can receive these
 messages from an  ACTION_TAG_DISCOVERED  intent. NdefRecord Represents a record which is delivered in a  NdefMessage  and describes the
 type of data being shared and carries the data itself. Note: 
 Not all Android-powered devices provide NFC functionality.",nfc message,nfc,1,no,yes,no,SINK,
<android.database.sqlite.SQLiteDatabase: void setMaxSqlCacheSize(int)>,"Sets the maximum size of the prepared-statement cache for this database.
 (size of the cache = number of compiled-sql-statements stored in the cache). Maximum cache size can ONLY be increased from its current size (default = 10).
 If this method is called with smaller size than the current maximum value
 then IllegalStateException is thrown. This method is thread-safe.",cacheSize int : the size of the cache. can be (0 to MAX_SQL_CACHE_SIZE ) |||,void,11,"Exposes methods to manage a SQLite database.

  
 SQLiteDatabase has methods to create delete execute SQL commands and
 perform other common database management tasks.
  
 See the Notepad sample application in the SDK for an example of creating
 and managing a database.
  
 Database names must be unique within an application not across all applications.
  Localized Collation - ORDER BY 
 In addition to SQLite's default  BINARY  collator Android supplies
 two more  LOCALIZED  which changes with the system's current locale
 and  UNICODE  which is the Unicode Collation Algorithm and not tailored
 to the current locale.","If you need to manage data in a private database use the  android.database.sqlite  classes. These classes are used to manage the  Cursor  object returned from a content provider query. Databases
 are usually created and opened with  openOrCreateDatabase(String int SQLiteDatabase.CursorFactory) 
 To make requests through
 content providers you can use the  content.ContentResolver  class.
  All databases are stored on the device in  /data/data/<package_name>/databases",no,database,0,no,no,no,no,
"<android.text.method.QwertyKeyListener: void markAsReplaced(Spannable,int,int,String)>","Marks the specified region of content as having
 contained original prior to AutoText replacement.
 Call this method when you have done or are about to do an
 AutoText-style replacement on a region of text and want to let
 the same mechanism (the user pressing DEL immediately after the
 change) undo the replacement.","content Spannable : the Editable text where the replacement was made |||
start int : the start of the replaced region |||
end int : the end of the replaced region; the location of the cursor |||
original String : the text to be restored if the user presses DEL |||",void,1,"This is the standard key listener for alphabetic input on qwerty
 keyboards.  You should generally not need to instantiate this yourself;
 TextKeyListener will do it for you.
  KeyListener","Provides classes that monitor or modify keypad input. You can use these classes to modify the type of keypad entry
 for your application or decipher the keypresses entered for your specific
 entry method. For example: 
 // Set the text to password display style:
 EditText txtView = (EditText)findViewById(R.id.text);
 txtView.setTransformationMethod(PasswordTransformationMethod.getInstance());

 //Set the input style to numbers rather than qwerty keyboard style.
 txtView.setInputMethod(DigitsInputMethod.getInstance());

 // Find out whether the caps lock is on.
 // 0 is no 1 is yes 2 is caps lock on.
 int active = MultiTapInputMethod.getCapsActive(txtView.getText());",no,UI,0,no,no,no,no,
<android.app.ActivityManager: ConfigurationInfo getDeviceConfigurationInfo()>,Get the device configuration attributes.,,ConfigurationInfo |||,3,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",preferences,preference storage file,1,yes,no,SOURCE,no,
"<android.media.SoundPool: int load(Context,int,int)>","Load the sound from the specified APK resource.

 Note that the extension is dropped. For example if you want to load
 a sound from the raw resource file ""explosion.mp3"" you would specify
 ""R.raw.explosion"" as the resource ID. Note that this means you cannot
 have both an ""explosion.wav"" and an ""explosion.mp3"" in the res/raw
 directory.","context Context : the application context |||
resId int : the resource ID |||
priority int : the priority of the sound. Currently has no effect. Use
a value of 1 for future compatibility. |||",int a sound ID. This value can be used to play or unload the sound. |||,1,"The SoundPool class manages and plays audio resources for applications.

  A SoundPool is a collection of samples that can be loaded into memory
 from a resource inside the APK or from a file in the file system. The
 SoundPool library uses the MediaPlayer service to decode the audio
 into a raw 16-bit PCM mono or stereo stream. This allows applications
 to ship with compressed streams without having to suffer the CPU load
 and latency of decompressing during playback. In addition to low-latency playback SoundPool can also manage the number
 of audio streams being rendered at once. When the SoundPool object is
 constructed the maxStreams parameter sets the maximum number of streams
 that can be played at a time from this single SoundPool. SoundPool tracks
 the number of active streams. If the maximum number of streams is exceeded
 SoundPool will automatically stop a previously playing stream based first
 on priority and then by age within that priority. Limiting the maximum
 number of streams helps to cap CPU loading and reducing the likelihood that
 audio mixing will impact visuals or UI performance. Sounds can be looped by setting a non-zero loop value. A value of -1
 causes the sound to loop forever. In this case the application must
 explicitly call the stop() function to stop the sound. Any other non-zero
 value will cause the sound to repeat the specified number of times e.g.
 a value of 3 causes the sound to play a total of 4 times. The playback rate can also be changed. A playback rate of 1.0 causes
 the sound to play at its original frequency (resampled if necessary
 to the hardware output frequency). A playback rate of 2.0 causes the
 sound to play at twice its original frequency and a playback rate of
 0.5 causes it to play at half its original frequency. The playback
 rate range is 0.5 to 2.0. Priority runs low to high i.e. higher numbers are higher priority.
 Priority is used when a call to play() would cause the number of active
 streams to exceed the value established by the maxStreams parameter when
 the SoundPool was created. In this case the stream allocator will stop
 the lowest priority stream. If there are multiple streams with the same
 low priority it will choose the oldest stream to stop. In the case
 where the priority of the new stream is lower than all the active
 streams the new sound will not play and the play() function will return
 a streamID of zero. Let's examine a typical use case: A game consists of several levels of
 play. For each level there is a set of unique sounds that are used only
 by that level. In this case the game logic should create a new SoundPool
 object when the first level is loaded. The level data itself might contain
 the list of sounds to be used by this level. The loading logic iterates
 through the list of sounds calling the appropriate SoundPool.load()
 function. This should typically be done early in the process to allow time
 for decompressing the audio to raw PCM format before they are needed for
 playback. Once the sounds are loaded and play has started the application can
 trigger sounds by calling SoundPool.play(). Playing streams can be
 paused or resumed and the application can also alter the pitch by
 adjusting the playback rate in real-time for doppler or synthesis
 effects. Note that since streams can be stopped due to resource constraints the
 streamID is a reference to a particular instance of a stream. If the stream
 is stopped to allow a higher priority stream to play the stream is no
 longer valid. However the application is allowed to call methods on
 the streamID without error. This may help simplify program logic since
 the application need not concern itself with the stream lifecycle. In our example when the player has completed the level the game
 logic should call SoundPool.release() to release all the native resources
 in use and then set the SoundPool reference to null. If the player starts
 another level a new SoundPool is created sounds are loaded and play
 resumes.","The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",no,no,0,no,no,no,no,
"<android.content.ContentProvider: int bulkInsert(Uri,ContentValues)>","Override this to handle requests to insert a set of new rows or the
 default implementation will iterate over the values and call insert(Uri ContentValues) on each of them.
 As a courtesy call ContentResolver#notifyChange(android.net.Uri android.database.ContentObserver) after inserting.
 This method can be called from multiple threads as described in Processes
 and Threads .","uri Uri : The content:// URI of the insertion request.
This value must never be null . |||
values ContentValues : An array of sets of column_name/value pairs to add to the database.
This must not be null .
This value must never be null . |||",int The number of values that were inserted. |||,1,"Content providers are one of the primary building blocks of Android applications providing
 content to applications. They encapsulate data and provide it to applications through the single
  ContentResolver  interface. A content provider is only required if you need to share
 data between multiple applications. For example the contacts data is used by multiple
 applications and must be stored in a content provider. If you don't need to share data amongst
 multiple applications you can use a database directly via
  SQLiteDatabase .

  When a request is made via
 a  ContentResolver  the system inspects the authority of the given URI and passes the
 request to the content provider registered with the authority. The content provider can interpret
 the rest of the URI however it wants. The  UriMatcher  class is helpful for parsing
 URIs. The primary methods that need to be implemented are:
  onCreate()  which is called to initialize the provider query(Uri String[] Bundle CancellationSignal)  which returns data to the caller insert(Uri ContentValues)  which inserts new data into the content provider update(Uri ContentValues String String[])  which updates existing data in the content provider delete(Uri String String[])  which deletes data from the content provider getType(Uri)  which returns the MIME type of data in the content provider Requests to  ContentResolver  are automatically forwarded to the appropriate
 ContentProvider instance so subclasses don't have to worry about the details of
 cross-process calls.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",database data,database,1,no,yes,no,SINK,
<android.content.Intent: Parcelable getParcelableArrayExtra(String)>,Retrieve extended data from the intent.,name String : The name of the desired item. |||,"Parcelable[] the value of an item previously added with putExtra()
 or null if no Parcelable[] value was found. |||",1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",IPC,no,0,no,no,no,no,
<android.view.inputmethod.InputMethodManager: void restartInput(View)>,"If the input method is currently connected to the given view
 restart it with its new contents.  You should call this when the text
 within your view changes outside of the normal input method or key
 input flow such as when an application calls TextView.setText().",view View : The view whose text has changed. |||,void,3,"Central system API to the overall input method framework (IMF) architecture
 which arbitrates interaction between applications and the current input method.

  Topics covered here:
  Architecture Overview Applications Input Methods Security Architecture Overview There are three primary parties involved in the input method
 framework (IMF) architecture:  The  input method manager  as expressed by this class
 is the central point of the system that manages interaction between all
 other parts.  It is expressed as the client-side API here which exists
 in each application context and communicates with a global system service
 that manages the interaction across all processes.
   An  input method (IME)  implements a particular
 interaction model allowing the user to generate text.  The system binds
 to the current input method that is in use causing it to be created and run
 and tells it when to hide and show its UI.  Only one IME is running at a time.
   Multiple  client applications  arbitrate with the input
 method manager for input focus and control over the state of the IME.  Only
 one such client is ever active (working with the IME) at a time.
  Applications In most cases applications that are using the standard
  TextView  or its subclasses will have little they need
 to do to work well with soft input methods.  The main things you need to
 be aware of are:  Properly set the  R.attr.inputType  in your editable
 text views so that the input method will have enough context to help the
 user in entering text into them.
   Deal well with losing screen space when the input method is
 displayed.  Ideally an application should handle its window being resized
 smaller but it can rely on the system performing panning of the window
 if needed.  You should set the  R.attr.windowSoftInputMode 
 attribute on your activity or the corresponding values on windows you
 create to help the system determine whether to pan or resize (it will
 try to determine this automatically but may get it wrong).
   You can also control the preferred soft input state (open closed etc)
 for your window using the same  R.attr.windowSoftInputMode 
 attribute.
  More finer-grained control is available through the APIs here to directly
 interact with the IMF and its IME -- either showing or hiding the input
 area letting the user pick an input method etc. For the rare people amongst us writing their own text editors you
 will need to implement  View.onCreateInputConnection(EditorInfo) 
 to return a new instance of your own  InputConnection  interface
 allowing the IME to interact with your editor. Input Methods An input method (IME) is implemented
 as a  Service  typically deriving from
  InputMethodService .  It must provide
 the core  InputMethod  interface though this is normally handled by
  InputMethodService  and implementors will
 only need to deal with the higher-level API there. InputMethodService Security There are a lot of security issues associated with input methods
 since they essentially have freedom to completely drive the UI and monitor
 everything the user enters.  The Android input method framework also allows
 arbitrary third party IMEs so care must be taken to restrict their
 selection and interactions. Here are some key points about the security architecture behind the
 IMF: Only the system is allowed to directly access an IME's
  InputMethod  interface via the
  Manifest.permission.BIND_INPUT_METHOD  permission.  This is
 enforced in the system by not binding to an input method service that does
 not require this permission so the system can guarantee no other untrusted
 clients are accessing the current input method outside of its control. There may be many client processes of the IMF but only one may
 be active at a time.  The inactive clients can not interact with key
 parts of the IMF through the mechanisms described below. Clients of an input method are only given access to its
  InputMethodSession  interface.  One instance of this interface is
 created for each client and only calls from the session associated with
 the active client will be processed by the current IME.  This is enforced
 by  AbstractInputMethodService  for normal
 IMEs but must be explicitly handled by an IME that is customizing the
 raw  InputMethodSession  implementation. Only the active client's  InputConnection  will accept
 operations.  The IMF tells each client process whether it is active and
 the framework enforces that in inactive processes calls on to the current
 InputConnection will be ignored.  This ensures that the current IME can
 only deliver events and text edits to the UI that the user sees as
 being in focus. An IME can never interact with an  InputConnection  while
 the screen is off.  This is enforced by making all clients inactive while
 the screen is off and prevents bad IMEs from driving the UI when the user
 can not be aware of its behavior. A client application can ask that the system let the user pick a
 new IME but can not programmatically switch to one itself.  This avoids
 malicious applications from switching the user to their own IME which
 remains running when the user navigates away to another application.  An
 IME on the other hand  is  allowed to programmatically switch
 the system to another IME since it already has full control of user
 input. The user must explicitly enable a new IME in settings before
 they can switch to it to confirm with the system that they know about it
 and want to make it available for use. PackageManager#FEATURE_INPUT_METHODS PackageManager.hasSystemFeature(String)",,uncategorized,UI,1,no,yes,no,SINK,
"<android.app.ListFragment: void onViewCreated(View,Bundle)>",Attach to list view once the view hierarchy has been created.,"view View : The View returned by onCreateView(android.view.LayoutInflater android.view.ViewGroup android.os.Bundle) . |||
savedInstanceState Bundle : If non-null this fragment is being re-constructed
from a previous saved state as given here.
This value may be null . |||",void,13,"A fragment that displays a list of items by binding to a data source such as
 an array or Cursor and exposes event handlers when the user selects an item.
  
 ListFragment hosts a  ListView  object that can
 be bound to different data sources typically either an array or a Cursor
 holding query results. Binding screen layout and row layout are discussed
 in the following sections.
  Screen Layout 
 ListFragment has a default layout that consists of a single list view.
 However if you desire you can customize the fragment layout by returning
 your own view hierarchy from  onCreateView(LayoutInflater ViewGroup Bundle) .
 To do this your view hierarchy  must  contain a ListView object with the
 id ""@android:id/list"" (or  R.id.list  if it's in code)
  
 Optionally your view hierarchy can contain another view object of any type to
 display when the list view is empty. This ""empty list"" notifier must have an
 id ""android:empty"". Note that when an empty view is present the list view
 will be hidden when there is no data to display.
  
 The following code demonstrates an (ugly) custom list layout. It has a list
 with a green background and an alternate red ""no data"" message.
  
 <?xml version=""1.0"" encoding=""utf-8""?>
 <LinearLayout xmlns:android=""http://schemas.android.com/apk/res/android""
         android:orientation=""vertical""
         android:layout_width=""match_parent""
         android:layout_height=""match_parent""
         android:paddingLeft=""8dp""
         android:paddingRight=""8dp"">

     <ListView android:id=""@id/android:list""
               android:layout_width=""match_parent""
               android:layout_height=""match_parent""
               android:background=""#00FF00""
               android:layout_weight=""1""
               android:drawSelectorOnTop=""false""/>

     <TextView android:id=""@id/android:empty""
               android:layout_width=""match_parent""
               android:layout_height=""match_parent""
               android:background=""#FF0000""
               android:text=""No data""/>
 </LinearLayout>
  Row Layout 
 You can specify the layout of individual rows in the list. You do this by
 specifying a layout resource in the ListAdapter object hosted by the fragment
 (the ListAdapter binds the ListView to the data; more on this later).
  
 A ListAdapter constructor takes a parameter that specifies a layout resource
 for each row. It also has two additional parameters that let you specify
 which data field to associate with which object in the row layout resource.
 These two parameters are typically parallel arrays.
  
 Android provides some standard row layout resources. These are in the
  R.layout  class and have names such as simple_list_item_1
 simple_list_item_2 and two_line_list_item. The following layout XML is the
 source for the resource two_line_list_item which displays two data
 fieldsone above the other for each list row.
  
 <?xml version=""1.0"" encoding=""utf-8""?>
 <LinearLayout xmlns:android=""http://schemas.android.com/apk/res/android""
     android:layout_width=""match_parent""
     android:layout_height=""wrap_content""
     android:orientation=""vertical"">

     <TextView android:id=""@+id/text1""
         android:textSize=""16sp""
         android:textStyle=""bold""
         android:layout_width=""match_parent""
         android:layout_height=""wrap_content""/>

     <TextView android:id=""@+id/text2""
         android:textSize=""16sp""
         android:layout_width=""match_parent""
         android:layout_height=""wrap_content""/>
 </LinearLayout>
  
 You must identify the data bound to each TextView object in this layout. The
 syntax for this is discussed in the next section.
  Binding to Data 
 You bind the ListFragment's ListView object to data using a class that
 implements the  ListAdapter  interface.
 Android provides two standard list adapters:
  SimpleAdapter  for static data (Maps)
 and  SimpleCursorAdapter  for Cursor
 query results.
  
 You  must  use
  ListFragment.setListAdapter()  to
 associate the list with an adapter.  Do not directly call
  ListView#setAdapter(ListAdapter)  or else
 important initialization will be skipped.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",uncategorized,UI,1,no,yes,no,SINK,
<android.content.CursorLoader: void cancelLoadInBackground()>,"Called on the main thread to abort a load in progress.

 Override this method to abort the current invocation of loadInBackground() that is running in the background on a worker thread.

 This method should do nothing if loadInBackground() has not started
 running or if it has already finished.",,void,16,"A loader that queries the  ContentResolver  and returns a  Cursor .
 This class implements the  Loader  protocol in a standard way for
 querying cursors building on  AsyncTaskLoader  to perform the cursor
 query on a background thread so that it does not block the application's UI.

  A CursorLoader must be built with the full information for the query to
 perform either through the
  CursorLoader(android.content.Context android.net.Uri java.lang.String[] java.lang.String java.lang.String[] java.lang.String)  or
 creating an empty instance with  CursorLoader(android.content.Context)  and filling
 in the desired parameters with  setUri(android.net.Uri)   setSelection(java.lang.String) 
  setSelectionArgs(java.lang.String[])   setSortOrder(java.lang.String) 
 and  setProjection(java.lang.String[]) .","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,
<android.preference.DialogPreference: void setDialogTitle(int)>,,dialogTitleResId int : The dialog title as a resource. |||,void,1,"A base class for  Preference  objects that are
 dialog-based. These preferences will when clicked open a dialog showing the
 actual preference controls.",,no,UI,0,no,no,no,no,
<android.widget.MediaController: void setAnchorView(View)>,"Set the view that acts as the anchor for the control view.
 This can for example be a VideoView or your Activity's main view.
 When VideoView calls this method it will use the VideoView's parent
 as the anchor.",view View : The view to which to anchor the controller when it is visible. |||,void,1,"A view containing controls for a MediaPlayer. Typically contains the
 buttons like ""Play/Pause"" ""Rewind"" ""Fast Forward"" and a progress
 slider. It takes care of synchronizing the controls with the state
 of the MediaPlayer.
  
 The way to use this class is to instantiate it programmatically.
 The MediaController will create a default set of controls
 and put them in a window floating above your application. Specifically
 the controls will float above the view specified with setAnchorView().
 The window will disappear if left idle for three seconds and reappear
 when the user touches the anchor view.
  
 Functions like show() and hide() have no effect when MediaController
 is created in an xml layout.

 MediaController will hide and
 show the buttons according to these rules:
   The ""previous"" and ""next"" buttons are hidden until setPrevNextListeners()
   has been called
   The ""previous"" and ""next"" buttons are visible but disabled if
   setPrevNextListeners() was called with null listeners
   The ""rewind"" and ""fastforward"" buttons are shown unless requested
   otherwise by using the MediaController(Context boolean) constructor
   with the boolean set to false","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",uncategorized,UI,1,no,yes,no,SINK,
"<android.content.ContentResolver: void startSync(Uri,Bundle)>","This method was deprecated
      in API level 15. instead use requestSync(android.accounts.Account java.lang.String android.os.Bundle) Start an asynchronous sync operation. If you want to monitor the progress
 of the sync you may register a SyncObserver. Only values of the following
 types may be used in the extras bundle: Integer 
Long 
Boolean 
Float 
Double 
String 
Account 
null","uri Uri : the uri of the provider to sync or null to sync all providers. |||
extras Bundle : any extras to pass to the SyncAdapter. |||",void,1,This class provides applications access to the content model.,"Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",database info,database,1,no,no,no,no,
<android.net.sip.SipAudioCall: void close()>,Closes this object. This object is not usable after being closed.,,void,9,"Handles an Internet audio call over SIP. You can instantiate this class with  SipManager 
 using  SipManager#makeAudioCall  and   SipManager#takeAudioCall .

  Note:  Using this class require the
    Manifest.permission.INTERNET  and
    Manifest.permission.USE_SIP  permissions. In addition  startAudio()  requires the
    Manifest.permission.RECORD_AUDIO 
    Manifest.permission.ACCESS_WIFI_STATE  and
    Manifest.permission.WAKE_LOCK  permissions; and  setSpeakerMode()  requires the
    Manifest.permission.MODIFY_AUDIO_SETTINGS  permission.",,no,no,0,no,no,no,no,
"<android.content.ContextWrapper: void enforceCallingPermission(String,String)>","If the calling process of an IPC you are handling has not been
 granted a particular permission throw a SecurityException .  This is basically the same as calling enforcePermission(java.lang.String int int java.lang.String) with the
 pid and uid returned by Binder.getCallingPid() and Binder.getCallingUid() .  One important
 difference is that if you are not currently processing an IPC
 this function will always throw the SecurityException.  This is
 done to protect against accidentally leaking permissions; you
 can use enforceCallingOrSelfPermission(String String) to avoid this
 protection.","permission String : The name of the permission being checked.
This value must never be null . |||
message String : A message to include in the exception if it is thrown.
This value may be null . |||",void,1,"Proxying implementation of Context that simply delegates all of its calls to
 another Context.  Can be subclassed to modify behavior without changing
 the original Context.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",IPC,no,0,no,no,no,no,
<android.text.Layout: float getLineWidth(int)>,"Gets the unsigned horizontal extent of the specified line including
 leading margin indent and trailing whitespace.",line int |||,float |||,1,"A base class that manages text layout in visual elements on
 the screen.
  For text that will be edited use a  DynamicLayout 
 which will be updated as the text changes.
 For text that will not change use a  StaticLayout .","Provides classes used to render or track text and text spans on the screen. You can use these classes to design your own widgets that manage text
 to handle arbitrary text spans for changes or to handle drawing yourself
 for an existing widget. The Span… interfaces and classes are used to create or manage spans of
 text in a View item. You can use these to style the text or background or to
 listen for changes. If creating your own widget extend DynamicLayout to manages
 the actual wrapping and drawing of your text.",no,UI,0,no,no,no,no,
<android.media.RingtoneManager: Cursor getCursor()>,"Returns a Cursor of all the ringtones available. The returned
 cursor will be the same cursor returned each time this method is called
 so do not Cursor#close() the cursor. The cursor can be Cursor#deactivate() safely. If RingtoneManager#RingtoneManager(Activity) was not used the
 caller should manage the returned cursor through its activity's life
 cycle to prevent leaking the cursor. Note that the list of ringtones available will differ depending on whether the caller
 has the Manifest.permission.READ_EXTERNAL_STORAGE permission.",,Cursor A Cursor of all the ringtones available. |||,1,"RingtoneManager provides access to ringtones notification and other types
 of sounds. It manages querying the different media providers and combines the
 results into a single cursor. It also provides a  Ringtone  for each
 ringtone. We generically call these sounds ringtones however the
  TYPE_RINGTONE  refers to the type of sounds that are suitable for the
 phone ringer.
  
 To show a ringtone picker to the user use the
  ACTION_RINGTONE_PICKER  intent to launch the picker as a subactivity.","The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",media,media files,1,yes ,no,SOURCE,no,
<android.app.LauncherActivity: List makeListItems()>,Perform the query to determine which results to show and return a list of them.,,List < LauncherActivity.ListItem > |||,3,"Displays a list of all activities which can be performed
 for a given intent. Launches when clicked.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
"<android.content.res.Resources: String getQuantityString(int,int,Object)>","Formats the string necessary for grammatically correct pluralization
 of the given resource ID for the given quantity using the given arguments.
 Note that the string is selected based solely on grammatical necessity
 and that such rules differ between languages. Do not assume you know which string
 will be returned for a given quantity. See String Resources for more detail. Substitution of format arguments works as if using Formatter and String.format(String Object...) .
 The resulting string will be stripped of any styled text information.","id int : The desired resource identifier as generated by the aapt
tool. This integer encodes the package type and resource
entry. The value 0 is an invalid identifier. |||
quantity int : The number used to get the correct string for the current language's
plural rules. |||
formatArgs Object : The format arguments that will be used for substitution. |||","String String The string data associated with the resource
 stripped of styled text information.
 
 This value will never be null . |||",1,"Class for accessing an application's resources.  This sits on top of the
 asset manager of the application (accessible through  getAssets() ) and
 provides a high-level API for getting typed data from the assets.

  The Android resource system keeps track of all non-code assets associated with an
 application. You can use this class to access your application's resources. You can generally
 acquire the  Resources  instance associated with your application
 with  getResources() . The Android SDK tools compile your application's resources into the application binary
 at build time.  To use a resource you must install it correctly in the source tree (inside
 your project's  res/  directory) and build your application.  As part of the build
 process the SDK tools generate symbols for each resource which you can use in your application
 code to access the resources. Using application resources makes it easy to update various characteristics of your
 application without modifying code and—by providing sets of alternative
 resources—enables you to optimize your application for a variety of device configurations
 (such as for different languages and screen sizes). This is an important aspect of developing
 Android applications that are compatible on different types of devices. For more information about using resources see the documentation about  Application Resources .","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,
<android.widget.AbsListView: void smoothScrollToPosition(int)>,"Smoothly scroll to the specified adapter position. The view will
 scroll such that the indicated position is displayed.",position int : Scroll to this adapter position. |||,void,8,"Base class that can be used to implement virtualized lists of items. A list does
 not have a spatial definition here. For instance subclasses of this class can
 display the content of the list in a grid in a carousel as stack etc.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,no,0,no,no,no,no,
<android.text.style.URLSpan: void onClick(View)>,Performs the click action associated with this span.,widget View : This value must never be null . |||,void,1,"Implementation of the  ClickableSpan  that allows setting a url string. When
 selecting and clicking on the text to which the span is attached the  URLSpan 
 will try to open the url by launching an an Activity with an  Intent#ACTION_VIEW  intent.
  
 For example a  URLSpan  can be used like this:
  
 SpannableString string = new SpannableString(""Text with a url span"");
 string.setSpan(new URLSpan(""http://www.developer.android.com"") 12 15 Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
  Text with  URLSpan .","Provides classes used to view or change the style of a span of text in a View object.
 The classes with a subclass Standard are passed in to  SpannableString.setSpan()  or  SpannableStringBuilder.setSpan()  to add a new styled span to a string in a View object.",no,no,0,no,no,no,no,
<android.widget.ViewSwitcher: void reset()>,"Reset the ViewSwitcher to hide all of the existing views and to make it
 think that the first time animation has not yet played.",,void,1,"ViewAnimator  that switches between two views and has a factory
 from which these views are created.  You can either use the factory to
 create the views or add them yourself.  A ViewSwitcher can only have two
 child views of which only one is shown at a time.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,no,0,no,no,no,no,
"<android.text.SpannableString: CharSequence subSequence(int,int)>","Returns a CharSequence that is a subsequence of this sequence.
 The subsequence starts with the char value at the specified index and
 ends with the char value at index end - 1 .  The length
 (in char s) of the
 returned sequence is end - start so if start == end then an empty sequence is returned.","start int : the start index inclusive |||
end int : the end index exclusive |||",CharSequence the specified subsequence |||,1,"This is the class for text whose content is immutable but to which
 markup objects can be attached and detached.
 For mutable text see  SpannableStringBuilder .","Provides classes used to render or track text and text spans on the screen. You can use these classes to design your own widgets that manage text
 to handle arbitrary text spans for changes or to handle drawing yourself
 for an existing widget. The Span… interfaces and classes are used to create or manage spans of
 text in a View item. You can use these to style the text or background or to
 listen for changes. If creating your own widget extend DynamicLayout to manages
 the actual wrapping and drawing of your text.",no,no,0,no,no,no,no,
<android.widget.CompoundButton: void setButtonDrawable(int)>,"Sets a drawable as the compound button image given its resource
 identifier. Related XML Attributes: android:button",resId int : the resource identifier of the drawable |||,void,1,"A button with two states checked and unchecked. When the button is pressed
 or clicked the state changes automatically.
  XML attributes 
 See  CompoundButton Attributes   Button
 Attributes   TextView Attributes   View Attributes","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,no,0,no,no,no,no,
<android.database.sqlite.SQLiteStatement: void execute()>,"Execute this SQL statement if it is not a SELECT / INSERT / DELETE / UPDATE for example
 CREATE / DROP table view trigger index etc.",,void,1,"Represents a statement that can be executed against a database.  The statement
 cannot return multiple rows or columns but single value (1 x 1) result sets
 are supported.
  
 This class is not thread-safe.","If you need to manage data in a private database use the  android.database.sqlite  classes. These classes are used to manage the  Cursor  object returned from a content provider query. Databases
 are usually created and opened with  openOrCreateDatabase(String int SQLiteDatabase.CursorFactory) 
 To make requests through
 content providers you can use the  content.ContentResolver  class.
  All databases are stored on the device in  /data/data/<package_name>/databases",no,no,0,no,no,no,no,
"<android.text.SpannedString: CharSequence subSequence(int,int)>","Returns a CharSequence that is a subsequence of this sequence.
 The subsequence starts with the char value at the specified index and
 ends with the char value at index end - 1 .  The length
 (in char s) of the
 returned sequence is end - start so if start == end then an empty sequence is returned.","start int : the start index inclusive |||
end int : the end index exclusive |||",CharSequence the specified subsequence |||,1,"This is the class for text whose content and markup are immutable.
 For mutable markup see  SpannableString ; for mutable text
 see  SpannableStringBuilder .","Provides classes used to render or track text and text spans on the screen. You can use these classes to design your own widgets that manage text
 to handle arbitrary text spans for changes or to handle drawing yourself
 for an existing widget. The Span… interfaces and classes are used to create or manage spans of
 text in a View item. You can use these to style the text or background or to
 listen for changes. If creating your own widget extend DynamicLayout to manages
 the actual wrapping and drawing of your text.",no,no,0,no,no,no,no,
"<android.app.ActivityManager: void moveTaskToFront(int,int,Bundle)>","Ask that the task associated with a given task ID be moved to the
 front of the stack so it is now visible to the user. Requires Manifest.permission.REORDER_TASKS","taskId int : The identifier of the task to be moved as found in RunningTaskInfo or RecentTaskInfo . |||
flags int : Additional operational flags.
Value is either 0 or a combination of MOVE_TASK_WITH_HOME and MOVE_TASK_NO_USER_ACTION |||
options Bundle : Additional options for the operation either null or
as per Context#startActivity(Intent android.os.Bundle) . |||",void,16,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
<android.webkit.WebView: WebBackForwardList restoreState(Bundle)>,"Restores the state of this WebView from the given Bundle. This method is
 intended for use in Activity.onRestoreInstanceState(Bundle) and should be called to restore the state of this WebView. If
 it is called after this WebView has had a chance to build state (load
 pages create a back/forward list etc.) there may be undesirable
 side-effects. Please note that this method no longer restores the
 display data for this WebView.","inState Bundle : the incoming Bundle of state
This value must never be null . |||",WebBackForwardList the restored back/forward list or null if restoreState failed |||,1,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",no,no,0,no,no,no,no,
<android.content.ContextWrapper: Context createConfigurationContext(Configuration)>,"Return a new Context object for the current Context but whose resources
 are adjusted to match the given Configuration.  Each call to this method
 returns a new instance of a Context object; Context objects are not
 shared however common state (ClassLoader other Resources for the
 same configuration) may be so the Context itself can be fairly lightweight.","overrideConfiguration Configuration : A Configuration specifying what
values to modify in the base Configuration of the original Context's
resources.  If the base configuration changes (such as due to an
orientation change) the resources of this context will also change except
for those that have been explicitly overridden with a value here.
This value must never be null . |||",Context A Context with the given configuration override. |||,17,"Proxying implementation of Context that simply delegates all of its calls to
 another Context.  Can be subclassed to modify behavior without changing
 the original Context.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,
"<android.appwidget.AppWidgetManager: void updateAppWidget(ComponentName,RemoteViews)>","Set the RemoteViews to use for all AppWidget instances for the supplied AppWidget provider. It is okay to call this method both inside an ACTION_APPWIDGET_UPDATE broadcast
 and outside of the handler.
 This method will only work when called from the uid that owns the AppWidget provider.","provider ComponentName : The ComponentName for the BroadcastReceiver provider
for your AppWidget. |||
views RemoteViews : The RemoteViews object to show. |||",void,3,"Updates AppWidget state; gets information about installed AppWidget providers and other
 AppWidget related state.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
<android.net.ConnectivityManager: int getNetworkPreference()>,"This method was deprecated
      in API level 21. Functionality has been removed as it no longer makes sense
             with many more than two networks - we'd need an array to express
             preference.  Instead we use dynamic network properties of
             the networks to describe their precedence. Retrieves the current preferred network type. Requires Manifest.permission.ACCESS_NETWORK_STATE",,int an integer representing the preferred network type |||,1,"Class that answers queries about the state of network connectivity. It also
 notifies applications when network connectivity changes.
  
 The primary responsibilities of this class are to:
  Monitor network connections (Wi-Fi GPRS UMTS etc.) Send broadcast intents when network connectivity changes Attempt to ""fail over"" to another network when connectivity to a network
 is lost Provide an API that allows applications to query the coarse-grained or fine-grained
 state of the available networks Provide an API that allows applications to request and select networks for their data
 traffic",,network info,network ,1,yes,no,SOURCE,no,
<android.text.SpannableStringBuilder: void clear()>,"Convenience for replace(0 length() """" 0 0).
 Note that this clears the text not the spans;
 use clearSpans() if you need that.",,void,1,"This is the class for text whose content is immutable but to which
 markup objects can be attached and detached.
 For mutable text see  SpannableStringBuilder .","Provides classes used to render or track text and text spans on the screen. You can use these classes to design your own widgets that manage text
 to handle arbitrary text spans for changes or to handle drawing yourself
 for an existing widget. The Span… interfaces and classes are used to create or manage spans of
 text in a View item. You can use these to style the text or background or to
 listen for changes. If creating your own widget extend DynamicLayout to manages
 the actual wrapping and drawing of your text.",no,no,0,no,no,no,no,
<android.bluetooth.BluetoothHealth: List getDevicesMatchingConnectionStates(int)>,"Get a list of devices that match any of the given connection
 states. If none of the devices match any of the given states
 an empty list will be returned. Requires Manifest.permission.BLUETOOTH permission.
 This is not specific to any application configuration but represents the connection
 state of the local Bluetooth adapter for this profile. This can be used
 by applications like status bar which would just like to know the state of the
 local adapter.",states int : Array of states. States can be one of BluetoothProfile.STATE_CONNECTED  BluetoothProfile.STATE_CONNECTING  BluetoothProfile.STATE_DISCONNECTED  BluetoothProfile.STATE_DISCONNECTING  |||,List < BluetoothDevice > List of devices. The list will be empty on error. |||,14,"Public API for Bluetooth Health Profile.

  BluetoothHealth is a proxy object for controlling the Bluetooth
 Service via IPC.

   How to connect to a health device which is acting in the source role.
   Use  BluetoothAdapter#getProfileProxy  to get
 the BluetoothHealth proxy object.   Create an  BluetoothHealth  callback and call
  registerSinkAppConfiguration(String int BluetoothHealthCallback)  to register an application
 configuration   Pair with the remote device. This currently needs to be done manually
 from Bluetooth Settings   Connect to a health device using  connectChannelToSource(BluetoothDevice BluetoothHealthAppConfiguration) . Some
 devices will connect the channel automatically. The  BluetoothHealth 
 callback will inform the application of channel state change.   Use the file descriptor provided with a connected channel to read and
 write data to the health channel.   The received data needs to be interpreted using a health manager which
 implements the IEEE 11073-xxxxx specifications.
   When done close the health channel by calling  disconnectChannel(BluetoothDevice BluetoothHealthAppConfiguration int) 
 and unregister the application configuration calling
  unregisterAppConfiguration(BluetoothHealthAppConfiguration)","Provides classes that manage Bluetooth functionality such as scanning for
 devices connecting with devices and managing data transfer between devices.
 The Bluetooth API supports both ""Classic Bluetooth"" and Bluetooth Low Energy. For more information about Classic Bluetooth see the
  Bluetooth  guide.
 For more information about Bluetooth Low Energy see the
  
 Bluetooth Low Energy  (BLE) guide. The Bluetooth APIs let applications: Scan for other Bluetooth devices (including BLE devices). Query the local Bluetooth adapter for paired Bluetooth devices. Establish RFCOMM channels/sockets. Connect to specified sockets on other devices. Transfer data to and from other devices. Communicate with BLE devices such as proximity sensors heart rate
     monitors fitness devices and so on. Act as a GATT client or a GATT server (BLE). 
 To perform Bluetooth communication using these APIs an application must
 declare the  BLUETOOTH  permission. Some
 additional functionality such as requesting device discovery
 also requires the  BLUETOOTH_ADMIN 
 permission.
  Note: 
 Not all Android-powered devices provide Bluetooth functionality.",bluetooth metadata,bluetooth,1,yes,no,SOURCE,no,
"<android.net.nsd.NsdServiceInfo: void writeToParcel(Parcel,int)>",Implement the Parcelable interface,"dest Parcel : The Parcel in which the object should be written. |||
flags int : Additional flags about how the object should be written.
May be 0 or Parcelable.PARCELABLE_WRITE_RETURN_VALUE .
Value is either 0 or a combination of Parcelable.PARCELABLE_WRITE_RETURN_VALUE and android.os.Parcelable.PARCELABLE_ELIDE_DUPLICATES |||",void,16,A class representing service information for network service discovery,,no,no,0,no,no,no,no,
"<android.text.method.ReplacementTransformationMethod: CharSequence getTransformation(CharSequence,View)>","Returns a CharSequence that will mirror the contents of the
 source CharSequence but with the characters in getOriginal() replaced by ones from getReplacement() .","source CharSequence |||
v View |||",CharSequence |||,1,"This transformation method causes the characters in the  getOriginal() 
 array to be replaced by the corresponding characters in the
  getReplacement()  array.","Provides classes that monitor or modify keypad input. You can use these classes to modify the type of keypad entry
 for your application or decipher the keypresses entered for your specific
 entry method. For example: 
 // Set the text to password display style:
 EditText txtView = (EditText)findViewById(R.id.text);
 txtView.setTransformationMethod(PasswordTransformationMethod.getInstance());

 //Set the input style to numbers rather than qwerty keyboard style.
 txtView.setInputMethod(DigitsInputMethod.getInstance());

 // Find out whether the caps lock is on.
 // 0 is no 1 is yes 2 is caps lock on.
 int active = MultiTapInputMethod.getCapsActive(txtView.getText());",uncategorized,UI,1,no,yes,no,SINK,
<android.content.res.Resources: XmlResourceParser getAnimation(int)>,"Return an XmlResourceParser through which you can read an animation
 description for the given resource ID.  This parser has limited
 functionality -- in particular you can't change its input and only
 the high-level events are available. This function is really a simple wrapper for calling getXml(int) with an animation resource.","id int : The desired resource identifier as generated by the aapt
tool. This integer encodes the package type and resource
entry. The value 0 is an invalid identifier. |||","XmlResourceParser A new parser object through which you can read
         the XML data.

 This value will never be null . |||",1,"Class for accessing an application's resources.  This sits on top of the
 asset manager of the application (accessible through  getAssets() ) and
 provides a high-level API for getting typed data from the assets.

  The Android resource system keeps track of all non-code assets associated with an
 application. You can use this class to access your application's resources. You can generally
 acquire the  Resources  instance associated with your application
 with  getResources() . The Android SDK tools compile your application's resources into the application binary
 at build time.  To use a resource you must install it correctly in the source tree (inside
 your project's  res/  directory) and build your application.  As part of the build
 process the SDK tools generate symbols for each resource which you can use in your application
 code to access the resources. Using application resources makes it easy to update various characteristics of your
 application without modifying code and—by providing sets of alternative
 resources—enables you to optimize your application for a variety of device configurations
 (such as for different languages and screen sizes). This is an important aspect of developing
 Android applications that are compatible on different types of devices. For more information about using resources see the documentation about  Application Resources .","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,
<android.speech.SpeechRecognizer: void startListening(Intent)>,"Starts listening for speech. Please note that setRecognitionListener(android.speech.RecognitionListener) should be called beforehand otherwise
 no notifications will be received.","recognizerIntent Intent : contains parameters for the recognition to be performed. The intent
may also contain optional extras see RecognizerIntent . If these values are
not set explicitly default values will be used by the recognizer. |||",void,8,"This class provides access to the speech recognition service. This service allows access to the
 speech recognizer. Do not instantiate this class directly instead call
  SpeechRecognizer#createSpeechRecognizer(Context) . This class's methods must be
 invoked only from the main application thread.

  The implementation of this API is likely to stream audio to remote servers to perform speech
 recognition. As such this API is not intended to be used for continuous recognition which would
 consume a significant amount of battery and bandwidth.

  Please note that the application must have  Manifest.permission.RECORD_AUDIO 
 permission to use this class.",,no,no,0,no,no,no,no,
"<android.os.DropBoxManager: void addFile(String,File,int)>",Stores the contents of a file which may be ignored or discarded as with addText(String String) .,"tag String : describing the type of entry being stored |||
file File : to read from |||
flags int : describing the data |||",void,8,"Enqueues chunks of data (from various sources -- application crashes kernel
 log records etc.).  The queue is size bounded and will drop old data if the
 enqueued data exceeds the maximum size.  You can think of this as a
 persistent system-wide blob-oriented ""logcat"".

  DropBoxManager entries are not sent anywhere directly but other system
 services and debugging tools may scan and upload entries for processing.",,no,file,0,no,no,no,no,
<android.widget.ViewAnimator: void showPrevious()>,Manually shows the previous child.,,void,1,"Base class for a  FrameLayout  container that will perform animations
 when switching between its views.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,no,0,no,no,no,no,
"<android.widget.ViewAnimator: void removeViews(int,int)>",Removes the specified range of views from the group. Note: do not invoke this method from View.draw(android.graphics.Canvas)  View.onDraw(android.graphics.Canvas)  dispatchDraw(android.graphics.Canvas) or any related method.,"start int : the first position in the group of the range of views to remove |||
count int : the number of views to remove |||",void,1,"Base class for a  FrameLayout  container that will perform animations
 when switching between its views.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,no,0,no,no,no,no,
<android.nfc.tech.MifareClassic: int getTimeout()>,Get the current transceive(byte[]) timeout in milliseconds. Requires the Manifest.permission.NFC permission.,,int timeout value in milliseconds |||,14,"Provides access to MIFARE Classic properties and I/O operations on a  Tag .

  Acquire a  MifareClassic  object using  get(Tag) .

  MIFARE Classic is also known as MIFARE Standard.
  MIFARE Classic tags are divided into sectors and each sector is sub-divided into
 blocks. Block size is always 16 bytes ( BLOCK_SIZE . Sector size varies.
  MIFARE Classic Mini are 320 bytes ( SIZE_MINI ) with 5 sectors each of 4 blocks.
  MIFARE Classic 1k are 1024 bytes ( SIZE_1K ) with 16 sectors each of 4 blocks.
  MIFARE Classic 2k are 2048 bytes ( SIZE_2K ) with 32 sectors each of 4 blocks.
  MIFARE Classic 4k are 4096 bytes ( SIZE_4K ). The first 32 sectors contain 4 blocks
 and the last 8 sectors contain 16 blocks.
  MIFARE Classic tags require authentication on a per-sector basis before any
 other I/O operations on that sector can be performed. There are two keys per sector
 and ACL bits determine what I/O operations are allowed on that sector after
 authenticating with a key.  and
 .

  Three well-known authentication keys are defined in this class:
  KEY_DEFAULT   KEY_MIFARE_APPLICATION_DIRECTORY 
  KEY_NFC_FORUM .
  KEY_DEFAULT  is the default factory key for MIFARE Classic.
  KEY_MIFARE_APPLICATION_DIRECTORY  is the well-known key for
 MIFARE Classic cards that have been formatted according to the
 MIFARE Application Directory (MAD) specification.
  KEY_NFC_FORUM  is the well-known key for MIFARE Classic cards that
 have been formatted according to the NXP specification for NDEF on MIFARE Classic.

  Implementation of this class on a Android NFC device is optional.
 If it is not implemented then
  MifareClassic  will never be enumerated in  Tag#getTechList .
 If it is enumerated then all  MifareClassic  I/O operations will be supported
 and  Ndef#MIFARE_CLASSIC  NDEF tags will also be supported. In either case
  NfcA  will also be enumerated on the tag because all MIFARE Classic tags are also
  NfcA .

  Note:  Methods that perform I/O operations
 require the  Manifest.permission.NFC  permission.","These classes provide access to a tag technology's features which vary by the type
 of tag that is scanned. A scanned tag can support multiple technologies and you can find
 out what they are by calling  getTechList() . For more information on dealing with tag technologies and handling the ones that you care about see
  The Tag Dispatch System .
 The  TagTechnology  interface provides an overview of the
 supported technologies.",nfc metadata,nfc,1,yes,no,SOURCE,no,
<android.app.Activity: void setContentView(View)>,"Set the activity content to an explicit view.  This view is placed
 directly into the activity's view hierarchy.  It can itself be a complex
 view hierarchy.  When calling this method the layout parameters of the
 specified view are ignored.  Both the width and the height of the view are
 set by default to ViewGroup.LayoutParams#MATCH_PARENT . To use
 your own layout parameters invoke setContentView(android.view.View android.view.ViewGroup.LayoutParams) instead.",view View : The desired content to display. |||,void,1,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",uncategorized,UI,1,no,yes,no,SINK,
"<android.animation.LayoutTransition: void addChild(ViewGroup,View)>","This method is called by ViewGroup when a child view is about to be added to the
 container. This callback starts the process of a transition; we grab the starting
 values listen for changes to all of the children of the container and start appropriate
 animations.","parent ViewGroup : The ViewGroup to which the View is being added. |||
child View : The View being added to the ViewGroup. |||",void,11,"This class enables automatic animations on layout changes in ViewGroup objects. To enable
 transitions for a layout container create a LayoutTransition object and set it on any
 ViewGroup by calling  ViewGroup#setLayoutTransition(LayoutTransition) . This will cause
 default animations to run whenever items are added to or removed from that container. To specify
 custom animations use the  LayoutTransition#setAnimator(int Animator)  method.

  One of the core concepts of these transition animations is that there are two types of
 changes that cause the transition and four different animations that run because of
 those changes. The changes that trigger the transition are items being added to a container
 (referred to as an ""appearing"" transition) or removed from a container (also known as
 ""disappearing""). Setting the visibility of views (between GONE and VISIBLE) will trigger
 the same add/remove logic. The animations that run due to those events are one that animates
 items being added one that animates items being removed and two that animate the other
 items in the container that change due to the add/remove occurrence. Users of
 the transition may want different animations for the changing items depending on whether
 they are changing due to an appearing or disappearing event so there is one animation for
 each of these variations of the changing event. Most of the API of this class is concerned
 with setting up the basic properties of the animations used in these four situations
 or with setting up custom animations for any or all of the four. By default the DISAPPEARING animation begins immediately as does the CHANGE_APPEARING
 animation. The other animations begin after a delay that is set to the default duration
 of the animations. This behavior facilitates a sequence of animations in transitions as
 follows: when an item is being added to a layout the other children of that container will
 move first (thus creating space for the new item) then the appearing animation will run to
 animate the item being added. Conversely when an item is removed from a container the
 animation to remove it will run first then the animations of the other children in the
 layout will run (closing the gap created in the layout when the item was removed). If this
 default choreography behavior is not desired the  setDuration(int long)  and
  setStartDelay(int long)  of any or all of the animations can be changed as
 appropriate. Keep in mind however that if you start an APPEARING animation before a
 DISAPPEARING animation is completed the DISAPPEARING animation stops and any effects from
 the DISAPPEARING animation are reverted. If you instead start a DISAPPEARING animation
 before an APPEARING animation is completed a similar set of effects occurs for the
 APPEARING animation. The animations specified for the transition both the defaults and any custom animations
 set on the transition object are templates only. That is these animations exist to hold the
 basic animation properties such as the duration start delay and properties being animated.
 But the actual target object as well as the start and end values for those properties are
 set automatically in the process of setting up the transition each time it runs. Each of the
 animations is cloned from the original copy and the clone is then populated with the dynamic
 values of the target being animated (such as one of the items in a layout container that is
 moving as a result of the layout event) as well as the values that are changing (such as the
 position and size of that object). The actual values that are pushed to each animation
 depends on what properties are specified for the animation. For example the default
 CHANGE_APPEARING animation animates the  left   top   right 
  bottom   scrollX  and  scrollY  properties.
 Values for these properties are updated with the pre- and post-layout
 values when the transition begins. Custom animations will be similarly populated with
 the target and values being animated assuming they use ObjectAnimator objects with
 property names that are known on the target object. This class and the associated XML flag for containers animateLayoutChanges=""true""
 provides a simple utility meant for automating changes in straightforward situations.
 Using LayoutTransition at multiple levels of a nested view hierarchy may not work due to the
 interrelationship of the various levels of layout. Also a container that is being scrolled
 at the same time as items are being added or removed is probably not a good candidate for
 this utility because the before/after locations calculated by LayoutTransition
 may not match the actual locations when the animations finish due to the container
 being scrolled as the animations are running. You can work around that
 particular issue by disabling the 'changing' animations by setting the CHANGE_APPEARING
 and CHANGE_DISAPPEARING animations to null and setting the startDelay of the
 other animations appropriately.","These classes provide functionality for the property animation system which allows you
 to animate object properties of any type.  int   float  and hexadecimal
 color values are supported by default. You can animate any other type by telling the system how
 to calculate the values for that given type with a custom  TypeEvaluator .
  For more information see the
  Animation  guide. 
 You can set many different types of interpolators (contained in  android.view.animation )
 specify  keyframes  or group animations to play sequentially
 or simultaneously (with  AnimatorSet ) to further control your animation
 behaviors.",uncategorized,callback,1,no,yes,no,SINK,
<android.app.AlertDialog: void setIconAttribute(int)>,Set an icon as supplied by a theme attribute. e.g. android.R.attr.alertDialogIcon,attrId int : ID of a theme attribute that points to a drawable resource. |||,void,11,"A subclass of Dialog that can display one two or three buttons. If you only want to
 display a String in this dialog box use the setMessage() method.  If you
 want to display a more complex view look up the FrameLayout called ""custom""
 and add your view to it:

  
 FrameLayout fl = findViewById(android.R.id.custom);
 fl.addView(myView new LayoutParams(MATCH_PARENT WRAP_CONTENT));
  The AlertDialog class takes care of automatically setting
  WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM  for you based on whether
 any views in the dialog return true from  View#onCheckIsTextEditor() .  Generally you want this set for a Dialog
 without text editors so that it will be placed on top of the current
 input method UI.  You can modify this behavior by forcing the flag to your
 desired mode after calling  onCreate(Bundle) .","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
<android.app.Notification: Notification clone()>,"Creates and returns a copy of this object.  The precise meaning
 of ""copy"" may depend on the class of the object. The general
 intent is that for any object x the expression: By convention the returned object should be obtained by calling super.clone .  If a class and all of its superclasses (except Object ) obey this convention it will be the case that x.clone().getClass() == x.getClass() . By convention the object returned by this method should be independent
 of this object (which is being cloned).  To achieve this independence
 it may be necessary to modify one or more fields of the object returned
 by super.clone before returning it.  Typically this means
 copying any mutable objects that comprise the internal ""deep structure""
 of the object being cloned and replacing the references to these
 objects with references to the copies.  If a class contains only
 primitive fields or references to immutable objects then it is usually
 the case that no fields in the object returned by super.clone need to be modified. The method clone for class Object performs a
 specific cloning operation. First if the class of this object does
 not implement the interface Cloneable then a CloneNotSupportedException is thrown. Note that all arrays
 are considered to implement the interface Cloneable and that
 the return type of the clone method of an array type T[] is T[] where T is any reference or primitive type.
 Otherwise this method creates a new instance of the class of this
 object and initializes all its fields with exactly the contents of
 the corresponding fields of this object as if by assignment; the
 contents of the fields are not themselves cloned. Thus this method
 performs a ""shallow copy"" of this object not a ""deep copy"" operation. The class Object does not itself implement the interface Cloneable so calling the clone method on an object
 whose class is Object will result in throwing an
 exception at run time.",,Notification a clone of this instance. |||,1,"A class that represents how a persistent notification is to be presented to
 the user using the  NotificationManager .

  The  Notification.Builder  has been added to make it
 easier to construct Notifications.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
"<android.content.ContentValues: void writeToParcel(Parcel,int)>",Flatten this object in to a Parcel.,"parcel Parcel : The Parcel in which the object should be written. |||
flags int : Additional flags about how the object should be written.
May be 0 or Parcelable.PARCELABLE_WRITE_RETURN_VALUE .
Value is either 0 or a combination of Parcelable.PARCELABLE_WRITE_RETURN_VALUE and android.os.Parcelable.PARCELABLE_ELIDE_DUPLICATES |||",void,1,"This class is used to store a set of values that the  ContentResolver 
 can process.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",IPC,no,0,no,no,no,no,
"<android.database.sqlite.SQLiteDatabase: Cursor rawQuery(String,String)>",Runs the provided SQL and returns a Cursor over the result set.,"sql String : the SQL query. The SQL string must not be ; terminated |||
selectionArgs String : You may include ?s in where clause in the query
which will be replaced by the values from selectionArgs. The
values will be bound as Strings. |||",Cursor A Cursor object which is positioned before the first entry. Note that Cursor s are not synchronized see the documentation for more details. |||,1,"Exposes methods to manage a SQLite database.

  
 SQLiteDatabase has methods to create delete execute SQL commands and
 perform other common database management tasks.
  
 See the Notepad sample application in the SDK for an example of creating
 and managing a database.
  
 Database names must be unique within an application not across all applications.
  Localized Collation - ORDER BY 
 In addition to SQLite's default  BINARY  collator Android supplies
 two more  LOCALIZED  which changes with the system's current locale
 and  UNICODE  which is the Unicode Collation Algorithm and not tailored
 to the current locale.","If you need to manage data in a private database use the  android.database.sqlite  classes. These classes are used to manage the  Cursor  object returned from a content provider query. Databases
 are usually created and opened with  openOrCreateDatabase(String int SQLiteDatabase.CursorFactory) 
 To make requests through
 content providers you can use the  content.ContentResolver  class.
  All databases are stored on the device in  /data/data/<package_name>/databases",database data,database,1,yes,no,SOURCE,no,
"<android.content.ContextWrapper: void startIntentSender(IntentSender,Intent,int,int,int,Bundle)>","Like startActivity(android.content.Intent android.os.Bundle) but taking a IntentSender
 to start.  If the IntentSender is for an activity that activity will be started
 as if you had called the regular startActivity(android.content.Intent) here; otherwise its associated action will be executed (such as
 sending a broadcast) as if you had called IntentSender#sendIntent on it.","intent IntentSender : The IntentSender to launch. |||
fillInIntent Intent : If non-null this will be provided as the
intent parameter to IntentSender#sendIntent .
This value may be null . |||
flagsMask int : Intent flags in the original IntentSender that you
would like to change.
Value is either 0 or a combination of Intent.FLAG_FROM_BACKGROUND  Intent.FLAG_DEBUG_LOG_RESOLUTION  Intent.FLAG_EXCLUDE_STOPPED_PACKAGES  Intent.FLAG_INCLUDE_STOPPED_PACKAGES android.content.Intent.FLAG_DEBUG_TRIAGED_MISSING android.content.Intent.FLAG_IGNORE_EPHEMERAL Intent.FLAG_ACTIVITY_MATCH_EXTERNAL  Intent.FLAG_ACTIVITY_NO_HISTORY  Intent.FLAG_ACTIVITY_SINGLE_TOP  Intent.FLAG_ACTIVITY_NEW_TASK  Intent.FLAG_ACTIVITY_MULTIPLE_TASK  Intent.FLAG_ACTIVITY_CLEAR_TOP  Intent.FLAG_ACTIVITY_FORWARD_RESULT  Intent.FLAG_ACTIVITY_PREVIOUS_IS_TOP  Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS  Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT  Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED  Intent.FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY  Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET  Intent.FLAG_ACTIVITY_NEW_DOCUMENT  Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET  Intent.FLAG_ACTIVITY_NO_USER_ACTION  Intent.FLAG_ACTIVITY_REORDER_TO_FRONT  Intent.FLAG_ACTIVITY_NO_ANIMATION  Intent.FLAG_ACTIVITY_CLEAR_TASK  Intent.FLAG_ACTIVITY_TASK_ON_HOME  Intent.FLAG_ACTIVITY_RETAIN_IN_RECENTS  Intent.FLAG_ACTIVITY_LAUNCH_ADJACENT  Intent.FLAG_RECEIVER_REGISTERED_ONLY  Intent.FLAG_RECEIVER_REPLACE_PENDING  Intent.FLAG_RECEIVER_FOREGROUND  Intent.FLAG_RECEIVER_NO_ABORT android.content.Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT android.content.Intent.FLAG_RECEIVER_BOOT_UPGRADE android.content.Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND android.content.Intent.FLAG_RECEIVER_EXCLUDE_BACKGROUND android.content.Intent.FLAG_RECEIVER_FROM_SHELL Intent.FLAG_RECEIVER_VISIBLE_TO_INSTANT_APPS and android.content.Intent.FLAG_RECEIVER_OFFLOAD |||
flagsValues int : Desired values for any bits set in flagsMask Value is either 0 or a combination of Intent.FLAG_FROM_BACKGROUND  Intent.FLAG_DEBUG_LOG_RESOLUTION  Intent.FLAG_EXCLUDE_STOPPED_PACKAGES  Intent.FLAG_INCLUDE_STOPPED_PACKAGES android.content.Intent.FLAG_DEBUG_TRIAGED_MISSING android.content.Intent.FLAG_IGNORE_EPHEMERAL Intent.FLAG_ACTIVITY_MATCH_EXTERNAL  Intent.FLAG_ACTIVITY_NO_HISTORY  Intent.FLAG_ACTIVITY_SINGLE_TOP  Intent.FLAG_ACTIVITY_NEW_TASK  Intent.FLAG_ACTIVITY_MULTIPLE_TASK  Intent.FLAG_ACTIVITY_CLEAR_TOP  Intent.FLAG_ACTIVITY_FORWARD_RESULT  Intent.FLAG_ACTIVITY_PREVIOUS_IS_TOP  Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS  Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT  Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED  Intent.FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY  Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET  Intent.FLAG_ACTIVITY_NEW_DOCUMENT  Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET  Intent.FLAG_ACTIVITY_NO_USER_ACTION  Intent.FLAG_ACTIVITY_REORDER_TO_FRONT  Intent.FLAG_ACTIVITY_NO_ANIMATION  Intent.FLAG_ACTIVITY_CLEAR_TASK  Intent.FLAG_ACTIVITY_TASK_ON_HOME  Intent.FLAG_ACTIVITY_RETAIN_IN_RECENTS  Intent.FLAG_ACTIVITY_LAUNCH_ADJACENT  Intent.FLAG_RECEIVER_REGISTERED_ONLY  Intent.FLAG_RECEIVER_REPLACE_PENDING  Intent.FLAG_RECEIVER_FOREGROUND  Intent.FLAG_RECEIVER_NO_ABORT android.content.Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT android.content.Intent.FLAG_RECEIVER_BOOT_UPGRADE android.content.Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND android.content.Intent.FLAG_RECEIVER_EXCLUDE_BACKGROUND android.content.Intent.FLAG_RECEIVER_FROM_SHELL Intent.FLAG_RECEIVER_VISIBLE_TO_INSTANT_APPS and android.content.Intent.FLAG_RECEIVER_OFFLOAD |||
extraFlags int : Always set to 0. |||
options Bundle : Additional options for how the Activity should be started.
See Context.startActivity(Intent Bundle) Context.startActivity(Intent Bundle)} for more details.  If options
have also been supplied by the IntentSender options given here will
override any that conflict with those given by the IntentSender.
This value may be null . |||",void,16,"Proxying implementation of Context that simply delegates all of its calls to
 another Context.  Can be subclassed to modify behavior without changing
 the original Context.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",IPC,IPC,1,no,yes,no,SINK,
"<android.content.ContentProvider: AssetFileDescriptor openTypedAssetFile(Uri,String,Bundle)>","Called by a client to open a read-only stream containing data of a
 particular MIME type.  This is like openAssetFile(android.net.Uri java.lang.String) except the file can only be read-only and the content provider may
 perform data conversions to generate data of the desired type. The default implementation compares the given mimeType against the
 result of getType(android.net.Uri) and if they match simply calls openAssetFile(android.net.Uri java.lang.String) . See ClipData for examples of the use and implementation
 of this method. The returned AssetFileDescriptor can be a pipe or socket pair to enable
 streaming of data. For better interoperability with other applications it is recommended
 that for any URIs that can be opened you also support queries on them
 containing at least the columns specified by OpenableColumns .
 You may also want to support other common columns if you have additional meta-data
 to supply such as MediaStore.MediaColumns.DATE_ADDED in MediaStore.MediaColumns .","uri Uri : The data in the content provider being queried.
This value must never be null . |||
mimeTypeFilter String : The type of data the client desires.  May be
a pattern such as */* if the caller does not have specific type
requirements; in this case the content provider will pick its best
type matching the pattern.
This value must never be null . |||
opts Bundle : Additional options from the client.  The definitions of
these are specific to the content provider being called.
This value may be null . |||","AssetFileDescriptor Returns a new AssetFileDescriptor from which the client can
 read data of the desired type.

 This value may be null . |||",11,"Content providers are one of the primary building blocks of Android applications providing
 content to applications. They encapsulate data and provide it to applications through the single
  ContentResolver  interface. A content provider is only required if you need to share
 data between multiple applications. For example the contacts data is used by multiple
 applications and must be stored in a content provider. If you don't need to share data amongst
 multiple applications you can use a database directly via
  SQLiteDatabase .

  When a request is made via
 a  ContentResolver  the system inspects the authority of the given URI and passes the
 request to the content provider registered with the authority. The content provider can interpret
 the rest of the URI however it wants. The  UriMatcher  class is helpful for parsing
 URIs. The primary methods that need to be implemented are:
  onCreate()  which is called to initialize the provider query(Uri String[] Bundle CancellationSignal)  which returns data to the caller insert(Uri ContentValues)  which inserts new data into the content provider update(Uri ContentValues String String[])  which updates existing data in the content provider delete(Uri String String[])  which deletes data from the content provider getType(Uri)  which returns the MIME type of data in the content provider Requests to  ContentResolver  are automatically forwarded to the appropriate
 ContentProvider instance so subclasses don't have to worry about the details of
 cross-process calls.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",file data,file,1,yes ,no,SOURCE,no,
<android.app.Dialog: void closeOptionsMenu()>,,,void,1,"Base class for Dialogs.

  Note: Activities provide a facility to manage the creation saving and
 restoring of dialogs. See  Activity#onCreateDialog(int) 
  Activity#onPrepareDialog(int Dialog) 
  Activity#showDialog(int)  and  Activity#dismissDialog(int) . If
 these methods are used  getOwnerActivity()  will return the Activity
 that managed this dialog.

  Often you will want to have a Dialog display on top of the current
 input method because there is no reason for it to accept text.  You can
 do this by setting the  WindowManager.LayoutParams#FLAG_ALT_FOCUSABLE_IM  window flag (assuming
 your Dialog takes input focus as it the default) with the following code:

  
 getWindow().setFlags(WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM
         WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
"<android.content.Intent: Intent putExtra(String,Parcelable)>","Add extended data to the intent.  The name must include a package
 prefix for example the app com.android.contacts would use names
 like ""com.android.contacts.ShowAll"".","name String : The name of the extra data with package prefix. |||
value Parcelable : The Parcelable data value.
This value may be null . |||","Intent Returns the same Intent object for chaining multiple calls
 into a single statement.

 This value will never be null . |||",1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",IPC,no,0,no,no,no,no,
"<android.security.KeyChain: PrivateKey getPrivateKey(Context,String)>","Returns the PrivateKey for the requested alias or null if the alias does not exist
 or the caller has no permission to access it (see note on exceptions below). This method may block while waiting for a connection to another process and must never
 be called from the main thread. As Activity and Service contexts are short-lived and can be destroyed
 at any time from the main thread it is safer to rely on a long-lived context such as one
 returned from Context#getApplicationContext() . If the caller provides a valid alias to which it was not granted access then the
 caller must invoke choosePrivateKeyAlias(Activity KeyChainAliasCallback String[] Principal[] Uri String) again to get another valid alias
 or a grant to access the same alias. On Android versions prior to Q when a key associated with the specified alias is
 unavailable the method will throw a KeyChainException rather than return null.
 If the exception's cause (as obtained by calling KeyChainException.getCause() )
 is a throwable of type IllegalStateException then the caller lacks a grant
 to access the key and certificates associated with this alias. This method may take several seconds to complete so it should
 only be called from a worker thread.","context Context : This value must never be null . |||
alias String : The alias of the desired private key typically returned via KeyChainAliasCallback#alias .
This value must never be null . |||",PrivateKey |||,14,"The  KeyChain  class provides access to private keys and
 their corresponding certificate chains in credential storage.

  Applications accessing the  KeyChain  normally go through
 these steps:

  Receive a callback from an  X509KeyManager  that a private key is requested.

  Call  choosePrivateKeyAlias  to allow the user to select from a
 list of currently available private keys and corresponding
 certificate chains. The chosen alias will be returned by the
 callback  KeyChainAliasCallback#alias  or null if no private
 key is available or the user cancels the request.

  Call  getPrivateKey(Context String)  and  getCertificateChain(Context String)  to
 retrieve the credentials to return to the corresponding  X509KeyManager  callbacks.

  An application may remember the value of a selected alias to
 avoid prompting the user with  choosePrivateKeyAlias  on subsequent connections. If the alias is
 no longer valid null will be returned on lookups using that value

  An application can request the installation of private keys and
 certificates via the  Intent  provided by  createInstallIntent() . Private keys installed via this  Intent  will be accessible via  choosePrivateKeyAlias(Activity KeyChainAliasCallback String[] Principal[] Uri String)  while
 Certificate Authority (CA) certificates will be trusted by all
 applications through the default  X509TrustManager .","Provides access to a few facilities of the Android security
     subsystems.",password data,password file ,1,yes,no,SOURCE,no,not sure
"<android.appwidget.AppWidgetManager: void updateAppWidget(int,RemoteViews)>","Set the RemoteViews to use for the specified appWidgetId. Note that the RemoteViews parameter will be cached by the AppWidgetService and hence should
 contain a complete representation of the widget. For performing partial widget updates see partiallyUpdateAppWidget(int android.widget.RemoteViews) . It is okay to call this method both inside an ACTION_APPWIDGET_UPDATE broadcast
 and outside of the handler.
 This method will only work when called from the uid that owns the AppWidget provider. The total Bitmap memory used by the RemoteViews object cannot exceed that required to
 fill the screen 1.5 times ie. (screen width x screen height x 4 x 1.5) bytes.","appWidgetId int : The AppWidget instance for which to set the RemoteViews. |||
views RemoteViews : The RemoteViews object to show. |||",void,3,"Updates AppWidget state; gets information about installed AppWidget providers and other
 AppWidget related state.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",uncategorized,UI,1,no,yes,no,SINK,
<android.bluetooth.BluetoothServerSocket: BluetoothSocket accept(int)>,"Block until a connection is established with timeout. Returns a connected BluetoothSocket on successful connection. Once this call returns it can be called again to accept subsequent
 incoming connections. close() can be used to abort this call from another thread.",timeout int |||,BluetoothSocket a connected BluetoothSocket |||,5,"A listening Bluetooth socket.

  The interface for Bluetooth Sockets is similar to that of TCP sockets:
  Socket  and  ServerSocket . On the server
 side use a  BluetoothServerSocket  to create a listening server
 socket. When a connection is accepted by the  BluetoothServerSocket 
 it will return a new  BluetoothSocket  to manage the connection.
 On the client side use a single  BluetoothSocket  to both initiate
 an outgoing connection and to manage the connection.

  For Bluetooth BR/EDR the most common type of socket is RFCOMM which is the type supported by
 the Android APIs. RFCOMM is a connection-oriented streaming transport over Bluetooth BR/EDR. It
 is also known as the Serial Port Profile (SPP). To create a listening
  BluetoothServerSocket  that's ready for incoming Bluetooth BR/EDR connections use  BluetoothAdapter#listenUsingRfcommWithServiceRecord .

  For Bluetooth LE the socket uses LE Connection-oriented Channel (CoC). LE CoC is a
 connection-oriented streaming transport over Bluetooth LE and has a credit-based flow control.
 Correspondingly use  BluetoothAdapter#listenUsingL2capChannel  to create a listening  BluetoothServerSocket 
 that's ready for incoming Bluetooth LE CoC connections. For LE CoC you can use  getPsm() 
 to get the protocol/service multiplexer (PSM) value that the peer needs to use to connect to your
 socket.

   After the listening  BluetoothServerSocket  is created call  accept()  to
 listen for incoming connection requests. This call will block until a connection is established
 at which point it will return a  BluetoothSocket  to manage the connection. Once the
  BluetoothSocket  is acquired it's a good idea to call  close()  on the  BluetoothServerSocket  when it's no longer needed for accepting
 connections. Closing the  BluetoothServerSocket  will  not  close the returned
  BluetoothSocket .

  BluetoothServerSocket  is thread
 safe. In particular  close()  will always immediately abort ongoing
 operations and close the server socket.

  Note: 
 Requires the  Manifest.permission.BLUETOOTH  permission.","Provides classes that manage Bluetooth functionality such as scanning for
 devices connecting with devices and managing data transfer between devices.
 The Bluetooth API supports both ""Classic Bluetooth"" and Bluetooth Low Energy. For more information about Classic Bluetooth see the
  Bluetooth  guide.
 For more information about Bluetooth Low Energy see the
  
 Bluetooth Low Energy  (BLE) guide. The Bluetooth APIs let applications: Scan for other Bluetooth devices (including BLE devices). Query the local Bluetooth adapter for paired Bluetooth devices. Establish RFCOMM channels/sockets. Connect to specified sockets on other devices. Transfer data to and from other devices. Communicate with BLE devices such as proximity sensors heart rate
     monitors fitness devices and so on. Act as a GATT client or a GATT server (BLE). 
 To perform Bluetooth communication using these APIs an application must
 declare the  BLUETOOTH  permission. Some
 additional functionality such as requesting device discovery
 also requires the  BLUETOOTH_ADMIN 
 permission.
  Note: 
 Not all Android-powered devices provide Bluetooth functionality.",bluetooth metadata,bluetooth,1,yes,no,SOURCE,no,
<android.inputmethodservice.InputMethodService: void sendKeyChar(char)>,"Send the given UTF-16 character to the current input connection.  Most
 characters will be delivered simply by calling InputConnection#commitText with
 the character; some however may be handled different.  In particular
 the enter character ('\n') will either be delivered as an action code
 or a raw key event as appropriate.  Consider this as a convenience
 method for IMEs that do not have a full implementation of actions; a
 fully complying IME will decide of the right action for each event and
 will likely never call this method except maybe to handle events coming
 from an actual hardware keyboard.",charCode char : The UTF-16 character code to send. |||,void,3,"InputMethodService provides a standard implementation of an InputMethod
 which final implementations can derive from and customize.  See the
 base class  AbstractInputMethodService  and the  InputMethod 
 interface for more information on the basics of writing input methods.

  In addition to the normal Service lifecycle methods this class
 introduces some new specific callbacks that most subclasses will want
 to make use of: onInitializeInterface()  for user-interface initialization
 in particular to deal with configuration changes while the service is
 running.
  onBindInput()  to find out about switching to a new client.
  onStartInput(EditorInfo boolean)  to deal with an input session starting with
 the client.
  onCreateInputView()   onCreateCandidatesView() 
 and  onCreateExtractTextView()  for non-demand generation of the UI.
  onStartInputView(android.view.inputmethod.EditorInfo boolean)  to deal with input
 starting within the input area of the IME.
  An input method has significant discretion in how it goes about its
 work: the  InputMethodService  provides
 a basic framework for standard UI elements (input view candidates view
 and running in fullscreen mode) but it is up to a particular implementor
 to decide how to use them.  For example one input method could implement
 an input area with a keyboard another could allow the user to draw text
 while a third could have no input area (and thus not be visible to the
 user) but instead listen to audio and perform text to speech conversion. In the implementation provided here all of these elements are placed
 together in a single window managed by the InputMethodService.  It will
 execute callbacks as it needs information about them and provides APIs for
 programmatic control over them.  They layout of these elements is explicitly
 defined: The soft input view if available is placed at the bottom of the
 screen.
  The candidates view if currently shown is placed above the soft
 input view.
  If not running fullscreen the application is moved or resized to be
 above these views; if running fullscreen the window will completely cover
 the application and its top part will contain the extract text of what is
 currently being edited by the application.
  Soft Input View Central to most input methods is the soft input view.  This is where most
 user interaction occurs: pressing on soft keys drawing characters or
 however else your input method wants to generate text.  Most implementations
 will simply have their own view doing all of this work and return a new
 instance of it when  onCreateInputView()  is called.  At that point
 as long as the input view is visible you will see user interaction in
 that view and can call back on the InputMethodService to interact with the
 application as appropriate. There are some situations where you want to decide whether or not your
 soft input view should be shown to the user.  This is done by implementing
 the  onEvaluateInputViewShown()  to return true or false based on
 whether it should be shown in the current environment.  If any of your
 state has changed that may impact this call
  updateInputViewShown()  to have it re-evaluated.  The default
 implementation always shows the input view unless there is a hard
 keyboard available which is the appropriate behavior for most input
 methods. Candidates View Often while the user is generating raw text an input method wants to
 provide them with a list of possible interpretations of that text that can
 be selected for use.  This is accomplished with the candidates view and
 like the soft input view you implement  onCreateCandidatesView() 
 to instantiate your own view implementing your candidates UI. Management of the candidates view is a little different than the input
 view because the candidates view tends to be more transient being shown
 only when there are possible candidates for the current text being entered
 by the user.  To control whether the candidates view is shown you use
  setCandidatesViewShown(boolean) .  Note that because the candidate
 view tends to be shown and hidden a lot it does not impact the application
 UI in the same way as the soft input view: it will never cause application
 windows to resize only cause them to be panned if needed for the user to
 see the current focus. Fullscreen Mode Sometimes your input method UI is too large to integrate with the
 application UI so you just want to take over the screen.  This is
 accomplished by switching to full-screen mode causing the input method
 window to fill the entire screen and add its own ""extracted text"" editor
 showing the user the text that is being typed.  Unlike the other UI elements
 there is a standard implementation for the extract editor that you should
 not need to change.  The editor is placed at the top of the IME above the
 input and candidates views. Similar to the input view you control whether the IME is running in
 fullscreen mode by implementing  onEvaluateFullscreenMode() 
 to return true or false based on
 whether it should be fullscreen in the current environment.  If any of your
 state has changed that may impact this call
  updateFullscreenMode()  to have it re-evaluated.  The default
 implementation selects fullscreen mode when the screen is in a landscape
 orientation which is appropriate behavior for most input methods that have
 a significant input area. When in fullscreen mode you have some special requirements because the
 user can not see the application UI.  In particular you should implement
  onDisplayCompletions(android.view.inputmethod.CompletionInfo[])  to show completions
 generated by your application typically in your candidates view like you
 would normally show candidates.


  Generating Text The key part of an IME is of course generating text for the application.
 This is done through calls to the
  InputConnection  interface to the
 application which can be retrieved from  getCurrentInputConnection() .
 This interface allows you to generate raw key events or if the target
 supports it directly edit in strings of candidates and committed text. Information about what the target is expected and supports can be found
 through the  EditorInfo  class which is
 retrieved with  getCurrentInputEditorInfo()  method.  The most
 important part of this is  EditorInfo.inputType ; in particular if this is
  EditorInfo.TYPE_NULL 
 then the target does not support complex edits and you need to only deliver
 raw key events to it.  An input method will also want to look at other
 values here to for example detect password mode auto complete text views
 phone number entry etc. When the user switches between input targets you will receive calls to
  onFinishInput()  and  onStartInput(android.view.inputmethod.EditorInfo boolean) .
 You can use these to reset and initialize your input state for the current
 target.  For example you will often want to clear any input state and
 update a soft keyboard to be appropriate for the new inputType.",,uncategorized,callback,1,no,yes,no,SINK,not sure
<android.net.sip.SipManager: SipSession getSessionFor(Intent)>,"Gets the SipSession that handles the incoming call. For audio
 calls consider to use SipAudioCall to handle the incoming call.
 See takeAudioCall(Intent SipAudioCall.Listener) . Note that the method may be called only once
 for the same intent. For subsequent calls on the same intent the method
 returns null.",incomingCallIntent Intent : the incoming call broadcast intent |||,SipSession the session object that handles the incoming call |||,9,"Provides APIs for SIP tasks such as initiating SIP connections and provides access to related
 SIP services. This class is the starting point for any SIP actions. You can acquire an instance
 of it with  newInstance() . The APIs in this class allows you to: Create a  SipSession  to get ready for making calls or listen for incoming calls. See
  createSipSession()  and  getSessionFor() . Initiate and receive generic SIP calls or audio-only SIP calls. Generic SIP calls may
 be video audio or other and are initiated with  open() . Audio-only SIP calls
 should be handled with a  SipAudioCall  which you can acquire with  makeAudioCall()  and  takeAudioCall() . Register and unregister with a SIP service provider with
       register()  and  unregister() . Verify session connectivity with  isOpened()  and
       isRegistered() . Note:  Not all Android-powered devices support VOIP calls using
 SIP. You should always call  isVoipSupported()  to verify that the device supports VOIP calling and  isApiSupported()  to verify that the device supports
 the SIP APIs. Your application must also request the  Manifest.permission.INTERNET  and  Manifest.permission.USE_SIP 
 permissions.",,network info,network ,1,yes,no,SOURCE,no,
<android.widget.TextView: void setPaintFlags(int)>,"Sets flags on the Paint being used to display the text and
 reflows the text if they are different from the old flags.",flags int |||,void,1,"A user interface element that displays text to the user.
 To provide user-editable text see  EditText .
  
 The following code sample shows a typical use with an XML layout
 and code to modify the contents of the text view:
  
 <LinearLayout
      xmlns:android=""http://schemas.android.com/apk/res/android""
      android:layout_width=""match_parent""
      android:layout_height=""match_parent"">
    <TextView
        android:id=""@+id/text_view_id""
        android:layout_height=""wrap_content""
        android:layout_width=""wrap_content""
        android:text=""@string/hello"" />
 </LinearLayout>
  
 This code sample demonstrates how to modify the contents of the text view
 defined in the previous XML layout:
  
 public class MainActivity extends Activity {

    protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_main);
         final TextView helloTextView = (TextView) findViewById(R.id.text_view_id);
         helloTextView.setText(R.string.user_greeting);
     }
 }
  
 To customize the appearance of TextView see  Styles and Themes .
  XML attributes 
 See  TextView Attributes 
  View Attributes","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,UI,0,no,no,no,no,
<android.widget.TabHost: void setCurrentTab(int)>,,index int |||,void,1,"Container for a tabbed window view. This object holds two children: a set of tab labels that the
 user clicks to select a specific tab and a FrameLayout object that displays the contents of that
 page. The individual elements are typically controlled using this container object rather than
 setting values on the child elements themselves.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,UI,0,no,no,no,no,
"<android.content.ClipData: ClipData newUri(ContentResolver,CharSequence,Uri)>","Create a new ClipData holding a URI.  If the URI is a content: URI
 this will query the content provider for the MIME type of its data and
 use that as the MIME type.  Otherwise it will use the MIME type ClipDescription#MIMETYPE_TEXT_URILIST .","resolver ContentResolver : ContentResolver used to get information about the URI. |||
label CharSequence : User-visible label for the clip data. |||
uri Uri : The URI in the clip. |||",ClipData Returns a new ClipData containing the specified data. |||,11,"Representation of a clipped data on the clipboard.

  ClipData is a complex type containing one or more Item instances
 each of which can hold one or more representations of an item of data.
 For display to the user it also has a label. A ClipData contains a  ClipDescription  which describes
 important meta-data about the clip.  In particular its
  ClipDescription#getMimeType(int) 
 must return correct MIME type(s) describing the data in the clip.  For help
 in correctly constructing a clip with the correct MIME type use
  newPlainText(java.lang.CharSequence java.lang.CharSequence) 
  newUri(android.content.ContentResolver java.lang.CharSequence android.net.Uri)  and
  newIntent(java.lang.CharSequence android.content.Intent) .

  Each Item instance can be one of three main classes of data: a simple
 CharSequence of text a single Intent object or a Uri.  See  Item 
 for more details.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",uncategorized,UI,1,no,yes,no,SINK,
<android.database.sqlite.SQLiteStatement: int executeUpdateDelete()>,"Execute this SQL statement if the number of rows affected by execution of this SQL
 statement is of any importance to the caller - for example UPDATE / DELETE SQL statements.",,int the number of rows affected by this SQL statement execution. |||,11,"Represents a statement that can be executed against a database.  The statement
 cannot return multiple rows or columns but single value (1 x 1) result sets
 are supported.
  
 This class is not thread-safe.","If you need to manage data in a private database use the  android.database.sqlite  classes. These classes are used to manage the  Cursor  object returned from a content provider query. Databases
 are usually created and opened with  openOrCreateDatabase(String int SQLiteDatabase.CursorFactory) 
 To make requests through
 content providers you can use the  content.ContentResolver  class.
  All databases are stored on the device in  /data/data/<package_name>/databases",no,database,0,no,no,no,no,
<android.location.LocationManager: void clearTestProviderEnabled(String)>,"This method was deprecated
      in API level 29. Use setTestProviderEnabled(java.lang.String boolean) instead. Equivalent to calling setTestProviderEnabled(java.lang.String boolean) to disable a test
 provider.",provider String : This value must never be null . |||,void,3,"A data class representing a geographic location.

  A location can consist of a latitude longitude timestamp
 and other information such as bearing altitude and velocity.

  All locations generated by the  LocationManager  are
 guaranteed to have a valid latitude longitude and timestamp
 (both UTC time and elapsed real-time since boot) all other
 parameters are optional.","Contains the framework API classes that define Android location-based and
 	related services. This API is not the recommended method for accessing Android location. 
 The
  Google Location Services API 
 part of Google Play services is the preferred way to add location-awareness to
 your app. It offers a simpler API higher accuracy low-power geofencing and
 more. If you are currently using the android.location API you are strongly
 encouraged to switch to the Google Location Services API as soon as
 possible.
  
 To learn more about the Google Location Services API see the
  Location API overview .",no,no,0,no,no,no,no,
<android.widget.ListView: void setRemoteViewsAdapter(Intent)>,"Sets up this AbsListView to use a remote views adapter which connects to a RemoteViewsService
 through the specified intent.",intent Intent : the intent used to identify the RemoteViewsService for the adapter to connect to. |||,void,11,"Displays a vertically-scrollable collection of views where each view is positioned
 immediatelybelow the previous view in the list.  For a more modern flexible and performant
 approach to displaying lists use  RecyclerView . To display a list you can include a list view in your layout XML file: <ListView
      android:id=""@+id/list_view""
      android:layout_width=""match_parent""
      android:layout_height=""match_parent"" /> A list view is an  
 adapter view  that does not know the details such as type and contents of the views it
 contains. Instead list view requests views on demand from a  ListAdapter  as needed
 such as to display new views as the user scrolls up or down. In order to display items in the list call  setAdapter(android.widget.ListAdapter) 
 to associate an adapter with the list.  For a simple example see the discussion of filling an
 adapter view with text in the
  
 Layouts  guide. To display a more custom view for each item in your dataset implement a ListAdapter.
 For example extend  BaseAdapter  and create and configure the view for each data item in
  getView(...) : private class MyAdapter extends BaseAdapter {

      // override other abstract methods here

      @Override
      public View getView(int position View convertView ViewGroup container) {
          if (convertView == null) {
              convertView = getLayoutInflater().inflate(R.layout.list_item container false);
          }

          ((TextView) convertView.findViewById(android.R.id.text1))
                  .setText(getItem(position));
          return convertView;
      }
  } ListView attempts to reuse view objects in order to improve performance and
 avoid a lag in response to user scrolls.  To take advantage of this feature check if the
  convertView  provided to  getView(...)  is null before creating or inflating a new
 view object.  See
  
 Making ListView Scrolling Smooth  for more ways to ensure a smooth user experience. To specify an action when a user clicks or taps on a single list item see
  
     Handling click events . To learn how to populate a list view with a CursorAdapter see the discussion of filling an
 adapter view with text in the
  
 Layouts  guide.
 See  
     Using a Loader 
 to learn how to avoid blocking the main thread when using a cursor. Note many examples use  ListActivity 
 or  ListFragment 
 to display a list view. Instead favor the more flexible approach when writing your own app:
 use a more generic Activity subclass or Fragment subclass and add a list view to the layout
 or view hierarchy directly.  This approach gives you more direct control of the
 list view and adapter.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",IPC,IPC,1,no,yes,no,SINK,
<android.webkit.WebViewFragment: void onPause()>,Called when the fragment is visible to the user and actively running. Resumes the WebView.,,void,11,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",no,no,0,no,no,no,no,
"<android.preference.PreferenceActivity: void startWithFragment(String,Bundle,Fragment,int)>",Like startWithFragment(java.lang.String android.os.Bundle android.app.Fragment int int int) but uses a 0 titleRes.,"fragmentName String |||
args Bundle |||
resultTo Fragment |||
resultRequestCode int |||",void,11,"This is the base class for an activity to show a hierarchy of preferences
 to the user.  Prior to  Build.VERSION_CODES.HONEYCOMB 
 this class only allowed the display of a single set of preference; this
 functionality should now be found in the new  PreferenceFragment 
 class.  If you are using PreferenceActivity in its old mode the documentation
 there applies to the deprecated APIs here.

  This activity shows one or more headers of preferences each of which
 is associated with a  PreferenceFragment  to display the preferences
 of that header.  The actual layout and display of these associations can
 however vary; currently there are two major approaches it may take:

  On a small screen it may display only the headers as a single list when first launched.
 Selecting one of the header items will only show the PreferenceFragment of that header (on
 Android N and lower a new Activity is launched).
  On a large screen it may display both the headers and current PreferenceFragment together as
 panes. Selecting a header item switches to showing the correct PreferenceFragment for that item.
  Subclasses of PreferenceActivity should implement
  onBuildHeaders(List )  to populate the header list with the desired
 items.  Doing this implicitly switches the class into its new ""headers
 + fragments"" mode rather than the old style of just showing a single
 preferences list.",,IPC,IPC,1,no,yes,no,SINK,
<android.nfc.tech.MifareClassic: void connect()>,"Enable I/O operations to the tag from this TagTechnology object. May cause RF activity and may block. Must not be called
 from the main application thread. A blocked call will be canceled with IOException by calling close() from another thread. Only one TagTechnology object can be connected to a Tag at a time. Applications must call close() when I/O operations are complete. Requires the Manifest.permission.NFC permission.",,void,-1,"Provides access to MIFARE Classic properties and I/O operations on a  Tag .

  Acquire a  MifareClassic  object using  get(Tag) .

  MIFARE Classic is also known as MIFARE Standard.
  MIFARE Classic tags are divided into sectors and each sector is sub-divided into
 blocks. Block size is always 16 bytes ( BLOCK_SIZE . Sector size varies.
  MIFARE Classic Mini are 320 bytes ( SIZE_MINI ) with 5 sectors each of 4 blocks.
  MIFARE Classic 1k are 1024 bytes ( SIZE_1K ) with 16 sectors each of 4 blocks.
  MIFARE Classic 2k are 2048 bytes ( SIZE_2K ) with 32 sectors each of 4 blocks.
  MIFARE Classic 4k are 4096 bytes ( SIZE_4K ). The first 32 sectors contain 4 blocks
 and the last 8 sectors contain 16 blocks.
  MIFARE Classic tags require authentication on a per-sector basis before any
 other I/O operations on that sector can be performed. There are two keys per sector
 and ACL bits determine what I/O operations are allowed on that sector after
 authenticating with a key.  and
 .

  Three well-known authentication keys are defined in this class:
  KEY_DEFAULT   KEY_MIFARE_APPLICATION_DIRECTORY 
  KEY_NFC_FORUM .
  KEY_DEFAULT  is the default factory key for MIFARE Classic.
  KEY_MIFARE_APPLICATION_DIRECTORY  is the well-known key for
 MIFARE Classic cards that have been formatted according to the
 MIFARE Application Directory (MAD) specification.
  KEY_NFC_FORUM  is the well-known key for MIFARE Classic cards that
 have been formatted according to the NXP specification for NDEF on MIFARE Classic.

  Implementation of this class on a Android NFC device is optional.
 If it is not implemented then
  MifareClassic  will never be enumerated in  Tag#getTechList .
 If it is enumerated then all  MifareClassic  I/O operations will be supported
 and  Ndef#MIFARE_CLASSIC  NDEF tags will also be supported. In either case
  NfcA  will also be enumerated on the tag because all MIFARE Classic tags are also
  NfcA .

  Note:  Methods that perform I/O operations
 require the  Manifest.permission.NFC  permission.","These classes provide access to a tag technology's features which vary by the type
 of tag that is scanned. A scanned tag can support multiple technologies and you can find
 out what they are by calling  getTechList() . For more information on dealing with tag technologies and handling the ones that you care about see
  The Tag Dispatch System .
 The  TagTechnology  interface provides an overview of the
 supported technologies.",no,nfc,0,no,no,no,no,
"<android.view.animation.LayoutAnimationController: void setInterpolator(Context,int)>","Sets the interpolator used to interpolate the delays between the
 children. Related XML Attributes: android:interpolator","context Context : the context from which the interpolator must be inflated |||
resourceID int : the resource identifier of the interpolator |||",void,1,"A layout animation controller is used to animated a layout's or a view
 group's children. Each child uses the same animation but for every one of
 them the animation starts at a different time. A layout animation controller
 is used by  ViewGroup  to compute the delay by which each
 child's animation start must be offset. The delay is computed by using
 characteristics of each child like its index in the view group.

 This standard implementation computes the delay by multiplying a fixed
 amount of miliseconds by the index of the child in its parent view group.
 Subclasses are supposed to override
  getDelayForView(android.view.View)  to implement a different way
 of computing the delay. For instance a
  GridLayoutAnimationController  will compute the
 delay based on the column and row indices of the child in its parent view
 group.

 Information used to compute the animation delay of each child are stored
 in an instance of
  LayoutAnimationController.AnimationParameters 
 itself stored in the  ViewGroup.LayoutParams  of the view.",,no,UI,0,no,no,no,no,
"<android.app.Activity: void triggerSearch(String,Bundle)>","Similar to startSearch(String boolean Bundle boolean) but actually fires off the search query after invoking
 the search dialog.  Made available for testing purposes.","query String : The query to trigger.  If empty the request will be ignored. |||
appSearchData Bundle : An application can insert application-specific
context here in order to improve quality or specificity of its own
searches.  This data will be returned with SEARCH intent(s).  Null if
no extra data is required.
This value may be null . |||",void,5,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,IPC,0,no,no,no,no,
"<android.view.animation.LayoutAnimationController: void setAnimation(Context,int)>","Sets the animation to be run on each child of the view group on which
 this layout animation controller is . Related XML Attributes: android:animation","context Context : the context from which the animation must be inflated |||
resourceID int : the resource identifier of the animation |||",void,1,"A layout animation controller is used to animated a layout's or a view
 group's children. Each child uses the same animation but for every one of
 them the animation starts at a different time. A layout animation controller
 is used by  ViewGroup  to compute the delay by which each
 child's animation start must be offset. The delay is computed by using
 characteristics of each child like its index in the view group.

 This standard implementation computes the delay by multiplying a fixed
 amount of miliseconds by the index of the child in its parent view group.
 Subclasses are supposed to override
  getDelayForView(android.view.View)  to implement a different way
 of computing the delay. For instance a
  GridLayoutAnimationController  will compute the
 delay based on the column and row indices of the child in its parent view
 group.

 Information used to compute the animation delay of each child are stored
 in an instance of
  LayoutAnimationController.AnimationParameters 
 itself stored in the  ViewGroup.LayoutParams  of the view.",,no,UI,0,no,no,no,no,
<android.animation.ObjectAnimator: void start()>,"Starts this animation. If the animation has a nonzero startDelay the animation will start
 running after that delay elapses. A non-delayed animation will have its initial
 value(s) set immediately followed by calls to AnimatorListener#onAnimationStart(Animator) for any listeners of this animator. The animation started by calling this method will be run on the thread that called
 this method. This thread should have a Looper on it (a runtime exception will be thrown if
 this is not the case). Also if the animation will animate
 properties of objects in the view hierarchy then the calling thread should be the UI
 thread for that view hierarchy.",,void,11,"This subclass of  ValueAnimator  provides support for animating properties on target objects.
 The constructors of this class take parameters to define the target object that will be animated
 as well as the name of the property that will be animated. Appropriate set/get functions
 are then determined internally and the animation will call these functions as necessary to
 animate the property.

  Animators can be created from either code or resource files as shown here: <objectAnimator xmlns:android=""http://schemas.android.com/apk/res/android""
    android:duration=""1000""
    android:valueTo=""200""
    android:valueType=""floatType""
    android:propertyName=""y""
    android:repeatCount=""1""
    android:repeatMode=""reverse""/> Starting from API 23 it is possible to use  PropertyValuesHolder  and
  Keyframe  in resource files to create more complex animations. Using PropertyValuesHolders
 allows animators to animate several properties in parallel as shown in this sample: <objectAnimator xmlns:android=""http://schemas.android.com/apk/res/android""
                android:duration=""1000""
                android:repeatCount=""1""
                android:repeatMode=""reverse"">
    <propertyValuesHolder android:propertyName=""x"" android:valueTo=""400""/>
    <propertyValuesHolder android:propertyName=""y"" android:valueTo=""200""/>
</objectAnimator> Using Keyframes allows animations to follow more complex paths from the start
 to the end values. Note that you can specify explicit fractional values (from 0 to 1) for
 each keyframe to determine when in the overall duration the animation should arrive at that
 value. Alternatively you can leave the fractions off and the keyframes will be equally
 distributed within the total duration. Also a keyframe with no value will derive its value
 from the target object when the animator starts just like animators with only one
 value specified. In addition an optional interpolator can be specified. The interpolator will
 be applied on the interval between the keyframe that the interpolator is set on and the previous
 keyframe. When no interpolator is supplied the default  AccelerateDecelerateInterpolator 
 will be used.  <propertyValuesHolder android:propertyName=""x"" >
    <keyframe android:fraction=""0"" android:value=""800"" />
    <keyframe android:fraction="".2""
              android:interpolator=""@android:anim/accelerate_interpolator""
              android:value=""1000"" />
    <keyframe android:fraction=""1""
              android:interpolator=""@android:anim/accelerate_interpolator""
              android:value=""400"" />
</propertyValuesHolder>
<propertyValuesHolder android:propertyName=""y"" >
    <keyframe/>
    <keyframe android:fraction="".2""
              android:interpolator=""@android:anim/accelerate_interpolator""
              android:value=""300""/>
    <keyframe android:interpolator=""@android:anim/accelerate_interpolator""
              android:value=""1000"" />
</propertyValuesHolder>","These classes provide functionality for the property animation system which allows you
 to animate object properties of any type.  int   float  and hexadecimal
 color values are supported by default. You can animate any other type by telling the system how
 to calculate the values for that given type with a custom  TypeEvaluator .
  For more information see the
  Animation  guide. 
 You can set many different types of interpolators (contained in  android.view.animation )
 specify  keyframes  or group animations to play sequentially
 or simultaneously (with  AnimatorSet ) to further control your animation
 behaviors.",no,no,0,no,no,no,no,
<android.view.KeyEvent: char getDisplayLabel()>,"Gets the primary character for this key.
 In other words the label that is physically printed on it.",,char The display label character or 0 if none (eg. for non-printing keys). |||,1,"Object used to report key and button events.
  
 Each key press is described by a sequence of key events.  A key press
 starts with a key event with  ACTION_DOWN .  If the key is held
 sufficiently long that it repeats then the initial down is followed
 additional key events with  ACTION_DOWN  and a non-zero value for
  getRepeatCount() .  The last key event is a  ACTION_UP 
 for the key up.  If the key press is canceled the key up event will have the
  FLAG_CANCELED  flag set.
  
 Key events are generally accompanied by a key code ( getKeyCode() )
 scan code ( getScanCode() ) and meta state ( getMetaState() ).
 Key code constants are defined in this class.  Scan code constants are raw
 device-specific codes obtained from the OS and so are not generally meaningful
 to applications unless interpreted using the  KeyCharacterMap .
 Meta states describe the pressed state of key modifiers
 such as  META_SHIFT_ON  or  META_ALT_ON .
  
 Key codes typically correspond one-to-one with individual keys on an input device.
 Many keys and key combinations serve quite different functions on different
 input devices so care must be taken when interpreting them.  Always use the
  KeyCharacterMap  associated with the input device when mapping keys
 to characters.  Be aware that there may be multiple key input devices active
 at the same time and each will have its own key character map.
  
 As soft input methods can use multiple and inventive ways of inputting text
 there is no guarantee that any key press on a soft keyboard will generate a key
 event: this is left to the IME's discretion and in fact sending such events is
 discouraged.  You should never rely on receiving KeyEvents for any key on a soft
 input method.  In particular the default software keyboard will never send any
 key event to any application targetting Jelly Bean or later and will only send
 events for some presses of the delete and return keys to applications targetting
 Ice Cream Sandwich or earlier.  Be aware that other software input methods may
 never send key events regardless of the version.  Consider using editor actions
 like  EditorInfo.IME_ACTION_DONE  if you need
 specific interaction with the software keyboard as it gives more visibility to
 the user as to how your application will react to key presses.
  
 When interacting with an IME the framework may deliver key events
 with the special action  ACTION_MULTIPLE  that either specifies
 that single repeated key code or a sequence of characters to insert.
  
 In general the framework cannot guarantee that the key events it delivers
 to a view always constitute complete key sequences since some events may be dropped
 or modified by containing views before they are delivered.  The view implementation
 should be prepared to handle  FLAG_CANCELED  and should tolerate anomalous
 situations such as receiving a new  ACTION_DOWN  without first having
 received an  ACTION_UP  for the prior key press.
  
 Refer to  InputDevice  for more information about how different kinds of
 input devices and sources represent keys and buttons.",,uncategorized,UI,1,yes,no,no,no,
<android.preference.TwoStatePreference: void setSummaryOff(int)>,,summaryResId int : The summary as a resource. |||,void,14,"Common base class for preferences that have two selectable states persist a
 boolean value in SharedPreferences and may have dependent preferences that are
 enabled/disabled based on the current state.",,no,no,0,no,no,no,no,
<android.widget.ShareActionProvider: void setShareHistoryFileName(String)>,"Sets the file name of a file for persisting the share history which
 history will be used for ordering share targets. This file will be used
 for all view created by onCreateActionView() . Defaults to DEFAULT_SHARE_HISTORY_FILE_NAME . Set to null if share history should not be persisted between sessions. Note: The history file name can be set any time however
 only the action views created by onCreateActionView() after setting
 the file name will be backed by the provided file. Therefore if you want to
 use different history files for sharing specific types of content every time
 you change the history file setShareHistoryFileName(java.lang.String) you must
 call Activity.invalidateOptionsMenu() to recreate the
 action view. You should not call Activity.invalidateOptionsMenu() from Activity.onCreateOptionsMenu(Menu) .",shareHistoryFile String : The share history file name. |||,void,14,"This is a provider for a share action. It is responsible for creating views
 that enable data sharing and also to show a sub menu with sharing activities
 if the hosting item is placed on the overflow menu.
  
 Here is how to use the action provider with custom backing file in a  MenuItem :
  
 // In Activity#onCreateOptionsMenu
 public boolean onCreateOptionsMenu(Menu menu) {
     // Get the menu item.
     MenuItem menuItem = menu.findItem(R.id.my_menu_item);
     // Get the provider and hold onto it to set/change the share intent.
     mShareActionProvider = (ShareActionProvider) menuItem.getActionProvider();
     // Set history different from the default before getting the action
     // view since a call to  MenuItem#getActionView()  calls
     //  ActionProvider#onCreateActionView()  which uses the backing file name. Omit this
     // line if using the default share history file is desired.
     mShareActionProvider.setShareHistoryFileName(""custom_share_history.xml"");
     . . .
 }

 // Somewhere in the application.
 public void doShare(Intent shareIntent) {
     // When you want to share set the share intent.
     mShareActionProvider.setShareIntent(shareIntent);
 } Note:  While the sample snippet demonstrates how to use this provider
 in the context of a menu item the use of the provider is not limited to menu items.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,no,0,no,no,no,no,
<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo findFocus(int)>,"Find the view that has the specified focus type. The search starts from
 the view represented by this node info.",focus int : The focus to find. One of FOCUS_INPUT or FOCUS_ACCESSIBILITY . |||,AccessibilityNodeInfo The node info of the focused view or null. |||,16,"This class represents a node of the window content as well as actions that
 can be requested from its source. From the point of view of an
  AccessibilityService  a window's content is
 presented as a tree of accessibility node infos which may or may not map one-to-one
 to the view hierarchy. In other words a custom view is free to report itself as
 a tree of accessibility node info.
  
 Once an accessibility node info is delivered to an accessibility service it is
 made immutable and calling a state mutation method generates an error.
  
 Please refer to  AccessibilityService  for
 details about how to obtain a handle to window content as a tree of accessibility
 node info as well as details about the security model.",,no,UI,0,no,no,no,no,
"<android.os.RecoverySystem: void installPackage(Context,File)>","Reboots the device in order to install the given update
 package.
 Requires the Manifest.permission.REBOOT permission. Requires android.Manifest.permission.RECOVERY","context Context : the Context to use |||
packageFile File : the update package to install.  Must be on
a partition mountable by recovery.  (The set of partitions
known to recovery may vary from device to device.  Generally
/cache and /data are safe.) |||",void,8,"RecoverySystem contains methods for interacting with the Android
 recovery system (the separate partition that can be used to install
 system updates wipe user data etc.)",,no,no,0,no,no,no,no,
<android.app.Application: void onConfigurationChanged(Configuration)>,"Called by the system when the device configuration changes while your
 component is running.  Note that unlike activities other components
 are never restarted when a configuration changes: they must always deal
 with the results of the change such as by re-retrieving resources. At the time that this function has been called your Resources
 object will have been updated to return resource values matching the
 new configuration. For more information read Handling Runtime Changes .
 
 If you override this method you must call through to the
 superclass implementation.",newConfig Configuration : This value must never be null . |||,void,1,"Base class for maintaining global application state. You can provide your own
 implementation by creating a subclass and specifying the fully-qualified name
 of this subclass as the  ""android:name""  attribute in your
 AndroidManifest.xml's  <application>  tag. The Application
 class or your subclass of the Application class is instantiated before any
 other class when the process for your application/package is created.

  Note:  There is normally no need to subclass
 Application.  In most situations static singletons can provide the same
 functionality in a more modular way.  If your singleton needs a global
 context (for example to register broadcast receivers) include
  Context.getApplicationContext() 
 as a  Context  argument when invoking your singleton's
  getInstance()  method.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,callback,0,no,no,no,no,
<android.inputmethodservice.InputMethodService: void requestHideSelf(int)>,"Close this input method's soft input area removing it from the display.

 The input method will continue running but the user can no longer use it to generate input
 by touching the screen.",flags int : Provides additional operating flags. |||,void,3,"InputMethodService provides a standard implementation of an InputMethod
 which final implementations can derive from and customize.  See the
 base class  AbstractInputMethodService  and the  InputMethod 
 interface for more information on the basics of writing input methods.

  In addition to the normal Service lifecycle methods this class
 introduces some new specific callbacks that most subclasses will want
 to make use of: onInitializeInterface()  for user-interface initialization
 in particular to deal with configuration changes while the service is
 running.
  onBindInput()  to find out about switching to a new client.
  onStartInput(EditorInfo boolean)  to deal with an input session starting with
 the client.
  onCreateInputView()   onCreateCandidatesView() 
 and  onCreateExtractTextView()  for non-demand generation of the UI.
  onStartInputView(android.view.inputmethod.EditorInfo boolean)  to deal with input
 starting within the input area of the IME.
  An input method has significant discretion in how it goes about its
 work: the  InputMethodService  provides
 a basic framework for standard UI elements (input view candidates view
 and running in fullscreen mode) but it is up to a particular implementor
 to decide how to use them.  For example one input method could implement
 an input area with a keyboard another could allow the user to draw text
 while a third could have no input area (and thus not be visible to the
 user) but instead listen to audio and perform text to speech conversion. In the implementation provided here all of these elements are placed
 together in a single window managed by the InputMethodService.  It will
 execute callbacks as it needs information about them and provides APIs for
 programmatic control over them.  They layout of these elements is explicitly
 defined: The soft input view if available is placed at the bottom of the
 screen.
  The candidates view if currently shown is placed above the soft
 input view.
  If not running fullscreen the application is moved or resized to be
 above these views; if running fullscreen the window will completely cover
 the application and its top part will contain the extract text of what is
 currently being edited by the application.
  Soft Input View Central to most input methods is the soft input view.  This is where most
 user interaction occurs: pressing on soft keys drawing characters or
 however else your input method wants to generate text.  Most implementations
 will simply have their own view doing all of this work and return a new
 instance of it when  onCreateInputView()  is called.  At that point
 as long as the input view is visible you will see user interaction in
 that view and can call back on the InputMethodService to interact with the
 application as appropriate. There are some situations where you want to decide whether or not your
 soft input view should be shown to the user.  This is done by implementing
 the  onEvaluateInputViewShown()  to return true or false based on
 whether it should be shown in the current environment.  If any of your
 state has changed that may impact this call
  updateInputViewShown()  to have it re-evaluated.  The default
 implementation always shows the input view unless there is a hard
 keyboard available which is the appropriate behavior for most input
 methods. Candidates View Often while the user is generating raw text an input method wants to
 provide them with a list of possible interpretations of that text that can
 be selected for use.  This is accomplished with the candidates view and
 like the soft input view you implement  onCreateCandidatesView() 
 to instantiate your own view implementing your candidates UI. Management of the candidates view is a little different than the input
 view because the candidates view tends to be more transient being shown
 only when there are possible candidates for the current text being entered
 by the user.  To control whether the candidates view is shown you use
  setCandidatesViewShown(boolean) .  Note that because the candidate
 view tends to be shown and hidden a lot it does not impact the application
 UI in the same way as the soft input view: it will never cause application
 windows to resize only cause them to be panned if needed for the user to
 see the current focus. Fullscreen Mode Sometimes your input method UI is too large to integrate with the
 application UI so you just want to take over the screen.  This is
 accomplished by switching to full-screen mode causing the input method
 window to fill the entire screen and add its own ""extracted text"" editor
 showing the user the text that is being typed.  Unlike the other UI elements
 there is a standard implementation for the extract editor that you should
 not need to change.  The editor is placed at the top of the IME above the
 input and candidates views. Similar to the input view you control whether the IME is running in
 fullscreen mode by implementing  onEvaluateFullscreenMode() 
 to return true or false based on
 whether it should be fullscreen in the current environment.  If any of your
 state has changed that may impact this call
  updateFullscreenMode()  to have it re-evaluated.  The default
 implementation selects fullscreen mode when the screen is in a landscape
 orientation which is appropriate behavior for most input methods that have
 a significant input area. When in fullscreen mode you have some special requirements because the
 user can not see the application UI.  In particular you should implement
  onDisplayCompletions(android.view.inputmethod.CompletionInfo[])  to show completions
 generated by your application typically in your candidates view like you
 would normally show candidates.


  Generating Text The key part of an IME is of course generating text for the application.
 This is done through calls to the
  InputConnection  interface to the
 application which can be retrieved from  getCurrentInputConnection() .
 This interface allows you to generate raw key events or if the target
 supports it directly edit in strings of candidates and committed text. Information about what the target is expected and supports can be found
 through the  EditorInfo  class which is
 retrieved with  getCurrentInputEditorInfo()  method.  The most
 important part of this is  EditorInfo.inputType ; in particular if this is
  EditorInfo.TYPE_NULL 
 then the target does not support complex edits and you need to only deliver
 raw key events to it.  An input method will also want to look at other
 values here to for example detect password mode auto complete text views
 phone number entry etc. When the user switches between input targets you will receive calls to
  onFinishInput()  and  onStartInput(android.view.inputmethod.EditorInfo boolean) .
 You can use these to reset and initialize your input state for the current
 target.  For example you will often want to clear any input state and
 update a soft keyboard to be appropriate for the new inputType.",,no,no,0,no,no,no,no,
"<android.app.Instrumentation: void sendStatus(int,Bundle)>",Provide a status report about the application.,"resultCode int : Current success/failure of instrumentation. |||
results Bundle : Any results to send back to the code that started the instrumentation. |||",void,1,"Base class for implementing application instrumentation code.  When running
 with instrumentation turned on this class will be instantiated for you
 before any of the application code allowing you to monitor all of the
 interaction the system has with the application.  An Instrumentation
 implementation is described to the system through an AndroidManifest.xml's
 <instrumentation> tag.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",IPC,no,0,no,no,no,no,
"<android.provider.Browser: void sendString(Context,String)>","Sends the given string using an Intent with Intent#ACTION_SEND and a mime type
 of text/plain. The string is put into Intent#EXTRA_TEXT .","context Context : the context used to start the activity |||
string String : the string to send |||",void,1,,"Provides convenience classes to access the content providers supplied by
 Android. Android ships with a number of content providers that store common data such
 as contact informations calendar information and media files. These classes
 provide simplified methods of adding or retrieving data from these content
 providers. For information about how to use a content provider see the  Content Providers  developer
 guide.",uncategorized,network ,1,no,yes,no,SINK,
"<android.content.ContentProvider: void attachInfo(Context,ProviderInfo)>","After being instantiated this is called to tell the content provider
 about itself.","context Context : The context this provider is running in |||
info ProviderInfo : Registered information about this content provider |||",void,1,"Content providers are one of the primary building blocks of Android applications providing
 content to applications. They encapsulate data and provide it to applications through the single
  ContentResolver  interface. A content provider is only required if you need to share
 data between multiple applications. For example the contacts data is used by multiple
 applications and must be stored in a content provider. If you don't need to share data amongst
 multiple applications you can use a database directly via
  SQLiteDatabase .

  When a request is made via
 a  ContentResolver  the system inspects the authority of the given URI and passes the
 request to the content provider registered with the authority. The content provider can interpret
 the rest of the URI however it wants. The  UriMatcher  class is helpful for parsing
 URIs. The primary methods that need to be implemented are:
  onCreate()  which is called to initialize the provider query(Uri String[] Bundle CancellationSignal)  which returns data to the caller insert(Uri ContentValues)  which inserts new data into the content provider update(Uri ContentValues String String[])  which updates existing data in the content provider delete(Uri String String[])  which deletes data from the content provider getType(Uri)  which returns the MIME type of data in the content provider Requests to  ContentResolver  are automatically forwarded to the appropriate
 ContentProvider instance so subclasses don't have to worry about the details of
 cross-process calls.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,database,0,no,no,no,no,
<android.webkit.WebView: void stopLoading()>,Stops the current load.,,void,1,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",no,no,0,no,no,no,no,
"<android.app.Activity: void startActivityFromChild(Activity,Intent,int,Bundle)>","This method was deprecated
      in API level R. Use androidx.fragment.app.FragmentActivity#startActivityFromFragment(
 androidx.fragment.app.FragmentIntentintBundle) This is called when a child activity of this one calls its startActivity(Intent) or startActivityForResult(Intent int) method. This method throws ActivityNotFoundException if there was no Activity found to run the given Intent.","child Activity : The activity making the call.
This value must never be null . |||
intent Intent : The intent to start. |||
requestCode int : Reply request code.  < 0 if reply is not requested. |||
options Bundle : Additional options for how the Activity should be started.
See Context.startActivity(Intent Bundle) Context.startActivity(Intent Bundle)} for more details.
This value may be null . |||",void,16,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",IPC,IPC,1,no,yes,no,SINK,
"<android.app.WallpaperManager: void suggestDesiredDimensions(int,int)>","For use only by the current home application to specify the size of
 wallpaper it would like to use.  This allows such applications to have
 a virtual wallpaper that is larger than the physical screen matching
 the size of their workspace. Calling this method from apps other than the active
 home app is not guaranteed to work properly.  Other apps that supply
 wallpaper imagery should use getDesiredMinimumWidth() and getDesiredMinimumHeight() and construct a wallpaper that
 matches those dimensions. This method requires the caller to hold the permission Manifest.permission.SET_WALLPAPER_HINTS .","minimumWidth int : Desired minimum width |||
minimumHeight int : Desired minimum height |||",void,5,"Provides access to the system wallpaper. With WallpaperManager you can
 get the current wallpaper get the desired dimensions for the wallpaper set
 the wallpaper and more.

   An app can check whether wallpapers are supported for the current user by calling
  isWallpaperSupported()  and whether setting of wallpapers is allowed by calling
  isSetWallpaperAllowed() .","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
<android.app.WallpaperManager: void clear()>,"Remove any currently set system wallpaper reverting to the system's built-in
 wallpaper. On success the intent Intent#ACTION_WALLPAPER_CHANGED is broadcast. This method requires the caller to hold the permission Manifest.permission.SET_WALLPAPER . Requires Manifest.permission.SET_WALLPAPER",,void,5,"Provides access to the system wallpaper. With WallpaperManager you can
 get the current wallpaper get the desired dimensions for the wallpaper set
 the wallpaper and more.

   An app can check whether wallpapers are supported for the current user by calling
  isWallpaperSupported()  and whether setting of wallpapers is allowed by calling
  isSetWallpaperAllowed() .","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
<android.view.View: AccessibilityNodeInfo createAccessibilityNodeInfo()>,"Returns an AccessibilityNodeInfo representing this view from the
 point of view of an AccessibilityService .
 This method is responsible for obtaining an accessibility node info from a
 pool of reusable instances and calling onInitializeAccessibilityNodeInfo(android.view.accessibility.AccessibilityNodeInfo) on this view to
 initialize the former. Note: The client is responsible for recycling the obtained instance by calling AccessibilityNodeInfo#recycle() to minimize object creation.",,AccessibilityNodeInfo A populated AccessibilityNodeInfo . |||,14,"This class represents the basic building block for user interface components. A View
 occupies a rectangular area on the screen and is responsible for drawing and
 event handling. View is the base class for  widgets  which are
 used to create interactive UI components (buttons text fields etc.). The
  ViewGroup  subclass is the base class for  layouts  which
 are invisible containers that hold other Views (or other ViewGroups) and define
 their layout properties.",,no,no,0,no,no,no,no,
"<android.test.AndroidTestRunner: void setTestClassName(String,String)>",,"testClassName String |||
testMethodName String |||",void,1,,,no,no,0,no,no,no,no,
"<android.app.Activity: void setFeatureDrawableUri(int,Uri)>",Convenience for calling Window.setFeatureDrawableUri(int Uri) .,"featureId int |||
uri Uri |||",void,1,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,UI,0,no,no,no,no,
<android.view.TextureView: Bitmap getBitmap(Bitmap)>,"Copies the content of this view's surface texture into the specified
 bitmap. If the surface texture is not available the copy is not executed.
 The content of the surface texture will be scaled to fit exactly inside
 the specified bitmap. Do not invoke this method from a drawing method
 ( onDraw(android.graphics.Canvas) for instance). If an error occurs the bitmap is left unchanged.","bitmap Bitmap : The bitmap to copy the content of the surface texture into
cannot be null all configurations are supported
This value must never be null . |||",Bitmap The bitmap specified as a parameter |||,14,"A TextureView can be used to display a content stream. Such a content
 stream can for instance be a video or an OpenGL scene. The content stream
 can come from the application's process as well as a remote process. TextureView can only be used in a hardware accelerated window. When
 rendered in software TextureView will draw nothing. Unlike  SurfaceView  TextureView does not create a separate
 window but behaves as a regular View. This key difference allows a
 TextureView to be moved transformed animated etc. For instance you
 can make a TextureView semi-translucent by calling
  myView.setAlpha(0.5f) . Using a TextureView is simple: all you need to do is get its
  SurfaceTexture . The  SurfaceTexture  can then be used to
 render content. The following example demonstrates how to render the
 camera preview into a TextureView: 
  public class LiveCameraActivity extends Activity implements TextureView.SurfaceTextureListener {
      private Camera mCamera;
      private TextureView mTextureView;

      protected void onCreate(Bundle savedInstanceState) {
          super.onCreate(savedInstanceState);

          mTextureView = new TextureView(this);
          mTextureView.setSurfaceTextureListener(this);

          setContentView(mTextureView);
      }

      public void onSurfaceTextureAvailable(SurfaceTexture surface int width int height) {
          mCamera = Camera.open();

          try {
              mCamera.setPreviewTexture(surface);
              mCamera.startPreview();
          } catch (IOException ioe) {
              // Something bad happened
          }
      }

      public void onSurfaceTextureSizeChanged(SurfaceTexture surface int width int height) {
          // Ignored Camera does all the work for us
      }

      public boolean onSurfaceTextureDestroyed(SurfaceTexture surface) {
          mCamera.stopPreview();
          mCamera.release();
          return true;
      }

      public void onSurfaceTextureUpdated(SurfaceTexture surface) {
          // Invoked every time there's a new Camera preview frame
      }
  }
  A TextureView's SurfaceTexture can be obtained either by invoking
  getSurfaceTexture()  or by using a  SurfaceTextureListener .
 It is important to know that a SurfaceTexture is available only after the
 TextureView is attached to a window (and  onAttachedToWindow()  has
 been invoked.) It is therefore highly recommended you use a listener to
 be notified when the SurfaceTexture becomes available. It is important to note that only one producer can use the TextureView.
 For instance if you use a TextureView to display the camera preview you
 cannot use  lockCanvas()  to draw onto the TextureView at the same
 time.",,image,UI,1,yes,no,SOURCE,no,
"<android.view.animation.AnimationUtils: LayoutAnimationController loadLayoutAnimation(Context,int)>",Loads a LayoutAnimationController object from a resource,"context Context : Application context used to access resources |||
id int : The resource id of the animation to load |||",LayoutAnimationController The animation controller object referenced by the specified id |||,1,"Abstraction for an Animation that can be applied to Views Surfaces or
 other objects. See the  animation package
 description file .",,no,UI,0,no,no,no,no,
"<android.widget.SimpleAdapter: void setViewImage(ImageView,String)>","Called by bindView() to set the image for an ImageView but only if
 there is no existing ViewBinder or if the existing ViewBinder cannot
 handle binding to an ImageView.

 By default the value will be treated as an image resource. If the
 value cannot be used as an image resource the value is used as an
 image Uri.

 This method is called instead of setViewImage(android.widget.ImageView int) if the supplied data is not an int or Integer.","v ImageView : ImageView to receive an image |||
value String : the value retrieved from the data set |||",void,1,"An easy adapter to map static data to views defined in an XML file. You can specify the data
 backing the list as an ArrayList of Maps. Each entry in the ArrayList corresponds to one row
 in the list. The Maps contain the data for each row. You also specify an XML file that
 defines the views used to display the row and a mapping from keys in the Map to specific
 views.

 Binding data to views occurs in two phases. First if a
  SimpleAdapter.ViewBinder  is available
  ViewBinder#setViewValue(android.view.View Object String) 
 is invoked. If the returned value is true binding has occurred.
 If the returned value is false the following views are then tried in order:
   A view that implements Checkable (e.g. CheckBox).  The expected bind value is a boolean.
   TextView.  The expected bind value is a string and  setViewText(android.widget.TextView java.lang.String) 
 is invoked.
   ImageView. The expected bind value is a resource id or a string and
  setViewImage(android.widget.ImageView int)  or  setViewImage(android.widget.ImageView java.lang.String)  is invoked.
  IllegalStateException","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",image,UI,1,no,yes,no,SINK,
<android.view.InputDevice: Vibrator getVibrator()>,"Gets the vibrator service associated with the device if there is one.
 Even if the device does not have a vibrator the result is never null.
 Use Vibrator#hasVibrator to determine whether a vibrator is
 present.

 Note that the vibrator associated with the device may be different from
 the system vibrator.  To obtain an instance of the system vibrator instead call Context#getSystemService with Context#VIBRATOR_SERVICE as argument.",,Vibrator The vibrator service associated with the device never null. |||,16,"Describes the capabilities of a particular input device.
  
 Each input device may support multiple classes of input.  For example a multi-function
 keyboard may compose the capabilities of a standard keyboard together with a track pad mouse
 or other pointing device.
  
 Some input devices present multiple distinguishable sources of input.
 Applications can query the framework about the characteristics of each distinct source.
  
 As a further wrinkle different kinds of input sources uses different coordinate systems
 to describe motion events.  Refer to the comments on the input source constants for
 the appropriate interpretation.",,no,input device,0,no,no,no,no,
<android.widget.DialerFilter: void setFilterWatcher(TextWatcher)>,,watcher TextWatcher |||,void,1,"This widget is a layout that contains several specifically-named child views that
 handle keyboard entry interpreted as standard phone dialpad digits.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,no,0,no,no,no,no,
<android.app.admin.DevicePolicyManager: void removeActiveAdmin(ComponentName)>,"Remove a current administration component.  This can only be called
 by the application that owns the administration component; if you
 try to remove someone else's component a security exception will be
 thrown. Note that the operation is not synchronous and the admin might still be active (as
 indicated by getActiveAdmins() ) by the time this method returns.","admin ComponentName : The administration compononent to remove.
This value must never be null . |||",void,8,"Public interface for managing policies enforced on a device. Most clients of this class must be
 registered with the system as a  device
 administrator . Additionally a device administrator may be registered as either a profile or
 device owner. A given method is accessible to all device administrators unless the documentation
 for that method specifies that it is restricted to either device or profile owners. Any
 application calling an api may only pass as an argument a device administrator component it
 owns. Otherwise a  SecurityException  will be thrown.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
"<android.net.wifi.p2p.WifiP2pGroup: void writeToParcel(Parcel,int)>",Implement the Parcelable interface,"dest Parcel : The Parcel in which the object should be written. |||
flags int : Additional flags about how the object should be written.
May be 0 or Parcelable.PARCELABLE_WRITE_RETURN_VALUE .
Value is either 0 or a combination of Parcelable.PARCELABLE_WRITE_RETURN_VALUE and android.os.Parcelable.PARCELABLE_ELIDE_DUPLICATES |||",void,14,"A class representing a Wi-Fi P2p group. A p2p group consists of a single group
 owner and one or more clients. In the case of a group with only two devices one
 will be the group owner and the other will be a group client.","Provides classes to create peer-to-peer (P2P) connections with Wi-Fi Direct. Using these APIs you can discover and connect to other devices when each
 device supports Wi-Fi Direct then communicate over a speedy connection across distances much longer
 than a Bluetooth connection. The primary class you need to work with is  WifiP2pManager  which you can acquire by calling  getSystemService(WIFI_P2P_SERVICE) . The  WifiP2pManager  includes APIs that allow you to: Initialize your application for P2P connections by calling  initialize() Discover nearby devices by calling  discoverPeers() Start a P2P connection by calling  connect() And more Several other interfaces and classes are necessary as well such as: The  WifiP2pManager.ActionListener  interface allows you to receive
 callbacks when an operation such as discovering peers or connecting to them succeeds or fails. WifiP2pManager.PeerListListener  interface allows you to receive
 information about discovered peers. The callback provides a  WifiP2pDeviceList  from which you can retrieve a  WifiP2pDevice  object for each device within range and get information such as
 the device name address device type the WPS configurations the device supports and more. The  WifiP2pManager.GroupInfoListener  interface allows you to
 receive information about a P2P group. The callback provides a  WifiP2pGroup  object which provides group information such as the owner the
 network name and passphrase. WifiP2pManager.ConnectionInfoListener  interface allows you to
 receive information about the current connection. The callback provides a  WifiP2pInfo  object which has information such as whether a group has been
 formed and who is the group owner. In order to use the Wi-Fi P2P APIs your app must request the following user permissions: ACCESS_WIFI_STATE CHANGE_WIFI_STATE INTERNET  (although your app doesn’t technically connect
 to the Internet communicating to Wi-Fi Direct peers with standard java sockets requires Internet
 permission). For example code see the  Wi-Fi
 Direct Demo  sample application. Note:  Not all Android-powered devices support Wi-Fi
 Direct. If your application uses Wi-Fi Direct declare so with a  <uses-feature> 
 element in the manifest file: 
 <manifest ...>
     <uses-feature android:name=""android.hardware.wifi.direct"" />
     ...
 </manifest>",IPC,no,0,no,no,no,no,
"<android.widget.Switch: void onMeasure(int,int)>","Measure the view and its content to determine the measured width and the
 measured height. This method is invoked by measure(int int) and
 should be overridden by subclasses to provide accurate and efficient
 measurement of their contents. CONTRACT: When overriding this method you must call setMeasuredDimension(int int) to store the
 measured width and height of this view. Failure to do so will trigger an IllegalStateException thrown by measure(int int) . Calling the superclass' onMeasure(int int) is a valid use. The base class implementation of measure defaults to the background size
 unless a larger size is allowed by the MeasureSpec. Subclasses should
 override onMeasure(int int) to provide better measurements of
 their content. If this method is overridden it is the subclass's responsibility to make
 sure the measured height and width are at least the view's minimum height
 and width ( getSuggestedMinimumHeight() and getSuggestedMinimumWidth() ).","widthMeasureSpec int : horizontal space requirements as imposed by the parent.
The requirements are encoded with View.MeasureSpec . |||
heightMeasureSpec int : vertical space requirements as imposed by the parent.
The requirements are encoded with View.MeasureSpec . |||",void,14,"A Switch is a two-state toggle switch widget that can select between two
 options. The user may drag the ""thumb"" back and forth to choose the selected option
 or simply tap to toggle as if it were a checkbox. The  text 
 property controls the text displayed in the label for the switch whereas the
  off  and  on  text
 controls the text on the thumb. Similarly the
  textAppearance  and the related
 setTypeface() methods control the typeface and style of label text whereas the
  switchTextAppearance  and
 the related setSwitchTypeface() methods control that of the thumb.

  SwitchCompat  is a version of
 the Switch widget which runs on devices back to API 7. See the  Toggle Buttons 
 guide.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,callback,0,no,no,no,no,
<android.database.sqlite.SQLiteDatabase: void beginTransactionNonExclusive()>,"Begins a transaction in IMMEDIATE mode. Transactions can be nested. When
 the outer transaction is ended all of the work done in that transaction
 and all of the nested transactions will be committed or rolled back. The
 changes will be rolled back if any transaction is ended without being
 marked as clean (by calling setTransactionSuccessful). Otherwise they
 will be committed. Here is the standard idiom for transactions:",,void,11,"Exposes methods to manage a SQLite database.

  
 SQLiteDatabase has methods to create delete execute SQL commands and
 perform other common database management tasks.
  
 See the Notepad sample application in the SDK for an example of creating
 and managing a database.
  
 Database names must be unique within an application not across all applications.
  Localized Collation - ORDER BY 
 In addition to SQLite's default  BINARY  collator Android supplies
 two more  LOCALIZED  which changes with the system's current locale
 and  UNICODE  which is the Unicode Collation Algorithm and not tailored
 to the current locale.","If you need to manage data in a private database use the  android.database.sqlite  classes. These classes are used to manage the  Cursor  object returned from a content provider query. Databases
 are usually created and opened with  openOrCreateDatabase(String int SQLiteDatabase.CursorFactory) 
 To make requests through
 content providers you can use the  content.ContentResolver  class.
  All databases are stored on the device in  /data/data/<package_name>/databases",no,database,0,no,no,no,no,
<android.app.ListFragment: void setListAdapter(ListAdapter)>,Provide the cursor for the list view.,adapter ListAdapter |||,void,11,"A fragment that displays a list of items by binding to a data source such as
 an array or Cursor and exposes event handlers when the user selects an item.
  
 ListFragment hosts a  ListView  object that can
 be bound to different data sources typically either an array or a Cursor
 holding query results. Binding screen layout and row layout are discussed
 in the following sections.
  Screen Layout 
 ListFragment has a default layout that consists of a single list view.
 However if you desire you can customize the fragment layout by returning
 your own view hierarchy from  onCreateView(LayoutInflater ViewGroup Bundle) .
 To do this your view hierarchy  must  contain a ListView object with the
 id ""@android:id/list"" (or  R.id.list  if it's in code)
  
 Optionally your view hierarchy can contain another view object of any type to
 display when the list view is empty. This ""empty list"" notifier must have an
 id ""android:empty"". Note that when an empty view is present the list view
 will be hidden when there is no data to display.
  
 The following code demonstrates an (ugly) custom list layout. It has a list
 with a green background and an alternate red ""no data"" message.
  
 <?xml version=""1.0"" encoding=""utf-8""?>
 <LinearLayout xmlns:android=""http://schemas.android.com/apk/res/android""
         android:orientation=""vertical""
         android:layout_width=""match_parent""
         android:layout_height=""match_parent""
         android:paddingLeft=""8dp""
         android:paddingRight=""8dp"">

     <ListView android:id=""@id/android:list""
               android:layout_width=""match_parent""
               android:layout_height=""match_parent""
               android:background=""#00FF00""
               android:layout_weight=""1""
               android:drawSelectorOnTop=""false""/>

     <TextView android:id=""@id/android:empty""
               android:layout_width=""match_parent""
               android:layout_height=""match_parent""
               android:background=""#FF0000""
               android:text=""No data""/>
 </LinearLayout>
  Row Layout 
 You can specify the layout of individual rows in the list. You do this by
 specifying a layout resource in the ListAdapter object hosted by the fragment
 (the ListAdapter binds the ListView to the data; more on this later).
  
 A ListAdapter constructor takes a parameter that specifies a layout resource
 for each row. It also has two additional parameters that let you specify
 which data field to associate with which object in the row layout resource.
 These two parameters are typically parallel arrays.
  
 Android provides some standard row layout resources. These are in the
  R.layout  class and have names such as simple_list_item_1
 simple_list_item_2 and two_line_list_item. The following layout XML is the
 source for the resource two_line_list_item which displays two data
 fieldsone above the other for each list row.
  
 <?xml version=""1.0"" encoding=""utf-8""?>
 <LinearLayout xmlns:android=""http://schemas.android.com/apk/res/android""
     android:layout_width=""match_parent""
     android:layout_height=""wrap_content""
     android:orientation=""vertical"">

     <TextView android:id=""@+id/text1""
         android:textSize=""16sp""
         android:textStyle=""bold""
         android:layout_width=""match_parent""
         android:layout_height=""wrap_content""/>

     <TextView android:id=""@+id/text2""
         android:textSize=""16sp""
         android:layout_width=""match_parent""
         android:layout_height=""wrap_content""/>
 </LinearLayout>
  
 You must identify the data bound to each TextView object in this layout. The
 syntax for this is discussed in the next section.
  Binding to Data 
 You bind the ListFragment's ListView object to data using a class that
 implements the  ListAdapter  interface.
 Android provides two standard list adapters:
  SimpleAdapter  for static data (Maps)
 and  SimpleCursorAdapter  for Cursor
 query results.
  
 You  must  use
  ListFragment.setListAdapter()  to
 associate the list with an adapter.  Do not directly call
  ListView#setAdapter(ListAdapter)  or else
 important initialization will be skipped.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",uncategorized,UI,1,no,yes,no,SINK,"Are ""Adapter""s uncategorized sensitive data?"
<android.test.TouchUtils: void dragQuarterScreenDown(ActivityInstrumentationTestCase)>,"This method was deprecated
      in API level 15. ActivityInstrumentationTestCase is deprecated in favor of ActivityInstrumentationTestCase2 which provides more options for
 configuring the Activity under test Simulate touching in the center of the screen and dragging one quarter of the way down",test ActivityInstrumentationTestCase : The test case that is being run |||,void,1,"Reusable methods for generating touch events. These methods can be used with
 InstrumentationTestCase or ActivityInstrumentationTestCase2 to simulate user interaction with
 the application through a touch screen.",,no,no,0,no,no,no,no,
<android.widget.TimePicker: void setIs24HourView(Boolean)>,"Sets whether this widget displays time in 24-hour mode or 12-hour mode
 with an AM/PM picker.","is24HourView Boolean : true to display in 24-hour mode false for 12-hour mode with AM/PM
This value must never be null . |||",void,1,"A widget for selecting the time of day in either 24-hour or AM/PM mode.
  
 For a dialog using this view see  TimePickerDialog . See
 the  Pickers 
 guide for more information.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,no,0,no,no,no,no,
"<android.app.admin.DevicePolicyManager: void setKeyguardDisabledFeatures(ComponentName,int)>","Called by an application that is administering the device to disable keyguard customizations
 such as widgets. After setting this keyguard features will be disabled according to the
 provided feature list. The calling device admin must have requested DeviceAdminInfo#USES_POLICY_DISABLE_KEYGUARD_FEATURES to be able to call this method;
 if it has not a security exception will be thrown. Calling this from a managed profile before version Build.VERSION_CODES.M will throw a security exception. From version Build.VERSION_CODES.M the
 profile owner of a managed profile can set: KEYGUARD_DISABLE_TRUST_AGENTS which affects the parent user but only if there
 is no separate challenge set on the managed profile. 
KEYGUARD_DISABLE_FINGERPRINT  KEYGUARD_DISABLE_FACE or KEYGUARD_DISABLE_IRIS which affects the managed profile challenge if
 there is one or the parent user otherwise. 
KEYGUARD_DISABLE_UNREDACTED_NOTIFICATIONS which affects notifications generated
 by applications in the managed profile. 
From version Build.VERSION_CODES.R the profile owner of an
 organization-owned managed profile can set: KEYGUARD_DISABLE_SECURE_CAMERA which affects the parent user when called on the
 parent profile. 
KEYGUARD_DISABLE_SECURE_NOTIFICATIONS which affects the parent user when called
 on the parent profile. 
Requests to disable other features on a managed profile will be ignored. The admin can check which features have been disabled by calling getKeyguardDisabledFeatures(android.content.ComponentName)","admin ComponentName : Which DeviceAdminReceiver this request is associated with.
This value must never be null . |||
which int : The disabled features flag which can be either KEYGUARD_DISABLE_FEATURES_NONE (default) KEYGUARD_DISABLE_FEATURES_ALL or a combination of KEYGUARD_DISABLE_WIDGETS_ALL  KEYGUARD_DISABLE_SECURE_CAMERA  KEYGUARD_DISABLE_SECURE_NOTIFICATIONS  KEYGUARD_DISABLE_TRUST_AGENTS  KEYGUARD_DISABLE_UNREDACTED_NOTIFICATIONS  KEYGUARD_DISABLE_FINGERPRINT  KEYGUARD_DISABLE_FACE  KEYGUARD_DISABLE_IRIS . |||",void,17,"Public interface for managing policies enforced on a device. Most clients of this class must be
 registered with the system as a  device
 administrator . Additionally a device administrator may be registered as either a profile or
 device owner. A given method is accessible to all device administrators unless the documentation
 for that method specifies that it is restricted to either device or profile owners. Any
 application calling an api may only pass as an argument a device administrator component it
 owns. Otherwise a  SecurityException  will be thrown.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
<android.content.res.Resources: AssetFileDescriptor openRawResourceFd(int)>,"Open a file descriptor for reading a raw resource.  This can only be used
 with resources whose value is the name of an asset files -- that is it can be
 used to open drawable sound and raw resources; it will fail on string
 and color resources. This function only works for resources that are stored in the package
 as uncompressed data which typically includes things like mp3 files
 and png images.",id int : The resource identifier to open as generated by the aapt tool. |||,"AssetFileDescriptor AssetFileDescriptor A new file descriptor you can use to read
 the resource.  This includes the file descriptor itself as well as the
 offset and length of data where the resource appears in the file.  A
 null is returned if the file exists but is compressed. |||",1,"Class for accessing an application's resources.  This sits on top of the
 asset manager of the application (accessible through  getAssets() ) and
 provides a high-level API for getting typed data from the assets.

  The Android resource system keeps track of all non-code assets associated with an
 application. You can use this class to access your application's resources. You can generally
 acquire the  Resources  instance associated with your application
 with  getResources() . The Android SDK tools compile your application's resources into the application binary
 at build time.  To use a resource you must install it correctly in the source tree (inside
 your project's  res/  directory) and build your application.  As part of the build
 process the SDK tools generate symbols for each resource which you can use in your application
 code to access the resources. Using application resources makes it easy to update various characteristics of your
 application without modifying code and—by providing sets of alternative
 resources—enables you to optimize your application for a variety of device configurations
 (such as for different languages and screen sizes). This is an important aspect of developing
 Android applications that are compatible on different types of devices. For more information about using resources see the documentation about  Application Resources .","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",file data,no,0,no,no,no,no,
<android.test.AndroidTestRunner: void runTest()>,,,void,1,,,no,no,0,no,no,no,no,
<android.view.View: void setVisibility(int)>,Set the visibility state of this view. Related XML Attributes: android:visibility,"visibility int : One of VISIBLE  INVISIBLE or GONE .
Value is VISIBLE  INVISIBLE or GONE |||",void,1,"This class represents the basic building block for user interface components. A View
 occupies a rectangular area on the screen and is responsible for drawing and
 event handling. View is the base class for  widgets  which are
 used to create interactive UI components (buttons text fields etc.). The
  ViewGroup  subclass is the base class for  layouts  which
 are invisible containers that hold other Views (or other ViewGroups) and define
 their layout properties.",,no,no,0,no,no,no,no,
"<android.media.MediaPlayer: void setDataSource(Context,Uri,Map)>","Sets the data source as a content Uri. Note that the cross domain redirection is allowed by default
 but that can be changed with key/value pairs through the headers parameter with
 ""android-allow-cross-domain-redirect"" as the key and ""0"" or ""1"" as the value to
 disallow or allow cross domain redirection.","context Context : the Context to use when resolving the Uri
This value must never be null . |||
uri Uri : the Content URI of the data you want to play
This value must never be null . |||
headers Map : the headers to be sent together with the request for the data
This value may be null . |||",void,14,"MediaPlayer class can be used to control playback
 of audio/video files and streams. An example on how to use the methods in
 this class can be found in  VideoView .

  Topics covered here are:
  State Diagram Valid and Invalid States Permissions Register informational and error callbacks","The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",file data,media,1,no,no,no,no,
"<android.content.Intent: short getShortExtra(String,short)>",Retrieve extended data from the intent.,"name String : The name of the desired item. |||
defaultValue short : the value to be returned if no value of the desired
type is stored with the given name. |||","short the value of an item previously added with putExtra()
 or the default value if none was found. |||",1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",IPC,no,0,no,no,no,no,
<android.app.Dialog: void registerForContextMenu(View)>,,view View : This value must never be null . |||,void,1,"Base class for Dialogs.

  Note: Activities provide a facility to manage the creation saving and
 restoring of dialogs. See  Activity#onCreateDialog(int) 
  Activity#onPrepareDialog(int Dialog) 
  Activity#showDialog(int)  and  Activity#dismissDialog(int) . If
 these methods are used  getOwnerActivity()  will return the Activity
 that managed this dialog.

  Often you will want to have a Dialog display on top of the current
 input method because there is no reason for it to accept text.  You can
 do this by setting the  WindowManager.LayoutParams#FLAG_ALT_FOCUSABLE_IM  window flag (assuming
 your Dialog takes input focus as it the default) with the following code:

  
 getWindow().setFlags(WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM
         WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",uncategorized,UI,1,no,no,no,no,
"<android.view.FocusFinder: View findNearestTouchable(ViewGroup,int,int,int,int)>",Find the nearest touchable view to the specified view.,"root ViewGroup : The root of the tree in which to search |||
x int : X coordinate from which to start the search |||
y int : Y coordinate from which to start the search |||
direction int : Direction to look |||
deltas int : Offset from the to the edge of the nearest view. Note that this array
may already be populated with values. |||",View The nearest touchable view or null if none exists. |||,1,"The algorithm used for finding the next focusable view in a given direction
 from a view that currently has focus.",,no,UI,0,no,no,no,no,
"<android.content.pm.ApplicationInfo: void writeToParcel(Parcel,int)>",,"dest Parcel |||
parcelableFlags int |||",void,1,"Information you can retrieve about a particular application.  This
 corresponds to information collected from the AndroidManifest.xml's
 <application> tag.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",IPC,no,0,no,no,no,no,
"<android.net.sip.SipSession: void answerCall(String,int)>","Answers an incoming call with the specified session description. The
 method is only valid to call when the session state is in State#INCOMING_CALL .","sessionDescription String : the session description to answer this call |||
timeout int : the session will be timed out if the call is not
established within timeout seconds. Default value (defined
by SIP protocol) is used if timeout is zero or negative. |||",void,9,"Represents a SIP session that is associated with a SIP dialog or a standalone
 transaction not within a dialog.
  You can get a  SipSession  from  SipManager  with  SipManager#createSipSession  (when initiating calls) or  SipManager#getSessionFor  (when receiving calls).",,no,phon,0,no,no,no,no,
"<android.view.animation.AnimationUtils: Interpolator loadInterpolator(Context,int)>",Loads an Interpolator object from a resource,"context Context : Application context used to access resources |||
id int : The resource id of the animation to load |||",Interpolator The interpolator object referenced by the specified id |||,1,"Abstraction for an Animation that can be applied to Views Surfaces or
 other objects. See the  animation package
 description file .",,no,UI,0,no,no,no,no,
"<android.content.Intent: Intent putExtra(String,float)>","Add extended data to the intent.  The name must include a package
 prefix for example the app com.android.contacts would use names
 like ""com.android.contacts.ShowAll"".","name String : The name of the extra data with package prefix. |||
value float : The float array data value.
This value may be null . |||","Intent Returns the same Intent object for chaining multiple calls
 into a single statement.

 This value will never be null . |||",1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",IPC,no,0,no,no,no,no,
"<android.content.Intent: Intent putIntegerArrayListExtra(String,ArrayList)>","Add extended data to the intent.  The name must include a package
 prefix for example the app com.android.contacts would use names
 like ""com.android.contacts.ShowAll"".","name String : The name of the extra data with package prefix. |||
value ArrayList : The ArrayList data value.
This value may be null . |||","Intent Returns the same Intent object for chaining multiple calls
 into a single statement.

 This value will never be null . |||",1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",IPC,no,0,no,no,no,no,
<android.widget.DialerFilter: void append(String)>,,text String |||,void,1,"This widget is a layout that contains several specifically-named child views that
 handle keyboard entry interpreted as standard phone dialpad digits.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",uncategorized,UI,1,no,yes,no,SINK,Example of when code was useful
<android.content.ContextWrapper: File getExternalFilesDir(String)>,"Returns the absolute path to the directory on the primary shared/external
 storage device where the application can place persistent files it owns.
 These files are internal to the applications and not typically visible
 to the user as media. This is like getFilesDir() in that these files will be deleted
 when the application is uninstalled however there are some important
 differences: Shared storage may not always be available since removable media can
 be ejected by the user. Media state can be checked using Environment#getExternalStorageState(File) . 
There is no security enforced with these files. For example any
 application holding Manifest.permission.WRITE_EXTERNAL_STORAGE can write to
 these files. 
If a shared storage device is emulated (as determined by Environment#isExternalStorageEmulated(File) ) it's contents are
 backed by a private user data partition which means there is little
 benefit to storing data here instead of the private directories returned
 by getFilesDir() etc. Starting in Build.VERSION_CODES.KITKAT no permissions
 are required to read or write to the returned path; it's always
 accessible to the calling app. This only applies to paths generated for
 package name of the calling application. To access paths belonging to
 other packages Manifest.permission.WRITE_EXTERNAL_STORAGE and/or Manifest.permission.READ_EXTERNAL_STORAGE are required. On devices with multiple users (as described by UserManager )
 each user has their own isolated shared storage. Applications only have
 access to the shared storage for the user they're running as. The returned path may change over time if different shared storage media
 is inserted so only relative paths should be persisted. Here is an example of typical code to manipulate a file in an
 application's shared storage: If you supply a non-null type to this function the returned
 file will be a path to a sub-directory of the given type. Though these
 files are not automatically scanned by the media scanner you can
 explicitly add them to the media database with MediaScannerConnection.scanFile . Note that this is not the same as Environment.getExternalStoragePublicDirectory() which provides
 directories of media shared by all applications. The directories returned
 here are owned by the application and their contents will be removed
 when the application is uninstalled. Unlike Environment.getExternalStoragePublicDirectory() the directory returned
 here will be automatically created for you. Here is an example of typical code to manipulate a picture in an
 application's shared storage and add it to the media database:","type String : The type of files directory to return. May be null for the root of the files directory or one of the following
constants for a subdirectory: Environment.DIRECTORY_MUSIC  Environment.DIRECTORY_PODCASTS  Environment.DIRECTORY_RINGTONES  Environment.DIRECTORY_ALARMS  Environment.DIRECTORY_NOTIFICATIONS  Environment.DIRECTORY_PICTURES or Environment.DIRECTORY_MOVIES .
This value may be null . |||",File the absolute path to application-specific directory. May return null if shared storage is not currently available. |||,8,"Proxying implementation of Context that simply delegates all of its calls to
 another Context.  Can be subclassed to modify behavior without changing
 the original Context.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,
"<android.content.ContentResolver: void removePeriodicSync(Account,String,Bundle)>","Remove a periodic sync. Has no affect if account authority and extras don't match
 an existing periodic sync. This method requires the caller to hold the permission Manifest.permission.WRITE_SYNC_SETTINGS .","account Account : the account of the periodic sync to remove |||
authority String : the provider of the periodic sync to remove |||
extras Bundle : the extras of the periodic sync to remove |||",void,8,This class provides applications access to the content model.,"Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,
<android.bluetooth.BluetoothHeadset: List getDevicesMatchingConnectionStates(int)>,"Get a list of devices that match any of the given connection
 states. If none of the devices match any of the given states
 an empty list will be returned. Requires Manifest.permission.BLUETOOTH",states int : Array of states. States can be one of BluetoothProfile.STATE_CONNECTED  BluetoothProfile.STATE_CONNECTING  BluetoothProfile.STATE_DISCONNECTED  BluetoothProfile.STATE_DISCONNECTING  |||,List < BluetoothDevice > List of devices. The list will be empty on error. |||,11,"Public API for controlling the Bluetooth Headset Service. This includes both
 Bluetooth Headset and Handsfree (v1.5) profiles.

  BluetoothHeadset is a proxy object for controlling the Bluetooth Headset
 Service via IPC.

   Use  BluetoothAdapter#getProfileProxy  to get
 the BluetoothHeadset proxy object. Use
  BluetoothAdapter#closeProfileProxy  to close the service connection.

   Android only supports one connected Bluetooth Headset at a time.
 Each method is protected with its appropriate permission.","Provides classes that manage Bluetooth functionality such as scanning for
 devices connecting with devices and managing data transfer between devices.
 The Bluetooth API supports both ""Classic Bluetooth"" and Bluetooth Low Energy. For more information about Classic Bluetooth see the
  Bluetooth  guide.
 For more information about Bluetooth Low Energy see the
  
 Bluetooth Low Energy  (BLE) guide. The Bluetooth APIs let applications: Scan for other Bluetooth devices (including BLE devices). Query the local Bluetooth adapter for paired Bluetooth devices. Establish RFCOMM channels/sockets. Connect to specified sockets on other devices. Transfer data to and from other devices. Communicate with BLE devices such as proximity sensors heart rate
     monitors fitness devices and so on. Act as a GATT client or a GATT server (BLE). 
 To perform Bluetooth communication using these APIs an application must
 declare the  BLUETOOTH  permission. Some
 additional functionality such as requesting device discovery
 also requires the  BLUETOOTH_ADMIN 
 permission.
  Note: 
 Not all Android-powered devices provide Bluetooth functionality.",input metadata,input device,1,yes,no,SOURCE,no,
<android.widget.DialerFilter: void removeFilterWatcher(TextWatcher)>,,watcher TextWatcher |||,void,1,"This widget is a layout that contains several specifically-named child views that
 handle keyboard entry interpreted as standard phone dialpad digits.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,no,0,no,no,no,no,
<android.net.wifi.WifiManager: int addNetwork(WifiConfiguration)>,"This method was deprecated
      in API level 29. a) See WifiNetworkSpecifier.Builder#build() for new
 mechanism to trigger connection to a Wi-Fi network.
 b) See addNetworkSuggestions(java.util.List)  removeNetworkSuggestions(java.util.List) for new API to add Wi-Fi networks for consideration
 when auto-connecting to wifi. Compatibility Note: For applications targeting Build.VERSION_CODES.Q or above this API will always fail and return -1 . Deprecation Exemptions: Device Owner (DO) Profile Owner (PO) and system apps. 
Add a new network description to the set of configured networks.
 The networkId field of the supplied configuration object
 is ignored.","config WifiConfiguration : the set of variables that describe the configuration
contained in a WifiConfiguration object.
If the WifiConfiguration has an Http Proxy set
the calling app must be System or be provisioned as the Profile or Device Owner. |||","int the ID of the newly created network description. This is used in
         other operations to specified the network to be acted upon.
         Returns -1 on failure. |||",1,"This class provides the primary API for managing all aspects of Wi-Fi
 connectivity.
  
 On releases before  Build.VERSION_CODES.N  this object
 should only be obtained from an  Context#getApplicationContext()  and not from any other derived context to avoid memory
 leaks within the calling process.
  
 It deals with several categories of items:
  The list of configured networks. The list can be viewed and updated and
 attributes of individual entries can be modified. The currently active Wi-Fi network if any. Connectivity can be
 established or torn down and dynamic information about the state of the
 network can be queried. Results of access point scans containing enough information to make
 decisions about what access point to connect to. It defines the names of various Intent actions that are broadcast upon
 any sort of change in Wi-Fi state.
  
 This is the API to use when performing Wi-Fi specific operations. To perform
 operations that pertain to network connectivity at an abstract level use
  ConnectivityManager .","Provides classes to manage Wi-Fi functionality on the device. The Wi-Fi APIs provide a means by which applications can communicate
 with the lower-level wireless stack that provides Wi-Fi network access. Almost all
 information from the device supplicant is available including the connected network's
 link speed IP address negotiation state and more plus information about other
 networks that are available. Some other API features include the ability to
 scan add save terminate and initiate Wi-Fi connections. Some APIs may require the following user permissions: ACCESS_WIFI_STATE CHANGE_WIFI_STATE CHANGE_WIFI_MULTICAST_STATE Note:  Not all Android-powered devices provide Wi-Fi functionality.
 If your application uses Wi-Fi declare so with a  <uses-feature> 
 element in the manifest file: 
 <manifest ...>
     <uses-feature android:name=""android.hardware.wifi"" />
     ...
 </manifest>",network info,network ,1,yes,no,SOURCE,no,
<android.widget.SlidingDrawer: void animateToggle()>,Toggles the drawer open and close with an animation.,,void,3,"SlidingDrawer hides content out of the screen and allows the user to drag a handle
 to bring the content on screen. SlidingDrawer can be used vertically or horizontally.

 A special widget composed of two children views: the handle that the users drags
 and the content attached to the handle and dragged with it.

 SlidingDrawer should be used as an overlay inside layouts. This means SlidingDrawer
 should only be used inside of a FrameLayout or a RelativeLayout for instance. The
 size of the SlidingDrawer defines how much space the content will occupy once slid
 out so SlidingDrawer should usually use match_parent for both its dimensions.

 Inside an XML layout SlidingDrawer must define the id of the handle and of the
 content:

  
 <SlidingDrawer
     android:id=""@+id/drawer""
     android:layout_width=""match_parent""
     android:layout_height=""match_parent""

     android:handle=""@+id/handle""
     android:content=""@+id/content"">

     <ImageView
         android:id=""@id/handle""
         android:layout_width=""88dip""
         android:layout_height=""44dip"" />

     <GridView
         android:id=""@id/content""
         android:layout_width=""match_parent""
         android:layout_height=""match_parent"" />

 </SlidingDrawer>","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,no,0,no,no,no,no,
<android.inputmethodservice.InputMethodService: void onConfigurationChanged(Configuration)>,"Take care of handling configuration changes.  Subclasses of
 InputMethodService generally don't need to deal directly with
 this on their own; the standard implementation here takes care of
 regenerating the input method UI as a result of the configuration
 change so you can rely on your onCreateInputView() and
 other methods being called as appropriate due to a configuration change. When a configuration change does happen onInitializeInterface() is guaranteed to be called the next
 time prior to any of the other input or UI creation callbacks.  The
 following will be called immediately depending if appropriate for current
 state: onStartInput(EditorInfo boolean) if input is active and onCreateInputView() and onStartInputView(EditorInfo boolean) and related
 appropriate functions if the UI is displayed.","newConfig Configuration : The new device configuration.
This value must never be null . |||",void,3,"InputMethodService provides a standard implementation of an InputMethod
 which final implementations can derive from and customize.  See the
 base class  AbstractInputMethodService  and the  InputMethod 
 interface for more information on the basics of writing input methods.

  In addition to the normal Service lifecycle methods this class
 introduces some new specific callbacks that most subclasses will want
 to make use of: onInitializeInterface()  for user-interface initialization
 in particular to deal with configuration changes while the service is
 running.
  onBindInput()  to find out about switching to a new client.
  onStartInput(EditorInfo boolean)  to deal with an input session starting with
 the client.
  onCreateInputView()   onCreateCandidatesView() 
 and  onCreateExtractTextView()  for non-demand generation of the UI.
  onStartInputView(android.view.inputmethod.EditorInfo boolean)  to deal with input
 starting within the input area of the IME.
  An input method has significant discretion in how it goes about its
 work: the  InputMethodService  provides
 a basic framework for standard UI elements (input view candidates view
 and running in fullscreen mode) but it is up to a particular implementor
 to decide how to use them.  For example one input method could implement
 an input area with a keyboard another could allow the user to draw text
 while a third could have no input area (and thus not be visible to the
 user) but instead listen to audio and perform text to speech conversion. In the implementation provided here all of these elements are placed
 together in a single window managed by the InputMethodService.  It will
 execute callbacks as it needs information about them and provides APIs for
 programmatic control over them.  They layout of these elements is explicitly
 defined: The soft input view if available is placed at the bottom of the
 screen.
  The candidates view if currently shown is placed above the soft
 input view.
  If not running fullscreen the application is moved or resized to be
 above these views; if running fullscreen the window will completely cover
 the application and its top part will contain the extract text of what is
 currently being edited by the application.
  Soft Input View Central to most input methods is the soft input view.  This is where most
 user interaction occurs: pressing on soft keys drawing characters or
 however else your input method wants to generate text.  Most implementations
 will simply have their own view doing all of this work and return a new
 instance of it when  onCreateInputView()  is called.  At that point
 as long as the input view is visible you will see user interaction in
 that view and can call back on the InputMethodService to interact with the
 application as appropriate. There are some situations where you want to decide whether or not your
 soft input view should be shown to the user.  This is done by implementing
 the  onEvaluateInputViewShown()  to return true or false based on
 whether it should be shown in the current environment.  If any of your
 state has changed that may impact this call
  updateInputViewShown()  to have it re-evaluated.  The default
 implementation always shows the input view unless there is a hard
 keyboard available which is the appropriate behavior for most input
 methods. Candidates View Often while the user is generating raw text an input method wants to
 provide them with a list of possible interpretations of that text that can
 be selected for use.  This is accomplished with the candidates view and
 like the soft input view you implement  onCreateCandidatesView() 
 to instantiate your own view implementing your candidates UI. Management of the candidates view is a little different than the input
 view because the candidates view tends to be more transient being shown
 only when there are possible candidates for the current text being entered
 by the user.  To control whether the candidates view is shown you use
  setCandidatesViewShown(boolean) .  Note that because the candidate
 view tends to be shown and hidden a lot it does not impact the application
 UI in the same way as the soft input view: it will never cause application
 windows to resize only cause them to be panned if needed for the user to
 see the current focus. Fullscreen Mode Sometimes your input method UI is too large to integrate with the
 application UI so you just want to take over the screen.  This is
 accomplished by switching to full-screen mode causing the input method
 window to fill the entire screen and add its own ""extracted text"" editor
 showing the user the text that is being typed.  Unlike the other UI elements
 there is a standard implementation for the extract editor that you should
 not need to change.  The editor is placed at the top of the IME above the
 input and candidates views. Similar to the input view you control whether the IME is running in
 fullscreen mode by implementing  onEvaluateFullscreenMode() 
 to return true or false based on
 whether it should be fullscreen in the current environment.  If any of your
 state has changed that may impact this call
  updateFullscreenMode()  to have it re-evaluated.  The default
 implementation selects fullscreen mode when the screen is in a landscape
 orientation which is appropriate behavior for most input methods that have
 a significant input area. When in fullscreen mode you have some special requirements because the
 user can not see the application UI.  In particular you should implement
  onDisplayCompletions(android.view.inputmethod.CompletionInfo[])  to show completions
 generated by your application typically in your candidates view like you
 would normally show candidates.


  Generating Text The key part of an IME is of course generating text for the application.
 This is done through calls to the
  InputConnection  interface to the
 application which can be retrieved from  getCurrentInputConnection() .
 This interface allows you to generate raw key events or if the target
 supports it directly edit in strings of candidates and committed text. Information about what the target is expected and supports can be found
 through the  EditorInfo  class which is
 retrieved with  getCurrentInputEditorInfo()  method.  The most
 important part of this is  EditorInfo.inputType ; in particular if this is
  EditorInfo.TYPE_NULL 
 then the target does not support complex edits and you need to only deliver
 raw key events to it.  An input method will also want to look at other
 values here to for example detect password mode auto complete text views
 phone number entry etc. When the user switches between input targets you will receive calls to
  onFinishInput()  and  onStartInput(android.view.inputmethod.EditorInfo boolean) .
 You can use these to reset and initialize your input state for the current
 target.  For example you will often want to clear any input state and
 update a soft keyboard to be appropriate for the new inputType.",,input data,callback,1,no,yes,no,SINK,
<android.app.WallpaperManager: Drawable getFastDrawable()>,"Like getDrawable() but the returned Drawable has a number
 of limitations to reduce its overhead as much as possible. It will
 never scale the wallpaper (only centering it if the requested bounds
 do match the bitmap bounds which should not be typical) doesn't
 allow setting an alpha color filter or other attributes etc.  The
 bounds of the returned drawable will be initialized to the same bounds
 as the wallpaper so normally you will not need to touch it.  The
 drawable also assumes that it will be used in a context running in
 the same density as the screen (not in density compatibility mode). Requires Manifest.permission.READ_EXTERNAL_STORAGE",,Drawable Returns a Drawable object that will draw the wallpaper. |||,5,"Provides access to the system wallpaper. With WallpaperManager you can
 get the current wallpaper get the desired dimensions for the wallpaper set
 the wallpaper and more.

   An app can check whether wallpapers are supported for the current user by calling
  isWallpaperSupported()  and whether setting of wallpapers is allowed by calling
  isSetWallpaperAllowed() .","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",image,UI,1,yes,no,SOURCE,no,
<android.app.Dialog: Bundle onSaveInstanceState()>,"Saves the state of the dialog into a bundle.

 The default implementation saves the state of its view hierarchy so you'll
 likely want to call through to super if you override this to save additional
 state.",,"Bundle A bundle with the state of the dialog.
 
 This value will never be null . |||",1,"Base class for Dialogs.

  Note: Activities provide a facility to manage the creation saving and
 restoring of dialogs. See  Activity#onCreateDialog(int) 
  Activity#onPrepareDialog(int Dialog) 
  Activity#showDialog(int)  and  Activity#dismissDialog(int) . If
 these methods are used  getOwnerActivity()  will return the Activity
 that managed this dialog.

  Often you will want to have a Dialog display on top of the current
 input method because there is no reason for it to accept text.  You can
 do this by setting the  WindowManager.LayoutParams#FLAG_ALT_FOCUSABLE_IM  window flag (assuming
 your Dialog takes input focus as it the default) with the following code:

  
 getWindow().setFlags(WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM
         WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",uncategorized,UI,1,yes,no,no,no,
<android.widget.AbsListView: Parcelable onSaveInstanceState()>,"Hook allowing a view to generate a representation of its internal state
 that can later be used to create a new instance with that same state.
 This state should only contain information that is not persistent or can
 not be reconstructed later. For example you will never store your
 current position on screen because that will be computed again when a
 new instance of the view is placed in its view hierarchy. Some examples of things you may store here: the current cursor position
 in a text view (but usually not the text itself since that is stored in a
 content provider or other persistent storage) the currently selected
 item in a list view. If you override this method you must call through to the
 superclass implementation.",,"Parcelable Returns a Parcelable object containing the view's current dynamic
         state or null if there is nothing interesting to save. |||",1,"Base class that can be used to implement virtualized lists of items. A list does
 not have a spatial definition here. For instance subclasses of this class can
 display the content of the list in a grid in a carousel as stack etc.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",uncategorized,UI,1,no,no,no,no,
<android.telephony.SmsMessage: SmsMessage createFromPdu(byte)>,"This method was deprecated
      in API level 23. Use createFromPdu(byte[] java.lang.String) instead. Create an SmsMessage from a raw PDU. Guess format based on Voice
 technology first if it fails use other format.
 All applications which handle
 incoming SMS messages by processing the SMS_RECEIVED_ACTION broadcast
 intent must now pass the new format String extra from the intent
 into the new method createFromPdu(byte[] String) which takes an
 extra format parameter. This is required in order to correctly decode the PDU on
 devices that require support for both 3GPP and 3GPP2 formats at the same time
 such as dual-mode GSM/CDMA and CDMA/LTE phones.",pdu byte |||,SmsMessage |||,4,A Short Message Service message.,,sms message,no,0,no,no,no,no,
"<android.app.Instrumentation: void callActivityOnNewIntent(Activity,Intent)>",Perform calling of an activity's Activity#onNewIntent method.  The default implementation simply calls through to that method.,"activity Activity : The activity receiving a new Intent. |||
intent Intent : The new intent being received. |||",void,1,"Base class for implementing application instrumentation code.  When running
 with instrumentation turned on this class will be instantiated for you
 before any of the application code allowing you to monitor all of the
 interaction the system has with the application.  An Instrumentation
 implementation is described to the system through an AndroidManifest.xml's
 <instrumentation> tag.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",IPC,IPC,1,no,yes,no,SINK,
"<android.text.SpannableStringBuilder: SpannableStringBuilder insert(int,CharSequence)>",Convenience for replace(where where text 0 text.length());,"where int |||
tb CharSequence |||",SpannableStringBuilder |||,1,"This is the class for text whose content is immutable but to which
 markup objects can be attached and detached.
 For mutable text see  SpannableStringBuilder .","Provides classes used to render or track text and text spans on the screen. You can use these classes to design your own widgets that manage text
 to handle arbitrary text spans for changes or to handle drawing yourself
 for an existing widget. The Span… interfaces and classes are used to create or manage spans of
 text in a View item. You can use these to style the text or background or to
 listen for changes. If creating your own widget extend DynamicLayout to manages
 the actual wrapping and drawing of your text.",no,no,0,no,no,no,no,
<android.app.Fragment: void startActivity(Intent)>,"Call Activity#startActivity(Intent) from the fragment's
 containing Activity.",intent Intent : The intent to start. |||,void,11,"A Fragment is a piece of an application's user interface or behavior
 that can be placed in an  Activity .  Interaction with fragments
 is done through  FragmentManager  which can be obtained via
  Activity#getFragmentManager()  and
  Fragment#getFragmentManager() .

  The Fragment class can be used many ways to achieve a wide variety of
 results. In its core it represents a particular operation or interface
 that is running within a larger  Activity .  A Fragment is closely
 tied to the Activity it is in and can not be used apart from one.  Though
 Fragment defines its own lifecycle that lifecycle is dependent on its
 activity: if the activity is stopped no fragments inside of it can be
 started; when the activity is destroyed all fragments will be destroyed.

  All subclasses of Fragment must include a public no-argument constructor.
 The framework will often re-instantiate a fragment class when needed
 in particular during state restore and needs to be able to find this
 constructor to instantiate it.  If the no-argument constructor is not
 available a runtime exception will occur in some cases during state
 restore.

  Topics covered here:
  Older Platforms Lifecycle Layout Back Stack","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",IPC,IPC,1,no,yes,no,SINK,
<android.media.MediaPlayer: void reset()>,"Resets the MediaPlayer to its uninitialized state. After calling
 this method you will have to initialize it again by setting the
 data source and calling prepare().",,void,1,"MediaPlayer class can be used to control playback
 of audio/video files and streams. An example on how to use the methods in
 this class can be found in  VideoView .

  Topics covered here are:
  State Diagram Valid and Invalid States Permissions Register informational and error callbacks","The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",no,no,0,no,no,no,no,
<android.widget.SlidingDrawer: void close()>,Closes the drawer immediately.,,void,3,"SlidingDrawer hides content out of the screen and allows the user to drag a handle
 to bring the content on screen. SlidingDrawer can be used vertically or horizontally.

 A special widget composed of two children views: the handle that the users drags
 and the content attached to the handle and dragged with it.

 SlidingDrawer should be used as an overlay inside layouts. This means SlidingDrawer
 should only be used inside of a FrameLayout or a RelativeLayout for instance. The
 size of the SlidingDrawer defines how much space the content will occupy once slid
 out so SlidingDrawer should usually use match_parent for both its dimensions.

 Inside an XML layout SlidingDrawer must define the id of the handle and of the
 content:

  
 <SlidingDrawer
     android:id=""@+id/drawer""
     android:layout_width=""match_parent""
     android:layout_height=""match_parent""

     android:handle=""@+id/handle""
     android:content=""@+id/content"">

     <ImageView
         android:id=""@id/handle""
         android:layout_width=""88dip""
         android:layout_height=""44dip"" />

     <GridView
         android:id=""@id/content""
         android:layout_width=""match_parent""
         android:layout_height=""match_parent"" />

 </SlidingDrawer>","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,no,0,no,no,no,no,
<android.media.AudioManager: void playSoundEffect(int)>,Plays a sound effect (Key clicks lid open/close...),"effectType int : The type of sound effect. One of FX_KEY_CLICK  FX_FOCUS_NAVIGATION_UP  FX_FOCUS_NAVIGATION_DOWN  FX_FOCUS_NAVIGATION_LEFT  FX_FOCUS_NAVIGATION_RIGHT  FX_KEYPRESS_STANDARD  FX_KEYPRESS_SPACEBAR  FX_KEYPRESS_DELETE  FX_KEYPRESS_RETURN  FX_KEYPRESS_INVALID NOTE: This version uses the UI settings to determine
whether sounds are heard or not. |||",void,1,AudioManager provides access to volume and ringer mode control.,"The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",no,audio,0,no,no,no,no,
<android.preference.PreferenceManager: SharedPreferences getSharedPreferences()>,Gets a SharedPreferences instance that preferences managed by this will use.,,"SharedPreferences a SharedPreferences instance pointing to the file that contains the values of
         preferences that are managed by this PreferenceManager. If a PreferenceDataStore has been set this method returns null . |||",1,"Used to help create  Preference  hierarchies
 from activities or XML.
  
 In most cases clients should use
  PreferenceActivity#addPreferencesFromIntent  or
  PreferenceActivity#addPreferencesFromResource(int) .",,preferences,preference storage file,1,yes,no,SOURCE,no,
"<android.animation.LayoutTransition: void showChild(ViewGroup,View,int)>","This method is called by ViewGroup when a child view is about to be made visible in the
 container. This callback starts the process of a transition; we grab the starting
 values listen for changes to all of the children of the container and start appropriate
 animations.","parent ViewGroup : The ViewGroup in which the View is being made visible. |||
child View : The View being made visible. |||
oldVisibility int : The previous visibility value of the child View either View#GONE or View#INVISIBLE . |||",void,16,"This class enables automatic animations on layout changes in ViewGroup objects. To enable
 transitions for a layout container create a LayoutTransition object and set it on any
 ViewGroup by calling  ViewGroup#setLayoutTransition(LayoutTransition) . This will cause
 default animations to run whenever items are added to or removed from that container. To specify
 custom animations use the  LayoutTransition#setAnimator(int Animator)  method.

  One of the core concepts of these transition animations is that there are two types of
 changes that cause the transition and four different animations that run because of
 those changes. The changes that trigger the transition are items being added to a container
 (referred to as an ""appearing"" transition) or removed from a container (also known as
 ""disappearing""). Setting the visibility of views (between GONE and VISIBLE) will trigger
 the same add/remove logic. The animations that run due to those events are one that animates
 items being added one that animates items being removed and two that animate the other
 items in the container that change due to the add/remove occurrence. Users of
 the transition may want different animations for the changing items depending on whether
 they are changing due to an appearing or disappearing event so there is one animation for
 each of these variations of the changing event. Most of the API of this class is concerned
 with setting up the basic properties of the animations used in these four situations
 or with setting up custom animations for any or all of the four. By default the DISAPPEARING animation begins immediately as does the CHANGE_APPEARING
 animation. The other animations begin after a delay that is set to the default duration
 of the animations. This behavior facilitates a sequence of animations in transitions as
 follows: when an item is being added to a layout the other children of that container will
 move first (thus creating space for the new item) then the appearing animation will run to
 animate the item being added. Conversely when an item is removed from a container the
 animation to remove it will run first then the animations of the other children in the
 layout will run (closing the gap created in the layout when the item was removed). If this
 default choreography behavior is not desired the  setDuration(int long)  and
  setStartDelay(int long)  of any or all of the animations can be changed as
 appropriate. Keep in mind however that if you start an APPEARING animation before a
 DISAPPEARING animation is completed the DISAPPEARING animation stops and any effects from
 the DISAPPEARING animation are reverted. If you instead start a DISAPPEARING animation
 before an APPEARING animation is completed a similar set of effects occurs for the
 APPEARING animation. The animations specified for the transition both the defaults and any custom animations
 set on the transition object are templates only. That is these animations exist to hold the
 basic animation properties such as the duration start delay and properties being animated.
 But the actual target object as well as the start and end values for those properties are
 set automatically in the process of setting up the transition each time it runs. Each of the
 animations is cloned from the original copy and the clone is then populated with the dynamic
 values of the target being animated (such as one of the items in a layout container that is
 moving as a result of the layout event) as well as the values that are changing (such as the
 position and size of that object). The actual values that are pushed to each animation
 depends on what properties are specified for the animation. For example the default
 CHANGE_APPEARING animation animates the  left   top   right 
  bottom   scrollX  and  scrollY  properties.
 Values for these properties are updated with the pre- and post-layout
 values when the transition begins. Custom animations will be similarly populated with
 the target and values being animated assuming they use ObjectAnimator objects with
 property names that are known on the target object. This class and the associated XML flag for containers animateLayoutChanges=""true""
 provides a simple utility meant for automating changes in straightforward situations.
 Using LayoutTransition at multiple levels of a nested view hierarchy may not work due to the
 interrelationship of the various levels of layout. Also a container that is being scrolled
 at the same time as items are being added or removed is probably not a good candidate for
 this utility because the before/after locations calculated by LayoutTransition
 may not match the actual locations when the animations finish due to the container
 being scrolled as the animations are running. You can work around that
 particular issue by disabling the 'changing' animations by setting the CHANGE_APPEARING
 and CHANGE_DISAPPEARING animations to null and setting the startDelay of the
 other animations appropriately.","These classes provide functionality for the property animation system which allows you
 to animate object properties of any type.  int   float  and hexadecimal
 color values are supported by default. You can animate any other type by telling the system how
 to calculate the values for that given type with a custom  TypeEvaluator .
  For more information see the
  Animation  guide. 
 You can set many different types of interpolators (contained in  android.view.animation )
 specify  keyframes  or group animations to play sequentially
 or simultaneously (with  AnimatorSet ) to further control your animation
 behaviors.",uncategorized,UI,1,no,yes,no,SINK,
<android.app.Activity: void removeDialog(int)>,"This method was deprecated
      in API level 15. Use the new DialogFragment class with FragmentManager instead; this is also
 available on older platforms through the Android compatibility package. Removes any internal references to a dialog managed by this Activity.
 If the dialog is showing it will dismiss it as part of the clean up. This can be useful if you know that you will never show a dialog again and
 want to avoid the overhead of saving and restoring it in the future. As of Build.VERSION_CODES.GINGERBREAD this function
 will not throw an exception if you try to remove an ID that does not
 currently have an associated dialog.",id int : The id of the managed dialog. |||,void,1,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
<android.view.View: void announceForAccessibility(CharSequence)>,"Convenience method for sending a AccessibilityEvent#TYPE_ANNOUNCEMENT AccessibilityEvent to suggest that an accessibility service announce the
 specified text to its users. Note: The event generated with this API carries no semantic meaning and is appropriate only
 in exceptional situations. Apps can generally achieve correct behavior for accessibility by
 accurately supplying the semantics of their UI.
 They should not need to specify what exactly is announced to users.",text CharSequence : The announcement text. |||,void,16,"This class represents the basic building block for user interface components. A View
 occupies a rectangular area on the screen and is responsible for drawing and
 event handling. View is the base class for  widgets  which are
 used to create interactive UI components (buttons text fields etc.). The
  ViewGroup  subclass is the base class for  layouts  which
 are invisible containers that hold other Views (or other ViewGroups) and define
 their layout properties.",,uncategorized,UI,1,no,yes,no,SINK,
<android.content.res.Resources: CharSequence getText(int)>,"Return the string value associated with a particular resource ID.  The
 returned object will be a String if this is a plain string; it will be
 some other type of CharSequence if it is styled.","id int : The desired resource identifier as generated by the aapt
tool. This integer encodes the package type and resource
entry. The value 0 is an invalid identifier. |||","CharSequence CharSequence The string data associated with the resource plus
         possibly styled text information.
 
 This value will never be null . |||",1,"Class for accessing an application's resources.  This sits on top of the
 asset manager of the application (accessible through  getAssets() ) and
 provides a high-level API for getting typed data from the assets.

  The Android resource system keeps track of all non-code assets associated with an
 application. You can use this class to access your application's resources. You can generally
 acquire the  Resources  instance associated with your application
 with  getResources() . The Android SDK tools compile your application's resources into the application binary
 at build time.  To use a resource you must install it correctly in the source tree (inside
 your project's  res/  directory) and build your application.  As part of the build
 process the SDK tools generate symbols for each resource which you can use in your application
 code to access the resources. Using application resources makes it easy to update various characteristics of your
 application without modifying code and—by providing sets of alternative
 resources—enables you to optimize your application for a variety of device configurations
 (such as for different languages and screen sizes). This is an important aspect of developing
 Android applications that are compatible on different types of devices. For more information about using resources see the documentation about  Application Resources .","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,
<android.view.ViewConfiguration: ViewConfiguration get(Context)>,"Returns a configuration for the specified context. The configuration depends on
 various parameters of the context like the dimension of the display or the
 density of the display.",context Context : The application context used to initialize the view configuration. |||,ViewConfiguration |||,3,Contains methods to standard constants used in the UI for timeouts sizes and distances.,,no,no,0,no,no,no,no,
<android.bluetooth.BluetoothAdapter: String getName()>,Get the friendly Bluetooth name of the local Bluetooth adapter. This name is visible to remote Bluetooth devices. Requires Manifest.permission.BLUETOOTH,,String the Bluetooth name or null on error |||,5,"Represents the local device Bluetooth adapter. The  BluetoothAdapter 
 lets you perform fundamental Bluetooth tasks such as initiate
 device discovery query a list of bonded (paired) devices
 instantiate a  BluetoothDevice  using a known MAC address and create
 a  BluetoothServerSocket  to listen for connection requests from other
 devices and start a scan for Bluetooth LE devices.

  To get a  BluetoothAdapter  representing the local Bluetooth
 adapter call the  BluetoothManager#getAdapter  function on  BluetoothManager .
 On JELLY_BEAN_MR1 and below you will need to use the static  getDefaultAdapter() 
 method instead.
  
 Fundamentally this is your starting point for all
 Bluetooth actions. Once you have the local adapter you can get a set of
  BluetoothDevice  objects representing all paired devices with
  getBondedDevices() ; start device discovery with
  startDiscovery() ; or create a  BluetoothServerSocket  to
 listen for incoming RFComm connection requests with  listenUsingRfcommWithServiceRecord(java.lang.String java.util.UUID) ; listen for incoming L2CAP Connection-oriented
 Channels (CoC) connection requests with  listenUsingL2capChannel() ; or start a scan for
 Bluetooth LE devices with  startLeScan(android.bluetooth.BluetoothAdapter.LeScanCallback) .
  This class is thread safe. Note: 
 Most methods require the  Manifest.permission.BLUETOOTH 
 permission and some also require the
  Manifest.permission.BLUETOOTH_ADMIN  permission.","Provides classes that manage Bluetooth functionality such as scanning for
 devices connecting with devices and managing data transfer between devices.
 The Bluetooth API supports both ""Classic Bluetooth"" and Bluetooth Low Energy. For more information about Classic Bluetooth see the
  Bluetooth  guide.
 For more information about Bluetooth Low Energy see the
  
 Bluetooth Low Energy  (BLE) guide. The Bluetooth APIs let applications: Scan for other Bluetooth devices (including BLE devices). Query the local Bluetooth adapter for paired Bluetooth devices. Establish RFCOMM channels/sockets. Connect to specified sockets on other devices. Transfer data to and from other devices. Communicate with BLE devices such as proximity sensors heart rate
     monitors fitness devices and so on. Act as a GATT client or a GATT server (BLE). 
 To perform Bluetooth communication using these APIs an application must
 declare the  BLUETOOTH  permission. Some
 additional functionality such as requesting device discovery
 also requires the  BLUETOOTH_ADMIN 
 permission.
  Note: 
 Not all Android-powered devices provide Bluetooth functionality.",yes,bluetooth,1,yes,no,SOURCE,no,
<android.util.EventLog: String getTagName(int)>,Get the name associated with an event type tag code.,tag int : code to look up |||,String the name of the tag or null if no tag has that number |||,8,"Access to the system diagnostic event record.  System diagnostic events are
 used to record certain system-level events (such as garbage collection
 activity manager state system watchdogs and other low level activity)
 which may be automatically collected and analyzed during system development.

  This is  not  the main ""logcat"" debugging log ( Log )!
 These diagnostic events are for system integrators not application authors.

  Events use integer tag codes corresponding to /system/etc/event-log-tags.
 They carry a payload of one or more int long or String values.  The
 event-log-tags file defines the payload contents for each type code.",,no,no,0,no,no,no,no,
"<android.widget.TextView: void setCompoundDrawablesWithIntrinsicBounds(int,int,int,int)>","Sets the Drawables (if any) to appear to the left of above to the
 right of and below the text. Use 0 if you do not want a Drawable there.
 The Drawables' bounds will be set to their intrinsic bounds. Calling this method will overwrite any Drawables previously set using setCompoundDrawablesRelative(Drawable Drawable Drawable Drawable) or related methods. Related XML Attributes: android:drawableLeft 
android:drawableTop 
android:drawableRight 
android:drawableBottom","left int : Resource identifier of the left Drawable. |||
top int : Resource identifier of the top Drawable. |||
right int : Resource identifier of the right Drawable. |||
bottom int : Resource identifier of the bottom Drawable. |||",void,3,"A user interface element that displays text to the user.
 To provide user-editable text see  EditText .
  
 The following code sample shows a typical use with an XML layout
 and code to modify the contents of the text view:
  
 <LinearLayout
      xmlns:android=""http://schemas.android.com/apk/res/android""
      android:layout_width=""match_parent""
      android:layout_height=""match_parent"">
    <TextView
        android:id=""@+id/text_view_id""
        android:layout_height=""wrap_content""
        android:layout_width=""wrap_content""
        android:text=""@string/hello"" />
 </LinearLayout>
  
 This code sample demonstrates how to modify the contents of the text view
 defined in the previous XML layout:
  
 public class MainActivity extends Activity {

    protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_main);
         final TextView helloTextView = (TextView) findViewById(R.id.text_view_id);
         helloTextView.setText(R.string.user_greeting);
     }
 }
  
 To customize the appearance of TextView see  Styles and Themes .
  XML attributes 
 See  TextView Attributes 
  View Attributes","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,no,0,no,no,no,no,
<android.app.SearchManager: ComponentName getGlobalSearchActivity()>,Gets the name of the global search activity.,,ComponentName |||,16,"This class provides access to the system search services.

  In practice you won't interact with this class directly as search
 services are provided through methods in  Activity 
 and the  ACTION_SEARCH Intent .

  Configuration#UI_MODE_TYPE_WATCH  does not support this system service.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
"<android.text.Layout: void getCursorPath(int,Path,CharSequence)>","Fills in the specified Path with a representation of a cursor
 at the specified offset.  This will often be a vertical line
 but can be multiple discontinuous lines in text with multiple
 directionalities.","point int |||
dest Path |||
editingBuffer CharSequence |||",void,1,"A base class that manages text layout in visual elements on
 the screen.
  For text that will be edited use a  DynamicLayout 
 which will be updated as the text changes.
 For text that will not change use a  StaticLayout .","Provides classes used to render or track text and text spans on the screen. You can use these classes to design your own widgets that manage text
 to handle arbitrary text spans for changes or to handle drawing yourself
 for an existing widget. The Span… interfaces and classes are used to create or manage spans of
 text in a View item. You can use these to style the text or background or to
 listen for changes. If creating your own widget extend DynamicLayout to manages
 the actual wrapping and drawing of your text.",no,no,0,no,no,no,no,
<android.content.res.AssetFileDescriptor: void close()>,Convenience for calling getParcelFileDescriptor().close() .,,void,1,"File descriptor of an entry in the AssetManager.  This provides your own
 opened FileDescriptor that can be used to read the data as well as the
 offset and length of that entry's data in the file.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,
<android.content.pm.LabeledIntent: CharSequence loadLabel(PackageManager)>,"Retrieve the label associated with this object.  If the object does
 not have a label null will be returned in which case you will probably
 want to load the label from the underlying resolved info for the Intent.",pm PackageManager |||,CharSequence |||,5,"A special subclass of Intent that can have a custom label/icon
 associated with it.  Primarily for use with  Intent#ACTION_CHOOSER .","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,
<android.content.ContextWrapper: ComponentName startService(Intent)>,"Request that a given application service be started.  The Intent
 should either contain the complete class name of a specific service
 implementation to start or a specific package name to target.  If the
 Intent is less specified it logs a warning about this.  In this case any of the
 multiple matching services may be used.  If this service
 is not already running it will be instantiated and started (creating a
 process for it if needed); if it is running then it remains running. Every call to this method will result in a corresponding call to
 the target service's Service.onStartCommand(Intent int int) method
 with the intent given here.  This provides a convenient way
 to submit jobs to a service without having to bind and call on to its
 interface. Using startService() overrides the default service lifetime that is
 managed by bindService(Intent ServiceConnection int) : it requires the service to remain
 running until stopService(Intent) is called regardless of whether
 any clients are connected to it.  Note that calls to startService()
 do not nest: no matter how many times you call startService()
 a single call to stopService(Intent) will stop it. The system attempts to keep running services around as much as
 possible.  The only time they should be stopped is if the current
 foreground application is using so many resources that the service needs
 to be killed.  If any errors happen in the service's process it will
 automatically be restarted. This function will throw SecurityException if you do not
 have permission to start the given service. Note: Each call to startService()
 results in significant work done by the system to manage service
 lifecycle surrounding the processing of the intent which can take
 multiple milliseconds of CPU time. Due to this cost startService()
 should not be used for frequent intent delivery to a service and only
 for scheduling significant work. Use bound services for high frequency calls.","service Intent : Identifies the service to be started.  The Intent must be
fully explicit (supplying a component name).  Additional values
may be included in the Intent extras to supply arguments along with
this specific start call. |||","ComponentName If the service is being started or is already running the ComponentName of the actual service that was started is
 returned; else if the service does not exist null is returned. |||",1,"Proxying implementation of Context that simply delegates all of its calls to
 another Context.  Can be subclassed to modify behavior without changing
 the original Context.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",IPC,IPC,1,no,yes,no,SINK,
"<android.app.ProgressDialog: ProgressDialog show(Context,CharSequence,CharSequence)>",Creates and shows a ProgressDialog.,"context Context : the parent context |||
title CharSequence : the title text for the dialog's window |||
message CharSequence : the text to be displayed in the dialog |||",ProgressDialog the ProgressDialog |||,1,"A dialog showing a progress indicator and an optional text message or view.
 Only a text message or a view can be used at the same time.

  The dialog can be made cancelable on back key press. The progress range is 0 to  max .","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",uncategorized,UI,1,no,yes,no,SINK,
<android.widget.TextView: void setTextSize(float)>,"Set the default text size to the given value interpreted as ""scaled
 pixel"" units.  This size is adjusted based on the current density and
 user font size preference. Note: if this TextView has the auto-size feature enabled than this function is no-op. Related XML Attributes: android:textSize",size float : The scaled pixel size. |||,void,1,"A user interface element that displays text to the user.
 To provide user-editable text see  EditText .
  
 The following code sample shows a typical use with an XML layout
 and code to modify the contents of the text view:
  
 <LinearLayout
      xmlns:android=""http://schemas.android.com/apk/res/android""
      android:layout_width=""match_parent""
      android:layout_height=""match_parent"">
    <TextView
        android:id=""@+id/text_view_id""
        android:layout_height=""wrap_content""
        android:layout_width=""wrap_content""
        android:text=""@string/hello"" />
 </LinearLayout>
  
 This code sample demonstrates how to modify the contents of the text view
 defined in the previous XML layout:
  
 public class MainActivity extends Activity {

    protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_main);
         final TextView helloTextView = (TextView) findViewById(R.id.text_view_id);
         helloTextView.setText(R.string.user_greeting);
     }
 }
  
 To customize the appearance of TextView see  Styles and Themes .
  XML attributes 
 See  TextView Attributes 
  View Attributes","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,UI,0,no,no,no,no,
"<android.view.inputmethod.InputMethodManager: void setInputMethod(IBinder,String)>","This method was deprecated
      in API level 28. Use InputMethodService#switchInputMethod(String) instead. This method was intended for IME developers who should be accessing APIs through
 the service. APIs in this class are intended for app developers interacting with the IME. Force switch to a new input method component. This can only be called
 from an application or a service which has a token of the currently active input method. On Android Build.VERSION_CODES#Q and later devices the undocumented behavior that
 token can be null when the caller has Manifest.permission.WRITE_SECURE_SETTINGS is deprecated. Instead update Settings.Secure.DEFAULT_INPUT_METHOD and Settings.Secure.SELECTED_INPUT_METHOD_SUBTYPE directly.","token IBinder : Supplies the identifying token given to an input method
when it was started which allows it to perform this operation on
itself. |||
id String : The unique identifier for the new input method to be switched to. |||",void,3,"Central system API to the overall input method framework (IMF) architecture
 which arbitrates interaction between applications and the current input method.

  Topics covered here:
  Architecture Overview Applications Input Methods Security Architecture Overview There are three primary parties involved in the input method
 framework (IMF) architecture:  The  input method manager  as expressed by this class
 is the central point of the system that manages interaction between all
 other parts.  It is expressed as the client-side API here which exists
 in each application context and communicates with a global system service
 that manages the interaction across all processes.
   An  input method (IME)  implements a particular
 interaction model allowing the user to generate text.  The system binds
 to the current input method that is in use causing it to be created and run
 and tells it when to hide and show its UI.  Only one IME is running at a time.
   Multiple  client applications  arbitrate with the input
 method manager for input focus and control over the state of the IME.  Only
 one such client is ever active (working with the IME) at a time.
  Applications In most cases applications that are using the standard
  TextView  or its subclasses will have little they need
 to do to work well with soft input methods.  The main things you need to
 be aware of are:  Properly set the  R.attr.inputType  in your editable
 text views so that the input method will have enough context to help the
 user in entering text into them.
   Deal well with losing screen space when the input method is
 displayed.  Ideally an application should handle its window being resized
 smaller but it can rely on the system performing panning of the window
 if needed.  You should set the  R.attr.windowSoftInputMode 
 attribute on your activity or the corresponding values on windows you
 create to help the system determine whether to pan or resize (it will
 try to determine this automatically but may get it wrong).
   You can also control the preferred soft input state (open closed etc)
 for your window using the same  R.attr.windowSoftInputMode 
 attribute.
  More finer-grained control is available through the APIs here to directly
 interact with the IMF and its IME -- either showing or hiding the input
 area letting the user pick an input method etc. For the rare people amongst us writing their own text editors you
 will need to implement  View.onCreateInputConnection(EditorInfo) 
 to return a new instance of your own  InputConnection  interface
 allowing the IME to interact with your editor. Input Methods An input method (IME) is implemented
 as a  Service  typically deriving from
  InputMethodService .  It must provide
 the core  InputMethod  interface though this is normally handled by
  InputMethodService  and implementors will
 only need to deal with the higher-level API there. InputMethodService Security There are a lot of security issues associated with input methods
 since they essentially have freedom to completely drive the UI and monitor
 everything the user enters.  The Android input method framework also allows
 arbitrary third party IMEs so care must be taken to restrict their
 selection and interactions. Here are some key points about the security architecture behind the
 IMF: Only the system is allowed to directly access an IME's
  InputMethod  interface via the
  Manifest.permission.BIND_INPUT_METHOD  permission.  This is
 enforced in the system by not binding to an input method service that does
 not require this permission so the system can guarantee no other untrusted
 clients are accessing the current input method outside of its control. There may be many client processes of the IMF but only one may
 be active at a time.  The inactive clients can not interact with key
 parts of the IMF through the mechanisms described below. Clients of an input method are only given access to its
  InputMethodSession  interface.  One instance of this interface is
 created for each client and only calls from the session associated with
 the active client will be processed by the current IME.  This is enforced
 by  AbstractInputMethodService  for normal
 IMEs but must be explicitly handled by an IME that is customizing the
 raw  InputMethodSession  implementation. Only the active client's  InputConnection  will accept
 operations.  The IMF tells each client process whether it is active and
 the framework enforces that in inactive processes calls on to the current
 InputConnection will be ignored.  This ensures that the current IME can
 only deliver events and text edits to the UI that the user sees as
 being in focus. An IME can never interact with an  InputConnection  while
 the screen is off.  This is enforced by making all clients inactive while
 the screen is off and prevents bad IMEs from driving the UI when the user
 can not be aware of its behavior. A client application can ask that the system let the user pick a
 new IME but can not programmatically switch to one itself.  This avoids
 malicious applications from switching the user to their own IME which
 remains running when the user navigates away to another application.  An
 IME on the other hand  is  allowed to programmatically switch
 the system to another IME since it already has full control of user
 input. The user must explicitly enable a new IME in settings before
 they can switch to it to confirm with the system that they know about it
 and want to make it available for use. PackageManager#FEATURE_INPUT_METHODS PackageManager.hasSystemFeature(String)",,no,IPC,0,no,no,no,no,
"<android.content.Intent: Intent putExtra(String,short)>","Add extended data to the intent.  The name must include a package
 prefix for example the app com.android.contacts would use names
 like ""com.android.contacts.ShowAll"".","name String : The name of the extra data with package prefix. |||
value short : The short array data value.
This value may be null . |||","Intent Returns the same Intent object for chaining multiple calls
 into a single statement.

 This value will never be null . |||",1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,
"<android.text.LoginFilter: CharSequence filter(CharSequence,int,int,Spanned,int,int)>","This method is called when the buffer is going to replace the
 range dstart … dend of dest with the new text from the range start … end of source .  Returns the CharSequence that we want
 placed there instead including an empty string
 if appropriate or null to accept the original
 replacement.  Be careful to not to reject 0-length replacements
 as this is what happens when you delete text.","source CharSequence |||
start int |||
end int |||
dest Spanned |||
dstart int |||
dend int |||",CharSequence |||,1,Abstract class for filtering login-related text (user names and passwords),"Provides classes used to render or track text and text spans on the screen. You can use these classes to design your own widgets that manage text
 to handle arbitrary text spans for changes or to handle drawing yourself
 for an existing widget. The Span… interfaces and classes are used to create or manage spans of
 text in a View item. You can use these to style the text or background or to
 listen for changes. If creating your own widget extend DynamicLayout to manages
 the actual wrapping and drawing of your text.",no,no,0,no,no,no,no,
<android.speech.RecognizerIntent: Intent getVoiceDetailsIntent(Context)>,"Returns the broadcast intent to fire with Context#sendOrderedBroadcast(Intent String BroadcastReceiver android.os.Handler int String Bundle) to receive details from the package that implements voice search. This is based on the value specified by the voice search Activity in DETAILS_META_DATA and if this is not specified will return null. Also if there
 is no chosen default to resolve for ACTION_WEB_SEARCH this will return null. If an intent is returned and is fired a Bundle of extras will be returned to the
 provided result receiver and should ideally contain values for EXTRA_LANGUAGE_PREFERENCE and EXTRA_SUPPORTED_LANGUAGES . (Whether these are actually provided is up to the particular implementation. It is
 recommended that Activity s implementing ACTION_WEB_SEARCH provide this
 information but it is not required.)",context Context : a context object |||,Intent the broadcast intent to fire or null if not available |||,8,Constants for supporting speech recognition through starting an  Intent,,IPC,IPC,1,yes,no,SOURCE,no,
<android.os.Bundle: void clear()>,Removes all elements from the mapping of this Bundle.,,void,1,A mapping from String keys to various  Parcelable  values.,,no,no,0,no,no,no,no,
"<android.webkit.WebView: void flingScroll(int,int)>",,"vx int |||
vy int |||",void,1,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",no,no,0,no,no,no,no,
"<android.os.Bundle: void putByteArray(String,byte)>","Inserts a byte array value into the mapping of this Bundle replacing
 any existing value for the given key.  Either key or value may be null.","key String : a String or null
This value may be null . |||
value byte : a byte array object or null
This value may be null . |||",void,1,A mapping from String keys to various  Parcelable  values.,,IPC,no,0,no,no,no,no,
<android.widget.ViewAnimator: void setDisplayedChild(int)>,Sets which child view will be displayed.,whichChild int : the index of the child view to display |||,void,1,"Base class for a  FrameLayout  container that will perform animations
 when switching between its views.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",uncategorized,UI,1,no,yes,no,SINK,
"<android.app.admin.DeviceAdminReceiver: void onReceive(Context,Intent)>","Intercept standard device administrator broadcasts.  Implementations
 should not override this method; it is better to implement the
 convenience callbacks for each action.","context Context : This value must never be null . |||
intent Intent : This value must never be null . |||",void,8,"Base class for implementing a device administration component.  This
 class provides a convenience for interpreting the raw intent actions
 that are sent by the system.

  The callback methods like the base
  BroadcastReceiver#onReceive(Context Intent) 
 method happen on the main thread of the process.  Thus long running
 operations must be done on another thread.  Note that because a receiver
 is done once returning from its receive function such long-running operations
 should probably be done in a  Service .

  When publishing your DeviceAdmin subclass as a receiver it must
 handle  ACTION_DEVICE_ADMIN_ENABLED  and require the
  Manifest.permission.BIND_DEVICE_ADMIN  permission.  A typical
 manifest entry would look like: <receiver android:name="".app.DeviceAdminSample$DeviceAdminSampleReceiver""
        android:label=""@string/sample_device_admin""
        android:description=""@string/sample_device_admin_description""
        android:permission=""android.permission.BIND_DEVICE_ADMIN"">
    <meta-data android:name=""android.app.device_admin""
               android:resource=""@xml/device_admin_sample"" />
    <intent-filter>
        <action android:name=""android.app.action.DEVICE_ADMIN_ENABLED"" />
    </intent-filter>
</receiver>
<receiver android:name="".app.DeviceAdminSample$DeviceAdminSampleReceiver2""
    android:label=""@string/sample_device_admin2""
    android:description=""@string/sample_device_admin_description2""
    android:permission=""android.permission.BIND_DEVICE_ADMIN"">
    <meta-data android:name=""android.app.device_admin""
        android:resource=""@xml/device_admin_sample"" />
    <intent-filter>
        <action android:name=""android.app.action.DEVICE_ADMIN_ENABLED"" />
    </intent-filter>
</receiver> The meta-data referenced here provides addition information specific
 to the device administrator as parsed by the  DeviceAdminInfo  class.
 A typical file would be: <device-admin xmlns:android=""http://schemas.android.com/apk/res/android"">
    <uses-policies>
        <limit-password />
        <watch-login />
        <reset-password />
        <force-lock />
        <wipe-data />
        <expire-password />
        <encrypted-storage />
        <disable-camera />
        <disable-keyguard-features />
    </uses-policies>
</device-admin>","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",IPC,callback,1,no,yes,no,SINK,
"<android.test.TouchUtils: void scrollToTop(InstrumentationTestCase,Activity,ViewGroup)>",Scroll a ViewGroup to the top by repeatedly calling dragQuarterScreenDown(android.test.InstrumentationTestCase android.app.Activity),"test InstrumentationTestCase : The test case that is being run |||
activity Activity : The activity that is in the foreground of the test case |||
v ViewGroup : The ViewGroup that should be dragged |||",void,3,"Reusable methods for generating touch events. These methods can be used with
 InstrumentationTestCase or ActivityInstrumentationTestCase2 to simulate user interaction with
 the application through a touch screen.",,no,UI,0,no,no,no,no,
<android.nfc.tech.MifareClassic: void close()>,"Disable I/O operations to the tag from this TagTechnology object and release resources. Also causes all blocked I/O operations on other thread to be canceled and
 return with IOException . Requires the Manifest.permission.NFC permission.",,void,-1,"Provides access to MIFARE Classic properties and I/O operations on a  Tag .

  Acquire a  MifareClassic  object using  get(Tag) .

  MIFARE Classic is also known as MIFARE Standard.
  MIFARE Classic tags are divided into sectors and each sector is sub-divided into
 blocks. Block size is always 16 bytes ( BLOCK_SIZE . Sector size varies.
  MIFARE Classic Mini are 320 bytes ( SIZE_MINI ) with 5 sectors each of 4 blocks.
  MIFARE Classic 1k are 1024 bytes ( SIZE_1K ) with 16 sectors each of 4 blocks.
  MIFARE Classic 2k are 2048 bytes ( SIZE_2K ) with 32 sectors each of 4 blocks.
  MIFARE Classic 4k are 4096 bytes ( SIZE_4K ). The first 32 sectors contain 4 blocks
 and the last 8 sectors contain 16 blocks.
  MIFARE Classic tags require authentication on a per-sector basis before any
 other I/O operations on that sector can be performed. There are two keys per sector
 and ACL bits determine what I/O operations are allowed on that sector after
 authenticating with a key.  and
 .

  Three well-known authentication keys are defined in this class:
  KEY_DEFAULT   KEY_MIFARE_APPLICATION_DIRECTORY 
  KEY_NFC_FORUM .
  KEY_DEFAULT  is the default factory key for MIFARE Classic.
  KEY_MIFARE_APPLICATION_DIRECTORY  is the well-known key for
 MIFARE Classic cards that have been formatted according to the
 MIFARE Application Directory (MAD) specification.
  KEY_NFC_FORUM  is the well-known key for MIFARE Classic cards that
 have been formatted according to the NXP specification for NDEF on MIFARE Classic.

  Implementation of this class on a Android NFC device is optional.
 If it is not implemented then
  MifareClassic  will never be enumerated in  Tag#getTechList .
 If it is enumerated then all  MifareClassic  I/O operations will be supported
 and  Ndef#MIFARE_CLASSIC  NDEF tags will also be supported. In either case
  NfcA  will also be enumerated on the tag because all MIFARE Classic tags are also
  NfcA .

  Note:  Methods that perform I/O operations
 require the  Manifest.permission.NFC  permission.","These classes provide access to a tag technology's features which vary by the type
 of tag that is scanned. A scanned tag can support multiple technologies and you can find
 out what they are by calling  getTechList() . For more information on dealing with tag technologies and handling the ones that you care about see
  The Tag Dispatch System .
 The  TagTechnology  interface provides an overview of the
 supported technologies.",no,no,0,no,no,no,no,
"<android.accessibilityservice.AccessibilityServiceInfo: void writeToParcel(Parcel,int)>",Flatten this object in to a Parcel.,"parcel Parcel : The Parcel in which the object should be written. |||
flagz int : Additional flags about how the object should be written.
May be 0 or Parcelable.PARCELABLE_WRITE_RETURN_VALUE .
Value is either 0 or a combination of Parcelable.PARCELABLE_WRITE_RETURN_VALUE and android.os.Parcelable.PARCELABLE_ELIDE_DUPLICATES |||",void,4,"This class describes an  AccessibilityService . The system notifies an
  AccessibilityService  for  AccessibilityEvent s
 according to the information encapsulated in this class.","The classes in this package are used for development of accessibility service that
   provide alternative or augmented feedback to the user.
  
   An  AccessibilityService  runs in the background and
   receives callbacks by the system when  AccessibilityEvent s
   are fired. Such events denote some state transition in the user interface for example the
   focus has changed a button has been clicked etc. Such a service can optionally request the
   capability for querying the content of the active window. Development of an accessibility
   service requires extends this class and implements its abstract methods.
  
   An  AccessibilityServiceInfo  describes an
    AccessibilityService . The system notifies an
   AccessibilityService for  AccessibilityEvent s
   according to the information encapsulated in this class.",IPC,no,0,no,no,no,no,
"<android.content.ContentProviderClient: Cursor query(Uri,String,String,String,String)>",See ContentProvider#query,"url Uri : This value must never be null . |||
projection String : This value may be null . |||
selection String : This value may be null . |||
selectionArgs String : This value may be null . |||
sortOrder String : This value may be null . |||",Cursor This value may be null . |||,5,"Content providers are one of the primary building blocks of Android applications providing
 content to applications. They encapsulate data and provide it to applications through the single
  ContentResolver  interface. A content provider is only required if you need to share
 data between multiple applications. For example the contacts data is used by multiple
 applications and must be stored in a content provider. If you don't need to share data amongst
 multiple applications you can use a database directly via
  SQLiteDatabase .

  When a request is made via
 a  ContentResolver  the system inspects the authority of the given URI and passes the
 request to the content provider registered with the authority. The content provider can interpret
 the rest of the URI however it wants. The  UriMatcher  class is helpful for parsing
 URIs. The primary methods that need to be implemented are:
  onCreate()  which is called to initialize the provider query(Uri String[] Bundle CancellationSignal)  which returns data to the caller insert(Uri ContentValues)  which inserts new data into the content provider update(Uri ContentValues String String[])  which updates existing data in the content provider delete(Uri String String[])  which deletes data from the content provider getType(Uri)  which returns the MIME type of data in the content provider Requests to  ContentResolver  are automatically forwarded to the appropriate
 ContentProvider instance so subclasses don't have to worry about the details of
 cross-process calls.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",database data,database,1,yes,no,SOURCE,no,
<android.telephony.TelephonyManager: int getNetworkType()>,"This method was deprecated
      in API level R. use getDataNetworkType() Return the current data network type. Requires Manifest.permission.READ_PHONE_STATE",,"int the NETWORK_TYPE_xxxx for current data connection.
 
 Value is NETWORK_TYPE_UNKNOWN  NETWORK_TYPE_GPRS  NETWORK_TYPE_EDGE  NETWORK_TYPE_UMTS  NETWORK_TYPE_CDMA  NETWORK_TYPE_EVDO_0  NETWORK_TYPE_EVDO_A  NETWORK_TYPE_1xRTT  NETWORK_TYPE_HSDPA  NETWORK_TYPE_HSUPA  NETWORK_TYPE_HSPA  NETWORK_TYPE_IDEN  NETWORK_TYPE_EVDO_B  NETWORK_TYPE_LTE  NETWORK_TYPE_EHRPD  NETWORK_TYPE_HSPAP  NETWORK_TYPE_GSM  NETWORK_TYPE_TD_SCDMA  NETWORK_TYPE_IWLAN or NETWORK_TYPE_NR |||",1,"Provides access to information about the telephony services on
 the device. Applications can use the methods in this class to
 determine telephony services and states as well as to access some
 types of subscriber information. Applications can also register
 a listener to receive notification of telephony state changes.
  
 The returned TelephonyManager will use the default subscription for all calls.
 To call an API for a specific subscription use  createForSubscriptionId(int) . e.g.
  
   telephonyManager = defaultSubTelephonyManager.createForSubscriptionId(subId);
  
 Note that access to some telephony information is
 permission-protected. Your application cannot access the protected
 information unless it has the appropriate permissions declared in
 its manifest file. Where permissions apply they are noted in the
 the methods through which you access the protected information.",,network info,network ,1,yes,no,SOURCE,no,
"<android.webkit.WebView: void addJavascriptInterface(Object,String)>","Injects the supplied Java object into this WebView. The object is
 injected into all frames of the web page including all the iframes
 using the supplied name. This allows the Java object's methods to be
 accessed from JavaScript. For applications targeted to API
 level Build.VERSION_CODES.JELLY_BEAN_MR1 and above only public methods that are annotated with JavascriptInterface can be accessed from JavaScript.
 For applications targeted to API level Build.VERSION_CODES.JELLY_BEAN or below
 all public methods (including the inherited ones) can be accessed see the
 important security note below for implications. Note that injected objects will not appear in JavaScript until the page is next
 (re)loaded. JavaScript should be enabled before injecting the object. For example: IMPORTANT: This method can be used to allow JavaScript to control the host
 application. This is a powerful feature but also presents a security
 risk for apps targeting Build.VERSION_CODES.JELLY_BEAN or earlier.
 Apps that target a version later than Build.VERSION_CODES.JELLY_BEAN are still vulnerable if the app runs on a device running Android earlier than 4.2.
 The most secure way to use this method is to target Build.VERSION_CODES.JELLY_BEAN_MR1 and to ensure the method is called only when running on Android 4.2 or later.
 With these older versions JavaScript could use reflection to access an
 injected object's public fields. Use of this method in a WebView
 containing untrusted content could allow an attacker to manipulate the
 host application in unintended ways executing Java code with the
 permissions of the host application. Use extreme care when using this
 method in a WebView which could contain untrusted content. 
JavaScript interacts with Java object on a private background
 thread of this WebView. Care is therefore required to maintain thread
 safety. 
Because the object is exposed to all the frames any frame could
 obtain the object name and call methods on it. There is no way to tell the
 calling frame's origin from the app side so the app must not assume that
 the caller is trustworthy unless the app can guarantee that no third party
 content is ever loaded into the WebView even inside an iframe. 
The Java object's fields are not accessible. 
For applications targeted to API level Build.VERSION_CODES.LOLLIPOP and above methods of injected Java objects are enumerable from
 JavaScript.","object Object : the Java object to inject into this WebView's JavaScript
context. null values are ignored.
This value must never be null . |||
name String : the name used to expose the object in JavaScript
This value must never be null . |||",void,1,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",no,network ,0,no,no,no,no,
"<android.content.ContextWrapper: void sendStickyBroadcastAsUser(Intent,UserHandle)>","This method is deprecated. Sticky broadcasts should not be used.  They provide no security (anyone
 can access them) no protection (anyone can modify them) and many other problems.
 The recommended pattern is to use a non-sticky broadcast to report that something has changed with another mechanism for apps to retrieve the current value whenever
 desired. Version of sendStickyBroadcast(android.content.Intent) that allows you to specify the
 user the broadcast will be sent to.  This is not available to applications
 that are not pre-installed on the system image. Requires android.Manifest.permission.INTERACT_ACROSS_USERS and Manifest.permission.BROADCAST_STICKY","intent Intent : The Intent to broadcast; all receivers matching this
Intent will receive the broadcast and the Intent will be held to
be re-broadcast to future receivers. |||
user UserHandle : UserHandle to send the intent to. |||",void,17,"Proxying implementation of Context that simply delegates all of its calls to
 another Context.  Can be subclassed to modify behavior without changing
 the original Context.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",IPC,IPC,1,no,yes,no,SINK,
<android.view.View: void buildDrawingCache()>,"This method was deprecated
      in API level 28. The view drawing cache was largely made obsolete with the introduction of
 hardware-accelerated rendering in API 11. With hardware-acceleration intermediate cache
 layers are largely unnecessary and can easily result in a net loss in performance due to the
 cost of creating and updating the layer. In the rare cases where caching layers are useful
 such as for alpha animations setLayerType(int android.graphics.Paint) handles this with hardware
 rendering. For software-rendered snapshots of a small part of the View hierarchy or
 individual Views it is recommended to create a Canvas from either a Bitmap or Picture and call draw(android.graphics.Canvas) on the View. However these
 software-rendered usages are discouraged and have compatibility issues with hardware-only
 rendering features such as Config.HARDWARE bitmaps real-time shadows and outline clipping. For screenshots of the UI for feedback
 reports or unit testing the PixelCopy API is recommended. Calling this method is equivalent to calling buildDrawingCache(false) .",,void,1,"This class represents the basic building block for user interface components. A View
 occupies a rectangular area on the screen and is responsible for drawing and
 event handling. View is the base class for  widgets  which are
 used to create interactive UI components (buttons text fields etc.). The
  ViewGroup  subclass is the base class for  layouts  which
 are invisible containers that hold other Views (or other ViewGroups) and define
 their layout properties.",,no,no,0,no,no,no,no,
"<android.view.TextureView: Bitmap getBitmap(int,int)>","Returns a Bitmap representation of the content
 of the associated surface texture. If the surface texture is not available
 this method returns null. The bitmap returned by this method uses the Bitmap.Config#ARGB_8888 pixel format. Do not invoke this method from a drawing method
 ( onDraw(android.graphics.Canvas) for instance). If an error occurs during the copy an empty bitmap will be returned.","width int : The width of the bitmap to create |||
height int : The height of the bitmap to create |||","Bitmap A valid Bitmap.Config#ARGB_8888 bitmap or null if the surface
         texture is not available or width is <= 0 or height is <= 0 |||",14,"A TextureView can be used to display a content stream. Such a content
 stream can for instance be a video or an OpenGL scene. The content stream
 can come from the application's process as well as a remote process. TextureView can only be used in a hardware accelerated window. When
 rendered in software TextureView will draw nothing. Unlike  SurfaceView  TextureView does not create a separate
 window but behaves as a regular View. This key difference allows a
 TextureView to be moved transformed animated etc. For instance you
 can make a TextureView semi-translucent by calling
  myView.setAlpha(0.5f) . Using a TextureView is simple: all you need to do is get its
  SurfaceTexture . The  SurfaceTexture  can then be used to
 render content. The following example demonstrates how to render the
 camera preview into a TextureView: 
  public class LiveCameraActivity extends Activity implements TextureView.SurfaceTextureListener {
      private Camera mCamera;
      private TextureView mTextureView;

      protected void onCreate(Bundle savedInstanceState) {
          super.onCreate(savedInstanceState);

          mTextureView = new TextureView(this);
          mTextureView.setSurfaceTextureListener(this);

          setContentView(mTextureView);
      }

      public void onSurfaceTextureAvailable(SurfaceTexture surface int width int height) {
          mCamera = Camera.open();

          try {
              mCamera.setPreviewTexture(surface);
              mCamera.startPreview();
          } catch (IOException ioe) {
              // Something bad happened
          }
      }

      public void onSurfaceTextureSizeChanged(SurfaceTexture surface int width int height) {
          // Ignored Camera does all the work for us
      }

      public boolean onSurfaceTextureDestroyed(SurfaceTexture surface) {
          mCamera.stopPreview();
          mCamera.release();
          return true;
      }

      public void onSurfaceTextureUpdated(SurfaceTexture surface) {
          // Invoked every time there's a new Camera preview frame
      }
  }
  A TextureView's SurfaceTexture can be obtained either by invoking
  getSurfaceTexture()  or by using a  SurfaceTextureListener .
 It is important to know that a SurfaceTexture is available only after the
 TextureView is attached to a window (and  onAttachedToWindow()  has
 been invoked.) It is therefore highly recommended you use a listener to
 be notified when the SurfaceTexture becomes available. It is important to note that only one producer can use the TextureView.
 For instance if you use a TextureView to display the camera preview you
 cannot use  lockCanvas()  to draw onto the TextureView at the same
 time.",,screenshot,UI,1,yes,no,SOURCE,no,
<android.widget.VideoView: void setVideoURI(Uri)>,Sets video URI.,uri Uri : the URI of the video. |||,void,1,"Displays a video file.  The VideoView class
 can load images from various sources (such as resources or content
 providers) takes care of computing its measurement from the video so that
 it can be used in any layout manager and provides various display options
 such as scaling and tinting. Note: VideoView does not retain its full state when going into the
 background.   In particular it does not restore the current play state
 play position selected tracks or any subtitle tracks added via
  addSubtitleSource() .  Applications should
 save and restore these on their own in
  Activity.onSaveInstanceState(Bundle)  and
  Activity.onRestoreInstanceState(Bundle) . 
 Also note that the audio session id (from  getAudioSessionId() ) may
 change from its previously returned value when the VideoView is restored.
  
 By default VideoView requests audio focus with  AudioManager#AUDIOFOCUS_GAIN . Use
  setAudioFocusRequest(int)  to change this behavior.
  
 The default  AudioAttributes  used during playback have a usage of
  AudioAttributes#USAGE_MEDIA  and a content type of
  AudioAttributes#CONTENT_TYPE_MOVIE  use  setAudioAttributes(android.media.AudioAttributes)  to
 modify them.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,video,0,no,no,no,no,
"<android.content.ContextWrapper: SharedPreferences getSharedPreferences(String,int)>","Retrieve and hold the contents of the preferences file 'name' returning
 a SharedPreferences through which you can retrieve and modify its
 values.  Only one instance of the SharedPreferences object is returned
 to any callers for the same name meaning they will see each other's
 edits as soon as they are made. This method is thread-safe. If the preferences directory does not already exist it will be created when this method
 is called. If a preferences file by this name does not exist it will be created when you retrieve an
 editor ( SharedPreferences#edit() ) and then commit changes ( SharedPreferences.Editor#commit() or SharedPreferences.Editor#apply() ).","name String : Desired preferences file. |||
mode int : Operating mode.
Value is either 0 or a combination of Context.MODE_PRIVATE  Context.MODE_WORLD_READABLE  Context.MODE_WORLD_WRITEABLE and Context.MODE_MULTI_PROCESS |||","SharedPreferences The single SharedPreferences instance that can be used
         to retrieve and modify the preference values. |||",1,"Proxying implementation of Context that simply delegates all of its calls to
 another Context.  Can be subclassed to modify behavior without changing
 the original Context.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",preferences,preference storage file,1,yes,no,SOURCE,no,
"<android.location.Geocoder: List getFromLocation(double,double,int)>","Returns an array of Addresses that are known to describe the
 area immediately surrounding the given latitude and longitude.
 The returned addresses will be localized for the locale
 provided to this class's constructor. The returned values may be obtained by means of a network lookup.
 The results are a best guess and are not guaranteed to be meaningful or
 correct. It may be useful to call this method from a thread separate from your
 primary UI thread.","latitude double : the latitude a point for the search |||
longitude double : the longitude a point for the search |||
maxResults int : max number of addresses to return. Smaller numbers (1 to 5) are recommended |||","List < Address > a list of Address objects. Returns null or empty list if no matches were
 found or there is no backend service available. |||",1,"A class for handling geocoding and reverse geocoding.  Geocoding is
 the process of transforming a street address or other description
 of a location into a (latitude longitude) coordinate.  Reverse
 geocoding is the process of transforming a (latitude longitude)
 coordinate into a (partial) address.  The amount of detail in a
 reverse geocoded location description may vary for example one
 might contain the full street address of the closest building while
 another might contain only a city name and postal code.

 The Geocoder class requires a backend service that is not included in
 the core android framework.  The Geocoder query methods will return an
 empty list if there no backend service in the platform.  Use the
 isPresent() method to determine whether a Geocoder implementation
 exists.","Contains the framework API classes that define Android location-based and
 	related services. This API is not the recommended method for accessing Android location. 
 The
  Google Location Services API 
 part of Google Play services is the preferred way to add location-awareness to
 your app. It offers a simpler API higher accuracy low-power geofencing and
 more. If you are currently using the android.location API you are strongly
 encouraged to switch to the Google Location Services API as soon as
 possible.
  
 To learn more about the Google Location Services API see the
  Location API overview .",no,location sensors,0,no,no,no,no,
"<android.app.NotificationManager: void notify(String,int,Notification)>","Posts a notification to be shown in the status bar. If a notification with
 the same tag and id has already been posted by your application and has not yet been
 canceled it will be replaced by the updated information.

 All listener services will
 be granted Intent#FLAG_GRANT_READ_URI_PERMISSION access to any Uri provided on this notification or the NotificationChannel this notification is posted to using Context#grantUriPermission(String Uri int) . Permission will be revoked when the
 notification is canceled or you can revoke permissions with Context#revokeUriPermission(Uri int) .","tag String : A string identifier for this notification.  May be null . |||
id int : An identifier for this notification.  The pair (tag id) must be unique
within your application. |||
notification Notification : A Notification object describing what to
show the user. Must not be null. |||",void,5,"A class that represents how a persistent notification is to be presented to
 the user using the  NotificationManager .

  The  Notification.Builder  has been added to make it
 easier to construct Notifications.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",uncategorized,UI,1,no,yes,no,SINK,
<android.widget.ImageSwitcher: void setImageResource(int)>,"Sets a new image on the ImageSwitcher with the given resource id.
 This will set that image resource on the next ImageView in the switcher and will
 then switch to that view.",resid int : a Drawable resource id |||,void,1,"ViewSwitcher  that switches between two ImageViews when a new
 image is set on it. The views added to an ImageSwitcher must all be
  ImageView .","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,UI,0,no,no,no,no,
<android.widget.TextView: void setText(int)>,Sets the text to be displayed using a string resource identifier. Related XML Attributes: android:text,resid int : the resource identifier of the string resource to be displayed |||,void,1,"A user interface element that displays text to the user.
 To provide user-editable text see  EditText .
  
 The following code sample shows a typical use with an XML layout
 and code to modify the contents of the text view:
  
 <LinearLayout
      xmlns:android=""http://schemas.android.com/apk/res/android""
      android:layout_width=""match_parent""
      android:layout_height=""match_parent"">
    <TextView
        android:id=""@+id/text_view_id""
        android:layout_height=""wrap_content""
        android:layout_width=""wrap_content""
        android:text=""@string/hello"" />
 </LinearLayout>
  
 This code sample demonstrates how to modify the contents of the text view
 defined in the previous XML layout:
  
 public class MainActivity extends Activity {

    protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_main);
         final TextView helloTextView = (TextView) findViewById(R.id.text_view_id);
         helloTextView.setText(R.string.user_greeting);
     }
 }
  
 To customize the appearance of TextView see  Styles and Themes .
  XML attributes 
 See  TextView Attributes 
  View Attributes","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,UI,0,no,no,no,no,
"<android.content.Intent: Intent putExtra(String,int)>","Add extended data to the intent.  The name must include a package
 prefix for example the app com.android.contacts would use names
 like ""com.android.contacts.ShowAll"".","name String : The name of the extra data with package prefix. |||
value int : The integer data value. |||","Intent Returns the same Intent object for chaining multiple calls
 into a single statement.

 This value will never be null . |||",1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",IPC,no,0,no,no,no,no,
<android.telephony.TelephonyManager: String getLine1Number()>,"Returns the phone number string for line 1 for example the MSISDN
 for a GSM phone. Return null if it is unavailable. Requires Permission: READ_PHONE_STATE  READ_SMS  READ_PHONE_NUMBERS that the caller is the default SMS app
     or that the caller has carrier privileges (see hasCarrierPrivileges() ). Requires Manifest.permission.READ_PHONE_STATE or Manifest.permission.READ_SMS or Manifest.permission.READ_PHONE_NUMBERS",,String |||,1,"Provides access to information about the telephony services on
 the device. Applications can use the methods in this class to
 determine telephony services and states as well as to access some
 types of subscriber information. Applications can also register
 a listener to receive notification of telephony state changes.
  
 The returned TelephonyManager will use the default subscription for all calls.
 To call an API for a specific subscription use  createForSubscriptionId(int) . e.g.
  
   telephonyManager = defaultSubTelephonyManager.createForSubscriptionId(subId);
  
 Note that access to some telephony information is
 permission-protected. Your application cannot access the protected
 information unless it has the appropriate permissions declared in
 its manifest file. Where permissions apply they are noted in the
 the methods through which you access the protected information.",,phone info,phone,1,yes,no,SOURCE,no,
"<android.appwidget.AppWidgetManager: void notifyAppWidgetViewDataChanged(int,int)>","Notifies the specified collection view in the specified AppWidget instance
 to invalidate its data.","appWidgetId int : The AppWidget instance to notify of view data changes. |||
viewId int : The collection view id. |||",void,11,"Updates AppWidget state; gets information about installed AppWidget providers and other
 AppWidget related state.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,UI,0,no,no,no,no,
<android.app.Activity: void finish()>,"Call this when your activity is done and should be closed.  The
 ActivityResult is propagated back to whoever launched you via
 onActivityResult().",,void,1,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
<android.nfc.tech.NfcF: void setTimeout(int)>,"Set the transceive(byte[]) timeout in milliseconds. The timeout only applies to transceive(byte[]) on this object
 and is reset to a default value when close() is called. Setting a longer timeout may be useful when performing
 transactions that require a long processing time on the tag
 such as key generation. Requires the Manifest.permission.NFC permission.",timeout int : timeout value in milliseconds |||,void,14,"Provides access to NFC-F (JIS 6319-4) properties and I/O operations on a  Tag .

  Acquire a  NfcF  object using  get(Tag) .
  The primary NFC-F I/O operation is  transceive(byte[]) . Applications must
 implement their own protocol stack on top of  transceive(byte[]) .

  Note:  Methods that perform I/O operations
 require the  Manifest.permission.NFC  permission.","These classes provide access to a tag technology's features which vary by the type
 of tag that is scanned. A scanned tag can support multiple technologies and you can find
 out what they are by calling  getTechList() . For more information on dealing with tag technologies and handling the ones that you care about see
  The Tag Dispatch System .
 The  TagTechnology  interface provides an overview of the
 supported technologies.",no,no,0,no,no,no,no,
<android.appwidget.AppWidgetHostView: void updateAppWidgetOptions(Bundle)>,"Specify some extra information for the widget provider. Causes a callback to the
 AppWidgetProvider.",options Bundle : The bundle of options information. |||,void,16,"Provides the glue to show AppWidget views. This class offers automatic animation
 between updates and will try recycling old views for each incoming
  RemoteViews .","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",uncategorized,UI,1,no,yes,no,SINK,
"<android.app.Activity: void startIntentSenderForResult(IntentSender,int,Intent,int,int,int)>",Same as calling startIntentSenderForResult(android.content.IntentSender int android.content.Intent int int int android.os.Bundle) with no options.,"intent IntentSender : The IntentSender to launch. |||
requestCode int : If >= 0 this code will be returned in
onActivityResult() when the activity exits. |||
fillInIntent Intent : If non-null this will be provided as the
intent parameter to IntentSender#sendIntent .
This value may be null . |||
flagsMask int : Intent flags in the original IntentSender that you
would like to change. |||
flagsValues int : Desired values for any bits set in flagsMask |||
extraFlags int : Always set to 0. |||",void,5,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",IPC,IPC,1,no,yes,no,SINK,
<android.webkit.WebView: void setDownloadListener(DownloadListener)>,"Registers the interface to be used when content can not be handled by
 the rendering engine and should be downloaded instead. This will replace
 the current handler.","listener DownloadListener : an implementation of DownloadListener
This value may be null . |||",void,1,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",no,no,0,no,no,no,no,
"<android.widget.RemoteViews: void setImageViewUri(int,Uri)>",Equivalent to calling ImageView#setImageURI(Uri),"viewId int : The id of the view whose drawable should change |||
uri Uri : The Uri for the image |||",void,1,"A class that describes a view hierarchy that can be displayed in
 another process. The hierarchy is inflated from a layout resource
 file and this class provides some basic operations for modifying
 the content of the inflated hierarchy.

  RemoteViews  is limited to support for the following layouts: AdapterViewFlipper FrameLayout GridLayout GridView LinearLayout ListView RelativeLayout StackView ViewFlipper And the following widgets: AnalogClock Button Chronometer ImageButton ImageView ProgressBar TextClock TextView Descendants of these classes are not supported.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",image,UI,1,no,yes,no,SINK,
<android.content.pm.ApplicationInfo: CharSequence loadDescription(PackageManager)>,"Retrieve the textual description of the application.  This
 will call back on the given PackageManager to load the description from
 the application.","pm PackageManager : A PackageManager from which the label can be loaded; usually
the PackageManager from which you originally retrieved this item. |||","CharSequence Returns a CharSequence containing the application's description.
 If there is no description null is returned. |||",1,"Information you can retrieve about a particular application.  This
 corresponds to information collected from the AndroidManifest.xml's
 <application> tag.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,
<android.net.sip.SipSession: void unregister()>,"Performs unregistration to the server specified by the associated local
 profile. Unregistration is technically the same as registration with zero
 expiration duration. The session listener is called back upon success or
 failure of unregistration. The method is only valid to call when the
 session state is in State#READY_TO_CALL .",,void,9,"Represents a SIP session that is associated with a SIP dialog or a standalone
 transaction not within a dialog.
  You can get a  SipSession  from  SipManager  with  SipManager#createSipSession  (when initiating calls) or  SipManager#getSessionFor  (when receiving calls).",,no,no,0,no,no,no,no,
<android.app.admin.DevicePolicyManager: int getPasswordMinimumSymbols(ComponentName)>,"Retrieve the current number of symbols required in the password
 for a particular admin or all admins that set restrictions on this user
 and its participating profiles. Restrictions on profiles that have
 a separate challenge are not taken into account. This is the same value as
 set by setPasswordMinimumSymbols(android.content.ComponentName int) and only applies when the password quality is PASSWORD_QUALITY_COMPLEX . On devices not supporting PackageManager#FEATURE_SECURE_LOCK_SCREEN feature the
 password is always treated as empty. This method can be called on the DevicePolicyManager instance
 returned by getParentProfileInstance(android.content.ComponentName) in order to retrieve
 restrictions on the parent profile.","admin ComponentName : The name of the admin component to check or null to
aggregate all admins.
This value may be null . |||",int The minimum number of symbols required in the password. |||,11,"Public interface for managing policies enforced on a device. Most clients of this class must be
 registered with the system as a  device
 administrator . Additionally a device administrator may be registered as either a profile or
 device owner. A given method is accessible to all device administrators unless the documentation
 for that method specifies that it is restricted to either device or profile owners. Any
 application calling an api may only pass as an argument a device administrator component it
 owns. Otherwise a  SecurityException  will be thrown.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",password metadata,password file ,1,yes,no,SOURCE,no,
<android.content.ContentResolver: InputStream openInputStream(Uri)>,"Open a stream on to the content associated with a content URI.  If there
 is no data associated with the URI FileNotFoundException is thrown. content ( SCHEME_CONTENT ) 
android.resource ( SCHEME_ANDROID_RESOURCE ) 
file ( SCHEME_FILE ) 
See openAssetFileDescriptor(android.net.Uri java.lang.String) for more information
 on these schemes.","uri Uri : The desired URI.
This value must never be null . |||","InputStream InputStream
 This value may be null . |||",1,This class provides applications access to the content model.,"Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",file data,file,1,yes,no,SOURCE,no,
<android.content.ContextWrapper: void removeStickyBroadcast(Intent)>,"This method is deprecated. Sticky broadcasts should not be used.  They provide no security (anyone
 can access them) no protection (anyone can modify them) and many other problems.
 The recommended pattern is to use a non-sticky broadcast to report that something has changed with another mechanism for apps to retrieve the current value whenever
 desired. Remove the data previously sent with sendStickyBroadcast(Intent) so that it is as if the sticky broadcast had never happened. Requires Manifest.permission.BROADCAST_STICKY",intent Intent : The Intent that was previously broadcast. |||,void,1,"Proxying implementation of Context that simply delegates all of its calls to
 another Context.  Can be subclassed to modify behavior without changing
 the original Context.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,IPC,0,no,no,no,no,
<android.nfc.tech.NfcF: void close()>,"Disable I/O operations to the tag from this TagTechnology object and release resources. Also causes all blocked I/O operations on other thread to be canceled and
 return with IOException . Requires the Manifest.permission.NFC permission.",,void,-1,"Provides access to NFC-F (JIS 6319-4) properties and I/O operations on a  Tag .

  Acquire a  NfcF  object using  get(Tag) .
  The primary NFC-F I/O operation is  transceive(byte[]) . Applications must
 implement their own protocol stack on top of  transceive(byte[]) .

  Note:  Methods that perform I/O operations
 require the  Manifest.permission.NFC  permission.","These classes provide access to a tag technology's features which vary by the type
 of tag that is scanned. A scanned tag can support multiple technologies and you can find
 out what they are by calling  getTechList() . For more information on dealing with tag technologies and handling the ones that you care about see
  The Tag Dispatch System .
 The  TagTechnology  interface provides an overview of the
 supported technologies.",no,nfc,0,no,no,no,no,
<android.content.ClipboardManager: void setPrimaryClip(ClipData)>,"Sets the current primary clip on the clipboard.  This is the clip that
 is involved in normal cut and paste operations.","clip ClipData : The clipped data item to set.
This value must never be null . |||",void,11,"Interface to the clipboard service for placing and retrieving text in
 the global clipboard.

  
 The ClipboardManager API itself is very simple: it consists of methods
 to atomically get and set the current primary clipboard data.  That data
 is expressed as a  ClipData  object which defines the protocol
 for data exchange between applications.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",uncategorized,clipboard,1,no,yes,no,SINK,
<android.preference.MultiSelectListPreference: void setEntries(int)>,,entriesResId int : The entries array as a resource. |||,void,11,"A  Preference  that displays a list of entries as
 a dialog.
  
 This preference will store a set of strings into the SharedPreferences.
 This set will contain one or more values from the
  setEntryValues(java.lang.CharSequence[])  array.",,no,no,0,no,no,no,no,
"<android.preference.PreferenceActivity: Intent onBuildStartFragmentIntent(String,Bundle,int,int)>","Called by startWithFragment(java.lang.String android.os.Bundle android.app.Fragment int int int) when
 in single-pane mode to build an Intent to launch a new activity showing
 the selected fragment.  The default implementation constructs an Intent
 that re-launches the current activity with the appropriate arguments to
 display the fragment.","fragmentName String : The name of the fragment to display. |||
args Bundle : Optional arguments to supply to the fragment. |||
titleRes int : Optional resource ID of title to show for this item. |||
shortTitleRes int : Optional resource ID of short title to show for this item. |||","Intent Returns an Intent that can be launched to display the given
 fragment. |||",14,"This is the base class for an activity to show a hierarchy of preferences
 to the user.  Prior to  Build.VERSION_CODES.HONEYCOMB 
 this class only allowed the display of a single set of preference; this
 functionality should now be found in the new  PreferenceFragment 
 class.  If you are using PreferenceActivity in its old mode the documentation
 there applies to the deprecated APIs here.

  This activity shows one or more headers of preferences each of which
 is associated with a  PreferenceFragment  to display the preferences
 of that header.  The actual layout and display of these associations can
 however vary; currently there are two major approaches it may take:

  On a small screen it may display only the headers as a single list when first launched.
 Selecting one of the header items will only show the PreferenceFragment of that header (on
 Android N and lower a new Activity is launched).
  On a large screen it may display both the headers and current PreferenceFragment together as
 panes. Selecting a header item switches to showing the correct PreferenceFragment for that item.
  Subclasses of PreferenceActivity should implement
  onBuildHeaders(List )  to populate the header list with the desired
 items.  Doing this implicitly switches the class into its new ""headers
 + fragments"" mode rather than the old style of just showing a single
 preferences list.",,IPC,no,0,no,no,no,no,
<android.media.MediaScannerConnection: void connect()>,Initiates a connection to the media scanner service. MediaScannerConnectionClient#onMediaScannerConnected() will be called when the connection is established.,,void,1,"MediaScannerConnection provides a way for applications to pass a
 newly created or downloaded media file to the media scanner service.
 The media scanner service will read metadata from the file and add
 the file to the media content provider.
 The MediaScannerConnectionClient provides an interface for the
 media scanner service to return the Uri for a newly scanned file
 to the client of the MediaScannerConnection class.","The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",no,no,0,no,no,no,no,
<android.app.DialogFragment: void onStop()>,"Called when the Fragment is no longer started.  This is generally
 tied to Activity#onStop() of the containing
 Activity's lifecycle. If you override this method you must call through to the
 superclass implementation.",,void,11,"Base class for Dialogs.

  Note: Activities provide a facility to manage the creation saving and
 restoring of dialogs. See  Activity#onCreateDialog(int) 
  Activity#onPrepareDialog(int Dialog) 
  Activity#showDialog(int)  and  Activity#dismissDialog(int) . If
 these methods are used  getOwnerActivity()  will return the Activity
 that managed this dialog.

  Often you will want to have a Dialog display on top of the current
 input method because there is no reason for it to accept text.  You can
 do this by setting the  WindowManager.LayoutParams#FLAG_ALT_FOCUSABLE_IM  window flag (assuming
 your Dialog takes input focus as it the default) with the following code:

  
 getWindow().setFlags(WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM
         WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
"<android.text.Selection: void setSelection(Spannable,int)>",Move the cursor to offset index .,"text Spannable |||
index int |||",void,1,"Utility class for manipulating cursors and selections in CharSequences.
 A cursor is a selection where the start and end are at the same offset.","Provides classes used to render or track text and text spans on the screen. You can use these classes to design your own widgets that manage text
 to handle arbitrary text spans for changes or to handle drawing yourself
 for an existing widget. The Span… interfaces and classes are used to create or manage spans of
 text in a View item. You can use these to style the text or background or to
 listen for changes. If creating your own widget extend DynamicLayout to manages
 the actual wrapping and drawing of your text.",no,no,0,no,no,no,no,
<android.animation.TimeAnimator: void start()>,"Starts this animation. If the animation has a nonzero startDelay the animation will start
 running after that delay elapses. A non-delayed animation will have its initial
 value(s) set immediately followed by calls to AnimatorListener#onAnimationStart(Animator) for any listeners of this animator. The animation started by calling this method will be run on the thread that called
 this method. This thread should have a Looper on it (a runtime exception will be thrown if
 this is not the case). Also if the animation will animate
 properties of objects in the view hierarchy then the calling thread should be the UI
 thread for that view hierarchy.",,void,16,"This class provides a simple callback mechanism to listeners that is synchronized with all
 other animators in the system. There is no duration interpolation or object value-setting
 with this Animator. Instead it is simply started after which it proceeds to send out events
 on every animation frame to its TimeListener (if set) with information about this animator
 the total elapsed time and the elapsed time since the previous animation frame.","These classes provide functionality for the property animation system which allows you
 to animate object properties of any type.  int   float  and hexadecimal
 color values are supported by default. You can animate any other type by telling the system how
 to calculate the values for that given type with a custom  TypeEvaluator .
  For more information see the
  Animation  guide. 
 You can set many different types of interpolators (contained in  android.view.animation )
 specify  keyframes  or group animations to play sequentially
 or simultaneously (with  AnimatorSet ) to further control your animation
 behaviors.",no,no,0,no,no,no,no,
<android.app.TimePickerDialog: void onRestoreInstanceState(Bundle)>,"Restore the state of the dialog from a previously saved bundle.

 The default implementation restores the state of the dialog's view
 hierarchy that was saved in the default implementation of onSaveInstanceState() so be sure to call through to super when overriding unless you want to
 do all restoring of state yourself.","savedInstanceState Bundle : The state of the dialog previously saved by onSaveInstanceState() .
This value must never be null . |||",void,1,"A dialog that prompts the user for the time of day using a
  TimePicker .

  
 See the  Pickers 
 guide.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
"<android.app.Instrumentation: void callActivityOnCreate(Activity,Bundle)>",Perform calling of an activity's Activity#onCreate method.  The default implementation simply calls through to that method.,"activity Activity : The activity being created. |||
icicle Bundle : The previously frozen state (or null) to pass through to onCreate(). |||",void,1,"Base class for implementing application instrumentation code.  When running
 with instrumentation turned on this class will be instantiated for you
 before any of the application code allowing you to monitor all of the
 interaction the system has with the application.  An Instrumentation
 implementation is described to the system through an AndroidManifest.xml's
 <instrumentation> tag.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",IPC,IPC,1,no,yes,no,SINK,
<android.webkit.WebView: void documentHasImages(Message)>,"Queries the document to see if it contains any image references. The
 message object will be dispatched with arg1 being set to 1 if images
 were found and 0 if the document does not reference any images.","response Message : the message that will be dispatched with the result
This value must never be null . |||",void,1,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",image metadata,network ,1,no,no,no,no,
<android.net.sip.SipAudioCall: int getState()>,"Gets the state of the SipSession that carries this call.
 The value returned must be one of the states in SipSession.State .",,int the session state |||,9,"Handles an Internet audio call over SIP. You can instantiate this class with  SipManager 
 using  SipManager#makeAudioCall  and   SipManager#takeAudioCall .

  Note:  Using this class require the
    Manifest.permission.INTERNET  and
    Manifest.permission.USE_SIP  permissions. In addition  startAudio()  requires the
    Manifest.permission.RECORD_AUDIO 
    Manifest.permission.ACCESS_WIFI_STATE  and
    Manifest.permission.WAKE_LOCK  permissions; and  setSpeakerMode()  requires the
    Manifest.permission.MODIFY_AUDIO_SETTINGS  permission.",,phone metadata,phone,1,yes,no,SOURCE,no,
"<android.app.PendingIntent: PendingIntent getActivity(Context,int,Intent,int)>","Retrieve a PendingIntent that will start a new activity like calling Context#startActivity(Intent) .
 Note that the activity will be started outside of the context of an
 existing activity so you must use the Intent#FLAG_ACTIVITY_NEW_TASK launch flag in the Intent. For security reasons the Intent you supply here should almost always be an explicit intent that is specify an explicit component to be delivered to through Intent#setClass(android.content.Context Class)","context Context : The Context in which this PendingIntent should start
the activity. |||
requestCode int : Private request code for the sender |||
intent Intent : Intent of the activity to be launched. |||
flags int : May be FLAG_ONE_SHOT  FLAG_NO_CREATE  FLAG_CANCEL_CURRENT  FLAG_UPDATE_CURRENT or any of the flags as supported by Intent#fillIn to control which unspecified parts
of the intent that can be supplied when the actual send happens.
Value is either 0 or a combination of FLAG_ONE_SHOT  FLAG_NO_CREATE  FLAG_CANCEL_CURRENT  FLAG_UPDATE_CURRENT  FLAG_IMMUTABLE  Intent.FILL_IN_ACTION  Intent.FILL_IN_DATA  Intent.FILL_IN_CATEGORIES  Intent.FILL_IN_COMPONENT  Intent.FILL_IN_PACKAGE  Intent.FILL_IN_SOURCE_BOUNDS  Intent.FILL_IN_SELECTOR and Intent.FILL_IN_CLIP_DATA |||","PendingIntent Returns an existing or new PendingIntent matching the given
 parameters.  May return null only if FLAG_NO_CREATE has been
 supplied. |||",1,"A description of an Intent and target action to perform with it.  Instances
 of this class are created with  getActivity(Context int Intent int)   getActivities(Context int Intent[] int) 
  getBroadcast(Context int Intent int)  and  getService(Context int Intent int) ; the returned object can be
 handed to other applications so that they can perform the action you
 described on your behalf at a later time.

  By giving a PendingIntent to another application
 you are granting it the right to perform the operation you have specified
 as if the other application was yourself (with the same permissions and
 identity).  As such you should be careful about how you build the PendingIntent:
 almost always for example the base Intent you supply should have the component
 name explicitly set to one of your own components to ensure it is ultimately
 sent there and nowhere else.

  A PendingIntent itself is simply a reference to a token maintained by
 the system describing the original data used to retrieve it.  This means
 that even if its owning application's process is killed the
 PendingIntent itself will remain usable from other processes that
 have been given it.  If the creating application later re-retrieves the
 same kind of PendingIntent (same operation same Intent action data
 categories and components and same flags) it will receive a PendingIntent
 representing the same token if that is still valid and can thus call
  cancel()  to remove it.

  Because of this behavior it is important to know when two Intents
 are considered to be the same for purposes of retrieving a PendingIntent.
 A common mistake people make is to create multiple PendingIntent objects
 with Intents that only vary in their ""extra"" contents expecting to get
 a different PendingIntent each time.  This does  not  happen.  The
 parts of the Intent that are used for matching are the same ones defined
 by  Intent#filterEquals(Intent) .  If you use two
 Intent objects that are equivalent as per
  Intent#filterEquals(Intent)  then you will get
 the same PendingIntent for both of them.

  There are two typical ways to deal with this.

  If you truly need multiple distinct PendingIntent objects active at
 the same time (such as to use as two notifications that are both shown
 at the same time) then you will need to ensure there is something that
 is different about them to associate them with different PendingIntents.
 This may be any of the Intent attributes considered by
  Intent#filterEquals(Intent)  or different
 request code integers supplied to  getActivity(Context int Intent int)   getActivities(Context int Intent[] int) 
  getBroadcast(Context int Intent int)  or  getService(Context int Intent int) .

  If you only need one PendingIntent active at a time for any of the
 Intents you will use then you can alternatively use the flags
  FLAG_CANCEL_CURRENT  or  FLAG_UPDATE_CURRENT  to either
 cancel or modify whatever current PendingIntent is associated with the
 Intent you are supplying.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",IPC,no,0,no,no,no,no,
"<android.content.Intent: Intent putExtra(String,char)>","Add extended data to the intent.  The name must include a package
 prefix for example the app com.android.contacts would use names
 like ""com.android.contacts.ShowAll"".","name String : The name of the extra data with package prefix. |||
value char : The char data value. |||","Intent Returns the same Intent object for chaining multiple calls
 into a single statement.

 This value will never be null . |||",1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,
<android.view.inputmethod.InputMethodManager: void showInputMethodAndSubtypeEnabler(String)>,Show the settings for enabling subtypes of the specified input method.,"imiId String : An input method whose subtypes settings will be shown. If imiId is null
subtypes of all input methods will be shown. |||",void,11,"Central system API to the overall input method framework (IMF) architecture
 which arbitrates interaction between applications and the current input method.

  Topics covered here:
  Architecture Overview Applications Input Methods Security Architecture Overview There are three primary parties involved in the input method
 framework (IMF) architecture:  The  input method manager  as expressed by this class
 is the central point of the system that manages interaction between all
 other parts.  It is expressed as the client-side API here which exists
 in each application context and communicates with a global system service
 that manages the interaction across all processes.
   An  input method (IME)  implements a particular
 interaction model allowing the user to generate text.  The system binds
 to the current input method that is in use causing it to be created and run
 and tells it when to hide and show its UI.  Only one IME is running at a time.
   Multiple  client applications  arbitrate with the input
 method manager for input focus and control over the state of the IME.  Only
 one such client is ever active (working with the IME) at a time.
  Applications In most cases applications that are using the standard
  TextView  or its subclasses will have little they need
 to do to work well with soft input methods.  The main things you need to
 be aware of are:  Properly set the  R.attr.inputType  in your editable
 text views so that the input method will have enough context to help the
 user in entering text into them.
   Deal well with losing screen space when the input method is
 displayed.  Ideally an application should handle its window being resized
 smaller but it can rely on the system performing panning of the window
 if needed.  You should set the  R.attr.windowSoftInputMode 
 attribute on your activity or the corresponding values on windows you
 create to help the system determine whether to pan or resize (it will
 try to determine this automatically but may get it wrong).
   You can also control the preferred soft input state (open closed etc)
 for your window using the same  R.attr.windowSoftInputMode 
 attribute.
  More finer-grained control is available through the APIs here to directly
 interact with the IMF and its IME -- either showing or hiding the input
 area letting the user pick an input method etc. For the rare people amongst us writing their own text editors you
 will need to implement  View.onCreateInputConnection(EditorInfo) 
 to return a new instance of your own  InputConnection  interface
 allowing the IME to interact with your editor. Input Methods An input method (IME) is implemented
 as a  Service  typically deriving from
  InputMethodService .  It must provide
 the core  InputMethod  interface though this is normally handled by
  InputMethodService  and implementors will
 only need to deal with the higher-level API there. InputMethodService Security There are a lot of security issues associated with input methods
 since they essentially have freedom to completely drive the UI and monitor
 everything the user enters.  The Android input method framework also allows
 arbitrary third party IMEs so care must be taken to restrict their
 selection and interactions. Here are some key points about the security architecture behind the
 IMF: Only the system is allowed to directly access an IME's
  InputMethod  interface via the
  Manifest.permission.BIND_INPUT_METHOD  permission.  This is
 enforced in the system by not binding to an input method service that does
 not require this permission so the system can guarantee no other untrusted
 clients are accessing the current input method outside of its control. There may be many client processes of the IMF but only one may
 be active at a time.  The inactive clients can not interact with key
 parts of the IMF through the mechanisms described below. Clients of an input method are only given access to its
  InputMethodSession  interface.  One instance of this interface is
 created for each client and only calls from the session associated with
 the active client will be processed by the current IME.  This is enforced
 by  AbstractInputMethodService  for normal
 IMEs but must be explicitly handled by an IME that is customizing the
 raw  InputMethodSession  implementation. Only the active client's  InputConnection  will accept
 operations.  The IMF tells each client process whether it is active and
 the framework enforces that in inactive processes calls on to the current
 InputConnection will be ignored.  This ensures that the current IME can
 only deliver events and text edits to the UI that the user sees as
 being in focus. An IME can never interact with an  InputConnection  while
 the screen is off.  This is enforced by making all clients inactive while
 the screen is off and prevents bad IMEs from driving the UI when the user
 can not be aware of its behavior. A client application can ask that the system let the user pick a
 new IME but can not programmatically switch to one itself.  This avoids
 malicious applications from switching the user to their own IME which
 remains running when the user navigates away to another application.  An
 IME on the other hand  is  allowed to programmatically switch
 the system to another IME since it already has full control of user
 input. The user must explicitly enable a new IME in settings before
 they can switch to it to confirm with the system that they know about it
 and want to make it available for use. PackageManager#FEATURE_INPUT_METHODS PackageManager.hasSystemFeature(String)",,no,no,0,no,no,no,no,
<android.app.Instrumentation: void sendPointerSync(MotionEvent)>,"Dispatch a pointer event. Finished at some point after the recipient has
 returned from its event processing though it may not have
 completely finished reacting from the event -- for example if it needs
 to update its display as a result it may still be in the process of
 doing that.",event MotionEvent : A motion event describing the pointer action.  (As noted in MotionEvent#obtain(long long int float float int) be sure to use SystemClock#uptimeMillis() as the timebase. |||,void,1,"Base class for implementing application instrumentation code.  When running
 with instrumentation turned on this class will be instantiated for you
 before any of the application code allowing you to monitor all of the
 interaction the system has with the application.  An Instrumentation
 implementation is described to the system through an AndroidManifest.xml's
 <instrumentation> tag.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
"<android.media.RingtoneManager: void setActualDefaultRingtoneUri(Context,int,Uri)>",Sets the Uri of the default sound for a given sound type.,"context Context : A context used for querying. |||
type int : The type whose default sound should be set. One of TYPE_RINGTONE  TYPE_NOTIFICATION or TYPE_ALARM . |||
ringtoneUri Uri : A Uri pointing to the default sound to set. |||",void,1,"RingtoneManager provides access to ringtones notification and other types
 of sounds. It manages querying the different media providers and combines the
 results into a single cursor. It also provides a  Ringtone  for each
 ringtone. We generically call these sounds ringtones however the
  TYPE_RINGTONE  refers to the type of sounds that are suitable for the
 phone ringer.
  
 To show a ringtone picker to the user use the
  ACTION_RINGTONE_PICKER  intent to launch the picker as a subactivity.","The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",file data,file,1,no,yes,no,SINK,
<android.content.ContextWrapper: void startActivity(Intent)>,"Same as startActivity(android.content.Intent android.os.Bundle) with no options
 specified.",intent Intent : The description of the activity to start. |||,void,1,"Proxying implementation of Context that simply delegates all of its calls to
 another Context.  Can be subclassed to modify behavior without changing
 the original Context.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",IPC,IPC,1,no,yes,no,SINK,
<android.content.Intent: short getShortArrayExtra(String)>,Retrieve extended data from the intent.,name String : The name of the desired item. |||,"short[] the value of an item previously added with putExtra()
 or null if no short array value was found. |||",1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",IPC,no,0,no,no,no,no,
"<android.text.method.ArrowKeyMovementMethod: void initialize(TextView,Spannable)>",,"widget TextView |||
text Spannable |||",void,1,"A movement method that provides cursor movement and selection.
 Supports displaying the context menu on DPad Center.","Provides classes that monitor or modify keypad input. You can use these classes to modify the type of keypad entry
 for your application or decipher the keypresses entered for your specific
 entry method. For example: 
 // Set the text to password display style:
 EditText txtView = (EditText)findViewById(R.id.text);
 txtView.setTransformationMethod(PasswordTransformationMethod.getInstance());

 //Set the input style to numbers rather than qwerty keyboard style.
 txtView.setInputMethod(DigitsInputMethod.getInstance());

 // Find out whether the caps lock is on.
 // 0 is no 1 is yes 2 is caps lock on.
 int active = MultiTapInputMethod.getCapsActive(txtView.getText());",no,no,0,no,no,no,no,
<android.accounts.AccountManager: void clearPassword(Account)>,"Forgets a saved password.  This erases the local copy of the password;
 it does not change the user's account password on the server.
 Has the same effect as setPassword(account null) but requires fewer
 permissions and may be used by applications or management interfaces
 to ""sign out"" from an account. This method only successfully clear the account's password when the
 caller has the same signature as the authenticator that owns the
 specified account. Otherwise this method will silently fail. It is safe to call this method from the main thread. NOTE: If targeting your app to work on API level 22 and before
 MANAGE_ACCOUNTS permission is needed for those platforms. See docs for
 this function in API level 22. Requires android.Manifest.permission.MANAGE_ACCOUNTS",account Account : The account whose password to clear |||,void,5,"This class provides access to a centralized registry of the user's
 online accounts.  The user enters credentials (username and password) once
 per account granting applications access to online resources with
 ""one-click"" approval.

  Different online services have different ways of handling accounts and
 authentication so the account manager uses pluggable  authenticator 
 modules for different  account types .  Authenticators (which may be
 written by third parties) handle the actual details of validating account
 credentials and storing account information.  For example Google Facebook
 and Microsoft Exchange each have their own authenticator.

  Many servers support some notion of an  authentication token 
 which can be used to authenticate a request to the server without sending
 the user's actual password.  (Auth tokens are normally created with a
 separate request which does include the user's credentials.)  AccountManager
 can generate auth tokens for applications so the application doesn't need to
 handle passwords directly.  Auth tokens are normally reusable and cached by
 AccountManager but must be refreshed periodically.  It's the responsibility
 of applications to  invalidate  auth tokens when they stop working so
 the AccountManager knows it needs to regenerate them.

  Applications accessing a server normally go through these steps:

  Get an instance of AccountManager using  get(android.content.Context) .

  List the available accounts using  getAccountsByType(String)  or
  getAccountsByTypeAndFeatures(String String[] AccountManagerCallback  Handler) .  Normally applications will only
 be interested in accounts with one particular  type  which
 identifies the authenticator.  Account  features  are used to
 identify particular account subtypes and capabilities.  Both the account
 type and features are authenticator-specific strings and must be known by
 the application in coordination with its preferred authenticators.

  Select one or more of the available accounts possibly by asking the
 user for their preference.  If no suitable accounts are available
  addAccount(String String String[] Bundle Activity AccountManagerCallback  Handler)  may be called to prompt the user to create an
 account of the appropriate type.

  Important:  If the application is using a previously remembered
 account selection it must make sure the account is still in the list
 of accounts returned by  getAccountsByType(String) .  Requesting an auth token
 for an account no longer on the device results in an undefined failure.

  Request an auth token for the selected account(s) using one of the
  getAuthToken(Account String Bundle Activity AccountManagerCallback  Handler)  methods or related helpers.  Refer to the description
 of each method for exact usage and error handling details.

  Make the request using the auth token.  The form of the auth token
 the format of the request and the protocol used are all specific to the
 service you are accessing.  The application may use whatever network and
 protocol libraries are useful.

  Important:  If the request fails with an authentication error
 it could be that a cached auth token is stale and no longer honored by
 the server.  The application must call  invalidateAuthToken(String String)  to remove
 the token from the cache otherwise requests will continue failing!  After
 invalidating the auth token immediately go back to the ""Request an auth
 token"" step above.  If the process fails the second time then it can be
 treated as a ""genuine"" authentication failure and the user notified or other
 appropriate actions taken.
  Some AccountManager methods may need to interact with the user to
 prompt for credentials present options or ask the user to add an account.
 The caller may choose whether to allow AccountManager to directly launch the
 necessary user interface and wait for the user or to return an Intent which
 the caller may use to launch the interface or (in some cases) to install a
 notification which the user can select at any time to launch the interface.
 To have AccountManager launch the interface directly the caller must supply
 the current foreground  Activity  context.

  Many AccountManager methods take  AccountManagerCallback  and
  Handler  as parameters.  These methods return immediately and
 run asynchronously. If a callback is provided then
  AccountManagerCallback#run  will be invoked on the Handler's
 thread when the request completes successfully or not.
 The result is retrieved by calling  AccountManagerFuture#getResult() 
 on the  AccountManagerFuture  returned by the method (and also passed
 to the callback).  This method waits for the operation to complete (if
 necessary) and either returns the result or throws an exception if an error
 occurred during the operation.  To make the request synchronously call
  AccountManagerFuture#getResult()  immediately on receiving the
 future from the method; no callback need be supplied.

  Requests which may block including
  AccountManagerFuture#getResult()  must never be called on
 the application's main event thread.  These operations throw
  IllegalStateException  if they are used on the main thread.",,no,no,0,no,no,no,no,
"<android.content.res.Resources: CharSequence getText(int,CharSequence)>","Return the string value associated with a particular resource ID.  The
 returned object will be a String if this is a plain string; it will be
 some other type of CharSequence if it is styled.","id int : The desired resource identifier as generated by the aapt
tool. This integer encodes the package type and resource
entry. The value 0 is an invalid identifier. |||
def CharSequence : The default CharSequence to return. |||","CharSequence CharSequence The string data associated with the resource plus
         possibly styled text information or def if id is 0 or not found. |||",1,"Class for accessing an application's resources.  This sits on top of the
 asset manager of the application (accessible through  getAssets() ) and
 provides a high-level API for getting typed data from the assets.

  The Android resource system keeps track of all non-code assets associated with an
 application. You can use this class to access your application's resources. You can generally
 acquire the  Resources  instance associated with your application
 with  getResources() . The Android SDK tools compile your application's resources into the application binary
 at build time.  To use a resource you must install it correctly in the source tree (inside
 your project's  res/  directory) and build your application.  As part of the build
 process the SDK tools generate symbols for each resource which you can use in your application
 code to access the resources. Using application resources makes it easy to update various characteristics of your
 application without modifying code and—by providing sets of alternative
 resources—enables you to optimize your application for a variety of device configurations
 (such as for different languages and screen sizes). This is an important aspect of developing
 Android applications that are compatible on different types of devices. For more information about using resources see the documentation about  Application Resources .","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,
<android.view.ViewGroup: void removeView(View)>,Note: do not invoke this method from View.draw(android.graphics.Canvas)  View.onDraw(android.graphics.Canvas)  dispatchDraw(android.graphics.Canvas) or any related method.,view View |||,void,1,"A  ViewGroup  is a special view that can contain other views
 (called children.) The view group is the base class for layouts and views
 containers. This class also defines the
  ViewGroup.LayoutParams  class which serves as the base
 class for layouts parameters.
  
 Also see  LayoutParams  for layout attributes.",,no,UI,0,no,no,no,no,
<android.view.View: void refreshDrawableState()>,"Call this to force a view to update its drawable state. This will cause
 drawableStateChanged to be called on this view. Views that are interested
 in the new state should call getDrawableState.",,void,1,"This class represents the basic building block for user interface components. A View
 occupies a rectangular area on the screen and is responsible for drawing and
 event handling. View is the base class for  widgets  which are
 used to create interactive UI components (buttons text fields etc.). The
  ViewGroup  subclass is the base class for  layouts  which
 are invisible containers that hold other Views (or other ViewGroups) and define
 their layout properties.",,no,no,0,no,no,no,no,
"<android.hardware.usb.UsbManager: void requestPermission(UsbAccessory,PendingIntent)>","Requests temporary permission for the given package to access the accessory.
 This may result in a system dialog being displayed to the user
 if permission had not already been granted.
 Success or failure is returned via the PendingIntent pi.
 If successful this grants the caller permission to access the accessory only
 until the device is disconnected.

 The following extras will be added to pi: EXTRA_ACCESSORY containing the accessory passed into this call 
EXTRA_PERMISSION_GRANTED containing boolean indicating whether
 permission was granted by the user","accessory UsbAccessory : to request permissions for |||
pi PendingIntent : PendingIntent for returning result |||",void,12,"This class allows you to access the state of USB and communicate with USB devices.
 Currently only host mode is supported in the public API.","Provides support to communicate with USB hardware peripherals that are connected to
 Android-powered devices. For more information see the
  USB  guide. Use  UsbManager  to access the state of the USB and to
 communicate with connected hardware peripherals. Use  UsbDevice  to
 communicate with the hardware peripheral if the Android-powered device is acting as the USB host.
 Use  UsbAccessory  if the peripheral is acting as the USB host.",no,no,0,no,no,no,no,
<android.widget.ViewAnimator: void showNext()>,Manually shows the next child.,,void,1,"Base class for a  FrameLayout  container that will perform animations
 when switching between its views.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,no,0,no,no,no,no,
"<android.app.Activity: void startActivityFromChild(Activity,Intent,int)>","This method was deprecated
      in API level R. Use androidx.fragment.app.FragmentActivity#startActivityFromFragment(
 androidx.fragment.app.FragmentIntentint) Same as calling startActivityFromChild(android.app.Activity android.content.Intent int android.os.Bundle) with no options.","child Activity : The activity making the call.
This value must never be null . |||
intent Intent : The intent to start. |||
requestCode int : Reply request code.  < 0 if reply is not requested. |||",void,1,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",IPC,IPC,1,no,yes,no,SINK,
"<android.content.Intent: Intent putExtra(String,CharSequence)>","Add extended data to the intent.  The name must include a package
 prefix for example the app com.android.contacts would use names
 like ""com.android.contacts.ShowAll"".","name String : The name of the extra data with package prefix. |||
value CharSequence : The CharSequence data value.
This value may be null . |||","Intent Returns the same Intent object for chaining multiple calls
 into a single statement.

 This value will never be null . |||",1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,
<android.app.admin.DevicePolicyManager: int getKeyguardDisabledFeatures(ComponentName)>,"Determine whether or not features have been disabled in keyguard either by the calling
 admin if specified or all admins that set restrictions on this user and its participating
 profiles. Restrictions on profiles that have a separate challenge are not taken into account. This method can be called on the DevicePolicyManager instance
 returned by getParentProfileInstance(android.content.ComponentName) in order to retrieve
 restrictions on the parent profile.","admin ComponentName : The name of the admin component to check or null to check whether any
admins have disabled features in keyguard.
This value may be null . |||",int bitfield of flags. See setKeyguardDisabledFeatures(android.content.ComponentName int) for a list. |||,17,"Public interface for managing policies enforced on a device. Most clients of this class must be
 registered with the system as a  device
 administrator . Additionally a device administrator may be registered as either a profile or
 device owner. A given method is accessible to all device administrators unless the documentation
 for that method specifies that it is restricted to either device or profile owners. Any
 application calling an api may only pass as an argument a device administrator component it
 owns. Otherwise a  SecurityException  will be thrown.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
<android.drm.DrmManagerClient: String getOriginalMimeType(Uri)>,Retrieves the MIME type embedded in the original content.,uri Uri : URI of the rights-protected content. |||,String MIME type of the original content such as video/mpeg . |||,11,"The main programming interface for the DRM framework. An application must instantiate this class
 to access DRM agents through the DRM framework.","Provides classes for managing DRM content and determining the capabilities of DRM plugins
 (agents). Common uses of the DRM API include: Determining which DRM plug-ins (agents) are installed on a device. Retrieving information about specific plug-ins such as the MIME types and file suffixes
   they support. Registering a user or a device with an online DRM service. Retrieving license constraints for rights-protected content. Checking whether a user has the proper rights to play or use rights-protected
   content. Associating rights-protected content with its license so you can use the
    MediaPlayer  API to play the content.",file metadata,file data,1,yes,no,SOURCE,no,
<android.view.ContextThemeWrapper: Object getSystemService(String)>,"Return the handle to a system-level service by name. The class of the
 returned object varies by the requested name. Currently available names
 are: Note:  System services obtained via this API may be closely associated with
 the Context in which they are obtained from.  In general do not share the
 service objects between various different contexts (Activities Applications
 Services Providers etc.) Note: Instant apps for which PackageManager#isInstantApp() returns true
 don't have access to the following system services: DEVICE_POLICY_SERVICE  FINGERPRINT_SERVICE  KEYGUARD_SERVICE  SHORTCUT_SERVICE  USB_SERVICE  WALLPAPER_SERVICE  WIFI_P2P_SERVICE  WIFI_SERVICE  WIFI_AWARE_SERVICE . For these services this method will
 return null .  Generally if you are running as an instant app you should always
 check whether the result of this method is null . Note: When implementing this method keep in mind that new services can be added on newer
 Android releases so if you're looking for just the explicit names mentioned above make sure
 to return null when you don't recognize the name — if you throw a RuntimeException exception instead you're app might break on new Android releases.","name String : The name of the desired service.
Value is Context.POWER_SERVICE  Context.WINDOW_SERVICE  Context.LAYOUT_INFLATER_SERVICE  Context.ACCOUNT_SERVICE  Context.ACTIVITY_SERVICE  Context.ALARM_SERVICE  Context.NOTIFICATION_SERVICE  Context.ACCESSIBILITY_SERVICE  Context.CAPTIONING_SERVICE  Context.KEYGUARD_SERVICE  Context.LOCATION_SERVICE  Context.SEARCH_SERVICE  Context.SENSOR_SERVICE android.content.Context.SENSOR_PRIVACY_SERVICE Context.STORAGE_SERVICE  Context.STORAGE_STATS_SERVICE  Context.WALLPAPER_SERVICE android.content.Context.TIME_ZONE_RULES_MANAGER_SERVICE Context.VIBRATOR_SERVICE  Context.CONNECTIVITY_SERVICE  Context.IPSEC_SERVICE  Context.VPN_MANAGEMENT_SERVICE android.content.Context.TEST_NETWORK_SERVICE Context.NETWORK_STATS_SERVICE  Context.WIFI_SERVICE  Context.WIFI_AWARE_SERVICE  Context.WIFI_P2P_SERVICE android.content.Context.WIFI_SCANNING_SERVICE Context.WIFI_RTT_RANGING_SERVICE  Context.NSD_SERVICE  Context.AUDIO_SERVICE android.content.Context.AUTH_SERVICE Context.FINGERPRINT_SERVICE  Context.BIOMETRIC_SERVICE  Context.MEDIA_ROUTER_SERVICE  Context.TELEPHONY_SERVICE  Context.TELEPHONY_SUBSCRIPTION_SERVICE  Context.CARRIER_CONFIG_SERVICE  Context.EUICC_SERVICE  Context.MMS_SERVICE  Context.TELECOM_SERVICE  Context.CLIPBOARD_SERVICE  Context.INPUT_METHOD_SERVICE  Context.TEXT_SERVICES_MANAGER_SERVICE  Context.TEXT_CLASSIFICATION_SERVICE  Context.APPWIDGET_SERVICE android.content.Context.ROLLBACK_SERVICE Context.DROPBOX_SERVICE  Context.DEVICE_POLICY_SERVICE  Context.UI_MODE_SERVICE  Context.DOWNLOAD_SERVICE  Context.NFC_SERVICE  Context.BLUETOOTH_SERVICE  Context.USB_SERVICE  Context.LAUNCHER_APPS_SERVICE  Context.INPUT_SERVICE  Context.DISPLAY_SERVICE  Context.USER_SERVICE  Context.RESTRICTIONS_SERVICE  Context.APP_OPS_SERVICE  Context.ROLE_SERVICE  Context.CAMERA_SERVICE  Context.PRINT_SERVICE  Context.CONSUMER_IR_SERVICE  Context.TV_INPUT_SERVICE  Context.USAGE_STATS_SERVICE  Context.MEDIA_SESSION_SERVICE  Context.BATTERY_SERVICE  Context.JOB_SCHEDULER_SERVICE  Context.MEDIA_PROJECTION_SERVICE  Context.MIDI_SERVICE android.content.Context.RADIO_SERVICE Context.HARDWARE_PROPERTIES_SERVICE  Context.SHORTCUT_SERVICE  Context.SYSTEM_HEALTH_SERVICE  Context.COMPANION_DEVICE_SERVICE  Context.CROSS_PROFILE_APPS_SERVICE android.content.Context.PERMISSION_SERVICE or android.content.Context.LIGHTS_SERVICE
This value must never be null . |||",Object The service or null if the name does not exist. |||,1,"A context wrapper that allows you to modify or replace the theme of the
 wrapped context.",,uncategorized,IPC,1,yes,no,no,no,
"<android.content.ContextWrapper: void sendStickyOrderedBroadcastAsUser(Intent,UserHandle,BroadcastReceiver,Handler,int,String,Bundle)>","This method is deprecated. Sticky broadcasts should not be used.  They provide no security (anyone
 can access them) no protection (anyone can modify them) and many other problems.
 The recommended pattern is to use a non-sticky broadcast to report that something has changed with another mechanism for apps to retrieve the current value whenever
 desired. Version of sendStickyOrderedBroadcast(android.content.Intent android.content.BroadcastReceiver android.os.Handler int java.lang.String android.os.Bundle) that allows you to specify the
 user the broadcast will be sent to.  This is not available to applications
 that are not pre-installed on the system image. See BroadcastReceiver for more information on Intent broadcasts. Requires android.Manifest.permission.INTERACT_ACROSS_USERS and Manifest.permission.BROADCAST_STICKY","intent Intent : The Intent to broadcast; all receivers matching this
Intent will receive the broadcast. |||
user UserHandle : UserHandle to send the intent to. |||
resultReceiver BroadcastReceiver : Your own BroadcastReceiver to treat as the final
receiver of the broadcast. |||
scheduler Handler : A custom Handler with which to schedule the
resultReceiver callback; if null it will be
scheduled in the Context's main thread.
This value may be null . |||
initialCode int : An initial value for the result code.  Often
Activity.RESULT_OK. |||
initialData String : An initial value for the result data.  Often
null.
This value may be null . |||
initialExtras Bundle : An initial value for the result extras.  Often
null.
This value may be null . |||",void,17,"Proxying implementation of Context that simply delegates all of its calls to
 another Context.  Can be subclassed to modify behavior without changing
 the original Context.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",IPC,IPC,1,no,yes,no,SINK,
<android.view.View: void setScrollY(int)>,"Set the vertical scrolled position of your view. This will cause a call to onScrollChanged(int int int int) and the view will be
 invalidated.",value int : the y position to scroll to |||,void,14,"This class represents the basic building block for user interface components. A View
 occupies a rectangular area on the screen and is responsible for drawing and
 event handling. View is the base class for  widgets  which are
 used to create interactive UI components (buttons text fields etc.). The
  ViewGroup  subclass is the base class for  layouts  which
 are invisible containers that hold other Views (or other ViewGroups) and define
 their layout properties.",,no,UI,0,no,no,no,no,
"<android.nfc.NfcAdapter: void enableForegroundNdefPush(Activity,NdefMessage)>","This method was deprecated
      in API level 15. use setNdefPushMessage(NdefMessage Activity Activity...) instead Enable NDEF message push over NFC while this Activity is in the foreground. You must explicitly call this method every time the activity is
 resumed and you must call disableForegro undNdefPush(Activity) before
 your activity completes Activity#onPause . Strongly recommend to use the new setNdefPushMessage(NdefMessage Activity Activity...) instead: it automatically hooks into your activity life-cycle
 so you do not need to call enable/disable in your onResume/onPause. For NDEF push to function properly the other NFC device must
 support either NFC Forum's SNEP (Simple Ndef Exchange Protocol) or
 Android's ""com.android.npp"" (Ndef Push Protocol). This was optional
 on Gingerbread level Android NFC devices but SNEP is mandatory on
 Ice-Cream-Sandwich and beyond. This method must be called from the main thread. Requires the Manifest.permission.NFC permission.","activity Activity : foreground activity |||
message NdefMessage : a NDEF Message to push over NFC |||",void,10,"Represents the local NFC adapter.
  
 Use the helper  getDefaultAdapter(android.content.Context)  to get the default NFC
 adapter for this Android device.","Provides access to Near Field Communication (NFC) functionality allowing applications to read
 NDEF message in NFC tags. A ""tag"" may actually be another device that appears as a tag. For more information see the
  Near Field Communication  guide. Here's a summary of the classes: NfcManager This is the high level manager used to obtain this device's  NfcAdapter . You can
 acquire an instance using  getSystemService(Class ) . NfcAdapter This represents the device's NFC adapter which is your entry-point to performing NFC
 operations. You can acquire an instance with  getDefaultAdapter()  or
  getDefaultAdapter(android.content.Context) . NdefMessage Represents an NDEF data message which is the standard format in which ""records""
 carrying data are transmitted between devices and tags. Your application can receive these
 messages from an  ACTION_TAG_DISCOVERED  intent. NdefRecord Represents a record which is delivered in a  NdefMessage  and describes the
 type of data being shared and carries the data itself. Note: 
 Not all Android-powered devices provide NFC functionality.",nfc,nfc,1,no,yes,no,SINK,
<android.widget.TimePicker: void setCurrentMinute(Integer)>,"This method was deprecated
      in API level 23. Use setMinute(int) Sets the currently selected minute.","currentMinute Integer : the minute to set in the range (0-59)
This value must never be null . |||",void,1,"A widget for selecting the time of day in either 24-hour or AM/PM mode.
  
 For a dialog using this view see  TimePickerDialog . See
 the  Pickers 
 guide for more information.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,no,0,no,no,no,no,
<android.content.ContextWrapper: ClassLoader getClassLoader()>,Return a class loader you can use to retrieve classes in this package.,,ClassLoader |||,1,"Proxying implementation of Context that simply delegates all of its calls to
 another Context.  Can be subclassed to modify behavior without changing
 the original Context.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,
<android.media.AudioManager: int getStreamVolume(int)>,Returns the current volume index for a particular stream.,streamType int : The stream type whose volume index is returned. |||,int The current volume index for the stream. |||,1,AudioManager provides access to volume and ringer mode control.,"The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",audio metadata,audio,1,yes,no,SOURCE,no,
"<android.view.View: void scrollTo(int,int)>","Set the scrolled position of your view. This will cause a call to onScrollChanged(int int int int) and the view will be
 invalidated.","x int : the x position to scroll to |||
y int : the y position to scroll to |||",void,1,"This class represents the basic building block for user interface components. A View
 occupies a rectangular area on the screen and is responsible for drawing and
 event handling. View is the base class for  widgets  which are
 used to create interactive UI components (buttons text fields etc.). The
  ViewGroup  subclass is the base class for  layouts  which
 are invisible containers that hold other Views (or other ViewGroups) and define
 their layout properties.",,no,UI,0,no,no,no,no,
"<android.inputmethodservice.InputMethodService: void onExtractedSelectionChanged(int,int)>","This is called when the user has moved the cursor in the extracted
 text view when running in fullsreen mode.  The default implementation
 performs the corresponding selection change on the underlying text
 editor.","start int |||
end int |||",void,3,"InputMethodService provides a standard implementation of an InputMethod
 which final implementations can derive from and customize.  See the
 base class  AbstractInputMethodService  and the  InputMethod 
 interface for more information on the basics of writing input methods.

  In addition to the normal Service lifecycle methods this class
 introduces some new specific callbacks that most subclasses will want
 to make use of: onInitializeInterface()  for user-interface initialization
 in particular to deal with configuration changes while the service is
 running.
  onBindInput()  to find out about switching to a new client.
  onStartInput(EditorInfo boolean)  to deal with an input session starting with
 the client.
  onCreateInputView()   onCreateCandidatesView() 
 and  onCreateExtractTextView()  for non-demand generation of the UI.
  onStartInputView(android.view.inputmethod.EditorInfo boolean)  to deal with input
 starting within the input area of the IME.
  An input method has significant discretion in how it goes about its
 work: the  InputMethodService  provides
 a basic framework for standard UI elements (input view candidates view
 and running in fullscreen mode) but it is up to a particular implementor
 to decide how to use them.  For example one input method could implement
 an input area with a keyboard another could allow the user to draw text
 while a third could have no input area (and thus not be visible to the
 user) but instead listen to audio and perform text to speech conversion. In the implementation provided here all of these elements are placed
 together in a single window managed by the InputMethodService.  It will
 execute callbacks as it needs information about them and provides APIs for
 programmatic control over them.  They layout of these elements is explicitly
 defined: The soft input view if available is placed at the bottom of the
 screen.
  The candidates view if currently shown is placed above the soft
 input view.
  If not running fullscreen the application is moved or resized to be
 above these views; if running fullscreen the window will completely cover
 the application and its top part will contain the extract text of what is
 currently being edited by the application.
  Soft Input View Central to most input methods is the soft input view.  This is where most
 user interaction occurs: pressing on soft keys drawing characters or
 however else your input method wants to generate text.  Most implementations
 will simply have their own view doing all of this work and return a new
 instance of it when  onCreateInputView()  is called.  At that point
 as long as the input view is visible you will see user interaction in
 that view and can call back on the InputMethodService to interact with the
 application as appropriate. There are some situations where you want to decide whether or not your
 soft input view should be shown to the user.  This is done by implementing
 the  onEvaluateInputViewShown()  to return true or false based on
 whether it should be shown in the current environment.  If any of your
 state has changed that may impact this call
  updateInputViewShown()  to have it re-evaluated.  The default
 implementation always shows the input view unless there is a hard
 keyboard available which is the appropriate behavior for most input
 methods. Candidates View Often while the user is generating raw text an input method wants to
 provide them with a list of possible interpretations of that text that can
 be selected for use.  This is accomplished with the candidates view and
 like the soft input view you implement  onCreateCandidatesView() 
 to instantiate your own view implementing your candidates UI. Management of the candidates view is a little different than the input
 view because the candidates view tends to be more transient being shown
 only when there are possible candidates for the current text being entered
 by the user.  To control whether the candidates view is shown you use
  setCandidatesViewShown(boolean) .  Note that because the candidate
 view tends to be shown and hidden a lot it does not impact the application
 UI in the same way as the soft input view: it will never cause application
 windows to resize only cause them to be panned if needed for the user to
 see the current focus. Fullscreen Mode Sometimes your input method UI is too large to integrate with the
 application UI so you just want to take over the screen.  This is
 accomplished by switching to full-screen mode causing the input method
 window to fill the entire screen and add its own ""extracted text"" editor
 showing the user the text that is being typed.  Unlike the other UI elements
 there is a standard implementation for the extract editor that you should
 not need to change.  The editor is placed at the top of the IME above the
 input and candidates views. Similar to the input view you control whether the IME is running in
 fullscreen mode by implementing  onEvaluateFullscreenMode() 
 to return true or false based on
 whether it should be fullscreen in the current environment.  If any of your
 state has changed that may impact this call
  updateFullscreenMode()  to have it re-evaluated.  The default
 implementation selects fullscreen mode when the screen is in a landscape
 orientation which is appropriate behavior for most input methods that have
 a significant input area. When in fullscreen mode you have some special requirements because the
 user can not see the application UI.  In particular you should implement
  onDisplayCompletions(android.view.inputmethod.CompletionInfo[])  to show completions
 generated by your application typically in your candidates view like you
 would normally show candidates.


  Generating Text The key part of an IME is of course generating text for the application.
 This is done through calls to the
  InputConnection  interface to the
 application which can be retrieved from  getCurrentInputConnection() .
 This interface allows you to generate raw key events or if the target
 supports it directly edit in strings of candidates and committed text. Information about what the target is expected and supports can be found
 through the  EditorInfo  class which is
 retrieved with  getCurrentInputEditorInfo()  method.  The most
 important part of this is  EditorInfo.inputType ; in particular if this is
  EditorInfo.TYPE_NULL 
 then the target does not support complex edits and you need to only deliver
 raw key events to it.  An input method will also want to look at other
 values here to for example detect password mode auto complete text views
 phone number entry etc. When the user switches between input targets you will receive calls to
  onFinishInput()  and  onStartInput(android.view.inputmethod.EditorInfo boolean) .
 You can use these to reset and initialize your input state for the current
 target.  For example you will often want to clear any input state and
 update a soft keyboard to be appropriate for the new inputType.",,no,callback,0,no,no,no,no,
"<android.appwidget.AppWidgetHost: AppWidgetHostView createView(Context,int,AppWidgetProviderInfo)>","Create the AppWidgetHostView for the given widget.
 The AppWidgetHost retains a pointer to the newly-created View.","context Context |||
appWidgetId int |||
appWidget AppWidgetProviderInfo |||",AppWidgetHostView |||,3,"AppWidgetHost provides the interaction with the AppWidget service for apps
 like the home screen that want to embed AppWidgets in their UI.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",uncategorized,UI,1,no,yes,no,SINK,
<android.app.Activity: int getRequestedOrientation()>,"Return the current requested orientation of the activity.  This will
 either be the orientation requested in its component's manifest or
 the last requested orientation given to setRequestedOrientation(int) .",,"int Returns an orientation constant as used in ActivityInfo#screenOrientation .
 
 Value is android.content.pm.ActivityInfo.SCREEN_ORIENTATION_UNSET ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED  ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE  ActivityInfo.SCREEN_ORIENTATION_PORTRAIT  ActivityInfo.SCREEN_ORIENTATION_USER  ActivityInfo.SCREEN_ORIENTATION_BEHIND  ActivityInfo.SCREEN_ORIENTATION_SENSOR  ActivityInfo.SCREEN_ORIENTATION_NOSENSOR  ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE  ActivityInfo.SCREEN_ORIENTATION_SENSOR_PORTRAIT  ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE  ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT  ActivityInfo.SCREEN_ORIENTATION_FULL_SENSOR  ActivityInfo.SCREEN_ORIENTATION_USER_LANDSCAPE  ActivityInfo.SCREEN_ORIENTATION_USER_PORTRAIT  ActivityInfo.SCREEN_ORIENTATION_FULL_USER or ActivityInfo.SCREEN_ORIENTATION_LOCKED |||",1,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
<android.hardware.Camera: Camera open()>,"Creates a new Camera object to access the first back-facing camera on the
 device. If the device does not have a back-facing camera this returns
 null. Otherwise acts like the open(int) call.",,"Camera a new Camera object for the first back-facing camera or null if there is no
  backfacing camera |||",1,"The Camera class is used to set image capture settings start/stop preview
 snap pictures and retrieve frames for encoding for video.  This class is a
 client for the Camera service which manages the actual camera hardware.

  To access the device camera you must declare the
  Manifest.permission.CAMERA  permission in your Android
 Manifest. Also be sure to include the
  <uses-feature> 
 manifest element to declare camera features used by your application.
 For example if you use the camera and auto-focus feature your Manifest
 should include the following:  <uses-permission android:name=""android.permission.CAMERA"" />
 <uses-feature android:name=""android.hardware.camera"" />
 <uses-feature android:name=""android.hardware.camera.autofocus"" /> To take pictures with this class use the following steps: Obtain an instance of Camera from  open(int) .

  Get existing (default) settings with  getParameters() .

  If necessary modify the returned  Camera.Parameters  object and call
  setParameters(android.hardware.Camera.Parameters) .

  Call  setDisplayOrientation(int)  to ensure correct orientation of preview.

  Important : Pass a fully initialized  SurfaceHolder  to
  setPreviewDisplay(android.view.SurfaceHolder) .  Without a surface the camera
 will be unable to start the preview.

  Important : Call  startPreview()  to start updating the
 preview surface.  Preview must be started before you can take a picture.

  When you want call  takePicture(android.hardware.Camera.ShutterCallback android.hardware.Camera.PictureCallback android.hardware.Camera.PictureCallback android.hardware.Camera.PictureCallback)  to
 capture a photo.  Wait for the callbacks to provide the actual image data.

  After taking a picture preview display will have stopped.  To take more
 photos call  startPreview()  again first.

  Call  stopPreview()  to stop updating the preview surface.

  Important:  Call  release()  to release the camera for
 use by other applications.  Applications should release the camera
 immediately in  Activity.onPause()  (and re- open() 
 it in  Activity.onResume() ).
  To quickly switch to video recording mode use these steps: Obtain and initialize a Camera and start preview as described above.

  Call  unlock()  to allow the media process to access the camera.

  Pass the camera to  MediaRecorder.setCamera(Camera) .
 See  MediaRecorder  information about video recording.

  When finished recording call  reconnect()  to re-acquire
 and re-lock the camera.

  If desired restart preview and take more photos or videos.

  Call  stopPreview()  and  release()  as described above.
  This class is not thread-safe and is meant for use from one event thread.
 Most long-running operations (preview focus photo capture etc) happen
 asynchronously and invoke callbacks as necessary.  Callbacks will be invoked
 on the event thread  open(int)  was called from.  This class's methods
 must never be called from multiple threads at once.","Provides support for hardware features such as the camera and other sensors. Be aware that
 not all Android-powered devices support all hardware features so you should declare hardware
 that your application requires using the  <uses-feature>  manifest element.",camera,camera,1,yes,no,SOURCE,no,
"<android.view.inputmethod.BaseInputConnection: CharSequence getTextBeforeCursor(int,int)>","The default implementation returns the given amount of text from the
 current cursor position in the buffer.","length int : The expected length of the text. |||
flags int : Supplies additional options controlling how the text is
returned. May be either 0 or InputConnection.GET_TEXT_WITH_STYLES . |||","CharSequence the text before the cursor position; the length of the
 returned text might be less than n . |||",3,"Base class for implementors of the InputConnection interface taking care
 of most of the common behavior for providing a connection to an Editable.
 Implementors of this class will want to be sure to implement
  getEditable()  to provide access to their own editable object and
 to refer to the documentation in  InputConnection .",,uncategorized,UI,1,yes,no,no,no,Are we sure this isn't sensitive?
"<android.content.Intent: float getFloatExtra(String,float)>",Retrieve extended data from the intent.,"name String : The name of the desired item. |||
defaultValue float : the value to be returned if no value of the desired
type is stored with the given name. |||","float the value of an item previously added with putExtra()
 or the default value if no such item is present |||",1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",IPC,no,0,no,no,no,no,
<android.appwidget.AppWidgetHost: void deleteAppWidgetId(int)>,Stop listening to changes for this AppWidget.,appWidgetId int |||,void,3,"AppWidgetHost provides the interaction with the AppWidget service for apps
 like the home screen that want to embed AppWidgets in their UI.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
<android.os.Parcel: void writeTypedList(List)>,"Flatten a List containing a particular object type into the parcel at
 the current dataPosition() and growing dataCapacity() if needed.  The
 type of the objects in the list must be one that implements Parcelable.
 Unlike the generic writeList() method however only the raw data of the
 objects is written and not their type so you must use the corresponding
 readTypedList() to unmarshall them.","val List : The list of objects to be written.
This value may be null . |||",void,1,"Container for a message (data and object references) that can
 be sent through an IBinder.  A Parcel can contain both flattened data
 that will be unflattened on the other side of the IPC (using the various
 methods here for writing specific types or the general
  Parcelable  interface) and references to live  IBinder 
 objects that will result in the other side receiving a proxy IBinder
 connected with the original IBinder in the Parcel.

  Parcel is  not  a general-purpose
 serialization mechanism.  This class (and the corresponding
  Parcelable  API for placing arbitrary objects into a Parcel) is
 designed as a high-performance IPC transport.  As such it is not
 appropriate to place any Parcel data in to persistent storage: changes
 in the underlying implementation of any of the data in the Parcel can
 render older data unreadable. The bulk of the Parcel API revolves around reading and writing data
 of various types.  There are six major classes of such functions available. Primitives The most basic data functions are for writing and reading primitive
 data types:  writeByte(byte)   readByte()   writeDouble(double) 
  readDouble()   writeFloat(float)   readFloat()   writeInt(int) 
  readInt()   writeLong(long)   readLong() 
  writeString(String)   readString() .  Most other
 data operations are built on top of these.  The given data is written and
 read using the endianess of the host CPU. Primitive Arrays There are a variety of methods for reading and writing raw arrays
 of primitive objects which generally result in writing a 4-byte length
 followed by the primitive data items.  The methods for reading can either
 read the data into an existing array or create and return a new array.
 These available types are: writeBooleanArray(boolean[]) 
  readBooleanArray(boolean[])   createBooleanArray() writeByteArray(byte[]) 
  writeByteArray(byte[] int int)   readByteArray(byte[]) 
  createByteArray() writeCharArray(char[])   readCharArray(char[]) 
  createCharArray() writeDoubleArray(double[])   readDoubleArray(double[]) 
  createDoubleArray() writeFloatArray(float[])   readFloatArray(float[]) 
  createFloatArray() writeIntArray(int[])   readIntArray(int[]) 
  createIntArray() writeLongArray(long[])   readLongArray(long[]) 
  createLongArray() writeStringArray(java.lang.String[])   readStringArray(java.lang.String[]) 
  createStringArray() .
  writeSparseBooleanArray(android.util.SparseBooleanArray) 
  readSparseBooleanArray() .
  Parcelables The  Parcelable  protocol provides an extremely efficient (but
 low-level) protocol for objects to write and read themselves from Parcels.
 You can use the direct methods  writeParcelable(android.os.Parcelable int) 
 and  readParcelable(java.lang.ClassLoader)  or
  writeParcelableArray(T[] int)  and
  readParcelableArray(java.lang.ClassLoader)  to write or read.  These
 methods write both the class type and its data to the Parcel allowing
 that class to be reconstructed from the appropriate class loader when
 later reading. There are also some methods that provide a more efficient way to work
 with Parcelables:  writeTypedObject(T int)   writeTypedArray(T[] int) 
  writeTypedList(List )   readTypedObject(Parcelable.Creator ) 
  createTypedArray(Parcelable.Creator )  and  createTypedArrayList(Parcelable.Creator ) .  These methods
 do not write the class information of the original object: instead the
 caller of the read function must know what type to expect and pass in the
 appropriate  Parcelable.Creator  instead to
 properly construct the new object and read its data.  (To more efficient
 write and read a single Parcelable object that is not null you can directly
 call  Parcelable#writeToParcel  and
  Parcelable.Creator#createFromParcel 
 yourself.) Bundles A special type-safe container called  Bundle  is available
 for key/value maps of heterogeneous values.  This has many optimizations
 for improved performance when reading and writing data and its type-safe
 API avoids difficult to debug type errors when finally marshalling the
 data contents into a Parcel.  The methods to use are
  writeBundle(android.os.Bundle)   readBundle()  and
  readBundle(java.lang.ClassLoader) .

  Active Objects An unusual feature of Parcel is the ability to read and write active
 objects.  For these objects the actual contents of the object is not
 written rather a special token referencing the object is written.  When
 reading the object back from the Parcel you do not get a new instance of
 the object but rather a handle that operates on the exact same object that
 was originally written.  There are two forms of active objects available. Binder  objects are a core facility of Android's general cross-process
 communication system.  The  IBinder  interface describes an abstract
 protocol with a Binder object.  Any such interface can be written in to
 a Parcel and upon reading you will receive either the original object
 implementing that interface or a special proxy implementation
 that communicates calls back to the original object.  The methods to use are
  writeStrongBinder(android.os.IBinder) 
  writeStrongInterface(android.os.IInterface)   readStrongBinder() 
  writeBinderArray(android.os.IBinder[])   readBinderArray(android.os.IBinder[]) 
  createBinderArray() 
  writeBinderList(java.util.List)   readBinderList(java.util.List) 
  createBinderArrayList() . FileDescriptor objects representing raw Linux file descriptor identifiers
 can be written and  ParcelFileDescriptor  objects returned to operate
 on the original file descriptor.  The returned file descriptor is a dup
 of the original file descriptor: the object and fd is different but
 operating on the same underlying file stream with the same position etc.
 The methods to use are  writeFileDescriptor(java.io.FileDescriptor) 
  readFileDescriptor() .

  Untyped Containers A final class of methods are for writing and reading standard Java
 containers of arbitrary types.  These all revolve around the
  writeValue(java.lang.Object)  and  readValue(java.lang.ClassLoader)  methods
 which define the types of objects allowed.  The container methods are
  writeArray(java.lang.Object[])   readArray(java.lang.ClassLoader) 
  writeList(java.util.List)   readList(java.util.List java.lang.ClassLoader) 
  readArrayList(java.lang.ClassLoader) 
  writeMap(java.util.Map)   readMap(java.util.Map java.lang.ClassLoader) 
  writeSparseArray(android.util.SparseArray) 
  readSparseArray(java.lang.ClassLoader) .",,IPC,no,0,no,no,no,no,
"<android.test.TouchUtils: int dragViewBy(ActivityInstrumentationTestCase,View,int,int,int)>","This method was deprecated
      in API level 15. ActivityInstrumentationTestCase is deprecated in favor of ActivityInstrumentationTestCase2 which provides more options for
 configuring the Activity under test Simulate touching a view and dragging it by the specified amount.","test ActivityInstrumentationTestCase : The test case that is being run |||
v View : The view that should be dragged |||
gravity int : Which part of the view to use for the initial down event. A combination of
(TOP CENTER_VERTICAL BOTTOM) and (LEFT CENTER_HORIZONTAL RIGHT) |||
deltaX int : Amount to drag horizontally in pixels |||
deltaY int : Amount to drag vertically in pixels |||",int distance in pixels covered by the drag |||,1,"Reusable methods for generating touch events. These methods can be used with
 InstrumentationTestCase or ActivityInstrumentationTestCase2 to simulate user interaction with
 the application through a touch screen.",,no,no,0,no,no,no,no,
<android.app.Activity: void setTitle(CharSequence)>,"Change the title associated with this activity.  If this is a
 top-level activity the title for its window will change.  If it
 is an embedded activity the parent can do whatever it wants
 with it.",title CharSequence |||,void,1,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",uncategorized,UI,1,no,yes,no,SINK,
<android.test.ServiceTestCase: void testServiceTestCaseSetUpProperly()>,"Tests that setupService() runs correctly and issues an Assert.assertNotNull(String Object) if it does.
 You can override this test method if you wish.",,void,1,"This test case provides a framework in which you can test Service classes in
 a controlled environment.  It provides basic support for the lifecycle of a
 Service and hooks with which you can inject various dependencies and control
 the environment in which your Service is tested.",,no,no,0,no,no,no,no,
<android.view.ActionProvider: void refreshVisibility()>,"If this ActionProvider is associated with an item in a menu
 refresh the visibility of the item based on overridesItemVisibility() and isVisible() . If overridesItemVisibility() returns false this call
 will have no effect.",,void,16,"An ActionProvider defines rich menu interaction in a single component.
 ActionProvider can generate action views for use in the action bar
 dynamically populate submenus of a MenuItem and handle default menu
 item invocations.

  An ActionProvider can be optionally specified for a  MenuItem  and will be
 responsible for creating the action view that appears in the  ActionBar 
 in place of a simple button in the bar. When the menu item is presented in a way that
 does not allow custom action views (e.g. in an overflow menu) the ActionProvider
 can perform a default action. There are two ways to use an action provider:
  
 Set the action provider on a  MenuItem  directly by calling
  MenuItem#setActionProvider(ActionProvider) .
  
 Declare the action provider in an XML menu resource. For example:
  
   <item android:id=""@+id/my_menu_item""
     android:title=""Title""
     android:icon=""@drawable/my_menu_item_icon""
     android:showAsAction=""ifRoom""
     android:actionProviderClass=""foo.bar.SomeActionProvider"" />",,no,no,0,no,no,no,no,
<android.os.UserManager: String getUserName()>,"Returns the user name of the context user. This call is only available to applications on
 the system image; it requires the android.permission.MANAGE_USERS or android.permission.GET_ACCOUNTS_PRIVILEGED permissions.",,"String the user name
 
 This value will never be null . |||",17,"Manages users and user details on a multi-user system. There are two major categories of
 users: fully customizable users with their own login and managed profiles that share a workspace
 with a related user.
  
 Users are different from accounts which are managed by
  AccountManager . Each user can have their own set of accounts.
  
 See  DevicePolicyManager#ACTION_PROVISION_MANAGED_PROFILE  for more on managed profiles.",,user info,user info file,1,yes,no,SOURCE,no,
<android.net.ConnectivityManager: void setNetworkPreference(int)>,"This method was deprecated
      in API level 21. Functionality has been removed as it no longer makes sense
             with many more than two networks - we'd need an array to express
             preference.  Instead we use dynamic network properties of
             the networks to describe their precedence. Specifies the preferred network type.  When the device has more
 than one type available the preferred network type will be used.","preference int : the network type to prefer over all others.  It is
unspecified what happens to the old preferred network in the
overall ordering. |||",void,1,"Class that answers queries about the state of network connectivity. It also
 notifies applications when network connectivity changes.
  
 The primary responsibilities of this class are to:
  Monitor network connections (Wi-Fi GPRS UMTS etc.) Send broadcast intents when network connectivity changes Attempt to ""fail over"" to another network when connectivity to a network
 is lost Provide an API that allows applications to query the coarse-grained or fine-grained
 state of the available networks Provide an API that allows applications to request and select networks for their data
 traffic",,no,network ,0,no,no,no,no,
"<android.view.FocusFinder: View findNextFocus(ViewGroup,View,int)>","Find the next view to take focus in root's descendants starting from the view
 that currently is focused.","root ViewGroup : Contains focused. Cannot be null. |||
focused View : Has focus now. |||
direction int : Direction to look. |||",View The next focusable view or null if none exists. |||,1,"The algorithm used for finding the next focusable view in a given direction
 from a view that currently has focus.",,no,UI,0,no,no,no,no,
<android.webkit.WebView: int findAll(String)>,"This method was deprecated
      in API level 16. findAllAsync(String) is preferred. Finds all instances of find on the page and highlights them.
 Notifies any registered FindListener .",find String : the string to find |||,"int the number of occurrences of the String ""find"" that were found |||",3,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",uncategorized,UI,1,no,no,no,no,Are we sure this isn't sensitive?
<android.nfc.NfcAdapter: NfcAdapter getDefaultAdapter(Context)>,Helper to get the default NFC Adapter. Most Android devices will only have one NFC Adapter (NFC Controller). This helper is the equivalent of:,context Context : the calling application's context |||,NfcAdapter the default NFC adapter or null if no NFC adapter exists |||,10,"Represents the local NFC adapter.
  
 Use the helper  getDefaultAdapter(android.content.Context)  to get the default NFC
 adapter for this Android device.","Provides access to Near Field Communication (NFC) functionality allowing applications to read
 NDEF message in NFC tags. A ""tag"" may actually be another device that appears as a tag. For more information see the
  Near Field Communication  guide. Here's a summary of the classes: NfcManager This is the high level manager used to obtain this device's  NfcAdapter . You can
 acquire an instance using  getSystemService(Class ) . NfcAdapter This represents the device's NFC adapter which is your entry-point to performing NFC
 operations. You can acquire an instance with  getDefaultAdapter()  or
  getDefaultAdapter(android.content.Context) . NdefMessage Represents an NDEF data message which is the standard format in which ""records""
 carrying data are transmitted between devices and tags. Your application can receive these
 messages from an  ACTION_TAG_DISCOVERED  intent. NdefRecord Represents a record which is delivered in a  NdefMessage  and describes the
 type of data being shared and carries the data itself. Note: 
 Not all Android-powered devices provide NFC functionality.",no,nfc,0,no,no,no,no,
<android.widget.ProgressBar: void setProgressDrawable(Drawable)>,Define the drawable used to draw the progress bar in progress mode.,d Drawable : the new drawable |||,void,1,"A user interface element that indicates the progress of an operation.
 Progress bar supports two modes to represent progress: determinate and indeterminate. For
 a visual overview of the difference between determinate and indeterminate progress modes see
  
 Progress & activity .
 Display progress bars to a user in a non-interruptive way.
 Show the progress bar in your app's user interface or in a notification
 instead of within a dialog.
  Indeterminate Progress 
 Use indeterminate mode for the progress bar when you do not know how long an
 operation will take.
 Indeterminate mode is the default for progress bar and shows a cyclic animation without a
 specific amount of progress indicated.
 The following example shows an indeterminate progress bar:
  
 <ProgressBar
      android:id=""@+id/indeterminateBar""
      android:layout_width=""wrap_content""
      android:layout_height=""wrap_content""
      />
  Determinate Progress 
 Use determinate mode for the progress bar when you want to show that a specific quantity of
 progress has occurred.
 For example the percent remaining of a file being retrieved the amount records in
 a batch written to database or the percent remaining of an audio file that is playing.
  
 To indicate determinate progress you set the style of the progress bar to
  R.style.Widget_ProgressBar_Horizontal  and set the amount of progress.
 The following example shows a determinate progress bar that is 25% complete:
  
 <ProgressBar
      android:id=""@+id/determinateBar""
      style=""@android:style/Widget.ProgressBar.Horizontal""
      android:layout_width=""wrap_content""
      android:layout_height=""wrap_content""
      android:progress=""25""/>
  setProgress(int) incrementProgressBy(int) android:max Other progress bar styles provided by the system include: Widget.ProgressBar.Horizontal Widget.ProgressBar.Small Widget.ProgressBar.Large Widget.ProgressBar.Inverse Widget.ProgressBar.Small.Inverse Widget.ProgressBar.Large.Inverse The ""inverse"" styles provide an inverse color scheme for the spinner which may be necessary
 if your application uses a light colored theme (a white background). XML attributes 
 See  ProgressBar Attributes 
  View Attributes","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,UI,0,no,no,no,no,
<android.webkit.CookieSyncManager: void run()>,"When an object implementing interface Runnable is used
 to create a thread starting the thread causes the object's run method to be called in that separately executing
 thread. The general contract of the method run is that it may
 take any action whatsoever.",,void,-1,"The CookieSyncManager is used to synchronize the browser cookie store
 between RAM and permanent storage. To get the best performance browser cookies are
 saved in RAM. A separate thread saves the cookies between driven by a timer.
  

 To use the CookieSyncManager the host application has to call the following
 when the application starts:
  CookieSyncManager.createInstance(context) 

 To set up for sync the host application has to call CookieSyncManager.getInstance().startSync() 

 in Activity.onResume() and call
  
 CookieSyncManager.getInstance().stopSync()
  

 in Activity.onPause(). 

 To get instant sync instead of waiting for the timer to trigger the host can
 call
  CookieSyncManager.getInstance().sync() 

 The sync interval is 5 minutes so you will want to force syncs
 manually anyway for instance in  WebViewClient#onPageFinished . Note that even sync() happens
 asynchronously so don't do it just as your activity is shutting
 down.","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",no,no,0,no,no,no,no,
"<android.appwidget.AppWidgetManager: void notifyAppWidgetViewDataChanged(int,int)>","Notifies the specified collection view in the specified AppWidget instance
 to invalidate its data.","appWidgetId int : The AppWidget instance to notify of view data changes. |||
viewId int : The collection view id. |||",void,11,"Updates AppWidget state; gets information about installed AppWidget providers and other
 AppWidget related state.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,UI,0,no,no,no,no,
<android.inputmethodservice.AbstractInputMethodService: IBinder onBind(Intent)>,"Return the communication channel to the service.  May return null if
 clients can not bind to the service.  The returned IBinder is usually for a complex interface
 that has been described using
 aidl . Note that unlike other application components calls on to the
 IBinder interface returned here may not happen on the main thread
 of the process .  More information about the main thread can be found in Processes and
 Threads .","intent Intent : The Intent that was used to bind to this service
as given to Context.bindService .  Note that any extras that were included with
the Intent at that point will not be seen here. |||","IBinder Return an IBinder through which clients can call on to the
         service. |||",3,"AbstractInputMethodService provides a abstract base class for input methods.
 Normal input method implementations will not derive from this directly
 instead building on top of  InputMethodService  or another more
 complete base class.  Be sure to read  InputMethod  for more
 information on the basics of writing input methods.

  This class combines a Service (representing the input method component
 to the system with the InputMethod interface that input methods must
 implement.  This base class takes care of reporting your InputMethod from
 the service when clients bind to it but provides no standard implementation
 of the InputMethod interface itself.  Derived classes must implement that
 interface.",,IPC,IPC,1,yes,no,SOURCE,no,
<android.app.WallpaperInfo: CharSequence loadLabel(PackageManager)>,Load the user-displayed label for this wallpaper.,"pm PackageManager : Supply a PackageManager used to load the wallpaper's
resources. |||",CharSequence |||,7,This class is used to specify meta information of a wallpaper service.,"Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,UI,0,no,no,no,no,
<android.content.ContextWrapper: Object getSystemService(String)>,"Return the handle to a system-level service by name. The class of the
 returned object varies by the requested name. Currently available names
 are: Note:  System services obtained via this API may be closely associated with
 the Context in which they are obtained from.  In general do not share the
 service objects between various different contexts (Activities Applications
 Services Providers etc.) Note: Instant apps for which PackageManager#isInstantApp() returns true
 don't have access to the following system services: DEVICE_POLICY_SERVICE  FINGERPRINT_SERVICE  KEYGUARD_SERVICE  SHORTCUT_SERVICE  USB_SERVICE  WALLPAPER_SERVICE  WIFI_P2P_SERVICE  WIFI_SERVICE  WIFI_AWARE_SERVICE . For these services this method will
 return null .  Generally if you are running as an instant app you should always
 check whether the result of this method is null . Note: When implementing this method keep in mind that new services can be added on newer
 Android releases so if you're looking for just the explicit names mentioned above make sure
 to return null when you don't recognize the name — if you throw a RuntimeException exception instead you're app might break on new Android releases.","name String : The name of the desired service.
Value is Context.POWER_SERVICE  Context.WINDOW_SERVICE  Context.LAYOUT_INFLATER_SERVICE  Context.ACCOUNT_SERVICE  Context.ACTIVITY_SERVICE  Context.ALARM_SERVICE  Context.NOTIFICATION_SERVICE  Context.ACCESSIBILITY_SERVICE  Context.CAPTIONING_SERVICE  Context.KEYGUARD_SERVICE  Context.LOCATION_SERVICE  Context.SEARCH_SERVICE  Context.SENSOR_SERVICE android.content.Context.SENSOR_PRIVACY_SERVICE Context.STORAGE_SERVICE  Context.STORAGE_STATS_SERVICE  Context.WALLPAPER_SERVICE android.content.Context.TIME_ZONE_RULES_MANAGER_SERVICE Context.VIBRATOR_SERVICE  Context.CONNECTIVITY_SERVICE  Context.IPSEC_SERVICE  Context.VPN_MANAGEMENT_SERVICE android.content.Context.TEST_NETWORK_SERVICE Context.NETWORK_STATS_SERVICE  Context.WIFI_SERVICE  Context.WIFI_AWARE_SERVICE  Context.WIFI_P2P_SERVICE android.content.Context.WIFI_SCANNING_SERVICE Context.WIFI_RTT_RANGING_SERVICE  Context.NSD_SERVICE  Context.AUDIO_SERVICE android.content.Context.AUTH_SERVICE Context.FINGERPRINT_SERVICE  Context.BIOMETRIC_SERVICE  Context.MEDIA_ROUTER_SERVICE  Context.TELEPHONY_SERVICE  Context.TELEPHONY_SUBSCRIPTION_SERVICE  Context.CARRIER_CONFIG_SERVICE  Context.EUICC_SERVICE  Context.MMS_SERVICE  Context.TELECOM_SERVICE  Context.CLIPBOARD_SERVICE  Context.INPUT_METHOD_SERVICE  Context.TEXT_SERVICES_MANAGER_SERVICE  Context.TEXT_CLASSIFICATION_SERVICE  Context.APPWIDGET_SERVICE android.content.Context.ROLLBACK_SERVICE Context.DROPBOX_SERVICE  Context.DEVICE_POLICY_SERVICE  Context.UI_MODE_SERVICE  Context.DOWNLOAD_SERVICE  Context.NFC_SERVICE  Context.BLUETOOTH_SERVICE  Context.USB_SERVICE  Context.LAUNCHER_APPS_SERVICE  Context.INPUT_SERVICE  Context.DISPLAY_SERVICE  Context.USER_SERVICE  Context.RESTRICTIONS_SERVICE  Context.APP_OPS_SERVICE  Context.ROLE_SERVICE  Context.CAMERA_SERVICE  Context.PRINT_SERVICE  Context.CONSUMER_IR_SERVICE  Context.TV_INPUT_SERVICE  Context.USAGE_STATS_SERVICE  Context.MEDIA_SESSION_SERVICE  Context.BATTERY_SERVICE  Context.JOB_SCHEDULER_SERVICE  Context.MEDIA_PROJECTION_SERVICE  Context.MIDI_SERVICE android.content.Context.RADIO_SERVICE Context.HARDWARE_PROPERTIES_SERVICE  Context.SHORTCUT_SERVICE  Context.SYSTEM_HEALTH_SERVICE  Context.COMPANION_DEVICE_SERVICE  Context.CROSS_PROFILE_APPS_SERVICE android.content.Context.PERMISSION_SERVICE or android.content.Context.LIGHTS_SERVICE
This value must never be null . |||",Object The service or null if the name does not exist. |||,1,"Proxying implementation of Context that simply delegates all of its calls to
 another Context.  Can be subclassed to modify behavior without changing
 the original Context.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",uncategorized,IPC,1,yes,no,no,no,Are we sure this isn't sensitive?
<android.inputmethodservice.InputMethodService: void onUpdateExtractingVisibility(EditorInfo)>,"Called when the fullscreen-mode extracting editor info has changed
 to determine whether the extracting (extract text and candidates) portion
 of the UI should be shown.  The standard implementation hides or shows
 the extract area depending on whether it makes sense for the
 current editor.  In particular a InputType#TYPE_NULL input type or EditorInfo#IME_FLAG_NO_EXTRACT_UI flag will
 turn off the extract area since there is no text to be shown.",ei EditorInfo |||,void,3,"InputMethodService provides a standard implementation of an InputMethod
 which final implementations can derive from and customize.  See the
 base class  AbstractInputMethodService  and the  InputMethod 
 interface for more information on the basics of writing input methods.

  In addition to the normal Service lifecycle methods this class
 introduces some new specific callbacks that most subclasses will want
 to make use of: onInitializeInterface()  for user-interface initialization
 in particular to deal with configuration changes while the service is
 running.
  onBindInput()  to find out about switching to a new client.
  onStartInput(EditorInfo boolean)  to deal with an input session starting with
 the client.
  onCreateInputView()   onCreateCandidatesView() 
 and  onCreateExtractTextView()  for non-demand generation of the UI.
  onStartInputView(android.view.inputmethod.EditorInfo boolean)  to deal with input
 starting within the input area of the IME.
  An input method has significant discretion in how it goes about its
 work: the  InputMethodService  provides
 a basic framework for standard UI elements (input view candidates view
 and running in fullscreen mode) but it is up to a particular implementor
 to decide how to use them.  For example one input method could implement
 an input area with a keyboard another could allow the user to draw text
 while a third could have no input area (and thus not be visible to the
 user) but instead listen to audio and perform text to speech conversion. In the implementation provided here all of these elements are placed
 together in a single window managed by the InputMethodService.  It will
 execute callbacks as it needs information about them and provides APIs for
 programmatic control over them.  They layout of these elements is explicitly
 defined: The soft input view if available is placed at the bottom of the
 screen.
  The candidates view if currently shown is placed above the soft
 input view.
  If not running fullscreen the application is moved or resized to be
 above these views; if running fullscreen the window will completely cover
 the application and its top part will contain the extract text of what is
 currently being edited by the application.
  Soft Input View Central to most input methods is the soft input view.  This is where most
 user interaction occurs: pressing on soft keys drawing characters or
 however else your input method wants to generate text.  Most implementations
 will simply have their own view doing all of this work and return a new
 instance of it when  onCreateInputView()  is called.  At that point
 as long as the input view is visible you will see user interaction in
 that view and can call back on the InputMethodService to interact with the
 application as appropriate. There are some situations where you want to decide whether or not your
 soft input view should be shown to the user.  This is done by implementing
 the  onEvaluateInputViewShown()  to return true or false based on
 whether it should be shown in the current environment.  If any of your
 state has changed that may impact this call
  updateInputViewShown()  to have it re-evaluated.  The default
 implementation always shows the input view unless there is a hard
 keyboard available which is the appropriate behavior for most input
 methods. Candidates View Often while the user is generating raw text an input method wants to
 provide them with a list of possible interpretations of that text that can
 be selected for use.  This is accomplished with the candidates view and
 like the soft input view you implement  onCreateCandidatesView() 
 to instantiate your own view implementing your candidates UI. Management of the candidates view is a little different than the input
 view because the candidates view tends to be more transient being shown
 only when there are possible candidates for the current text being entered
 by the user.  To control whether the candidates view is shown you use
  setCandidatesViewShown(boolean) .  Note that because the candidate
 view tends to be shown and hidden a lot it does not impact the application
 UI in the same way as the soft input view: it will never cause application
 windows to resize only cause them to be panned if needed for the user to
 see the current focus. Fullscreen Mode Sometimes your input method UI is too large to integrate with the
 application UI so you just want to take over the screen.  This is
 accomplished by switching to full-screen mode causing the input method
 window to fill the entire screen and add its own ""extracted text"" editor
 showing the user the text that is being typed.  Unlike the other UI elements
 there is a standard implementation for the extract editor that you should
 not need to change.  The editor is placed at the top of the IME above the
 input and candidates views. Similar to the input view you control whether the IME is running in
 fullscreen mode by implementing  onEvaluateFullscreenMode() 
 to return true or false based on
 whether it should be fullscreen in the current environment.  If any of your
 state has changed that may impact this call
  updateFullscreenMode()  to have it re-evaluated.  The default
 implementation selects fullscreen mode when the screen is in a landscape
 orientation which is appropriate behavior for most input methods that have
 a significant input area. When in fullscreen mode you have some special requirements because the
 user can not see the application UI.  In particular you should implement
  onDisplayCompletions(android.view.inputmethod.CompletionInfo[])  to show completions
 generated by your application typically in your candidates view like you
 would normally show candidates.


  Generating Text The key part of an IME is of course generating text for the application.
 This is done through calls to the
  InputConnection  interface to the
 application which can be retrieved from  getCurrentInputConnection() .
 This interface allows you to generate raw key events or if the target
 supports it directly edit in strings of candidates and committed text. Information about what the target is expected and supports can be found
 through the  EditorInfo  class which is
 retrieved with  getCurrentInputEditorInfo()  method.  The most
 important part of this is  EditorInfo.inputType ; in particular if this is
  EditorInfo.TYPE_NULL 
 then the target does not support complex edits and you need to only deliver
 raw key events to it.  An input method will also want to look at other
 values here to for example detect password mode auto complete text views
 phone number entry etc. When the user switches between input targets you will receive calls to
  onFinishInput()  and  onStartInput(android.view.inputmethod.EditorInfo boolean) .
 You can use these to reset and initialize your input state for the current
 target.  For example you will often want to clear any input state and
 update a soft keyboard to be appropriate for the new inputType.",,no,UI,0,no,no,no,no,
<android.view.View: void dispatchWindowVisibilityChanged(int)>,"Dispatch a window visibility change down the view hierarchy.
 ViewGroups should override to route to their children.","visibility int : The new visibility of the window.
Value is VISIBLE  INVISIBLE or GONE |||",void,1,"This class represents the basic building block for user interface components. A View
 occupies a rectangular area on the screen and is responsible for drawing and
 event handling. View is the base class for  widgets  which are
 used to create interactive UI components (buttons text fields etc.). The
  ViewGroup  subclass is the base class for  layouts  which
 are invisible containers that hold other Views (or other ViewGroups) and define
 their layout properties.",,no,callback,0,no,no,no,no,
"<android.test.TouchUtils: void dragViewToBottom(ActivityInstrumentationTestCase,View,int)>","This method was deprecated
      in API level 15. ActivityInstrumentationTestCase is deprecated in favor of ActivityInstrumentationTestCase2 which provides more options for
 configuring the Activity under test Simulate touching the center of a view and dragging to the bottom of the screen.","test ActivityInstrumentationTestCase : The test case that is being run |||
v View : The view that should be dragged |||
stepCount int : How many move steps to include in the drag |||",void,1,"Reusable methods for generating touch events. These methods can be used with
 InstrumentationTestCase or ActivityInstrumentationTestCase2 to simulate user interaction with
 the application through a touch screen.",,no,no,0,no,no,no,no,
<android.webkit.WebView: int getContentHeight()>,Gets the height of the HTML content.,,int the height of the HTML content |||,1,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",no,UI,0,no,no,no,no,
<android.app.Instrumentation: void callActivityOnRestart(Activity)>,Perform calling of an activity's Activity#onRestart method.  The default implementation simply calls through to that method.,activity Activity : The activity being restarted. |||,void,1,"Base class for implementing application instrumentation code.  When running
 with instrumentation turned on this class will be instantiated for you
 before any of the application code allowing you to monitor all of the
 interaction the system has with the application.  An Instrumentation
 implementation is described to the system through an AndroidManifest.xml's
 <instrumentation> tag.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",IPC,IPC,1,no,yes,no,SINK,
"<android.content.pm.InstrumentationInfo: void writeToParcel(Parcel,int)>",,"dest Parcel |||
parcelableFlags int |||",void,1,"Information you can retrieve about a particular piece of test
 instrumentation.  This corresponds to information collected
 from the AndroidManifest.xml's <instrumentation> tag.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",IPC,no,0,no,no,no,no,
<android.view.SurfaceView: void draw(Canvas)>,"Manually render this view (and all of its children) to the given Canvas.
 The view must have already done a full layout before this function is
 called.  When implementing a view implement onDraw(android.graphics.Canvas) instead of overriding this method.
 If you do need to override this method call the superclass version. If you override this method you must call through to the
 superclass implementation.",canvas Canvas : The Canvas to which the View is rendered. |||,void,1,"Handle onto a raw buffer that is being managed by the screen compositor.

  A Surface is generally created by or from a consumer of image buffers (such as a
  SurfaceTexture   MediaRecorder  or
  Allocation ) and is handed to some kind of producer (such as
  OpenGL 
  MediaPlayer  or
  CameraDevice ) to draw
 into. Note:  A Surface acts like a
  weak reference  to the consumer it is associated with. By
 itself it will not keep its parent consumer from being reclaimed.",,uncategorized,UI,1,no,yes,no,SINK,
<android.app.AlarmManager: void setTimeZone(String)>,"Sets the system's persistent default time zone. This is the time zone for all apps even
 after a reboot. Use TimeZone.setDefault(TimeZone) if you just want to change the
 time zone within your app and even then prefer to pass an explicit TimeZone to APIs that require it rather than changing the time zone for
 all threads. On android M and above it is an error to pass in a non-Olson timezone to this
 function. Note that this is a bad idea on all Android releases because POSIX and
 the TimeZone class have opposite interpretations of '+' and '-' in the same non-Olson ID. Requires Manifest.permission.SET_TIME_ZONE",timeZone String : one of the Olson ids from the list returned by TimeZone.getAvailableIDs() |||,void,1,"This class provides access to the system alarm services.  These allow you
 to schedule your application to be run at some point in the future.  When
 an alarm goes off the  Intent  that had been registered for it
 is broadcast by the system automatically starting the target application
 if it is not already running.  Registered alarms are retained while the
 device is asleep (and can optionally wake the device up if they go off
 during that time) but will be cleared if it is turned off and rebooted.

  The Alarm Manager holds a CPU wake lock as long as the alarm receiver's
 onReceive() method is executing. This guarantees that the phone will not sleep
 until you have finished handling the broadcast. Once onReceive() returns the
 Alarm Manager releases this wake lock. This means that the phone will in some
 cases sleep as soon as your onReceive() method completes.  If your alarm receiver
 called  Context.startService()  it
 is possible that the phone will sleep before the requested service is launched.
 To prevent this your BroadcastReceiver and Service will need to implement a
 separate wake lock policy to ensure that the phone continues running until the
 service becomes available.

  Note: The Alarm Manager is intended for cases where you want to have
 your application code run at a specific time even if your application is
 not currently running.  For normal timing operations (ticks timeouts
 etc) it is easier and much more efficient to use
  Handler .","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
<android.widget.VideoView: void setMediaController(MediaController)>,,controller MediaController |||,void,1,"Displays a video file.  The VideoView class
 can load images from various sources (such as resources or content
 providers) takes care of computing its measurement from the video so that
 it can be used in any layout manager and provides various display options
 such as scaling and tinting. Note: VideoView does not retain its full state when going into the
 background.   In particular it does not restore the current play state
 play position selected tracks or any subtitle tracks added via
  addSubtitleSource() .  Applications should
 save and restore these on their own in
  Activity.onSaveInstanceState(Bundle)  and
  Activity.onRestoreInstanceState(Bundle) . 
 Also note that the audio session id (from  getAudioSessionId() ) may
 change from its previously returned value when the VideoView is restored.
  
 By default VideoView requests audio focus with  AudioManager#AUDIOFOCUS_GAIN . Use
  setAudioFocusRequest(int)  to change this behavior.
  
 The default  AudioAttributes  used during playback have a usage of
  AudioAttributes#USAGE_MEDIA  and a content type of
  AudioAttributes#CONTENT_TYPE_MOVIE  use  setAudioAttributes(android.media.AudioAttributes)  to
 modify them.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,video,0,no,no,no,no,
<android.appwidget.AppWidgetHost: void stopListening()>,"Stop receiving onAppWidgetChanged calls for your AppWidgets.  Call this when your activity is
 no longer visible i.e. from onStop() in your Activity.",,void,3,"AppWidgetHost provides the interaction with the AppWidget service for apps
 like the home screen that want to embed AppWidgets in their UI.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
<android.net.sip.SipAudioCall: void sendDtmf(int)>,"Sends a DTMF code. According to RFC 2883 event 0--9 maps to decimal
 value 0--9 '*' to 10 '#' to 11 event 'A'--'D' to 12--15 and event
 flash to 16. Currently event flash is not supported.","code int : the DTMF code to send. Value 0 to 15 (inclusive) are valid
inputs. |||",void,9,"Handles an Internet audio call over SIP. You can instantiate this class with  SipManager 
 using  SipManager#makeAudioCall  and   SipManager#takeAudioCall .

  Note:  Using this class require the
    Manifest.permission.INTERNET  and
    Manifest.permission.USE_SIP  permissions. In addition  startAudio()  requires the
    Manifest.permission.RECORD_AUDIO 
    Manifest.permission.ACCESS_WIFI_STATE  and
    Manifest.permission.WAKE_LOCK  permissions; and  setSpeakerMode()  requires the
    Manifest.permission.MODIFY_AUDIO_SETTINGS  permission.",,phone metadata,phone,1,no,yes,no,SINK,
"<android.widget.TextView: void append(CharSequence,int,int)>","Convenience method to append the specified text slice to the TextView's
 display buffer upgrading it to TextView.BufferType.EDITABLE if it was not already editable.","text CharSequence : text to be appended to the already displayed text |||
start int : the index of the first character in the text |||
end int : the index of the character following the last character in the text |||",void,1,"A user interface element that displays text to the user.
 To provide user-editable text see  EditText .
  
 The following code sample shows a typical use with an XML layout
 and code to modify the contents of the text view:
  
 <LinearLayout
      xmlns:android=""http://schemas.android.com/apk/res/android""
      android:layout_width=""match_parent""
      android:layout_height=""match_parent"">
    <TextView
        android:id=""@+id/text_view_id""
        android:layout_height=""wrap_content""
        android:layout_width=""wrap_content""
        android:text=""@string/hello"" />
 </LinearLayout>
  
 This code sample demonstrates how to modify the contents of the text view
 defined in the previous XML layout:
  
 public class MainActivity extends Activity {

    protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_main);
         final TextView helloTextView = (TextView) findViewById(R.id.text_view_id);
         helloTextView.setText(R.string.user_greeting);
     }
 }
  
 To customize the appearance of TextView see  Styles and Themes .
  XML attributes 
 See  TextView Attributes 
  View Attributes","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",uncategorized,UI,1,no,yes,no,SINK,
<android.widget.AutoCompleteTextView: void setCompletionHint(CharSequence)>,"Sets the optional hint text that is displayed at the bottom of the
 the matching list.  This can be used as a cue to the user on how to
 best use the list or to provide extra information. Related XML Attributes: android:completionHint",hint CharSequence : the text to be displayed to the user |||,void,1,"An editable text view that shows completion suggestions automatically
 while the user is typing. The list of suggestions is displayed in a drop
 down menu from which the user can choose an item to replace the content
 of the edit box with. The drop down can be dismissed at any time by pressing the back key or
 if no item is selected in the drop down by pressing the enter/dpad center
 key. The list of suggestions is obtained from a data adapter and appears
 only after a given number of characters defined by
  the threshold . The following code snippet shows how to create a text view which suggests
 various countries names while the user is typing: 
 public class CountriesActivity extends Activity {
     protected void onCreate(Bundle icicle) {
         super.onCreate(icicle);
         setContentView(R.layout.countries);

         ArrayAdapter<String> adapter = new ArrayAdapter<String>(this
                 android.R.layout.simple_dropdown_item_1line COUNTRIES);
         AutoCompleteTextView textView = (AutoCompleteTextView)
                 findViewById(R.id.countries_list);
         textView.setAdapter(adapter);
     }

     private static final String[] COUNTRIES = new String[] {
         ""Belgium"" ""France"" ""Italy"" ""Germany"" ""Spain""
     };
 }
  See the  Text Fields 
 guide.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",uncategorized,Ui,1,no,yes,no,SINK,
"<android.view.View: void addFocusables(ArrayList,int,int)>","Adds any focusable views that are descendants of this view (possibly
 including this view if it is focusable itself) to views. This method
 adds all focusable views regardless if we are in touch mode or
 only views focusable in touch mode if we are in touch mode or
 only views that can take accessibility focus if accessibility is enabled
 depending on the focusable mode parameter.","views ArrayList : Focusable views found so far or null if all we are interested is
the number of focusables. |||
direction int : The direction of the focus.
Value is FOCUS_BACKWARD  FOCUS_FORWARD  FOCUS_LEFT  FOCUS_UP  FOCUS_RIGHT or FOCUS_DOWN |||
focusableMode int : The type of focusables to be added.
Value is either 0 or a combination of FOCUSABLES_ALL and FOCUSABLES_TOUCH_MODE |||",void,4,"This class represents the basic building block for user interface components. A View
 occupies a rectangular area on the screen and is responsible for drawing and
 event handling. View is the base class for  widgets  which are
 used to create interactive UI components (buttons text fields etc.). The
  ViewGroup  subclass is the base class for  layouts  which
 are invisible containers that hold other Views (or other ViewGroups) and define
 their layout properties.",,no,UI,0,no,no,no,no,
"<android.content.Intent: Intent putParcelableArrayListExtra(String,ArrayList)>","Add extended data to the intent.  The name must include a package
 prefix for example the app com.android.contacts would use names
 like ""com.android.contacts.ShowAll"".","name String : The name of the extra data with package prefix. |||
value ArrayList : The ArrayList data value.
This value may be null . |||","Intent Returns the same Intent object for chaining multiple calls
 into a single statement.

 This value will never be null . |||",1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",IPC,no,0,no,no,no,no,
<android.test.TouchUtils: void dragQuarterScreenUp(ActivityInstrumentationTestCase)>,"This method was deprecated
      in API level 15. ActivityInstrumentationTestCase is deprecated in favor of ActivityInstrumentationTestCase2 which provides more options for
 configuring the Activity under test Simulate touching in the center of the screen and dragging one quarter of the way up",test ActivityInstrumentationTestCase : The test case that is being run |||,void,1,"Reusable methods for generating touch events. These methods can be used with
 InstrumentationTestCase or ActivityInstrumentationTestCase2 to simulate user interaction with
 the application through a touch screen.",,no,UI,0,no,no,no,no,
<android.content.Intent: void readFromParcel(Parcel)>,,in Parcel |||,void,1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",IPC,no,0,no,no,no,no,
<android.view.inputmethod.InputMethodManager: Map getShortcutInputMethodsAndSubtypes()>,Returns a map of all shortcut input method info and their subtypes.,,Map < InputMethodInfo  List < InputMethodSubtype >> |||,11,"Central system API to the overall input method framework (IMF) architecture
 which arbitrates interaction between applications and the current input method.

  Topics covered here:
  Architecture Overview Applications Input Methods Security Architecture Overview There are three primary parties involved in the input method
 framework (IMF) architecture:  The  input method manager  as expressed by this class
 is the central point of the system that manages interaction between all
 other parts.  It is expressed as the client-side API here which exists
 in each application context and communicates with a global system service
 that manages the interaction across all processes.
   An  input method (IME)  implements a particular
 interaction model allowing the user to generate text.  The system binds
 to the current input method that is in use causing it to be created and run
 and tells it when to hide and show its UI.  Only one IME is running at a time.
   Multiple  client applications  arbitrate with the input
 method manager for input focus and control over the state of the IME.  Only
 one such client is ever active (working with the IME) at a time.
  Applications In most cases applications that are using the standard
  TextView  or its subclasses will have little they need
 to do to work well with soft input methods.  The main things you need to
 be aware of are:  Properly set the  R.attr.inputType  in your editable
 text views so that the input method will have enough context to help the
 user in entering text into them.
   Deal well with losing screen space when the input method is
 displayed.  Ideally an application should handle its window being resized
 smaller but it can rely on the system performing panning of the window
 if needed.  You should set the  R.attr.windowSoftInputMode 
 attribute on your activity or the corresponding values on windows you
 create to help the system determine whether to pan or resize (it will
 try to determine this automatically but may get it wrong).
   You can also control the preferred soft input state (open closed etc)
 for your window using the same  R.attr.windowSoftInputMode 
 attribute.
  More finer-grained control is available through the APIs here to directly
 interact with the IMF and its IME -- either showing or hiding the input
 area letting the user pick an input method etc. For the rare people amongst us writing their own text editors you
 will need to implement  View.onCreateInputConnection(EditorInfo) 
 to return a new instance of your own  InputConnection  interface
 allowing the IME to interact with your editor. Input Methods An input method (IME) is implemented
 as a  Service  typically deriving from
  InputMethodService .  It must provide
 the core  InputMethod  interface though this is normally handled by
  InputMethodService  and implementors will
 only need to deal with the higher-level API there. InputMethodService Security There are a lot of security issues associated with input methods
 since they essentially have freedom to completely drive the UI and monitor
 everything the user enters.  The Android input method framework also allows
 arbitrary third party IMEs so care must be taken to restrict their
 selection and interactions. Here are some key points about the security architecture behind the
 IMF: Only the system is allowed to directly access an IME's
  InputMethod  interface via the
  Manifest.permission.BIND_INPUT_METHOD  permission.  This is
 enforced in the system by not binding to an input method service that does
 not require this permission so the system can guarantee no other untrusted
 clients are accessing the current input method outside of its control. There may be many client processes of the IMF but only one may
 be active at a time.  The inactive clients can not interact with key
 parts of the IMF through the mechanisms described below. Clients of an input method are only given access to its
  InputMethodSession  interface.  One instance of this interface is
 created for each client and only calls from the session associated with
 the active client will be processed by the current IME.  This is enforced
 by  AbstractInputMethodService  for normal
 IMEs but must be explicitly handled by an IME that is customizing the
 raw  InputMethodSession  implementation. Only the active client's  InputConnection  will accept
 operations.  The IMF tells each client process whether it is active and
 the framework enforces that in inactive processes calls on to the current
 InputConnection will be ignored.  This ensures that the current IME can
 only deliver events and text edits to the UI that the user sees as
 being in focus. An IME can never interact with an  InputConnection  while
 the screen is off.  This is enforced by making all clients inactive while
 the screen is off and prevents bad IMEs from driving the UI when the user
 can not be aware of its behavior. A client application can ask that the system let the user pick a
 new IME but can not programmatically switch to one itself.  This avoids
 malicious applications from switching the user to their own IME which
 remains running when the user navigates away to another application.  An
 IME on the other hand  is  allowed to programmatically switch
 the system to another IME since it already has full control of user
 input. The user must explicitly enable a new IME in settings before
 they can switch to it to confirm with the system that they know about it
 and want to make it available for use. PackageManager#FEATURE_INPUT_METHODS PackageManager.hasSystemFeature(String)",,no,no,0,no,no,no,no,
<android.app.admin.DevicePolicyManager: int getStorageEncryptionStatus()>,"Called by an application that is administering the device to
 determine the current encryption status of the device. Depending on the returned status code the caller may proceed in different
 ways.  If the result is ENCRYPTION_STATUS_UNSUPPORTED the
 storage system does not support encryption.  If the
 result is ENCRYPTION_STATUS_INACTIVE use ACTION_START_ENCRYPTION to begin the process of encrypting or decrypting the
 storage.  If the result is ENCRYPTION_STATUS_ACTIVE_DEFAULT_KEY the
 storage system has enabled encryption but no password is set so further action
 may be required.  If the result is ENCRYPTION_STATUS_ACTIVATING  ENCRYPTION_STATUS_ACTIVE or ENCRYPTION_STATUS_ACTIVE_PER_USER no further action is required.",,int current status of encryption. The value will be one of ENCRYPTION_STATUS_UNSUPPORTED  ENCRYPTION_STATUS_INACTIVE  ENCRYPTION_STATUS_ACTIVATING  ENCRYPTION_STATUS_ACTIVE_DEFAULT_KEY  ENCRYPTION_STATUS_ACTIVE or ENCRYPTION_STATUS_ACTIVE_PER_USER . |||,11,"Public interface for managing policies enforced on a device. Most clients of this class must be
 registered with the system as a  device
 administrator . Additionally a device administrator may be registered as either a profile or
 device owner. A given method is accessible to all device administrators unless the documentation
 for that method specifies that it is restricted to either device or profile owners. Any
 application calling an api may only pass as an argument a device administrator component it
 owns. Otherwise a  SecurityException  will be thrown.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,not sure
<android.view.ViewPropertyAnimator: ViewPropertyAnimator xBy(float)>,"This method will cause the View's x property to be animated by the
 specified value. Animations already running on the property will be canceled.",value float : The amount to be animated by as an offset from the current value. |||,ViewPropertyAnimator This object allowing calls to methods in this class to be chained. |||,12,"This class enables automatic and optimized animation of select properties on View objects.
 If only one or two properties on a View object are being animated then using an
  ObjectAnimator  is fine; the property setters called by ObjectAnimator
 are well equipped to do the right thing to set the property and invalidate the view
 appropriately. But if several properties are animated simultaneously or if you just want a
 more convenient syntax to animate a specific property then ViewPropertyAnimator might be
 more well-suited to the task.

  This class may provide better performance for several simultaneous animations because
 it will optimize invalidate calls to take place only once for several properties instead of each
 animated property independently causing its own invalidation. Also the syntax of using this
 class could be easier to use because the caller need only tell the View object which
 property to animate and the value to animate either to or by and this class handles the
 details of configuring the underlying Animator class and starting it. This class is not constructed by the caller but rather by the View whose properties
 it will animate. Calls to  View.animate()  will return a reference
 to the appropriate ViewPropertyAnimator object for that View.",,no,UI,0,no,no,no,no,
"<android.test.AndroidTestCase: void assertActivityRequiresPermission(String,String,String)>","Asserts that launching a given activity is protected by a particular permission by
 attempting to start the activity and validating that a SecurityException is thrown that mentions the permission in its error message.

 Note that an instrumentation isn't needed because all we are looking for is a security error
 and we don't need to wait for the activity to launch and get a handle to the activity.","packageName String : The package name of the activity to launch. |||
className String : The class of the activity to launch. |||
permission String : The name of the permission. |||",void,4,Extend this if you need to access Resources or other things that depend on Activity Context.,,no,IPC,0,no,no,no,no,
"<android.content.Intent: Intent putExtra(String,double)>","Add extended data to the intent.  The name must include a package
 prefix for example the app com.android.contacts would use names
 like ""com.android.contacts.ShowAll"".","name String : The name of the extra data with package prefix. |||
value double : The double array data value.
This value may be null . |||","Intent Returns the same Intent object for chaining multiple calls
 into a single statement.

 This value will never be null . |||",1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",IPC,no,0,no,no,no,no,
<android.app.Activity: void onBackPressed()>,"Called when the activity has detected the user's press of the back
 key.  The default implementation simply finishes the current activity
 but you can override this to do whatever you want.",,void,5,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,callback,0,no,no,no,no,
"<android.content.Intent: Intent putExtra(String,Serializable)>","Add extended data to the intent.  The name must include a package
 prefix for example the app com.android.contacts would use names
 like ""com.android.contacts.ShowAll"".","name String : The name of the extra data with package prefix. |||
value Serializable : The Serializable data value.
This value may be null . |||","Intent Returns the same Intent object for chaining multiple calls
 into a single statement.

 This value will never be null . |||",1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",IPC,no,0,no,no,no,no,
<android.nfc.tech.NfcF: NfcF get(Tag)>,"Get an instance of NfcF for the given tag. Returns null if NfcF was not enumerated in Tag#getTechList .
 This indicates the tag does not support NFC-F. Does not cause any RF activity and does not block.",tag Tag : an NFC-F compatible tag |||,NfcF NFC-F object |||,10,"Provides access to NFC-F (JIS 6319-4) properties and I/O operations on a  Tag .

  Acquire a  NfcF  object using  get(Tag) .
  The primary NFC-F I/O operation is  transceive(byte[]) . Applications must
 implement their own protocol stack on top of  transceive(byte[]) .

  Note:  Methods that perform I/O operations
 require the  Manifest.permission.NFC  permission.","These classes provide access to a tag technology's features which vary by the type
 of tag that is scanned. A scanned tag can support multiple technologies and you can find
 out what they are by calling  getTechList() . For more information on dealing with tag technologies and handling the ones that you care about see
  The Tag Dispatch System .
 The  TagTechnology  interface provides an overview of the
 supported technologies.",nfc,nfc,1,yes,no,SOURCE,no,
"<android.app.DatePickerDialog: void onClick(DialogInterface,int)>",This method will be invoked when a button in the dialog is clicked.,"dialog DialogInterface : This value must never be null . |||
which int : the button that was clicked (ex. DialogInterface#BUTTON_POSITIVE ) or the position
of the item clicked |||",void,1,"A simple dialog containing an  DatePicker .
  
 See the  Pickers 
 guide.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,UI,0,no,no,no,no,
<android.webkit.WebView: void requestFocusNodeHref(Message)>,"Requests the anchor or image element URL at the last tapped point.
 If hrefMsg is null this method returns immediately and does not
 dispatch hrefMsg to its target. If the tapped point hits an image
 an anchor or an image in an anchor the message associates
 strings in named keys in its data. The value paired with the key
 may be an empty string.","hrefMsg Message : the message to be dispatched with the result of the
request. The message data contains three keys. ""url""
returns the anchor's href attribute. ""title"" returns the
anchor's text. ""src"" returns the image's src attribute.
This value may be null . |||",void,1,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",no,no,0,no,no,no,no,
<android.content.ContextWrapper: Drawable getWallpaper()>,This method is deprecated. Use WallpaperManager.get() instead.,,Drawable |||,1,"Proxying implementation of Context that simply delegates all of its calls to
 another Context.  Can be subclassed to modify behavior without changing
 the original Context.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",image,UI,1,yes,no,SOURCE,no,
<android.os.Parcel: Object readValue(ClassLoader)>,"Read a typed object from a parcel.  The given class loader will be
 used to load any enclosed Parcelables.  If it is null the default class
 loader will be used.",loader ClassLoader : This value may be null . |||,Object |||,1,"Container for a message (data and object references) that can
 be sent through an IBinder.  A Parcel can contain both flattened data
 that will be unflattened on the other side of the IPC (using the various
 methods here for writing specific types or the general
  Parcelable  interface) and references to live  IBinder 
 objects that will result in the other side receiving a proxy IBinder
 connected with the original IBinder in the Parcel.

  Parcel is  not  a general-purpose
 serialization mechanism.  This class (and the corresponding
  Parcelable  API for placing arbitrary objects into a Parcel) is
 designed as a high-performance IPC transport.  As such it is not
 appropriate to place any Parcel data in to persistent storage: changes
 in the underlying implementation of any of the data in the Parcel can
 render older data unreadable. The bulk of the Parcel API revolves around reading and writing data
 of various types.  There are six major classes of such functions available. Primitives The most basic data functions are for writing and reading primitive
 data types:  writeByte(byte)   readByte()   writeDouble(double) 
  readDouble()   writeFloat(float)   readFloat()   writeInt(int) 
  readInt()   writeLong(long)   readLong() 
  writeString(String)   readString() .  Most other
 data operations are built on top of these.  The given data is written and
 read using the endianess of the host CPU. Primitive Arrays There are a variety of methods for reading and writing raw arrays
 of primitive objects which generally result in writing a 4-byte length
 followed by the primitive data items.  The methods for reading can either
 read the data into an existing array or create and return a new array.
 These available types are: writeBooleanArray(boolean[]) 
  readBooleanArray(boolean[])   createBooleanArray() writeByteArray(byte[]) 
  writeByteArray(byte[] int int)   readByteArray(byte[]) 
  createByteArray() writeCharArray(char[])   readCharArray(char[]) 
  createCharArray() writeDoubleArray(double[])   readDoubleArray(double[]) 
  createDoubleArray() writeFloatArray(float[])   readFloatArray(float[]) 
  createFloatArray() writeIntArray(int[])   readIntArray(int[]) 
  createIntArray() writeLongArray(long[])   readLongArray(long[]) 
  createLongArray() writeStringArray(java.lang.String[])   readStringArray(java.lang.String[]) 
  createStringArray() .
  writeSparseBooleanArray(android.util.SparseBooleanArray) 
  readSparseBooleanArray() .
  Parcelables The  Parcelable  protocol provides an extremely efficient (but
 low-level) protocol for objects to write and read themselves from Parcels.
 You can use the direct methods  writeParcelable(android.os.Parcelable int) 
 and  readParcelable(java.lang.ClassLoader)  or
  writeParcelableArray(T[] int)  and
  readParcelableArray(java.lang.ClassLoader)  to write or read.  These
 methods write both the class type and its data to the Parcel allowing
 that class to be reconstructed from the appropriate class loader when
 later reading. There are also some methods that provide a more efficient way to work
 with Parcelables:  writeTypedObject(T int)   writeTypedArray(T[] int) 
  writeTypedList(List )   readTypedObject(Parcelable.Creator ) 
  createTypedArray(Parcelable.Creator )  and  createTypedArrayList(Parcelable.Creator ) .  These methods
 do not write the class information of the original object: instead the
 caller of the read function must know what type to expect and pass in the
 appropriate  Parcelable.Creator  instead to
 properly construct the new object and read its data.  (To more efficient
 write and read a single Parcelable object that is not null you can directly
 call  Parcelable#writeToParcel  and
  Parcelable.Creator#createFromParcel 
 yourself.) Bundles A special type-safe container called  Bundle  is available
 for key/value maps of heterogeneous values.  This has many optimizations
 for improved performance when reading and writing data and its type-safe
 API avoids difficult to debug type errors when finally marshalling the
 data contents into a Parcel.  The methods to use are
  writeBundle(android.os.Bundle)   readBundle()  and
  readBundle(java.lang.ClassLoader) .

  Active Objects An unusual feature of Parcel is the ability to read and write active
 objects.  For these objects the actual contents of the object is not
 written rather a special token referencing the object is written.  When
 reading the object back from the Parcel you do not get a new instance of
 the object but rather a handle that operates on the exact same object that
 was originally written.  There are two forms of active objects available. Binder  objects are a core facility of Android's general cross-process
 communication system.  The  IBinder  interface describes an abstract
 protocol with a Binder object.  Any such interface can be written in to
 a Parcel and upon reading you will receive either the original object
 implementing that interface or a special proxy implementation
 that communicates calls back to the original object.  The methods to use are
  writeStrongBinder(android.os.IBinder) 
  writeStrongInterface(android.os.IInterface)   readStrongBinder() 
  writeBinderArray(android.os.IBinder[])   readBinderArray(android.os.IBinder[]) 
  createBinderArray() 
  writeBinderList(java.util.List)   readBinderList(java.util.List) 
  createBinderArrayList() . FileDescriptor objects representing raw Linux file descriptor identifiers
 can be written and  ParcelFileDescriptor  objects returned to operate
 on the original file descriptor.  The returned file descriptor is a dup
 of the original file descriptor: the object and fd is different but
 operating on the same underlying file stream with the same position etc.
 The methods to use are  writeFileDescriptor(java.io.FileDescriptor) 
  readFileDescriptor() .

  Untyped Containers A final class of methods are for writing and reading standard Java
 containers of arbitrary types.  These all revolve around the
  writeValue(java.lang.Object)  and  readValue(java.lang.ClassLoader)  methods
 which define the types of objects allowed.  The container methods are
  writeArray(java.lang.Object[])   readArray(java.lang.ClassLoader) 
  writeList(java.util.List)   readList(java.util.List java.lang.ClassLoader) 
  readArrayList(java.lang.ClassLoader) 
  writeMap(java.util.Map)   readMap(java.util.Map java.lang.ClassLoader) 
  writeSparseArray(android.util.SparseArray) 
  readSparseArray(java.lang.ClassLoader) .",,IPC,no,0,no,no,no,no,
<android.view.View: ArrayList getFocusables(int)>,"Find and return all focusable views that are descendants of this view
 possibly including this view if it is focusable itself.","direction int : The direction of the focus
Value is FOCUS_BACKWARD  FOCUS_FORWARD  FOCUS_LEFT  FOCUS_UP  FOCUS_RIGHT or FOCUS_DOWN |||",ArrayList < View > A list of focusable views |||,1,"This class represents the basic building block for user interface components. A View
 occupies a rectangular area on the screen and is responsible for drawing and
 event handling. View is the base class for  widgets  which are
 used to create interactive UI components (buttons text fields etc.). The
  ViewGroup  subclass is the base class for  layouts  which
 are invisible containers that hold other Views (or other ViewGroups) and define
 their layout properties.",,no,UI,0,no,no,no,no,
"<android.telephony.SmsManager: void sendMultipartTextMessage(String,String,ArrayList,ArrayList,ArrayList)>","Send a multi-part text based SMS.  The callee should have already
 divided the message into correctly sized parts by calling divideMessage . Note: Using this method requires that your app has the Manifest.permission.SEND_SMS permission. Note: Beginning with Android 4.4 (API level 19) if and only if an app is not selected as the default SMS app the system automatically
 writes messages sent using this method to the SMS Provider (the default SMS app is always
 responsible for writing its sent messages to the SMS Provider). For information about
 how to behave as the default SMS app see Telephony . Note: If getDefault() is used to instantiate this
 manager on a multi-SIM device this operation may fail sending the SMS message because no
 suitable default subscription could be found. In this case if sentIntent is
 non-null then the PendingIntent will be sent with an error code RESULT_ERROR_GENERIC_FAILURE and an extra string ""noDefault"" containing the
 boolean value true . See getDefault() for more information on the conditions
 where this operation may fail.","destinationAddress String : the address to send the message to |||
scAddress String : is the service center address or null to use
the current default SMSC |||
parts ArrayList : an ArrayList of strings that in order
comprise the original message |||
sentIntents ArrayList : if not null an ArrayList of PendingIntent s (one for each message part) that is
broadcast when the corresponding message part has been sent.
The result code will be Activity.RESULT_OK for success
or one of these errors: RESULT_ERROR_GENERIC_FAILURE RESULT_ERROR_RADIO_OFF RESULT_ERROR_NULL_PDU RESULT_ERROR_NO_SERVICE RESULT_ERROR_NO_SERVICE RESULT_ERROR_LIMIT_EXCEEDED RESULT_ERROR_FDN_CHECK_FAILURE RESULT_ERROR_SHORT_CODE_NOT_ALLOWED RESULT_ERROR_SHORT_CODE_NEVER_ALLOWED RESULT_RADIO_NOT_AVAILABLE RESULT_NETWORK_REJECT RESULT_INVALID_ARGUMENTS RESULT_INVALID_STATE RESULT_NO_MEMORY RESULT_INVALID_SMS_FORMAT RESULT_SYSTEM_ERROR RESULT_MODEM_ERROR RESULT_NETWORK_ERROR RESULT_ENCODING_ERROR RESULT_INVALID_SMSC_ADDRESS RESULT_OPERATION_NOT_ALLOWED RESULT_INTERNAL_ERROR RESULT_NO_RESOURCES RESULT_CANCELLED RESULT_REQUEST_NOT_SUPPORTED RESULT_NO_BLUETOOTH_SERVICE RESULT_INVALID_BLUETOOTH_ADDRESS RESULT_BLUETOOTH_DISCONNECTED RESULT_UNEXPECTED_EVENT_STOP_SENDING RESULT_SMS_BLOCKED_DURING_EMERGENCY RESULT_SMS_SEND_RETRY_FAILED RESULT_REMOTE_EXCEPTION RESULT_NO_DEFAULT_SMS_APP RESULT_RIL_RADIO_NOT_AVAILABLE RESULT_RIL_SMS_SEND_FAIL_RETRY RESULT_RIL_NETWORK_REJECT RESULT_RIL_INVALID_STATE RESULT_RIL_INVALID_ARGUMENTS RESULT_RIL_NO_MEMORY RESULT_RIL_REQUEST_RATE_LIMITED RESULT_RIL_INVALID_SMS_FORMAT RESULT_RIL_SYSTEM_ERR RESULT_RIL_ENCODING_ERR RESULT_RIL_INVALID_SMSC_ADDRESS RESULT_RIL_MODEM_ERR RESULT_RIL_NETWORK_ERR RESULT_RIL_INTERNAL_ERR RESULT_RIL_REQUEST_NOT_SUPPORTED RESULT_RIL_INVALID_MODEM_STATE RESULT_RIL_NETWORK_NOT_READY RESULT_RIL_OPERATION_NOT_ALLOWED RESULT_RIL_NO_RESOURCES RESULT_RIL_CANCELLED RESULT_RIL_SIM_ABSENT For RESULT_ERROR_GENERIC_FAILURE or any of the RESULT_RIL errors
the sentIntent may include the extra ""errorCode"" containing a radio technology specific
value generally only useful for troubleshooting. The per-application based SMS control checks sentIntent. If sentIntent
is NULL the caller will be checked against all unknown applications
which cause smaller number of SMS to be sent in checking period. |||
deliveryIntents ArrayList : if not null an ArrayList of PendingIntent s (one for each message part) that is
broadcast when the corresponding message part has been delivered
to the recipient.  The raw pdu of the status report is in the
extended data (""pdu""). |||",void,4,"Manages SMS operations such as sending data text and pdu SMS messages.
 Get this object by calling the static method  getDefault() . To create an instance of
  SmsManager  associated with a specific subscription ID call
  getSmsManagerForSubscriptionId(int) . This is typically used for devices that support
 multiple active subscriptions at once.

  For information about how to behave as the default SMS app on Android 4.4 (API level 19)
 and higher see  Telephony .",,sms,sms,1,no,yes,no,SINK,
<android.nfc.tech.Ndef: void close()>,"Disable I/O operations to the tag from this TagTechnology object and release resources. Also causes all blocked I/O operations on other thread to be canceled and
 return with IOException . Requires the Manifest.permission.NFC permission.",,void,-1,"Provides access to NDEF content and operations on a  Tag .

  Acquire a  Ndef  object using  get(Tag) .

  NDEF is an NFC Forum data format. The data formats are implemented in
  NdefMessage  and
  NdefRecord . This class provides methods to
 retrieve and modify the  NdefMessage 
 on a tag.

  There are currently four NFC Forum standardized tag types that can be
 formatted to contain NDEF data.
  NFC Forum Type 1 Tag ( NFC_FORUM_TYPE_1 ) such as the Innovision Topaz
  NFC Forum Type 2 Tag ( NFC_FORUM_TYPE_2 ) such as the NXP MIFARE Ultralight
  NFC Forum Type 3 Tag ( NFC_FORUM_TYPE_3 ) such as Sony Felica
  NFC Forum Type 4 Tag ( NFC_FORUM_TYPE_4 ) such as NXP MIFARE Desfire
  Ndef Some vendors have their own well defined specifications for storing NDEF data
 on tags that do not fall into the above categories. Android devices with NFC
 should enumerate and implement  Ndef  under these vendor specifications
 where possible but it is not mandatory.  getType()  returns a String
 describing this specification for example  MIFARE_CLASSIC  is
  com.nxp.ndef.mifareclassic .

  Android devices that support MIFARE Classic must also correctly
 implement  Ndef  on MIFARE Classic tags formatted to NDEF.

  For guaranteed compatibility across all Android devices with NFC it is
 recommended to use NFC Forum Types 1-4 in new deployments of NFC tags
 with NDEF payload. Vendor NDEF formats will not work on all Android devices.

  Note:  Methods that perform I/O operations
 require the  Manifest.permission.NFC  permission.","These classes provide access to a tag technology's features which vary by the type
 of tag that is scanned. A scanned tag can support multiple technologies and you can find
 out what they are by calling  getTechList() . For more information on dealing with tag technologies and handling the ones that you care about see
  The Tag Dispatch System .
 The  TagTechnology  interface provides an overview of the
 supported technologies.",no,no,0,no,no,no,no,
"<android.webkit.WebView: void loadUrl(String,Map)>",Loads the given URL with the specified additional HTTP headers. Also see compatibility note on evaluateJavascript(String ValueCallback ) .,"url String : the URL of the resource to load
This value must never be null . |||
additionalHttpHeaders Map : the additional headers to be used in the
HTTP request for this URL specified as a map from name to
value. Note that if this map contains any of the headers
that are set by default by this WebView such as those
controlling caching accept types or the User-Agent their
values may be overridden by this WebView's defaults.
This value must never be null . |||",void,8,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",no,network ,0,no,no,no,no,
"<android.content.ContextWrapper: void sendBroadcastAsUser(Intent,UserHandle,String)>","Version of sendBroadcast(android.content.Intent java.lang.String) that allows you to specify the
 user the broadcast will be sent to.  This is not available to applications
 that are not pre-installed on the system image. Requires android.Manifest.permission.INTERACT_ACROSS_USERS","intent Intent : The Intent to broadcast; all receivers matching this
Intent will receive the broadcast. |||
user UserHandle : UserHandle to send the intent to. |||
receiverPermission String : (optional) String naming a permission that
a receiver must hold in order to receive your broadcast.
If null no permission is required.
This value may be null . |||",void,17,"Proxying implementation of Context that simply delegates all of its calls to
 another Context.  Can be subclassed to modify behavior without changing
 the original Context.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",IPC,IPC,1,no,yes,no,SINK,
<android.widget.AdapterViewFlipper: void showPrevious()>,Manually shows the previous child.,,void,11,"Simple  ViewAnimator  that will animate between two or more views
 that have been added to it.  Only one child is shown at a time.  If
 requested can automatically flip between each child at a regular interval.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,no,0,no,no,no,no,
"<android.content.ContextWrapper: void sendBroadcastAsUser(Intent,UserHandle)>","Version of sendBroadcast(android.content.Intent) that allows you to specify the
 user the broadcast will be sent to.  This is not available to applications
 that are not pre-installed on the system image. Requires android.Manifest.permission.INTERACT_ACROSS_USERS","intent Intent : The intent to broadcast |||
user UserHandle : UserHandle to send the intent to. |||",void,17,"Proxying implementation of Context that simply delegates all of its calls to
 another Context.  Can be subclassed to modify behavior without changing
 the original Context.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",IPC,IPC,1,no,yes,no,SINK,
<android.app.Activity: void setTitleColor(int)>,"This method was deprecated
      in API level 21. Use action bar styles instead. Change the color of the title associated with this activity. This method is deprecated starting in API Level 11 and replaced by action
 bar styles. For information on styling the Action Bar read the Action Bar developer
 guide.",textColor int |||,void,1,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,UI,0,no,no,no,no,
<android.media.MediaPlayer: void pause()>,Pauses playback. Call start() to resume.,,void,1,"MediaPlayer class can be used to control playback
 of audio/video files and streams. An example on how to use the methods in
 this class can be found in  VideoView .

  Topics covered here are:
  State Diagram Valid and Invalid States Permissions Register informational and error callbacks","The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",no,no,0,no,no,no,no,
<android.nfc.tech.Ndef: NdefMessage getNdefMessage()>,"Read the current NdefMessage on this tag. This always reads the current NDEF Message stored on the tag. Note that this method may return null if the tag was in the
 INITIALIZED state as defined by NFC Forum as in that state the
 tag is formatted to support NDEF but does not contain a message yet. This is an I/O operation and will block until complete. It must
 not be called from the main application thread. A blocked call will be canceled with IOException if close() is called from another thread. Requires the Manifest.permission.NFC permission.",,NdefMessage the NDEF Message can be null |||,10,"Provides access to NDEF content and operations on a  Tag .

  Acquire a  Ndef  object using  get(Tag) .

  NDEF is an NFC Forum data format. The data formats are implemented in
  NdefMessage  and
  NdefRecord . This class provides methods to
 retrieve and modify the  NdefMessage 
 on a tag.

  There are currently four NFC Forum standardized tag types that can be
 formatted to contain NDEF data.
  NFC Forum Type 1 Tag ( NFC_FORUM_TYPE_1 ) such as the Innovision Topaz
  NFC Forum Type 2 Tag ( NFC_FORUM_TYPE_2 ) such as the NXP MIFARE Ultralight
  NFC Forum Type 3 Tag ( NFC_FORUM_TYPE_3 ) such as Sony Felica
  NFC Forum Type 4 Tag ( NFC_FORUM_TYPE_4 ) such as NXP MIFARE Desfire
  Ndef Some vendors have their own well defined specifications for storing NDEF data
 on tags that do not fall into the above categories. Android devices with NFC
 should enumerate and implement  Ndef  under these vendor specifications
 where possible but it is not mandatory.  getType()  returns a String
 describing this specification for example  MIFARE_CLASSIC  is
  com.nxp.ndef.mifareclassic .

  Android devices that support MIFARE Classic must also correctly
 implement  Ndef  on MIFARE Classic tags formatted to NDEF.

  For guaranteed compatibility across all Android devices with NFC it is
 recommended to use NFC Forum Types 1-4 in new deployments of NFC tags
 with NDEF payload. Vendor NDEF formats will not work on all Android devices.

  Note:  Methods that perform I/O operations
 require the  Manifest.permission.NFC  permission.","These classes provide access to a tag technology's features which vary by the type
 of tag that is scanned. A scanned tag can support multiple technologies and you can find
 out what they are by calling  getTechList() . For more information on dealing with tag technologies and handling the ones that you care about see
  The Tag Dispatch System .
 The  TagTechnology  interface provides an overview of the
 supported technologies.",nfc,nfc,1,yes,no,SOURCE,no,
"<android.view.MenuInflater: void inflate(int,Menu)>",Inflate a menu hierarchy from the specified XML resource. Throws InflateException if there is an error.,"menuRes int : Resource ID for an XML layout resource to load (e.g. R.menu.main_activity ) |||
menu Menu : The Menu to inflate into. The items and submenus will be
added to this Menu. |||",void,1,"This class is used to instantiate menu XML files into Menu objects.
  
 For performance reasons menu inflation relies heavily on pre-processing of
 XML files that is done at build time. Therefore it is not currently possible
 to use MenuInflater with an XmlPullParser over a plain XML file at runtime;
 it only works with an XmlPullParser returned from a compiled resource (R.
  something  file.)",,no,no,0,no,no,no,no,
<android.net.sip.SipAudioCall: void toggleMute()>,Toggles mute.,,void,9,"Handles an Internet audio call over SIP. You can instantiate this class with  SipManager 
 using  SipManager#makeAudioCall  and   SipManager#takeAudioCall .

  Note:  Using this class require the
    Manifest.permission.INTERNET  and
    Manifest.permission.USE_SIP  permissions. In addition  startAudio()  requires the
    Manifest.permission.RECORD_AUDIO 
    Manifest.permission.ACCESS_WIFI_STATE  and
    Manifest.permission.WAKE_LOCK  permissions; and  setSpeakerMode()  requires the
    Manifest.permission.MODIFY_AUDIO_SETTINGS  permission.",,no,no,0,no,no,no,no,
"<android.test.TouchUtils: int dragViewToX(InstrumentationTestCase,View,int,int)>",Simulate touching a view and dragging it to a specified location. Only moves horizontally.,"test InstrumentationTestCase : The test case that is being run |||
v View : The view that should be dragged |||
gravity int : Which part of the view to use for the initial down event. A combination of
(TOP CENTER_VERTICAL BOTTOM) and (LEFT CENTER_HORIZONTAL RIGHT) |||
toX int : Final location of the view after dragging |||",int distance in pixels covered by the drag |||,3,"Reusable methods for generating touch events. These methods can be used with
 InstrumentationTestCase or ActivityInstrumentationTestCase2 to simulate user interaction with
 the application through a touch screen.",,no,no,0,no,no,no,no,
<android.app.PendingIntent: UserHandle getCreatorUserHandle()>,"Return the user handle of the application that created this
 PendingIntent that is the user under which you will actually be
 sending the Intent.  The returned UserHandle is supplied by the system so
 that an application can not spoof its user.  See Process.myUserHandle() for
 more explanation of user handles. Be careful about how you use this.  All this tells you is
 who created the PendingIntent.  It does not tell you who
 handed the PendingIntent to you: that is PendingIntent objects are intended to be
 passed between applications so the PendingIntent you receive from an application
 could actually be one it received from another application meaning the result
 you get here will identify the original application.  Because of this you should
 only use this information to identify who you expect to be interacting with
 through a send() call not who gave you the PendingIntent.",,"UserHandle The user handle of the PendingIntent or null if there is
 none associated with it. |||",17,"A description of an Intent and target action to perform with it.  Instances
 of this class are created with  getActivity(Context int Intent int)   getActivities(Context int Intent[] int) 
  getBroadcast(Context int Intent int)  and  getService(Context int Intent int) ; the returned object can be
 handed to other applications so that they can perform the action you
 described on your behalf at a later time.

  By giving a PendingIntent to another application
 you are granting it the right to perform the operation you have specified
 as if the other application was yourself (with the same permissions and
 identity).  As such you should be careful about how you build the PendingIntent:
 almost always for example the base Intent you supply should have the component
 name explicitly set to one of your own components to ensure it is ultimately
 sent there and nowhere else.

  A PendingIntent itself is simply a reference to a token maintained by
 the system describing the original data used to retrieve it.  This means
 that even if its owning application's process is killed the
 PendingIntent itself will remain usable from other processes that
 have been given it.  If the creating application later re-retrieves the
 same kind of PendingIntent (same operation same Intent action data
 categories and components and same flags) it will receive a PendingIntent
 representing the same token if that is still valid and can thus call
  cancel()  to remove it.

  Because of this behavior it is important to know when two Intents
 are considered to be the same for purposes of retrieving a PendingIntent.
 A common mistake people make is to create multiple PendingIntent objects
 with Intents that only vary in their ""extra"" contents expecting to get
 a different PendingIntent each time.  This does  not  happen.  The
 parts of the Intent that are used for matching are the same ones defined
 by  Intent#filterEquals(Intent) .  If you use two
 Intent objects that are equivalent as per
  Intent#filterEquals(Intent)  then you will get
 the same PendingIntent for both of them.

  There are two typical ways to deal with this.

  If you truly need multiple distinct PendingIntent objects active at
 the same time (such as to use as two notifications that are both shown
 at the same time) then you will need to ensure there is something that
 is different about them to associate them with different PendingIntents.
 This may be any of the Intent attributes considered by
  Intent#filterEquals(Intent)  or different
 request code integers supplied to  getActivity(Context int Intent int)   getActivities(Context int Intent[] int) 
  getBroadcast(Context int Intent int)  or  getService(Context int Intent int) .

  If you only need one PendingIntent active at a time for any of the
 Intents you will use then you can alternatively use the flags
  FLAG_CANCEL_CURRENT  or  FLAG_UPDATE_CURRENT  to either
 cancel or modify whatever current PendingIntent is associated with the
 Intent you are supplying.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",user info,user info file,1,yes,no,SOURCE,no,
"<android.content.res.Resources: InputStream openRawResource(int,TypedValue)>","Open a data stream for reading a raw resource.  This can only be used
 with resources whose value is the name of an asset file -- that is it can be
 used to open drawable sound and raw resources; it will fail on string
 and color resources.","id int : The resource identifier to open as generated by the aapt tool. |||
value TypedValue : The TypedValue object to hold the resource information. |||","InputStream InputStream Access to the resource data.

 This value will never be null . |||",3,"Class for accessing an application's resources.  This sits on top of the
 asset manager of the application (accessible through  getAssets() ) and
 provides a high-level API for getting typed data from the assets.

  The Android resource system keeps track of all non-code assets associated with an
 application. You can use this class to access your application's resources. You can generally
 acquire the  Resources  instance associated with your application
 with  getResources() . The Android SDK tools compile your application's resources into the application binary
 at build time.  To use a resource you must install it correctly in the source tree (inside
 your project's  res/  directory) and build your application.  As part of the build
 process the SDK tools generate symbols for each resource which you can use in your application
 code to access the resources. Using application resources makes it easy to update various characteristics of your
 application without modifying code and—by providing sets of alternative
 resources—enables you to optimize your application for a variety of device configurations
 (such as for different languages and screen sizes). This is an important aspect of developing
 Android applications that are compatible on different types of devices. For more information about using resources see the documentation about  Application Resources .","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,not sure
<android.widget.DialerFilter: void setDigitsWatcher(TextWatcher)>,,watcher TextWatcher |||,void,1,"This widget is a layout that contains several specifically-named child views that
 handle keyboard entry interpreted as standard phone dialpad digits.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,callback,0,no,no,no,no,
"<android.content.BroadcastReceiver: IBinder peekService(Context,Intent)>","Provide a binder to an already-bound service.  This method is synchronous
 and will not start the target service if it is not present so it is safe
 to call from onReceive(Context Intent) .

 For peekService() to return a non null IBinder interface
 the service must have published it before. In other words some component
 must have called Context.bindService(Intent ServiceConnection int) on it.","myContext Context : The Context that had been passed to onReceive(android.content.Context android.content.Intent) |||
service Intent : Identifies the already-bound service you wish to use. See Context.bindService(Intent ServiceConnection int) for more information. |||",IBinder |||,3,"Base class for code that receives and handles broadcast intents sent by
  Context.sendBroadcast(Intent) .

  You can either dynamically register an instance of this class with
  Context#registerReceiver 
 or statically declare an implementation with the
  <receiver> 
 tag in your  AndroidManifest.xml .","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",IPC,IPC,1,no,yes,no,SINK,
"<android.app.Fragment: void startActivityForResult(Intent,int,Bundle)>","Call Activity#startActivityForResult(Intent int Bundle) from the fragment's
 containing Activity.","intent Intent |||
requestCode int |||
options Bundle |||",void,16,"A Fragment is a piece of an application's user interface or behavior
 that can be placed in an  Activity .  Interaction with fragments
 is done through  FragmentManager  which can be obtained via
  Activity#getFragmentManager()  and
  Fragment#getFragmentManager() .

  The Fragment class can be used many ways to achieve a wide variety of
 results. In its core it represents a particular operation or interface
 that is running within a larger  Activity .  A Fragment is closely
 tied to the Activity it is in and can not be used apart from one.  Though
 Fragment defines its own lifecycle that lifecycle is dependent on its
 activity: if the activity is stopped no fragments inside of it can be
 started; when the activity is destroyed all fragments will be destroyed.

  All subclasses of Fragment must include a public no-argument constructor.
 The framework will often re-instantiate a fragment class when needed
 in particular during state restore and needs to be able to find this
 constructor to instantiate it.  If the no-argument constructor is not
 available a runtime exception will occur in some cases during state
 restore.

  Topics covered here:
  Older Platforms Lifecycle Layout Back Stack","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",IPC,IPC,1,no,yes,no,SINK,
<android.database.sqlite.SQLiteDatabase: void disableWriteAheadLogging()>,This method disables the features enabled by enableWriteAheadLogging() .,,void,16,"Exposes methods to manage a SQLite database.

  
 SQLiteDatabase has methods to create delete execute SQL commands and
 perform other common database management tasks.
  
 See the Notepad sample application in the SDK for an example of creating
 and managing a database.
  
 Database names must be unique within an application not across all applications.
  Localized Collation - ORDER BY 
 In addition to SQLite's default  BINARY  collator Android supplies
 two more  LOCALIZED  which changes with the system's current locale
 and  UNICODE  which is the Unicode Collation Algorithm and not tailored
 to the current locale.","If you need to manage data in a private database use the  android.database.sqlite  classes. These classes are used to manage the  Cursor  object returned from a content provider query. Databases
 are usually created and opened with  openOrCreateDatabase(String int SQLiteDatabase.CursorFactory) 
 To make requests through
 content providers you can use the  content.ContentResolver  class.
  All databases are stored on the device in  /data/data/<package_name>/databases",no,database,0,no,no,no,no,
<android.widget.TextSwitcher: void setText(CharSequence)>,"Sets the text of the next view and switches to the next view. This can
 be used to animate the old text out and animate the next text in.",text CharSequence : the new text to display |||,void,1,"Specialized  ViewSwitcher  that contains
 only children of type  TextView .

 A TextSwitcher is useful to animate a label on screen. Whenever
  setText(java.lang.CharSequence)  is called TextSwitcher animates the current text
 out and animates the new text in.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",uncategorized,UI,1,no,yes,no,SINK,
<android.database.sqlite.SQLiteDatabase: SQLiteStatement compileStatement(String)>,"Compiles an SQL statement into a reusable pre-compiled statement object.
 The parameters are identical to execSQL(java.lang.String) . You may put ?s in the
 statement and fill in those values with SQLiteProgram#bindString and SQLiteProgram#bindLong each time you want to run the
 statement. Statements may not return result sets larger than 1x1. No two threads should be using the same SQLiteStatement at the same time.","sql String : The raw SQL statement may contain ? for unknown values to be
bound later. |||",SQLiteStatement A pre-compiled SQLiteStatement object. Note that SQLiteStatement s are not synchronized see the documentation for more details. |||,1,"Exposes methods to manage a SQLite database.

  
 SQLiteDatabase has methods to create delete execute SQL commands and
 perform other common database management tasks.
  
 See the Notepad sample application in the SDK for an example of creating
 and managing a database.
  
 Database names must be unique within an application not across all applications.
  Localized Collation - ORDER BY 
 In addition to SQLite's default  BINARY  collator Android supplies
 two more  LOCALIZED  which changes with the system's current locale
 and  UNICODE  which is the Unicode Collation Algorithm and not tailored
 to the current locale.","If you need to manage data in a private database use the  android.database.sqlite  classes. These classes are used to manage the  Cursor  object returned from a content provider query. Databases
 are usually created and opened with  openOrCreateDatabase(String int SQLiteDatabase.CursorFactory) 
 To make requests through
 content providers you can use the  content.ContentResolver  class.
  All databases are stored on the device in  /data/data/<package_name>/databases",no,database,0,no,no,no,no,
<android.view.View: void dispatchSystemUiVisibilityChanged(int)>,"This method was deprecated
      in API level R. Use WindowInsets#isVisible(int) to find out about system bar visibilities
 by setting a OnApplyWindowInsetsListener on this view. Dispatch callbacks to setOnSystemUiVisibilityChangeListener(View.OnSystemUiVisibilityChangeListener) down
 the view hierarchy.",visibility int |||,void,11,"This class represents the basic building block for user interface components. A View
 occupies a rectangular area on the screen and is responsible for drawing and
 event handling. View is the base class for  widgets  which are
 used to create interactive UI components (buttons text fields etc.). The
  ViewGroup  subclass is the base class for  layouts  which
 are invisible containers that hold other Views (or other ViewGroups) and define
 their layout properties.",,no,callback,0,no,no,no,no,
<android.widget.TextClock: void setFormat24Hour(CharSequence)>,"Specifies the formatting pattern used to display the date and/or time
 in 24-hour mode. The formatting pattern syntax is described in DateFormat . If this pattern is set to null getFormat24Hour() will be used
 even in 12-hour mode. If both 24-hour and 12-hour formatting patterns
 are set to null the default pattern for the current locale will be used
 instead. Note: if styling is not needed it is highly recommended
 you supply a format string generated by DateFormat#getBestDateTimePattern(java.util.Locale String) . This method
 takes care of generating a format string adapted to the desired locale. Related XML Attributes: android:format24Hour",format CharSequence : A date/time formatting pattern as described in DateFormat |||,void,17,"TextClock  can display the current date and/or time as
 a formatted string. This view honors the 24-hour format system setting. As such it is
 possible and recommended to provide two different formatting patterns:
 one to display the date/time in 24-hour mode and one to display the
 date/time in 12-hour mode. Most callers will want to use the defaults
 though which will be appropriate for the user's locale. It is possible to determine whether the system is currently in
 24-hour mode by calling  is24HourModeEnabled() . The rules used by this widget to decide how to format the date and
 time are the following: In 24-hour mode:
          Use the value returned by  getFormat24Hour()  when non-null Otherwise use the value returned by  getFormat12Hour()  when non-null Otherwise use a default value appropriate for the user's locale such as  h:mm a In 12-hour mode:
          Use the value returned by  getFormat12Hour()  when non-null Otherwise use the value returned by  getFormat24Hour()  when non-null Otherwise use a default value appropriate for the user's locale such as  HH:mm The  CharSequence  instances used as formatting patterns when calling either
  setFormat24Hour(java.lang.CharSequence)  or  setFormat12Hour(java.lang.CharSequence)  can
 contain styling information. To do so use a  Spanned  object.
 Note that if you customize these strings it is your responsibility to supply strings
 appropriate for formatting dates and/or times in the user's locale.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,no,0,no,no,no,no,
<android.view.ViewGroup: void clearChildFocus(View)>,Called when a child of this parent is giving up focus,child View : The view that is giving up focus |||,void,1,"A  ViewGroup  is a special view that can contain other views
 (called children.) The view group is the base class for layouts and views
 containers. This class also defines the
  ViewGroup.LayoutParams  class which serves as the base
 class for layouts parameters.
  
 Also see  LayoutParams  for layout attributes.",,no,no,0,no,no,no,no,
<android.view.View: void clearAnimation()>,Cancels any animations for this view.,,void,1,"This class represents the basic building block for user interface components. A View
 occupies a rectangular area on the screen and is responsible for drawing and
 event handling. View is the base class for  widgets  which are
 used to create interactive UI components (buttons text fields etc.). The
  ViewGroup  subclass is the base class for  layouts  which
 are invisible containers that hold other Views (or other ViewGroups) and define
 their layout properties.",,no,no,0,no,no,no,no,
"<android.widget.ArrayAdapter: View getView(int,View,ViewGroup)>","Get a View that displays the data at the specified position in the data set. You can either
 create a View manually or inflate it from an XML layout file. When the View is inflated the
 parent View (GridView ListView...) will apply default layout parameters unless you use LayoutInflater.inflate(int android.view.ViewGroup boolean) to specify a root view and to prevent attachment to the root.","position int : The position of the item within the adapter's data set of the item whose view
we want. |||
convertView View : This value may be null . |||
parent ViewGroup : This value must never be null . |||",View This value will never be null . |||,1,"You can use this adapter to provide views for an  AdapterView 
 Returns a view for each object in a collection of data objects you
 provide and can be used with list-based user interface widgets such as
  ListView  or  Spinner .
  
 By default the array adapter creates a view by calling  Object#toString()  on each
 data object in the collection you provide and places the result in a TextView.
 You may also customize what type of view is used for the data object in the collection.
 To customize what type of view is used for the data object
 override  getView(int android.view.View android.view.ViewGroup) 
 and inflate a view resource.
 For a code example see
 the  
 CustomChoiceList  sample.
  
 For an example of using an array adapter with a ListView see the
  
 Adapter Views  guide.
  
 For an example of using an array adapter with a Spinner see the
  Spinners  guide.
  Note: 
 If you are considering using array adapter with a ListView consider using
  RecyclerView  instead.
 RecyclerView offers similar features with better performance and more flexibility than
 ListView provides.
 See the
  
 Recycler View  guide.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",UI,UI,1,yes,no,SOURCE,no,
<android.text.Html: Spanned fromHtml(String)>,"This method was deprecated
      in API level 24. use fromHtml(java.lang.String int) instead. Returns displayable styled text from the provided HTML string with the legacy flags FROM_HTML_MODE_LEGACY .",source String |||,Spanned |||,1,"This class processes HTML strings into displayable styled text.
 Not all HTML tags are supported.","Provides classes used to render or track text and text spans on the screen. You can use these classes to design your own widgets that manage text
 to handle arbitrary text spans for changes or to handle drawing yourself
 for an existing widget. The Span… interfaces and classes are used to create or manage spans of
 text in a View item. You can use these to style the text or background or to
 listen for changes. If creating your own widget extend DynamicLayout to manages
 the actual wrapping and drawing of your text.",no,no,0,no,no,no,no,
<android.app.admin.DevicePolicyManager: int getPasswordMinimumNonLetter(ComponentName)>,"Retrieve the current number of non-letter characters required in the password
 for a particular admin or all admins that set restrictions on this user
 and its participating profiles. Restrictions on profiles that have
 a separate challenge are not taken into account.
 This is the same value as set by setPasswordMinimumNonLetter(android.content.ComponentName int) and only applies when the password quality is PASSWORD_QUALITY_COMPLEX . On devices not supporting PackageManager#FEATURE_SECURE_LOCK_SCREEN feature the
 password is always treated as empty. This method can be called on the DevicePolicyManager instance
 returned by getParentProfileInstance(android.content.ComponentName) in order to retrieve
 restrictions on the parent profile.","admin ComponentName : The name of the admin component to check or null to
aggregate all admins.
This value may be null . |||",int The minimum number of letters required in the password. |||,11,"Public interface for managing policies enforced on a device. Most clients of this class must be
 registered with the system as a  device
 administrator . Additionally a device administrator may be registered as either a profile or
 device owner. A given method is accessible to all device administrators unless the documentation
 for that method specifies that it is restricted to either device or profile owners. Any
 application calling an api may only pass as an argument a device administrator component it
 owns. Otherwise a  SecurityException  will be thrown.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",password metadata,password file ,1,yes,no,SOURCE,no,
"<android.nfc.NfcAdapter: void setBeamPushUris(Uri,Activity)>","This method was deprecated
      in API level 29. this feature is deprecated. File sharing can work using other technology like
 Bluetooth. Set one or more Uri s to send using Android Beam (TM). Every
 Uri you provide must have either scheme 'file' or scheme 'content'. For the data provided through this method Android Beam tries to
 switch to alternate transports such as Bluetooth to achieve a fast
 transfer speed. Hence this method is very suitable
 for transferring large files such as pictures or songs. The receiving side will store the content of each Uri in
 a file and present a notification to the user to open the file
 with a Intent with action Intent.ACTION_VIEW .
 If multiple URIs are sent the Intent will refer
 to the first of the stored files. This method may be called at any time before Activity#onDestroy but the URI(s) are only made available for Android Beam when the
 specified activity(s) are in resumed (foreground) state. The recommended
 approach is to call this method during your Activity's Activity#onCreate - see sample
 code below. This method does not immediately perform any I/O or blocking work
 so is safe to call on your main thread. setBeamPushUris(Uri[] Activity) and setBeamPushUrisCallback(NfcAdapter.CreateBeamUrisCallback Activity) have priority over both setNdefPushMessage(NdefMessage Activity Activity...) and setNdefPushMessageCallback(NfcAdapter.CreateNdefMessageCallback Activity Activity...) . If setBeamPushUris(Uri[] Activity) is called with a null Uri array
 and/or setBeamPushUrisCallback(NfcAdapter.CreateBeamUrisCallback Activity) is called with a null callback
 then the Uri push will be completely disabled for the specified activity(s). Code example: If your Activity wants to dynamically supply Uri(s)
 then set a callback using setBeamPushUrisCallback(NfcAdapter.CreateBeamUrisCallback Activity) instead
 of using this method. Do not pass in an Activity that has already been through Activity#onDestroy . This is guaranteed if you call this API
 during Activity#onCreate . If this device does not support alternate transports
 such as Bluetooth or WiFI calling this method does nothing. Requires the Manifest.permission.NFC permission.","uris Uri : an array of Uri(s) to push over Android Beam |||
activity Activity : activity for which the Uri(s) will be pushed |||",void,16,"Represents the local NFC adapter.
  
 Use the helper  getDefaultAdapter(android.content.Context)  to get the default NFC
 adapter for this Android device.","Provides access to Near Field Communication (NFC) functionality allowing applications to read
 NDEF message in NFC tags. A ""tag"" may actually be another device that appears as a tag. For more information see the
  Near Field Communication  guide. Here's a summary of the classes: NfcManager This is the high level manager used to obtain this device's  NfcAdapter . You can
 acquire an instance using  getSystemService(Class ) . NfcAdapter This represents the device's NFC adapter which is your entry-point to performing NFC
 operations. You can acquire an instance with  getDefaultAdapter()  or
  getDefaultAdapter(android.content.Context) . NdefMessage Represents an NDEF data message which is the standard format in which ""records""
 carrying data are transmitted between devices and tags. Your application can receive these
 messages from an  ACTION_TAG_DISCOVERED  intent. NdefRecord Represents a record which is delivered in a  NdefMessage  and describes the
 type of data being shared and carries the data itself. Note: 
 Not all Android-powered devices provide NFC functionality.",file data,nfc,1,no,yes,no,SINK,
<android.os.Parcel: void writeList(List)>,"Flatten a List into the parcel at the current dataPosition() growing
 dataCapacity() if needed.  The List values are written using writeValue(Object) and must follow the specification there.",val List : This value may be null . |||,void,1,"Container for a message (data and object references) that can
 be sent through an IBinder.  A Parcel can contain both flattened data
 that will be unflattened on the other side of the IPC (using the various
 methods here for writing specific types or the general
  Parcelable  interface) and references to live  IBinder 
 objects that will result in the other side receiving a proxy IBinder
 connected with the original IBinder in the Parcel.

  Parcel is  not  a general-purpose
 serialization mechanism.  This class (and the corresponding
  Parcelable  API for placing arbitrary objects into a Parcel) is
 designed as a high-performance IPC transport.  As such it is not
 appropriate to place any Parcel data in to persistent storage: changes
 in the underlying implementation of any of the data in the Parcel can
 render older data unreadable. The bulk of the Parcel API revolves around reading and writing data
 of various types.  There are six major classes of such functions available. Primitives The most basic data functions are for writing and reading primitive
 data types:  writeByte(byte)   readByte()   writeDouble(double) 
  readDouble()   writeFloat(float)   readFloat()   writeInt(int) 
  readInt()   writeLong(long)   readLong() 
  writeString(String)   readString() .  Most other
 data operations are built on top of these.  The given data is written and
 read using the endianess of the host CPU. Primitive Arrays There are a variety of methods for reading and writing raw arrays
 of primitive objects which generally result in writing a 4-byte length
 followed by the primitive data items.  The methods for reading can either
 read the data into an existing array or create and return a new array.
 These available types are: writeBooleanArray(boolean[]) 
  readBooleanArray(boolean[])   createBooleanArray() writeByteArray(byte[]) 
  writeByteArray(byte[] int int)   readByteArray(byte[]) 
  createByteArray() writeCharArray(char[])   readCharArray(char[]) 
  createCharArray() writeDoubleArray(double[])   readDoubleArray(double[]) 
  createDoubleArray() writeFloatArray(float[])   readFloatArray(float[]) 
  createFloatArray() writeIntArray(int[])   readIntArray(int[]) 
  createIntArray() writeLongArray(long[])   readLongArray(long[]) 
  createLongArray() writeStringArray(java.lang.String[])   readStringArray(java.lang.String[]) 
  createStringArray() .
  writeSparseBooleanArray(android.util.SparseBooleanArray) 
  readSparseBooleanArray() .
  Parcelables The  Parcelable  protocol provides an extremely efficient (but
 low-level) protocol for objects to write and read themselves from Parcels.
 You can use the direct methods  writeParcelable(android.os.Parcelable int) 
 and  readParcelable(java.lang.ClassLoader)  or
  writeParcelableArray(T[] int)  and
  readParcelableArray(java.lang.ClassLoader)  to write or read.  These
 methods write both the class type and its data to the Parcel allowing
 that class to be reconstructed from the appropriate class loader when
 later reading. There are also some methods that provide a more efficient way to work
 with Parcelables:  writeTypedObject(T int)   writeTypedArray(T[] int) 
  writeTypedList(List )   readTypedObject(Parcelable.Creator ) 
  createTypedArray(Parcelable.Creator )  and  createTypedArrayList(Parcelable.Creator ) .  These methods
 do not write the class information of the original object: instead the
 caller of the read function must know what type to expect and pass in the
 appropriate  Parcelable.Creator  instead to
 properly construct the new object and read its data.  (To more efficient
 write and read a single Parcelable object that is not null you can directly
 call  Parcelable#writeToParcel  and
  Parcelable.Creator#createFromParcel 
 yourself.) Bundles A special type-safe container called  Bundle  is available
 for key/value maps of heterogeneous values.  This has many optimizations
 for improved performance when reading and writing data and its type-safe
 API avoids difficult to debug type errors when finally marshalling the
 data contents into a Parcel.  The methods to use are
  writeBundle(android.os.Bundle)   readBundle()  and
  readBundle(java.lang.ClassLoader) .

  Active Objects An unusual feature of Parcel is the ability to read and write active
 objects.  For these objects the actual contents of the object is not
 written rather a special token referencing the object is written.  When
 reading the object back from the Parcel you do not get a new instance of
 the object but rather a handle that operates on the exact same object that
 was originally written.  There are two forms of active objects available. Binder  objects are a core facility of Android's general cross-process
 communication system.  The  IBinder  interface describes an abstract
 protocol with a Binder object.  Any such interface can be written in to
 a Parcel and upon reading you will receive either the original object
 implementing that interface or a special proxy implementation
 that communicates calls back to the original object.  The methods to use are
  writeStrongBinder(android.os.IBinder) 
  writeStrongInterface(android.os.IInterface)   readStrongBinder() 
  writeBinderArray(android.os.IBinder[])   readBinderArray(android.os.IBinder[]) 
  createBinderArray() 
  writeBinderList(java.util.List)   readBinderList(java.util.List) 
  createBinderArrayList() . FileDescriptor objects representing raw Linux file descriptor identifiers
 can be written and  ParcelFileDescriptor  objects returned to operate
 on the original file descriptor.  The returned file descriptor is a dup
 of the original file descriptor: the object and fd is different but
 operating on the same underlying file stream with the same position etc.
 The methods to use are  writeFileDescriptor(java.io.FileDescriptor) 
  readFileDescriptor() .

  Untyped Containers A final class of methods are for writing and reading standard Java
 containers of arbitrary types.  These all revolve around the
  writeValue(java.lang.Object)  and  readValue(java.lang.ClassLoader)  methods
 which define the types of objects allowed.  The container methods are
  writeArray(java.lang.Object[])   readArray(java.lang.ClassLoader) 
  writeList(java.util.List)   readList(java.util.List java.lang.ClassLoader) 
  readArrayList(java.lang.ClassLoader) 
  writeMap(java.util.Map)   readMap(java.util.Map java.lang.ClassLoader) 
  writeSparseArray(android.util.SparseArray) 
  readSparseArray(java.lang.ClassLoader) .",,IPC,no,0,no,no,no,no,
<android.database.MergeCursor: void deactivate()>,"Deactivates the Cursor making all calls on it fail until requery() is called.
 Inactive Cursors use fewer resources than active Cursors.
 Calling requery() will make the cursor active again.",,void,1,"A convenience class that lets you present an array of Cursors as a single linear Cursor.
 The schema of the cursors presented is entirely up to the creator of the MergeCursor and
 may be different if that is desired. Calls to getColumns getColumnIndex etc will return the
 value for the row that the MergeCursor is currently pointing at.","If you need to manage data in a private database use the  android.database.sqlite  classes. These classes are used to manage the  Cursor  object returned from a content provider query. Databases
 are usually created and opened with  openOrCreateDatabase(String int SQLiteDatabase.CursorFactory) 
 To make requests through
 content providers you can use the  content.ContentResolver  class.
  All databases are stored on the device in  /data/data/<package_name>/databases",no,no,0,no,no,no,no,
<android.media.RemoteControlClient: void setTransportControlFlags(int)>,Sets the flags for the media transport control buttons that this client supports.,transportControlFlags int : A combination of the following flags: FLAG_KEY_MEDIA_PREVIOUS  FLAG_KEY_MEDIA_REWIND  FLAG_KEY_MEDIA_PLAY  FLAG_KEY_MEDIA_PLAY_PAUSE  FLAG_KEY_MEDIA_PAUSE  FLAG_KEY_MEDIA_STOP  FLAG_KEY_MEDIA_FAST_FORWARD  FLAG_KEY_MEDIA_NEXT  FLAG_KEY_MEDIA_POSITION_UPDATE  FLAG_KEY_MEDIA_RATING . |||,void,14,"RemoteControlClient enables exposing information meant to be consumed by remote controls
 capable of displaying metadata artwork and media transport control buttons.

  A remote control client object is associated with a media button event receiver. This
 event receiver must have been previously registered with
  AudioManager#registerMediaButtonEventReceiver(ComponentName)  before the
 RemoteControlClient can be registered through
  AudioManager#registerRemoteControlClient(RemoteControlClient) .

  Here is an example of creating a RemoteControlClient instance after registering a media
 button event receiver:
  ComponentName myEventReceiver = new ComponentName(getPackageName() MyRemoteControlEventReceiver.class.getName());
 AudioManager myAudioManager = (AudioManager) getSystemService(Context.AUDIO_SERVICE);
 myAudioManager.registerMediaButtonEventReceiver(myEventReceiver);
 // build the PendingIntent for the remote control client
 Intent mediaButtonIntent = new Intent(Intent.ACTION_MEDIA_BUTTON);
 mediaButtonIntent.setComponent(myEventReceiver);
 PendingIntent mediaPendingIntent = PendingIntent.getBroadcast(getApplicationContext() 0 mediaButtonIntent 0);
 // create and register the remote control client
 RemoteControlClient myRemoteControlClient = new RemoteControlClient(mediaPendingIntent);
 myAudioManager.registerRemoteControlClient(myRemoteControlClient);","The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",no,no,0,no,no,no,no,
<android.media.AsyncPlayer: void stop()>,"Stop a previously played sound.  It can't be played again or unpaused
 at this point.  Calling this multiple times has no ill effects.",,void,1,"Plays a series of audio URIs but does all the hard work on another thread
 so that any slowness with preparing or loading doesn't block the calling thread.","The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",no,no,0,no,no,no,no,
"<android.webkit.WebView: void setHttpAuthUsernamePassword(String,String,String,String)>","This method was deprecated
      in API level 26. Use WebViewDatabase#setHttpAuthUsernamePassword instead Stores HTTP authentication credentials for a given host and realm to the WebViewDatabase instance.","host String : the host to which the credentials apply |||
realm String : the realm to which the credentials apply |||
username String : the username |||
password String : the password |||",void,1,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",no,network ,0,no,no,no,no,
<android.widget.AutoCompleteTextView: void onCommitCompletion(CompletionInfo)>,"Called by the framework in response to a text completion from
 the current input method provided by it calling InputConnection#commitCompletion .  The default implementation does
 nothing; text views that are supporting auto-completion should override
 this to do their desired behavior.",completion CompletionInfo : The auto complete text the user has selected. |||,void,3,"An editable text view that shows completion suggestions automatically
 while the user is typing. The list of suggestions is displayed in a drop
 down menu from which the user can choose an item to replace the content
 of the edit box with. The drop down can be dismissed at any time by pressing the back key or
 if no item is selected in the drop down by pressing the enter/dpad center
 key. The list of suggestions is obtained from a data adapter and appears
 only after a given number of characters defined by
  the threshold . The following code snippet shows how to create a text view which suggests
 various countries names while the user is typing: 
 public class CountriesActivity extends Activity {
     protected void onCreate(Bundle icicle) {
         super.onCreate(icicle);
         setContentView(R.layout.countries);

         ArrayAdapter<String> adapter = new ArrayAdapter<String>(this
                 android.R.layout.simple_dropdown_item_1line COUNTRIES);
         AutoCompleteTextView textView = (AutoCompleteTextView)
                 findViewById(R.id.countries_list);
         textView.setAdapter(adapter);
     }

     private static final String[] COUNTRIES = new String[] {
         ""Belgium"" ""France"" ""Italy"" ""Germany"" ""Spain""
     };
 }
  See the  Text Fields 
 guide.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",uncategorized,callback,1,no,yes,no,SINK,should methods that are intended to be overridden be considered
"<android.test.TouchUtils: void clickView(InstrumentationTestCase,View)>",Simulate touching the center of a view and releasing.,"test InstrumentationTestCase : The test case that is being run |||
v View : The view that should be clicked |||",void,1,"Reusable methods for generating touch events. These methods can be used with
 InstrumentationTestCase or ActivityInstrumentationTestCase2 to simulate user interaction with
 the application through a touch screen.",,no,no,0,no,no,no,no,
<android.app.PendingIntent: void cancel()>,"Cancel a currently active PendingIntent.  Only the original application
 owning a PendingIntent can cancel it.",,void,1,"A description of an Intent and target action to perform with it.  Instances
 of this class are created with  getActivity(Context int Intent int)   getActivities(Context int Intent[] int) 
  getBroadcast(Context int Intent int)  and  getService(Context int Intent int) ; the returned object can be
 handed to other applications so that they can perform the action you
 described on your behalf at a later time.

  By giving a PendingIntent to another application
 you are granting it the right to perform the operation you have specified
 as if the other application was yourself (with the same permissions and
 identity).  As such you should be careful about how you build the PendingIntent:
 almost always for example the base Intent you supply should have the component
 name explicitly set to one of your own components to ensure it is ultimately
 sent there and nowhere else.

  A PendingIntent itself is simply a reference to a token maintained by
 the system describing the original data used to retrieve it.  This means
 that even if its owning application's process is killed the
 PendingIntent itself will remain usable from other processes that
 have been given it.  If the creating application later re-retrieves the
 same kind of PendingIntent (same operation same Intent action data
 categories and components and same flags) it will receive a PendingIntent
 representing the same token if that is still valid and can thus call
  cancel()  to remove it.

  Because of this behavior it is important to know when two Intents
 are considered to be the same for purposes of retrieving a PendingIntent.
 A common mistake people make is to create multiple PendingIntent objects
 with Intents that only vary in their ""extra"" contents expecting to get
 a different PendingIntent each time.  This does  not  happen.  The
 parts of the Intent that are used for matching are the same ones defined
 by  Intent#filterEquals(Intent) .  If you use two
 Intent objects that are equivalent as per
  Intent#filterEquals(Intent)  then you will get
 the same PendingIntent for both of them.

  There are two typical ways to deal with this.

  If you truly need multiple distinct PendingIntent objects active at
 the same time (such as to use as two notifications that are both shown
 at the same time) then you will need to ensure there is something that
 is different about them to associate them with different PendingIntents.
 This may be any of the Intent attributes considered by
  Intent#filterEquals(Intent)  or different
 request code integers supplied to  getActivity(Context int Intent int)   getActivities(Context int Intent[] int) 
  getBroadcast(Context int Intent int)  or  getService(Context int Intent int) .

  If you only need one PendingIntent active at a time for any of the
 Intents you will use then you can alternatively use the flags
  FLAG_CANCEL_CURRENT  or  FLAG_UPDATE_CURRENT  to either
 cancel or modify whatever current PendingIntent is associated with the
 Intent you are supplying.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
"<android.media.MediaPlayer: MediaPlayer create(Context,int)>","Convenience method to create a MediaPlayer for a given resource id.
 On success prepare() will already have been called and must not be called again. When done with the MediaPlayer you should call release() to free the resources. If not released too many MediaPlayer instances will
 result in an exception. Note that since prepare() is called automatically in this method
 you cannot change the audio
 session ID (see setAudioSessionId(int) ) or audio attributes
 (see setAudioAttributes(android.media.AudioAttributes) of the new MediaPlayer.","context Context : the Context to use |||
resid int : the raw resource id ( R.raw.<something> ) for
the resource to use as the datasource |||",MediaPlayer a MediaPlayer object or null if creation failed |||,1,"MediaPlayer class can be used to control playback
 of audio/video files and streams. An example on how to use the methods in
 this class can be found in  VideoView .

  Topics covered here are:
  State Diagram Valid and Invalid States Permissions Register informational and error callbacks","The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",no,no,0,no,no,no,no,
<android.view.Display: int getOrientation()>,"This method was deprecated
      in API level 15. use getRotation()",,"int orientation of this display.
 
 Value is Surface.ROTATION_0  Surface.ROTATION_90  Surface.ROTATION_180 or Surface.ROTATION_270 |||",1,"Provides information about the size and density of a logical display.
  
 The display area is described in two different ways.
  The application display area specifies the part of the display that may contain
 an application window excluding the system decorations.  The application display area may
 be smaller than the real display area because the system subtracts the space needed
 for decor elements such as the status bar.  Use the following methods to query the
 application display area:  getSize(Point)   getRectSize(Rect)  and  getMetrics(DisplayMetrics) . The real display area specifies the part of the display that contains content
 including the system decorations.  Even so the real display area may be smaller than the
 physical size of the display if the window manager is emulating a smaller display
 using (adb shell wm size).  Use the following methods to query the
 real display area:  getRealSize(Point)   getRealMetrics(DisplayMetrics) . 
 A logical display does not necessarily represent a particular physical display device
 such as the built-in screen or an external monitor.  The contents of a logical
 display may be presented on one or more physical displays according to the devices
 that are currently attached and whether mirroring has been enabled.",,no,UI,0,no,no,no,no,
<android.widget.AbsListView: void setFilterText(String)>,Sets the initial value for the text filter.,filterText String : The text to use for the filter. |||,void,1,"Base class that can be used to implement virtualized lists of items. A list does
 not have a spatial definition here. For instance subclasses of this class can
 display the content of the list in a grid in a carousel as stack etc.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",uncategorized,UI,1,no,yes,no,SINK,
<android.speech.SpeechRecognizer: void destroy()>,Destroys the SpeechRecognizer object.,,void,8,"This class provides access to the speech recognition service. This service allows access to the
 speech recognizer. Do not instantiate this class directly instead call
  SpeechRecognizer#createSpeechRecognizer(Context) . This class's methods must be
 invoked only from the main application thread.

  The implementation of this API is likely to stream audio to remote servers to perform speech
 recognition. As such this API is not intended to be used for continuous recognition which would
 consume a significant amount of battery and bandwidth.

  Please note that the application must have  Manifest.permission.RECORD_AUDIO 
 permission to use this class.",,no,no,0,no,no,no,no,
<android.preference.Preference: void setTitle(int)>,Sets the title for this Preference with a resource ID.,titleResId int : the title as a resource ID |||,void,1,"Represents the basic Preference UI building
 block displayed by a  PreferenceActivity  in the form of a
  ListView . This class provides the  View  to be displayed in
 the activity and associates with a  SharedPreferences  to
 store/retrieve the preference data.
  
 When specifying a preference hierarchy in XML each element can point to a
 subclass of  Preference  similar to the view hierarchy and layouts.
  
 This class contains a  key  that will be used as the key into the
  SharedPreferences . It is up to the subclass to decide how to store
 the value.",,no,UI,0,no,no,no,no,
<android.widget.ShareActionProvider: View onCreateActionView()>,"This method is deprecated. use onCreateActionView(android.view.MenuItem) Factory method called by the Android framework to create new action views. This method has been deprecated in favor of onCreateActionView(android.view.MenuItem) .
 Newer apps that wish to support platform versions prior to API 16 should also
 implement this method to return a valid action view.",,View A new action view. |||,14,"This is a provider for a share action. It is responsible for creating views
 that enable data sharing and also to show a sub menu with sharing activities
 if the hosting item is placed on the overflow menu.
  
 Here is how to use the action provider with custom backing file in a  MenuItem :
  
 // In Activity#onCreateOptionsMenu
 public boolean onCreateOptionsMenu(Menu menu) {
     // Get the menu item.
     MenuItem menuItem = menu.findItem(R.id.my_menu_item);
     // Get the provider and hold onto it to set/change the share intent.
     mShareActionProvider = (ShareActionProvider) menuItem.getActionProvider();
     // Set history different from the default before getting the action
     // view since a call to  MenuItem#getActionView()  calls
     //  ActionProvider#onCreateActionView()  which uses the backing file name. Omit this
     // line if using the default share history file is desired.
     mShareActionProvider.setShareHistoryFileName(""custom_share_history.xml"");
     . . .
 }

 // Somewhere in the application.
 public void doShare(Intent shareIntent) {
     // When you want to share set the share intent.
     mShareActionProvider.setShareIntent(shareIntent);
 } Note:  While the sample snippet demonstrates how to use this provider
 in the context of a menu item the use of the provider is not limited to menu items.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",uncategorized,UI,1,yes,no,no,no,
<android.media.MediaScannerConnection: void disconnect()>,Releases the connection to the media scanner service.,,void,1,"MediaScannerConnection provides a way for applications to pass a
 newly created or downloaded media file to the media scanner service.
 The media scanner service will read metadata from the file and add
 the file to the media content provider.
 The MediaScannerConnectionClient provides an interface for the
 media scanner service to return the Uri for a newly scanned file
 to the client of the MediaScannerConnection class.","The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",no,no,0,no,no,no,no,
"<android.database.sqlite.SQLiteDatabase: Cursor query(String,String,String,String,String,String,String)>",Query the given table returning a Cursor over the result set.,"table String : The table name to compile the query against. |||
columns String : A list of which columns to return. Passing null will
return all columns which is discouraged to prevent reading
data from storage that isn't going to be used. |||
selection String : A filter declaring which rows to return formatted as an
SQL WHERE clause (excluding the WHERE itself). Passing null
will return all rows for the given table. |||
selectionArgs String : You may include ?s in selection which will be
replaced by the values from selectionArgs in order that they
appear in the selection. The values will be bound as Strings. |||
groupBy String : A filter declaring how to group rows formatted as an SQL
GROUP BY clause (excluding the GROUP BY itself). Passing null
will cause the rows to not be grouped. |||
having String : A filter declare which row groups to include in the cursor
if row grouping is being used formatted as an SQL HAVING
clause (excluding the HAVING itself). Passing null will cause
all row groups to be included and is required when row
grouping is not being used. |||
orderBy String : How to order the rows formatted as an SQL ORDER BY clause
(excluding the ORDER BY itself). Passing null will use the
default sort order which may be unordered. |||",Cursor A Cursor object which is positioned before the first entry. Note that Cursor s are not synchronized see the documentation for more details. |||,1,"Exposes methods to manage a SQLite database.

  
 SQLiteDatabase has methods to create delete execute SQL commands and
 perform other common database management tasks.
  
 See the Notepad sample application in the SDK for an example of creating
 and managing a database.
  
 Database names must be unique within an application not across all applications.
  Localized Collation - ORDER BY 
 In addition to SQLite's default  BINARY  collator Android supplies
 two more  LOCALIZED  which changes with the system's current locale
 and  UNICODE  which is the Unicode Collation Algorithm and not tailored
 to the current locale.","If you need to manage data in a private database use the  android.database.sqlite  classes. These classes are used to manage the  Cursor  object returned from a content provider query. Databases
 are usually created and opened with  openOrCreateDatabase(String int SQLiteDatabase.CursorFactory) 
 To make requests through
 content providers you can use the  content.ContentResolver  class.
  All databases are stored on the device in  /data/data/<package_name>/databases",database data,database,1,yes,no,SOURCE,no,
<android.view.View: void setFadingEdgeLength(int)>,"Set the size of the faded edge used to indicate that more content in this
 view is available.  Will not change whether the fading edge is enabled; use setVerticalFadingEdgeEnabled(boolean) or setHorizontalFadingEdgeEnabled(boolean) to enable the fading edge
 for the vertical or horizontal fading edges.","length int : The size in pixels of the faded edge used to indicate that more
content in this view is visible. |||",void,1,"This class represents the basic building block for user interface components. A View
 occupies a rectangular area on the screen and is responsible for drawing and
 event handling. View is the base class for  widgets  which are
 used to create interactive UI components (buttons text fields etc.). The
  ViewGroup  subclass is the base class for  layouts  which
 are invisible containers that hold other Views (or other ViewGroups) and define
 their layout properties.",,no,UI,0,no,no,no,no,
<android.content.res.Resources: int getDimensionPixelSize(int)>,"Retrieve a dimensional for a particular resource ID for use
 as a size in raw pixels.  This is the same as getDimension(int) except the returned value is converted to
 integer pixels for use as a size.  A size conversion involves
 rounding the base value and ensuring that a non-zero base value
 is at least one pixel in size.","id int : The desired resource identifier as generated by the aapt
tool. This integer encodes the package type and resource
entry. The value 0 is an invalid identifier. |||","int Resource dimension value multiplied by the appropriate
 metric and truncated to integer pixels. |||",1,"Class for accessing an application's resources.  This sits on top of the
 asset manager of the application (accessible through  getAssets() ) and
 provides a high-level API for getting typed data from the assets.

  The Android resource system keeps track of all non-code assets associated with an
 application. You can use this class to access your application's resources. You can generally
 acquire the  Resources  instance associated with your application
 with  getResources() . The Android SDK tools compile your application's resources into the application binary
 at build time.  To use a resource you must install it correctly in the source tree (inside
 your project's  res/  directory) and build your application.  As part of the build
 process the SDK tools generate symbols for each resource which you can use in your application
 code to access the resources. Using application resources makes it easy to update various characteristics of your
 application without modifying code and—by providing sets of alternative
 resources—enables you to optimize your application for a variety of device configurations
 (such as for different languages and screen sizes). This is an important aspect of developing
 Android applications that are compatible on different types of devices. For more information about using resources see the documentation about  Application Resources .","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,
<android.content.pm.PermissionGroupInfo: CharSequence loadDescription(PackageManager)>,"Retrieve the textual description of this permission.  This
 will call back on the given PackageManager to load the description from
 the application.","pm PackageManager : A PackageManager from which the label can be loaded; usually
the PackageManager from which you originally retrieved this item.
This value must never be null . |||","CharSequence Returns a CharSequence containing the permission's description.
 If there is no description null is returned. |||",1,"Information you can retrieve about a particular security permission
 group known to the system.  This corresponds to information collected from the
 AndroidManifest.xml's <permission-group> tags.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,
<android.app.AlarmManager: void cancel(PendingIntent)>,"Remove any alarms with a matching Intent .
 Any alarm of any type whose Intent matches this one (as defined by Intent#filterEquals ) will be canceled.","operation PendingIntent : IntentSender which matches a previously added
IntentSender. This parameter must not be null . |||",void,1,"This class provides access to the system alarm services.  These allow you
 to schedule your application to be run at some point in the future.  When
 an alarm goes off the  Intent  that had been registered for it
 is broadcast by the system automatically starting the target application
 if it is not already running.  Registered alarms are retained while the
 device is asleep (and can optionally wake the device up if they go off
 during that time) but will be cleared if it is turned off and rebooted.

  The Alarm Manager holds a CPU wake lock as long as the alarm receiver's
 onReceive() method is executing. This guarantees that the phone will not sleep
 until you have finished handling the broadcast. Once onReceive() returns the
 Alarm Manager releases this wake lock. This means that the phone will in some
 cases sleep as soon as your onReceive() method completes.  If your alarm receiver
 called  Context.startService()  it
 is possible that the phone will sleep before the requested service is launched.
 To prevent this your BroadcastReceiver and Service will need to implement a
 separate wake lock policy to ensure that the phone continues running until the
 service becomes available.

  Note: The Alarm Manager is intended for cases where you want to have
 your application code run at a specific time even if your application is
 not currently running.  For normal timing operations (ticks timeouts
 etc) it is easier and much more efficient to use
  Handler .","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
<android.widget.AbsListView: InputConnection onCreateInputConnection(EditorInfo)>,Return an InputConnection for editing of the filter text.,outAttrs EditorInfo : Fill in with attribute information about the connection. |||,InputConnection |||,3,"Base class that can be used to implement virtualized lists of items. A list does
 not have a spatial definition here. For instance subclasses of this class can
 display the content of the list in a grid in a carousel as stack etc.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",uncategorized,UI,1,yes,no,no,no,
<android.appwidget.AppWidgetHost: void deleteHost()>,"Remove all records about this host from the AppWidget manager. Call this when initializing your database as it might be because of a data wipe. 
Call this to have the AppWidget manager release all resources associated with your
   host.  Any future calls about this host will cause the records to be re-allocated.",,void,3,"AppWidgetHost provides the interaction with the AppWidget service for apps
 like the home screen that want to embed AppWidgets in their UI.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
"<android.content.Intent: Intent putExtra(String,String)>","Add extended data to the intent.  The name must include a package
 prefix for example the app com.android.contacts would use names
 like ""com.android.contacts.ShowAll"".","name String : The name of the extra data with package prefix. |||
value String : The String data value.
This value may be null . |||","Intent Returns the same Intent object for chaining multiple calls
 into a single statement.

 This value will never be null . |||",1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",IPC,no,0,no,no,no,no,
<android.app.LocalActivityManager: void dispatchStop()>,"Called by the container activity in its Activity#onStop so
 that LocalActivityManager can perform the corresponding action on the
 activities it holds.",,void,1,"Helper class for managing multiple running embedded activities in the same
 process. This class is not normally used directly but rather created for
 you as part of the  ActivityGroup  implementation.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
"<android.media.AudioManager: void adjustVolume(int,int)>","Adjusts the volume of the most relevant stream. For example if a call is
 active it will have the highest priority regardless of if the in-call
 screen is showing. Another example if music is playing in the background
 and a call is not active the music stream will be adjusted. This method should only be used by applications that replace the
 platform-wide management of audio settings or the main telephony
 application. This method has no effect if the device implements a fixed volume policy
 as indicated by isVolumeFixed() .","direction int : The direction to adjust the volume. One of ADJUST_LOWER  ADJUST_RAISE  ADJUST_SAME  ADJUST_MUTE  ADJUST_UNMUTE or ADJUST_TOGGLE_MUTE . |||
flags int : One or more flags. |||",void,1,AudioManager provides access to volume and ringer mode control.,"The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",no,no,0,no,no,no,no,
"<android.security.KeyChain: void choosePrivateKeyAlias(Activity,KeyChainAliasCallback,String,Principal,String,int,String)>","Launches an Activity for the user to select the alias
 for a private key and certificate pair for authentication. The
 selected alias or null will be returned via the
 KeyChainAliasCallback callback. A device policy controller (as a device or profile owner) can
 intercept the request before the activity is shown to pick a
 specific private key alias by implementing onChoosePrivateKeyAlias . keyTypes and issuers may be used to
 narrow down suggested choices to the user. If either keyTypes or issuers is specified and non-empty and there are no
 matching certificates in the KeyChain then the certificate
 selection prompt would be suppressed entirely. host and port may be used to give the user
 more context about the server requesting the credentials. alias allows the caller to preselect an existing
 alias which will still be subject to user confirmation.","activity Activity : The Activity context to use for
launching the new sub-Activity to prompt the user to select
a private key; used only to call startActivity(); must not
be null.
This value must never be null . |||
response KeyChainAliasCallback : Callback to invoke when the request completes;
must not be null.
This value must never be null . |||
keyTypes String : The acceptable types of asymmetric keys such as
""RSA"" ""EC"" or null.
This value may be null .
Value is KeyProperties.KEY_ALGORITHM_RSA  KeyProperties.KEY_ALGORITHM_EC  KeyProperties.KEY_ALGORITHM_AES  KeyProperties.KEY_ALGORITHM_HMAC_SHA1  KeyProperties.KEY_ALGORITHM_HMAC_SHA224  KeyProperties.KEY_ALGORITHM_HMAC_SHA256  KeyProperties.KEY_ALGORITHM_HMAC_SHA384 or KeyProperties.KEY_ALGORITHM_HMAC_SHA512 |||
issuers Principal : The acceptable certificate issuers for the
certificate matching the private key or null.
This value may be null . |||
host String : The host name of the server requesting the
certificate or null if unavailable.
This value may be null . |||
port int : The port number of the server requesting the
certificate or -1 if unavailable. |||
alias String : The alias to preselect if available or null if
unavailable.
This value may be null . |||",void,14,"The  KeyChain  class provides access to private keys and
 their corresponding certificate chains in credential storage.

  Applications accessing the  KeyChain  normally go through
 these steps:

  Receive a callback from an  X509KeyManager  that a private key is requested.

  Call  choosePrivateKeyAlias  to allow the user to select from a
 list of currently available private keys and corresponding
 certificate chains. The chosen alias will be returned by the
 callback  KeyChainAliasCallback#alias  or null if no private
 key is available or the user cancels the request.

  Call  getPrivateKey(Context String)  and  getCertificateChain(Context String)  to
 retrieve the credentials to return to the corresponding  X509KeyManager  callbacks.

  An application may remember the value of a selected alias to
 avoid prompting the user with  choosePrivateKeyAlias  on subsequent connections. If the alias is
 no longer valid null will be returned on lookups using that value

  An application can request the installation of private keys and
 certificates via the  Intent  provided by  createInstallIntent() . Private keys installed via this  Intent  will be accessible via  choosePrivateKeyAlias(Activity KeyChainAliasCallback String[] Principal[] Uri String)  while
 Certificate Authority (CA) certificates will be trusted by all
 applications through the default  X509TrustManager .","Provides access to a few facilities of the Android security
     subsystems.",no,no,0,no,no,no,no,
"<android.content.Intent: Intent putExtra(String,long)>","Add extended data to the intent.  The name must include a package
 prefix for example the app com.android.contacts would use names
 like ""com.android.contacts.ShowAll"".","name String : The name of the extra data with package prefix. |||
value long : The byte array data value.
This value may be null . |||","Intent Returns the same Intent object for chaining multiple calls
 into a single statement.

 This value will never be null . |||",1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,
"<android.content.res.TypedArray: int getColor(int,int)>","Retrieve the color value for the attribute at index .  If
 the attribute references a color resource holding a complex ColorStateList then the default color from
 the set is returned. This method will throw an exception if the attribute is defined but is
 not an integer color or color state list.","index int : Index of attribute to retrieve. |||
defValue int : Value to return if the attribute is not defined or
not a resource. |||",int Attribute color value or defValue if not defined. |||,1,"Container for an array of values that were retrieved with
  Resources.Theme#obtainStyledAttributes(AttributeSet int[] int int) 
 or  Resources#obtainAttributes .  Be
 sure to call  recycle()  when done with them.

 The indices used to retrieve values from this structure correspond to
 the positions of the attributes given to obtainStyledAttributes.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,
<android.text.AutoText: int getSize(View)>,"Returns the size of the auto text dictionary. The return value can be zero if there is
 no auto correction data available for the current locale.",view View : used to retrieve the current Locale and Resources. |||,int the number of entries in the auto text dictionary |||,3,This class accesses a dictionary of corrections to frequent misspellings.,"Provides classes used to render or track text and text spans on the screen. You can use these classes to design your own widgets that manage text
 to handle arbitrary text spans for changes or to handle drawing yourself
 for an existing widget. The Span… interfaces and classes are used to create or manage spans of
 text in a View item. You can use these to style the text or background or to
 listen for changes. If creating your own widget extend DynamicLayout to manages
 the actual wrapping and drawing of your text.",no,UI,0,no,no,no,no,
"<android.location.LocationManager: void setTestProviderLocation(String,Location)>","Sets a new location for the given test provider. This location will be identiable as a mock
 location to all clients via Location#isFromMockProvider() . The location object must have a minimum number of fields set to be considered valid as
 per documentation on Location class.","provider String : the provider name
This value must never be null . |||
location Location : the mock location
This value must never be null . |||",void,3,"A data class representing a geographic location.

  A location can consist of a latitude longitude timestamp
 and other information such as bearing altitude and velocity.

  All locations generated by the  LocationManager  are
 guaranteed to have a valid latitude longitude and timestamp
 (both UTC time and elapsed real-time since boot) all other
 parameters are optional.","Contains the framework API classes that define Android location-based and
 	related services. This API is not the recommended method for accessing Android location. 
 The
  Google Location Services API 
 part of Google Play services is the preferred way to add location-awareness to
 your app. It offers a simpler API higher accuracy low-power geofencing and
 more. If you are currently using the android.location API you are strongly
 encouraged to switch to the Google Location Services API as soon as
 possible.
  
 To learn more about the Google Location Services API see the
  Location API overview .",no,location sensors,0,no,no,no,no,
<android.content.ContextWrapper: Context createDisplayContext(Display)>,"Return a new Context object for the current Context but whose resources
 are adjusted to match the metrics of the given Display.  Each call to this method
 returns a new instance of a Context object; Context objects are not
 shared however common state (ClassLoader other Resources for the
 same configuration) may be so the Context itself can be fairly lightweight.

 To obtain an instance of a WindowManager (see getSystemService(java.lang.String) ) that
 is configured to show windows on the given display call createWindowContext(int android.os.Bundle) on the returned display Context or use an Activity .","display Display : A Display object specifying the display for whose metrics the
Context's resources should be tailored.
This value must never be null . |||",Context A Context for the display. |||,17,"Proxying implementation of Context that simply delegates all of its calls to
 another Context.  Can be subclassed to modify behavior without changing
 the original Context.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,
<android.widget.SearchView: void onActionViewCollapsed()>,"Called when this view is collapsed as an action view.
 See MenuItem#collapseActionView() .",,void,14,"A widget that provides a user interface for the user to enter a search query and submit a request
 to a search provider. Shows a list of query suggestions or results if available and allows the
 user to pick a suggestion or result to launch into.

  
 When the SearchView is used in an ActionBar as an action view for a collapsible menu item it
 needs to be set to iconified by default using  setIconifiedByDefault(true) . This is the default so nothing needs to be done.
  
 If you want the search field to always be visible then call setIconifiedByDefault(false).","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,no,0,no,no,no,no,
<android.app.WallpaperManager: Drawable peekDrawable()>,"Retrieve the current system wallpaper; if there is no wallpaper set
 a null pointer is returned. This is returned as an
 abstract Drawable that you can install in a View to display whatever
 wallpaper the user has currently set.",,"Drawable Returns a Drawable object that will draw the wallpaper or a
 null pointer if these is none. |||",5,"Provides access to the system wallpaper. With WallpaperManager you can
 get the current wallpaper get the desired dimensions for the wallpaper set
 the wallpaper and more.

   An app can check whether wallpapers are supported for the current user by calling
  isWallpaperSupported()  and whether setting of wallpapers is allowed by calling
  isSetWallpaperAllowed() .","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",image,UI,1,yes,no,SOURCE,no,
<android.webkit.WebView: void loadUrl(String)>,Loads the given URL. Also see compatibility note on evaluateJavascript(String ValueCallback ) .,"url String : the URL of the resource to load
This value must never be null . |||",void,1,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",no,network ,0,no,no,no,no,
<android.view.ViewGroup: void removeViewAt(int)>,Removes the view at the specified position in the group. Note: do not invoke this method from View.draw(android.graphics.Canvas)  View.onDraw(android.graphics.Canvas)  dispatchDraw(android.graphics.Canvas) or any related method.,index int : the position in the group of the view to remove |||,void,1,"A  ViewGroup  is a special view that can contain other views
 (called children.) The view group is the base class for layouts and views
 containers. This class also defines the
  ViewGroup.LayoutParams  class which serves as the base
 class for layouts parameters.
  
 Also see  LayoutParams  for layout attributes.",,no,no,0,no,no,no,no,
"<android.widget.SimpleCursorAdapter: void setViewImage(ImageView,String)>","Called by bindView() to set the image for an ImageView but only if
 there is no existing ViewBinder or if the existing ViewBinder cannot
 handle binding to an ImageView.

 By default the value will be treated as an image resource. If the
 value cannot be used as an image resource the value is used as an
 image Uri.

 Intended to be overridden by Adapters that need to filter strings
 retrieved from the database.","v ImageView : ImageView to receive an image |||
value String : the value retrieved from the cursor |||",void,1,"An easy adapter to map columns from a cursor to TextViews or ImageViews
 defined in an XML file. You can specify which columns you want which
 views you want to display the columns and the XML file that defines
 the appearance of these views.

 Binding occurs in two phases. First if a
  SimpleCursorAdapter.ViewBinder  is available
  ViewBinder#setViewValue(android.view.View android.database.Cursor int) 
 is invoked. If the returned value is true binding has occured. If the
 returned value is false and the view to bind is a TextView
  setViewText(android.widget.TextView java.lang.String)  is invoked. If the returned value
 is false and the view to bind is an ImageView
  setViewImage(android.widget.ImageView java.lang.String)  is invoked. If no appropriate
 binding can be found an  IllegalStateException  is thrown.

 If this adapter is used with filtering for instance in an
  AutoCompleteTextView  you can use the
  SimpleCursorAdapter.CursorToStringConverter  and the
  FilterQueryProvider  interfaces
 to get control over the filtering process. You can refer to
  convertToString(android.database.Cursor)  and
  CursorAdapter.runQueryOnBackgroundThread(java.lang.CharSequence)  for more information.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",image,UI,1,no,yes,no,SINK,
"<android.content.pm.LabeledIntent: void writeToParcel(Parcel,int)>",Flatten this object in to a Parcel.,"dest Parcel : The Parcel in which the object should be written. |||
parcelableFlags int : Additional flags about how the object should be written.
May be 0 or Parcelable.PARCELABLE_WRITE_RETURN_VALUE .
Value is either 0 or a combination of Parcelable.PARCELABLE_WRITE_RETURN_VALUE and android.os.Parcelable.PARCELABLE_ELIDE_DUPLICATES |||",void,5,"A special subclass of Intent that can have a custom label/icon
 associated with it.  Primarily for use with  Intent#ACTION_CHOOSER .","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",IPC,no,0,no,no,no,no,
<android.preference.ListPreference: void setEntries(int)>,,entriesResId int : The entries array as a resource. |||,void,1,"A  Preference  that displays a list of entries as
 a dialog.
  
 This preference will store a string into the SharedPreferences. This string will be the value
 from the  setEntryValues(java.lang.CharSequence[])  array.",,no,no,0,no,no,no,no,
<android.inputmethodservice.InputMethodService: void onFinishInput()>,"Called to inform the input method that text input has finished in
 the last editor.  At this point there may be a call to onStartInput(android.view.inputmethod.EditorInfo boolean) to perform input in a
 new editor or the input method may be left idle.  This method is not called when input restarts in the same editor. The default
 implementation uses the InputConnection to clear any active composing
 text; you can override this (not calling the base class implementation)
 to perform whatever behavior you would like.",,void,3,"InputMethodService provides a standard implementation of an InputMethod
 which final implementations can derive from and customize.  See the
 base class  AbstractInputMethodService  and the  InputMethod 
 interface for more information on the basics of writing input methods.

  In addition to the normal Service lifecycle methods this class
 introduces some new specific callbacks that most subclasses will want
 to make use of: onInitializeInterface()  for user-interface initialization
 in particular to deal with configuration changes while the service is
 running.
  onBindInput()  to find out about switching to a new client.
  onStartInput(EditorInfo boolean)  to deal with an input session starting with
 the client.
  onCreateInputView()   onCreateCandidatesView() 
 and  onCreateExtractTextView()  for non-demand generation of the UI.
  onStartInputView(android.view.inputmethod.EditorInfo boolean)  to deal with input
 starting within the input area of the IME.
  An input method has significant discretion in how it goes about its
 work: the  InputMethodService  provides
 a basic framework for standard UI elements (input view candidates view
 and running in fullscreen mode) but it is up to a particular implementor
 to decide how to use them.  For example one input method could implement
 an input area with a keyboard another could allow the user to draw text
 while a third could have no input area (and thus not be visible to the
 user) but instead listen to audio and perform text to speech conversion. In the implementation provided here all of these elements are placed
 together in a single window managed by the InputMethodService.  It will
 execute callbacks as it needs information about them and provides APIs for
 programmatic control over them.  They layout of these elements is explicitly
 defined: The soft input view if available is placed at the bottom of the
 screen.
  The candidates view if currently shown is placed above the soft
 input view.
  If not running fullscreen the application is moved or resized to be
 above these views; if running fullscreen the window will completely cover
 the application and its top part will contain the extract text of what is
 currently being edited by the application.
  Soft Input View Central to most input methods is the soft input view.  This is where most
 user interaction occurs: pressing on soft keys drawing characters or
 however else your input method wants to generate text.  Most implementations
 will simply have their own view doing all of this work and return a new
 instance of it when  onCreateInputView()  is called.  At that point
 as long as the input view is visible you will see user interaction in
 that view and can call back on the InputMethodService to interact with the
 application as appropriate. There are some situations where you want to decide whether or not your
 soft input view should be shown to the user.  This is done by implementing
 the  onEvaluateInputViewShown()  to return true or false based on
 whether it should be shown in the current environment.  If any of your
 state has changed that may impact this call
  updateInputViewShown()  to have it re-evaluated.  The default
 implementation always shows the input view unless there is a hard
 keyboard available which is the appropriate behavior for most input
 methods. Candidates View Often while the user is generating raw text an input method wants to
 provide them with a list of possible interpretations of that text that can
 be selected for use.  This is accomplished with the candidates view and
 like the soft input view you implement  onCreateCandidatesView() 
 to instantiate your own view implementing your candidates UI. Management of the candidates view is a little different than the input
 view because the candidates view tends to be more transient being shown
 only when there are possible candidates for the current text being entered
 by the user.  To control whether the candidates view is shown you use
  setCandidatesViewShown(boolean) .  Note that because the candidate
 view tends to be shown and hidden a lot it does not impact the application
 UI in the same way as the soft input view: it will never cause application
 windows to resize only cause them to be panned if needed for the user to
 see the current focus. Fullscreen Mode Sometimes your input method UI is too large to integrate with the
 application UI so you just want to take over the screen.  This is
 accomplished by switching to full-screen mode causing the input method
 window to fill the entire screen and add its own ""extracted text"" editor
 showing the user the text that is being typed.  Unlike the other UI elements
 there is a standard implementation for the extract editor that you should
 not need to change.  The editor is placed at the top of the IME above the
 input and candidates views. Similar to the input view you control whether the IME is running in
 fullscreen mode by implementing  onEvaluateFullscreenMode() 
 to return true or false based on
 whether it should be fullscreen in the current environment.  If any of your
 state has changed that may impact this call
  updateFullscreenMode()  to have it re-evaluated.  The default
 implementation selects fullscreen mode when the screen is in a landscape
 orientation which is appropriate behavior for most input methods that have
 a significant input area. When in fullscreen mode you have some special requirements because the
 user can not see the application UI.  In particular you should implement
  onDisplayCompletions(android.view.inputmethod.CompletionInfo[])  to show completions
 generated by your application typically in your candidates view like you
 would normally show candidates.


  Generating Text The key part of an IME is of course generating text for the application.
 This is done through calls to the
  InputConnection  interface to the
 application which can be retrieved from  getCurrentInputConnection() .
 This interface allows you to generate raw key events or if the target
 supports it directly edit in strings of candidates and committed text. Information about what the target is expected and supports can be found
 through the  EditorInfo  class which is
 retrieved with  getCurrentInputEditorInfo()  method.  The most
 important part of this is  EditorInfo.inputType ; in particular if this is
  EditorInfo.TYPE_NULL 
 then the target does not support complex edits and you need to only deliver
 raw key events to it.  An input method will also want to look at other
 values here to for example detect password mode auto complete text views
 phone number entry etc. When the user switches between input targets you will receive calls to
  onFinishInput()  and  onStartInput(android.view.inputmethod.EditorInfo boolean) .
 You can use these to reset and initialize your input state for the current
 target.  For example you will often want to clear any input state and
 update a soft keyboard to be appropriate for the new inputType.",,no,no,0,no,no,no,no,
<android.content.ContentResolver: SyncAdapterType getSyncAdapterTypes()>,Get information about the SyncAdapters that are known to the system.,,SyncAdapterType[] an array of SyncAdapters that have registered with the system |||,5,This class provides applications access to the content model.,"Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,
"<android.app.Activity: void startActivities(Intent,Bundle)>","Launch a new activity.  You will not receive any information about when
 the activity exits.  This implementation overrides the base version
 providing information about
 the activity performing the launch.  Because of this additional
 information the Intent#FLAG_ACTIVITY_NEW_TASK launch flag is not
 required; if not specified the new activity will be added to the
 task of the caller. This method throws ActivityNotFoundException if there was no Activity found to run the given Intent.","intents Intent : The intents to start. |||
options Bundle : Additional options for how the Activity should be started.
See Context.startActivity(Intent Bundle) Context.startActivity(Intent Bundle)} for more details.
This value may be null . |||",void,16,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",IPC,IPC,1,no,yes,no,SINK,
<android.widget.TextClock: void setFormat12Hour(CharSequence)>,"Specifies the formatting pattern used to display the date and/or time
 in 12-hour mode. The formatting pattern syntax is described in DateFormat . If this pattern is set to null getFormat24Hour() will be used
 even in 12-hour mode. If both 24-hour and 12-hour formatting patterns
 are set to null the default pattern for the current locale will be used
 instead. Note: if styling is not needed it is highly recommended
 you supply a format string generated by DateFormat#getBestDateTimePattern(java.util.Locale String) . This method
 takes care of generating a format string adapted to the desired locale. Related XML Attributes: android:format12Hour",format CharSequence : A date/time formatting pattern as described in DateFormat |||,void,17,"TextClock  can display the current date and/or time as
 a formatted string. This view honors the 24-hour format system setting. As such it is
 possible and recommended to provide two different formatting patterns:
 one to display the date/time in 24-hour mode and one to display the
 date/time in 12-hour mode. Most callers will want to use the defaults
 though which will be appropriate for the user's locale. It is possible to determine whether the system is currently in
 24-hour mode by calling  is24HourModeEnabled() . The rules used by this widget to decide how to format the date and
 time are the following: In 24-hour mode:
          Use the value returned by  getFormat24Hour()  when non-null Otherwise use the value returned by  getFormat12Hour()  when non-null Otherwise use a default value appropriate for the user's locale such as  h:mm a In 12-hour mode:
          Use the value returned by  getFormat12Hour()  when non-null Otherwise use the value returned by  getFormat24Hour()  when non-null Otherwise use a default value appropriate for the user's locale such as  HH:mm The  CharSequence  instances used as formatting patterns when calling either
  setFormat24Hour(java.lang.CharSequence)  or  setFormat12Hour(java.lang.CharSequence)  can
 contain styling information. To do so use a  Spanned  object.
 Note that if you customize these strings it is your responsibility to supply strings
 appropriate for formatting dates and/or times in the user's locale.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,no,0,no,no,no,no,
<android.view.ViewStub: View inflate()>,Inflates the layout resource identified by getLayoutResource() and replaces this StubbedView in its parent by the inflated layout resource.,,View The inflated layout resource. |||,1,"A ViewStub is an invisible zero-sized View that can be used to lazily inflate
 layout resources at runtime.

 When a ViewStub is made visible or when  inflate()   is invoked the layout resource
 is inflated. The ViewStub then replaces itself in its parent with the inflated View or Views.
 Therefore the ViewStub exists in the view hierarchy until  setVisibility(int)  or
  inflate()  is invoked.

 The inflated View is added to the ViewStub's parent with the ViewStub's layout
 parameters. Similarly you can define/override the inflate View's id by using the
 ViewStub's inflatedId property. For instance:

  
     <ViewStub android:id=""@+id/stub""
               android:inflatedId=""@+id/subTree""
               android:layout=""@layout/mySubTree""
               android:layout_width=""120dip""
               android:layout_height=""40dip"" />
  
     ViewStub stub = findViewById(R.id.stub);
     View inflated = stub.inflate();
  inflate()",,no,no,0,no,no,no,no,
"<android.text.method.NumberKeyListener: CharSequence filter(CharSequence,int,int,Spanned,int,int)>","This method is called when the buffer is going to replace the
 range dstart … dend of dest with the new text from the range start … end of source .  Return the CharSequence that you would
 like to have placed there instead including an empty string
 if appropriate or null to accept the original
 replacement.  Be careful to not to reject 0-length replacements
 as this is what happens when you delete text.  Also beware that
 you should not attempt to make any changes to dest from this method; you may only examine it for context.

 Note: If source is an instance of Spanned or Spannable the span objects in the source should be
 copied into the filtered result (i.e. the non-null return value). TextUtils#copySpansFrom can be used for convenience if the
 span boundary indices would be remaining identical relative to the source.","source CharSequence |||
start int |||
end int |||
dest Spanned |||
dstart int |||
dend int |||",CharSequence |||,1,"For numeric text entry
  KeyListener","Provides classes that monitor or modify keypad input. You can use these classes to modify the type of keypad entry
 for your application or decipher the keypresses entered for your specific
 entry method. For example: 
 // Set the text to password display style:
 EditText txtView = (EditText)findViewById(R.id.text);
 txtView.setTransformationMethod(PasswordTransformationMethod.getInstance());

 //Set the input style to numbers rather than qwerty keyboard style.
 txtView.setInputMethod(DigitsInputMethod.getInstance());

 // Find out whether the caps lock is on.
 // 0 is no 1 is yes 2 is caps lock on.
 int active = MultiTapInputMethod.getCapsActive(txtView.getText());",uncategorized,UI,1,no,yes,no,SINK,
<android.speech.tts.TextToSpeech: int setPitch(float)>,"Sets the speech pitch for the TextToSpeech engine.

 This has no effect on any pre-recorded speech.","pitch float : Speech pitch. 1.0 is the normal pitch
lower values lower the tone of the synthesized voice
greater values increase it. |||",int ERROR or SUCCESS . |||,4,"Synthesizes speech from text for immediate playback or to create a sound file.
  A TextToSpeech instance can only be used to synthesize text once it has completed its
 initialization. Implement the  TextToSpeech.OnInitListener  to be
 notified of the completion of the initialization. 
 When you are done using the TextToSpeech instance call the  shutdown()  method
 to release the native resources used by the TextToSpeech engine.",,no,no,0,no,no,no,no,
<android.app.SearchManager: List getSearchablesInGlobalSearch()>,Returns a list of the searchable activities that can be included in global search.,,"List < SearchableInfo > a list containing searchable information for all searchable activities
         that have the android:includeInGlobalSearch attribute set
         in their searchable meta-data. |||",8,"This class provides access to the system search services.

  In practice you won't interact with this class directly as search
 services are provided through methods in  Activity 
 and the  ACTION_SEARCH Intent .

  Configuration#UI_MODE_TYPE_WATCH  does not support this system service.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
<android.app.Instrumentation: void sendCharacterSync(int)>,"Higher-level method for sending both the down and up key events for a
 particular character key code.  Equivalent to creating both KeyEvent
 objects by hand and calling sendKeySync(KeyEvent) .  The event appears
 as if it came from keyboard 0 the built in one.",keyCode int : The key code of the character to send. |||,void,1,"Base class for implementing application instrumentation code.  When running
 with instrumentation turned on this class will be instantiated for you
 before any of the application code allowing you to monitor all of the
 interaction the system has with the application.  An Instrumentation
 implementation is described to the system through an AndroidManifest.xml's
 <instrumentation> tag.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
<android.content.Intent: Intent putExtras(Intent)>,Copy all extras in 'src' in to this intent.,"src Intent : Contains the extras to copy.
This value must never be null . |||",Intent This value will never be null . |||,1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,
<android.webkit.WebView: void clearMatches()>,Clears the highlighting surrounding text matches created by findAllAsync(String) .,,void,3,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",no,no,0,no,no,no,no,
"<android.content.Intent: void writeToParcel(Parcel,int)>",Flatten this object in to a Parcel.,"out Parcel : The Parcel in which the object should be written. |||
flags int : Additional flags about how the object should be written.
May be 0 or Parcelable.PARCELABLE_WRITE_RETURN_VALUE .
Value is either 0 or a combination of Parcelable.PARCELABLE_WRITE_RETURN_VALUE and android.os.Parcelable.PARCELABLE_ELIDE_DUPLICATES |||",void,1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,
<android.widget.AbsListView: void setChoiceMode(int)>,"Defines the choice behavior for the List. By default Lists do not have any choice behavior
 ( CHOICE_MODE_NONE ). By setting the choiceMode to CHOICE_MODE_SINGLE the
 List allows up to one item to  be in a chosen state. By setting the choiceMode to CHOICE_MODE_MULTIPLE the list allows any number of items to be chosen.",choiceMode int : One of CHOICE_MODE_NONE  CHOICE_MODE_SINGLE or CHOICE_MODE_MULTIPLE |||,void,11,"Base class that can be used to implement virtualized lists of items. A list does
 not have a spatial definition here. For instance subclasses of this class can
 display the content of the list in a grid in a carousel as stack etc.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,no,0,no,no,no,no,
"<android.test.ProviderTestCase2: ContentResolver newResolverWithContentProviderFromSql(Context,String,Class,String,String,int,String)>","Creates a new content provider of the same type as that passed to the test case class
      with an authority name set to the authority parameter and using an SQLite database as
      the underlying data source. The SQL statement parameter is used to create the database.
      This method also creates a new MockContentResolver and adds the provider to it. Both the new provider and the new resolver are put into an IsolatedContext that uses the targetContext parameter for file operations and a MockContext for everything else. The IsolatedContext prepends the filenamePrefix parameter to
      file database and directory names. This is a convenience method for creating a ""mock"" provider that can contain test data.","targetContext Context : The context to use as the basis of the IsolatedContext |||
filenamePrefix String : A string that is prepended to file database and directory names |||
providerClass Class : The type of the provider being tested |||
authority String : The authority string to associated with the test provider |||
databaseName String : The name assigned to the database |||
databaseVersion int : The version assigned to the database |||
sql String : A string containing the SQL statements that are needed to create the desired
database and its tables. The format is the same as that generated by the sqlite3 tool's .dump command. |||",ContentResolver ContentResolver A new MockContentResolver linked to the provider |||,3,"This test case class provides a framework for testing a single
  ContentProvider  and for testing your app code with an
 isolated content provider. Instead of using the system map of
 providers that is based on the manifests of other applications the test
 case creates its own internal map. It then uses this map to resolve providers
 given an authority. This allows you to inject test providers and to null out
 providers that you do not want to use.
  
      This test case also sets up the following mock objects:
  
          An  IsolatedContext  that stubs out Context methods that might
          affect the rest of the running system while allowing tests to do real file and
          database work.
       
          A  MockContentResolver  that provides the functionality of a
          regular content resolver but uses  IsolatedContext . It stubs out
           ContentResolver#notifyChange(Uri ContentObserver boolean)  to
          prevent the test from affecting the running system.
       
          An instance of the provider under test running in an  IsolatedContext .
       
      This framework is set up automatically by the base class'  setUp()  method. If you
      override this method you must call the super method as the first statement in
      your override.
  
     In order for their tests to be run concrete subclasses must provide their own
     constructor with no arguments. This constructor must call
      ProviderTestCase2(java.lang.Class java.lang.String)  as  its first operation.
  Content Provider Testing",,no,no,0,no,no,no,no,
<android.inputmethodservice.InputMethodService: void hideWindow()>,,,void,3,"InputMethodService provides a standard implementation of an InputMethod
 which final implementations can derive from and customize.  See the
 base class  AbstractInputMethodService  and the  InputMethod 
 interface for more information on the basics of writing input methods.

  In addition to the normal Service lifecycle methods this class
 introduces some new specific callbacks that most subclasses will want
 to make use of: onInitializeInterface()  for user-interface initialization
 in particular to deal with configuration changes while the service is
 running.
  onBindInput()  to find out about switching to a new client.
  onStartInput(EditorInfo boolean)  to deal with an input session starting with
 the client.
  onCreateInputView()   onCreateCandidatesView() 
 and  onCreateExtractTextView()  for non-demand generation of the UI.
  onStartInputView(android.view.inputmethod.EditorInfo boolean)  to deal with input
 starting within the input area of the IME.
  An input method has significant discretion in how it goes about its
 work: the  InputMethodService  provides
 a basic framework for standard UI elements (input view candidates view
 and running in fullscreen mode) but it is up to a particular implementor
 to decide how to use them.  For example one input method could implement
 an input area with a keyboard another could allow the user to draw text
 while a third could have no input area (and thus not be visible to the
 user) but instead listen to audio and perform text to speech conversion. In the implementation provided here all of these elements are placed
 together in a single window managed by the InputMethodService.  It will
 execute callbacks as it needs information about them and provides APIs for
 programmatic control over them.  They layout of these elements is explicitly
 defined: The soft input view if available is placed at the bottom of the
 screen.
  The candidates view if currently shown is placed above the soft
 input view.
  If not running fullscreen the application is moved or resized to be
 above these views; if running fullscreen the window will completely cover
 the application and its top part will contain the extract text of what is
 currently being edited by the application.
  Soft Input View Central to most input methods is the soft input view.  This is where most
 user interaction occurs: pressing on soft keys drawing characters or
 however else your input method wants to generate text.  Most implementations
 will simply have their own view doing all of this work and return a new
 instance of it when  onCreateInputView()  is called.  At that point
 as long as the input view is visible you will see user interaction in
 that view and can call back on the InputMethodService to interact with the
 application as appropriate. There are some situations where you want to decide whether or not your
 soft input view should be shown to the user.  This is done by implementing
 the  onEvaluateInputViewShown()  to return true or false based on
 whether it should be shown in the current environment.  If any of your
 state has changed that may impact this call
  updateInputViewShown()  to have it re-evaluated.  The default
 implementation always shows the input view unless there is a hard
 keyboard available which is the appropriate behavior for most input
 methods. Candidates View Often while the user is generating raw text an input method wants to
 provide them with a list of possible interpretations of that text that can
 be selected for use.  This is accomplished with the candidates view and
 like the soft input view you implement  onCreateCandidatesView() 
 to instantiate your own view implementing your candidates UI. Management of the candidates view is a little different than the input
 view because the candidates view tends to be more transient being shown
 only when there are possible candidates for the current text being entered
 by the user.  To control whether the candidates view is shown you use
  setCandidatesViewShown(boolean) .  Note that because the candidate
 view tends to be shown and hidden a lot it does not impact the application
 UI in the same way as the soft input view: it will never cause application
 windows to resize only cause them to be panned if needed for the user to
 see the current focus. Fullscreen Mode Sometimes your input method UI is too large to integrate with the
 application UI so you just want to take over the screen.  This is
 accomplished by switching to full-screen mode causing the input method
 window to fill the entire screen and add its own ""extracted text"" editor
 showing the user the text that is being typed.  Unlike the other UI elements
 there is a standard implementation for the extract editor that you should
 not need to change.  The editor is placed at the top of the IME above the
 input and candidates views. Similar to the input view you control whether the IME is running in
 fullscreen mode by implementing  onEvaluateFullscreenMode() 
 to return true or false based on
 whether it should be fullscreen in the current environment.  If any of your
 state has changed that may impact this call
  updateFullscreenMode()  to have it re-evaluated.  The default
 implementation selects fullscreen mode when the screen is in a landscape
 orientation which is appropriate behavior for most input methods that have
 a significant input area. When in fullscreen mode you have some special requirements because the
 user can not see the application UI.  In particular you should implement
  onDisplayCompletions(android.view.inputmethod.CompletionInfo[])  to show completions
 generated by your application typically in your candidates view like you
 would normally show candidates.


  Generating Text The key part of an IME is of course generating text for the application.
 This is done through calls to the
  InputConnection  interface to the
 application which can be retrieved from  getCurrentInputConnection() .
 This interface allows you to generate raw key events or if the target
 supports it directly edit in strings of candidates and committed text. Information about what the target is expected and supports can be found
 through the  EditorInfo  class which is
 retrieved with  getCurrentInputEditorInfo()  method.  The most
 important part of this is  EditorInfo.inputType ; in particular if this is
  EditorInfo.TYPE_NULL 
 then the target does not support complex edits and you need to only deliver
 raw key events to it.  An input method will also want to look at other
 values here to for example detect password mode auto complete text views
 phone number entry etc. When the user switches between input targets you will receive calls to
  onFinishInput()  and  onStartInput(android.view.inputmethod.EditorInfo boolean) .
 You can use these to reset and initialize your input state for the current
 target.  For example you will often want to clear any input state and
 update a soft keyboard to be appropriate for the new inputType.",,no,no,0,no,no,no,no,
"<android.content.ContentProviderClient: Cursor query(Uri,String,String,String,String,CancellationSignal)>",See ContentProvider#query,"uri Uri : This value must never be null . |||
projection String : This value may be null . |||
selection String : This value may be null . |||
selectionArgs String : This value may be null . |||
sortOrder String : This value may be null . |||
cancellationSignal CancellationSignal : This value may be null . |||",Cursor This value may be null . |||,16,"Content providers are one of the primary building blocks of Android applications providing
 content to applications. They encapsulate data and provide it to applications through the single
  ContentResolver  interface. A content provider is only required if you need to share
 data between multiple applications. For example the contacts data is used by multiple
 applications and must be stored in a content provider. If you don't need to share data amongst
 multiple applications you can use a database directly via
  SQLiteDatabase .

  When a request is made via
 a  ContentResolver  the system inspects the authority of the given URI and passes the
 request to the content provider registered with the authority. The content provider can interpret
 the rest of the URI however it wants. The  UriMatcher  class is helpful for parsing
 URIs. The primary methods that need to be implemented are:
  onCreate()  which is called to initialize the provider query(Uri String[] Bundle CancellationSignal)  which returns data to the caller insert(Uri ContentValues)  which inserts new data into the content provider update(Uri ContentValues String String[])  which updates existing data in the content provider delete(Uri String String[])  which deletes data from the content provider getType(Uri)  which returns the MIME type of data in the content provider Requests to  ContentResolver  are automatically forwarded to the appropriate
 ContentProvider instance so subclasses don't have to worry about the details of
 cross-process calls.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",database data,database,1,yes,no,SOURCE,no,
<android.os.Bundle: short getShortArray(String)>,"Returns the value associated with the given key or null if
 no mapping of the desired type exists for the given key or a null
 value is explicitly associated with the key.","key String : a String or null
This value may be null . |||",short[] a short[] value or null |||,1,A mapping from String keys to various  Parcelable  values.,,IPC,no,0,no,no,no,no,
<android.media.RingtoneManager: Ringtone getRingtone(int)>,Gets a Ringtone for the ringtone at the given position in the Cursor .,position int : The position (in the Cursor ) of the ringtone. |||,Ringtone A Ringtone pointing to the ringtone. |||,1,"RingtoneManager provides access to ringtones notification and other types
 of sounds. It manages querying the different media providers and combines the
 results into a single cursor. It also provides a  Ringtone  for each
 ringtone. We generically call these sounds ringtones however the
  TYPE_RINGTONE  refers to the type of sounds that are suitable for the
 phone ringer.
  
 To show a ringtone picker to the user use the
  ACTION_RINGTONE_PICKER  intent to launch the picker as a subactivity.","The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",no,no,0,no,no,no,no,
<android.view.View: void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo)>,"Initializes an AccessibilityNodeInfo with information about this view.
 The base implementation sets: AccessibilityNodeInfo#setParent(View)  
AccessibilityNodeInfo#setBoundsInParent(Rect)  
AccessibilityNodeInfo#setBoundsInScreen(Rect)  
AccessibilityNodeInfo#setPackageName(CharSequence)  
AccessibilityNodeInfo#setClassName(CharSequence)  
AccessibilityNodeInfo#setContentDescription(CharSequence)  
AccessibilityNodeInfo#setEnabled(boolean)  
AccessibilityNodeInfo#setClickable(boolean)  
AccessibilityNodeInfo#setFocusable(boolean)  
AccessibilityNodeInfo#setFocused(boolean)  
AccessibilityNodeInfo#setLongClickable(boolean)  
AccessibilityNodeInfo#setSelected(boolean)  
AccessibilityNodeInfo#setContextClickable(boolean) 
Subclasses should override this method call the super implementation
 and set additional attributes. If an AccessibilityDelegate has been specified via calling setAccessibilityDelegate(android.view.View.AccessibilityDelegate) its AccessibilityDelegate#onInitializeAccessibilityNodeInfo(View AccessibilityNodeInfo) is responsible for handling this call.",info AccessibilityNodeInfo : The instance to initialize. |||,void,14,"This class represents the basic building block for user interface components. A View
 occupies a rectangular area on the screen and is responsible for drawing and
 event handling. View is the base class for  widgets  which are
 used to create interactive UI components (buttons text fields etc.). The
  ViewGroup  subclass is the base class for  layouts  which
 are invisible containers that hold other Views (or other ViewGroups) and define
 their layout properties.",,no,no,0,no,no,no,no,
<android.widget.Toast: void show()>,Show the view for the specified duration.,,void,1,"A toast is a view containing a quick little message for the user.  The toast class
 helps you create and show those.
  
 When the view is shown to the user appears as a floating view over the
 application.  It will never receive focus.  The user will probably be in the
 middle of typing something else.  The idea is to be as unobtrusive as
 possible while still showing the user the information you want them to see.
 Two examples are the volume control and the brief message saying that your
 settings have been saved.
  
 The easiest way to use this class is to call one of the static methods that constructs
 everything you need and returns a new Toast object.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,no,0,no,no,no,no,
<android.view.ViewGroup: void clearFocus()>,"Called when this view wants to give up focus. If focus is cleared onFocusChanged(boolean int android.graphics.Rect) is called. Note: When not in touch-mode the framework will try to give focus
 to the first focusable View from the top after focus is cleared. Hence if this
 View is the first from the top that can take focus then all callbacks
 related to clearing focus will be invoked after which the framework will
 give focus to this view.",,void,1,"A  ViewGroup  is a special view that can contain other views
 (called children.) The view group is the base class for layouts and views
 containers. This class also defines the
  ViewGroup.LayoutParams  class which serves as the base
 class for layouts parameters.
  
 Also see  LayoutParams  for layout attributes.",,no,no,0,no,no,no,no,
<android.widget.EditText: void extendSelection(int)>,Convenience for Selection#extendSelection .,index int |||,void,1,"A user interface element for entering and modifying text.
 When you define an edit text widget you must specify the
  R.styleable.TextView_inputType 
 attribute. For example for plain text input set inputType to ""text"":
  
 <EditText
     android:id=""@+id/plain_text_input""
     android:layout_height=""wrap_content""
     android:layout_width=""match_parent""
     android:inputType=""text""/> 
 See the  Text Fields 
 guide for examples of other
  R.styleable.TextView_inputType  settings.
  You also can receive callbacks as a user changes text by
 adding a  TextWatcher  to the edit text.
 This is useful when you want to add auto-save functionality as changes are made
 or validate the format of user input for example.
 You add a text watcher using the  TextView#addTextChangedListener  method.
  
 This widget does not support auto-sizing text.
  XML attributes 
 See  EditText Attributes 
  TextView Attributes 
  View Attributes","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,no,0,no,no,no,no,
<android.widget.StackView: void showNext()>,Manually shows the next child.,,void,11,,"The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,no,0,no,no,no,no,
<android.net.sip.SipAudioCall: void answerCall(int)>,"Answers a call. The attempt will be timed out if the call is not
 established within timeout seconds and Listener#onError will be called.","timeout int : the timeout value in seconds. Default value (defined by
SIP protocol) is used if timeout is zero or negative. |||",void,9,"Handles an Internet audio call over SIP. You can instantiate this class with  SipManager 
 using  SipManager#makeAudioCall  and   SipManager#takeAudioCall .

  Note:  Using this class require the
    Manifest.permission.INTERNET  and
    Manifest.permission.USE_SIP  permissions. In addition  startAudio()  requires the
    Manifest.permission.RECORD_AUDIO 
    Manifest.permission.ACCESS_WIFI_STATE  and
    Manifest.permission.WAKE_LOCK  permissions; and  setSpeakerMode()  requires the
    Manifest.permission.MODIFY_AUDIO_SETTINGS  permission.",,no,no,0,no,no,no,no,not sure
<android.app.Instrumentation: Activity startActivitySync(Intent)>,"Start a new activity and wait for it to begin running before returning.
 In addition to being synchronous this method as some semantic
 differences from the standard Context#startActivity call: the
 activity component is resolved before talking with the activity manager
 (its class name is specified in the Intent that this method ultimately
 starts) and it does not allow you to start activities that run in a
 different process.  In addition if the given Intent resolves to
 multiple activities instead of displaying a dialog for the user to
 select an activity an exception will be thrown. The function returns as soon as the activity goes idle following the
 call to its Activity#onCreate .  Generally this means it has gone
 through the full initialization including Activity#onResume and
 drawn and displayed its initial window.",intent Intent : Description of the activity to start. |||,Activity |||,1,"Base class for implementing application instrumentation code.  When running
 with instrumentation turned on this class will be instantiated for you
 before any of the application code allowing you to monitor all of the
 interaction the system has with the application.  An Instrumentation
 implementation is described to the system through an AndroidManifest.xml's
 <instrumentation> tag.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",IPC,IPC,1,yes,no,SOURCE,no,
"<android.view.inputmethod.BaseInputConnection: CharSequence getTextAfterCursor(int,int)>","The default implementation returns the given amount of text from the
 current cursor position in the buffer.","length int : The expected length of the text. |||
flags int : Supplies additional options controlling how the text is
returned. May be either 0 or InputConnection.GET_TEXT_WITH_STYLES . |||","CharSequence the text after the cursor position; the length of the
 returned text might be less than n . |||",3,"Base class for implementors of the InputConnection interface taking care
 of most of the common behavior for providing a connection to an Editable.
 Implementors of this class will want to be sure to implement
  getEditable()  to provide access to their own editable object and
 to refer to the documentation in  InputConnection .",,uncategorized,UI,1,yes,no,no,no,
<android.widget.VideoView: void resume()>,,,void,8,"Displays a video file.  The VideoView class
 can load images from various sources (such as resources or content
 providers) takes care of computing its measurement from the video so that
 it can be used in any layout manager and provides various display options
 such as scaling and tinting. Note: VideoView does not retain its full state when going into the
 background.   In particular it does not restore the current play state
 play position selected tracks or any subtitle tracks added via
  addSubtitleSource() .  Applications should
 save and restore these on their own in
  Activity.onSaveInstanceState(Bundle)  and
  Activity.onRestoreInstanceState(Bundle) . 
 Also note that the audio session id (from  getAudioSessionId() ) may
 change from its previously returned value when the VideoView is restored.
  
 By default VideoView requests audio focus with  AudioManager#AUDIOFOCUS_GAIN . Use
  setAudioFocusRequest(int)  to change this behavior.
  
 The default  AudioAttributes  used during playback have a usage of
  AudioAttributes#USAGE_MEDIA  and a content type of
  AudioAttributes#CONTENT_TYPE_MOVIE  use  setAudioAttributes(android.media.AudioAttributes)  to
 modify them.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,no,0,no,no,no,no,
<android.telephony.TelephonyManager: String getDeviceSoftwareVersion()>,"Returns the software version number for the device for example
 the IMEI/SV for GSM phones. Return null if the software version is
 not available. Requires Permission: READ_PHONE_STATE . Requires Manifest.permission.READ_PHONE_STATE",,String |||,1,"Provides access to information about the telephony services on
 the device. Applications can use the methods in this class to
 determine telephony services and states as well as to access some
 types of subscriber information. Applications can also register
 a listener to receive notification of telephony state changes.
  
 The returned TelephonyManager will use the default subscription for all calls.
 To call an API for a specific subscription use  createForSubscriptionId(int) . e.g.
  
   telephonyManager = defaultSubTelephonyManager.createForSubscriptionId(subId);
  
 Note that access to some telephony information is
 permission-protected. Your application cannot access the protected
 information unless it has the appropriate permissions declared in
 its manifest file. Where permissions apply they are noted in the
 the methods through which you access the protected information.",,system metadata,system,1,yes,no,SOURCE,no,
<android.os.Bundle: ArrayList getStringArrayList(String)>,"Returns the value associated with the given key or null if
 no mapping of the desired type exists for the given key or a null
 value is explicitly associated with the key.","key String : a String or null
This value may be null . |||",ArrayList < String > an ArrayList value or null |||,1,A mapping from String keys to various  Parcelable  values.,,IPC,no,0,no,no,no,no,
<android.content.res.Resources: InputStream openRawResource(int)>,"Open a data stream for reading a raw resource.  This can only be used
 with resources whose value is the name of an asset files -- that is it can be
 used to open drawable sound and raw resources; it will fail on string
 and color resources.",id int : The resource identifier to open as generated by the aapt tool. |||,"InputStream InputStream Access to the resource data.

 This value will never be null . |||",1,"Class for accessing an application's resources.  This sits on top of the
 asset manager of the application (accessible through  getAssets() ) and
 provides a high-level API for getting typed data from the assets.

  The Android resource system keeps track of all non-code assets associated with an
 application. You can use this class to access your application's resources. You can generally
 acquire the  Resources  instance associated with your application
 with  getResources() . The Android SDK tools compile your application's resources into the application binary
 at build time.  To use a resource you must install it correctly in the source tree (inside
 your project's  res/  directory) and build your application.  As part of the build
 process the SDK tools generate symbols for each resource which you can use in your application
 code to access the resources. Using application resources makes it easy to update various characteristics of your
 application without modifying code and—by providing sets of alternative
 resources—enables you to optimize your application for a variety of device configurations
 (such as for different languages and screen sizes). This is an important aspect of developing
 Android applications that are compatible on different types of devices. For more information about using resources see the documentation about  Application Resources .","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,
<android.widget.SlidingDrawer: void animateClose()>,Closes the drawer with an animation.,,void,3,"SlidingDrawer hides content out of the screen and allows the user to drag a handle
 to bring the content on screen. SlidingDrawer can be used vertically or horizontally.

 A special widget composed of two children views: the handle that the users drags
 and the content attached to the handle and dragged with it.

 SlidingDrawer should be used as an overlay inside layouts. This means SlidingDrawer
 should only be used inside of a FrameLayout or a RelativeLayout for instance. The
 size of the SlidingDrawer defines how much space the content will occupy once slid
 out so SlidingDrawer should usually use match_parent for both its dimensions.

 Inside an XML layout SlidingDrawer must define the id of the handle and of the
 content:

  
 <SlidingDrawer
     android:id=""@+id/drawer""
     android:layout_width=""match_parent""
     android:layout_height=""match_parent""

     android:handle=""@+id/handle""
     android:content=""@+id/content"">

     <ImageView
         android:id=""@id/handle""
         android:layout_width=""88dip""
         android:layout_height=""44dip"" />

     <GridView
         android:id=""@id/content""
         android:layout_width=""match_parent""
         android:layout_height=""match_parent"" />

 </SlidingDrawer>","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,no,0,no,no,no,no,
"<android.speech.SpeechRecognizer: SpeechRecognizer createSpeechRecognizer(Context,ComponentName)>","Factory method to create a new SpeechRecognizer . Please note that setRecognitionListener(android.speech.RecognitionListener) should be called before dispatching any
 command to the created SpeechRecognizer otherwise no notifications will be
 received.

 Use this version of the method to specify a specific service to direct this SpeechRecognizer to. Normally you would not use this; use createSpeechRecognizer(android.content.Context) instead to use the system default recognition
 service.","context Context : in which to create SpeechRecognizer |||
serviceComponent ComponentName : the ComponentName of a specific service to direct this SpeechRecognizer to |||",SpeechRecognizer a new SpeechRecognizer |||,8,"This class provides access to the speech recognition service. This service allows access to the
 speech recognizer. Do not instantiate this class directly instead call
  SpeechRecognizer#createSpeechRecognizer(Context) . This class's methods must be
 invoked only from the main application thread.

  The implementation of this API is likely to stream audio to remote servers to perform speech
 recognition. As such this API is not intended to be used for continuous recognition which would
 consume a significant amount of battery and bandwidth.

  Please note that the application must have  Manifest.permission.RECORD_AUDIO 
 permission to use this class.",,no,no,0,no,no,no,no,
<android.content.Intent: double getDoubleArrayExtra(String)>,Retrieve extended data from the intent.,name String : The name of the desired item. |||,"double[] the value of an item previously added with putExtra()
 or null if no double array value was found. |||",1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",IPC,no,0,no,no,no,no,
<android.bluetooth.BluetoothHeadset: int getConnectionState(BluetoothDevice)>,Get the current connection state of the profile Requires Manifest.permission.BLUETOOTH,device BluetoothDevice : Remote bluetooth device. |||,int State of the profile connection. One of STATE_CONNECTED  STATE_CONNECTING  STATE_DISCONNECTED  STATE_DISCONNECTING Value is STATE_DISCONNECTED  STATE_CONNECTING  STATE_CONNECTED or STATE_DISCONNECTING |||,11,"Public API for controlling the Bluetooth Headset Service. This includes both
 Bluetooth Headset and Handsfree (v1.5) profiles.

  BluetoothHeadset is a proxy object for controlling the Bluetooth Headset
 Service via IPC.

   Use  BluetoothAdapter#getProfileProxy  to get
 the BluetoothHeadset proxy object. Use
  BluetoothAdapter#closeProfileProxy  to close the service connection.

   Android only supports one connected Bluetooth Headset at a time.
 Each method is protected with its appropriate permission.","Provides classes that manage Bluetooth functionality such as scanning for
 devices connecting with devices and managing data transfer between devices.
 The Bluetooth API supports both ""Classic Bluetooth"" and Bluetooth Low Energy. For more information about Classic Bluetooth see the
  Bluetooth  guide.
 For more information about Bluetooth Low Energy see the
  
 Bluetooth Low Energy  (BLE) guide. The Bluetooth APIs let applications: Scan for other Bluetooth devices (including BLE devices). Query the local Bluetooth adapter for paired Bluetooth devices. Establish RFCOMM channels/sockets. Connect to specified sockets on other devices. Transfer data to and from other devices. Communicate with BLE devices such as proximity sensors heart rate
     monitors fitness devices and so on. Act as a GATT client or a GATT server (BLE). 
 To perform Bluetooth communication using these APIs an application must
 declare the  BLUETOOTH  permission. Some
 additional functionality such as requesting device discovery
 also requires the  BLUETOOTH_ADMIN 
 permission.
  Note: 
 Not all Android-powered devices provide Bluetooth functionality.",bluetooth metadata,bluetooth,1,yes,no,SOURCE,no,
<android.nfc.tech.NfcB: void connect()>,"Enable I/O operations to the tag from this TagTechnology object. May cause RF activity and may block. Must not be called
 from the main application thread. A blocked call will be canceled with IOException by calling close() from another thread. Only one TagTechnology object can be connected to a Tag at a time. Applications must call close() when I/O operations are complete. Requires the Manifest.permission.NFC permission.",,void,-1,"Provides access to NFC-B (ISO 14443-3B) properties and I/O operations on a  Tag .

  Acquire a  NfcB  object using  get(Tag) .
  The primary NFC-B I/O operation is  transceive(byte[]) . Applications must
 implement their own protocol stack on top of  transceive(byte[]) .

  Note:  Methods that perform I/O operations
 require the  Manifest.permission.NFC  permission.","These classes provide access to a tag technology's features which vary by the type
 of tag that is scanned. A scanned tag can support multiple technologies and you can find
 out what they are by calling  getTechList() . For more information on dealing with tag technologies and handling the ones that you care about see
  The Tag Dispatch System .
 The  TagTechnology  interface provides an overview of the
 supported technologies.",no,no,0,no,no,no,no,
"<android.text.style.DynamicDrawableSpan: void draw(Canvas,CharSequence,int,int,float,int,int,int,Paint)>",Draws the span into the canvas.,"canvas Canvas : This value must never be null . |||
text CharSequence : Current text. |||
start int : Value is 0 or greater |||
end int : Value is 0 or greater |||
x float : Edge of the replacement closest to the leading margin. |||
top int : Top of the line. |||
y int : Baseline. |||
bottom int : Bottom of the line. |||
paint Paint : This value must never be null . |||",void,1,"Span that replaces the text it's attached to with a  Drawable  that can be aligned with
 the bottom or with the baseline of the surrounding text.
  
 For an implementation that constructs the drawable from various sources ( Bitmap 
  Drawable  resource id or  Uri ) use  ImageSpan .
  
 A simple implementation of  DynamicDrawableSpan  that uses drawables from resources
 looks like this:
  
 class MyDynamicDrawableSpan extends DynamicDrawableSpan {

 private final Context mContext;
 private final int mResourceId;

 public MyDynamicDrawableSpan(Context context @DrawableRes int resourceId) {
     mContext = context;
     mResourceId = resourceId;
 }

 @Override
 public Drawable getDrawable() {
      Drawable drawable = mContext.getDrawable(mResourceId);
      drawable.setBounds(0 0 drawable.getIntrinsicWidth() drawable.getIntrinsicHeight());
      return drawable;
 }
 } 
 SpannableString string = new SpannableString(""Text with a drawable span"");
 string.setSpan(new MyDynamicDrawableSpan(context R.mipmap.ic_launcher) 12 20 Spanned
 .SPAN_EXCLUSIVE_EXCLUSIVE); Replacing text with a drawable.","Provides classes used to view or change the style of a span of text in a View object.
 The classes with a subclass Standard are passed in to  SpannableString.setSpan()  or  SpannableStringBuilder.setSpan()  to add a new styled span to a string in a View object.",uncategorized,UI,1,no,yes,no,SINK,
<android.app.MediaRouteActionProvider: View onCreateActionView(MenuItem)>,"Factory method called by the Android framework to create new action views.
 This method returns a new action view for the given MenuItem. If your ActionProvider implementation overrides the deprecated no-argument overload onCreateActionView() overriding this method for devices running API 16 or later
 is recommended but optional. The default implementation calls onCreateActionView() for compatibility with applications written for older platform versions.",item MenuItem : MenuItem to create the action view for |||,View the new action view |||,16,"The media route action provider displays a  MediaRouteButton 
 in the application's  ActionBar  to allow the user to select routes and
 to control the currently selected route.
  
 The application must specify the kinds of routes that the user should be allowed
 to select by specifying the route types with the  setRouteTypes(int)  method.
  
 Refer to  MediaRouteButton  for a description of the button that will
 appear in the action bar menu.  Note that instead of disabling the button
 when no routes are available the action provider will instead make the
 menu item invisible.  In this way the button will only be visible when it
 is possible for the user to discover and select a matching route.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",uncategorized,UI,1,yes,no,no,no,
<android.widget.ProgressBar: Parcelable onSaveInstanceState()>,"Hook allowing a view to generate a representation of its internal state
 that can later be used to create a new instance with that same state.
 This state should only contain information that is not persistent or can
 not be reconstructed later. For example you will never store your
 current position on screen because that will be computed again when a
 new instance of the view is placed in its view hierarchy. Some examples of things you may store here: the current cursor position
 in a text view (but usually not the text itself since that is stored in a
 content provider or other persistent storage) the currently selected
 item in a list view. If you override this method you must call through to the
 superclass implementation.",,"Parcelable Returns a Parcelable object containing the view's current dynamic
         state or null if there is nothing interesting to save. |||",1,"A user interface element that indicates the progress of an operation.
 Progress bar supports two modes to represent progress: determinate and indeterminate. For
 a visual overview of the difference between determinate and indeterminate progress modes see
  
 Progress & activity .
 Display progress bars to a user in a non-interruptive way.
 Show the progress bar in your app's user interface or in a notification
 instead of within a dialog.
  Indeterminate Progress 
 Use indeterminate mode for the progress bar when you do not know how long an
 operation will take.
 Indeterminate mode is the default for progress bar and shows a cyclic animation without a
 specific amount of progress indicated.
 The following example shows an indeterminate progress bar:
  
 <ProgressBar
      android:id=""@+id/indeterminateBar""
      android:layout_width=""wrap_content""
      android:layout_height=""wrap_content""
      />
  Determinate Progress 
 Use determinate mode for the progress bar when you want to show that a specific quantity of
 progress has occurred.
 For example the percent remaining of a file being retrieved the amount records in
 a batch written to database or the percent remaining of an audio file that is playing.
  
 To indicate determinate progress you set the style of the progress bar to
  R.style.Widget_ProgressBar_Horizontal  and set the amount of progress.
 The following example shows a determinate progress bar that is 25% complete:
  
 <ProgressBar
      android:id=""@+id/determinateBar""
      style=""@android:style/Widget.ProgressBar.Horizontal""
      android:layout_width=""wrap_content""
      android:layout_height=""wrap_content""
      android:progress=""25""/>
  setProgress(int) incrementProgressBy(int) android:max Other progress bar styles provided by the system include: Widget.ProgressBar.Horizontal Widget.ProgressBar.Small Widget.ProgressBar.Large Widget.ProgressBar.Inverse Widget.ProgressBar.Small.Inverse Widget.ProgressBar.Large.Inverse The ""inverse"" styles provide an inverse color scheme for the spinner which may be necessary
 if your application uses a light colored theme (a white background). XML attributes 
 See  ProgressBar Attributes 
  View Attributes","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,callback,0,no,no,no,no,
<android.app.Instrumentation: void callApplicationOnCreate(Application)>,"Perform calling of the application's Application#onCreate method.  The default implementation simply calls through to that method. Note: This method will be called immediately after onCreate(android.os.Bundle) .
 Often instrumentation tests start their test thread in onCreate(); you
 need to be careful of races between these.  (Well between it and
 everything else but let's start here.)",app Application : The application being created. |||,void,1,"Base class for implementing application instrumentation code.  When running
 with instrumentation turned on this class will be instantiated for you
 before any of the application code allowing you to monitor all of the
 interaction the system has with the application.  An Instrumentation
 implementation is described to the system through an AndroidManifest.xml's
 <instrumentation> tag.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
<android.view.View: void createContextMenu(ContextMenu)>,"Show the context menu for th is view. It is not safe to hold on to the
 menu after returning from this method.

 You should normally not overload this method. Overload onCreateContextMenu(android.view.ContextMenu) or define an OnCreateContextMenuListener to add items to the context menu.",menu ContextMenu : The context menu to populate |||,void,1,"This class represents the basic building block for user interface components. A View
 occupies a rectangular area on the screen and is responsible for drawing and
 event handling. View is the base class for  widgets  which are
 used to create interactive UI components (buttons text fields etc.). The
  ViewGroup  subclass is the base class for  layouts  which
 are invisible containers that hold other Views (or other ViewGroups) and define
 their layout properties.",,no,no,0,no,on,no,no,
<android.bluetooth.BluetoothA2dp: void finalize()>,"Called by the garbage collector on an object when garbage collection
 determines that there are no more references to the object.
 A subclass overrides the finalize method to dispose of
 system resources or to perform other cleanup. The general contract of finalize is that it is invoked
 if and when the Java™ virtual
 machine has determined that there is no longer any
 means by which this object can be accessed by any thread that has
 not yet died except as a result of an action taken by the
 finalization of some other object or class which is ready to be
 finalized. The finalize method may take any action including
 making this object available again to other threads; the usual purpose
 of finalize however is to perform cleanup actions before
 the object is irrevocably discarded. For example the finalize method
 for an object that represents an input/output connection might perform
 explicit I/O transactions to break the connection before the object is
 permanently discarded. The finalize method of class Object performs no
 special action; it simply returns normally. Subclasses of Object may override this definition. The Java programming language does not guarantee which thread will
 invoke the finalize method for any given object. It is
 guaranteed however that the thread that invokes finalize will not
 be holding any user-visible synchronization locks when finalize is
 invoked. If an uncaught exception is thrown by the finalize method
 the exception is ignored and finalization of that object terminates. After the finalize method has been invoked for an object no
 further action is taken until the Java virtual machine has again
 determined that there is no longer any means by which this object can
 be accessed by any thread that has not yet died including possible
 actions by other objects or classes which are ready to be finalized
 at which point the object may be discarded. The finalize method is never invoked more than once by a Java
 virtual machine for any given object. Any exception thrown by the finalize method causes
 the finalization of this object to be halted but is otherwise
 ignored.",,void,11,"This class provides the public APIs to control the Bluetooth A2DP
 profile.

  BluetoothA2dp is a proxy object for controlling the Bluetooth A2DP
 Service via IPC. Use  BluetoothAdapter#getProfileProxy  to get
 the BluetoothA2dp proxy object.

   Android only supports one connected Bluetooth A2dp device at a time.
 Each method is protected with its appropriate permission.","Provides classes that manage Bluetooth functionality such as scanning for
 devices connecting with devices and managing data transfer between devices.
 The Bluetooth API supports both ""Classic Bluetooth"" and Bluetooth Low Energy. For more information about Classic Bluetooth see the
  Bluetooth  guide.
 For more information about Bluetooth Low Energy see the
  
 Bluetooth Low Energy  (BLE) guide. The Bluetooth APIs let applications: Scan for other Bluetooth devices (including BLE devices). Query the local Bluetooth adapter for paired Bluetooth devices. Establish RFCOMM channels/sockets. Connect to specified sockets on other devices. Transfer data to and from other devices. Communicate with BLE devices such as proximity sensors heart rate
     monitors fitness devices and so on. Act as a GATT client or a GATT server (BLE). 
 To perform Bluetooth communication using these APIs an application must
 declare the  BLUETOOTH  permission. Some
 additional functionality such as requesting device discovery
 also requires the  BLUETOOTH_ADMIN 
 permission.
  Note: 
 Not all Android-powered devices provide Bluetooth functionality.",no,no,0,no,no,no,no,
"<android.preference.PreferenceActivity: void startPreferencePanel(String,Bundle,int,CharSequence,Fragment,int)>","Start a new fragment containing a preference panel.  If the preferences
 are being displayed in multi-pane mode the given fragment class will
 be instantiated and placed in the appropriate pane.  If running in
 single-pane mode a new activity will be launched in which to show the
 fragment.","fragmentClass String : Full name of the class implementing the fragment. |||
args Bundle : Any desired arguments to supply to the fragment. |||
titleRes int : Optional resource identifier of the title of this
fragment. |||
titleText CharSequence : Optional text of the title of this fragment. |||
resultTo Fragment : Optional fragment that result data should be sent to.
If non-null resultTo.onActivityResult() will be called when this
preference panel is done.  The launched panel must use finishPreferencePanel(android.app.Fragment int android.content.Intent) when done. |||
resultRequestCode int : If resultTo is non-null this is the caller's
request code to be received with the result. |||",void,11,"This is the base class for an activity to show a hierarchy of preferences
 to the user.  Prior to  Build.VERSION_CODES.HONEYCOMB 
 this class only allowed the display of a single set of preference; this
 functionality should now be found in the new  PreferenceFragment 
 class.  If you are using PreferenceActivity in its old mode the documentation
 there applies to the deprecated APIs here.

  This activity shows one or more headers of preferences each of which
 is associated with a  PreferenceFragment  to display the preferences
 of that header.  The actual layout and display of these associations can
 however vary; currently there are two major approaches it may take:

  On a small screen it may display only the headers as a single list when first launched.
 Selecting one of the header items will only show the PreferenceFragment of that header (on
 Android N and lower a new Activity is launched).
  On a large screen it may display both the headers and current PreferenceFragment together as
 panes. Selecting a header item switches to showing the correct PreferenceFragment for that item.
  Subclasses of PreferenceActivity should implement
  onBuildHeaders(List )  to populate the header list with the desired
 items.  Doing this implicitly switches the class into its new ""headers
 + fragments"" mode rather than the old style of just showing a single
 preferences list.",,no,no,0,no,no,no,no,
"<android.content.ContextWrapper: void sendBroadcast(Intent,String)>","Broadcast the given intent to all interested BroadcastReceivers allowing
 an optional required permission to be enforced.  This
 call is asynchronous; it returns immediately and you will continue
 executing while the receivers are run.  No results are propagated from
 receivers and receivers can not abort the broadcast. If you want
 to allow receivers to propagate results or abort the broadcast you must
 send an ordered broadcast using sendOrderedBroadcast(android.content.Intent java.lang.String) . See BroadcastReceiver for more information on Intent broadcasts.","intent Intent : The Intent to broadcast; all receivers matching this
Intent will receive the broadcast. |||
receiverPermission String : (optional) String naming a permission that
a receiver must hold in order to receive your broadcast.
If null no permission is required.
This value may be null . |||",void,1,"Proxying implementation of Context that simply delegates all of its calls to
 another Context.  Can be subclassed to modify behavior without changing
 the original Context.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",IPC,IPC,1,no,yes,no,SINK,
"<android.widget.AdapterViewAnimator: void setInAnimation(Context,int)>",Specifies the animation used to animate a View that enters the screen.,"context Context : The application's environment. |||
resourceID int : The resource id of the animation. |||",void,11,"An AdapterView is a view whose children are determined by an  Adapter .

  
 See  ListView   GridView   Spinner  and
       Gallery  for commonly used subclasses of AdapterView.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,UI,0,no,no,no,no,
"<android.animation.LayoutTransition: void hideChild(ViewGroup,View)>","This method was deprecated
      in API level 16. Use hideChild(android.view.ViewGroup android.view.View int) .","parent ViewGroup |||
child View |||",void,11,"This class enables automatic animations on layout changes in ViewGroup objects. To enable
 transitions for a layout container create a LayoutTransition object and set it on any
 ViewGroup by calling  ViewGroup#setLayoutTransition(LayoutTransition) . This will cause
 default animations to run whenever items are added to or removed from that container. To specify
 custom animations use the  LayoutTransition#setAnimator(int Animator)  method.

  One of the core concepts of these transition animations is that there are two types of
 changes that cause the transition and four different animations that run because of
 those changes. The changes that trigger the transition are items being added to a container
 (referred to as an ""appearing"" transition) or removed from a container (also known as
 ""disappearing""). Setting the visibility of views (between GONE and VISIBLE) will trigger
 the same add/remove logic. The animations that run due to those events are one that animates
 items being added one that animates items being removed and two that animate the other
 items in the container that change due to the add/remove occurrence. Users of
 the transition may want different animations for the changing items depending on whether
 they are changing due to an appearing or disappearing event so there is one animation for
 each of these variations of the changing event. Most of the API of this class is concerned
 with setting up the basic properties of the animations used in these four situations
 or with setting up custom animations for any or all of the four. By default the DISAPPEARING animation begins immediately as does the CHANGE_APPEARING
 animation. The other animations begin after a delay that is set to the default duration
 of the animations. This behavior facilitates a sequence of animations in transitions as
 follows: when an item is being added to a layout the other children of that container will
 move first (thus creating space for the new item) then the appearing animation will run to
 animate the item being added. Conversely when an item is removed from a container the
 animation to remove it will run first then the animations of the other children in the
 layout will run (closing the gap created in the layout when the item was removed). If this
 default choreography behavior is not desired the  setDuration(int long)  and
  setStartDelay(int long)  of any or all of the animations can be changed as
 appropriate. Keep in mind however that if you start an APPEARING animation before a
 DISAPPEARING animation is completed the DISAPPEARING animation stops and any effects from
 the DISAPPEARING animation are reverted. If you instead start a DISAPPEARING animation
 before an APPEARING animation is completed a similar set of effects occurs for the
 APPEARING animation. The animations specified for the transition both the defaults and any custom animations
 set on the transition object are templates only. That is these animations exist to hold the
 basic animation properties such as the duration start delay and properties being animated.
 But the actual target object as well as the start and end values for those properties are
 set automatically in the process of setting up the transition each time it runs. Each of the
 animations is cloned from the original copy and the clone is then populated with the dynamic
 values of the target being animated (such as one of the items in a layout container that is
 moving as a result of the layout event) as well as the values that are changing (such as the
 position and size of that object). The actual values that are pushed to each animation
 depends on what properties are specified for the animation. For example the default
 CHANGE_APPEARING animation animates the  left   top   right 
  bottom   scrollX  and  scrollY  properties.
 Values for these properties are updated with the pre- and post-layout
 values when the transition begins. Custom animations will be similarly populated with
 the target and values being animated assuming they use ObjectAnimator objects with
 property names that are known on the target object. This class and the associated XML flag for containers animateLayoutChanges=""true""
 provides a simple utility meant for automating changes in straightforward situations.
 Using LayoutTransition at multiple levels of a nested view hierarchy may not work due to the
 interrelationship of the various levels of layout. Also a container that is being scrolled
 at the same time as items are being added or removed is probably not a good candidate for
 this utility because the before/after locations calculated by LayoutTransition
 may not match the actual locations when the animations finish due to the container
 being scrolled as the animations are running. You can work around that
 particular issue by disabling the 'changing' animations by setting the CHANGE_APPEARING
 and CHANGE_DISAPPEARING animations to null and setting the startDelay of the
 other animations appropriately.","These classes provide functionality for the property animation system which allows you
 to animate object properties of any type.  int   float  and hexadecimal
 color values are supported by default. You can animate any other type by telling the system how
 to calculate the values for that given type with a custom  TypeEvaluator .
  For more information see the
  Animation  guide. 
 You can set many different types of interpolators (contained in  android.view.animation )
 specify  keyframes  or group animations to play sequentially
 or simultaneously (with  AnimatorSet ) to further control your animation
 behaviors.",no,no,0,no,no,no,no,
<android.nfc.NfcAdapter: void disableForegroundNdefPush(Activity)>,"This method was deprecated
      in API level 15. use setNdefPushMessage(NdefMessage Activity Activity...) instead Disable NDEF message push over P2P. After calling enableForegroundNdefPush(Activity NdefMessage) an activity
 must call this method before its Activity#onPause callback
 completes. Strongly recommend to use the new setNdefPushMessage(NdefMessage Activity Activity...) instead: it automatically hooks into your activity life-cycle
 so you do not need to call enable/disable in your onResume/onPause. This method must be called from the main thread. Requires the Manifest.permission.NFC permission.",activity Activity : the Foreground activity |||,void,10,"Represents the local NFC adapter.
  
 Use the helper  getDefaultAdapter(android.content.Context)  to get the default NFC
 adapter for this Android device.","Provides access to Near Field Communication (NFC) functionality allowing applications to read
 NDEF message in NFC tags. A ""tag"" may actually be another device that appears as a tag. For more information see the
  Near Field Communication  guide. Here's a summary of the classes: NfcManager This is the high level manager used to obtain this device's  NfcAdapter . You can
 acquire an instance using  getSystemService(Class ) . NfcAdapter This represents the device's NFC adapter which is your entry-point to performing NFC
 operations. You can acquire an instance with  getDefaultAdapter()  or
  getDefaultAdapter(android.content.Context) . NdefMessage Represents an NDEF data message which is the standard format in which ""records""
 carrying data are transmitted between devices and tags. Your application can receive these
 messages from an  ACTION_TAG_DISCOVERED  intent. NdefRecord Represents a record which is delivered in a  NdefMessage  and describes the
 type of data being shared and carries the data itself. Note: 
 Not all Android-powered devices provide NFC functionality.",no,no,0,no,no,no,no,
"<android.app.Activity: void setFeatureDrawable(int,Drawable)>",Convenience for calling Window.setFeatureDrawable(int Drawable) .,"featureId int |||
drawable Drawable |||",void,1,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
<android.widget.TextView: void setTextKeepState(CharSequence)>,"Sets the text to be displayed but retains the cursor position. Same as setText(java.lang.CharSequence) except that the cursor position (if any) is retained in the
 new text.",text CharSequence : text to be displayed |||,void,1,"A user interface element that displays text to the user.
 To provide user-editable text see  EditText .
  
 The following code sample shows a typical use with an XML layout
 and code to modify the contents of the text view:
  
 <LinearLayout
      xmlns:android=""http://schemas.android.com/apk/res/android""
      android:layout_width=""match_parent""
      android:layout_height=""match_parent"">
    <TextView
        android:id=""@+id/text_view_id""
        android:layout_height=""wrap_content""
        android:layout_width=""wrap_content""
        android:text=""@string/hello"" />
 </LinearLayout>
  
 This code sample demonstrates how to modify the contents of the text view
 defined in the previous XML layout:
  
 public class MainActivity extends Activity {

    protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_main);
         final TextView helloTextView = (TextView) findViewById(R.id.text_view_id);
         helloTextView.setText(R.string.user_greeting);
     }
 }
  
 To customize the appearance of TextView see  Styles and Themes .
  XML attributes 
 See  TextView Attributes 
  View Attributes","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",uncategorized,yes,1,no,yes,no,SINK,
<android.widget.Toast: void cancel()>,"Close the view if it's showing or don't show it if it isn't showing yet.
 You do not normally have to call this.  Normally view will disappear on its own
 after the appropriate duration.",,void,1,"A toast is a view containing a quick little message for the user.  The toast class
 helps you create and show those.
  
 When the view is shown to the user appears as a floating view over the
 application.  It will never receive focus.  The user will probably be in the
 middle of typing something else.  The idea is to be as unobtrusive as
 possible while still showing the user the information you want them to see.
 Two examples are the volume control and the brief message saying that your
 settings have been saved.
  
 The easiest way to use this class is to call one of the static methods that constructs
 everything you need and returns a new Toast object.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,no,0,no,no,no,no,
<android.telephony.gsm.SmsManager: ArrayList divideMessage(String)>,"This method was deprecated
      in API level 4. Use android.telephony.SmsManager. Divide a text message into several messages none bigger than
 the maximum SMS message size.",text String : the original message.  Must not be null. |||,"ArrayList < String > an ArrayList of strings that in order
   comprise the original message |||",1,"Manages SMS operations such as sending data text and pdu SMS messages.
 Get this object by calling the static method SmsManager.getDefault().",,sms message,no,0,no,no,no,no,
<android.location.LocationManager: LocationProvider getProvider(String)>,"Returns the information about the location provider with the given name or null if no
 provider exists by that name.",provider String : a provider listed by getAllProviders() This value must never be null . |||,LocationProvider location provider information or null if provider does not exist |||,1,"A data class representing a geographic location.

  A location can consist of a latitude longitude timestamp
 and other information such as bearing altitude and velocity.

  All locations generated by the  LocationManager  are
 guaranteed to have a valid latitude longitude and timestamp
 (both UTC time and elapsed real-time since boot) all other
 parameters are optional.","Contains the framework API classes that define Android location-based and
 	related services. This API is not the recommended method for accessing Android location. 
 The
  Google Location Services API 
 part of Google Play services is the preferred way to add location-awareness to
 your app. It offers a simpler API higher accuracy low-power geofencing and
 more. If you are currently using the android.location API you are strongly
 encouraged to switch to the Google Location Services API as soon as
 possible.
  
 To learn more about the Google Location Services API see the
  Location API overview .",no,location sensors,0,no,no,no,no,
"<android.content.ContentResolver: Object addStatusChangeListener(int,SyncStatusObserver)>","Request notifications when the different aspects of the SyncManager change. The
 different items that can be requested are: SYNC_OBSERVER_TYPE_PENDING 
SYNC_OBSERVER_TYPE_ACTIVE 
SYNC_OBSERVER_TYPE_SETTINGS","mask int : the status change types that will cause the callback to be invoked |||
callback SyncStatusObserver : observer to be invoked when the status changes |||",Object a handle that can be used to remove the listener at a later time |||,5,This class provides applications access to the content model.,"Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,not sure
<android.os.PowerManager: void reboot(String)>,Reboot the device.  Will not return if the reboot is successful. Requires the Manifest.permission.REBOOT permission.,"reason String : code to pass to the kernel (e.g. ""recovery"") to
request special boot modes or null.
This value may be null . |||",void,8,"This class gives you control of the power state of the device.

  Device battery life will be significantly affected by the use of this API. 
 Do not acquire  WakeLock s unless you really need them use the minimum levels
 possible and be sure to release them as soon as possible.
  
 The primary API you'll use is  newWakeLock() .
 This will create a  PowerManager.WakeLock  object.  You can then use methods
 on the wake lock object to control the power state of the device.
  
 In practice it's quite simple:
  PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE);
 PowerManager.WakeLock wl = pm.newWakeLock(PowerManager.SCREEN_DIM_WAKE_LOCK ""My Tag"");
 wl.acquire();
   ..screen will stay on during this section..
 wl.release();
  
 The following wake lock levels are defined with varying effects on system power.
  These levels are mutually exclusive - you may only specify one of them. Flag Value CPU Screen Keyboard PARTIAL_WAKE_LOCK On* Off Off SCREEN_DIM_WAKE_LOCK On Dim Off SCREEN_BRIGHT_WAKE_LOCK On Bright Off FULL_WAKE_LOCK On Bright Bright 
 * If you hold a partial wake lock the CPU will continue to run regardless of any
 display timeouts or the state of the screen and even after the user presses the power button.
 In all other wake locks the CPU will run but the user can still put the device to sleep
 using the power button. 
 In addition you can add two more flags which affect behavior of the screen only.
  These flags have no effect when combined with a  PARTIAL_WAKE_LOCK . Flag Value Description ACQUIRE_CAUSES_WAKEUP Normal wake locks don't actually turn on the illumination.  Instead they cause
         the illumination to remain on once it turns on (e.g. from user activity).  This flag
         will force the screen and/or keyboard to turn on immediately when the WakeLock is
         acquired.  A typical use would be for notifications which are important for the user to
         see immediately. ON_AFTER_RELEASE If this flag is set the user activity timer will be reset when the WakeLock is
         released causing the illumination to remain on a bit longer.  This can be used to
         reduce flicker if you are cycling between wake lock conditions. 
 Any application using a WakeLock must request the  android.permission.WAKE_LOCK 
 permission in an  <uses-permission>  element of the application's manifest.",,no,no,0,no,no,no,no,
<android.util.LruCache: void resize(int)>,Sets the size of the cache.,maxSize int : The new maximum size. |||,void,21,"A cache that holds strong references to a limited number of values. Each time
 a value is accessed it is moved to the head of a queue. When a value is
 added to a full cache the value at the end of that queue is evicted and may
 become eligible for garbage collection.

  If your cached values hold resources that need to be explicitly released
 override  entryRemoved(boolean K V V) .

  If a cache miss should be computed on demand for the corresponding keys
 override  create(K) . This simplifies the calling code allowing it to
 assume a value will always be returned even when there's a cache miss.

  By default the cache size is measured in the number of entries. Override
  sizeOf(K V)  to size the cache in different units. For example this cache
 is limited to 4MiB of bitmaps:
  int cacheSize = 4 * 1024 * 1024; // 4MiB
   LruCache<String Bitmap> bitmapCache = new LruCache<String Bitmap>(cacheSize) {
       protected int sizeOf(String key Bitmap value) {
           return value.getByteCount();
       }
   } This class is thread-safe. Perform multiple cache operations atomically by
 synchronizing on the cache:  synchronized (cache) {
     if (cache.get(key) == null) {
         cache.put(key value);
     }
   } This class does not allow null to be used as a key or value. A return
 value of null from  get(K)   put(K V)  or  remove(K)  is
 unambiguous: the key was not in the cache.

  This class appeared in Android 3.1 (Honeycomb MR1); it's available as part
 of  Android's
 Support Package  for earlier releases.",,no,no,0,no,no,no,no,
"<android.content.res.Resources: float getFraction(int,int,int)>",Retrieve a fractional unit for a particular resource ID.,"id int : The desired resource identifier as generated by the aapt
tool. This integer encodes the package type and resource
entry. The value 0 is an invalid identifier. |||
base int : The base value of this fraction.  In other words a
standard fraction is multiplied by this value. |||
pbase int : The parent base value of this fraction.  In other
words a parent fraction (nn%p) is multiplied by this
value. |||","float Attribute fractional value multiplied by the appropriate
 base value. |||",3,"Class for accessing an application's resources.  This sits on top of the
 asset manager of the application (accessible through  getAssets() ) and
 provides a high-level API for getting typed data from the assets.

  The Android resource system keeps track of all non-code assets associated with an
 application. You can use this class to access your application's resources. You can generally
 acquire the  Resources  instance associated with your application
 with  getResources() . The Android SDK tools compile your application's resources into the application binary
 at build time.  To use a resource you must install it correctly in the source tree (inside
 your project's  res/  directory) and build your application.  As part of the build
 process the SDK tools generate symbols for each resource which you can use in your application
 code to access the resources. Using application resources makes it easy to update various characteristics of your
 application without modifying code and—by providing sets of alternative
 resources—enables you to optimize your application for a variety of device configurations
 (such as for different languages and screen sizes). This is an important aspect of developing
 Android applications that are compatible on different types of devices. For more information about using resources see the documentation about  Application Resources .","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,
"<android.app.Activity: void startActivity(Intent,Bundle)>","Launch a new activity.  You will not receive any information about when
 the activity exits.  This implementation overrides the base version
 providing information about
 the activity performing the launch.  Because of this additional
 information the Intent#FLAG_ACTIVITY_NEW_TASK launch flag is not
 required; if not specified the new activity will be added to the
 task of the caller. This method throws ActivityNotFoundException if there was no Activity found to run the given Intent.","intent Intent : The intent to start. |||
options Bundle : Additional options for how the Activity should be started.
See Context.startActivity(Intent Bundle) Context.startActivity(Intent Bundle)} for more details.
This value may be null . |||",void,16,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",IPC,IPC,1,no,yes,no,SINK,
<android.app.Activity: void showDialog(int)>,"This method was deprecated
      in API level 15. Use the new DialogFragment class with FragmentManager instead; this is also
 available on older platforms through the Android compatibility package. Simple version of showDialog(int android.os.Bundle) that does not
 take any arguments.  Simply calls showDialog(int android.os.Bundle) with null arguments.",id int |||,void,1,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
"<android.app.TimePickerDialog: void onClick(DialogInterface,int)>",This method will be invoked when a button in the dialog is clicked.,"dialog DialogInterface : the dialog that received the click |||
which int : the button that was clicked (ex. DialogInterface#BUTTON_POSITIVE ) or the position
of the item clicked |||",void,1,"A dialog that prompts the user for the time of day using a
  TimePicker .

  
 See the  Pickers 
 guide.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
<android.service.wallpaper.WallpaperService: void onDestroy()>,"Called by the system to notify a Service that it is no longer used and is being removed.  The
 service should clean up any resources it holds (threads registered
 receivers etc) at this point.  Upon return there will be no more calls
 in to this Service object and it is effectively dead.  Do not call this method directly.",,void,7,"A wallpaper service is responsible for showing a live wallpaper behind
 applications that would like to sit on top of it.  This service object
 itself does very little -- its only purpose is to generate instances of
  Engine  as needed.  Implementing a wallpaper thus
 involves subclassing from this subclassing an Engine implementation
 and implementing  onCreateEngine()  to return a new instance of
 your engine.",,no,no,0,no,no,no,no,
"<android.content.ContextWrapper: int checkUriPermission(Uri,String,String,int,int,int)>","Check both a Uri and normal permission.  This allows you to perform
 both checkPermission(String int int) and checkUriPermission(Uri int int int) in one
 call.","uri Uri : The Uri whose permission is to be checked or null to not
do this check.
This value may be null . |||
readPermission String : The permission that provides overall read access
or null to not do this check.
This value may be null . |||
writePermission String : The permission that provides overall write
access or null to not do this check.
This value may be null . |||
pid int : The process ID being checked against.  Must be > 0. |||
uid int : The user ID being checked against.  A uid of 0 is the root
user which will pass every permission check. |||
modeFlags int : The access modes to check.
Value is either 0 or a combination of Intent.FLAG_GRANT_READ_URI_PERMISSION and Intent.FLAG_GRANT_WRITE_URI_PERMISSION |||","int PackageManager#PERMISSION_GRANTED if the caller
 is allowed to access that uri or holds one of the given permissions or PackageManager#PERMISSION_DENIED if it is not.
 
 Value is PackageManager.PERMISSION_GRANTED or PackageManager.PERMISSION_DENIED |||",1,"Proxying implementation of Context that simply delegates all of its calls to
 another Context.  Can be subclassed to modify behavior without changing
 the original Context.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,
"<android.content.Intent: ActivityInfo resolveActivityInfo(PackageManager,int)>","Resolve the Intent into an ActivityInfo describing the activity that should execute the intent.  Resolution
 follows the same rules as described for resolveActivity(PackageManager) but
 you get back the completely information about the resolved activity
 instead of just its class name.","pm PackageManager : The package manager with which to resolve the Intent.
This value must never be null . |||
flags int : Addition information to retrieve as per PackageManager#getActivityInfo(ComponentName int) .
Value is either 0 or a combination of PackageManager.GET_META_DATA  PackageManager.GET_SHARED_LIBRARY_FILES  PackageManager.MATCH_ALL android.content.pm.PackageManager.MATCH_DEBUG_TRIAGED_MISSING PackageManager.MATCH_DEFAULT_ONLY  PackageManager.MATCH_DISABLED_COMPONENTS  PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS  PackageManager.MATCH_DIRECT_BOOT_AUTO  PackageManager.MATCH_DIRECT_BOOT_AWARE  PackageManager.MATCH_DIRECT_BOOT_UNAWARE  PackageManager.MATCH_SYSTEM_ONLY  PackageManager.MATCH_UNINSTALLED_PACKAGES android.content.pm.PackageManager.MATCH_INSTANT android.content.pm.PackageManager.MATCH_STATIC_SHARED_LIBRARIES PackageManager.GET_DISABLED_COMPONENTS  PackageManager.GET_DISABLED_UNTIL_USED_COMPONENTS and PackageManager.GET_UNINSTALLED_PACKAGES |||",ActivityInfo PackageManager.ActivityInfo |||,1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",IPC,no,0,no,no,no,no,
"<android.content.ContentProviderOperation: void writeToParcel(Parcel,int)>",Flatten this object in to a Parcel.,"dest Parcel : The Parcel in which the object should be written. |||
flags int : Additional flags about how the object should be written.
May be 0 or Parcelable.PARCELABLE_WRITE_RETURN_VALUE .
Value is either 0 or a combination of Parcelable.PARCELABLE_WRITE_RETURN_VALUE and android.os.Parcelable.PARCELABLE_ELIDE_DUPLICATES |||",void,5,"Content providers are one of the primary building blocks of Android applications providing
 content to applications. They encapsulate data and provide it to applications through the single
  ContentResolver  interface. A content provider is only required if you need to share
 data between multiple applications. For example the contacts data is used by multiple
 applications and must be stored in a content provider. If you don't need to share data amongst
 multiple applications you can use a database directly via
  SQLiteDatabase .

  When a request is made via
 a  ContentResolver  the system inspects the authority of the given URI and passes the
 request to the content provider registered with the authority. The content provider can interpret
 the rest of the URI however it wants. The  UriMatcher  class is helpful for parsing
 URIs. The primary methods that need to be implemented are:
  onCreate()  which is called to initialize the provider query(Uri String[] Bundle CancellationSignal)  which returns data to the caller insert(Uri ContentValues)  which inserts new data into the content provider update(Uri ContentValues String String[])  which updates existing data in the content provider delete(Uri String String[])  which deletes data from the content provider getType(Uri)  which returns the MIME type of data in the content provider Requests to  ContentResolver  are automatically forwarded to the appropriate
 ContentProvider instance so subclasses don't have to worry about the details of
 cross-process calls.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",IPC,no,0,no,no,no,no,
<android.net.sip.SipSession: String getCallId()>,Gets the call ID of the session.,,String the call ID |||,9,"Represents a SIP session that is associated with a SIP dialog or a standalone
 transaction not within a dialog.
  You can get a  SipSession  from  SipManager  with  SipManager#createSipSession  (when initiating calls) or  SipManager#getSessionFor  (when receiving calls).",,phone metadata,phone,1,yes,no,SOURCE,no,
"<android.widget.ResourceCursorAdapter: View newDropDownView(Context,Cursor,ViewGroup)>",Makes a new drop down view to hold the data pointed to by cursor.,"context Context : Interface to application's global information |||
cursor Cursor : The cursor from which to get the data. The cursor is already
moved to the correct position. |||
parent ViewGroup : The parent to which the new view is attached to |||",View the newly created view. |||,1,"An easy adapter that creates views defined in an XML file. You can specify
 the XML file that defines the appearance of the views.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",uncategorized,UI,1,no,yes,no,SINK,
<android.net.wifi.WifiManager: int getWifiState()>,Gets the Wi-Fi enabled state.,,int One of WIFI_STATE_DISABLED  WIFI_STATE_DISABLING  WIFI_STATE_ENABLED  WIFI_STATE_ENABLING  WIFI_STATE_UNKNOWN |||,1,"This class provides the primary API for managing all aspects of Wi-Fi
 connectivity.
  
 On releases before  Build.VERSION_CODES.N  this object
 should only be obtained from an  Context#getApplicationContext()  and not from any other derived context to avoid memory
 leaks within the calling process.
  
 It deals with several categories of items:
  The list of configured networks. The list can be viewed and updated and
 attributes of individual entries can be modified. The currently active Wi-Fi network if any. Connectivity can be
 established or torn down and dynamic information about the state of the
 network can be queried. Results of access point scans containing enough information to make
 decisions about what access point to connect to. It defines the names of various Intent actions that are broadcast upon
 any sort of change in Wi-Fi state.
  
 This is the API to use when performing Wi-Fi specific operations. To perform
 operations that pertain to network connectivity at an abstract level use
  ConnectivityManager .","Provides classes to manage Wi-Fi functionality on the device. The Wi-Fi APIs provide a means by which applications can communicate
 with the lower-level wireless stack that provides Wi-Fi network access. Almost all
 information from the device supplicant is available including the connected network's
 link speed IP address negotiation state and more plus information about other
 networks that are available. Some other API features include the ability to
 scan add save terminate and initiate Wi-Fi connections. Some APIs may require the following user permissions: ACCESS_WIFI_STATE CHANGE_WIFI_STATE CHANGE_WIFI_MULTICAST_STATE Note:  Not all Android-powered devices provide Wi-Fi functionality.
 If your application uses Wi-Fi declare so with a  <uses-feature> 
 element in the manifest file: 
 <manifest ...>
     <uses-feature android:name=""android.hardware.wifi"" />
     ...
 </manifest>",network info,network ,1,yes,no,SOURCE,no,
"<android.app.Activity: void startActivityFromFragment(Fragment,Intent,int,Bundle)>","This method was deprecated
      in API level 28. Use androidx.fragment.app.FragmentActivity#startActivityFromFragment(
 androidx.fragment.app.FragmentIntentintBundle) This is called when a Fragment in this activity calls its Fragment#startActivity or Fragment#startActivityForResult method. This method throws ActivityNotFoundException if there was no Activity found to run the given Intent.","fragment Fragment : The fragment making the call.
This value must never be null . |||
intent Intent : The intent to start. |||
requestCode int : Reply request code.  < 0 if reply is not requested. |||
options Bundle : Additional options for how the Activity should be started.
See Context.startActivity(Intent Bundle) Context.startActivity(Intent Bundle)} for more details.
This value may be null . |||",void,16,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",IPC,IPC,1,no,yes,no,SINK,
<android.net.VpnService: IBinder onBind(Intent)>,"Return the communication interface to the service. This method returns null on Intent s other than SERVICE_INTERFACE action. Applications overriding this method must identify the intent
 and return the corresponding interface accordingly.","intent Intent : The Intent that was used to bind to this service
as given to Context.bindService .  Note that any extras that were included with
the Intent at that point will not be seen here. |||","IBinder Return an IBinder through which clients can call on to the
         service. |||",14,"VpnService is a base class for applications to extend and build their
 own VPN solutions. In general it creates a virtual network interface
 configures addresses and routing rules and returns a file descriptor
 to the application. Each read from the descriptor retrieves an outgoing
 packet which was routed to the interface. Each write to the descriptor
 injects an incoming packet just like it was received from the interface.
 The interface is running on Internet Protocol (IP) so packets are
 always started with IP headers. The application then completes a VPN
 connection by processing and exchanging packets with the remote server
 over a tunnel.

  Letting applications intercept packets raises huge security concerns.
 A VPN application can easily break the network. Besides two of them may
 conflict with each other. The system takes several actions to address
 these issues. Here are some key points:
  User action is required the first time an application creates a VPN
       connection. There can be only one VPN connection running at the same time. The
       existing interface is deactivated when a new one is created. A system-managed notification is shown during the lifetime of a
       VPN connection. A system-managed dialog gives the information of the current VPN
       connection. It also provides a button to disconnect. The network is restored automatically when the file descriptor is
       closed. It also covers the cases when a VPN application is crashed
       or killed by the system. There are two primary methods in this class:  prepare(Context)  and
  Builder#establish . The former deals with user action and stops
 the VPN connection created by another application. The latter creates
 a VPN interface using the parameters supplied to the  Builder .
 An application must call  prepare(Context)  to grant the right to use
 other methods in this class and the right can be revoked at any time.
 Here are the general steps to create a VPN connection:
  When the user presses the button to connect call  prepare(Context) 
       and launch the returned intent if non-null. When the application becomes prepared start the service. Create a tunnel to the remote server and negotiate the network
       parameters for the VPN connection. Supply those parameters to a  Builder  and create a VPN
       interface by calling  Builder#establish . Process and exchange packets between the tunnel and the returned
       file descriptor. When  onRevoke()  is invoked close the file descriptor and
       shut down the tunnel gracefully. Services extending this class need to be declared with an appropriate
 permission and intent filter. Their access must be secured by
  Manifest.permission.BIND_VPN_SERVICE  permission and
 their intent filter must match  SERVICE_INTERFACE  action. Here
 is an example of declaring a VPN service in  AndroidManifest.xml :
  
 <service android:name="".ExampleVpnService""
         android:permission=""android.permission.BIND_VPN_SERVICE"">
     <intent-filter>
         <action android:name=""android.net.VpnService""/>
     </intent-filter>
 </service>  The Android system starts a VPN in the background by calling
  startService() . In Android 8.0
 (API level 26) and higher the system places VPN apps on the temporary
 whitelist for a short period so the app can start in the background. The VPN
 app must promote itself to the foreground after it's launched or the system
 will shut down the app.

  Developer's guide To learn more about developing VPN apps read the
  VPN developer's guide .",,IPC,IPC,1,yes,no,SOURCE,no,
<android.drm.DrmManagerClient: ContentValues getMetadata(Uri)>,Retrieves metadata information for rights-protected content.,uri Uri : URI for the content from which you are retrieving metadata information. |||,"ContentValues A ContentValues instance that contains
 key-value pairs representing the constraints. Null in case of failure. |||",11,"The main programming interface for the DRM framework. An application must instantiate this class
 to access DRM agents through the DRM framework.","Provides classes for managing DRM content and determining the capabilities of DRM plugins
 (agents). Common uses of the DRM API include: Determining which DRM plug-ins (agents) are installed on a device. Retrieving information about specific plug-ins such as the MIME types and file suffixes
   they support. Registering a user or a device with an online DRM service. Retrieving license constraints for rights-protected content. Checking whether a user has the proper rights to play or use rights-protected
   content. Associating rights-protected content with its license so you can use the
    MediaPlayer  API to play the content.",media metadata,media,1,yes,no,SOURCE,no,
"<android.inputmethodservice.KeyboardView: void setPopupOffset(int,int)>",,"x int |||
y int |||",void,3,"A view that renders a virtual  Keyboard . It handles rendering of keys and
 detecting key presses and touch movements.",,no,UI,0,no,no,no,no,
<android.database.sqlite.SQLiteClosable: void close()>,"Releases a reference to the object closing the object if the last reference
 was released.

 Calling this method is equivalent to calling releaseReference() .",,void,16,"An object created from a SQLiteDatabase that can be closed.

 This class implements a primitive reference counting scheme for database objects.","If you need to manage data in a private database use the  android.database.sqlite  classes. These classes are used to manage the  Cursor  object returned from a content provider query. Databases
 are usually created and opened with  openOrCreateDatabase(String int SQLiteDatabase.CursorFactory) 
 To make requests through
 content providers you can use the  content.ContentResolver  class.
  All databases are stored on the device in  /data/data/<package_name>/databases",no,no,0,no,no,no,no,
<android.webkit.WebViewFragment: void onResume()>,Called when the fragment is no longer resumed. Pauses the WebView.,,void,11,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",no,no,0,no,no,no,no,
<android.telephony.cdma.CdmaCellLocation: void fillInNotifierBundle(Bundle)>,Fill the cell location data into the intent notifier Bundle based on service state,bundleToFill Bundle : intent notifier Bundle |||,void,5,Represents the cell location on a CDMA phone.,,location information,location sensors,1,no,no,no,no,good example of sensitive info leaving through the parameters
<android.os.Environment: String getExternalStorageState()>,Returns the current state of the primary shared/external storage media.,,String one of MEDIA_UNKNOWN  MEDIA_REMOVED  MEDIA_UNMOUNTED  MEDIA_CHECKING  MEDIA_NOFS  MEDIA_MOUNTED  MEDIA_MOUNTED_READ_ONLY  MEDIA_SHARED  MEDIA_BAD_REMOVAL or MEDIA_UNMOUNTABLE . |||,1,Provides access to environment variables.,,external storage metadata,external storage,1,yes,no,SOURCE,no,
"<android.text.method.Touch: void scrollTo(TextView,Layout,int,int)>","Scrolls the specified widget to the specified coordinates except
 constrains the X scrolling position to the horizontal regions of
 the text that will be visible after scrolling to the specified
 Y position.","widget TextView |||
layout Layout |||
x int |||
y int |||",void,1,,"Provides classes that monitor or modify keypad input. You can use these classes to modify the type of keypad entry
 for your application or decipher the keypresses entered for your specific
 entry method. For example: 
 // Set the text to password display style:
 EditText txtView = (EditText)findViewById(R.id.text);
 txtView.setTransformationMethod(PasswordTransformationMethod.getInstance());

 //Set the input style to numbers rather than qwerty keyboard style.
 txtView.setInputMethod(DigitsInputMethod.getInstance());

 // Find out whether the caps lock is on.
 // 0 is no 1 is yes 2 is caps lock on.
 int active = MultiTapInputMethod.getCapsActive(txtView.getText());",no,UI,0,no,no,no,no,
<android.widget.TextView: void append(CharSequence)>,"Convenience method to append the specified text to the TextView's
 display buffer upgrading it to TextView.BufferType.EDITABLE if it was not already editable.",text CharSequence : text to be appended to the already displayed text |||,void,1,"A user interface element that displays text to the user.
 To provide user-editable text see  EditText .
  
 The following code sample shows a typical use with an XML layout
 and code to modify the contents of the text view:
  
 <LinearLayout
      xmlns:android=""http://schemas.android.com/apk/res/android""
      android:layout_width=""match_parent""
      android:layout_height=""match_parent"">
    <TextView
        android:id=""@+id/text_view_id""
        android:layout_height=""wrap_content""
        android:layout_width=""wrap_content""
        android:text=""@string/hello"" />
 </LinearLayout>
  
 This code sample demonstrates how to modify the contents of the text view
 defined in the previous XML layout:
  
 public class MainActivity extends Activity {

    protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_main);
         final TextView helloTextView = (TextView) findViewById(R.id.text_view_id);
         helloTextView.setText(R.string.user_greeting);
     }
 }
  
 To customize the appearance of TextView see  Styles and Themes .
  XML attributes 
 See  TextView Attributes 
  View Attributes","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",uncategorized,UI,1,no,yes,no,SINK,
<android.test.InstrumentationTestRunner: void onCreate(Bundle)>,"Called when the instrumentation is starting before any application code
 has been loaded.  Usually this will be implemented to simply call start() to begin the instrumentation thread which will then
 continue execution in onStart() . If you do not need your own thread -- that is you are writing your
 instrumentation to be completely asynchronous (returning to the event
 loop so that the application can run) you can simply begin your
 instrumentation here for example call Context#startActivity to
 begin the appropriate first activity of the application.","arguments Bundle : Any additional arguments that were supplied when the
instrumentation was started. |||",void,1,"An  Instrumentation  that runs various types of  TestCase s against
 an Android package (application).",,no,no,0,no,no,no,no,
"<android.view.accessibility.AccessibilityEvent: void writeToParcel(Parcel,int)>",Flatten this object in to a Parcel.,"parcel Parcel : The Parcel in which the object should be written. |||
flags int : Additional flags about how the object should be written.
May be 0 or Parcelable.PARCELABLE_WRITE_RETURN_VALUE .
Value is either 0 or a combination of Parcelable.PARCELABLE_WRITE_RETURN_VALUE and android.os.Parcelable.PARCELABLE_ELIDE_DUPLICATES |||",void,4,"This class represents accessibility events that are sent by the system when
 something notable happens in the user interface. For example when a
  Button  is clicked a  View  is focused etc.
  
 An accessibility event is fired by an individual view which populates the event with
 data for its state and requests from its parent to send the event to interested
 parties. The parent can optionally modify or even block the event based on its broader
 understanding of the user interface's context.
  
 The main purpose of an accessibility event is to communicate changes in the UI to an
  AccessibilityService . The service may then inspect
 if needed the user interface by examining the View hierarchy as represented by a tree of
  AccessibilityNodeInfo s (snapshot of a View state)
 which can be used for exploring the window content. Note that the privilege for accessing
 an event's source thus the window content has to be explicitly requested. For more
 details refer to  AccessibilityService . If an
 accessibility service has not requested to retrieve the window content the event will
 not contain reference to its source. Also for events of type
  TYPE_NOTIFICATION_STATE_CHANGED  the source is never available.
  
 This class represents various semantically different accessibility event
 types. Each event type has an associated set of related properties. In other
 words each event type is characterized via a subset of the properties exposed
 by this class. For each event type there is a corresponding constant defined
 in this class. Follows a specification of the event types and their associated properties:",,IPC,no,0,no,no,no,no,
"<android.content.Intent: Intent putExtra(String,CharSequence)>","Add extended data to the intent.  The name must include a package
 prefix for example the app com.android.contacts would use names
 like ""com.android.contacts.ShowAll"".","name String : The name of the extra data with package prefix. |||
value CharSequence : The CharSequence data value.
This value may be null . |||","Intent Returns the same Intent object for chaining multiple calls
 into a single statement.

 This value will never be null . |||",1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",IPC,no,0,no,no,no,no,
<android.net.sip.SipAudioCall: SipProfile getPeerProfile()>,Gets the peer's SIP profile.,,SipProfile the peer's SIP profile |||,9,"Handles an Internet audio call over SIP. You can instantiate this class with  SipManager 
 using  SipManager#makeAudioCall  and   SipManager#takeAudioCall .

  Note:  Using this class require the
    Manifest.permission.INTERNET  and
    Manifest.permission.USE_SIP  permissions. In addition  startAudio()  requires the
    Manifest.permission.RECORD_AUDIO 
    Manifest.permission.ACCESS_WIFI_STATE  and
    Manifest.permission.WAKE_LOCK  permissions; and  setSpeakerMode()  requires the
    Manifest.permission.MODIFY_AUDIO_SETTINGS  permission.",,phone metadata,phone,1,yes,no,SOURCE,no,
<android.view.ViewPropertyAnimator: ViewPropertyAnimator scaleYBy(float)>,"This method will cause the View's scaleY property to be animated by the
 specified value. Animations already running on the property will be canceled.",value float : The amount to be animated by as an offset from the current value. |||,ViewPropertyAnimator This object allowing calls to methods in this class to be chained. |||,12,"This class enables automatic and optimized animation of select properties on View objects.
 If only one or two properties on a View object are being animated then using an
  ObjectAnimator  is fine; the property setters called by ObjectAnimator
 are well equipped to do the right thing to set the property and invalidate the view
 appropriately. But if several properties are animated simultaneously or if you just want a
 more convenient syntax to animate a specific property then ViewPropertyAnimator might be
 more well-suited to the task.

  This class may provide better performance for several simultaneous animations because
 it will optimize invalidate calls to take place only once for several properties instead of each
 animated property independently causing its own invalidation. Also the syntax of using this
 class could be easier to use because the caller need only tell the View object which
 property to animate and the value to animate either to or by and this class handles the
 details of configuring the underlying Animator class and starting it. This class is not constructed by the caller but rather by the View whose properties
 it will animate. Calls to  View.animate()  will return a reference
 to the appropriate ViewPropertyAnimator object for that View.",,no,UI,0,no,no,no,no,
<android.preference.SwitchPreference: void setSwitchTextOff(int)>,"Set the text displayed on the switch widget in the off state.
 This should be a very short string; one word if possible.",resId int : The text as a string resource ID |||,void,14,"A  Preference  that provides a two-state toggleable option.
  
 This preference will store a boolean into the SharedPreferences.",,no,no,0,no,no,no,no,
"<android.database.sqlite.SQLiteDatabase: int update(String,ContentValues,String,String)>",Convenience method for updating rows in the database.,"table String : the table to update in |||
values ContentValues : a map from column names to new column values. null is a
valid value that will be translated to NULL. |||
whereClause String : the optional WHERE clause to apply when updating.
Passing null will update all rows. |||
whereArgs String : You may include ?s in the where clause which
will be replaced by the values from whereArgs. The values
will be bound as Strings. |||",int the number of rows affected |||,1,"Exposes methods to manage a SQLite database.

  
 SQLiteDatabase has methods to create delete execute SQL commands and
 perform other common database management tasks.
  
 See the Notepad sample application in the SDK for an example of creating
 and managing a database.
  
 Database names must be unique within an application not across all applications.
  Localized Collation - ORDER BY 
 In addition to SQLite's default  BINARY  collator Android supplies
 two more  LOCALIZED  which changes with the system's current locale
 and  UNICODE  which is the Unicode Collation Algorithm and not tailored
 to the current locale.","If you need to manage data in a private database use the  android.database.sqlite  classes. These classes are used to manage the  Cursor  object returned from a content provider query. Databases
 are usually created and opened with  openOrCreateDatabase(String int SQLiteDatabase.CursorFactory) 
 To make requests through
 content providers you can use the  content.ContentResolver  class.
  All databases are stored on the device in  /data/data/<package_name>/databases",database data,database,1,no,yes,no,SINK,
<android.widget.StackView: void showPrevious()>,Manually shows the previous child.,,void,11,,"The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,no,0,no,no,no,no,
<android.widget.ShareActionProvider: void setShareIntent(Intent)>,"Sets an intent with information about the share action. Here is a
 sample for constructing a share intent:",shareIntent Intent : The share intent. |||,void,14,"This is a provider for a share action. It is responsible for creating views
 that enable data sharing and also to show a sub menu with sharing activities
 if the hosting item is placed on the overflow menu.
  
 Here is how to use the action provider with custom backing file in a  MenuItem :
  
 // In Activity#onCreateOptionsMenu
 public boolean onCreateOptionsMenu(Menu menu) {
     // Get the menu item.
     MenuItem menuItem = menu.findItem(R.id.my_menu_item);
     // Get the provider and hold onto it to set/change the share intent.
     mShareActionProvider = (ShareActionProvider) menuItem.getActionProvider();
     // Set history different from the default before getting the action
     // view since a call to  MenuItem#getActionView()  calls
     //  ActionProvider#onCreateActionView()  which uses the backing file name. Omit this
     // line if using the default share history file is desired.
     mShareActionProvider.setShareHistoryFileName(""custom_share_history.xml"");
     . . .
 }

 // Somewhere in the application.
 public void doShare(Intent shareIntent) {
     // When you want to share set the share intent.
     mShareActionProvider.setShareIntent(shareIntent);
 } Note:  While the sample snippet demonstrates how to use this provider
 in the context of a menu item the use of the provider is not limited to menu items.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",IPC,IPC,1,no,no,no,no,
<android.content.IntentSender: int getCreatorUid()>,"Return the uid of the application that created this
 PendingIntent that is the identity under which you will actually be
 sending the Intent.  The returned integer is supplied by the system so
 that an application can not spoof its uid.",,"int The uid of the PendingIntent or -1 if there is
 none associated with it. |||",17,"A description of an Intent and target action to perform with it.
 The returned object can be
 handed to other applications so that they can perform the action you
 described on your behalf at a later time.

  By giving a IntentSender to another application
 you are granting it the right to perform the operation you have specified
 as if the other application was yourself (with the same permissions and
 identity).  As such you should be careful about how you build the IntentSender:
 often for example the base Intent you supply will have the component
 name explicitly set to one of your own components to ensure it is ultimately
 sent there and nowhere else.

  A IntentSender itself is simply a reference to a token maintained by
 the system describing the original data used to retrieve it.  This means
 that even if its owning application's process is killed the
 IntentSender itself will remain usable from other processes that
 have been given it.  If the creating application later re-retrieves the
 same kind of IntentSender (same operation same Intent action data
 categories and components and same flags) it will receive a IntentSender
 representing the same token if that is still valid.

  Instances of this class can not be made directly but rather must be
 created from an existing  PendingIntent  with
  PendingIntent.getIntentSender() .","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,IPC,0,no,no,no,no,
<android.app.Instrumentation: void callActivityOnUserLeaving(Activity)>,"Perform calling of an activity's Activity#onUserLeaveHint method.
 The default implementation simply calls through to that method.",activity Activity : The activity being notified that the user has navigated away |||,void,3,"Base class for implementing application instrumentation code.  When running
 with instrumentation turned on this class will be instantiated for you
 before any of the application code allowing you to monitor all of the
 interaction the system has with the application.  An Instrumentation
 implementation is described to the system through an AndroidManifest.xml's
 <instrumentation> tag.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",IPC,IPC,1,no,yes,no,SINK,
"<android.content.ContextWrapper: void enforceCallingUriPermission(Uri,int,String)>","If the calling process and user ID has not been granted
 permission to access a specific URI throw SecurityException .  This is basically the same as calling enforceUriPermission(android.net.Uri int int int java.lang.String) with
 the pid and uid returned by Binder.getCallingPid() and Binder.getCallingUid() .  One important difference is
 that if you are not currently processing an IPC this function
 will always throw a SecurityException.","uri Uri : The uri that is being checked. |||
modeFlags int : The access modes to enforce.
Value is either 0 or a combination of Intent.FLAG_GRANT_READ_URI_PERMISSION and Intent.FLAG_GRANT_WRITE_URI_PERMISSION |||
message String : A message to include in the exception if it is thrown. |||",void,1,"Proxying implementation of Context that simply delegates all of its calls to
 another Context.  Can be subclassed to modify behavior without changing
 the original Context.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,
"<android.content.Intent: Intent putExtra(String,int)>","Add extended data to the intent.  The name must include a package
 prefix for example the app com.android.contacts would use names
 like ""com.android.contacts.ShowAll"".","name String : The name of the extra data with package prefix. |||
value int : The integer data value. |||","Intent Returns the same Intent object for chaining multiple calls
 into a single statement.

 This value will never be null . |||",1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,
"<android.nfc.NfcAdapter: void enableForegroundDispatch(Activity,PendingIntent,IntentFilter,String)>","Enable foreground dispatch to the given Activity. This will give priority to the foreground activity when
 dispatching a discovered Tag to an application. If any IntentFilters are provided to this method they are used to match dispatch Intents
 for both the NfcAdapter#ACTION_NDEF_DISCOVERED and NfcAdapter#ACTION_TAG_DISCOVERED . Since NfcAdapter#ACTION_TECH_DISCOVERED relies on meta data outside of the IntentFilter matching for that dispatch Intent is handled
 by passing in the tech lists separately. Each first level entry in the tech list represents
 an array of technologies that must all be present to match. If any of the first level sets
 match then the dispatch is routed through the given PendingIntent. In other words the second
 level is ANDed together and the first level entries are ORed together. If you pass null for both the filters and techLists parameters
 that acts a wild card and will cause the foreground activity to receive all tags via the NfcAdapter#ACTION_TAG_DISCOVERED intent. This method must be called from the main thread and only when the activity is in the
 foreground (resumed). Also activities must call disableForegroundDispatch(Activity) before
 the completion of their Activity#onPause callback to disable foreground dispatch
 after it has been enabled. Requires the Manifest.permission.NFC permission.","activity Activity : the Activity to dispatch to |||
intent PendingIntent : the PendingIntent to start for the dispatch |||
filters IntentFilter : the IntentFilters to override dispatching for or null to always dispatch |||
techLists String : the tech lists used to perform matching for dispatching of the NfcAdapter#ACTION_TECH_DISCOVERED intent |||",void,10,"Represents the local NFC adapter.
  
 Use the helper  getDefaultAdapter(android.content.Context)  to get the default NFC
 adapter for this Android device.","Provides access to Near Field Communication (NFC) functionality allowing applications to read
 NDEF message in NFC tags. A ""tag"" may actually be another device that appears as a tag. For more information see the
  Near Field Communication  guide. Here's a summary of the classes: NfcManager This is the high level manager used to obtain this device's  NfcAdapter . You can
 acquire an instance using  getSystemService(Class ) . NfcAdapter This represents the device's NFC adapter which is your entry-point to performing NFC
 operations. You can acquire an instance with  getDefaultAdapter()  or
  getDefaultAdapter(android.content.Context) . NdefMessage Represents an NDEF data message which is the standard format in which ""records""
 carrying data are transmitted between devices and tags. Your application can receive these
 messages from an  ACTION_TAG_DISCOVERED  intent. NdefRecord Represents a record which is delivered in a  NdefMessage  and describes the
 type of data being shared and carries the data itself. Note: 
 Not all Android-powered devices provide NFC functionality.",no,no,0,no,no,no,no,
"<android.webkit.WebViewFragment: View onCreateView(LayoutInflater,ViewGroup,Bundle)>",Called to instantiate the view. Creates and returns the WebView.,"inflater LayoutInflater : The LayoutInflater object that can be used to inflate
any views in the fragment |||
container ViewGroup : If non-null this is the parent view that the fragment's
UI should be attached to.  The fragment should not add the view itself
but this can be used to generate the LayoutParams of the view.
This value may be null . |||
savedInstanceState Bundle : If non-null this fragment is being re-constructed
from a previous saved state as given here. |||",View Return the View for the fragment's UI or null. |||,11,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",no,network ,0,no,no,no,no,
"<android.app.TimePickerDialog: void updateTime(int,int)>",Sets the current time.,"hourOfDay int : The current hour within the day. |||
minuteOfHour int : The current minute within the hour. |||",void,1,"A dialog that prompts the user for the time of day using a
  TimePicker .

  
 See the  Pickers 
 guide.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
<android.inputmethodservice.InputMethodService: void setExtractView(View)>,,view View |||,void,3,"InputMethodService provides a standard implementation of an InputMethod
 which final implementations can derive from and customize.  See the
 base class  AbstractInputMethodService  and the  InputMethod 
 interface for more information on the basics of writing input methods.

  In addition to the normal Service lifecycle methods this class
 introduces some new specific callbacks that most subclasses will want
 to make use of: onInitializeInterface()  for user-interface initialization
 in particular to deal with configuration changes while the service is
 running.
  onBindInput()  to find out about switching to a new client.
  onStartInput(EditorInfo boolean)  to deal with an input session starting with
 the client.
  onCreateInputView()   onCreateCandidatesView() 
 and  onCreateExtractTextView()  for non-demand generation of the UI.
  onStartInputView(android.view.inputmethod.EditorInfo boolean)  to deal with input
 starting within the input area of the IME.
  An input method has significant discretion in how it goes about its
 work: the  InputMethodService  provides
 a basic framework for standard UI elements (input view candidates view
 and running in fullscreen mode) but it is up to a particular implementor
 to decide how to use them.  For example one input method could implement
 an input area with a keyboard another could allow the user to draw text
 while a third could have no input area (and thus not be visible to the
 user) but instead listen to audio and perform text to speech conversion. In the implementation provided here all of these elements are placed
 together in a single window managed by the InputMethodService.  It will
 execute callbacks as it needs information about them and provides APIs for
 programmatic control over them.  They layout of these elements is explicitly
 defined: The soft input view if available is placed at the bottom of the
 screen.
  The candidates view if currently shown is placed above the soft
 input view.
  If not running fullscreen the application is moved or resized to be
 above these views; if running fullscreen the window will completely cover
 the application and its top part will contain the extract text of what is
 currently being edited by the application.
  Soft Input View Central to most input methods is the soft input view.  This is where most
 user interaction occurs: pressing on soft keys drawing characters or
 however else your input method wants to generate text.  Most implementations
 will simply have their own view doing all of this work and return a new
 instance of it when  onCreateInputView()  is called.  At that point
 as long as the input view is visible you will see user interaction in
 that view and can call back on the InputMethodService to interact with the
 application as appropriate. There are some situations where you want to decide whether or not your
 soft input view should be shown to the user.  This is done by implementing
 the  onEvaluateInputViewShown()  to return true or false based on
 whether it should be shown in the current environment.  If any of your
 state has changed that may impact this call
  updateInputViewShown()  to have it re-evaluated.  The default
 implementation always shows the input view unless there is a hard
 keyboard available which is the appropriate behavior for most input
 methods. Candidates View Often while the user is generating raw text an input method wants to
 provide them with a list of possible interpretations of that text that can
 be selected for use.  This is accomplished with the candidates view and
 like the soft input view you implement  onCreateCandidatesView() 
 to instantiate your own view implementing your candidates UI. Management of the candidates view is a little different than the input
 view because the candidates view tends to be more transient being shown
 only when there are possible candidates for the current text being entered
 by the user.  To control whether the candidates view is shown you use
  setCandidatesViewShown(boolean) .  Note that because the candidate
 view tends to be shown and hidden a lot it does not impact the application
 UI in the same way as the soft input view: it will never cause application
 windows to resize only cause them to be panned if needed for the user to
 see the current focus. Fullscreen Mode Sometimes your input method UI is too large to integrate with the
 application UI so you just want to take over the screen.  This is
 accomplished by switching to full-screen mode causing the input method
 window to fill the entire screen and add its own ""extracted text"" editor
 showing the user the text that is being typed.  Unlike the other UI elements
 there is a standard implementation for the extract editor that you should
 not need to change.  The editor is placed at the top of the IME above the
 input and candidates views. Similar to the input view you control whether the IME is running in
 fullscreen mode by implementing  onEvaluateFullscreenMode() 
 to return true or false based on
 whether it should be fullscreen in the current environment.  If any of your
 state has changed that may impact this call
  updateFullscreenMode()  to have it re-evaluated.  The default
 implementation selects fullscreen mode when the screen is in a landscape
 orientation which is appropriate behavior for most input methods that have
 a significant input area. When in fullscreen mode you have some special requirements because the
 user can not see the application UI.  In particular you should implement
  onDisplayCompletions(android.view.inputmethod.CompletionInfo[])  to show completions
 generated by your application typically in your candidates view like you
 would normally show candidates.


  Generating Text The key part of an IME is of course generating text for the application.
 This is done through calls to the
  InputConnection  interface to the
 application which can be retrieved from  getCurrentInputConnection() .
 This interface allows you to generate raw key events or if the target
 supports it directly edit in strings of candidates and committed text. Information about what the target is expected and supports can be found
 through the  EditorInfo  class which is
 retrieved with  getCurrentInputEditorInfo()  method.  The most
 important part of this is  EditorInfo.inputType ; in particular if this is
  EditorInfo.TYPE_NULL 
 then the target does not support complex edits and you need to only deliver
 raw key events to it.  An input method will also want to look at other
 values here to for example detect password mode auto complete text views
 phone number entry etc. When the user switches between input targets you will receive calls to
  onFinishInput()  and  onStartInput(android.view.inputmethod.EditorInfo boolean) .
 You can use these to reset and initialize your input state for the current
 target.  For example you will often want to clear any input state and
 update a soft keyboard to be appropriate for the new inputType.",,no,no,0,no,no,no,no,
<android.net.ConnectivityManager: NetworkInfo getNetworkInfo(int)>,"This method was deprecated
      in API level 23. This method does not support multiple connected networks
             of the same type. Use getAllNetworks() and getNetworkInfo(android.net.Network) instead. Returns connection status information about a particular
 network type. Requires Manifest.permission.ACCESS_NETWORK_STATE","networkType int : integer specifying which networkType in
which you're interested. |||","NetworkInfo a NetworkInfo object for the requested
        network type or null if the type is not
        supported by the device. If networkType is
        TYPE_VPN and a VPN is active for the calling app
        then this method will try to return one of the
        underlying networks for the VPN or null if the
        VPN agent didn't specify any. |||",1,"Class that answers queries about the state of network connectivity. It also
 notifies applications when network connectivity changes.
  
 The primary responsibilities of this class are to:
  Monitor network connections (Wi-Fi GPRS UMTS etc.) Send broadcast intents when network connectivity changes Attempt to ""fail over"" to another network when connectivity to a network
 is lost Provide an API that allows applications to query the coarse-grained or fine-grained
 state of the available networks Provide an API that allows applications to request and select networks for their data
 traffic",,network info,network ,1,yes,no,SOURCE,no,
<android.webkit.WebView: String findAddress(String)>,"This method was deprecated
      in API level 28. This method is superseded by TextClassifier#generateLinks(
 android.view.textclassifier.TextLinks.Request) . Avoid using this method even when targeting
 API levels where no alternative is available. Gets the first substring which appears to be the address of a physical
 location. Only addresses in the United States can be detected which
 must consist of: a house number 
a street name 
a street type (Road Circle etc) either spelled out or
       abbreviated 
a city name 
a state or territory either spelled out or two-letter abbr 
an optional 5 digit or 9 digit zip code 
Note: This function is deprecated and should be
 avoided on all API levels as it cannot detect addresses outside of the
 United States and has a high rate of false positives. On API level Build.VERSION_CODES.O_MR1 and earlier it also causes
 the entire WebView implementation to be loaded and initialized which
 can throw AndroidRuntimeException or other exceptions
 if the WebView implementation is currently being updated.",addr String : the string to search for addresses |||,String the address or if no address is found null |||,1,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",location information,location sensors,1,yes,no,SOURCE,no,
<android.app.ListFragment: ListView getListView()>,Get the fragment's list view widget.,,ListView |||,11,"A fragment that displays a list of items by binding to a data source such as
 an array or Cursor and exposes event handlers when the user selects an item.
  
 ListFragment hosts a  ListView  object that can
 be bound to different data sources typically either an array or a Cursor
 holding query results. Binding screen layout and row layout are discussed
 in the following sections.
  Screen Layout 
 ListFragment has a default layout that consists of a single list view.
 However if you desire you can customize the fragment layout by returning
 your own view hierarchy from  onCreateView(LayoutInflater ViewGroup Bundle) .
 To do this your view hierarchy  must  contain a ListView object with the
 id ""@android:id/list"" (or  R.id.list  if it's in code)
  
 Optionally your view hierarchy can contain another view object of any type to
 display when the list view is empty. This ""empty list"" notifier must have an
 id ""android:empty"". Note that when an empty view is present the list view
 will be hidden when there is no data to display.
  
 The following code demonstrates an (ugly) custom list layout. It has a list
 with a green background and an alternate red ""no data"" message.
  
 <?xml version=""1.0"" encoding=""utf-8""?>
 <LinearLayout xmlns:android=""http://schemas.android.com/apk/res/android""
         android:orientation=""vertical""
         android:layout_width=""match_parent""
         android:layout_height=""match_parent""
         android:paddingLeft=""8dp""
         android:paddingRight=""8dp"">

     <ListView android:id=""@id/android:list""
               android:layout_width=""match_parent""
               android:layout_height=""match_parent""
               android:background=""#00FF00""
               android:layout_weight=""1""
               android:drawSelectorOnTop=""false""/>

     <TextView android:id=""@id/android:empty""
               android:layout_width=""match_parent""
               android:layout_height=""match_parent""
               android:background=""#FF0000""
               android:text=""No data""/>
 </LinearLayout>
  Row Layout 
 You can specify the layout of individual rows in the list. You do this by
 specifying a layout resource in the ListAdapter object hosted by the fragment
 (the ListAdapter binds the ListView to the data; more on this later).
  
 A ListAdapter constructor takes a parameter that specifies a layout resource
 for each row. It also has two additional parameters that let you specify
 which data field to associate with which object in the row layout resource.
 These two parameters are typically parallel arrays.
  
 Android provides some standard row layout resources. These are in the
  R.layout  class and have names such as simple_list_item_1
 simple_list_item_2 and two_line_list_item. The following layout XML is the
 source for the resource two_line_list_item which displays two data
 fieldsone above the other for each list row.
  
 <?xml version=""1.0"" encoding=""utf-8""?>
 <LinearLayout xmlns:android=""http://schemas.android.com/apk/res/android""
     android:layout_width=""match_parent""
     android:layout_height=""wrap_content""
     android:orientation=""vertical"">

     <TextView android:id=""@+id/text1""
         android:textSize=""16sp""
         android:textStyle=""bold""
         android:layout_width=""match_parent""
         android:layout_height=""wrap_content""/>

     <TextView android:id=""@+id/text2""
         android:textSize=""16sp""
         android:layout_width=""match_parent""
         android:layout_height=""wrap_content""/>
 </LinearLayout>
  
 You must identify the data bound to each TextView object in this layout. The
 syntax for this is discussed in the next section.
  Binding to Data 
 You bind the ListFragment's ListView object to data using a class that
 implements the  ListAdapter  interface.
 Android provides two standard list adapters:
  SimpleAdapter  for static data (Maps)
 and  SimpleCursorAdapter  for Cursor
 query results.
  
 You  must  use
  ListFragment.setListAdapter()  to
 associate the list with an adapter.  Do not directly call
  ListView#setAdapter(ListAdapter)  or else
 important initialization will be skipped.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
<android.webkit.WebView: void computeScroll()>,"Called by a parent to request that a child update its values for mScrollX
 and mScrollY if necessary. This will typically be done if the child is
 animating a scroll using a Scroller object.",,void,1,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",no,no,0,no,no,no,no,
"<android.animation.LayoutTransition: void removeChild(ViewGroup,View)>","This method is called by ViewGroup when a child view is about to be removed from the
 container. This callback starts the process of a transition; we grab the starting
 values listen for changes to all of the children of the container and start appropriate
 animations.","parent ViewGroup : The ViewGroup from which the View is being removed. |||
child View : The View being removed from the ViewGroup. |||",void,11,"This class enables automatic animations on layout changes in ViewGroup objects. To enable
 transitions for a layout container create a LayoutTransition object and set it on any
 ViewGroup by calling  ViewGroup#setLayoutTransition(LayoutTransition) . This will cause
 default animations to run whenever items are added to or removed from that container. To specify
 custom animations use the  LayoutTransition#setAnimator(int Animator)  method.

  One of the core concepts of these transition animations is that there are two types of
 changes that cause the transition and four different animations that run because of
 those changes. The changes that trigger the transition are items being added to a container
 (referred to as an ""appearing"" transition) or removed from a container (also known as
 ""disappearing""). Setting the visibility of views (between GONE and VISIBLE) will trigger
 the same add/remove logic. The animations that run due to those events are one that animates
 items being added one that animates items being removed and two that animate the other
 items in the container that change due to the add/remove occurrence. Users of
 the transition may want different animations for the changing items depending on whether
 they are changing due to an appearing or disappearing event so there is one animation for
 each of these variations of the changing event. Most of the API of this class is concerned
 with setting up the basic properties of the animations used in these four situations
 or with setting up custom animations for any or all of the four. By default the DISAPPEARING animation begins immediately as does the CHANGE_APPEARING
 animation. The other animations begin after a delay that is set to the default duration
 of the animations. This behavior facilitates a sequence of animations in transitions as
 follows: when an item is being added to a layout the other children of that container will
 move first (thus creating space for the new item) then the appearing animation will run to
 animate the item being added. Conversely when an item is removed from a container the
 animation to remove it will run first then the animations of the other children in the
 layout will run (closing the gap created in the layout when the item was removed). If this
 default choreography behavior is not desired the  setDuration(int long)  and
  setStartDelay(int long)  of any or all of the animations can be changed as
 appropriate. Keep in mind however that if you start an APPEARING animation before a
 DISAPPEARING animation is completed the DISAPPEARING animation stops and any effects from
 the DISAPPEARING animation are reverted. If you instead start a DISAPPEARING animation
 before an APPEARING animation is completed a similar set of effects occurs for the
 APPEARING animation. The animations specified for the transition both the defaults and any custom animations
 set on the transition object are templates only. That is these animations exist to hold the
 basic animation properties such as the duration start delay and properties being animated.
 But the actual target object as well as the start and end values for those properties are
 set automatically in the process of setting up the transition each time it runs. Each of the
 animations is cloned from the original copy and the clone is then populated with the dynamic
 values of the target being animated (such as one of the items in a layout container that is
 moving as a result of the layout event) as well as the values that are changing (such as the
 position and size of that object). The actual values that are pushed to each animation
 depends on what properties are specified for the animation. For example the default
 CHANGE_APPEARING animation animates the  left   top   right 
  bottom   scrollX  and  scrollY  properties.
 Values for these properties are updated with the pre- and post-layout
 values when the transition begins. Custom animations will be similarly populated with
 the target and values being animated assuming they use ObjectAnimator objects with
 property names that are known on the target object. This class and the associated XML flag for containers animateLayoutChanges=""true""
 provides a simple utility meant for automating changes in straightforward situations.
 Using LayoutTransition at multiple levels of a nested view hierarchy may not work due to the
 interrelationship of the various levels of layout. Also a container that is being scrolled
 at the same time as items are being added or removed is probably not a good candidate for
 this utility because the before/after locations calculated by LayoutTransition
 may not match the actual locations when the animations finish due to the container
 being scrolled as the animations are running. You can work around that
 particular issue by disabling the 'changing' animations by setting the CHANGE_APPEARING
 and CHANGE_DISAPPEARING animations to null and setting the startDelay of the
 other animations appropriately.","These classes provide functionality for the property animation system which allows you
 to animate object properties of any type.  int   float  and hexadecimal
 color values are supported by default. You can animate any other type by telling the system how
 to calculate the values for that given type with a custom  TypeEvaluator .
  For more information see the
  Animation  guide. 
 You can set many different types of interpolators (contained in  android.view.animation )
 specify  keyframes  or group animations to play sequentially
 or simultaneously (with  AnimatorSet ) to further control your animation
 behaviors.",no,no,0,no,no,no,no,
<android.view.Display: void getRealMetrics(DisplayMetrics)>,"Gets display metrics based on the real size of this display. The size is adjusted based on the current rotation of the display. The real size may be smaller than the physical size of the screen when the
 window manager is emulating a smaller display (using adb shell wm size).",outMetrics DisplayMetrics : A DisplayMetrics object to receive the metrics. |||,void,17,"Provides information about the size and density of a logical display.
  
 The display area is described in two different ways.
  The application display area specifies the part of the display that may contain
 an application window excluding the system decorations.  The application display area may
 be smaller than the real display area because the system subtracts the space needed
 for decor elements such as the status bar.  Use the following methods to query the
 application display area:  getSize(Point)   getRectSize(Rect)  and  getMetrics(DisplayMetrics) . The real display area specifies the part of the display that contains content
 including the system decorations.  Even so the real display area may be smaller than the
 physical size of the display if the window manager is emulating a smaller display
 using (adb shell wm size).  Use the following methods to query the
 real display area:  getRealSize(Point)   getRealMetrics(DisplayMetrics) . 
 A logical display does not necessarily represent a particular physical display device
 such as the built-in screen or an external monitor.  The contents of a logical
 display may be presented on one or more physical displays according to the devices
 that are currently attached and whether mirroring has been enabled.",,uncategorized,UI,1,yes,no,no,no,not sure
<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getLabelFor()>,"Gets the node info for which the view represented by this info serves as
 a label for accessibility purposes. Note: It is a client responsibility to recycle the
     received info by calling AccessibilityNodeInfo#recycle() to avoid creating of multiple instances.",,AccessibilityNodeInfo The labeled info. |||,17,"This class represents a node of the window content as well as actions that
 can be requested from its source. From the point of view of an
  AccessibilityService  a window's content is
 presented as a tree of accessibility node infos which may or may not map one-to-one
 to the view hierarchy. In other words a custom view is free to report itself as
 a tree of accessibility node info.
  
 Once an accessibility node info is delivered to an accessibility service it is
 made immutable and calling a state mutation method generates an error.
  
 Please refer to  AccessibilityService  for
 details about how to obtain a handle to window content as a tree of accessibility
 node info as well as details about the security model.",,no,no,0,no,no,no,no,
<android.bluetooth.BluetoothA2dp: List getDevicesMatchingConnectionStates(int)>,"Get a list of devices that match any of the given connection
 states. If none of the devices match any of the given states
 an empty list will be returned. Requires Manifest.permission.BLUETOOTH",states int : Array of states. States can be one of BluetoothProfile.STATE_CONNECTED  BluetoothProfile.STATE_CONNECTING  BluetoothProfile.STATE_DISCONNECTED  BluetoothProfile.STATE_DISCONNECTING  |||,List < BluetoothDevice > List of devices. The list will be empty on error. |||,11,"This class provides the public APIs to control the Bluetooth A2DP
 profile.

  BluetoothA2dp is a proxy object for controlling the Bluetooth A2DP
 Service via IPC. Use  BluetoothAdapter#getProfileProxy  to get
 the BluetoothA2dp proxy object.

   Android only supports one connected Bluetooth A2dp device at a time.
 Each method is protected with its appropriate permission.","Provides classes that manage Bluetooth functionality such as scanning for
 devices connecting with devices and managing data transfer between devices.
 The Bluetooth API supports both ""Classic Bluetooth"" and Bluetooth Low Energy. For more information about Classic Bluetooth see the
  Bluetooth  guide.
 For more information about Bluetooth Low Energy see the
  
 Bluetooth Low Energy  (BLE) guide. The Bluetooth APIs let applications: Scan for other Bluetooth devices (including BLE devices). Query the local Bluetooth adapter for paired Bluetooth devices. Establish RFCOMM channels/sockets. Connect to specified sockets on other devices. Transfer data to and from other devices. Communicate with BLE devices such as proximity sensors heart rate
     monitors fitness devices and so on. Act as a GATT client or a GATT server (BLE). 
 To perform Bluetooth communication using these APIs an application must
 declare the  BLUETOOTH  permission. Some
 additional functionality such as requesting device discovery
 also requires the  BLUETOOTH_ADMIN 
 permission.
  Note: 
 Not all Android-powered devices provide Bluetooth functionality.",bluetooth metadata,bluetooth,1,yes,no,SOURCE,no,
<android.content.pm.LabeledIntent: void readFromParcel(Parcel)>,,in Parcel |||,void,5,"A special subclass of Intent that can have a custom label/icon
 associated with it.  Primarily for use with  Intent#ACTION_CHOOSER .","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",IPC,no,0,no,no,no,no,
"<android.view.inputmethod.InputMethodManager: void setAdditionalInputMethodSubtypes(String,InputMethodSubtype)>","This method was deprecated
      in API level 29. For IMEs that have already implemented features like customizable/downloadable
             keyboard layouts/languages please start migration to other approaches. One idea
             would be exposing only one unified InputMethodSubtype then implement
             IME's own language switching mechanism within that unified subtype. The support
             of ""Additional Subtype"" may be completely dropped in a future version of Android. Set additional input method subtypes. Only a process which shares the same uid with the IME
 can add additional input method subtypes to the IME.
 Please note that a subtype's status is stored in the system.
 For example enabled subtypes are remembered by the framework even after they are removed
 by using this method. If you re-add the same subtypes again
 they will just get enabled. If you want to avoid such conflicts for instance you may
 want to create a ""different"" new subtype even with the same locale and mode
 by changing its extra value. The different subtype won't get affected by the stored past
 status. (You may want to take a look at InputMethodSubtype#hashCode() to refer
 to the current implementation.) NOTE: If the same subtype exists in both the manifest XML file and additional subtypes
 specified by subtypes those multiple instances are automatically merged into one
 instance. CAVEAT: In API Level 23 and prior the system may do nothing if an empty InputMethodSubtype is specified in subtypes which prevents you from removing
 the last one entry of additional subtypes. If your IME statically defines one or more
 subtypes in the manifest XML file you may be able to work around this limitation by
 specifying one of those statically defined subtypes in subtypes .","imiId String : Id of InputMethodInfo which additional input method subtypes will be added to. |||
subtypes InputMethodSubtype : subtypes will be added as additional subtypes of the current input method. |||",void,14,"Central system API to the overall input method framework (IMF) architecture
 which arbitrates interaction between applications and the current input method.

  Topics covered here:
  Architecture Overview Applications Input Methods Security Architecture Overview There are three primary parties involved in the input method
 framework (IMF) architecture:  The  input method manager  as expressed by this class
 is the central point of the system that manages interaction between all
 other parts.  It is expressed as the client-side API here which exists
 in each application context and communicates with a global system service
 that manages the interaction across all processes.
   An  input method (IME)  implements a particular
 interaction model allowing the user to generate text.  The system binds
 to the current input method that is in use causing it to be created and run
 and tells it when to hide and show its UI.  Only one IME is running at a time.
   Multiple  client applications  arbitrate with the input
 method manager for input focus and control over the state of the IME.  Only
 one such client is ever active (working with the IME) at a time.
  Applications In most cases applications that are using the standard
  TextView  or its subclasses will have little they need
 to do to work well with soft input methods.  The main things you need to
 be aware of are:  Properly set the  R.attr.inputType  in your editable
 text views so that the input method will have enough context to help the
 user in entering text into them.
   Deal well with losing screen space when the input method is
 displayed.  Ideally an application should handle its window being resized
 smaller but it can rely on the system performing panning of the window
 if needed.  You should set the  R.attr.windowSoftInputMode 
 attribute on your activity or the corresponding values on windows you
 create to help the system determine whether to pan or resize (it will
 try to determine this automatically but may get it wrong).
   You can also control the preferred soft input state (open closed etc)
 for your window using the same  R.attr.windowSoftInputMode 
 attribute.
  More finer-grained control is available through the APIs here to directly
 interact with the IMF and its IME -- either showing or hiding the input
 area letting the user pick an input method etc. For the rare people amongst us writing their own text editors you
 will need to implement  View.onCreateInputConnection(EditorInfo) 
 to return a new instance of your own  InputConnection  interface
 allowing the IME to interact with your editor. Input Methods An input method (IME) is implemented
 as a  Service  typically deriving from
  InputMethodService .  It must provide
 the core  InputMethod  interface though this is normally handled by
  InputMethodService  and implementors will
 only need to deal with the higher-level API there. InputMethodService Security There are a lot of security issues associated with input methods
 since they essentially have freedom to completely drive the UI and monitor
 everything the user enters.  The Android input method framework also allows
 arbitrary third party IMEs so care must be taken to restrict their
 selection and interactions. Here are some key points about the security architecture behind the
 IMF: Only the system is allowed to directly access an IME's
  InputMethod  interface via the
  Manifest.permission.BIND_INPUT_METHOD  permission.  This is
 enforced in the system by not binding to an input method service that does
 not require this permission so the system can guarantee no other untrusted
 clients are accessing the current input method outside of its control. There may be many client processes of the IMF but only one may
 be active at a time.  The inactive clients can not interact with key
 parts of the IMF through the mechanisms described below. Clients of an input method are only given access to its
  InputMethodSession  interface.  One instance of this interface is
 created for each client and only calls from the session associated with
 the active client will be processed by the current IME.  This is enforced
 by  AbstractInputMethodService  for normal
 IMEs but must be explicitly handled by an IME that is customizing the
 raw  InputMethodSession  implementation. Only the active client's  InputConnection  will accept
 operations.  The IMF tells each client process whether it is active and
 the framework enforces that in inactive processes calls on to the current
 InputConnection will be ignored.  This ensures that the current IME can
 only deliver events and text edits to the UI that the user sees as
 being in focus. An IME can never interact with an  InputConnection  while
 the screen is off.  This is enforced by making all clients inactive while
 the screen is off and prevents bad IMEs from driving the UI when the user
 can not be aware of its behavior. A client application can ask that the system let the user pick a
 new IME but can not programmatically switch to one itself.  This avoids
 malicious applications from switching the user to their own IME which
 remains running when the user navigates away to another application.  An
 IME on the other hand  is  allowed to programmatically switch
 the system to another IME since it already has full control of user
 input. The user must explicitly enable a new IME in settings before
 they can switch to it to confirm with the system that they know about it
 and want to make it available for use. PackageManager#FEATURE_INPUT_METHODS PackageManager.hasSystemFeature(String)",,no,no,0,no,no,no,no,
<android.widget.AdapterViewAnimator: void setDisplayedChild(int)>,Sets which child view will be displayed.,whichChild int : the index of the child view to display |||,void,11,"An AdapterView is a view whose children are determined by an  Adapter .

  
 See  ListView   GridView   Spinner  and
       Gallery  for commonly used subclasses of AdapterView.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,no,0,no,no,no,no,
"<android.app.ApplicationErrorReport: ComponentName getErrorReportReceiver(Context,String,int)>",,"context Context |||
packageName String |||
appFlags int |||",ComponentName |||,14,"Base class for maintaining global application state. You can provide your own
 implementation by creating a subclass and specifying the fully-qualified name
 of this subclass as the  ""android:name""  attribute in your
 AndroidManifest.xml's  <application>  tag. The Application
 class or your subclass of the Application class is instantiated before any
 other class when the process for your application/package is created.

  Note:  There is normally no need to subclass
 Application.  In most situations static singletons can provide the same
 functionality in a more modular way.  If your singleton needs a global
 context (for example to register broadcast receivers) include
  Context.getApplicationContext() 
 as a  Context  argument when invoking your singleton's
  getInstance()  method.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
"<android.os.Message: void writeToParcel(Parcel,int)>",Flatten this object in to a Parcel.,"dest Parcel : The Parcel in which the object should be written. |||
flags int : Additional flags about how the object should be written.
May be 0 or Parcelable.PARCELABLE_WRITE_RETURN_VALUE .
Value is either 0 or a combination of Parcelable.PARCELABLE_WRITE_RETURN_VALUE and android.os.Parcelable.PARCELABLE_ELIDE_DUPLICATES |||",void,1,"Defines a message containing a description and arbitrary data object that can be
 sent to a  Handler .  This object contains two extra int fields and an
 extra object field that allow you to not do allocations in many cases.

  While the constructor of Message is public the best way to get
 one of these is to call  Message.obtain()  or one of the
  Handler#obtainMessage  methods which will pull
 them from a pool of recycled objects.",,IPC,no,0,no,no,no,no,
"<android.app.PendingIntent: PendingIntent getBroadcast(Context,int,Intent,int)>",Retrieve a PendingIntent that will perform a broadcast like calling Context#sendBroadcast(Intent) . For security reasons the Intent you supply here should almost always be an explicit intent that is specify an explicit component to be delivered to through Intent#setClass(android.content.Context Class),"context Context : The Context in which this PendingIntent should perform
the broadcast. |||
requestCode int : Private request code for the sender |||
intent Intent : The Intent to be broadcast. |||
flags int : May be FLAG_ONE_SHOT  FLAG_NO_CREATE  FLAG_CANCEL_CURRENT  FLAG_UPDATE_CURRENT  FLAG_IMMUTABLE or any of the flags as supported by Intent#fillIn to control which unspecified parts
of the intent that can be supplied when the actual send happens.
Value is either 0 or a combination of FLAG_ONE_SHOT  FLAG_NO_CREATE  FLAG_CANCEL_CURRENT  FLAG_UPDATE_CURRENT  FLAG_IMMUTABLE  Intent.FILL_IN_ACTION  Intent.FILL_IN_DATA  Intent.FILL_IN_CATEGORIES  Intent.FILL_IN_COMPONENT  Intent.FILL_IN_PACKAGE  Intent.FILL_IN_SOURCE_BOUNDS  Intent.FILL_IN_SELECTOR and Intent.FILL_IN_CLIP_DATA |||","PendingIntent Returns an existing or new PendingIntent matching the given
 parameters.  May return null only if FLAG_NO_CREATE has been
 supplied. |||",1,"A description of an Intent and target action to perform with it.  Instances
 of this class are created with  getActivity(Context int Intent int)   getActivities(Context int Intent[] int) 
  getBroadcast(Context int Intent int)  and  getService(Context int Intent int) ; the returned object can be
 handed to other applications so that they can perform the action you
 described on your behalf at a later time.

  By giving a PendingIntent to another application
 you are granting it the right to perform the operation you have specified
 as if the other application was yourself (with the same permissions and
 identity).  As such you should be careful about how you build the PendingIntent:
 almost always for example the base Intent you supply should have the component
 name explicitly set to one of your own components to ensure it is ultimately
 sent there and nowhere else.

  A PendingIntent itself is simply a reference to a token maintained by
 the system describing the original data used to retrieve it.  This means
 that even if its owning application's process is killed the
 PendingIntent itself will remain usable from other processes that
 have been given it.  If the creating application later re-retrieves the
 same kind of PendingIntent (same operation same Intent action data
 categories and components and same flags) it will receive a PendingIntent
 representing the same token if that is still valid and can thus call
  cancel()  to remove it.

  Because of this behavior it is important to know when two Intents
 are considered to be the same for purposes of retrieving a PendingIntent.
 A common mistake people make is to create multiple PendingIntent objects
 with Intents that only vary in their ""extra"" contents expecting to get
 a different PendingIntent each time.  This does  not  happen.  The
 parts of the Intent that are used for matching are the same ones defined
 by  Intent#filterEquals(Intent) .  If you use two
 Intent objects that are equivalent as per
  Intent#filterEquals(Intent)  then you will get
 the same PendingIntent for both of them.

  There are two typical ways to deal with this.

  If you truly need multiple distinct PendingIntent objects active at
 the same time (such as to use as two notifications that are both shown
 at the same time) then you will need to ensure there is something that
 is different about them to associate them with different PendingIntents.
 This may be any of the Intent attributes considered by
  Intent#filterEquals(Intent)  or different
 request code integers supplied to  getActivity(Context int Intent int)   getActivities(Context int Intent[] int) 
  getBroadcast(Context int Intent int)  or  getService(Context int Intent int) .

  If you only need one PendingIntent active at a time for any of the
 Intents you will use then you can alternatively use the flags
  FLAG_CANCEL_CURRENT  or  FLAG_UPDATE_CURRENT  to either
 cancel or modify whatever current PendingIntent is associated with the
 Intent you are supplying.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",IPC,IPC,1,yes,no,SOURCE,no,
<android.webkit.WebView: String getOriginalUrl()>,"Gets the original URL for the current page. This is not always the same
 as the URL passed to WebViewClient.onPageStarted because although the
 load for that URL has begun the current page may not have changed.
 Also there may have been redirects resulting in a different URL to that
 originally requested.",,String the URL that was originally requested for the current page or null if no page has been loaded |||,3,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",no,network ,0,no,no,no,no,
<android.os.Parcel: Object readArray(ClassLoader)>,"Read and return a new Object array from the parcel at the current
 dataPosition().  Returns null if the previously written array was
 null.  The given class loader will be used to load any enclosed
 Parcelables.",loader ClassLoader : This value may be null . |||,Object[] |||,1,"Container for a message (data and object references) that can
 be sent through an IBinder.  A Parcel can contain both flattened data
 that will be unflattened on the other side of the IPC (using the various
 methods here for writing specific types or the general
  Parcelable  interface) and references to live  IBinder 
 objects that will result in the other side receiving a proxy IBinder
 connected with the original IBinder in the Parcel.

  Parcel is  not  a general-purpose
 serialization mechanism.  This class (and the corresponding
  Parcelable  API for placing arbitrary objects into a Parcel) is
 designed as a high-performance IPC transport.  As such it is not
 appropriate to place any Parcel data in to persistent storage: changes
 in the underlying implementation of any of the data in the Parcel can
 render older data unreadable. The bulk of the Parcel API revolves around reading and writing data
 of various types.  There are six major classes of such functions available. Primitives The most basic data functions are for writing and reading primitive
 data types:  writeByte(byte)   readByte()   writeDouble(double) 
  readDouble()   writeFloat(float)   readFloat()   writeInt(int) 
  readInt()   writeLong(long)   readLong() 
  writeString(String)   readString() .  Most other
 data operations are built on top of these.  The given data is written and
 read using the endianess of the host CPU. Primitive Arrays There are a variety of methods for reading and writing raw arrays
 of primitive objects which generally result in writing a 4-byte length
 followed by the primitive data items.  The methods for reading can either
 read the data into an existing array or create and return a new array.
 These available types are: writeBooleanArray(boolean[]) 
  readBooleanArray(boolean[])   createBooleanArray() writeByteArray(byte[]) 
  writeByteArray(byte[] int int)   readByteArray(byte[]) 
  createByteArray() writeCharArray(char[])   readCharArray(char[]) 
  createCharArray() writeDoubleArray(double[])   readDoubleArray(double[]) 
  createDoubleArray() writeFloatArray(float[])   readFloatArray(float[]) 
  createFloatArray() writeIntArray(int[])   readIntArray(int[]) 
  createIntArray() writeLongArray(long[])   readLongArray(long[]) 
  createLongArray() writeStringArray(java.lang.String[])   readStringArray(java.lang.String[]) 
  createStringArray() .
  writeSparseBooleanArray(android.util.SparseBooleanArray) 
  readSparseBooleanArray() .
  Parcelables The  Parcelable  protocol provides an extremely efficient (but
 low-level) protocol for objects to write and read themselves from Parcels.
 You can use the direct methods  writeParcelable(android.os.Parcelable int) 
 and  readParcelable(java.lang.ClassLoader)  or
  writeParcelableArray(T[] int)  and
  readParcelableArray(java.lang.ClassLoader)  to write or read.  These
 methods write both the class type and its data to the Parcel allowing
 that class to be reconstructed from the appropriate class loader when
 later reading. There are also some methods that provide a more efficient way to work
 with Parcelables:  writeTypedObject(T int)   writeTypedArray(T[] int) 
  writeTypedList(List )   readTypedObject(Parcelable.Creator ) 
  createTypedArray(Parcelable.Creator )  and  createTypedArrayList(Parcelable.Creator ) .  These methods
 do not write the class information of the original object: instead the
 caller of the read function must know what type to expect and pass in the
 appropriate  Parcelable.Creator  instead to
 properly construct the new object and read its data.  (To more efficient
 write and read a single Parcelable object that is not null you can directly
 call  Parcelable#writeToParcel  and
  Parcelable.Creator#createFromParcel 
 yourself.) Bundles A special type-safe container called  Bundle  is available
 for key/value maps of heterogeneous values.  This has many optimizations
 for improved performance when reading and writing data and its type-safe
 API avoids difficult to debug type errors when finally marshalling the
 data contents into a Parcel.  The methods to use are
  writeBundle(android.os.Bundle)   readBundle()  and
  readBundle(java.lang.ClassLoader) .

  Active Objects An unusual feature of Parcel is the ability to read and write active
 objects.  For these objects the actual contents of the object is not
 written rather a special token referencing the object is written.  When
 reading the object back from the Parcel you do not get a new instance of
 the object but rather a handle that operates on the exact same object that
 was originally written.  There are two forms of active objects available. Binder  objects are a core facility of Android's general cross-process
 communication system.  The  IBinder  interface describes an abstract
 protocol with a Binder object.  Any such interface can be written in to
 a Parcel and upon reading you will receive either the original object
 implementing that interface or a special proxy implementation
 that communicates calls back to the original object.  The methods to use are
  writeStrongBinder(android.os.IBinder) 
  writeStrongInterface(android.os.IInterface)   readStrongBinder() 
  writeBinderArray(android.os.IBinder[])   readBinderArray(android.os.IBinder[]) 
  createBinderArray() 
  writeBinderList(java.util.List)   readBinderList(java.util.List) 
  createBinderArrayList() . FileDescriptor objects representing raw Linux file descriptor identifiers
 can be written and  ParcelFileDescriptor  objects returned to operate
 on the original file descriptor.  The returned file descriptor is a dup
 of the original file descriptor: the object and fd is different but
 operating on the same underlying file stream with the same position etc.
 The methods to use are  writeFileDescriptor(java.io.FileDescriptor) 
  readFileDescriptor() .

  Untyped Containers A final class of methods are for writing and reading standard Java
 containers of arbitrary types.  These all revolve around the
  writeValue(java.lang.Object)  and  readValue(java.lang.ClassLoader)  methods
 which define the types of objects allowed.  The container methods are
  writeArray(java.lang.Object[])   readArray(java.lang.ClassLoader) 
  writeList(java.util.List)   readList(java.util.List java.lang.ClassLoader) 
  readArrayList(java.lang.ClassLoader) 
  writeMap(java.util.Map)   readMap(java.util.Map java.lang.ClassLoader) 
  writeSparseArray(android.util.SparseArray) 
  readSparseArray(java.lang.ClassLoader) .",,IPC,no,0,no,no,no,no,
<android.database.CursorWindow: CursorWindow newFromParcel(Parcel)>,,p Parcel |||,CursorWindow |||,1,"A buffer containing multiple cursor rows.
  
 A  CursorWindow  is read-write when initially created and used locally.
 When sent to a remote process (by writing it to a  Parcel ) the remote process
 receives a read-only view of the cursor window.  Typically the cursor window
 will be allocated by the producer filled with data and then sent to the
 consumer for reading.","If you need to manage data in a private database use the  android.database.sqlite  classes. These classes are used to manage the  Cursor  object returned from a content provider query. Databases
 are usually created and opened with  openOrCreateDatabase(String int SQLiteDatabase.CursorFactory) 
 To make requests through
 content providers you can use the  content.ContentResolver  class.
  All databases are stored on the device in  /data/data/<package_name>/databases",no,database,0,no,no,no,no,
<android.os.Bundle: Bundle getBundle(String)>,"Returns the value associated with the given key or null if
 no mapping of the desired type exists for the given key or a null
 value is explicitly associated with the key.","key String : a String or null
This value may be null . |||",Bundle a Bundle value or null |||,1,A mapping from String keys to various  Parcelable  values.,,IPC,no,0,no,no,no,no,
<android.app.ListFragment: void onDestroyView()>,Detach from list view.,,void,11,"A fragment that displays a list of items by binding to a data source such as
 an array or Cursor and exposes event handlers when the user selects an item.
  
 ListFragment hosts a  ListView  object that can
 be bound to different data sources typically either an array or a Cursor
 holding query results. Binding screen layout and row layout are discussed
 in the following sections.
  Screen Layout 
 ListFragment has a default layout that consists of a single list view.
 However if you desire you can customize the fragment layout by returning
 your own view hierarchy from  onCreateView(LayoutInflater ViewGroup Bundle) .
 To do this your view hierarchy  must  contain a ListView object with the
 id ""@android:id/list"" (or  R.id.list  if it's in code)
  
 Optionally your view hierarchy can contain another view object of any type to
 display when the list view is empty. This ""empty list"" notifier must have an
 id ""android:empty"". Note that when an empty view is present the list view
 will be hidden when there is no data to display.
  
 The following code demonstrates an (ugly) custom list layout. It has a list
 with a green background and an alternate red ""no data"" message.
  
 <?xml version=""1.0"" encoding=""utf-8""?>
 <LinearLayout xmlns:android=""http://schemas.android.com/apk/res/android""
         android:orientation=""vertical""
         android:layout_width=""match_parent""
         android:layout_height=""match_parent""
         android:paddingLeft=""8dp""
         android:paddingRight=""8dp"">

     <ListView android:id=""@id/android:list""
               android:layout_width=""match_parent""
               android:layout_height=""match_parent""
               android:background=""#00FF00""
               android:layout_weight=""1""
               android:drawSelectorOnTop=""false""/>

     <TextView android:id=""@id/android:empty""
               android:layout_width=""match_parent""
               android:layout_height=""match_parent""
               android:background=""#FF0000""
               android:text=""No data""/>
 </LinearLayout>
  Row Layout 
 You can specify the layout of individual rows in the list. You do this by
 specifying a layout resource in the ListAdapter object hosted by the fragment
 (the ListAdapter binds the ListView to the data; more on this later).
  
 A ListAdapter constructor takes a parameter that specifies a layout resource
 for each row. It also has two additional parameters that let you specify
 which data field to associate with which object in the row layout resource.
 These two parameters are typically parallel arrays.
  
 Android provides some standard row layout resources. These are in the
  R.layout  class and have names such as simple_list_item_1
 simple_list_item_2 and two_line_list_item. The following layout XML is the
 source for the resource two_line_list_item which displays two data
 fieldsone above the other for each list row.
  
 <?xml version=""1.0"" encoding=""utf-8""?>
 <LinearLayout xmlns:android=""http://schemas.android.com/apk/res/android""
     android:layout_width=""match_parent""
     android:layout_height=""wrap_content""
     android:orientation=""vertical"">

     <TextView android:id=""@+id/text1""
         android:textSize=""16sp""
         android:textStyle=""bold""
         android:layout_width=""match_parent""
         android:layout_height=""wrap_content""/>

     <TextView android:id=""@+id/text2""
         android:textSize=""16sp""
         android:layout_width=""match_parent""
         android:layout_height=""wrap_content""/>
 </LinearLayout>
  
 You must identify the data bound to each TextView object in this layout. The
 syntax for this is discussed in the next section.
  Binding to Data 
 You bind the ListFragment's ListView object to data using a class that
 implements the  ListAdapter  interface.
 Android provides two standard list adapters:
  SimpleAdapter  for static data (Maps)
 and  SimpleCursorAdapter  for Cursor
 query results.
  
 You  must  use
  ListFragment.setListAdapter()  to
 associate the list with an adapter.  Do not directly call
  ListView#setAdapter(ListAdapter)  or else
 important initialization will be skipped.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
<android.widget.ProgressBar: void setProgress(int)>,"Sets the current progress to the specified value. Does not do anything
 if the progress bar is in indeterminate mode. This method will immediately update the visual position of the progress
 indicator. To animate the visual position to the target value use setProgress(int boolean) }.",progress int : the new progress between getMin() and getMax() |||,void,1,"A user interface element that indicates the progress of an operation.
 Progress bar supports two modes to represent progress: determinate and indeterminate. For
 a visual overview of the difference between determinate and indeterminate progress modes see
  
 Progress & activity .
 Display progress bars to a user in a non-interruptive way.
 Show the progress bar in your app's user interface or in a notification
 instead of within a dialog.
  Indeterminate Progress 
 Use indeterminate mode for the progress bar when you do not know how long an
 operation will take.
 Indeterminate mode is the default for progress bar and shows a cyclic animation without a
 specific amount of progress indicated.
 The following example shows an indeterminate progress bar:
  
 <ProgressBar
      android:id=""@+id/indeterminateBar""
      android:layout_width=""wrap_content""
      android:layout_height=""wrap_content""
      />
  Determinate Progress 
 Use determinate mode for the progress bar when you want to show that a specific quantity of
 progress has occurred.
 For example the percent remaining of a file being retrieved the amount records in
 a batch written to database or the percent remaining of an audio file that is playing.
  
 To indicate determinate progress you set the style of the progress bar to
  R.style.Widget_ProgressBar_Horizontal  and set the amount of progress.
 The following example shows a determinate progress bar that is 25% complete:
  
 <ProgressBar
      android:id=""@+id/determinateBar""
      style=""@android:style/Widget.ProgressBar.Horizontal""
      android:layout_width=""wrap_content""
      android:layout_height=""wrap_content""
      android:progress=""25""/>
  setProgress(int) incrementProgressBy(int) android:max Other progress bar styles provided by the system include: Widget.ProgressBar.Horizontal Widget.ProgressBar.Small Widget.ProgressBar.Large Widget.ProgressBar.Inverse Widget.ProgressBar.Small.Inverse Widget.ProgressBar.Large.Inverse The ""inverse"" styles provide an inverse color scheme for the spinner which may be necessary
 if your application uses a light colored theme (a white background). XML attributes 
 See  ProgressBar Attributes 
  View Attributes","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,UI,0,no,no,no,no,
<android.media.AudioManager: void registerRemoteControlClient(RemoteControlClient)>,"This method was deprecated
      in API level 21. Use MediaSession instead. Registers the remote control client for providing information to display on the remote
 controls.","rcClient RemoteControlClient : The remote control client from which remote controls will receive
information to display. |||",void,14,AudioManager provides access to volume and ringer mode control.,"The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",no,no,0,no,no,no,no,
<android.os.Parcel: void writeMap(Map)>,"Please use writeBundle(Bundle) instead.  Flattens a Map into the parcel
 at the current dataPosition()
 growing dataCapacity() if needed.  The Map keys must be String objects.
 The Map values are written using writeValue(Object) and must follow
 the specification there. It is strongly recommended to use writeBundle(Bundle) instead of
 this method since the Bundle class provides a type-safe API that
 allows you to avoid mysterious type errors at the point of marshalling.",val Map : This value may be null . |||,void,1,"Container for a message (data and object references) that can
 be sent through an IBinder.  A Parcel can contain both flattened data
 that will be unflattened on the other side of the IPC (using the various
 methods here for writing specific types or the general
  Parcelable  interface) and references to live  IBinder 
 objects that will result in the other side receiving a proxy IBinder
 connected with the original IBinder in the Parcel.

  Parcel is  not  a general-purpose
 serialization mechanism.  This class (and the corresponding
  Parcelable  API for placing arbitrary objects into a Parcel) is
 designed as a high-performance IPC transport.  As such it is not
 appropriate to place any Parcel data in to persistent storage: changes
 in the underlying implementation of any of the data in the Parcel can
 render older data unreadable. The bulk of the Parcel API revolves around reading and writing data
 of various types.  There are six major classes of such functions available. Primitives The most basic data functions are for writing and reading primitive
 data types:  writeByte(byte)   readByte()   writeDouble(double) 
  readDouble()   writeFloat(float)   readFloat()   writeInt(int) 
  readInt()   writeLong(long)   readLong() 
  writeString(String)   readString() .  Most other
 data operations are built on top of these.  The given data is written and
 read using the endianess of the host CPU. Primitive Arrays There are a variety of methods for reading and writing raw arrays
 of primitive objects which generally result in writing a 4-byte length
 followed by the primitive data items.  The methods for reading can either
 read the data into an existing array or create and return a new array.
 These available types are: writeBooleanArray(boolean[]) 
  readBooleanArray(boolean[])   createBooleanArray() writeByteArray(byte[]) 
  writeByteArray(byte[] int int)   readByteArray(byte[]) 
  createByteArray() writeCharArray(char[])   readCharArray(char[]) 
  createCharArray() writeDoubleArray(double[])   readDoubleArray(double[]) 
  createDoubleArray() writeFloatArray(float[])   readFloatArray(float[]) 
  createFloatArray() writeIntArray(int[])   readIntArray(int[]) 
  createIntArray() writeLongArray(long[])   readLongArray(long[]) 
  createLongArray() writeStringArray(java.lang.String[])   readStringArray(java.lang.String[]) 
  createStringArray() .
  writeSparseBooleanArray(android.util.SparseBooleanArray) 
  readSparseBooleanArray() .
  Parcelables The  Parcelable  protocol provides an extremely efficient (but
 low-level) protocol for objects to write and read themselves from Parcels.
 You can use the direct methods  writeParcelable(android.os.Parcelable int) 
 and  readParcelable(java.lang.ClassLoader)  or
  writeParcelableArray(T[] int)  and
  readParcelableArray(java.lang.ClassLoader)  to write or read.  These
 methods write both the class type and its data to the Parcel allowing
 that class to be reconstructed from the appropriate class loader when
 later reading. There are also some methods that provide a more efficient way to work
 with Parcelables:  writeTypedObject(T int)   writeTypedArray(T[] int) 
  writeTypedList(List )   readTypedObject(Parcelable.Creator ) 
  createTypedArray(Parcelable.Creator )  and  createTypedArrayList(Parcelable.Creator ) .  These methods
 do not write the class information of the original object: instead the
 caller of the read function must know what type to expect and pass in the
 appropriate  Parcelable.Creator  instead to
 properly construct the new object and read its data.  (To more efficient
 write and read a single Parcelable object that is not null you can directly
 call  Parcelable#writeToParcel  and
  Parcelable.Creator#createFromParcel 
 yourself.) Bundles A special type-safe container called  Bundle  is available
 for key/value maps of heterogeneous values.  This has many optimizations
 for improved performance when reading and writing data and its type-safe
 API avoids difficult to debug type errors when finally marshalling the
 data contents into a Parcel.  The methods to use are
  writeBundle(android.os.Bundle)   readBundle()  and
  readBundle(java.lang.ClassLoader) .

  Active Objects An unusual feature of Parcel is the ability to read and write active
 objects.  For these objects the actual contents of the object is not
 written rather a special token referencing the object is written.  When
 reading the object back from the Parcel you do not get a new instance of
 the object but rather a handle that operates on the exact same object that
 was originally written.  There are two forms of active objects available. Binder  objects are a core facility of Android's general cross-process
 communication system.  The  IBinder  interface describes an abstract
 protocol with a Binder object.  Any such interface can be written in to
 a Parcel and upon reading you will receive either the original object
 implementing that interface or a special proxy implementation
 that communicates calls back to the original object.  The methods to use are
  writeStrongBinder(android.os.IBinder) 
  writeStrongInterface(android.os.IInterface)   readStrongBinder() 
  writeBinderArray(android.os.IBinder[])   readBinderArray(android.os.IBinder[]) 
  createBinderArray() 
  writeBinderList(java.util.List)   readBinderList(java.util.List) 
  createBinderArrayList() . FileDescriptor objects representing raw Linux file descriptor identifiers
 can be written and  ParcelFileDescriptor  objects returned to operate
 on the original file descriptor.  The returned file descriptor is a dup
 of the original file descriptor: the object and fd is different but
 operating on the same underlying file stream with the same position etc.
 The methods to use are  writeFileDescriptor(java.io.FileDescriptor) 
  readFileDescriptor() .

  Untyped Containers A final class of methods are for writing and reading standard Java
 containers of arbitrary types.  These all revolve around the
  writeValue(java.lang.Object)  and  readValue(java.lang.ClassLoader)  methods
 which define the types of objects allowed.  The container methods are
  writeArray(java.lang.Object[])   readArray(java.lang.ClassLoader) 
  writeList(java.util.List)   readList(java.util.List java.lang.ClassLoader) 
  readArrayList(java.lang.ClassLoader) 
  writeMap(java.util.Map)   readMap(java.util.Map java.lang.ClassLoader) 
  writeSparseArray(android.util.SparseArray) 
  readSparseArray(java.lang.ClassLoader) .",,IPC,no,0,no,no,no,no,
"<android.view.View: View inflate(Context,int,ViewGroup)>",Inflate a view from an XML resource.  This convenience method wraps the LayoutInflater class which provides a full range of options for view inflation.,"context Context : The Context object for your activity or application. |||
resource int : The resource ID to inflate |||
root ViewGroup : A view group that will be the parent.  Used to properly inflate the
layout_* parameters. |||",View |||,1,"This class represents the basic building block for user interface components. A View
 occupies a rectangular area on the screen and is responsible for drawing and
 event handling. View is the base class for  widgets  which are
 used to create interactive UI components (buttons text fields etc.). The
  ViewGroup  subclass is the base class for  layouts  which
 are invisible containers that hold other Views (or other ViewGroups) and define
 their layout properties.",,no,UI,0,no,no,no,no,
"<android.nfc.NfcAdapter: void enableForegroundDispatch(Activity,PendingIntent,IntentFilter,String)>","Enable foreground dispatch to the given Activity. This will give priority to the foreground activity when
 dispatching a discovered Tag to an application. If any IntentFilters are provided to this method they are used to match dispatch Intents
 for both the NfcAdapter#ACTION_NDEF_DISCOVERED and NfcAdapter#ACTION_TAG_DISCOVERED . Since NfcAdapter#ACTION_TECH_DISCOVERED relies on meta data outside of the IntentFilter matching for that dispatch Intent is handled
 by passing in the tech lists separately. Each first level entry in the tech list represents
 an array of technologies that must all be present to match. If any of the first level sets
 match then the dispatch is routed through the given PendingIntent. In other words the second
 level is ANDed together and the first level entries are ORed together. If you pass null for both the filters and techLists parameters
 that acts a wild card and will cause the foreground activity to receive all tags via the NfcAdapter#ACTION_TAG_DISCOVERED intent. This method must be called from the main thread and only when the activity is in the
 foreground (resumed). Also activities must call disableForegroundDispatch(Activity) before
 the completion of their Activity#onPause callback to disable foreground dispatch
 after it has been enabled. Requires the Manifest.permission.NFC permission.","activity Activity : the Activity to dispatch to |||
intent PendingIntent : the PendingIntent to start for the dispatch |||
filters IntentFilter : the IntentFilters to override dispatching for or null to always dispatch |||
techLists String : the tech lists used to perform matching for dispatching of the NfcAdapter#ACTION_TECH_DISCOVERED intent |||",void,10,"Represents the local NFC adapter.
  
 Use the helper  getDefaultAdapter(android.content.Context)  to get the default NFC
 adapter for this Android device.","Provides access to Near Field Communication (NFC) functionality allowing applications to read
 NDEF message in NFC tags. A ""tag"" may actually be another device that appears as a tag. For more information see the
  Near Field Communication  guide. Here's a summary of the classes: NfcManager This is the high level manager used to obtain this device's  NfcAdapter . You can
 acquire an instance using  getSystemService(Class ) . NfcAdapter This represents the device's NFC adapter which is your entry-point to performing NFC
 operations. You can acquire an instance with  getDefaultAdapter()  or
  getDefaultAdapter(android.content.Context) . NdefMessage Represents an NDEF data message which is the standard format in which ""records""
 carrying data are transmitted between devices and tags. Your application can receive these
 messages from an  ACTION_TAG_DISCOVERED  intent. NdefRecord Represents a record which is delivered in a  NdefMessage  and describes the
 type of data being shared and carries the data itself. Note: 
 Not all Android-powered devices provide NFC functionality.",IPC,IPC,1,no,yes,no,SINK,
<android.animation.AnimatorSet: void end()>,"Ends the animation. This causes the animation to assign the end value of the property being
 animated then calling the Animator.AnimatorListener.onAnimationEnd(Animator) method on
 its listeners. This method must be called on the thread that is running the animation. Note that ending a AnimatorSet also ends all of the animations that it is
 responsible for.",,void,11,"This class plays a set of  Animator  objects in the specified order. Animations
 can be set up to play together in sequence or after a specified delay.

  There are two different approaches to adding animations to a  AnimatorSet :
 either the  AnimatorSet#playTogether(Animator[])  or
  AnimatorSet#playSequentially(Animator[])  methods can be called to add
 a set of animations all at once or the  AnimatorSet#play(Animator)  can be
 used in conjunction with methods in the  AnimatorSet.Builder 
 class to add animations
 one by one. It is possible to set up a  AnimatorSet  with circular dependencies between
 its animations. For example an animation a1 could be set up to start before animation a2 a2
 before a3 and a3 before a1. The results of this configuration are undefined but will typically
 result in none of the affected animations being played. Because of this (and because
 circular dependencies do not make logical sense anyway) circular dependencies
 should be avoided and the dependency flow of animations should only be in one direction.","These classes provide functionality for the property animation system which allows you
 to animate object properties of any type.  int   float  and hexadecimal
 color values are supported by default. You can animate any other type by telling the system how
 to calculate the values for that given type with a custom  TypeEvaluator .
  For more information see the
  Animation  guide. 
 You can set many different types of interpolators (contained in  android.view.animation )
 specify  keyframes  or group animations to play sequentially
 or simultaneously (with  AnimatorSet ) to further control your animation
 behaviors.",no,no,0,no,no,no,no,
<android.content.Intent: Intent getIntentOld(String)>,,uri String |||,Intent |||,1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",IPC,no,0,no,no,no,no,
<android.net.sip.SipManager: void open(SipProfile)>,"Opens the profile for making generic SIP calls. The caller may make subsequent calls
 through makeAudioCall(SipProfile SipProfile SipAudioCall.Listener int) . If one also wants to receive calls on the
 profile use open(android.net.sip.SipProfile android.app.PendingIntent android.net.sip.SipRegistrationListener) instead.",localProfile SipProfile : the SIP profile to make calls from |||,void,9,"Provides APIs for SIP tasks such as initiating SIP connections and provides access to related
 SIP services. This class is the starting point for any SIP actions. You can acquire an instance
 of it with  newInstance() . The APIs in this class allows you to: Create a  SipSession  to get ready for making calls or listen for incoming calls. See
  createSipSession()  and  getSessionFor() . Initiate and receive generic SIP calls or audio-only SIP calls. Generic SIP calls may
 be video audio or other and are initiated with  open() . Audio-only SIP calls
 should be handled with a  SipAudioCall  which you can acquire with  makeAudioCall()  and  takeAudioCall() . Register and unregister with a SIP service provider with
       register()  and  unregister() . Verify session connectivity with  isOpened()  and
       isRegistered() . Note:  Not all Android-powered devices support VOIP calls using
 SIP. You should always call  isVoipSupported()  to verify that the device supports VOIP calling and  isApiSupported()  to verify that the device supports
 the SIP APIs. Your application must also request the  Manifest.permission.INTERNET  and  Manifest.permission.USE_SIP 
 permissions.",,no,no,0,no,no,no,no,
<android.nfc.tech.IsoDep: void close()>,"Disable I/O operations to the tag from this TagTechnology object and release resources. Also causes all blocked I/O operations on other thread to be canceled and
 return with IOException . Requires the Manifest.permission.NFC permission.",,void,-1,"Provides access to ISO-DEP (ISO 14443-4) properties and I/O operations on a  Tag .

  Acquire an  IsoDep  object using  get(Tag) .
  The primary ISO-DEP I/O operation is  transceive(byte[]) . Applications must
 implement their own protocol stack on top of  transceive(byte[]) .
  Tags that enumerate the  IsoDep  technology in  Tag#getTechList 
 will also enumerate
  NfcA  or  NfcB  (since IsoDep builds on top of either of these).

  Note:  Methods that perform I/O operations
 require the  Manifest.permission.NFC  permission.","These classes provide access to a tag technology's features which vary by the type
 of tag that is scanned. A scanned tag can support multiple technologies and you can find
 out what they are by calling  getTechList() . For more information on dealing with tag technologies and handling the ones that you care about see
  The Tag Dispatch System .
 The  TagTechnology  interface provides an overview of the
 supported technologies.",no,no,0,no,no,no,no,
"<android.content.ContextWrapper: Intent registerReceiver(BroadcastReceiver,IntentFilter)>","Register a BroadcastReceiver to be run in the main activity thread.  The receiver will be called with any broadcast Intent that
 matches filter in the main application thread. The system may broadcast Intents that are ""sticky"" -- these stay
 around after the broadcast has finished to be sent to any later
 registrations. If your IntentFilter matches one of these sticky
 Intents that Intent will be returned by this function and sent to your receiver as if it had just
 been broadcast. There may be multiple sticky Intents that match filter in which case each of these will be sent to receiver .  In
 this case only one of these can be returned directly by the function;
 which of these that is returned is arbitrarily decided by the system. If you know the Intent your are registering for is sticky you can
 supply null for your receiver .  In this case no receiver is
 registered -- the function simply returns the sticky Intent that
 matches filter .  In the case of multiple matches the same
 rules as described above apply. See BroadcastReceiver for more information on Intent broadcasts. As of Build.VERSION_CODES.ICE_CREAM_SANDWICH receivers
 registered with this method will correctly respect the Intent#setPackage(String) specified for an Intent being broadcast.
 Prior to that it would be ignored and delivered to all matching registered
 receivers.  Be careful if using this for security. Note: this method cannot be called from a BroadcastReceiver component; that is from a BroadcastReceiver
 that is declared in an application's manifest.  It is okay however to call
 this method from another BroadcastReceiver that has itself been registered
 at run time with registerReceiver(BroadcastReceiver IntentFilter) since the lifetime of such a
 registered BroadcastReceiver is tied to the object that registered it.","receiver BroadcastReceiver : The BroadcastReceiver to handle the broadcast.
This value may be null . |||
filter IntentFilter : Selects the Intent broadcasts to be received. |||",Intent The first sticky intent found that matches filter or null if there are none. |||,1,"Proxying implementation of Context that simply delegates all of its calls to
 another Context.  Can be subclassed to modify behavior without changing
 the original Context.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",IPC,IPC,1,yes,no,SOURCE,no,
<android.view.ViewPropertyAnimator: ViewPropertyAnimator rotation(float)>,"This method will cause the View's rotation property to be animated to the
 specified value. Animations already running on the property will be canceled.",value float : The value to be animated to. |||,ViewPropertyAnimator This object allowing calls to methods in this class to be chained. |||,12,"This class enables automatic and optimized animation of select properties on View objects.
 If only one or two properties on a View object are being animated then using an
  ObjectAnimator  is fine; the property setters called by ObjectAnimator
 are well equipped to do the right thing to set the property and invalidate the view
 appropriately. But if several properties are animated simultaneously or if you just want a
 more convenient syntax to animate a specific property then ViewPropertyAnimator might be
 more well-suited to the task.

  This class may provide better performance for several simultaneous animations because
 it will optimize invalidate calls to take place only once for several properties instead of each
 animated property independently causing its own invalidation. Also the syntax of using this
 class could be easier to use because the caller need only tell the View object which
 property to animate and the value to animate either to or by and this class handles the
 details of configuring the underlying Animator class and starting it. This class is not constructed by the caller but rather by the View whose properties
 it will animate. Calls to  View.animate()  will return a reference
 to the appropriate ViewPropertyAnimator object for that View.",,no,UI,0,no,no,no,no,
<android.app.Instrumentation: Bundle getAllocCounts()>,Returns a bundle with the current results from the allocation counting.,,Bundle |||,1,"Base class for implementing application instrumentation code.  When running
 with instrumentation turned on this class will be instantiated for you
 before any of the application code allowing you to monitor all of the
 interaction the system has with the application.  An Instrumentation
 implementation is described to the system through an AndroidManifest.xml's
 <instrumentation> tag.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
"<android.content.pm.ProviderInfo: void writeToParcel(Parcel,int)>",,"out Parcel |||
parcelableFlags int |||",void,1,"Holds information about a specific
  content provider . This is returned by
  PackageManager.resolveContentProvider() .","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",IPC,no,0,no,no,no,no,
<android.content.Intent: String resolveTypeIfNeeded(ContentResolver)>,"Return the MIME data type of this intent only if it will be needed for
 intent resolution.  This is not generally useful for application code;
 it is used by the frameworks for communicating with back-end system
 services.","resolver ContentResolver : A ContentResolver that can be used to determine the MIME
type of the intent's data.
This value must never be null . |||","String The MIME type of this intent or null if it is unknown or not
         needed. |||",1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",IPC,no,0,no,no,no,no,
<android.app.Activity: void registerForContextMenu(View)>,"Registers a context menu to be shown for the given view (multiple views
 can show the context menu). This method will set the OnCreateContextMenuListener on the view to this activity so onCreateContextMenu(android.view.ContextMenu android.view.View android.view.ContextMenu.ContextMenuInfo) will be
 called when it is time to show the context menu.",view View : The view that should show a context menu. |||,void,1,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
"<android.widget.TextView: void setCompoundDrawablesRelativeWithIntrinsicBounds(int,int,int,int)>","Sets the Drawables (if any) to appear to the start of above to the end
 of and below the text. Use 0 if you do not want a Drawable there. The
 Drawables' bounds will be set to their intrinsic bounds. Calling this method will overwrite any Drawables previously set using setCompoundDrawables(Drawable Drawable Drawable Drawable) or related methods. Related XML Attributes: android:drawableStart 
android:drawableTop 
android:drawableEnd 
android:drawableBottom","start int : Resource identifier of the start Drawable. |||
top int : Resource identifier of the top Drawable. |||
end int : Resource identifier of the end Drawable. |||
bottom int : Resource identifier of the bottom Drawable. |||",void,17,"A user interface element that displays text to the user.
 To provide user-editable text see  EditText .
  
 The following code sample shows a typical use with an XML layout
 and code to modify the contents of the text view:
  
 <LinearLayout
      xmlns:android=""http://schemas.android.com/apk/res/android""
      android:layout_width=""match_parent""
      android:layout_height=""match_parent"">
    <TextView
        android:id=""@+id/text_view_id""
        android:layout_height=""wrap_content""
        android:layout_width=""wrap_content""
        android:text=""@string/hello"" />
 </LinearLayout>
  
 This code sample demonstrates how to modify the contents of the text view
 defined in the previous XML layout:
  
 public class MainActivity extends Activity {

    protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_main);
         final TextView helloTextView = (TextView) findViewById(R.id.text_view_id);
         helloTextView.setText(R.string.user_greeting);
     }
 }
  
 To customize the appearance of TextView see  Styles and Themes .
  XML attributes 
 See  TextView Attributes 
  View Attributes","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,UI,0,no,no,no,no,
<android.net.sip.SipSession: SipProfile getLocalProfile()>,Gets the SIP profile that this session is associated with.,,SipProfile the SIP profile that this session is associated with |||,9,"Represents a SIP session that is associated with a SIP dialog or a standalone
 transaction not within a dialog.
  You can get a  SipSession  from  SipManager  with  SipManager#createSipSession  (when initiating calls) or  SipManager#getSessionFor  (when receiving calls).",,phone metadata,phone,1,yes,no,SOURCE,no,
"<android.preference.Preference: View getView(View,ViewGroup)>",Gets the View that will be shown in the PreferenceActivity .,"convertView View : The old View to reuse if possible. Note: You should
check that this View is non-null and of an appropriate type
before using. If it is not possible to convert this View to
display the correct data this method can create a new View. |||
parent ViewGroup : The parent that this View will eventually be attached to. |||","View Returns the same Preference object for chaining multiple calls
         into a single statement. |||",1,"Represents the basic Preference UI building
 block displayed by a  PreferenceActivity  in the form of a
  ListView . This class provides the  View  to be displayed in
 the activity and associates with a  SharedPreferences  to
 store/retrieve the preference data.
  
 When specifying a preference hierarchy in XML each element can point to a
 subclass of  Preference  similar to the view hierarchy and layouts.
  
 This class contains a  key  that will be used as the key into the
  SharedPreferences . It is up to the subclass to decide how to store
 the value.",,no,UI,0,no,no,no,no,
<android.telephony.SmsMessage: SmsMessage createFromPdu(byte)>,"This method was deprecated
      in API level 23. Use createFromPdu(byte[] java.lang.String) instead. Create an SmsMessage from a raw PDU. Guess format based on Voice
 technology first if it fails use other format.
 All applications which handle
 incoming SMS messages by processing the SMS_RECEIVED_ACTION broadcast
 intent must now pass the new format String extra from the intent
 into the new method createFromPdu(byte[] String) which takes an
 extra format parameter. This is required in order to correctly decode the PDU on
 devices that require support for both 3GPP and 3GPP2 formats at the same time
 such as dual-mode GSM/CDMA and CDMA/LTE phones.",pdu byte |||,SmsMessage |||,4,A Short Message Service message.,,sms message,no,0,no,no,no,no,
"<android.accounts.AccountManager: void setPassword(Account,String)>","Sets or forgets a saved password. This modifies the local copy of the
 password used to automatically authenticate the user; it does not change
 the user's account password on the server. Intended for use by the
 authenticator not directly by applications. Calling this method does not update the last authenticated timestamp
 referred by KEY_LAST_AUTHENTICATED_TIME . To update it call notifyAccountAuthenticated(android.accounts.Account) after getting success. It is safe to call this method from the main thread. This method requires the caller to have a signature match with the
 authenticator that manages the specified account. NOTE: If targeting your app to work on API level 22 and before
 AUTHENTICATE_ACCOUNTS permission and same UID as account's authenticator
 is needed for those platforms. See docs for this function in API level 22. Requires android.Manifest.permission.AUTHENTICATE_ACCOUNTS","account Account : The account whose password is to be set. Cannot be null . |||
password String : The password to set null to clear the password |||",void,5,"This class provides access to a centralized registry of the user's
 online accounts.  The user enters credentials (username and password) once
 per account granting applications access to online resources with
 ""one-click"" approval.

  Different online services have different ways of handling accounts and
 authentication so the account manager uses pluggable  authenticator 
 modules for different  account types .  Authenticators (which may be
 written by third parties) handle the actual details of validating account
 credentials and storing account information.  For example Google Facebook
 and Microsoft Exchange each have their own authenticator.

  Many servers support some notion of an  authentication token 
 which can be used to authenticate a request to the server without sending
 the user's actual password.  (Auth tokens are normally created with a
 separate request which does include the user's credentials.)  AccountManager
 can generate auth tokens for applications so the application doesn't need to
 handle passwords directly.  Auth tokens are normally reusable and cached by
 AccountManager but must be refreshed periodically.  It's the responsibility
 of applications to  invalidate  auth tokens when they stop working so
 the AccountManager knows it needs to regenerate them.

  Applications accessing a server normally go through these steps:

  Get an instance of AccountManager using  get(android.content.Context) .

  List the available accounts using  getAccountsByType(String)  or
  getAccountsByTypeAndFeatures(String String[] AccountManagerCallback  Handler) .  Normally applications will only
 be interested in accounts with one particular  type  which
 identifies the authenticator.  Account  features  are used to
 identify particular account subtypes and capabilities.  Both the account
 type and features are authenticator-specific strings and must be known by
 the application in coordination with its preferred authenticators.

  Select one or more of the available accounts possibly by asking the
 user for their preference.  If no suitable accounts are available
  addAccount(String String String[] Bundle Activity AccountManagerCallback  Handler)  may be called to prompt the user to create an
 account of the appropriate type.

  Important:  If the application is using a previously remembered
 account selection it must make sure the account is still in the list
 of accounts returned by  getAccountsByType(String) .  Requesting an auth token
 for an account no longer on the device results in an undefined failure.

  Request an auth token for the selected account(s) using one of the
  getAuthToken(Account String Bundle Activity AccountManagerCallback  Handler)  methods or related helpers.  Refer to the description
 of each method for exact usage and error handling details.

  Make the request using the auth token.  The form of the auth token
 the format of the request and the protocol used are all specific to the
 service you are accessing.  The application may use whatever network and
 protocol libraries are useful.

  Important:  If the request fails with an authentication error
 it could be that a cached auth token is stale and no longer honored by
 the server.  The application must call  invalidateAuthToken(String String)  to remove
 the token from the cache otherwise requests will continue failing!  After
 invalidating the auth token immediately go back to the ""Request an auth
 token"" step above.  If the process fails the second time then it can be
 treated as a ""genuine"" authentication failure and the user notified or other
 appropriate actions taken.
  Some AccountManager methods may need to interact with the user to
 prompt for credentials present options or ask the user to add an account.
 The caller may choose whether to allow AccountManager to directly launch the
 necessary user interface and wait for the user or to return an Intent which
 the caller may use to launch the interface or (in some cases) to install a
 notification which the user can select at any time to launch the interface.
 To have AccountManager launch the interface directly the caller must supply
 the current foreground  Activity  context.

  Many AccountManager methods take  AccountManagerCallback  and
  Handler  as parameters.  These methods return immediately and
 run asynchronously. If a callback is provided then
  AccountManagerCallback#run  will be invoked on the Handler's
 thread when the request completes successfully or not.
 The result is retrieved by calling  AccountManagerFuture#getResult() 
 on the  AccountManagerFuture  returned by the method (and also passed
 to the callback).  This method waits for the operation to complete (if
 necessary) and either returns the result or throws an exception if an error
 occurred during the operation.  To make the request synchronously call
  AccountManagerFuture#getResult()  immediately on receiving the
 future from the method; no callback need be supplied.

  Requests which may block including
  AccountManagerFuture#getResult()  must never be called on
 the application's main event thread.  These operations throw
  IllegalStateException  if they are used on the main thread.",,password data,password file ,1,no,yes,no,SINK,
"<android.view.View: void measure(int,int)>","This is called to find out how big a view should be. The parent
 supplies constraint information in the width and height parameters. The actual measurement work of a view is performed in onMeasure(int int) called by this method. Therefore only onMeasure(int int) can and must be overridden by subclasses.","widthMeasureSpec int : Horizontal space requirements as imposed by the
parent |||
heightMeasureSpec int : Vertical space requirements as imposed by the
parent |||",void,1,"This class represents the basic building block for user interface components. A View
 occupies a rectangular area on the screen and is responsible for drawing and
 event handling. View is the base class for  widgets  which are
 used to create interactive UI components (buttons text fields etc.). The
  ViewGroup  subclass is the base class for  layouts  which
 are invisible containers that hold other Views (or other ViewGroups) and define
 their layout properties.",,no,UI,0,no,no,no,no,
"<android.view.ViewGroup: void addView(View,int)>","Adds a child view. If no layout parameters are already set on the child the
 default parameters for this ViewGroup are set on the child. Note: do not invoke this method from View.draw(android.graphics.Canvas)  View.onDraw(android.graphics.Canvas)  dispatchDraw(android.graphics.Canvas) or any related method.","child View : the child view to add |||
index int : the position at which to add the child |||",void,1,"A  ViewGroup  is a special view that can contain other views
 (called children.) The view group is the base class for layouts and views
 containers. This class also defines the
  ViewGroup.LayoutParams  class which serves as the base
 class for layouts parameters.
  
 Also see  LayoutParams  for layout attributes.",,no,UI,0,no,no,no,no,
"<android.drm.DrmManagerClient: int checkRightsStatus(Uri,int)>",Checks whether the given rights-protected content has valid rights for the specified DrmStore.Action .,"uri Uri : URI for the rights-protected content. |||
action int : The DrmStore.Action to perform. |||",int An int representing the DrmStore.RightsStatus of the content. |||,11,"The main programming interface for the DRM framework. An application must instantiate this class
 to access DRM agents through the DRM framework.","Provides classes for managing DRM content and determining the capabilities of DRM plugins
 (agents). Common uses of the DRM API include: Determining which DRM plug-ins (agents) are installed on a device. Retrieving information about specific plug-ins such as the MIME types and file suffixes
   they support. Registering a user or a device with an online DRM service. Retrieving license constraints for rights-protected content. Checking whether a user has the proper rights to play or use rights-protected
   content. Associating rights-protected content with its license so you can use the
    MediaPlayer  API to play the content.",no,no,0,no,no,no,no,
<android.net.SSLCertificateSocketFactory: Socket createSocket()>,"Creates a new socket which is not connected to any remote host.
 You must use Socket#connect to connect the socket. Warning: Hostname verification is not performed
 with this method.  You MUST verify the server's identity after connecting
 the socket to avoid man-in-the-middle attacks.",,Socket the unconnected socket |||,1,"SSLSocketFactory implementation with several extra features:

  Timeout specification for SSL handshake operations
  Hostname verification in most cases (see WARNINGs below)
  Optional SSL session caching with  SSLSessionCache Optionally bypass all SSL certificate checks
  createSocket() Socket#connect(java.net.SocketAddress int) The recommended way to verify the server's identity is to use
  HttpsURLConnection#getDefaultHostnameVerifier()  to get a
  HostnameVerifier  to verify the certificate hostname.

  Warning : Some methods on this class return connected sockets and some return
 unconnected sockets.  For the methods that return connected sockets setting
 connection- or handshake-related properties on those sockets will have no effect.

  On development devices ""setprop socket.relaxsslcheck yes"" bypasses all
 SSL certificate and hostname checks for testing purposes.  This setting
 requires root access.",,no,IPC,0,no,no,no,no,
<android.app.Instrumentation: void callActivityOnDestroy(Activity)>,,activity Activity |||,void,1,"Base class for implementing application instrumentation code.  When running
 with instrumentation turned on this class will be instantiated for you
 before any of the application code allowing you to monitor all of the
 interaction the system has with the application.  An Instrumentation
 implementation is described to the system through an AndroidManifest.xml's
 <instrumentation> tag.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
"<android.content.ContextWrapper: void sendOrderedBroadcastAsUser(Intent,UserHandle,String,BroadcastReceiver,Handler,int,String,Bundle)>","Version of sendOrderedBroadcast(android.content.Intent java.lang.String android.content.BroadcastReceiver android.os.Handler int java.lang.String android.os.Bundle) that allows you to specify the
 user the broadcast will be sent to.  This is not available to applications
 that are not pre-installed on the system image. See BroadcastReceiver for more information on Intent broadcasts. Requires android.Manifest.permission.INTERACT_ACROSS_USERS","intent Intent : The Intent to broadcast; all receivers matching this
Intent will receive the broadcast. |||
user UserHandle : UserHandle to send the intent to. |||
receiverPermission String : String naming a permissions that
a receiver must hold in order to receive your broadcast.
If null no permission is required.
This value may be null . |||
resultReceiver BroadcastReceiver : Your own BroadcastReceiver to treat as the final
receiver of the broadcast. |||
scheduler Handler : A custom Handler with which to schedule the
resultReceiver callback; if null it will be
scheduled in the Context's main thread.
This value may be null . |||
initialCode int : An initial value for the result code.  Often
Activity.RESULT_OK. |||
initialData String : An initial value for the result data.  Often
null.
This value may be null . |||
initialExtras Bundle : An initial value for the result extras.  Often
null.
This value may be null . |||",void,17,"Proxying implementation of Context that simply delegates all of its calls to
 another Context.  Can be subclassed to modify behavior without changing
 the original Context.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",IPC,IPC,1,no,yes,no,SINK,
"<android.preference.PreferenceFragment: View onCreateView(LayoutInflater,ViewGroup,Bundle)>","Called to have the fragment instantiate its user interface view.
 This is optional and non-graphical fragments can return null (which
 is the default implementation).  This will be called between onCreate(android.os.Bundle) and onActivityCreated(android.os.Bundle) . If you return a View from here you will later be called in onDestroyView() when the view is being released.","inflater LayoutInflater : The LayoutInflater object that can be used to inflate
any views in the fragment |||
container ViewGroup : This value may be null . |||
savedInstanceState Bundle : This value may be null . |||",View Return the View for the fragment's UI or null. |||,11,"Represents the basic Preference UI building
 block displayed by a  PreferenceActivity  in the form of a
  ListView . This class provides the  View  to be displayed in
 the activity and associates with a  SharedPreferences  to
 store/retrieve the preference data.
  
 When specifying a preference hierarchy in XML each element can point to a
 subclass of  Preference  similar to the view hierarchy and layouts.
  
 This class contains a  key  that will be used as the key into the
  SharedPreferences . It is up to the subclass to decide how to store
 the value.",,uncategorized,UI,1,no,yes,no,SINK,
<android.app.admin.DevicePolicyManager: int getCurrentFailedPasswordAttempts()>,"Retrieve the number of times the user has failed at entering a password since that last
 successful password entry. This method can be called on the DevicePolicyManager instance returned by getParentProfileInstance(android.content.ComponentName) in order to retrieve the number of failed
 password attemts for the parent user. The calling device admin must have requested DeviceAdminInfo#USES_POLICY_WATCH_LOGIN to be able to call this method; if it has not a security exception will be thrown. On devices not supporting PackageManager#FEATURE_SECURE_LOCK_SCREEN feature the
 password is always empty and this method always returns 0. Requires the PackageManager#FEATURE_SECURE_LOCK_SCREEN feature which can be detected using PackageManager.hasSystemFeature(String) .",,"int The number of times user has entered an incorrect password since the last correct
         password entry. |||",8,"Public interface for managing policies enforced on a device. Most clients of this class must be
 registered with the system as a  device
 administrator . Additionally a device administrator may be registered as either a profile or
 device owner. A given method is accessible to all device administrators unless the documentation
 for that method specifies that it is restricted to either device or profile owners. Any
 application calling an api may only pass as an argument a device administrator component it
 owns. Otherwise a  SecurityException  will be thrown.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",password metadata,password file ,1,yes,no,SOURCE,no,
<android.widget.Chronometer: void stop()>,"Stop counting up.  This does not affect the base as set from setBase(long) just
 the view display.

 This stops the messages to the handler effectively releasing resources that would
 be held as the chronometer is running via start() .",,void,1,"Class that implements a simple timer.
  
 You can give it a start time in the  SystemClock#elapsedRealtime  timebase
 and it counts up from that or if you don't give it a base time it will use the
 time at which you call  start() .

  The timer can also count downward towards the base time by
 setting  setCountDown(boolean)  to true.

   By default it will display the current
 timer value in the form ""MM:SS"" or ""H:MM:SS"" or you can use  setFormat(String) 
 to format the timer value into an arbitrary string.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,no,0,no,no,no,no,
<android.os.Bundle: void putAll(Bundle)>,Inserts all mappings from the given Bundle into this Bundle.,bundle Bundle : a Bundle |||,void,1,A mapping from String keys to various  Parcelable  values.,,IPC,no,0,no,no,no,no,
<android.widget.MediaController: void show()>,"Show the controller on screen. It will go away
 automatically after 3 seconds of inactivity.",,void,1,"A view containing controls for a MediaPlayer. Typically contains the
 buttons like ""Play/Pause"" ""Rewind"" ""Fast Forward"" and a progress
 slider. It takes care of synchronizing the controls with the state
 of the MediaPlayer.
  
 The way to use this class is to instantiate it programmatically.
 The MediaController will create a default set of controls
 and put them in a window floating above your application. Specifically
 the controls will float above the view specified with setAnchorView().
 The window will disappear if left idle for three seconds and reappear
 when the user touches the anchor view.
  
 Functions like show() and hide() have no effect when MediaController
 is created in an xml layout.

 MediaController will hide and
 show the buttons according to these rules:
   The ""previous"" and ""next"" buttons are hidden until setPrevNextListeners()
   has been called
   The ""previous"" and ""next"" buttons are visible but disabled if
   setPrevNextListeners() was called with null listeners
   The ""rewind"" and ""fastforward"" buttons are shown unless requested
   otherwise by using the MediaController(Context boolean) constructor
   with the boolean set to false","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,no,0,no,no,no,no,
<android.app.WallpaperManager: int getDesiredMinimumHeight()>,"Returns the desired minimum height for the wallpaper. Callers of setBitmap(android.graphics.Bitmap) or setStream(java.io.InputStream) should check this value
 beforehand to make sure the supplied wallpaper respects the desired
 minimum height.

 If the returned value is <= 0 the caller should use the height of
 the default display instead.",,"int The desired minimum height for the wallpaper. This value should
 be honored by applications that set the wallpaper but it is not
 mandatory. |||",5,"Provides access to the system wallpaper. With WallpaperManager you can
 get the current wallpaper get the desired dimensions for the wallpaper set
 the wallpaper and more.

   An app can check whether wallpapers are supported for the current user by calling
  isWallpaperSupported()  and whether setting of wallpapers is allowed by calling
  isSetWallpaperAllowed() .","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,UI,0,no,no,no,no,
"<android.app.Activity: void onPanelClosed(int,Menu)>","Default implementation of Window.Callback.onPanelClosed(int Menu) for
 activities. This calls through to onOptionsMenuClosed(android.view.Menu) method for the Window.FEATURE_OPTIONS_PANEL panel
 so that subclasses of Activity don't need to deal with feature codes.
 For context menus ( Window#FEATURE_CONTEXT_MENU ) the onContextMenuClosed(android.view.Menu) will be called.","featureId int : The panel that is being displayed. |||
menu Menu : This value must never be null . |||",void,1,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",uncategorized,UI,1,no,yes,no,SINK,
<android.content.ContextWrapper: void setWallpaper(Bitmap)>,This method is deprecated. Use WallpaperManager.set() instead. This method requires the caller to hold the permission Manifest.permission.SET_WALLPAPER .,bitmap Bitmap |||,void,1,"Proxying implementation of Context that simply delegates all of its calls to
 another Context.  Can be subclassed to modify behavior without changing
 the original Context.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",image,UI,1,no,yes,no,SINK,
<android.app.TaskStackBuilder: TaskStackBuilder addParentStack(Class)>,"Add the activity parent chain as specified by the parentActivityName attribute of the activity
 (or activity-alias) element in the application's manifest to the task stack builder.",sourceActivityClass Class : All parents of this activity will be added |||,TaskStackBuilder This TaskStackBuilder for method chaining |||,16,"Utility class for constructing synthetic back stacks for cross-task navigation
 on Android 3.0 and newer.

  In API level 11 (Android 3.0/Honeycomb) the recommended conventions for
 app navigation using the back key changed. The back key's behavior is local
 to the current task and does not capture navigation across different tasks.
 Navigating across tasks and easily reaching the previous task is accomplished
 through the ""recents"" UI accessible through the software-provided Recents key
 on the navigation or system bar. On devices with the older hardware button configuration
 the recents UI can be accessed with a long press on the Home key. When crossing from one task stack to another post-Android 3.0
 the application should synthesize a back stack/history for the new task so that
 the user may navigate out of the new task and back to the Launcher by repeated
 presses of the back key. Back key presses should not navigate across task stacks. TaskStackBuilder provides a way to obey the correct conventions
 around cross-task navigation.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
<android.net.sip.SipSession: void endCall()>,"Ends an established call terminates an outgoing call or rejects an
 incoming call. The method is only valid to call when the session state is
 in State#IN_CALL  State#INCOMING_CALL  State#OUTGOING_CALL or State#OUTGOING_CALL_RING_BACK .",,void,9,"Represents a SIP session that is associated with a SIP dialog or a standalone
 transaction not within a dialog.
  You can get a  SipSession  from  SipManager  with  SipManager#createSipSession  (when initiating calls) or  SipManager#getSessionFor  (when receiving calls).",,no,no,0,no,no,no,no,
<android.animation.ValueAnimator: void start()>,"Starts this animation. If the animation has a nonzero startDelay the animation will start
 running after that delay elapses. A non-delayed animation will have its initial
 value(s) set immediately followed by calls to AnimatorListener#onAnimationStart(Animator) for any listeners of this animator. The animation started by calling this method will be run on the thread that called
 this method. This thread should have a Looper on it (a runtime exception will be thrown if
 this is not the case). Also if the animation will animate
 properties of objects in the view hierarchy then the calling thread should be the UI
 thread for that view hierarchy.",,void,11,"This class provides a simple timing engine for running animations
 which calculate animated values and set them on target objects.

  There is a single timing pulse that all animations use. It runs in a
 custom handler to ensure that property changes happen on the UI thread. By default ValueAnimator uses non-linear time interpolation via the
  AccelerateDecelerateInterpolator  class which accelerates into and decelerates
 out of an animation. This behavior can be changed by calling
  ValueAnimator#setInterpolator(TimeInterpolator) . Animators can be created from either code or resource files. Here is an example
 of a ValueAnimator resource file: <animator xmlns:android=""http://schemas.android.com/apk/res/android""
    android:duration=""1000""
    android:valueFrom=""1""
    android:valueTo=""0""
    android:valueType=""floatType""
    android:repeatCount=""1""
    android:repeatMode=""reverse""/> Starting from API 23 it is also possible to use a combination of  PropertyValuesHolder 
 and  Keyframe  resource tags to create a multi-step animation.
 Note that you can specify explicit fractional values (from 0 to 1) for
 each keyframe to determine when in the overall duration the animation should arrive at that
 value. Alternatively you can leave the fractions off and the keyframes will be equally
 distributed within the total duration: <animator xmlns:android=""http://schemas.android.com/apk/res/android""
          android:duration=""1000""
          android:repeatCount=""1""
          android:repeatMode=""reverse"">
    <propertyValuesHolder>
        <keyframe android:fraction=""0"" android:value=""1""/>
        <keyframe android:fraction="".2"" android:value="".4""/>
        <keyframe android:fraction=""1"" android:value=""0""/>
    </propertyValuesHolder>
</animator>","These classes provide functionality for the property animation system which allows you
 to animate object properties of any type.  int   float  and hexadecimal
 color values are supported by default. You can animate any other type by telling the system how
 to calculate the values for that given type with a custom  TypeEvaluator .
  For more information see the
  Animation  guide. 
 You can set many different types of interpolators (contained in  android.view.animation )
 specify  keyframes  or group animations to play sequentially
 or simultaneously (with  AnimatorSet ) to further control your animation
 behaviors.",no,no,0,no,no,no,no,
"<android.net.SSLCertificateSocketFactory: Socket createSocket(String,int,InetAddress,int)>","Creates a socket and connects it to the specified remote host
 on the specified remote port.
 The socket will also be bound to the local address and port supplied.
 This socket is configured using
 the socket options established for this factory. If there is a security manager its checkConnect method is called with the host address and port as its arguments. This could result in a SecurityException. By default this method returns a connected socket and verifies the peer's
 certificate hostname after connecting using the HostnameVerifier obtained from HttpsURLConnection.getDefaultHostnameVerifier() ; if this instance was created with getInsecure(int android.net.SSLSessionCache) it returns a socket that is not connected instead.","host String : the server host name with which to connect or null for the loopback address. |||
port int : the server port |||
localAddr InetAddress : the local address the socket is bound to |||
localPort int : the local port the socket is bound to |||",Socket the Socket |||,1,"SSLSocketFactory implementation with several extra features:

  Timeout specification for SSL handshake operations
  Hostname verification in most cases (see WARNINGs below)
  Optional SSL session caching with  SSLSessionCache Optionally bypass all SSL certificate checks
  createSocket() Socket#connect(java.net.SocketAddress int) The recommended way to verify the server's identity is to use
  HttpsURLConnection#getDefaultHostnameVerifier()  to get a
  HostnameVerifier  to verify the certificate hostname.

  Warning : Some methods on this class return connected sockets and some return
 unconnected sockets.  For the methods that return connected sockets setting
 connection- or handshake-related properties on those sockets will have no effect.

  On development devices ""setprop socket.relaxsslcheck yes"" bypasses all
 SSL certificate and hostname checks for testing purposes.  This setting
 requires root access.",,no,network ,0,no,no,no,no,
<android.view.accessibility.AccessibilityManager: List getEnabledAccessibilityServiceList(int)>,"Returns the AccessibilityServiceInfo s of the enabled accessibility services
 for a given feedback type.",feedbackTypeFlags int : The feedback type flags. |||,List < AccessibilityServiceInfo > An unmodifiable list with AccessibilityServiceInfo s. |||,14,"System level service that serves as an event dispatch for  AccessibilityEvent s
 and provides facilities for querying the accessibility state of the system.
 Accessibility events are generated when something notable happens in the user interface
 for example an  Activity  starts the focus or selection of a
  View  changes etc. Parties interested in handling accessibility
 events implement and register an accessibility service which extends
  AccessibilityService .",,no,no,0,no,no,no,no,
<android.app.ProgressDialog: void incrementSecondaryProgressBy(int)>,Increments the current secondary progress value.,"diff int : the amount by which the current secondary progress will be incremented
up to getMax() |||",void,1,"A dialog showing a progress indicator and an optional text message or view.
 Only a text message or a view can be used at the same time.

  The dialog can be made cancelable on back key press. The progress range is 0 to  max .","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
<android.os.Looper: void loop()>,Run the message queue in this thread. Be sure to call quit() to end the loop.,,void,1,"Class used to run a message loop for a thread.  Threads by default do
 not have a message loop associated with them; to create one call
  prepare()  in the thread that is to run the loop and then
  loop()  to have it process messages until the loop is stopped.

  Most interaction with a message loop is through the
  Handler  class.

  This is a typical example of the implementation of a Looper thread
 using the separation of  prepare()  and  loop()  to create an
 initial Handler to communicate with the Looper.

  
  class LooperThread extends Thread {
      public Handler mHandler;

      public void run() {
          Looper.prepare();

          mHandler = new Handler() {
              public void handleMessage(Message msg) {
                  // process incoming messages here
              }
          };

          Looper.loop();
      }
  }",,no,no,0,no,no,no,no,
<android.content.ContextWrapper: int checkCallingPermission(String)>,"Determine whether the calling process of an IPC you are handling has been
 granted a particular permission.  This is basically the same as calling checkPermission(java.lang.String int int) with the pid and uid returned
 by Binder.getCallingPid() and Binder.getCallingUid() .  One important difference
 is that if you are not currently processing an IPC this function
 will always fail.  This is done to protect against accidentally
 leaking permissions; you can use checkCallingOrSelfPermission(String) to avoid this protection.","permission String : The name of the permission being checked.
This value must never be null . |||","int PackageManager#PERMISSION_GRANTED if the calling
 pid/uid is allowed that permission or PackageManager#PERMISSION_DENIED if it is not.

 Value is PackageManager.PERMISSION_GRANTED or PackageManager.PERMISSION_DENIED |||",1,"Proxying implementation of Context that simply delegates all of its calls to
 another Context.  Can be subclassed to modify behavior without changing
 the original Context.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,IPC,0,no,no,no,no,
<android.view.InputDevice: int getDeviceIds()>,Gets the ids of all input devices in the system.,,int[] The input device ids. |||,9,"Describes the capabilities of a particular input device.
  
 Each input device may support multiple classes of input.  For example a multi-function
 keyboard may compose the capabilities of a standard keyboard together with a track pad mouse
 or other pointing device.
  
 Some input devices present multiple distinguishable sources of input.
 Applications can query the framework about the characteristics of each distinct source.
  
 As a further wrinkle different kinds of input sources uses different coordinate systems
 to describe motion events.  Refer to the comments on the input source constants for
 the appropriate interpretation.",,input device metadata,input device,1,yes,no,SOURCE,no,
<android.view.ViewTreeObserver: void dispatchOnGlobalLayout()>,"Notifies registered listeners that a global layout happened. This can be called
 manually if you are forcing a layout on a View or a hierarchy of Views that are
 not attached to a Window or in the GONE state.",,void,1,"A view tree observer is used to register listeners that can be notified of global
 changes in the view tree. Such global events include but are not limited to
 layout of the whole tree beginning of the drawing pass touch mode change....

 A ViewTreeObserver should never be instantiated by applications as it is provided
 by the views hierarchy. Refer to  View.getViewTreeObserver() 
 for more information.",,no,UI,0,no,no,no,no,
<android.content.Intent: Intent getIntent(String)>,"This method was deprecated
      in API level 15. Use parseUri(String int) instead. Call parseUri(String int) with 0 flags.",uri String |||,Intent |||,1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",IPC,file ,1,yes,no,SOURCE,no,
<android.telephony.SmsManager: ArrayList divideMessage(String)>,Divide a message text into several fragments none bigger than the maximum SMS message size.,text String : the original message. Must not be null. |||,ArrayList < String > an ArrayList of strings that in order comprise the original message. |||,4,"Manages SMS operations such as sending data text and pdu SMS messages.
 Get this object by calling the static method  getDefault() . To create an instance of
  SmsManager  associated with a specific subscription ID call
  getSmsManagerForSubscriptionId(int) . This is typically used for devices that support
 multiple active subscriptions at once.

  For information about how to behave as the default SMS app on Android 4.4 (API level 19)
 and higher see  Telephony .",,sms message,no,0,no,no,no,no,
"<android.widget.SimpleAdapter: void setViewText(TextView,String)>","Called by bindView() to set the text for a TextView but only if
 there is no existing ViewBinder or if the existing ViewBinder cannot
 handle binding to a TextView.","v TextView : TextView to receive text |||
text String : the text to be set for the TextView |||",void,1,"An easy adapter to map static data to views defined in an XML file. You can specify the data
 backing the list as an ArrayList of Maps. Each entry in the ArrayList corresponds to one row
 in the list. The Maps contain the data for each row. You also specify an XML file that
 defines the views used to display the row and a mapping from keys in the Map to specific
 views.

 Binding data to views occurs in two phases. First if a
  SimpleAdapter.ViewBinder  is available
  ViewBinder#setViewValue(android.view.View Object String) 
 is invoked. If the returned value is true binding has occurred.
 If the returned value is false the following views are then tried in order:
   A view that implements Checkable (e.g. CheckBox).  The expected bind value is a boolean.
   TextView.  The expected bind value is a string and  setViewText(android.widget.TextView java.lang.String) 
 is invoked.
   ImageView. The expected bind value is a resource id or a string and
  setViewImage(android.widget.ImageView int)  or  setViewImage(android.widget.ImageView java.lang.String)  is invoked.
  IllegalStateException","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",uncategorized,UI,1,no,yes,no,SINK,
"<android.content.ContentResolver: void cancelSync(Account,String)>","Cancel any active or pending syncs that match account and authority. The account and
 authority can each independently be set to null which means that syncs with any account
 or authority respectively will match.","account Account : filters the syncs that match by this account |||
authority String : filters the syncs that match by this authority |||",void,5,This class provides applications access to the content model.,"Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,
<android.net.Proxy: int getPort(Context)>,"This method was deprecated
      in API level 15. Use standard java vm proxy values to find the host port
         and exclusion list.  This call ignores the exclusion list. Return the proxy port set by the user.",ctx Context : A Context used to get the settings for the proxy port. |||,int The port number to use or -1 if no proxy is to be used. |||,1,"A convenience class for accessing the user and default proxy
 settings.",,network info,network ,1,yes,no,SOURCE,no,
"<android.test.TouchUtils: void dragViewToBottom(ActivityInstrumentationTestCase,View)>","This method was deprecated
      in API level 15. ActivityInstrumentationTestCase is deprecated in favor of ActivityInstrumentationTestCase2 which provides more options for
 configuring the Activity under test Simulate touching the center of a view and dragging to the bottom of the screen.","test ActivityInstrumentationTestCase : The test case that is being run |||
v View : The view that should be dragged |||",void,1,"Reusable methods for generating touch events. These methods can be used with
 InstrumentationTestCase or ActivityInstrumentationTestCase2 to simulate user interaction with
 the application through a touch screen.",,no,no,0,no,no,no,no,
<android.view.inputmethod.InputMethodManager: InputMethodSubtype getLastInputMethodSubtype()>,,,InputMethodSubtype |||,14,"Central system API to the overall input method framework (IMF) architecture
 which arbitrates interaction between applications and the current input method.

  Topics covered here:
  Architecture Overview Applications Input Methods Security Architecture Overview There are three primary parties involved in the input method
 framework (IMF) architecture:  The  input method manager  as expressed by this class
 is the central point of the system that manages interaction between all
 other parts.  It is expressed as the client-side API here which exists
 in each application context and communicates with a global system service
 that manages the interaction across all processes.
   An  input method (IME)  implements a particular
 interaction model allowing the user to generate text.  The system binds
 to the current input method that is in use causing it to be created and run
 and tells it when to hide and show its UI.  Only one IME is running at a time.
   Multiple  client applications  arbitrate with the input
 method manager for input focus and control over the state of the IME.  Only
 one such client is ever active (working with the IME) at a time.
  Applications In most cases applications that are using the standard
  TextView  or its subclasses will have little they need
 to do to work well with soft input methods.  The main things you need to
 be aware of are:  Properly set the  R.attr.inputType  in your editable
 text views so that the input method will have enough context to help the
 user in entering text into them.
   Deal well with losing screen space when the input method is
 displayed.  Ideally an application should handle its window being resized
 smaller but it can rely on the system performing panning of the window
 if needed.  You should set the  R.attr.windowSoftInputMode 
 attribute on your activity or the corresponding values on windows you
 create to help the system determine whether to pan or resize (it will
 try to determine this automatically but may get it wrong).
   You can also control the preferred soft input state (open closed etc)
 for your window using the same  R.attr.windowSoftInputMode 
 attribute.
  More finer-grained control is available through the APIs here to directly
 interact with the IMF and its IME -- either showing or hiding the input
 area letting the user pick an input method etc. For the rare people amongst us writing their own text editors you
 will need to implement  View.onCreateInputConnection(EditorInfo) 
 to return a new instance of your own  InputConnection  interface
 allowing the IME to interact with your editor. Input Methods An input method (IME) is implemented
 as a  Service  typically deriving from
  InputMethodService .  It must provide
 the core  InputMethod  interface though this is normally handled by
  InputMethodService  and implementors will
 only need to deal with the higher-level API there. InputMethodService Security There are a lot of security issues associated with input methods
 since they essentially have freedom to completely drive the UI and monitor
 everything the user enters.  The Android input method framework also allows
 arbitrary third party IMEs so care must be taken to restrict their
 selection and interactions. Here are some key points about the security architecture behind the
 IMF: Only the system is allowed to directly access an IME's
  InputMethod  interface via the
  Manifest.permission.BIND_INPUT_METHOD  permission.  This is
 enforced in the system by not binding to an input method service that does
 not require this permission so the system can guarantee no other untrusted
 clients are accessing the current input method outside of its control. There may be many client processes of the IMF but only one may
 be active at a time.  The inactive clients can not interact with key
 parts of the IMF through the mechanisms described below. Clients of an input method are only given access to its
  InputMethodSession  interface.  One instance of this interface is
 created for each client and only calls from the session associated with
 the active client will be processed by the current IME.  This is enforced
 by  AbstractInputMethodService  for normal
 IMEs but must be explicitly handled by an IME that is customizing the
 raw  InputMethodSession  implementation. Only the active client's  InputConnection  will accept
 operations.  The IMF tells each client process whether it is active and
 the framework enforces that in inactive processes calls on to the current
 InputConnection will be ignored.  This ensures that the current IME can
 only deliver events and text edits to the UI that the user sees as
 being in focus. An IME can never interact with an  InputConnection  while
 the screen is off.  This is enforced by making all clients inactive while
 the screen is off and prevents bad IMEs from driving the UI when the user
 can not be aware of its behavior. A client application can ask that the system let the user pick a
 new IME but can not programmatically switch to one itself.  This avoids
 malicious applications from switching the user to their own IME which
 remains running when the user navigates away to another application.  An
 IME on the other hand  is  allowed to programmatically switch
 the system to another IME since it already has full control of user
 input. The user must explicitly enable a new IME in settings before
 they can switch to it to confirm with the system that they know about it
 and want to make it available for use. PackageManager#FEATURE_INPUT_METHODS PackageManager.hasSystemFeature(String)",,no,no,0,no,no,no,no,
"<android.view.inputmethod.InputMethodManager: void toggleSoftInputFromWindow(IBinder,int,int)>","This method toggles the input method window display.
 If the input window is already displayed it gets hidden.
 If not the input window will be displayed.","windowToken IBinder : The token of the window that is making the request
as returned by View#getWindowToken() . |||
showFlags int : Provides additional operating flags.  May be
0 or have the SHOW_IMPLICIT  SHOW_FORCED bit set. |||
hideFlags int : Provides additional operating flags.  May be
0 or have the HIDE_IMPLICIT_ONLY  HIDE_NOT_ALWAYS bit set.
* @apiSince 3 |||",void,-1,"Central system API to the overall input method framework (IMF) architecture
 which arbitrates interaction between applications and the current input method.

  Topics covered here:
  Architecture Overview Applications Input Methods Security Architecture Overview There are three primary parties involved in the input method
 framework (IMF) architecture:  The  input method manager  as expressed by this class
 is the central point of the system that manages interaction between all
 other parts.  It is expressed as the client-side API here which exists
 in each application context and communicates with a global system service
 that manages the interaction across all processes.
   An  input method (IME)  implements a particular
 interaction model allowing the user to generate text.  The system binds
 to the current input method that is in use causing it to be created and run
 and tells it when to hide and show its UI.  Only one IME is running at a time.
   Multiple  client applications  arbitrate with the input
 method manager for input focus and control over the state of the IME.  Only
 one such client is ever active (working with the IME) at a time.
  Applications In most cases applications that are using the standard
  TextView  or its subclasses will have little they need
 to do to work well with soft input methods.  The main things you need to
 be aware of are:  Properly set the  R.attr.inputType  in your editable
 text views so that the input method will have enough context to help the
 user in entering text into them.
   Deal well with losing screen space when the input method is
 displayed.  Ideally an application should handle its window being resized
 smaller but it can rely on the system performing panning of the window
 if needed.  You should set the  R.attr.windowSoftInputMode 
 attribute on your activity or the corresponding values on windows you
 create to help the system determine whether to pan or resize (it will
 try to determine this automatically but may get it wrong).
   You can also control the preferred soft input state (open closed etc)
 for your window using the same  R.attr.windowSoftInputMode 
 attribute.
  More finer-grained control is available through the APIs here to directly
 interact with the IMF and its IME -- either showing or hiding the input
 area letting the user pick an input method etc. For the rare people amongst us writing their own text editors you
 will need to implement  View.onCreateInputConnection(EditorInfo) 
 to return a new instance of your own  InputConnection  interface
 allowing the IME to interact with your editor. Input Methods An input method (IME) is implemented
 as a  Service  typically deriving from
  InputMethodService .  It must provide
 the core  InputMethod  interface though this is normally handled by
  InputMethodService  and implementors will
 only need to deal with the higher-level API there. InputMethodService Security There are a lot of security issues associated with input methods
 since they essentially have freedom to completely drive the UI and monitor
 everything the user enters.  The Android input method framework also allows
 arbitrary third party IMEs so care must be taken to restrict their
 selection and interactions. Here are some key points about the security architecture behind the
 IMF: Only the system is allowed to directly access an IME's
  InputMethod  interface via the
  Manifest.permission.BIND_INPUT_METHOD  permission.  This is
 enforced in the system by not binding to an input method service that does
 not require this permission so the system can guarantee no other untrusted
 clients are accessing the current input method outside of its control. There may be many client processes of the IMF but only one may
 be active at a time.  The inactive clients can not interact with key
 parts of the IMF through the mechanisms described below. Clients of an input method are only given access to its
  InputMethodSession  interface.  One instance of this interface is
 created for each client and only calls from the session associated with
 the active client will be processed by the current IME.  This is enforced
 by  AbstractInputMethodService  for normal
 IMEs but must be explicitly handled by an IME that is customizing the
 raw  InputMethodSession  implementation. Only the active client's  InputConnection  will accept
 operations.  The IMF tells each client process whether it is active and
 the framework enforces that in inactive processes calls on to the current
 InputConnection will be ignored.  This ensures that the current IME can
 only deliver events and text edits to the UI that the user sees as
 being in focus. An IME can never interact with an  InputConnection  while
 the screen is off.  This is enforced by making all clients inactive while
 the screen is off and prevents bad IMEs from driving the UI when the user
 can not be aware of its behavior. A client application can ask that the system let the user pick a
 new IME but can not programmatically switch to one itself.  This avoids
 malicious applications from switching the user to their own IME which
 remains running when the user navigates away to another application.  An
 IME on the other hand  is  allowed to programmatically switch
 the system to another IME since it already has full control of user
 input. The user must explicitly enable a new IME in settings before
 they can switch to it to confirm with the system that they know about it
 and want to make it available for use. PackageManager#FEATURE_INPUT_METHODS PackageManager.hasSystemFeature(String)",,no,no,0,no,no,no,no,
"<android.database.sqlite.SQLiteDatabase: void execSQL(String,Object)>","Execute a single SQL statement that is NOT a SELECT/INSERT/UPDATE/DELETE. For INSERT statements use any of the following instead. insert(java.lang.String java.lang.String android.content.ContentValues) 
insertOrThrow(java.lang.String java.lang.String android.content.ContentValues) 
insertWithOnConflict(java.lang.String java.lang.String android.content.ContentValues int) 
For UPDATE statements use any of the following instead. update(java.lang.String android.content.ContentValues java.lang.String java.lang.String[]) 
updateWithOnConflict(java.lang.String android.content.ContentValues java.lang.String java.lang.String[] int) 
For DELETE statements use any of the following instead. delete(java.lang.String java.lang.String java.lang.String[]) 
For example the following are good candidates for using this method: ALTER TABLE 
CREATE or DROP table / trigger / view / index / virtual table 
REINDEX 
RELEASE 
SAVEPOINT 
PRAGMA that returns no data 
When using enableWriteAheadLogging() journal_mode is
 automatically managed by this class. So do not set journal_mode
 using ""PRAGMA journal_mode' "" statement if your app is using enableWriteAheadLogging()","sql String : the SQL statement to be executed. Multiple statements separated by semicolons are
not supported. |||
bindArgs Object : only byte[] String Long and Double are supported in bindArgs. |||",void,1,"Exposes methods to manage a SQLite database.

  
 SQLiteDatabase has methods to create delete execute SQL commands and
 perform other common database management tasks.
  
 See the Notepad sample application in the SDK for an example of creating
 and managing a database.
  
 Database names must be unique within an application not across all applications.
  Localized Collation - ORDER BY 
 In addition to SQLite's default  BINARY  collator Android supplies
 two more  LOCALIZED  which changes with the system's current locale
 and  UNICODE  which is the Unicode Collation Algorithm and not tailored
 to the current locale.","If you need to manage data in a private database use the  android.database.sqlite  classes. These classes are used to manage the  Cursor  object returned from a content provider query. Databases
 are usually created and opened with  openOrCreateDatabase(String int SQLiteDatabase.CursorFactory) 
 To make requests through
 content providers you can use the  content.ContentResolver  class.
  All databases are stored on the device in  /data/data/<package_name>/databases",no,database,0,no,no,no,no,
<android.net.http.SslCertificate: SslCertificate restoreState(Bundle)>,Restores the certificate stored in the bundle,bundle Bundle : The bundle with the certificate state stored in it |||,SslCertificate The SSL certificate stored in the bundle or null if fails |||,1,SSL certificate info (certificate details) class,,no,no,0,no,no,no,no,
"<android.app.admin.DevicePolicyManager: void setPasswordMinimumSymbols(ComponentName,int)>","Called by an application that is administering the device to set the minimum number of
 symbols required in the password. After setting this the user will not be able to enter a
 new password that is not at least as restrictive as what has been set. Note that the current
 password will remain until the user has set a new one so the change does not take place
 immediately. To prompt the user for a new password use ACTION_SET_NEW_PASSWORD or ACTION_SET_NEW_PARENT_PROFILE_PASSWORD after setting this value. This constraint is
 only imposed if the administrator has also requested PASSWORD_QUALITY_COMPLEX with setPasswordQuality(ComponentName int) . If an app targeting SDK level Build.VERSION_CODES.R and above enforces this constraint without settings
 password quality to PASSWORD_QUALITY_COMPLEX first this method will throw IllegalStateException . The default value is 1. On devices not supporting PackageManager#FEATURE_SECURE_LOCK_SCREEN feature the
 password is always treated as empty. The calling device admin must have requested DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD to be able to call this method; if it has
 not a security exception will be thrown. This method can be called on the DevicePolicyManager instance returned by getParentProfileInstance(android.content.ComponentName) in order to set restrictions on the parent
 profile.","admin ComponentName : Which DeviceAdminReceiver this request is associated with.
This value must never be null . |||
length int : The new desired minimum number of symbols required in the password. A value of
0 means there is no restriction. |||",void,11,"Public interface for managing policies enforced on a device. Most clients of this class must be
 registered with the system as a  device
 administrator . Additionally a device administrator may be registered as either a profile or
 device owner. A given method is accessible to all device administrators unless the documentation
 for that method specifies that it is restricted to either device or profile owners. Any
 application calling an api may only pass as an argument a device administrator component it
 owns. Otherwise a  SecurityException  will be thrown.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,password file ,0,no,no,no,no,
<android.webkit.WebView: void setOverScrollMode(int)>,"Set the over-scroll mode for this view. Valid over-scroll modes are OVER_SCROLL_ALWAYS  OVER_SCROLL_IF_CONTENT_SCROLLS (allow over-scrolling only if the view content is larger than the container)
 or OVER_SCROLL_NEVER .

 Setting the over-scroll mode of a view will have an effect only if the
 view is capable of scrolling.",mode int : The new over-scroll mode for this view. |||,void,9,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",no,no,0,no,no,no,no,
<android.media.MediaPlayer: void start()>,"Starts or resumes playback. If playback had previously been paused
 playback will continue from where it was paused. If playback had
 been stopped or never started before playback will start at the
 beginning.",,void,1,"MediaPlayer class can be used to control playback
 of audio/video files and streams. An example on how to use the methods in
 this class can be found in  VideoView .

  Topics covered here are:
  State Diagram Valid and Invalid States Permissions Register informational and error callbacks","The Media APIs are used to play and in some cases record media files. This includes
 audio (e.g. play MP3s or other music files ringtones game sound effects or DTMF tones)
 and video (e.g. play a video streamed over the web or from local storage).
  Other special classes in the package offer the ability to detect the faces of people
 in Bitmaps ( FaceDetector ) control audio routing (to the device or a headset)
 and control alerts such as ringtones and phone vibrations ( AudioManager ).",no,no,0,no,no,no,no,
<android.webkit.WebView: WebSettings getSettings()>,"Gets the WebSettings object used to control the settings for this
 WebView.",,"WebSettings a WebSettings object that can be used to control this WebView's
         settings
 
 This value will never be null . |||",1,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",network info,network ,1,yes,no,SOURCE,no,
<android.inputmethodservice.InputMethodService: void updateInputViewShown()>,"Re-evaluate whether the soft input area should currently be shown and
 update its UI if this has changed since the last time it
 was evaluated.  This will call onEvaluateInputViewShown() to
 determine whether the input view should currently be shown.  You
 can use isInputViewShown() to determine if the input view
 is currently shown.",,void,3,"InputMethodService provides a standard implementation of an InputMethod
 which final implementations can derive from and customize.  See the
 base class  AbstractInputMethodService  and the  InputMethod 
 interface for more information on the basics of writing input methods.

  In addition to the normal Service lifecycle methods this class
 introduces some new specific callbacks that most subclasses will want
 to make use of: onInitializeInterface()  for user-interface initialization
 in particular to deal with configuration changes while the service is
 running.
  onBindInput()  to find out about switching to a new client.
  onStartInput(EditorInfo boolean)  to deal with an input session starting with
 the client.
  onCreateInputView()   onCreateCandidatesView() 
 and  onCreateExtractTextView()  for non-demand generation of the UI.
  onStartInputView(android.view.inputmethod.EditorInfo boolean)  to deal with input
 starting within the input area of the IME.
  An input method has significant discretion in how it goes about its
 work: the  InputMethodService  provides
 a basic framework for standard UI elements (input view candidates view
 and running in fullscreen mode) but it is up to a particular implementor
 to decide how to use them.  For example one input method could implement
 an input area with a keyboard another could allow the user to draw text
 while a third could have no input area (and thus not be visible to the
 user) but instead listen to audio and perform text to speech conversion. In the implementation provided here all of these elements are placed
 together in a single window managed by the InputMethodService.  It will
 execute callbacks as it needs information about them and provides APIs for
 programmatic control over them.  They layout of these elements is explicitly
 defined: The soft input view if available is placed at the bottom of the
 screen.
  The candidates view if currently shown is placed above the soft
 input view.
  If not running fullscreen the application is moved or resized to be
 above these views; if running fullscreen the window will completely cover
 the application and its top part will contain the extract text of what is
 currently being edited by the application.
  Soft Input View Central to most input methods is the soft input view.  This is where most
 user interaction occurs: pressing on soft keys drawing characters or
 however else your input method wants to generate text.  Most implementations
 will simply have their own view doing all of this work and return a new
 instance of it when  onCreateInputView()  is called.  At that point
 as long as the input view is visible you will see user interaction in
 that view and can call back on the InputMethodService to interact with the
 application as appropriate. There are some situations where you want to decide whether or not your
 soft input view should be shown to the user.  This is done by implementing
 the  onEvaluateInputViewShown()  to return true or false based on
 whether it should be shown in the current environment.  If any of your
 state has changed that may impact this call
  updateInputViewShown()  to have it re-evaluated.  The default
 implementation always shows the input view unless there is a hard
 keyboard available which is the appropriate behavior for most input
 methods. Candidates View Often while the user is generating raw text an input method wants to
 provide them with a list of possible interpretations of that text that can
 be selected for use.  This is accomplished with the candidates view and
 like the soft input view you implement  onCreateCandidatesView() 
 to instantiate your own view implementing your candidates UI. Management of the candidates view is a little different than the input
 view because the candidates view tends to be more transient being shown
 only when there are possible candidates for the current text being entered
 by the user.  To control whether the candidates view is shown you use
  setCandidatesViewShown(boolean) .  Note that because the candidate
 view tends to be shown and hidden a lot it does not impact the application
 UI in the same way as the soft input view: it will never cause application
 windows to resize only cause them to be panned if needed for the user to
 see the current focus. Fullscreen Mode Sometimes your input method UI is too large to integrate with the
 application UI so you just want to take over the screen.  This is
 accomplished by switching to full-screen mode causing the input method
 window to fill the entire screen and add its own ""extracted text"" editor
 showing the user the text that is being typed.  Unlike the other UI elements
 there is a standard implementation for the extract editor that you should
 not need to change.  The editor is placed at the top of the IME above the
 input and candidates views. Similar to the input view you control whether the IME is running in
 fullscreen mode by implementing  onEvaluateFullscreenMode() 
 to return true or false based on
 whether it should be fullscreen in the current environment.  If any of your
 state has changed that may impact this call
  updateFullscreenMode()  to have it re-evaluated.  The default
 implementation selects fullscreen mode when the screen is in a landscape
 orientation which is appropriate behavior for most input methods that have
 a significant input area. When in fullscreen mode you have some special requirements because the
 user can not see the application UI.  In particular you should implement
  onDisplayCompletions(android.view.inputmethod.CompletionInfo[])  to show completions
 generated by your application typically in your candidates view like you
 would normally show candidates.


  Generating Text The key part of an IME is of course generating text for the application.
 This is done through calls to the
  InputConnection  interface to the
 application which can be retrieved from  getCurrentInputConnection() .
 This interface allows you to generate raw key events or if the target
 supports it directly edit in strings of candidates and committed text. Information about what the target is expected and supports can be found
 through the  EditorInfo  class which is
 retrieved with  getCurrentInputEditorInfo()  method.  The most
 important part of this is  EditorInfo.inputType ; in particular if this is
  EditorInfo.TYPE_NULL 
 then the target does not support complex edits and you need to only deliver
 raw key events to it.  An input method will also want to look at other
 values here to for example detect password mode auto complete text views
 phone number entry etc. When the user switches between input targets you will receive calls to
  onFinishInput()  and  onStartInput(android.view.inputmethod.EditorInfo boolean) .
 You can use these to reset and initialize your input state for the current
 target.  For example you will often want to clear any input state and
 update a soft keyboard to be appropriate for the new inputType.",,no,no,0,no,no,no,no,
<android.webkit.WebView: String getTitle()>,"Gets the title for the current page. This is the title of the current page
 until WebViewClient.onReceivedTitle is called.",,String the title for the current page or null if no page has been loaded |||,1,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",uncategorized,network ,1,yes,no,no,no,
"<android.content.Intent: Intent putExtra(String,double)>","Add extended data to the intent.  The name must include a package
 prefix for example the app com.android.contacts would use names
 like ""com.android.contacts.ShowAll"".","name String : The name of the extra data with package prefix. |||
value double : The double data value. |||","Intent Returns the same Intent object for chaining multiple calls
 into a single statement.

 This value will never be null . |||",1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",IPC,no,0,no,no,no,no,
<android.content.ContentProvider: ContentProviderResult applyBatch(ArrayList)>,,operations ArrayList : This value must never be null . |||,ContentProviderResult[] This value will never be null . |||,5,"Content providers are one of the primary building blocks of Android applications providing
 content to applications. They encapsulate data and provide it to applications through the single
  ContentResolver  interface. A content provider is only required if you need to share
 data between multiple applications. For example the contacts data is used by multiple
 applications and must be stored in a content provider. If you don't need to share data amongst
 multiple applications you can use a database directly via
  SQLiteDatabase .

  When a request is made via
 a  ContentResolver  the system inspects the authority of the given URI and passes the
 request to the content provider registered with the authority. The content provider can interpret
 the rest of the URI however it wants. The  UriMatcher  class is helpful for parsing
 URIs. The primary methods that need to be implemented are:
  onCreate()  which is called to initialize the provider query(Uri String[] Bundle CancellationSignal)  which returns data to the caller insert(Uri ContentValues)  which inserts new data into the content provider update(Uri ContentValues String String[])  which updates existing data in the content provider delete(Uri String String[])  which deletes data from the content provider getType(Uri)  which returns the MIME type of data in the content provider Requests to  ContentResolver  are automatically forwarded to the appropriate
 ContentProvider instance so subclasses don't have to worry about the details of
 cross-process calls.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",database data,database,1,yes,no,SOURCE,no,
<android.webkit.WebView: void setWebChromeClient(WebChromeClient)>,"Sets the chrome handler. This is an implementation of WebChromeClient for
 use in handling JavaScript dialogs favicons titles and the progress.
 This will replace the current handler.","client WebChromeClient : an implementation of WebChromeClient
This value may be null . |||",void,1,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",no,network ,0,no,no,no,no,
<android.widget.TabWidget: void addView(View)>,"Adds a child view. If no layout parameters are already set on the child the
 default parameters for this ViewGroup are set on the child. Note: do not invoke this method from View.draw(android.graphics.Canvas)  View.onDraw(android.graphics.Canvas)  dispatchDraw(android.graphics.Canvas) or any related method.",child View : the child view to add |||,void,1,"Displays a list of tab labels representing each page in the parent's tab
 collection.
  
 The container object for this widget is  TabHost .
 When the user selects a tab this object sends a message to the parent
 container TabHost to tell it to switch the displayed page. You typically
 won't use many methods directly on this object. The container TabHost is
 used to add labels add the callback handler and manage callbacks. You
 might call this object to iterate the list of tabs or to tweak the layout
 of the tab list but most methods should be called on the containing TabHost
 object.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,no,0,no,no,no,no,
"<android.content.pm.PackageItemInfo: XmlResourceParser loadXmlMetaData(PackageManager,String)>","Load an XML resource attached to the meta-data of this item.  This will
 retrieved the name meta-data entry and if defined call back on the
 given PackageManager to load its XML file from the application.","pm PackageManager : A PackageManager from which the XML can be loaded; usually
the PackageManager from which you originally retrieved this item. |||
name String : Name of the meta-date you would like to load. |||","XmlResourceParser Returns an XmlPullParser you can use to parse the XML file
 assigned as the given meta-data.  If the meta-data name is not defined
 or the XML resource could not be found null is returned. |||",1,"Base class containing information common to all package items held by
 the package manager.  This provides a very common basic set of attributes:
 a label icon and meta-data.  This class is not intended
 to be used by itself; it is simply here to share common definitions
 between all items returned by the package manager.  As such it does not
 itself implement Parcelable but does provide convenience methods to assist
 in the implementation of Parcelable in subclasses.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,
<android.app.NativeActivity: void onLowMemory()>,"This is called when the overall system is running low on memory and
 actively running processes should trim their memory usage.  While
 the exact point at which this will be called is not defined generally
 it will happen when all background process have been killed.
 That is before reaching the point of killing processes hosting
 service and foreground UI that we would like to avoid killing. You should implement this method to release
 any caches or other unnecessary resources you may be holding on to.
 The system will perform a garbage collection for you after returning from this method. Preferably you should implement ComponentCallbacks2#onTrimMemory from ComponentCallbacks2 to incrementally unload your resources based on various
 levels of memory demands.  That API is available for API level 14 and higher so you should
 only use this onLowMemory() method as a fallback for older versions which can be
 treated the same as ComponentCallbacks2#onTrimMemory with the ComponentCallbacks2#TRIM_MEMORY_COMPLETE level.",,void,9,"Convenience for implementing an activity that will be implemented
 purely in native code.  That is a game (or game-like thing).  There
 is no need to derive from this class; you can simply declare it in your
 manifest and use the NDK APIs from there.

  A  sample
 native activity  is available in the NDK samples.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
"<android.database.sqlite.SQLiteQueryBuilder: Cursor query(SQLiteDatabase,String,String,String,String,String,String,String)>","Perform a query by combining all current settings and the
 information passed into this method.","db SQLiteDatabase : the database to query on |||
projectionIn String : A list of which columns to return. Passing
null will return all columns which is discouraged to prevent
reading data from storage that isn't going to be used. |||
selection String : A filter declaring which rows to return
formatted as an SQL WHERE clause (excluding the WHERE itself). Passing null will return all rows for the given URL. |||
selectionArgs String : You may include ?s in selection which
will be replaced by the values from selectionArgs in order
that they appear in the selection. The values will be bound
as Strings. |||
groupBy String : A filter declaring how to group rows formatted
as an SQL GROUP BY clause (excluding the GROUP BY itself). Passing null will cause the rows to not be grouped. |||
having String : A filter declare which row groups to include in
the cursor if row grouping is being used formatted as an
SQL HAVING clause (excluding the HAVING itself).  Passing
null will cause all row groups to be included and is
required when row grouping is not being used. |||
sortOrder String : How to order the rows formatted as an SQL ORDER BY clause (excluding the ORDER BY itself). Passing null
will use the default sort order which may be unordered. |||
limit String : Limits the number of rows returned by the query
formatted as LIMIT clause. Passing null denotes no LIMIT clause. |||",Cursor a cursor over the result set |||,1,"This is a convenience class that helps build SQL queries to be sent to
  SQLiteDatabase  objects.","If you need to manage data in a private database use the  android.database.sqlite  classes. These classes are used to manage the  Cursor  object returned from a content provider query. Databases
 are usually created and opened with  openOrCreateDatabase(String int SQLiteDatabase.CursorFactory) 
 To make requests through
 content providers you can use the  content.ContentResolver  class.
  All databases are stored on the device in  /data/data/<package_name>/databases",database data,database,1,yes,no,SOURCE,no,
<android.widget.MediaController: void show(int)>,"Show the controller on screen. It will go away
 automatically after 'timeout' milliseconds of inactivity.","timeout int : The timeout in milliseconds. Use 0 to show
the controller until hide() is called. |||",void,1,"A view containing controls for a MediaPlayer. Typically contains the
 buttons like ""Play/Pause"" ""Rewind"" ""Fast Forward"" and a progress
 slider. It takes care of synchronizing the controls with the state
 of the MediaPlayer.
  
 The way to use this class is to instantiate it programmatically.
 The MediaController will create a default set of controls
 and put them in a window floating above your application. Specifically
 the controls will float above the view specified with setAnchorView().
 The window will disappear if left idle for three seconds and reappear
 when the user touches the anchor view.
  
 Functions like show() and hide() have no effect when MediaController
 is created in an xml layout.

 MediaController will hide and
 show the buttons according to these rules:
   The ""previous"" and ""next"" buttons are hidden until setPrevNextListeners()
   has been called
   The ""previous"" and ""next"" buttons are visible but disabled if
   setPrevNextListeners() was called with null listeners
   The ""rewind"" and ""fastforward"" buttons are shown unless requested
   otherwise by using the MediaController(Context boolean) constructor
   with the boolean set to false","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,no,0,no,no,no,no,
<android.content.ContextWrapper: PackageManager getPackageManager()>,Return PackageManager instance to find global package information.,,PackageManager |||,1,"Proxying implementation of Context that simply delegates all of its calls to
 another Context.  Can be subclassed to modify behavior without changing
 the original Context.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,
<android.content.Context: String getString(int)>,"Returns a localized string from the application's package's
 default string table.",resId int : Resource id for the string |||,"String The string data associated with the resource stripped of styled
         text information.
 
 This value will never be null . |||",1,"Interface to global information about an application environment.  This is
 an abstract class whose implementation is provided by
 the Android system.  It
 allows access to application-specific resources and classes as well as
 up-calls for application-level operations such as launching activities
 broadcasting and receiving intents etc.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,on,no,no,
"<android.app.Fragment: void startActivity(Intent,Bundle)>","Call Activity#startActivity(Intent Bundle) from the fragment's
 containing Activity.","intent Intent : The intent to start. |||
options Bundle : Additional options for how the Activity should be started.
See Context.startActivity(Intent Bundle) Context.startActivity(Intent Bundle)} for more details. |||",void,16,"A Fragment is a piece of an application's user interface or behavior
 that can be placed in an  Activity .  Interaction with fragments
 is done through  FragmentManager  which can be obtained via
  Activity#getFragmentManager()  and
  Fragment#getFragmentManager() .

  The Fragment class can be used many ways to achieve a wide variety of
 results. In its core it represents a particular operation or interface
 that is running within a larger  Activity .  A Fragment is closely
 tied to the Activity it is in and can not be used apart from one.  Though
 Fragment defines its own lifecycle that lifecycle is dependent on its
 activity: if the activity is stopped no fragments inside of it can be
 started; when the activity is destroyed all fragments will be destroyed.

  All subclasses of Fragment must include a public no-argument constructor.
 The framework will often re-instantiate a fragment class when needed
 in particular during state restore and needs to be able to find this
 constructor to instantiate it.  If the no-argument constructor is not
 available a runtime exception will occur in some cases during state
 restore.

  Topics covered here:
  Older Platforms Lifecycle Layout Back Stack","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",IPC,IPC,1,no,yes,no,SINK,
<android.app.DialogFragment: void onCreate(Bundle)>,"Called to do initial creation of a fragment.  This is called after onAttach(android.app.Activity) and before onCreateView(android.view.LayoutInflater android.view.ViewGroup android.os.Bundle) but is not called if the fragment
 instance is retained across Activity re-creation (see setRetainInstance(boolean) ). Note that this can be called while the fragment's activity is
 still in the process of being created.  As such you can not rely
 on things like the activity's content view hierarchy being initialized
 at this point.  If you want to do work once the activity itself is
 created see onActivityCreated(android.os.Bundle) . If your app's targetSdkVersion is Build.VERSION_CODES.M or lower child fragments being restored from the savedInstanceState are restored after onCreate returns. When targeting Build.VERSION_CODES.N or
 above and running on an N or newer platform version
 they are restored by Fragment.onCreate .","savedInstanceState Bundle : If the fragment is being re-created from
a previous saved state this is the state.
This value may be null . |||",void,11,"Base class for Dialogs.

  Note: Activities provide a facility to manage the creation saving and
 restoring of dialogs. See  Activity#onCreateDialog(int) 
  Activity#onPrepareDialog(int Dialog) 
  Activity#showDialog(int)  and  Activity#dismissDialog(int) . If
 these methods are used  getOwnerActivity()  will return the Activity
 that managed this dialog.

  Often you will want to have a Dialog display on top of the current
 input method because there is no reason for it to accept text.  You can
 do this by setting the  WindowManager.LayoutParams#FLAG_ALT_FOCUSABLE_IM  window flag (assuming
 your Dialog takes input focus as it the default) with the following code:

  
 getWindow().setFlags(WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM
         WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
"<android.drm.DrmManagerClient: int getDrmObjectType(Uri,String)>","Retrieves the type of rights-protected object (for example content object rights
 object and so on) using the specified URI or MIME type. At least one parameter must
 be specified to retrieve the DRM object type.","uri Uri : URI for the content or null. |||
mimeType String : MIME type of the content or null. |||",int An int that corresponds to a DrmStore.DrmObjectType . |||,11,"The main programming interface for the DRM framework. An application must instantiate this class
 to access DRM agents through the DRM framework.","Provides classes for managing DRM content and determining the capabilities of DRM plugins
 (agents). Common uses of the DRM API include: Determining which DRM plug-ins (agents) are installed on a device. Retrieving information about specific plug-ins such as the MIME types and file suffixes
   they support. Registering a user or a device with an online DRM service. Retrieving license constraints for rights-protected content. Checking whether a user has the proper rights to play or use rights-protected
   content. Associating rights-protected content with its license so you can use the
    MediaPlayer  API to play the content.",no,no,0,no,no,no,no,
<android.app.PendingIntent: void send()>,Perform the operation associated with this PendingIntent.,,void,1,"A description of an Intent and target action to perform with it.  Instances
 of this class are created with  getActivity(Context int Intent int)   getActivities(Context int Intent[] int) 
  getBroadcast(Context int Intent int)  and  getService(Context int Intent int) ; the returned object can be
 handed to other applications so that they can perform the action you
 described on your behalf at a later time.

  By giving a PendingIntent to another application
 you are granting it the right to perform the operation you have specified
 as if the other application was yourself (with the same permissions and
 identity).  As such you should be careful about how you build the PendingIntent:
 almost always for example the base Intent you supply should have the component
 name explicitly set to one of your own components to ensure it is ultimately
 sent there and nowhere else.

  A PendingIntent itself is simply a reference to a token maintained by
 the system describing the original data used to retrieve it.  This means
 that even if its owning application's process is killed the
 PendingIntent itself will remain usable from other processes that
 have been given it.  If the creating application later re-retrieves the
 same kind of PendingIntent (same operation same Intent action data
 categories and components and same flags) it will receive a PendingIntent
 representing the same token if that is still valid and can thus call
  cancel()  to remove it.

  Because of this behavior it is important to know when two Intents
 are considered to be the same for purposes of retrieving a PendingIntent.
 A common mistake people make is to create multiple PendingIntent objects
 with Intents that only vary in their ""extra"" contents expecting to get
 a different PendingIntent each time.  This does  not  happen.  The
 parts of the Intent that are used for matching are the same ones defined
 by  Intent#filterEquals(Intent) .  If you use two
 Intent objects that are equivalent as per
  Intent#filterEquals(Intent)  then you will get
 the same PendingIntent for both of them.

  There are two typical ways to deal with this.

  If you truly need multiple distinct PendingIntent objects active at
 the same time (such as to use as two notifications that are both shown
 at the same time) then you will need to ensure there is something that
 is different about them to associate them with different PendingIntents.
 This may be any of the Intent attributes considered by
  Intent#filterEquals(Intent)  or different
 request code integers supplied to  getActivity(Context int Intent int)   getActivities(Context int Intent[] int) 
  getBroadcast(Context int Intent int)  or  getService(Context int Intent int) .

  If you only need one PendingIntent active at a time for any of the
 Intents you will use then you can alternatively use the flags
  FLAG_CANCEL_CURRENT  or  FLAG_UPDATE_CURRENT  to either
 cancel or modify whatever current PendingIntent is associated with the
 Intent you are supplying.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
"<android.text.TextUtils: CharSequence expandTemplate(CharSequence,CharSequence)>","Replace instances of ""^1"" ""^2"" etc. in the template CharSequence with the corresponding values .  ""^^"" is used to produce a single caret in
 the output.  Only up to 9 replacement values are supported
 ""^10"" will be produce the first replacement value followed by a
 '0'.","template CharSequence : the input text containing ""^1""-style
placeholder values.  This object is not modified; a copy is
returned. |||
values CharSequence : CharSequences substituted into the template.  The
first is substituted for ""^1"" the second for ""^2"" and so on. |||",CharSequence the new CharSequence produced by doing the replacement |||,1,,"Provides classes used to render or track text and text spans on the screen. You can use these classes to design your own widgets that manage text
 to handle arbitrary text spans for changes or to handle drawing yourself
 for an existing widget. The Span… interfaces and classes are used to create or manage spans of
 text in a View item. You can use these to style the text or background or to
 listen for changes. If creating your own widget extend DynamicLayout to manages
 the actual wrapping and drawing of your text.",no,no,0,no,no,no,no,
"<android.inputmethodservice.InputMethodService: void onExtractedCursorMovement(int,int)>","This is called when the user has performed a cursor movement in the
 extracted text view when it is running in fullscreen mode.  The default
 implementation hides the candidates view when a vertical movement
 happens but only if the extracted text editor has a vertical scroll bar
 because its text doesn't fit.
 Re-implement this to provide whatever behavior you want.","dx int : The amount of cursor movement in the x dimension. |||
dy int : The amount of cursor movement in the y dimension. |||",void,3,"InputMethodService provides a standard implementation of an InputMethod
 which final implementations can derive from and customize.  See the
 base class  AbstractInputMethodService  and the  InputMethod 
 interface for more information on the basics of writing input methods.

  In addition to the normal Service lifecycle methods this class
 introduces some new specific callbacks that most subclasses will want
 to make use of: onInitializeInterface()  for user-interface initialization
 in particular to deal with configuration changes while the service is
 running.
  onBindInput()  to find out about switching to a new client.
  onStartInput(EditorInfo boolean)  to deal with an input session starting with
 the client.
  onCreateInputView()   onCreateCandidatesView() 
 and  onCreateExtractTextView()  for non-demand generation of the UI.
  onStartInputView(android.view.inputmethod.EditorInfo boolean)  to deal with input
 starting within the input area of the IME.
  An input method has significant discretion in how it goes about its
 work: the  InputMethodService  provides
 a basic framework for standard UI elements (input view candidates view
 and running in fullscreen mode) but it is up to a particular implementor
 to decide how to use them.  For example one input method could implement
 an input area with a keyboard another could allow the user to draw text
 while a third could have no input area (and thus not be visible to the
 user) but instead listen to audio and perform text to speech conversion. In the implementation provided here all of these elements are placed
 together in a single window managed by the InputMethodService.  It will
 execute callbacks as it needs information about them and provides APIs for
 programmatic control over them.  They layout of these elements is explicitly
 defined: The soft input view if available is placed at the bottom of the
 screen.
  The candidates view if currently shown is placed above the soft
 input view.
  If not running fullscreen the application is moved or resized to be
 above these views; if running fullscreen the window will completely cover
 the application and its top part will contain the extract text of what is
 currently being edited by the application.
  Soft Input View Central to most input methods is the soft input view.  This is where most
 user interaction occurs: pressing on soft keys drawing characters or
 however else your input method wants to generate text.  Most implementations
 will simply have their own view doing all of this work and return a new
 instance of it when  onCreateInputView()  is called.  At that point
 as long as the input view is visible you will see user interaction in
 that view and can call back on the InputMethodService to interact with the
 application as appropriate. There are some situations where you want to decide whether or not your
 soft input view should be shown to the user.  This is done by implementing
 the  onEvaluateInputViewShown()  to return true or false based on
 whether it should be shown in the current environment.  If any of your
 state has changed that may impact this call
  updateInputViewShown()  to have it re-evaluated.  The default
 implementation always shows the input view unless there is a hard
 keyboard available which is the appropriate behavior for most input
 methods. Candidates View Often while the user is generating raw text an input method wants to
 provide them with a list of possible interpretations of that text that can
 be selected for use.  This is accomplished with the candidates view and
 like the soft input view you implement  onCreateCandidatesView() 
 to instantiate your own view implementing your candidates UI. Management of the candidates view is a little different than the input
 view because the candidates view tends to be more transient being shown
 only when there are possible candidates for the current text being entered
 by the user.  To control whether the candidates view is shown you use
  setCandidatesViewShown(boolean) .  Note that because the candidate
 view tends to be shown and hidden a lot it does not impact the application
 UI in the same way as the soft input view: it will never cause application
 windows to resize only cause them to be panned if needed for the user to
 see the current focus. Fullscreen Mode Sometimes your input method UI is too large to integrate with the
 application UI so you just want to take over the screen.  This is
 accomplished by switching to full-screen mode causing the input method
 window to fill the entire screen and add its own ""extracted text"" editor
 showing the user the text that is being typed.  Unlike the other UI elements
 there is a standard implementation for the extract editor that you should
 not need to change.  The editor is placed at the top of the IME above the
 input and candidates views. Similar to the input view you control whether the IME is running in
 fullscreen mode by implementing  onEvaluateFullscreenMode() 
 to return true or false based on
 whether it should be fullscreen in the current environment.  If any of your
 state has changed that may impact this call
  updateFullscreenMode()  to have it re-evaluated.  The default
 implementation selects fullscreen mode when the screen is in a landscape
 orientation which is appropriate behavior for most input methods that have
 a significant input area. When in fullscreen mode you have some special requirements because the
 user can not see the application UI.  In particular you should implement
  onDisplayCompletions(android.view.inputmethod.CompletionInfo[])  to show completions
 generated by your application typically in your candidates view like you
 would normally show candidates.


  Generating Text The key part of an IME is of course generating text for the application.
 This is done through calls to the
  InputConnection  interface to the
 application which can be retrieved from  getCurrentInputConnection() .
 This interface allows you to generate raw key events or if the target
 supports it directly edit in strings of candidates and committed text. Information about what the target is expected and supports can be found
 through the  EditorInfo  class which is
 retrieved with  getCurrentInputEditorInfo()  method.  The most
 important part of this is  EditorInfo.inputType ; in particular if this is
  EditorInfo.TYPE_NULL 
 then the target does not support complex edits and you need to only deliver
 raw key events to it.  An input method will also want to look at other
 values here to for example detect password mode auto complete text views
 phone number entry etc. When the user switches between input targets you will receive calls to
  onFinishInput()  and  onStartInput(android.view.inputmethod.EditorInfo boolean) .
 You can use these to reset and initialize your input state for the current
 target.  For example you will often want to clear any input state and
 update a soft keyboard to be appropriate for the new inputType.",,no,no,0,no,no,no,no,
"<android.widget.ArrayAdapter: ArrayAdapter createFromResource(Context,int,int)>","Creates a new ArrayAdapter from external resources. The content of the array is
 obtained through Resources.getTextArray(int) .","context Context : The application's environment.
This value must never be null . |||
textArrayResId int : The identifier of the array to use as the data source. |||
textViewResId int : The identifier of the layout used to create views. |||","ArrayAdapter < CharSequence > An ArrayAdapter .
 
 This value will never be null . |||",1,"You can use this adapter to provide views for an  AdapterView 
 Returns a view for each object in a collection of data objects you
 provide and can be used with list-based user interface widgets such as
  ListView  or  Spinner .
  
 By default the array adapter creates a view by calling  Object#toString()  on each
 data object in the collection you provide and places the result in a TextView.
 You may also customize what type of view is used for the data object in the collection.
 To customize what type of view is used for the data object
 override  getView(int android.view.View android.view.ViewGroup) 
 and inflate a view resource.
 For a code example see
 the  
 CustomChoiceList  sample.
  
 For an example of using an array adapter with a ListView see the
  
 Adapter Views  guide.
  
 For an example of using an array adapter with a Spinner see the
  Spinners  guide.
  Note: 
 If you are considering using array adapter with a ListView consider using
  RecyclerView  instead.
 RecyclerView offers similar features with better performance and more flexibility than
 ListView provides.
 See the
  
 Recycler View  guide.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,no,0,no,no,no,no,
<android.nfc.tech.NfcA: NfcA get(Tag)>,"Get an instance of NfcA for the given tag. Returns null if NfcA was not enumerated in Tag#getTechList .
 This indicates the tag does not support NFC-A. Does not cause any RF activity and does not block.",tag Tag : an NFC-A compatible tag |||,NfcA NFC-A object |||,10,"Provides access to NFC-A (ISO 14443-3A) properties and I/O operations on a  Tag .

  Acquire a  NfcA  object using  get(Tag) .
  The primary NFC-A I/O operation is  transceive(byte[]) . Applications must
 implement their own protocol stack on top of  transceive(byte[]) .

  Note:  Methods that perform I/O operations
 require the  Manifest.permission.NFC  permission.","These classes provide access to a tag technology's features which vary by the type
 of tag that is scanned. A scanned tag can support multiple technologies and you can find
 out what they are by calling  getTechList() . For more information on dealing with tag technologies and handling the ones that you care about see
  The Tag Dispatch System .
 The  TagTechnology  interface provides an overview of the
 supported technologies.",nfc,nfc,1,yes,no,SOURCE,no,
<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getLabeledBy()>,"Gets the node info which serves as the label of the view represented by
 this info for accessibility purposes. Note: It is a client responsibility to recycle the
     received info by calling AccessibilityNodeInfo#recycle() to avoid creating of multiple instances.",,AccessibilityNodeInfo The label. |||,17,"This class represents a node of the window content as well as actions that
 can be requested from its source. From the point of view of an
  AccessibilityService  a window's content is
 presented as a tree of accessibility node infos which may or may not map one-to-one
 to the view hierarchy. In other words a custom view is free to report itself as
 a tree of accessibility node info.
  
 Once an accessibility node info is delivered to an accessibility service it is
 made immutable and calling a state mutation method generates an error.
  
 Please refer to  AccessibilityService  for
 details about how to obtain a handle to window content as a tree of accessibility
 node info as well as details about the security model.",,no,no,0,no,no,no,no,
"<android.test.TouchUtils: void tapView(InstrumentationTestCase,View)>",Simulate touching the center of a view and releasing quickly (before the tap timeout).,"test InstrumentationTestCase : The test case that is being run |||
v View : The view that should be clicked |||",void,1,"Reusable methods for generating touch events. These methods can be used with
 InstrumentationTestCase or ActivityInstrumentationTestCase2 to simulate user interaction with
 the application through a touch screen.",,no,no,0,no,no,no,no,
<android.preference.Preference: void restoreHierarchyState(Bundle)>,Restore this Preference hierarchy's previously saved state from the given container.,container Bundle : The Bundle that holds the previously saved state. |||,void,1,"Represents the basic Preference UI building
 block displayed by a  PreferenceActivity  in the form of a
  ListView . This class provides the  View  to be displayed in
 the activity and associates with a  SharedPreferences  to
 store/retrieve the preference data.
  
 When specifying a preference hierarchy in XML each element can point to a
 subclass of  Preference  similar to the view hierarchy and layouts.
  
 This class contains a  key  that will be used as the key into the
  SharedPreferences . It is up to the subclass to decide how to store
 the value.",,no,no,0,no,no,no,no,
<android.hardware.SensorManager: int getSensors()>,"This method was deprecated
      in API level 15. This method is deprecated use SensorManager#getSensorList(int) instead",,int available sensors. |||,1,"SensorManager lets you access the device's  sensors .
  
 Always make sure to disable sensors you don't need especially when your
 activity is paused. Failing to do so can drain the battery in just a few
 hours. Note that the system will  not  disable sensors automatically when
 the screen turns off.
  
 Note: Don't use this mechanism with a Trigger Sensor have a look
 at  TriggerEventListener .  Sensor#TYPE_SIGNIFICANT_MOTION 
 is an example of a trigger sensor.
  
 public class SensorActivity extends Activity implements SensorEventListener {
     private final SensorManager mSensorManager;
     private final Sensor mAccelerometer;

     public SensorActivity() {
         mSensorManager = (SensorManager)getSystemService(SENSOR_SERVICE);
         mAccelerometer = mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
     }

     protected void onResume() {
         super.onResume();
         mSensorManager.registerListener(this mAccelerometer SensorManager.SENSOR_DELAY_NORMAL);
     }

     protected void onPause() {
         super.onPause();
         mSensorManager.unregisterListener(this);
     }

     public void onAccuracyChanged(Sensor sensor int accuracy) {
     }

     public void onSensorChanged(SensorEvent event) {
     }
 }","Provides support for hardware features such as the camera and other sensors. Be aware that
 not all Android-powered devices support all hardware features so you should declare hardware
 that your application requires using the  <uses-feature>  manifest element.",sensor metadata,sensors,1,yes,no,SOURCE,no,
"<android.database.sqlite.SQLiteDatabase: Cursor query(String,String,String,String,String,String,String,String)>",Query the given table returning a Cursor over the result set.,"table String : The table name to compile the query against. |||
columns String : A list of which columns to return. Passing null will
return all columns which is discouraged to prevent reading
data from storage that isn't going to be used. |||
selection String : A filter declaring which rows to return formatted as an
SQL WHERE clause (excluding the WHERE itself). Passing null
will return all rows for the given table. |||
selectionArgs String : You may include ?s in selection which will be
replaced by the values from selectionArgs in order that they
appear in the selection. The values will be bound as Strings. |||
groupBy String : A filter declaring how to group rows formatted as an SQL
GROUP BY clause (excluding the GROUP BY itself). Passing null
will cause the rows to not be grouped. |||
having String : A filter declare which row groups to include in the cursor
if row grouping is being used formatted as an SQL HAVING
clause (excluding the HAVING itself). Passing null will cause
all row groups to be included and is required when row
grouping is not being used. |||
orderBy String : How to order the rows formatted as an SQL ORDER BY clause
(excluding the ORDER BY itself). Passing null will use the
default sort order which may be unordered. |||
limit String : Limits the number of rows returned by the query
formatted as LIMIT clause. Passing null denotes no LIMIT clause. |||",Cursor A Cursor object which is positioned before the first entry. Note that Cursor s are not synchronized see the documentation for more details. |||,1,"Exposes methods to manage a SQLite database.

  
 SQLiteDatabase has methods to create delete execute SQL commands and
 perform other common database management tasks.
  
 See the Notepad sample application in the SDK for an example of creating
 and managing a database.
  
 Database names must be unique within an application not across all applications.
  Localized Collation - ORDER BY 
 In addition to SQLite's default  BINARY  collator Android supplies
 two more  LOCALIZED  which changes with the system's current locale
 and  UNICODE  which is the Unicode Collation Algorithm and not tailored
 to the current locale.","If you need to manage data in a private database use the  android.database.sqlite  classes. These classes are used to manage the  Cursor  object returned from a content provider query. Databases
 are usually created and opened with  openOrCreateDatabase(String int SQLiteDatabase.CursorFactory) 
 To make requests through
 content providers you can use the  content.ContentResolver  class.
  All databases are stored on the device in  /data/data/<package_name>/databases",database data,database,1,yes,no,SOURCE,no,
"<android.content.Intent: Intent putExtra(String,double)>","Add extended data to the intent.  The name must include a package
 prefix for example the app com.android.contacts would use names
 like ""com.android.contacts.ShowAll"".","name String : The name of the extra data with package prefix. |||
value double : The double array data value.
This value may be null . |||","Intent Returns the same Intent object for chaining multiple calls
 into a single statement.

 This value will never be null . |||",1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,
"<android.test.TouchUtils: void touchAndCancelView(InstrumentationTestCase,View)>","Simulate touching the center of a view and cancelling (so no onClick should
 fire etc).","test InstrumentationTestCase : The test case that is being run |||
v View : The view that should be clicked |||",void,1,"Reusable methods for generating touch events. These methods can be used with
 InstrumentationTestCase or ActivityInstrumentationTestCase2 to simulate user interaction with
 the application through a touch screen.",,no,no,0,no,no,no,no,
<android.widget.AdapterViewFlipper: void setAdapter(Adapter)>,"Sets the adapter that provides the data and the views to represent the data
 in this widget.",adapter Adapter : The adapter to use to create this view's content. |||,void,11,"Simple  ViewAnimator  that will animate between two or more views
 that have been added to it.  Only one child is shown at a time.  If
 requested can automatically flip between each child at a regular interval.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,no,0,no,no,no,no,
<android.app.TaskStackBuilder: void startActivities(Bundle)>,Start the task stack constructed by this builder.,"options Bundle : Additional options for how the Activity should be started.
See Context.startActivity(Intent Bundle) Context.startActivity(Intent Bundle)} for more details. |||",void,16,"Utility class for constructing synthetic back stacks for cross-task navigation
 on Android 3.0 and newer.

  In API level 11 (Android 3.0/Honeycomb) the recommended conventions for
 app navigation using the back key changed. The back key's behavior is local
 to the current task and does not capture navigation across different tasks.
 Navigating across tasks and easily reaching the previous task is accomplished
 through the ""recents"" UI accessible through the software-provided Recents key
 on the navigation or system bar. On devices with the older hardware button configuration
 the recents UI can be accessed with a long press on the Home key. When crossing from one task stack to another post-Android 3.0
 the application should synthesize a back stack/history for the new task so that
 the user may navigate out of the new task and back to the Launcher by repeated
 presses of the back key. Back key presses should not navigate across task stacks. TaskStackBuilder provides a way to obey the correct conventions
 around cross-task navigation.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",IPC,IPC,1,no,yes,no,SINK,
<android.inputmethodservice.KeyboardView: void onDetachedFromWindow()>,"This is called when the view is detached from a window.  At this point it
 no longer has a surface for drawing. If you override this method you must call through to the
 superclass implementation.",,void,3,"A view that renders a virtual  Keyboard . It handles rendering of keys and
 detecting key presses and touch movements.",,no,no,0,no,no,no,no,
<android.os.Parcel: SparseArray readSparseArray(ClassLoader)>,"Read and return a new SparseArray object from the parcel at the current
 dataPosition().  Returns null if the previously written list object was
 null.  The given class loader will be used to load any enclosed
 Parcelables.",loader ClassLoader : This value may be null . |||,SparseArray <T> |||,1,"Container for a message (data and object references) that can
 be sent through an IBinder.  A Parcel can contain both flattened data
 that will be unflattened on the other side of the IPC (using the various
 methods here for writing specific types or the general
  Parcelable  interface) and references to live  IBinder 
 objects that will result in the other side receiving a proxy IBinder
 connected with the original IBinder in the Parcel.

  Parcel is  not  a general-purpose
 serialization mechanism.  This class (and the corresponding
  Parcelable  API for placing arbitrary objects into a Parcel) is
 designed as a high-performance IPC transport.  As such it is not
 appropriate to place any Parcel data in to persistent storage: changes
 in the underlying implementation of any of the data in the Parcel can
 render older data unreadable. The bulk of the Parcel API revolves around reading and writing data
 of various types.  There are six major classes of such functions available. Primitives The most basic data functions are for writing and reading primitive
 data types:  writeByte(byte)   readByte()   writeDouble(double) 
  readDouble()   writeFloat(float)   readFloat()   writeInt(int) 
  readInt()   writeLong(long)   readLong() 
  writeString(String)   readString() .  Most other
 data operations are built on top of these.  The given data is written and
 read using the endianess of the host CPU. Primitive Arrays There are a variety of methods for reading and writing raw arrays
 of primitive objects which generally result in writing a 4-byte length
 followed by the primitive data items.  The methods for reading can either
 read the data into an existing array or create and return a new array.
 These available types are: writeBooleanArray(boolean[]) 
  readBooleanArray(boolean[])   createBooleanArray() writeByteArray(byte[]) 
  writeByteArray(byte[] int int)   readByteArray(byte[]) 
  createByteArray() writeCharArray(char[])   readCharArray(char[]) 
  createCharArray() writeDoubleArray(double[])   readDoubleArray(double[]) 
  createDoubleArray() writeFloatArray(float[])   readFloatArray(float[]) 
  createFloatArray() writeIntArray(int[])   readIntArray(int[]) 
  createIntArray() writeLongArray(long[])   readLongArray(long[]) 
  createLongArray() writeStringArray(java.lang.String[])   readStringArray(java.lang.String[]) 
  createStringArray() .
  writeSparseBooleanArray(android.util.SparseBooleanArray) 
  readSparseBooleanArray() .
  Parcelables The  Parcelable  protocol provides an extremely efficient (but
 low-level) protocol for objects to write and read themselves from Parcels.
 You can use the direct methods  writeParcelable(android.os.Parcelable int) 
 and  readParcelable(java.lang.ClassLoader)  or
  writeParcelableArray(T[] int)  and
  readParcelableArray(java.lang.ClassLoader)  to write or read.  These
 methods write both the class type and its data to the Parcel allowing
 that class to be reconstructed from the appropriate class loader when
 later reading. There are also some methods that provide a more efficient way to work
 with Parcelables:  writeTypedObject(T int)   writeTypedArray(T[] int) 
  writeTypedList(List )   readTypedObject(Parcelable.Creator ) 
  createTypedArray(Parcelable.Creator )  and  createTypedArrayList(Parcelable.Creator ) .  These methods
 do not write the class information of the original object: instead the
 caller of the read function must know what type to expect and pass in the
 appropriate  Parcelable.Creator  instead to
 properly construct the new object and read its data.  (To more efficient
 write and read a single Parcelable object that is not null you can directly
 call  Parcelable#writeToParcel  and
  Parcelable.Creator#createFromParcel 
 yourself.) Bundles A special type-safe container called  Bundle  is available
 for key/value maps of heterogeneous values.  This has many optimizations
 for improved performance when reading and writing data and its type-safe
 API avoids difficult to debug type errors when finally marshalling the
 data contents into a Parcel.  The methods to use are
  writeBundle(android.os.Bundle)   readBundle()  and
  readBundle(java.lang.ClassLoader) .

  Active Objects An unusual feature of Parcel is the ability to read and write active
 objects.  For these objects the actual contents of the object is not
 written rather a special token referencing the object is written.  When
 reading the object back from the Parcel you do not get a new instance of
 the object but rather a handle that operates on the exact same object that
 was originally written.  There are two forms of active objects available. Binder  objects are a core facility of Android's general cross-process
 communication system.  The  IBinder  interface describes an abstract
 protocol with a Binder object.  Any such interface can be written in to
 a Parcel and upon reading you will receive either the original object
 implementing that interface or a special proxy implementation
 that communicates calls back to the original object.  The methods to use are
  writeStrongBinder(android.os.IBinder) 
  writeStrongInterface(android.os.IInterface)   readStrongBinder() 
  writeBinderArray(android.os.IBinder[])   readBinderArray(android.os.IBinder[]) 
  createBinderArray() 
  writeBinderList(java.util.List)   readBinderList(java.util.List) 
  createBinderArrayList() . FileDescriptor objects representing raw Linux file descriptor identifiers
 can be written and  ParcelFileDescriptor  objects returned to operate
 on the original file descriptor.  The returned file descriptor is a dup
 of the original file descriptor: the object and fd is different but
 operating on the same underlying file stream with the same position etc.
 The methods to use are  writeFileDescriptor(java.io.FileDescriptor) 
  readFileDescriptor() .

  Untyped Containers A final class of methods are for writing and reading standard Java
 containers of arbitrary types.  These all revolve around the
  writeValue(java.lang.Object)  and  readValue(java.lang.ClassLoader)  methods
 which define the types of objects allowed.  The container methods are
  writeArray(java.lang.Object[])   readArray(java.lang.ClassLoader) 
  writeList(java.util.List)   readList(java.util.List java.lang.ClassLoader) 
  readArrayList(java.lang.ClassLoader) 
  writeMap(java.util.Map)   readMap(java.util.Map java.lang.ClassLoader) 
  writeSparseArray(android.util.SparseArray) 
  readSparseArray(java.lang.ClassLoader) .",,no,no,0,no,no,no,no,
"<android.app.Activity: View onCreateView(View,String,Context,AttributeSet)>","Standard implementation of LayoutInflater.Factory2.onCreateView(View String Context AttributeSet) used when inflating with the LayoutInflater returned by Context.getSystemService(Class ) .
 This implementation handles tags to embed fragments inside
 of the activity.","parent View : This value may be null . |||
name String : This value must never be null . |||
context Context : This value must never be null . |||
attrs AttributeSet : This value must never be null . |||",View This value may be null . |||,11,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",uncategorized,UI,1,no,yes,no,SINK,
<android.content.res.TypedArray: ColorStateList getColorStateList(int)>,"Retrieve the ColorStateList for the attribute at index .
 The value may be either a single solid color or a reference to
 a color or complex ColorStateList description. This method will return null if the attribute is not defined or
 is not an integer color or color state list.",index int : Index of attribute to retrieve. |||,"ColorStateList ColorStateList for the attribute or null if not
         defined. |||",1,"Container for an array of values that were retrieved with
  Resources.Theme#obtainStyledAttributes(AttributeSet int[] int int) 
 or  Resources#obtainAttributes .  Be
 sure to call  recycle()  when done with them.

 The indices used to retrieve values from this structure correspond to
 the positions of the attributes given to obtainStyledAttributes.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,
"<android.content.ContextWrapper: Intent registerReceiver(BroadcastReceiver,IntentFilter,String,Handler)>","Register to receive intent broadcasts to run in the context of scheduler .  See registerReceiver(android.content.BroadcastReceiver android.content.IntentFilter) for more
 information.  This allows you to enforce permissions on who can
 broadcast intents to your receiver or have the receiver run in
 a different thread than the main application thread. See BroadcastReceiver for more information on Intent broadcasts. As of Build.VERSION_CODES.ICE_CREAM_SANDWICH receivers
 registered with this method will correctly respect the Intent#setPackage(String) specified for an Intent being broadcast.
 Prior to that it would be ignored and delivered to all matching registered
 receivers.  Be careful if using this for security.","receiver BroadcastReceiver : The BroadcastReceiver to handle the broadcast. |||
filter IntentFilter : Selects the Intent broadcasts to be received. |||
broadcastPermission String : String naming a permissions that a
broadcaster must hold in order to send an Intent to you.  If null
no permission is required.
This value may be null . |||
scheduler Handler : Handler identifying the thread that will receive
the Intent.  If null the main thread of the process will be used.
This value may be null . |||",Intent The first sticky intent found that matches filter or null if there are none. |||,1,"Proxying implementation of Context that simply delegates all of its calls to
 another Context.  Can be subclassed to modify behavior without changing
 the original Context.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,IPC,0,no,no,no,no,
<android.net.sip.SipAudioCall: void endCall()>,Ends a call.,,void,9,"Handles an Internet audio call over SIP. You can instantiate this class with  SipManager 
 using  SipManager#makeAudioCall  and   SipManager#takeAudioCall .

  Note:  Using this class require the
    Manifest.permission.INTERNET  and
    Manifest.permission.USE_SIP  permissions. In addition  startAudio()  requires the
    Manifest.permission.RECORD_AUDIO 
    Manifest.permission.ACCESS_WIFI_STATE  and
    Manifest.permission.WAKE_LOCK  permissions; and  setSpeakerMode()  requires the
    Manifest.permission.MODIFY_AUDIO_SETTINGS  permission.",,no,no,0,no,no,no,no,
<android.content.res.Resources: XmlResourceParser getLayout(int)>,"Return an XmlResourceParser through which you can read a view layout
 description for the given resource ID.  This parser has limited
 functionality -- in particular you can't change its input and only
 the high-level events are available. This function is really a simple wrapper for calling getXml(int) with a layout resource.","id int : The desired resource identifier as generated by the aapt
tool. This integer encodes the package type and resource
entry. The value 0 is an invalid identifier. |||","XmlResourceParser A new parser object through which you can read
         the XML data.

 This value will never be null . |||",1,"Class for accessing an application's resources.  This sits on top of the
 asset manager of the application (accessible through  getAssets() ) and
 provides a high-level API for getting typed data from the assets.

  The Android resource system keeps track of all non-code assets associated with an
 application. You can use this class to access your application's resources. You can generally
 acquire the  Resources  instance associated with your application
 with  getResources() . The Android SDK tools compile your application's resources into the application binary
 at build time.  To use a resource you must install it correctly in the source tree (inside
 your project's  res/  directory) and build your application.  As part of the build
 process the SDK tools generate symbols for each resource which you can use in your application
 code to access the resources. Using application resources makes it easy to update various characteristics of your
 application without modifying code and—by providing sets of alternative
 resources—enables you to optimize your application for a variety of device configurations
 (such as for different languages and screen sizes). This is an important aspect of developing
 Android applications that are compatible on different types of devices. For more information about using resources see the documentation about  Application Resources .","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,
<android.app.WallpaperInfo: CharSequence loadDescription(PackageManager)>,Return a brief summary of this wallpaper's behavior.,pm PackageManager |||,CharSequence |||,7,This class is used to specify meta information of a wallpaper service.,"Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",image metadata,UI,1,yes,no,SOURCE,no,
<android.text.SpannableStringBuilder: SpannableStringBuilder append(CharSequence)>,Convenience for replace(length() length() text 0 text.length()),"text CharSequence : The character sequence to append.  If csq is null then the four characters ""null"" are
appended to this Appendable. |||",SpannableStringBuilder A reference to this Appendable |||,1,"This is the class for text whose content is immutable but to which
 markup objects can be attached and detached.
 For mutable text see  SpannableStringBuilder .","Provides classes used to render or track text and text spans on the screen. You can use these classes to design your own widgets that manage text
 to handle arbitrary text spans for changes or to handle drawing yourself
 for an existing widget. The Span… interfaces and classes are used to create or manage spans of
 text in a View item. You can use these to style the text or background or to
 listen for changes. If creating your own widget extend DynamicLayout to manages
 the actual wrapping and drawing of your text.",no,no,0,no,no,no,no,
"<android.view.inputmethod.InputMethodManager: void displayCompletions(View,CompletionInfo)>",,"view View |||
completions CompletionInfo |||",void,3,"Central system API to the overall input method framework (IMF) architecture
 which arbitrates interaction between applications and the current input method.

  Topics covered here:
  Architecture Overview Applications Input Methods Security Architecture Overview There are three primary parties involved in the input method
 framework (IMF) architecture:  The  input method manager  as expressed by this class
 is the central point of the system that manages interaction between all
 other parts.  It is expressed as the client-side API here which exists
 in each application context and communicates with a global system service
 that manages the interaction across all processes.
   An  input method (IME)  implements a particular
 interaction model allowing the user to generate text.  The system binds
 to the current input method that is in use causing it to be created and run
 and tells it when to hide and show its UI.  Only one IME is running at a time.
   Multiple  client applications  arbitrate with the input
 method manager for input focus and control over the state of the IME.  Only
 one such client is ever active (working with the IME) at a time.
  Applications In most cases applications that are using the standard
  TextView  or its subclasses will have little they need
 to do to work well with soft input methods.  The main things you need to
 be aware of are:  Properly set the  R.attr.inputType  in your editable
 text views so that the input method will have enough context to help the
 user in entering text into them.
   Deal well with losing screen space when the input method is
 displayed.  Ideally an application should handle its window being resized
 smaller but it can rely on the system performing panning of the window
 if needed.  You should set the  R.attr.windowSoftInputMode 
 attribute on your activity or the corresponding values on windows you
 create to help the system determine whether to pan or resize (it will
 try to determine this automatically but may get it wrong).
   You can also control the preferred soft input state (open closed etc)
 for your window using the same  R.attr.windowSoftInputMode 
 attribute.
  More finer-grained control is available through the APIs here to directly
 interact with the IMF and its IME -- either showing or hiding the input
 area letting the user pick an input method etc. For the rare people amongst us writing their own text editors you
 will need to implement  View.onCreateInputConnection(EditorInfo) 
 to return a new instance of your own  InputConnection  interface
 allowing the IME to interact with your editor. Input Methods An input method (IME) is implemented
 as a  Service  typically deriving from
  InputMethodService .  It must provide
 the core  InputMethod  interface though this is normally handled by
  InputMethodService  and implementors will
 only need to deal with the higher-level API there. InputMethodService Security There are a lot of security issues associated with input methods
 since they essentially have freedom to completely drive the UI and monitor
 everything the user enters.  The Android input method framework also allows
 arbitrary third party IMEs so care must be taken to restrict their
 selection and interactions. Here are some key points about the security architecture behind the
 IMF: Only the system is allowed to directly access an IME's
  InputMethod  interface via the
  Manifest.permission.BIND_INPUT_METHOD  permission.  This is
 enforced in the system by not binding to an input method service that does
 not require this permission so the system can guarantee no other untrusted
 clients are accessing the current input method outside of its control. There may be many client processes of the IMF but only one may
 be active at a time.  The inactive clients can not interact with key
 parts of the IMF through the mechanisms described below. Clients of an input method are only given access to its
  InputMethodSession  interface.  One instance of this interface is
 created for each client and only calls from the session associated with
 the active client will be processed by the current IME.  This is enforced
 by  AbstractInputMethodService  for normal
 IMEs but must be explicitly handled by an IME that is customizing the
 raw  InputMethodSession  implementation. Only the active client's  InputConnection  will accept
 operations.  The IMF tells each client process whether it is active and
 the framework enforces that in inactive processes calls on to the current
 InputConnection will be ignored.  This ensures that the current IME can
 only deliver events and text edits to the UI that the user sees as
 being in focus. An IME can never interact with an  InputConnection  while
 the screen is off.  This is enforced by making all clients inactive while
 the screen is off and prevents bad IMEs from driving the UI when the user
 can not be aware of its behavior. A client application can ask that the system let the user pick a
 new IME but can not programmatically switch to one itself.  This avoids
 malicious applications from switching the user to their own IME which
 remains running when the user navigates away to another application.  An
 IME on the other hand  is  allowed to programmatically switch
 the system to another IME since it already has full control of user
 input. The user must explicitly enable a new IME in settings before
 they can switch to it to confirm with the system that they know about it
 and want to make it available for use. PackageManager#FEATURE_INPUT_METHODS PackageManager.hasSystemFeature(String)",,no,no,0,no,no,no,no,
<android.view.View: void onInitializeAccessibilityEvent(AccessibilityEvent)>,"Initializes an AccessibilityEvent with information about
 this View which is the event source. In other words the source of
 an accessibility event is the view whose state change triggered firing
 the event. Example: Setting the password property of an event in addition
          to properties set by the super implementation: If an AccessibilityDelegate has been specified via calling setAccessibilityDelegate(android.view.View.AccessibilityDelegate) its AccessibilityDelegate#onInitializeAccessibilityEvent(View AccessibilityEvent) is responsible for handling this call. Note: Always call the super implementation before adding
 information to the event in case the default implementation has basic information to add.",event AccessibilityEvent : The event to initialize. |||,void,14,"This class represents the basic building block for user interface components. A View
 occupies a rectangular area on the screen and is responsible for drawing and
 event handling. View is the base class for  widgets  which are
 used to create interactive UI components (buttons text fields etc.). The
  ViewGroup  subclass is the base class for  layouts  which
 are invisible containers that hold other Views (or other ViewGroups) and define
 their layout properties.",,no,UI,0,no,no,no,no,
<android.view.ViewGroup: void focusableViewAvailable(View)>,"Tells the parent that a new focusable view has become available. This is
 to handle transitions from the case where there are no focusable views to
 the case where the first focusable view appears.",v View : The view that has become newly focusable |||,void,1,"A  ViewGroup  is a special view that can contain other views
 (called children.) The view group is the base class for layouts and views
 containers. This class also defines the
  ViewGroup.LayoutParams  class which serves as the base
 class for layouts parameters.
  
 Also see  LayoutParams  for layout attributes.",,no,no,0,no,no,no,no,
"<android.text.method.ArrowKeyMovementMethod: void onTakeFocus(TextView,Spannable,int)>",,"view TextView |||
text Spannable |||
dir int |||",void,1,"A movement method that provides cursor movement and selection.
 Supports displaying the context menu on DPad Center.","Provides classes that monitor or modify keypad input. You can use these classes to modify the type of keypad entry
 for your application or decipher the keypresses entered for your specific
 entry method. For example: 
 // Set the text to password display style:
 EditText txtView = (EditText)findViewById(R.id.text);
 txtView.setTransformationMethod(PasswordTransformationMethod.getInstance());

 //Set the input style to numbers rather than qwerty keyboard style.
 txtView.setInputMethod(DigitsInputMethod.getInstance());

 // Find out whether the caps lock is on.
 // 0 is no 1 is yes 2 is caps lock on.
 int active = MultiTapInputMethod.getCapsActive(txtView.getText());",no,no,0,no,no,no,no,
"<android.os.ParcelFileDescriptor: void writeToParcel(Parcel,int)>","Flatten this object in to a Parcel.
 If Parcelable#PARCELABLE_WRITE_RETURN_VALUE is set in flags
 the file descriptor will be closed after a copy is written to the Parcel.","out Parcel : The Parcel in which the object should be written. |||
flags int : Additional flags about how the object should be written.
May be 0 or Parcelable.PARCELABLE_WRITE_RETURN_VALUE .
Value is either 0 or a combination of Parcelable.PARCELABLE_WRITE_RETURN_VALUE and android.os.Parcelable.PARCELABLE_ELIDE_DUPLICATES |||",void,1,"Container for a message (data and object references) that can
 be sent through an IBinder.  A Parcel can contain both flattened data
 that will be unflattened on the other side of the IPC (using the various
 methods here for writing specific types or the general
  Parcelable  interface) and references to live  IBinder 
 objects that will result in the other side receiving a proxy IBinder
 connected with the original IBinder in the Parcel.

  Parcel is  not  a general-purpose
 serialization mechanism.  This class (and the corresponding
  Parcelable  API for placing arbitrary objects into a Parcel) is
 designed as a high-performance IPC transport.  As such it is not
 appropriate to place any Parcel data in to persistent storage: changes
 in the underlying implementation of any of the data in the Parcel can
 render older data unreadable. The bulk of the Parcel API revolves around reading and writing data
 of various types.  There are six major classes of such functions available. Primitives The most basic data functions are for writing and reading primitive
 data types:  writeByte(byte)   readByte()   writeDouble(double) 
  readDouble()   writeFloat(float)   readFloat()   writeInt(int) 
  readInt()   writeLong(long)   readLong() 
  writeString(String)   readString() .  Most other
 data operations are built on top of these.  The given data is written and
 read using the endianess of the host CPU. Primitive Arrays There are a variety of methods for reading and writing raw arrays
 of primitive objects which generally result in writing a 4-byte length
 followed by the primitive data items.  The methods for reading can either
 read the data into an existing array or create and return a new array.
 These available types are: writeBooleanArray(boolean[]) 
  readBooleanArray(boolean[])   createBooleanArray() writeByteArray(byte[]) 
  writeByteArray(byte[] int int)   readByteArray(byte[]) 
  createByteArray() writeCharArray(char[])   readCharArray(char[]) 
  createCharArray() writeDoubleArray(double[])   readDoubleArray(double[]) 
  createDoubleArray() writeFloatArray(float[])   readFloatArray(float[]) 
  createFloatArray() writeIntArray(int[])   readIntArray(int[]) 
  createIntArray() writeLongArray(long[])   readLongArray(long[]) 
  createLongArray() writeStringArray(java.lang.String[])   readStringArray(java.lang.String[]) 
  createStringArray() .
  writeSparseBooleanArray(android.util.SparseBooleanArray) 
  readSparseBooleanArray() .
  Parcelables The  Parcelable  protocol provides an extremely efficient (but
 low-level) protocol for objects to write and read themselves from Parcels.
 You can use the direct methods  writeParcelable(android.os.Parcelable int) 
 and  readParcelable(java.lang.ClassLoader)  or
  writeParcelableArray(T[] int)  and
  readParcelableArray(java.lang.ClassLoader)  to write or read.  These
 methods write both the class type and its data to the Parcel allowing
 that class to be reconstructed from the appropriate class loader when
 later reading. There are also some methods that provide a more efficient way to work
 with Parcelables:  writeTypedObject(T int)   writeTypedArray(T[] int) 
  writeTypedList(List )   readTypedObject(Parcelable.Creator ) 
  createTypedArray(Parcelable.Creator )  and  createTypedArrayList(Parcelable.Creator ) .  These methods
 do not write the class information of the original object: instead the
 caller of the read function must know what type to expect and pass in the
 appropriate  Parcelable.Creator  instead to
 properly construct the new object and read its data.  (To more efficient
 write and read a single Parcelable object that is not null you can directly
 call  Parcelable#writeToParcel  and
  Parcelable.Creator#createFromParcel 
 yourself.) Bundles A special type-safe container called  Bundle  is available
 for key/value maps of heterogeneous values.  This has many optimizations
 for improved performance when reading and writing data and its type-safe
 API avoids difficult to debug type errors when finally marshalling the
 data contents into a Parcel.  The methods to use are
  writeBundle(android.os.Bundle)   readBundle()  and
  readBundle(java.lang.ClassLoader) .

  Active Objects An unusual feature of Parcel is the ability to read and write active
 objects.  For these objects the actual contents of the object is not
 written rather a special token referencing the object is written.  When
 reading the object back from the Parcel you do not get a new instance of
 the object but rather a handle that operates on the exact same object that
 was originally written.  There are two forms of active objects available. Binder  objects are a core facility of Android's general cross-process
 communication system.  The  IBinder  interface describes an abstract
 protocol with a Binder object.  Any such interface can be written in to
 a Parcel and upon reading you will receive either the original object
 implementing that interface or a special proxy implementation
 that communicates calls back to the original object.  The methods to use are
  writeStrongBinder(android.os.IBinder) 
  writeStrongInterface(android.os.IInterface)   readStrongBinder() 
  writeBinderArray(android.os.IBinder[])   readBinderArray(android.os.IBinder[]) 
  createBinderArray() 
  writeBinderList(java.util.List)   readBinderList(java.util.List) 
  createBinderArrayList() . FileDescriptor objects representing raw Linux file descriptor identifiers
 can be written and  ParcelFileDescriptor  objects returned to operate
 on the original file descriptor.  The returned file descriptor is a dup
 of the original file descriptor: the object and fd is different but
 operating on the same underlying file stream with the same position etc.
 The methods to use are  writeFileDescriptor(java.io.FileDescriptor) 
  readFileDescriptor() .

  Untyped Containers A final class of methods are for writing and reading standard Java
 containers of arbitrary types.  These all revolve around the
  writeValue(java.lang.Object)  and  readValue(java.lang.ClassLoader)  methods
 which define the types of objects allowed.  The container methods are
  writeArray(java.lang.Object[])   readArray(java.lang.ClassLoader) 
  writeList(java.util.List)   readList(java.util.List java.lang.ClassLoader) 
  readArrayList(java.lang.ClassLoader) 
  writeMap(java.util.Map)   readMap(java.util.Map java.lang.ClassLoader) 
  writeSparseArray(android.util.SparseArray) 
  readSparseArray(java.lang.ClassLoader) .",,IPC,no,0,no,no,no,no,
"<android.test.TouchUtils: void dragQuarterScreenDown(InstrumentationTestCase,Activity)>",Simulate touching in the center of the screen and dragging one quarter of the way down,"test InstrumentationTestCase : The test case that is being run |||
activity Activity : The activity that is in the foreground of the test case |||",void,3,"Reusable methods for generating touch events. These methods can be used with
 InstrumentationTestCase or ActivityInstrumentationTestCase2 to simulate user interaction with
 the application through a touch screen.",,no,no,0,no,no,no,no,
<android.bluetooth.BluetoothHealth: int getConnectionState(BluetoothDevice)>,"Get the current connection state of the profile. Requires Manifest.permission.BLUETOOTH permission.

 This is not specific to any application configuration but represents the connection
 state of the local Bluetooth adapter with the remote device. This can be used
 by applications like status bar which would just like to know the state of the
 local adapter.",device BluetoothDevice : Remote bluetooth device. |||,int State of the profile connection. One of BluetoothProfile.STATE_CONNECTED  BluetoothProfile.STATE_CONNECTING  BluetoothProfile.STATE_DISCONNECTED  BluetoothProfile.STATE_DISCONNECTING |||,14,"Public API for Bluetooth Health Profile.

  BluetoothHealth is a proxy object for controlling the Bluetooth
 Service via IPC.

   How to connect to a health device which is acting in the source role.
   Use  BluetoothAdapter#getProfileProxy  to get
 the BluetoothHealth proxy object.   Create an  BluetoothHealth  callback and call
  registerSinkAppConfiguration(String int BluetoothHealthCallback)  to register an application
 configuration   Pair with the remote device. This currently needs to be done manually
 from Bluetooth Settings   Connect to a health device using  connectChannelToSource(BluetoothDevice BluetoothHealthAppConfiguration) . Some
 devices will connect the channel automatically. The  BluetoothHealth 
 callback will inform the application of channel state change.   Use the file descriptor provided with a connected channel to read and
 write data to the health channel.   The received data needs to be interpreted using a health manager which
 implements the IEEE 11073-xxxxx specifications.
   When done close the health channel by calling  disconnectChannel(BluetoothDevice BluetoothHealthAppConfiguration int) 
 and unregister the application configuration calling
  unregisterAppConfiguration(BluetoothHealthAppConfiguration)","Provides classes that manage Bluetooth functionality such as scanning for
 devices connecting with devices and managing data transfer between devices.
 The Bluetooth API supports both ""Classic Bluetooth"" and Bluetooth Low Energy. For more information about Classic Bluetooth see the
  Bluetooth  guide.
 For more information about Bluetooth Low Energy see the
  
 Bluetooth Low Energy  (BLE) guide. The Bluetooth APIs let applications: Scan for other Bluetooth devices (including BLE devices). Query the local Bluetooth adapter for paired Bluetooth devices. Establish RFCOMM channels/sockets. Connect to specified sockets on other devices. Transfer data to and from other devices. Communicate with BLE devices such as proximity sensors heart rate
     monitors fitness devices and so on. Act as a GATT client or a GATT server (BLE). 
 To perform Bluetooth communication using these APIs an application must
 declare the  BLUETOOTH  permission. Some
 additional functionality such as requesting device discovery
 also requires the  BLUETOOTH_ADMIN 
 permission.
  Note: 
 Not all Android-powered devices provide Bluetooth functionality.",bluetooth metadata,bluetooth,1,yes,no,SOURCE,no,
<android.webkit.WebView: void goForward()>,Goes forward in the history of this WebView.,,void,1,"A View that displays web pages.

  Basic usage In most cases we recommend using a standard web browser like Chrome to deliver
 content to the user. To learn more about web browsers read the guide on
  
 invoking a browser with an intent .

  WebView objects allow you to display web content as part of your activity layout but
 lack some of the features of fully-developed browsers. A WebView is useful when
 you need increased control over the UI and advanced configuration options that will allow
 you to embed web pages in a specially-designed environment for your app.

  To learn more about WebView and alternatives for serving web content read the
 documentation on
  
 Web-based content .","Provides tools for browsing the web.
  For more information about building apps with web-based content see the
  Web Apps Overview .",no,network ,0,no,no,no,no,
<android.bluetooth.BluetoothAdapter: BluetoothDevice getRemoteDevice(byte)>,"Get a BluetoothDevice object for the given Bluetooth hardware
 address. Valid Bluetooth hardware addresses must be 6 bytes. This method
 expects the address in network byte order (MSB first). A BluetoothDevice will always be returned for a valid
 hardware address even if this adapter has never seen that device.",address byte : Bluetooth MAC address (6 bytes) |||,BluetoothDevice |||,16,"Represents the local device Bluetooth adapter. The  BluetoothAdapter 
 lets you perform fundamental Bluetooth tasks such as initiate
 device discovery query a list of bonded (paired) devices
 instantiate a  BluetoothDevice  using a known MAC address and create
 a  BluetoothServerSocket  to listen for connection requests from other
 devices and start a scan for Bluetooth LE devices.

  To get a  BluetoothAdapter  representing the local Bluetooth
 adapter call the  BluetoothManager#getAdapter  function on  BluetoothManager .
 On JELLY_BEAN_MR1 and below you will need to use the static  getDefaultAdapter() 
 method instead.
  
 Fundamentally this is your starting point for all
 Bluetooth actions. Once you have the local adapter you can get a set of
  BluetoothDevice  objects representing all paired devices with
  getBondedDevices() ; start device discovery with
  startDiscovery() ; or create a  BluetoothServerSocket  to
 listen for incoming RFComm connection requests with  listenUsingRfcommWithServiceRecord(java.lang.String java.util.UUID) ; listen for incoming L2CAP Connection-oriented
 Channels (CoC) connection requests with  listenUsingL2capChannel() ; or start a scan for
 Bluetooth LE devices with  startLeScan(android.bluetooth.BluetoothAdapter.LeScanCallback) .
  This class is thread safe. Note: 
 Most methods require the  Manifest.permission.BLUETOOTH 
 permission and some also require the
  Manifest.permission.BLUETOOTH_ADMIN  permission.","Provides classes that manage Bluetooth functionality such as scanning for
 devices connecting with devices and managing data transfer between devices.
 The Bluetooth API supports both ""Classic Bluetooth"" and Bluetooth Low Energy. For more information about Classic Bluetooth see the
  Bluetooth  guide.
 For more information about Bluetooth Low Energy see the
  
 Bluetooth Low Energy  (BLE) guide. The Bluetooth APIs let applications: Scan for other Bluetooth devices (including BLE devices). Query the local Bluetooth adapter for paired Bluetooth devices. Establish RFCOMM channels/sockets. Connect to specified sockets on other devices. Transfer data to and from other devices. Communicate with BLE devices such as proximity sensors heart rate
     monitors fitness devices and so on. Act as a GATT client or a GATT server (BLE). 
 To perform Bluetooth communication using these APIs an application must
 declare the  BLUETOOTH  permission. Some
 additional functionality such as requesting device discovery
 also requires the  BLUETOOTH_ADMIN 
 permission.
  Note: 
 Not all Android-powered devices provide Bluetooth functionality.",bluetooth metadata,bluetooth,1,yes,no,SOURCE,no,
<android.telephony.TelephonyManager: String getDeviceId()>,"This method was deprecated
      in API level 26. Use getImei() which returns IMEI for GSM or getMeid() which returns
 MEID for CDMA. Returns the unique device ID for example the IMEI for GSM and the MEID
 or ESN for CDMA phones. Return null if device ID is not available. Requires Permission: READ_PRIVILEGED_PHONE_STATE for the calling app to be the device or
 profile owner and have the READ_PHONE_STATE permission or that the calling app has carrier
 privileges (see hasCarrierPrivileges() ) on any active subscription. The profile owner
 is an app that owns a managed profile on the device; for more details see Work profiles . Profile owner
 access is deprecated and will be removed in a future release. If the calling app does not meet one of these requirements then this method will behave
 as follows: If the calling app's target SDK is API level 28 or lower and the app has the
     READ_PHONE_STATE permission then null is returned. 
If the calling app's target SDK is API level 28 or lower and the app does not have
     the READ_PHONE_STATE permission or if the calling app is targeting API level 29 or
     higher then a SecurityException is thrown.",,String |||,1,"Provides access to information about the telephony services on
 the device. Applications can use the methods in this class to
 determine telephony services and states as well as to access some
 types of subscriber information. Applications can also register
 a listener to receive notification of telephony state changes.
  
 The returned TelephonyManager will use the default subscription for all calls.
 To call an API for a specific subscription use  createForSubscriptionId(int) . e.g.
  
   telephonyManager = defaultSubTelephonyManager.createForSubscriptionId(subId);
  
 Note that access to some telephony information is
 permission-protected. Your application cannot access the protected
 information unless it has the appropriate permissions declared in
 its manifest file. Where permissions apply they are noted in the
 the methods through which you access the protected information.",,phone metadata,phone,1,yes,no,SOURCE,no,
"<android.os.ResultReceiver: void send(int,Bundle)>","Deliver a result to this receiver.  Will call onReceiveResult(int Bundle) always asynchronously if the receiver has supplied a Handler in which
 to dispatch the result.","resultCode int : Arbitrary result code to deliver as defined by you. |||
resultData Bundle : Any additional data provided by you. |||",void,3,"Generic interface for receiving a callback result from someone.  Use this
 by creating a subclass and implement  onReceiveResult(int Bundle)  which you can
 then pass to others and send through IPC and receive results they
 supply with  send(int Bundle) .

  Note: the implementation underneath is just a simple wrapper around
 a  Binder  that is used to perform the communication.  This means
 semantically you should treat it as such: this class does not impact process
 lifecycle management (you must be using some higher-level component to tell
 the system that your process needs to continue running) the connection will
 break if your process goes away for any reason etc.",,IPC,IPC,1,no,yes,no,SINK,
<android.app.LocalActivityManager: void removeAllActivities()>,Remove all activities from this LocalActivityManager performing an Activity#onDestroy on any that are currently instantiated.,,void,1,"Helper class for managing multiple running embedded activities in the same
 process. This class is not normally used directly but rather created for
 you as part of the  ActivityGroup  implementation.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
<android.app.Dialog: void openOptionsMenu()>,,,void,1,"Base class for Dialogs.

  Note: Activities provide a facility to manage the creation saving and
 restoring of dialogs. See  Activity#onCreateDialog(int) 
  Activity#onPrepareDialog(int Dialog) 
  Activity#showDialog(int)  and  Activity#dismissDialog(int) . If
 these methods are used  getOwnerActivity()  will return the Activity
 that managed this dialog.

  Often you will want to have a Dialog display on top of the current
 input method because there is no reason for it to accept text.  You can
 do this by setting the  WindowManager.LayoutParams#FLAG_ALT_FOCUSABLE_IM  window flag (assuming
 your Dialog takes input focus as it the default) with the following code:

  
 getWindow().setFlags(WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM
         WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
"<android.content.ContentResolver: int delete(Uri,String,String)>","Deletes row(s) specified by a content URI.

 If the content provider supports transactions the deletion will be atomic.","url Uri : The URL of the row to delete.
This value must never be null . |||
where String : A filter to apply to rows before deleting formatted as an SQL WHERE clause
(excluding the WHERE itself).
This value may be null . |||
selectionArgs String : This value may be null . |||",int The number of rows deleted. |||,1,This class provides applications access to the content model.,"Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,
<android.widget.PopupMenu: void inflate(int)>,"Inflate a menu resource into this PopupMenu. This is equivalent to
 calling popupMenu.getMenuInflater().inflate(menuRes popupMenu.getMenu()) .",menuRes int : Menu resource to inflate |||,void,14,"A PopupMenu displays a  Menu  in a modal popup window anchored to a
  View . The popup will appear below the anchor view if there is room
 or above it if there is not. If the IME is visible the popup will not
 overlap it until it is touched. Touching outside of the popup will dismiss
 it.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,no,0,no,no,no,no,
"<android.widget.AbsListView: void smoothScrollToPositionFromTop(int,int)>","Smoothly scroll to the specified adapter position. The view will scroll
 such that the indicated position is displayed offset pixels below
 the top edge of the view. If this is impossible (e.g. the offset would scroll
 the first or last item beyond the boundaries of the list) it will get as close
 as possible.","position int : Position to scroll to |||
offset int : Desired distance in pixels of position from the top
of the view when scrolling is finished |||",void,11,"Base class that can be used to implement virtualized lists of items. A list does
 not have a spatial definition here. For instance subclasses of this class can
 display the content of the list in a grid in a carousel as stack etc.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,no,0,no,no,no,no,
<android.app.Activity: void startActivity(Intent)>,"Same as startActivity(android.content.Intent android.os.Bundle) with no options
 specified.",intent Intent : The intent to start. |||,void,1,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",IPC,IPC,1,no,yes,no,SINK,
<android.widget.AdapterViewAnimator: void advance()>,"Called by an AppWidgetHost in order to advance the current view when
 it is being used within an app widget.",,void,11,"An AdapterView is a view whose children are determined by an  Adapter .

  
 See  ListView   GridView   Spinner  and
       Gallery  for commonly used subclasses of AdapterView.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",no,no,0,no,no,no,no,
"<android.content.Intent: Intent putExtra(String,float)>","Add extended data to the intent.  The name must include a package
 prefix for example the app com.android.contacts would use names
 like ""com.android.contacts.ShowAll"".","name String : The name of the extra data with package prefix. |||
value float : The float array data value.
This value may be null . |||","Intent Returns the same Intent object for chaining multiple calls
 into a single statement.

 This value will never be null . |||",1,"An intent is an abstract description of an operation to be performed.  It
 can be used with  Context#startActivity(Intent)  to
 launch an  Activity 
  broadcastIntent  to
 send it to any interested  BroadcastReceiver  components
 and  Context.startService(Intent)  or
  Context.bindService(Intent ServiceConnection int)  to communicate with a
 background  Service .

  An Intent provides a facility for performing late runtime binding between the code in
 different applications. Its most significant use is in the launching of activities where it
 can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,
<android.app.admin.DevicePolicyManager: int getPasswordMinimumNumeric(ComponentName)>,"Retrieve the current number of numerical digits required in the password
 for a particular admin or all admins that set restrictions on this user
 and its participating profiles. Restrictions on profiles that have
 a separate challenge are not taken into account.
 This is the same value as set by setPasswordMinimumNumeric(android.content.ComponentName int) and only applies when the password quality is PASSWORD_QUALITY_COMPLEX . On devices not supporting PackageManager#FEATURE_SECURE_LOCK_SCREEN feature the
 password is always treated as empty. This method can be called on the DevicePolicyManager instance
 returned by getParentProfileInstance(android.content.ComponentName) in order to retrieve
 restrictions on the parent profile.","admin ComponentName : The name of the admin component to check or null to
aggregate all admins.
This value may be null . |||",int The minimum number of numerical digits required in the password. |||,11,"Public interface for managing policies enforced on a device. Most clients of this class must be
 registered with the system as a  device
 administrator . Additionally a device administrator may be registered as either a profile or
 device owner. A given method is accessible to all device administrators unless the documentation
 for that method specifies that it is restricted to either device or profile owners. Any
 application calling an api may only pass as an argument a device administrator component it
 owns. Otherwise a  SecurityException  will be thrown.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",password metadata,password file ,1,yes,no,SOURCE,no,
<android.bluetooth.BluetoothDevice: int getBondState()>,Get the bond state of the remote device. Possible values for the bond state are: BOND_NONE  BOND_BONDING  BOND_BONDED . Requires Manifest.permission.BLUETOOTH,,int the bond state |||,5,"Represents a remote Bluetooth device. A  BluetoothDevice  lets you
 create a connection with the respective device or query information about
 it such as the name address class and bonding state.

  This class is really just a thin wrapper for a Bluetooth hardware
 address. Objects of this class are immutable. Operations on this class
 are performed on the remote Bluetooth hardware address using the
  BluetoothAdapter  that was used to create this  BluetoothDevice .

  To get a  BluetoothDevice  use
  BluetoothAdapter#getRemoteDevice(String)  to create one representing a device
 of a known MAC address (which you can get through device discovery with
  BluetoothAdapter ) or get one from the set of bonded devices
 returned by  BluetoothAdapter#getBondedDevices() . You can then open a
  BluetoothSocket  for communication with the remote device using
  createRfcommSocketToServiceRecord(java.util.UUID)  over Bluetooth BR/EDR or using
  createL2capChannel(int)  over Bluetooth LE.

  Note: 
 Requires the  Manifest.permission.BLUETOOTH  permission.","Provides classes that manage Bluetooth functionality such as scanning for
 devices connecting with devices and managing data transfer between devices.
 The Bluetooth API supports both ""Classic Bluetooth"" and Bluetooth Low Energy. For more information about Classic Bluetooth see the
  Bluetooth  guide.
 For more information about Bluetooth Low Energy see the
  
 Bluetooth Low Energy  (BLE) guide. The Bluetooth APIs let applications: Scan for other Bluetooth devices (including BLE devices). Query the local Bluetooth adapter for paired Bluetooth devices. Establish RFCOMM channels/sockets. Connect to specified sockets on other devices. Transfer data to and from other devices. Communicate with BLE devices such as proximity sensors heart rate
     monitors fitness devices and so on. Act as a GATT client or a GATT server (BLE). 
 To perform Bluetooth communication using these APIs an application must
 declare the  BLUETOOTH  permission. Some
 additional functionality such as requesting device discovery
 also requires the  BLUETOOTH_ADMIN 
 permission.
  Note: 
 Not all Android-powered devices provide Bluetooth functionality.",bluetooth metadata,bluetooth,1,yes,no,SOURCE,no,
<android.widget.AdapterView: void setEmptyView(View)>,Sets the view to show if the adapter is empty,emptyView View |||,void,1,"An AdapterView is a view whose children are determined by an  Adapter .

  
 See  ListView   GridView   Spinner  and
       Gallery  for commonly used subclasses of AdapterView.","The widget package contains (mostly visual) UI elements to use
 on your Application screen. You can also design your own.
  
 To create your own widget extend  View  or a subclass. To
 use your widget in layout XML there are two additional files for you to
 create. Here is a list of files you'll need to create to implement a custom
 widget:
  Java implementation file  - This is the file that implements the
 behavior of the widget. If you can instantiate the object from layout XML
 you will also have to code a constructor that retrieves all the attribute
 values from the layout XML file. XML definition file  - An XML file in res/values/ that defines
 the XML element used to instantiate your widget and the attributes that it
 supports. Other applications will use this element and attributes in their in
 another in their layout XML. Layout XML  [ optional ]- An optional XML file inside
 res/layout/ that describes the layout of your widget. You could also do
 this in code in your Java file. 
 ApiDemos sample application has an example of creating a custom layout XML
 tag LabelView. See the following files that demonstrate implementing and using
 a custom widget:
  LabelView.java  - The implementation file res/values/attrs.xml  - Definition file res/layout/custom_view_1.xml  - Layout file",uncategorized,UI,1,no,yes,no,SINK,
"<android.database.sqlite.SQLiteDatabase: Cursor rawQuery(String,String,CancellationSignal)>",Runs the provided SQL and returns a Cursor over the result set.,"sql String : the SQL query. The SQL string must not be ; terminated |||
selectionArgs String : You may include ?s in where clause in the query
which will be replaced by the values from selectionArgs. The
values will be bound as Strings. |||
cancellationSignal CancellationSignal : A signal to cancel the operation in progress or null if none.
If the operation is canceled then OperationCanceledException will be thrown
when the query is executed. |||",Cursor A Cursor object which is positioned before the first entry. Note that Cursor s are not synchronized see the documentation for more details. |||,16,"Exposes methods to manage a SQLite database.

  
 SQLiteDatabase has methods to create delete execute SQL commands and
 perform other common database management tasks.
  
 See the Notepad sample application in the SDK for an example of creating
 and managing a database.
  
 Database names must be unique within an application not across all applications.
  Localized Collation - ORDER BY 
 In addition to SQLite's default  BINARY  collator Android supplies
 two more  LOCALIZED  which changes with the system's current locale
 and  UNICODE  which is the Unicode Collation Algorithm and not tailored
 to the current locale.","If you need to manage data in a private database use the  android.database.sqlite  classes. These classes are used to manage the  Cursor  object returned from a content provider query. Databases
 are usually created and opened with  openOrCreateDatabase(String int SQLiteDatabase.CursorFactory) 
 To make requests through
 content providers you can use the  content.ContentResolver  class.
  All databases are stored on the device in  /data/data/<package_name>/databases",database data,database,1,yes,no,SOURCE,no,
<android.preference.DialogPreference: void setDialogMessage(int)>,,dialogMessageResId int : The dialog message as a resource. |||,void,1,"A base class for  Preference  objects that are
 dialog-based. These preferences will when clicked open a dialog showing the
 actual preference controls.",,no,no,0,no,no,no,no,
<android.preference.TwoStatePreference: void setSummaryOn(int)>,,summaryResId int : The summary as a resource. |||,void,14,"Common base class for preferences that have two selectable states persist a
 boolean value in SharedPreferences and may have dependent preferences that are
 enabled/disabled based on the current state.",,no,no,0,no,no,no,no,
<android.content.Loader: void deliverCancellation()>,"Informs the registered OnLoadCanceledListener that the load has been canceled.
 Should only be called by subclasses.

 Must be called from the process's main thread.",,void,16,"A class that performs asynchronous loading of data. While Loaders are active
 they should monitor the source of their data and deliver new results when the contents
 change.  See  LoaderManager  for more detail.

  Note on threading:  Clients of loaders should as a rule perform
 any calls on to a Loader from the main thread of their process (that is
 the thread the Activity callbacks and other things occur on).  Subclasses
 of Loader (such as  AsyncTaskLoader ) will often perform their work
 in a separate thread but when delivering their results this too should
 be done on the main thread. Subclasses generally must implement at least  onStartLoading() 
  onStopLoading()   onForceLoad()  and  onReset() . Most implementations should not derive directly from this class but
 instead inherit from  AsyncTaskLoader .","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,
<android.app.FragmentBreadCrumbs: void onBackStackChanged()>,Called whenever the contents of the back stack change.,,void,11,"A Fragment is a piece of an application's user interface or behavior
 that can be placed in an  Activity .  Interaction with fragments
 is done through  FragmentManager  which can be obtained via
  Activity#getFragmentManager()  and
  Fragment#getFragmentManager() .

  The Fragment class can be used many ways to achieve a wide variety of
 results. In its core it represents a particular operation or interface
 that is running within a larger  Activity .  A Fragment is closely
 tied to the Activity it is in and can not be used apart from one.  Though
 Fragment defines its own lifecycle that lifecycle is dependent on its
 activity: if the activity is stopped no fragments inside of it can be
 started; when the activity is destroyed all fragments will be destroyed.

  All subclasses of Fragment must include a public no-argument constructor.
 The framework will often re-instantiate a fragment class when needed
 in particular during state restore and needs to be able to find this
 constructor to instantiate it.  If the no-argument constructor is not
 available a runtime exception will occur in some cases during state
 restore.

  Topics covered here:
  Older Platforms Lifecycle Layout Back Stack","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
"<android.content.ContentProviderClient: ParcelFileDescriptor openFile(Uri,String)>","See ContentProvider#openFile .  Note that
 this does not take care of non-content: URIs such as file:.  It is strongly recommended
 you use the ContentResolver#openFileDescriptor API instead.","url Uri : This value must never be null . |||
mode String : This value must never be null . |||",ParcelFileDescriptor This value may be null . |||,5,"Content providers are one of the primary building blocks of Android applications providing
 content to applications. They encapsulate data and provide it to applications through the single
  ContentResolver  interface. A content provider is only required if you need to share
 data between multiple applications. For example the contacts data is used by multiple
 applications and must be stored in a content provider. If you don't need to share data amongst
 multiple applications you can use a database directly via
  SQLiteDatabase .

  When a request is made via
 a  ContentResolver  the system inspects the authority of the given URI and passes the
 request to the content provider registered with the authority. The content provider can interpret
 the rest of the URI however it wants. The  UriMatcher  class is helpful for parsing
 URIs. The primary methods that need to be implemented are:
  onCreate()  which is called to initialize the provider query(Uri String[] Bundle CancellationSignal)  which returns data to the caller insert(Uri ContentValues)  which inserts new data into the content provider update(Uri ContentValues String String[])  which updates existing data in the content provider delete(Uri String String[])  which deletes data from the content provider getType(Uri)  which returns the MIME type of data in the content provider Requests to  ContentResolver  are automatically forwarded to the appropriate
 ContentProvider instance so subclasses don't have to worry about the details of
 cross-process calls.","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",file data,file ,1,yes,no,SOURCE,no,
<android.bluetooth.BluetoothAdapter: Set getBondedDevices()>,"Return the set of BluetoothDevice objects that are bonded
 (paired) to the local adapter. If Bluetooth state is not STATE_ON this API
 will return an empty set. After turning on Bluetooth
 wait for ACTION_STATE_CHANGED with STATE_ON to get the updated value. Requires Manifest.permission.BLUETOOTH",,Set < BluetoothDevice > unmodifiable set of BluetoothDevice or null on error |||,5,"Represents the local device Bluetooth adapter. The  BluetoothAdapter 
 lets you perform fundamental Bluetooth tasks such as initiate
 device discovery query a list of bonded (paired) devices
 instantiate a  BluetoothDevice  using a known MAC address and create
 a  BluetoothServerSocket  to listen for connection requests from other
 devices and start a scan for Bluetooth LE devices.

  To get a  BluetoothAdapter  representing the local Bluetooth
 adapter call the  BluetoothManager#getAdapter  function on  BluetoothManager .
 On JELLY_BEAN_MR1 and below you will need to use the static  getDefaultAdapter() 
 method instead.
  
 Fundamentally this is your starting point for all
 Bluetooth actions. Once you have the local adapter you can get a set of
  BluetoothDevice  objects representing all paired devices with
  getBondedDevices() ; start device discovery with
  startDiscovery() ; or create a  BluetoothServerSocket  to
 listen for incoming RFComm connection requests with  listenUsingRfcommWithServiceRecord(java.lang.String java.util.UUID) ; listen for incoming L2CAP Connection-oriented
 Channels (CoC) connection requests with  listenUsingL2capChannel() ; or start a scan for
 Bluetooth LE devices with  startLeScan(android.bluetooth.BluetoothAdapter.LeScanCallback) .
  This class is thread safe. Note: 
 Most methods require the  Manifest.permission.BLUETOOTH 
 permission and some also require the
  Manifest.permission.BLUETOOTH_ADMIN  permission.","Provides classes that manage Bluetooth functionality such as scanning for
 devices connecting with devices and managing data transfer between devices.
 The Bluetooth API supports both ""Classic Bluetooth"" and Bluetooth Low Energy. For more information about Classic Bluetooth see the
  Bluetooth  guide.
 For more information about Bluetooth Low Energy see the
  
 Bluetooth Low Energy  (BLE) guide. The Bluetooth APIs let applications: Scan for other Bluetooth devices (including BLE devices). Query the local Bluetooth adapter for paired Bluetooth devices. Establish RFCOMM channels/sockets. Connect to specified sockets on other devices. Transfer data to and from other devices. Communicate with BLE devices such as proximity sensors heart rate
     monitors fitness devices and so on. Act as a GATT client or a GATT server (BLE). 
 To perform Bluetooth communication using these APIs an application must
 declare the  BLUETOOTH  permission. Some
 additional functionality such as requesting device discovery
 also requires the  BLUETOOTH_ADMIN 
 permission.
  Note: 
 Not all Android-powered devices provide Bluetooth functionality.",bluetooth metadata,bluetooth,1,yes,no,SOURCE,no,
<android.preference.PreferenceFragment: void onStop()>,"Called when the Fragment is no longer started.  This is generally
 tied to Activity#onStop() of the containing
 Activity's lifecycle. If you override this method you must call through to the
 superclass implementation.",,void,11,"Represents the basic Preference UI building
 block displayed by a  PreferenceActivity  in the form of a
  ListView . This class provides the  View  to be displayed in
 the activity and associates with a  SharedPreferences  to
 store/retrieve the preference data.
  
 When specifying a preference hierarchy in XML each element can point to a
 subclass of  Preference  similar to the view hierarchy and layouts.
  
 This class contains a  key  that will be used as the key into the
  SharedPreferences . It is up to the subclass to decide how to store
 the value.",,no,no,0,no,no,no,no,
<android.content.ContentResolver: OutputStream openOutputStream(Uri)>,"Synonym for openOutputStream(uri ""w"") .",uri Uri : This value must never be null . |||,OutputStream This value may be null . |||,1,This class provides applications access to the content model.,"Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",uncategorized,file ,1,no,yes,no,SINK,
<android.app.IntentService: void onCreate()>,Called by the system when the service is first created.  Do not call this method directly.,,void,3,"IntentService is a base class for  Service s that handle asynchronous
 requests (expressed as  Intent s) on demand.  Clients send requests
 through  Context.startService(Intent)  calls; the
 service is started as needed handles each Intent in turn using a worker
 thread and stops itself when it runs out of work.

  This ""work queue processor"" pattern is commonly used to offload tasks
 from an application's main thread.  The IntentService class exists to
 simplify this pattern and take care of the mechanics.  To use it extend
 IntentService and implement  onHandleIntent(android.content.Intent) .  IntentService
 will receive the Intents launch a worker thread and stop the service as
 appropriate.

  All requests are handled on a single worker thread -- they may take as
 long as necessary (and will not block the application's main loop) but
 only one request will be processed at a time.

  Note:  IntentService is subject to all the
  background execution limits 
 imposed with Android 8.0 (API level 26). In most cases you are better off
 using  JobIntentService  which uses jobs
 instead of services when running on Android 8.0 or higher.","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
"<android.content.SearchRecentSuggestionsProvider: int delete(Uri,String,String)>","This method is provided for use by the ContentResolver.  Do not override or directly
 call from your own code.","uri Uri : The full URI to query including a row ID (if a specific
record is requested).
This value must never be null . |||
selection String : An optional restriction to apply to rows when deleting.
This value may be null . |||
selectionArgs String : This value may be null . |||",int The number of rows affected. |||,1,"This superclass can be used to create a simple search suggestions provider for your application.
 It creates suggestions (as the user types) based on recent queries and/or recent views.

  In order to use this class you must do the following.

  Implement and test query search as described in  SearchManager .  (This
 provider will send any suggested queries via the standard
  ACTION_SEARCH  Intent which you'll already
 support once you have implemented and tested basic searchability.) Create a Content Provider within your application by extending
  SearchRecentSuggestionsProvider .  The class you create will be
 very simple - typically it will have only a constructor.  But the constructor has a very
 important responsibility:  When it calls  setupSuggestions(java.lang.String int)  it
  configures  the provider to match the requirements of your searchable activity. Create a manifest entry describing your provider.  Typically this would be as simple
 as adding the following lines:
  
     <!-- Content provider for search suggestions -->
     <provider android:name=""YourSuggestionProviderClass""
               android:authorities=""your.suggestion.authority"" /> Please note that you  do not  instantiate this content provider directly from within
 your code.  This is done automatically by the system Content Resolver when the search dialog
 looks for suggestions. In order for the Content Resolver to do this you must update your searchable activity's
 XML configuration file with information about your content provider.  The following additions
 are usually sufficient:
  
     android:searchSuggestAuthority=""your.suggestion.authority""
     android:searchSuggestSelection="" ? "" In your searchable activities capture any user-generated queries and record them
 for future searches by calling  SearchRecentSuggestions.saveRecentQuery() .","Contains classes for accessing and publishing data on a device.  It includes three main
 categories of APIs: Content sharing ( android.content ) For sharing content between application components. The most important classes are:
      ContentProvider  and  ContentResolver 
   for managing and publishing persistent data associated with an application. Intent  and  IntentFilter  for delivering
   structured messages between different application components—allowing components to initiate
   other components and return results. Package management ( android.content.pm ) For accessing information about an Android package (an  .apk ) including information
 about its activities permissions services signatures and providers. The most important class for
 accessing this information is  PackageManager . Resource management ( android.content.res ) For retrieving resource data associated with an application such as strings drawables
 media and device configuration details. The most important class for accessing this data is  Resources .",no,no,0,no,no,no,no,
<android.app.Activity: ComponentName getCallingActivity()>,"Return the name of the activity that invoked this activity.  This is
 who the data in setResult() will be sent to.  You
 can use this information to validate that the recipient is allowed to
 receive the data. Note: if the calling activity is not expecting a result (that is it
 did not use the startActivityForResult(Intent int) form that includes a request code) then the calling package will be
 null.",,"ComponentName The ComponentName of the activity that will receive your
         reply or null if none. |||",1,"An activity is a single focused thing that the user can do.  Almost all
 activities interact with the user so the Activity class takes care of
 creating a window for you in which you can place your UI with
  setContentView(View) .  While activities are often presented to the user
 as full-screen windows they can also be used in other ways: as floating
 windows (via a theme with  R.attr.windowIsFloating  set)
  
 Multi-Window mode  or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

  onCreate(Bundle)  is where you initialize your activity.  Most
     importantly here you will usually call  setContentView(int) 
     with a layout resource defining your UI and using  findViewById(int) 
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

      onPause()  is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
      ContentProvider  holding the data). In this
     state the activity is still visible on screen.
  To be of use with  Context.startActivity()  all
 activity classes must have a corresponding
  <activity> 
 declaration in their package's  AndroidManifest.xml . Topics covered here:
  Fragments Activity Lifecycle Configuration Changes Starting Activities and Getting Results Saving Persistent State Permissions Process Lifecycle","Contains high-level classes encapsulating the overall Android application model. An Android application is defined using one or more of Android's four core application
 components. Two such application components are defined in this package:  Activity  and  Service . The other two components are from the  android.content  package:  BroadcastReceiver  and  ContentProvider . An  Activity  is an application component that provides a screen with which
 users can interact in order to do something such as dial the phone take a photo send an email or
 view a map. An activity can start other activities including activities that live in separate
 applications. A  Service  is an application component that can perform
 long-running operations in the background without a user interface. For example a service
 can handle network transactions play music or work with a content provider without the user being
 aware of the work going on. The  Fragment  class is also an important part of an application's
 design—especially when designing for large screen devices such as tablets. A fragment defines
 a distinct part of an activity's behavior including the associated UI. It has its own lifecycle
 that is similar to that of the activity and can exist alongside other fragments that are embedded in
 the activity. While an activity is running you can add and remove fragments and include each
 fragment in a back stack that's managed by the activity—allowing the user to navigate
 backwards through the fragment states without leaving the activity. This package also defines application utilities such as dialogs notifications and the
 action bar. For information about using some the classes in this package see the following
 documents:  Activities   Services   Fragments   Using the Action Bar   Creating Dialogs  and  Notifying the User .",no,no,0,no,no,no,no,
